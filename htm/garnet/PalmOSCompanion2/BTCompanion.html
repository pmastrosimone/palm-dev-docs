<html>
<head>
<title>(68K) Bluetooth | Palm OS&#174; Programmer's Companion</title> 
<link href="psi_devpubs.css" rel="stylesheet" type="text/css">

<!-- BEGIN META DATA -->
<meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
<META NAME="PSITEMPLATE" CONTENT="1006-007 PalmSource_HTML_2003 20041101">
<META NAME="GENERATOR" CONTENT="Quadralay WebWorks AutoMap 2003 for FrameMaker 8.0.6.2138">
<META NAME="LASTUPDATED" CONTENT="11/22/04 10:43:45">
<!-- END META DATA -->
</head>

<body bgcolor="#ffffff" text="#000000" leftmargin="0" topmargin="0" marginwidth="0" marginheight="0">
<a name="1017445"></a>

<!-- BEGIN TOPNAV -->
<table width="100%" border="0" cellspacing="0" cellpadding="0">
<tr>
<td><img src="images/shim.gif" width="7" height="75" border="0" alt=""></td>
<td align="left"><table border="0" cellpadding="0" cellspacing="0" width="744">
<tr>
<td><img name="index_r2_c1" src="images/shim.gif" width="25" height="75" border="0" alt=""></td>
<td valign="top"><table border="0" cellpadding="0" cellspacing="0" width="96">
<tr>
<td><img name="index_r2_c4" src="images/shim.gif" width="96" height="15" border="0" alt=""></td>
</tr>
<tr>
<td><a href="http://www.palmsource.com/"><img name="ps_logo" src="images/ps_logo.gif" width="96" height="54" border="0" alt=""></a></td>
</tr>

</table>
</td>

<td><table border="0" cellpadding="0" cellspacing="0" width="30">
<td><img name="index_x" src="images/shim.gif" width="30" height="75" border="0" alt=""></td>
</table></td>

<!--BEGIN MASTHEAD-->
<td><table border="0" cellpadding="0" cellspacing="0" width="96">
<tr>
<td><img name="index_x" src="images/shim.gif" width="615" height="5" border="0" alt=""></td>
</tr>
<tr>
<td>
<!--BEGIN BOOK NAVIGATION-->
<span class="nav">
<A href="http://www.palmos.com/dev/support/docs/">Documentation</a>&nbsp;&nbsp;|&nbsp;&nbsp;
<a href="Companion2TOC.html">Table of Contents</a>&nbsp;&nbsp;
             |&nbsp;&nbsp;<a href="SerialCommunication.html">&lt;&nbsp;Previous</a>&nbsp;&nbsp;
             |&nbsp;&nbsp;<a href="NetworkCommunication.html">Next&nbsp;&gt;</a>&nbsp;&nbsp;
             |&nbsp;&nbsp;<a href="Companion2IX.html">Index</a>
</span>
<!--END BOOK NAVIGATION-->
</tr>
<tr>
<td>
<!--BEGIN PAGE TITLE-->
<h2 class="PageTitle">6 &nbsp;&nbsp;
Bluetooth</h2></td>
<!--END PAGE TITLE-->
</tr>
<tr>
<td>
<!--BEGIN BOOK TITLE-->
<p class="BookTitle">Palm OS&#174; Programmer's Companion</p>
<p class="SubTitle">Volume II Communications </p>
<!--END BOOK TITLE-->
</td>
</tr>
<tr>
<td><img name="index_x" src="images/shim.gif" width="615" height="5" border="0" alt=""></td>
</tr>
</table>
</td>
<!--END MASTHEAD-->
</tr>
</table>
<img name="dashes" src="images/dashes.gif" width="744" height="3" border="0" alt=""></td>
</tr>
</table>
<!-- END TOPNAV -->

<table width="100%" border="0" cellspacing="0" cellpadding="0">
<tr>
<td valign="top" width="5"><img name="index_x" src="images/shim.gif" width="5" height="33" border="0" alt=""></td>

<!--BEGIN SIDETOC-->
<td valign="top" width="175">
<div id="sidetoc" valign="bottom">
<h1 class="SideTOC1"><a href="BTCompanion.html">6  Bluetooth</a></h1>

   <h2 class="SideTOC2"><a href="#1017453">
   Palm OS Bluetooth System</a></h2>

      <h3 class="SideTOC3"><a href="#1017462">
      Bluetooth System Components</a></h3>

      <h3 class="SideTOC3"><a href="#1017533">
      Implementation Overview</a></h3>

      <h3 class="SideTOC3"><a href="#1017537">
      Profiles</a></h3>

      <h3 class="SideTOC3"><a href="#1017601">
      Usage Scenarios</a></h3>

      <h3 class="SideTOC3"><a href="#1017807">
      Authentication and Encryption</a></h3>

      <h3 class="SideTOC3"><a href="#1017812">
      Device Discovery</a></h3>

      <h3 class="SideTOC3"><a href="#1017815">
      Piconet Support</a></h3>

      <h3 class="SideTOC3"><a href="#1017825">
      Radio Power Management</a></h3>

   <h2 class="SideTOC2"><a href="#1017830">
   Developing Bluetooth-Enabled Applications</a></h2>

      <h3 class="SideTOC3"><a href="#1017855">
      Overview of the Bluetooth Library</a></h3>

      <h3 class="SideTOC3"><a href="#1017862">
      Management</a></h3>

      <h3 class="SideTOC3"><a href="#1018038">
      Sockets</a></h3>

   <h2 class="SideTOC2"><a href="#1018212">
   Bluetooth Virtual Serial Driver</a></h2>

      <h3 class="SideTOC3"><a href="#1018227">
      Opening the Serial Port</a></h3>

      <h3 class="SideTOC3"><a href="#1018320">
      Palm-to-Palm Communication</a></h3>

      <h3 class="SideTOC3"><a href="#1018323">
      How Palm OS Uses the Bluetooth Virtual Serial Driver</a></h3>

   <h2 class="SideTOC2"><a href="#1018328">
   Bluetooth Exchange Library Support</a></h2>

      <h3 class="SideTOC3"><a href="#1018333">
      Detecting the Bluetooth Exchange Library</a></h3>

      <h3 class="SideTOC3"><a href="#1018338">
      Using the Exchange Manager With Bluetooth</a></h3>

      <h3 class="SideTOC3"><a href="#1018380">
      ExgGet and ExgRequest</a></h3>

</div>
</td>

<td width="5">&nbsp;&nbsp;</td>
<td width="2" background="images/index_r8_c10.gif"><img src="images/shim.gif" width="2" height="75" border="0" alt=""></td>
<td width="5">&nbsp;&nbsp;</td>

<!--END SIDETOC-->

<td valign="top">

<!--BEGIN CONTENT-->
<div id="content" valign="bottom">
<p><a name="1017446"> </a>The Bluetooth APIs provide developers a way to access the Palm OS Bluetooth system and write Bluetooth-enabled applications. In addition to enabling Bluetooth development, the Palm OS Bluetooth system also provides:</p>
<ul type="disc">
  <li><a name="1017447"> </a>a user interface for device discovery and connection
  <li><a name="1017448"> </a>a user interface for passkey entry
  <li><a name="1017449"> </a>a modified Palm Connection Panel to support Bluetooth
  <li><a name="1017450"> </a>serial port emulation using the Bluetooth Virtual Serial Driver
  <li><a name="1017451"> </a>object exchange support using the Bluetooth Exchange Library
</ul>

<p><a name="1017452"> </a>This documentation covers how to use the Palm OS Bluetooth APIs but does not provide the basic understanding of Bluetooth concepts and protocols that you need to write Bluetooth code. For more information about Bluetooth, refer to the <i>Specification of the Bluetooth System</i>, available at the Bluetooth Special Interest Group website at <code>www.bluetooth.com</code>. There are also several third-party books that you may wish to consult for helpful Bluetooth information.</p>

<h2 class="haH2">
  <a name="1017453"> </a>Palm OS Bluetooth System <a href="#1017445"><span class="nav">^TOP^</span></a>
</h2>


<p><a name="1017454"> </a>The Palm OS Bluetooth system enables a Palm Powered handheld to:</p>
<ul type="disc">
  <li><a name="1017455"> </a>access the internet through LAN access points and cell phones
  <li><a name="1017456"> </a>exchange objects such as business cards and appointments over Bluetooth
  <li><a name="1017457"> </a>perform HotSync operations over Bluetooth
  <li><a name="1017458"> </a>communicate with other handhelds for multi-user applications like games and various collaborative applications
  <li><a name="1017459"> </a>send SMS messages and manage your phone's internal phone book.
</ul>

<p><a name="1017460"> </a>The Palm OS Bluetooth system designers focused their efforts on the user, recognizing that on the Palm OS technical interoperability is simply not enough. The user cares about the overall experience. The user's "Bluetooth learning curve" should be short. And, as always, simplicity is key.</p>
<h3 class="hbH3">
  <a name="1017462"> </a>Bluetooth System Components <a href="#1017445"><span class="nav">^TOP^</span></a>
</h3>


<p><a name="1017463"> </a>The Palm OS Bluetooth system contains the following components:</p>
<ul type="disc">
  <li><a name="1017467"> </a><a href="BTCompanion.html#1017500">Bluetooth Library</a>
  <li><a name="1017471"> </a><a href="BTCompanion.html#1017509">Bluetooth Virtual Serial Driver</a>
  <li><a name="1017475"> </a><a href="BTCompanion.html#1017516">Bluetooth Exchange Library</a>
  <li><a name="1017479"> </a><a href="BTCompanion.html#1017523">Bluetooth Stack</a>
  <li><a name="1017483"> </a><a href="BTCompanion.html#1017527">Bluetooth Transports</a>
  <li><a name="1017487"> </a><a href="BTCompanion.html#1017531">Bluetooth Extension</a>
</ul>

<p><a name="1017491"> </a><a href="BTCompanion.html#1017493">Figure 6.1</a> shows these components and their relationship with each other.</p>

<p class="FFigureCaption">
  <a name="1017493"> </a><b>Figure 6.1&nbsp;&nbsp;Overall Palm OS Bluetooth architecture</b>
</p>
<div align="left"><img src="images/BluetoothStack.gif" border="0" hspace="0" vspace="0">
</div>

<h4 class="hcH4">
  <a name="1017500"> </a>Bluetooth Library
</h4>

<p><a name="1017501"> </a>The Bluetooth Library is a shared library that provides an API for developers to develop Bluetooth applications. The API provides functions in the following areas:</p>
<ul type="disc">
  <li><a name="1017502"> </a>Managing remote devices, piconets, and ACL links
  <li><a name="1017503"> </a>Communicating using the L2CAP and RFCOMM protocols
  <li><a name="1017504"> </a>Advertising services and querying for remote services using SDP
  <li><a name="1017505"> </a>Maintaining a list of trusted devices
</ul>

<h4 class="hcH4">
  <a name="1017509"> </a>Bluetooth Virtual Serial Driver
</h4>

<p><a name="1017510"> </a>The Bluetooth Virtual Serial Driver allows applications to use the Palm OS New Serial Manager with Bluetooth's RFCOMM protocol as the serial link. As shown in <a href="BTCompanion.html#1017493">Figure 6.1</a>, the Bluetooth Serial Driver communicates with the rest of the Bluetooth system through the Bluetooth Library. The Bluetooth Virtual Serial Driver is used by PPP, HotSync, and Telephony.</p>

<h4 class="hcH4">
  <a name="1017516"> </a>Bluetooth Exchange Library
</h4>

<p><a name="1017517"> </a>The Bluetooth Exchange Library allows applications to use the Palm OS Exchange Manager with Bluetooth as the link. As shown in <a href="BTCompanion.html#1017493">Figure 6.1</a>, the Bluetooth Exchange Library communicates with the rest of the Bluetooth system through the Bluetooth Library. RFCOMM is used as the sole transport mechanism for the Exchange Manager.</p>

<h4 class="hcH4">
  <a name="1017523"> </a>Bluetooth Stack
</h4>

<p><a name="1017524"> </a>The Bluetooth Stack is a shared library that implements the various protocols of the Bluetooth specification. Palm OS developers don't need to access the Bluetooth Stack directly.</p>

<h4 class="hcH4">
  <a name="1017527"> </a>Bluetooth Transports
</h4>

<p><a name="1017528"> </a>Bluetooth Transports are shared libraries that act as device drivers for different radios. Palm OS developers cannot access the Bluetooth Transports.</p>

<h4 class="hcH4">
  <a name="1017531"> </a>Bluetooth Extension
</h4>

<p><a name="1017532"> </a>The Bluetooth extension oversees and coordinates the multiple libraries of the Bluetooth system. Palm OS developers cannot access the Bluetooth extension.</p>
<h3 class="hbH3">
  <a name="1017533"> </a>Implementation Overview <a href="#1017445"><span class="nav">^TOP^</span></a>
</h3>


<p><a name="1017534"> </a>The Bluetooth system is a collection of PRCs that can reside in either RAM or ROM. A minimum of 4Mb of RAM is required (256k heap). Incorporation into actual devices is up to the handheld manufacturers.</p>

<p><a name="1017535"> </a>The Bluetooth system runs in the UI thread, except when it is used by the virtual serial driver.</p>
<h3 class="hbH3">
  <a name="1017537"> </a>Profiles <a href="#1017445"><span class="nav">^TOP^</span></a>
</h3>


<p><a name="1017541"> </a><a href="BTCompanion.html#1017548">Table 6.1</a> lists the profiles supported by the Palm OS Bluetooth system.</p>

<p class="caption"><a name="1017548"> </a><b>Table 6.1&nbsp;&nbsp;Supported Bluetooth profiles </b></p>
<div class="tablediv"><table cellspacing="0" class="tTable">

  <tr valign="top">
    <th><p class="tt"><a name="1017552"> </a><b>Profile</b></p>
    </th>
    <th><p class="tt"><a name="1017554"> </a><b>Description</b></p>
    </th>
  </tr>
  <tr valign="top">
    <td><p class="tt"><a name="1017557"> </a>Generic Access</p>
    </td>
    <td><p class="tt"><a name="1017559"> </a>Describes the use of the lower layers of the Bluetooth protocol stack (LC and LMP), security-related alternatives, and the higher layers: L2CAP, RFCOMM, and OBEX.</p>
    </td>
  </tr>
  <tr valign="top">
    <td><p class="tt"><a name="1017562"> </a>Service Discovery Application</p>
    </td>
    <td><p class="tt"><a name="1017564"> </a>Defines the protocols and procedures used by a service discovery application on a device to locate services in other Bluetooth-enabled devices using the Service Discovery Protocol (SDP).</p>
    </td>
  </tr>
  <tr valign="top">
    <td><p class="tt"><a name="1017567"> </a>Serial Port</p>
    </td>
    <td><p class="tt"><a name="1017569"> </a>Defines the protocols and procedures used by devices using Bluetooth for RS-232 (or similar) serial cable emulation. The scenario covered by this profile deals with legacy applications using Bluetooth as a cable replacement through a virtual serial port abstraction (which in itself is operating system-dependent).</p>
    </td>
  </tr>
  <tr valign="top">
    <td><p class="tt"><a name="1017572"> </a>Dial-up Networking</p>
    </td>
    <td><p class="tt"><a name="1017574"> </a>Defines the protocols and procedures used by devices implementing the "Internet Bridge" usage model. This profile covers the usage of a cellular phone or modem both to receive data calls and to connect to a dial-up Internet access server or other dial-up service.</p>
    </td>
  </tr>
  <tr valign="top">
    <td><p class="tt"><a name="1017577"> </a>LAN Access Point</p>
    </td>
    <td><p class="tt"><a name="1017579"> </a>Defines LAN access using PPP over RFCOMM.</p>
    </td>
  </tr>
  <tr valign="top">
    <td><p class="tt"><a name="1017582"> </a>Generic Object Exchange</p>
    </td>
    <td><p class="tt"><a name="1017584"> </a>Defines the protocols and procedures used by the applications providing the usage models that need object exchange capabilities. </p>
    </td>
  </tr>
  <tr valign="top">
    <td><p class="tt"><a name="1017587"> </a>Object Push</p>
    </td>
    <td><p class="tt"><a name="1017589"> </a>Defines the requirements for the protocols and procedures used by applications providing the object push usage model. This profile makes use of the generic object exchange profile to define the interoperability requirements for the protocols needed by applications.</p>
    </td>
  </tr>
</table>

</div>


<p><a name="1017591"> </a>The following profiles are <i>not</i> supported by the Palm OS Bluetooth system:</p>
<ul type="disc">
  <li><a name="1017592"> </a>Cordless Telephony
  <li><a name="1017593"> </a>Intercom
  <li><a name="1017594"> </a>Headset
  <li><a name="1017595"> </a>Fax
  <li><a name="1017596"> </a>File Transfer
  <li><a name="1017597"> </a>Synchronization
</ul>

<p><a name="1017598"> </a>Note that although the Bluetooth system does not support the Bluetooth Synchronization profile, it implements HotSync operations over Bluetooth using the Serial Port profile. Also note that network HotSync operations use PPP.</p>

<p><a name="1017599"> </a>The Bluetooth system can dial and control voice calls on a Bluetooth-enabled phone as if it were connected through a serial cable. It does this using AT modem commands and not the Cordless Telephony profile.</p>
<h3 class="hbH3">
  <a name="1017601"> </a>Usage Scenarios <a href="#1017445"><span class="nav">^TOP^</span></a>
</h3>


<p><a name="1017602"> </a>Bluetooth-enabled Palm Powered handhelds are able to communicate with a variety of remote Bluetooth devices. The Bluetooth system uses the profiles defined by the Bluetooth specification in order to support the following usage scenarios:</p>

<p class="caption"><a name="1017608"> </a><b>Table 6.2&nbsp;&nbsp;Profiles required by various usage scenarios </b></p>
<div class="tablediv"><table cellspacing="0" class="tTable">

  <tr valign="top">
    <th><p class="tt"><a name="1017626"> </a><b></b></p>
    </th>
    <th><p class="tt"><a name="1017628"> </a><b></b></p>
    </th>
    <th colspan="7" rowspan="1"><p class="tt"><a name="1017630"> </a><b>Required Profiles</b></p>
    </th>
  </tr>
  <tr valign="top">
    <th><p class="tt"><a name="1017644"> </a><b>Feature</b></p>
    </th>
    <th><p class="tt"><a name="1017646"> </a><b>Handheld Connects With</b></p>
    </th>
    <th><p class="tt"><a name="1017648"> </a><b>Generic Access</b></p>
    </th>
    <th><p class="tt"><a name="1017650"> </a><b>Service Discovery</b></p>
    </th>
    <th><p class="tt"><a name="1017652"> </a><b>Serial Port</b></p>
    </th>
    <th><p class="tt"><a name="1017654"> </a><b>Dial-up Networking</b></p>
    </th>
    <th><p class="tt"><a name="1017656"> </a><b>LAN Access</b></p>
    </th>
    <th><p class="tt"><a name="1017658"> </a><b>Generic Obj. Exchange</b></p>
    </th>
    <th><p class="tt"><a name="1017660"> </a><b>Object Push</b></p>
    </th>
  </tr>
  <tr valign="top">
    <td colspan="1" rowspan="3"><p class="tt"><a name="1017662"> </a>Email and Web Clipping</p>
    </td>
    <td><p class="tt"><a name="1017664"> </a>Cell phone</p>
    </td>
    <td><p class="tt"><a name="1017666"> </a>X</p>
    </td>
    <td><p class="tt"><a name="1017668"> </a>X</p>
    </td>
    <td><p class="tt"><a name="1017670"> </a>X</p>
    </td>
    <td><p class="tt"><a name="1017672"> </a>X</p>
    </td>
    <td><p class="tt"><a name="1017674"> </a></p>
    </td>
    <td><p class="tt"><a name="1017676"> </a></p>
    </td>
    <td><p class="tt"><a name="1017678"> </a></p>
    </td>
  </tr>
  <tr valign="top">
    <td><p class="tt"><a name="1017682"> </a>Access point</p>
    </td>
    <td><p class="tt"><a name="1017684"> </a>X</p>
    </td>
    <td><p class="tt"><a name="1017686"> </a>X</p>
    </td>
    <td><p class="tt"><a name="1017688"> </a>X</p>
    </td>
    <td><p class="tt"><a name="1017690"> </a></p>
    </td>
    <td><p class="tt"><a name="1017692"> </a>X</p>
    </td>
    <td><p class="tt"><a name="1017694"> </a></p>
    </td>
    <td><p class="tt"><a name="1017696"> </a></p>
    </td>
  </tr>
  <tr valign="top">
    <td><p class="tt"><a name="1017700"> </a>Desktop computer</p>
    </td>
    <td><p class="tt"><a name="1017702"> </a>X</p>
    </td>
    <td><p class="tt"><a name="1017704"> </a>X</p>
    </td>
    <td><p class="tt"><a name="1017706"> </a>X</p>
    </td>
    <td><p class="tt"><a name="1017708"> </a></p>
    </td>
    <td><p class="tt"><a name="1017710"> </a>X</p>
    </td>
    <td><p class="tt"><a name="1017712"> </a></p>
    </td>
    <td><p class="tt"><a name="1017714"> </a></p>
    </td>
  </tr>
  <tr valign="top">
    <td colspan="1" rowspan="3"><p class="tt"><a name="1017716"> </a>HotSync</p>
    </td>
    <td><p class="tt"><a name="1017718"> </a>Cell phone</p>
    </td>
    <td><p class="tt"><a name="1017720"> </a>X</p>
    </td>
    <td><p class="tt"><a name="1017722"> </a>X</p>
    </td>
    <td><p class="tt"><a name="1017724"> </a>X</p>
    </td>
    <td><p class="tt"><a name="1017726"> </a>X</p>
    </td>
    <td><p class="tt"><a name="1017728"> </a></p>
    </td>
    <td><p class="tt"><a name="1017730"> </a></p>
    </td>
    <td><p class="tt"><a name="1017732"> </a></p>
    </td>
  </tr>
  <tr valign="top">
    <td><p class="tt"><a name="1017736"> </a>Access point</p>
    </td>
    <td><p class="tt"><a name="1017738"> </a>X</p>
    </td>
    <td><p class="tt"><a name="1017740"> </a>X</p>
    </td>
    <td><p class="tt"><a name="1017742"> </a>X</p>
    </td>
    <td><p class="tt"><a name="1017744"> </a></p>
    </td>
    <td><p class="tt"><a name="1017746"> </a>X</p>
    </td>
    <td><p class="tt"><a name="1017748"> </a></p>
    </td>
    <td><p class="tt"><a name="1017750"> </a></p>
    </td>
  </tr>
  <tr valign="top">
    <td><p class="tt"><a name="1017754"> </a>Desktop computer</p>
    </td>
    <td><p class="tt"><a name="1017756"> </a>X</p>
    </td>
    <td><p class="tt"><a name="1017758"> </a>X</p>
    </td>
    <td><p class="tt"><a name="1017760"> </a>X</p>
    </td>
    <td><p class="tt"><a name="1017762"> </a></p>
    </td>
    <td><p class="tt"><a name="1017764"> </a></p>
    </td>
    <td><p class="tt"><a name="1017766"> </a></p>
    </td>
    <td><p class="tt"><a name="1017768"> </a></p>
    </td>
  </tr>
  <tr valign="top">
    <td><p class="tt"><a name="1017770"> </a>SMS and Mobile Handset Management</p>
    </td>
    <td><p class="tt"><a name="1017772"> </a>Cell phone</p>
    </td>
    <td><p class="tt"><a name="1017774"> </a>X</p>
    </td>
    <td><p class="tt"><a name="1017776"> </a>X</p>
    </td>
    <td><p class="tt"><a name="1017778"> </a>X</p>
    </td>
    <td><p class="tt"><a name="1017780"> </a></p>
    </td>
    <td><p class="tt"><a name="1017782"> </a></p>
    </td>
    <td><p class="tt"><a name="1017784"> </a></p>
    </td>
    <td><p class="tt"><a name="1017786"> </a></p>
    </td>
  </tr>
  <tr valign="top">
    <td><p class="tt"><a name="1017788"> </a>Beaming</p>
    </td>
    <td><p class="tt"><a name="1017790"> </a>Many devices</p>
    </td>
    <td><p class="tt"><a name="1017792"> </a>X</p>
    </td>
    <td><p class="tt"><a name="1017794"> </a>X</p>
    </td>
    <td><p class="tt"><a name="1017796"> </a>X</p>
    </td>
    <td><p class="tt"><a name="1017798"> </a></p>
    </td>
    <td><p class="tt"><a name="1017800"> </a></p>
    </td>
    <td><p class="tt"><a name="1017802"> </a>X</p>
    </td>
    <td><p class="tt"><a name="1017804"> </a>X</p>
    </td>
  </tr>
</table>

</div>

<h3 class="hbH3">
  <a name="1017807"> </a>Authentication and Encryption <a href="#1017445"><span class="nav">^TOP^</span></a>
</h3>


<p><a name="1017808"> </a>The Bluetooth system handles the generation, utilization, and storage of authentication and encryption keys at the OS level.</p>

<p><a name="1017809"> </a>The Bluetooth system doesn't support Authorization. Access concerns beyond authentication are left up to the individual application, as in a standard networking environment.</p>

<p><a name="1017810"> </a>The Bluetooth system supports security modes 1 and 2: the "non-secure" and "service-level enforced security" modes. Security mode 3&#8212;"link-level enforced security"&#8212;isn't supported by the Bluetooth system.</p>
<h3 class="hbH3">
  <a name="1017812"> </a>Device Discovery <a href="#1017445"><span class="nav">^TOP^</span></a>
</h3>


<p><a name="1017813"> </a>In a system of Bluetooth devices, ad-hoc networks are established between the devices. The "inquiry" procedure is used to discover Bluetooth devices within range. The specification defines two inquiry modes, "General" and "Limited." The General mode, which is supported by the Bluetooth system, is used by devices that need to discover devices that are made discoverable continuously or for no specific condition. Limited mode, on the other hand, is used to devices that need to discover devices that are made discoverable for only a limited period of time, during temporary conditions, or for a specific event. The Bluetooth system doesn't support the Limited inquiry mode.</p>
<h3 class="hbH3">
  <a name="1017815"> </a>Piconet Support <a href="#1017445"><span class="nav">^TOP^</span></a>
</h3>


<p><a name="1017816"> </a>There are two main scenarios in which a piconet can be created, and the Bluetooth system supports both:</p>
<ul type="disc">
  <li><a name="1017817"> </a>Master performs inquiry, sees a number of devices, and proceeds to contact each of them. A variant is that the master later performs inquiry to find additional slaves. This should be useful for a game server where the master establishes the connection to each Palm device that wants to participate in a game.
  <li><a name="1017818"> </a>Master sits in page scan mode, and when a device connects to it, a master/slave switch is performed. The LAN access profile uses this approach for multi-point LAN access devices. The Bluetooth system handles the master/slave negotiation automatically.
</ul>

<p><a name="1017819"> </a>The Bluetooth system places existing connections in hold mode while new links are established. In the first scenario outlined above, hold times for each connection are determined based upon a list of the devices that the user has selected to participate in the piconet. The Bluetooth system performs the following for each device on the list:</p>
<ol type="1">
  <li value="1"><a name="1017820"> </a>Establish an ACL connection to the device.
  <li value="2"><a name="1017821"> </a>Place the device in hold mode for a period of time that is a function of the total number of devices that are to participate in the piconet.
  <li value="3"><a name="1017822"> </a>Delay for a set period of time to allow the slave to enter hold mode.
</ol>

<p><a name="1017823"> </a>After all connections have been established, each of the slave hold timers should expire, and the piconet should be operational.</p>
<h3 class="hbH3">
  <a name="1017825"> </a>Radio Power Management <a href="#1017445"><span class="nav">^TOP^</span></a>
</h3>


<p><a name="1017826"> </a>The extended battery life of Palm Powered handhelds is considered to be a key competitive advantage by many Palm Powered handheld manufacturers. The Bluetooth system helps preserve battery life by taking advantage of the Bluetooth power efficiency modes (hold, park, and sniff) and the internal power management functionality built into the Bluetooth radio chipset.</p>

<p><a name="1017828"> </a>Applications don't explicitly put the radio into the sniff, park, or standby modes. Instead, power management is under the control of the Bluetooth system. When participating in a piconet, the Bluetooth system honors requests from the other members of the piconet to enter any of the defined power-saving modes.</p>

<p><a name="1021614"> </a>Some Palm OS devices support Bluetooth sleep and wake scheduling. This allows the device to be configured to be awakened by incoming connection attempts only during certain time periods.</p>

<p><a name="1021615"> </a>You can determine if the device supports sleep and wake scheduling by checking for the <code>sysFtrBtSupportsScheduledWakeup</code> feature. Use this <a href="../PalmOSReference/FeatureManager.html#1036943"><code>FtrGet()</code></a> call:</p>

<div class="CodeRule"><hr></div><pre class="CodeBlock">
err = FtrGet(sysFtrCreator,
sysFtrBtSupportsScheduledWakeup, &amp;value);<a name="1021624"> </a>
</pre><div class="CodeRule"><hr></div>


<p><a name="1021625"> </a>If Bluetooth sleep and wake scheduling is available, the <code>value</code> parameter will be non-zero and the returned error should also be zero (for no error).</p>

<h2 class="haH2">
  <a name="1017830"> </a>Developing Bluetooth-Enabled Applications <a href="#1017445"><span class="nav">^TOP^</span></a>
</h2>


<p><a name="1017831"> </a>The Palm OS exposes Bluetooth through multiple interfaces, allowing you to choose the interface that is best suited for the task at hand. Bluetooth development is supported through the Serial Manager using the Virtual Serial Driver, which is discussed in <a href="BTCompanion.html#1018212">"Bluetooth Virtual Serial Driver."</a> Object transfer is supported through the Exchange Manager using the Bluetooth Exchange Library, which is discussed in <a href="BTCompanion.html#1018328">"Bluetooth Exchange Library Support."</a> Finally, you can program directly with the Bluetooth Library APIs, which is the subject of this section.</p>

<p><a name="1017839"> </a>Regardless of which approach you take, your applications should check if the Bluetooth system is running on the handheld before using any Bluetooth APIs. To do so, use the following code:</p>

<div class="CodeRule"><hr></div><pre class="CodeBlock">
	UInt32 btVersion;<a name="1017841"> </a>
<a name="1017842"> </a>
	// Make sure Bluetooth components are installed<a name="1017843"> </a>
	// This check also ensures Palm OS 4.0 or greater<a name="1017844"> </a>
	if (FtrGet(btLibFeatureCreator, btLibFeatureVersion,<a name="1017845"> </a>
		&amp;btVersion) != errNone)<a name="1017846"> </a>
	{<a name="1017847"> </a>
		// Alert the user if it's the active application<a name="1017848"> </a>
		if ((launchFlags &amp; sysAppLaunchFlagNewGlobals) &amp;&amp;<a name="1017849"> </a>
			(launchFlags &amp; sysAppLaunchFlagUIApp))<a name="1017850"> </a>
			FrmAlert (MissingBtComponentsAlert);<a name="1017851"> </a>
		return sysErrRomIncompatible;<a name="1017852"> </a>
	}<a name="1017853"> </a>
</pre><div class="CodeRule"><hr></div>


<p><a name="1022146"> </a>Once your application has determined that Bluetooth support is available, it needs to load the Bluetooth library. This can be done with code like this:</p>

<div class="CodeRule"><hr></div><pre class="CodeBlock">
UInt16 btLibRefNum;<a name="1022148"> </a>
Err error = errNone;<a name="1022170"> </a>
<a name="1022159"> </a>
if (SysLibFind(btLibName, &amp;btLibRefNum)) {<a name="1022168"> </a>
	error = SysLibLoad(sysFileTLibrary, sysFileCBtLib,<a name="1022169"> </a>
					&amp;btLibRefNum);<a name="1022175"> </a>
}<a name="1022171"> </a>
</pre><div class="CodeRule"><hr></div>


<p><a name="1022184"> </a>Your application is then ready to open and use the Bluetooth library; it will use the <code>btLibRefNum</code> value to reference the library.</p>
<h3 class="hbH3">
  <a name="1017855"> </a>Overview of the Bluetooth Library <a href="#1017445"><span class="nav">^TOP^</span></a>
</h3>


<p><a name="1017856"> </a>From a programmer's perspective, the functions of the Bluetooth library fall into four areas: management, sockets, security, and utility.</p>
<ul type="disc">
  <li><a name="1017857"> </a>The management functions deal with the radio and baseband parts of the Bluetooth specification. You use them to find nearby devices and establish ACL links.
  <li><a name="1017858"> </a>The socket functions enable communication with L2CAP, RFCOMM, and SDP.
  <li><a name="1017859"> </a>The security functions manage a set of trusted devices&#8212;devices that do not have to authenticate when they create a secure connection with the handheld.
  <li><a name="1017860"> </a>The utility functions perform useful data conversions.
</ul>
<h3 class="hbH3">
  <a name="1017862"> </a>Management <a href="#1017445"><span class="nav">^TOP^</span></a>
</h3>


<p><a name="1017863"> </a>Three basic management tasks common among Bluetooth applications are finding the Bluetooth devices in range, establishing ACL links, and working with piconets. However, in order for your code to use any of the functions that do these operations, you need to create a management callback function.</p>

<h4 class="hcH4">
  <a name="1017865"> </a>Management Callback Function
</h4>

<p><a name="1017866"> </a>Most management calls are asynchronous. In other words, they start an operation and return before the operation actually completes. When the operation completes, the Bluetooth Library notifies the application by way of a callback function. Such a notification is called a <b>management event</b>.</p>

<p><a name="1017868"> </a>In some cases, a management function fails before starting the asynchronous operation. In this case, the callback function does not get called. You can tell whether the callback function will be called or not by looking at the management function's return code:</p>

<dl>
<dt><a name="1017870"> </a><code>btLibErrNoError</code></dt>
<dd><a name="1017871"> </a>The operation has completed and the callback function will not be called.</dd>

<dt><a name="1017872"> </a><code>btLibErrPending</code></dt>
<dd><a name="1017873"> </a>The operation has started successfully and the callback function will be called,</dd>

<dt><a name="1017874"> </a><code>any other error code</code></dt>
<dd><a name="1017875"> </a>The operation failed and the callback function will not be called.</dd>

</dl>

<p><a name="1017876"> </a>The management callback function has two parameters: a management event structure, which contains all the information about the event that has occurred, and a reference context, an optional <code>UInt32</code> you can use to establish the context of the event. The callback function needs to provide the code that handles the events generated as a result of the operations you perform.</p>

<p><a name="1017878"> </a>The callback function should not perform any heavyweight processing; doing so prevents the Bluetooth stack from running. You can defer processing by generating a custom system event in the callback function and responding to the event with your event handling code. For some operations, you must defer the processing. For example, the callback function cannot close the Bluetooth library in response to a <a href="../PalmOSReference/BtLibRef_Mgt.html#1028379"><code>btLibManagementEventAclDisconnect</code></a> event.</p>

<p><a name="1017883"> </a>As a simple example, consider the task of finding nearby devices, discussed in the next section. The callback function must respond to four events: <code>btLibManagementEventInquiryResult</code>, <code>btLibManagementEventInquiryComplete</code>, <code>btLibManagementEventInquiryCanceled</code>, and <code>btLibManagementEventRadioState</code>. The following code is a skeleton of the callback function you need:</p>

<div class="CodeRule"><hr></div><pre class="CodeBlock">
void MyManagementCallback (BtLibManagementEventType *eventP,<a name="1017884"> </a>
	UInt32 refcon) {<a name="1017885"> </a>
	switch (eventP-&gt;event) {<a name="1017886"> </a>
		case btLibManagementEventInquiryResult :<a name="1017887"> </a>
			// A device has been found. Save it in a list<a name="1017888"> </a>
			break;<a name="1017889"> </a>
		case btLibManagementEventInquiryComplete :<a name="1017890"> </a>
			// The inquiry has finished<a name="1017891"> </a>
			break;<a name="1017892"> </a>
		case btLibManagementEventInquiryCanceled :<a name="1017893"> </a>
			// The inquiry has been canceled<a name="1017894"> </a>
			break;<a name="1017895"> </a>
		case btLibManagementEventRadioState :<a name="1017896"> </a>
			// The radio state has changed<a name="1017897"> </a>
			break;<a name="1017898"> </a>
		default :<a name="1017899"> </a>
			// Unknown event<a name="1017900"> </a>
			break;<a name="1017901"> </a>
	}<a name="1017902"> </a>
</pre><div class="CodeRule"><hr></div>


<p><a name="1017903"> </a>To tell the Bluetooth Library to use your callback function, call <a href="../PalmOSReference/BtLibRef_Mgt.html#1029564"><code>BtLibRegisterManagementNotification</code></a>. You should always unregister your callback before closing the Bluetooth Library.</p>

<p><a name="1017910"> </a>For a list of management events, see <a href="../PalmOSReference/BtLibRef_Mgt.html#1028315">"Management Callback Events"</a> in <a href="../PalmOSReference/BtLibRef_Mgt.html#1027980">Chapter 82, "Bluetooth Library: Management."</a></p>

<h4 class="hcH4">
  <a name="1017916"> </a>Opening the Library
</h4>

<p><a name="1017921"> </a>To open the Bluetooth library, use the <a href="../PalmOSReference/BtLibRef_Mgt.html#1028773"><code>BtLibOpen</code></a> function. At this time, the Bluetooth library starts the radio initialization process. When initialization successfully finishes, the Bluetooth library generates a <a href="../PalmOSReference/BtLibRef_Mgt.html#1028623"><code>btLibManagementEventRadioState</code></a> event with a status of <code>btLibErrRadioInitialized</code>. You must wait for the initialization to complete successfully before calling any Bluetooth library function involving the radio.</p>

<p><a name="1017927"> </a>The exceptions to this rule are the discovery functions, <a href="../PalmOSReference/BtLibRef_Mgt.html#1028867"><code>BtLibDiscoverMultipleDevices</code></a> and <a href="../PalmOSReference/BtLibRef_Mgt.html#1028929"><code>BtLibDiscoverSingleDevice</code></a>, which handle the radio initialization events automatically and can be called directly after the Bluetooth library is opened.</p>

<h4 class="hcH4">
  <a name="1017937"> </a>Finding Nearby Devices
</h4>

<p><a name="1017938"> </a>There are two ways to find Bluetooth devices that are within range:</p>
<ul type="disc">
  <li><a name="1017943"> </a>Use the <a href="../PalmOSReference/BtLibRef_Mgt.html#1028867"><code>BtLibDiscoverMultipleDevices</code></a> and <a href="../PalmOSReference/BtLibRef_Mgt.html#1028929"><code>BtLibDiscoverSingleDevice</code></a> functions to find nearby devices. These functions bring up a user interface that allows the user to choose one or more devices.
  <li><a name="1017952"> </a>Perform a device inquiry using <a href="../PalmOSReference/BtLibRef_Mgt.html#1029663"><code>BtLibStartInquiry</code></a>. This is more difficult to do than using one of the discovery functions, but provides more flexibility.
</ul>

<p><a name="1017957"> </a>When you call <a href="../PalmOSReference/BtLibRef_Mgt.html#1029663"><code>BtLibStartInquiry</code></a>, the Bluetooth Library searches for all devices in range. Whenever it finds a device, it generates a <a href="../PalmOSReference/BtLibRef_Mgt.html#1028455"><code>btLibManagementEventInquiryResult</code></a> event. When the inquiry has completed, a <a href="../PalmOSReference/BtLibRef_Mgt.html#1028448"><code>btLibManagementEventInquiryComplete</code></a> event is generated. To cancel the inquiry, call <a href="../PalmOSReference/BtLibRef_Mgt.html#1028820"><code>BtLibCancelInquiry</code></a>. The <a href="../PalmOSReference/BtLibRef_Mgt.html#1028441"><code>btLibManagementEventInquiryCanceled</code></a> event is generated when the cancellation succeeds.</p>

<h4 class="hcH4">
  <a name="1017975"> </a>Creating ACL Links
</h4>

<p><a name="1017976"> </a>Once you have the device address of a remote device, you can attempt to create an ACL link to it using the <a href="../PalmOSReference/BtLibRef_Mgt.html#1029171"><code>BtLibLinkConnect</code></a> function. This causes the <a href="../PalmOSReference/BtLibRef_Mgt.html#1028361"><code>btLibManagementEventAclConnectOutbound</code></a> event to be generated, and the status code within that event indicates whether or not the link was successfully established.</p>

<p><a name="1017990"> </a>To disconnect a link, use the <a href="../PalmOSReference/BtLibRef_Mgt.html#1029216"><code>BtLibLinkDisconnect</code></a> function. This causes the <a href="../PalmOSReference/BtLibRef_Mgt.html#1028379"><code>btLibManagementEventAclDisconnect</code></a> event to be generated. Note that the same event is generated when the remote device initiates the disconnection.</p>

<p><a name="1017995"> </a>Your program must also respond to <a href="../PalmOSReference/BtLibRef_Mgt.html#1028351"><code>btLibManagementEventAclConnectInbound</code></a> events that indicate that a remote device has established a link with the handheld. You can disconnect an inbound link with the <a href="../PalmOSReference/BtLibRef_Mgt.html#1029216"><code>BtLibLinkDisconnect</code></a> function.</p>

<h4 class="hcH4">
  <a name="1018005"> </a>Working With Piconets
</h4>

<p><a name="1018006"> </a>Bluetooth supports up to seven slaves in a piconet. The Bluetooth Library provides simplified APIs to create and destroy piconets.</p>

<p><a name="1018007"> </a>Note that the Bluetooth 1.1 specification suggests that the upper software layers place slaves in hold or park mode while new connections are established. This isn't well&#8211;defined in the specification, and is difficult to do because of timing. The Bluetooth Library expects the radio baseband to handle piconet timing.</p>

<p><a name="1018013"> </a>To create a piconet, the "master" calls <a href="../PalmOSReference/BtLibRef_Mgt.html#1029396"><code>BtLibPiconetCreate</code></a>. Slaves can then discover the master and join the piconet, or the master can discover and connect to the slaves. The master stops advertising once the limit of seven slaves has been reached. Note that any device should be capable of acting as a slave.</p>

<p><a name="1018014"> </a>The piconet can be locked to prevent additional slaves from joining. The master can still discover and add slaves, however. With the piconet locked, there is a bandwidth improvement of approximately 10%.</p>

<p><a name="1018015"> </a>In the Bluetooth Library, the following functions support the management of piconets:</p>
<ul type="disc">
  <li><a name="1018020"> </a><a href="../PalmOSReference/BtLibRef_Mgt.html#1029396"><code>BtLibPiconetCreate</code></a>: create a piconet or reconfigure an existing piconet so the local device is the master.
  <li><a name="1018025"> </a><a href="../PalmOSReference/BtLibRef_Mgt.html#1029449"><code>BtLibPiconetDestroy</code></a>: destroy the piconet by disconnecting links to all devices and removing all restrictions on whether the local device is a master or a slave.
  <li><a name="1018030"> </a><a href="../PalmOSReference/BtLibRef_Mgt.html#1029498"><code>BtLibPiconetLockInbound</code></a>: prevent remote devices from creating ACL links into the piconet.
  <li><a name="1018035"> </a><a href="../PalmOSReference/BtLibRef_Mgt.html#1029530"><code>BtLibPiconetUnlockInbound</code></a>: allow additional slaves to create ACL links into the piconet.
</ul>

<p><a name="1018036"> </a>Remember the following limitations of piconets: Slave-to-slave communication is not permitted. The master cannot "broadcast" to slaves.</p>
<h3 class="hbH3">
  <a name="1018038"> </a>Sockets <a href="#1017445"><span class="nav">^TOP^</span></a>
</h3>


<p><a name="1018039"> </a>The Bluetooth Library uses the concept of sockets to manage communication between Bluetooth devices. A socket represents a bidirectional packet-based link to a remote device. Sockets run over ACL connections. The Bluetooth library can accommodate up to 16 simultaneous sockets.</p>

<p><a name="1018040"> </a>Three types of sockets are supported by the Bluetooth Library. L2CAP and RFCOMM sockets establish data channels and send and receive arbitrary data over those channels. SDP sockets allow you to query remote devices about the services those devices provide.</p>

<p><a name="1018043"> </a>To send a packet of data over an L2CAP or RFCOMM socket, use the <a href="../PalmOSReference/BtLibRef_Sockets.html#1040525"><code>BtLibSocketSend</code></a> function. The send buffer must not change until the send completes. In other words, you must not modify the buffer, free the buffer, or use a local variable for the buffer. The Bluetooth Library notifies you when the send completes by generating a <a href="../PalmOSReference/BtLibRef_Sockets.html#1039921"><code>btLibSocketEventSendComplete</code></a> event. You can only have one outstanding packet on each socket.</p>

<p><a name="1018056"> </a>The <a href="../PalmOSReference/BtLibRef_Sockets.html#1039594"><code>btLibSocketEventData</code></a> event indicates data has been received.</p>

<h4 class="hcH4">
  <a name="1018058"> </a>L2CAP
</h4>

<p><a name="1018059"> </a>L2CAP sockets don't allow for flow control.</p>

<h5 class="hdH5">
  <a name="1018061"> </a>Establishing Inbound L2CAP Connections
</h5>

<p><a name="1018062"> </a>To set up for inbound L2CAP connections, you call the following:</p>
<ol type="1">
  <li value="1"><a name="1018067"> </a><a href="../PalmOSReference/BtLibRef_Sockets.html#1040185"><code>BtLibSocketCreate</code></a>: create an L2CAP socket.
  <li value="2"><a name="1018072"> </a><a href="../PalmOSReference/BtLibRef_Sockets.html#1040344"><code>BtLibSocketListen</code></a>: set up an L2CAP socket as a listener.
  <li value="3"><a name="1018077"> </a><a href="../PalmOSReference/BtLibRef_Sockets.html#1040850"><code>BtLibSdpServiceRecordCreate</code></a>: allocate a memory chunk that represents an SDP service record.
  <li value="4"><a name="1018082"> </a><a href="../PalmOSReference/BtLibRef_Sockets.html#1041405"><code>BtLibSdpServiceRecordSetAttributesForSocket</code></a>: initialize an SDP memory record so it can represent the newly-created L2CAP listener socket as a service
  <li value="5"><a name="1018087"> </a><a href="../PalmOSReference/BtLibRef_Sockets.html#1041579"><code>BtLibSdpServiceRecordStartAdvertising</code></a>: make an SDP memory record representing a local SDP service record visible to remote devices.
</ol>

<p><a name="1018092"> </a>When you get a <a href="../PalmOSReference/BtLibRef_Sockets.html#1039574"><code>btLibSocketEventConnectRequest</code></a> event, you need to respond with a call to <a href="../PalmOSReference/BtLibRef_Sockets.html#1040458"><code>BtLibSocketRespondToConnection</code></a>. You then receive a <a href="../PalmOSReference/BtLibRef_Sockets.html#1039552"><code>btLibSocketEventConnectedInbound</code></a> event with an inbound socket with which you can send and receive data.</p>

<p><a name="1018101"> </a>The listening socket remains open and will notify you of further connection attempts. In other words, you can use a single L2CAP listening socket to spawn several inbound sockets. You cannot close the listening socket until after you close its inbound sockets.</p>

<h5 class="hdH5">
  <a name="1018103"> </a>Establishing Outbound L2CAP Connections
</h5>

<p><a name="1018104"> </a>To establish an outbound L2CAP connection, you first establish an ACL link to the remote device. Then you call:</p>
<ol type="1">
  <li value="1"><a name="1018109"> </a><a href="../PalmOSReference/BtLibRef_Sockets.html#1040185"><code>BtLibSocketCreate</code></a>: create an SDP socket.
  <li value="2"><a name="1018114"> </a><a href="../PalmOSReference/BtLibRef_Sockets.html#1040613"><code>BtLibSdpGetPSMByUuid</code></a>: get an available L2CAP PSM using SDP.
  <li value="3"><a name="1018119"> </a><a href="../PalmOSReference/BtLibRef_Sockets.html#1040019"><code>BtLibSocketClose</code></a>: close the SDP socket.
  <li value="4"><a name="1018124"> </a><a href="../PalmOSReference/BtLibRef_Sockets.html#1040185"><code>BtLibSocketCreate</code></a>: create an L2CAP socket.
  <li value="5"><a name="1018129"> </a><a href="../PalmOSReference/BtLibRef_Sockets.html#1040060"><code>BtLibSocketConnect</code></a>: create an outbound L2CAP connection.
</ol>

<h4 class="hcH4">
  <a name="1018131"> </a>RFCOMM
</h4>

<p><a name="1018132"> </a>RFCOMM emulates a serial connection. It is used by the Bluetooth Virtual Serial Driver and the Bluetooth Exchange Library.</p>

<p><a name="1018133"> </a>When using RFCOMM, you can only have one inbound connection per listener socket. Flow control uses a "credit" system: you need to advance a credit to the far end before you can receive a data packet.</p>

<p><a name="1018134"> </a>RFCOMM defines the notions of <b>server</b> and <b>client</b>. A server uses SDP to advertise its existence and listens for inbound connections. A client creates an outbound RFCOMM connection to a server.</p>

<h5 class="hdH5">
  <a name="1018136"> </a>Establishing Inbound RFCOMM Connections
</h5>

<p><a name="1018137"> </a>To set up for inbound RFCOMM connections, call the following:</p>
<ol type="1">
  <li value="1"><a name="1018142"> </a><a href="../PalmOSReference/BtLibRef_Sockets.html#1040185"><code>BtLibSocketCreate</code></a>: create an RFCOMM socket.
  <li value="2"><a name="1018147"> </a><a href="../PalmOSReference/BtLibRef_Sockets.html#1040344"><code>BtLibSocketListen</code></a>: set up the RFCOMM socket as a listener.
  <li value="3"><a name="1018152"> </a><a href="../PalmOSReference/BtLibRef_Sockets.html#1040850"><code>BtLibSdpServiceRecordCreate</code></a>: allocate a memory chunk that represents an SDP service record.
  <li value="4"><a name="1018157"> </a><a href="../PalmOSReference/BtLibRef_Sockets.html#1041405"><code>BtLibSdpServiceRecordSetAttributesForSocket</code></a>: initialize an SDP memory record so it can represent the newly-created RFCOMM listener socket as a service
  <li value="5"><a name="1018162"> </a><a href="../PalmOSReference/BtLibRef_Sockets.html#1041579"><code>BtLibSdpServiceRecordStartAdvertising</code></a>: make the SDP memory record representing your local SDP service record visible to remote devices.
</ol>

<p><a name="1018167"> </a>When you get a <a href="../PalmOSReference/BtLibRef_Sockets.html#1039574"><code>btLibSocketEventConnectRequest</code></a> event, you need to respond with a call to <a href="../PalmOSReference/BtLibRef_Sockets.html#1040458"><code>BtLibSocketRespondToConnection</code></a>. You then receive a <a href="../PalmOSReference/BtLibRef_Sockets.html#1039552"><code>btLibSocketEventConnectedInbound</code></a> event with an inbound socket with which you can send and receive data. To send data, use the <a href="../PalmOSReference/BtLibRef_Sockets.html#1040525"><code>BtLibSocketSend</code></a> function. The <a href="../PalmOSReference/BtLibRef_Sockets.html#1039594"><code>btLibSocketEventData</code></a> event indicates data has been received.</p>

<p><a name="1018184"> </a>The listening socket will not notify you of further connection attempts. In other words, a single RFCOMM listening socket can only spawn a single inbound RFCOMM socket. You cannot close the listening socket until after you close its inbound socket.</p>

<h5 class="hdH5">
  <a name="1018186"> </a>Establishing Outbound RFCOMM Connections
</h5>

<p><a name="1018187"> </a>To establish an outbound RFCOMM connection, you first establish an ACL link to the remote device. Then you call:</p>
<ol type="1">
  <li value="1"><a name="1018192"> </a><a href="../PalmOSReference/BtLibRef_Sockets.html#1040185"><code>BtLibSocketCreate</code></a>: create an SDP socket.
  <li value="2"><a name="1018197"> </a><a href="../PalmOSReference/BtLibRef_Sockets.html#1040756"><code>BtLibSdpGetServerChannelByUuid</code></a>: get an available RFCOMM server channel using SDP.
  <li value="3"><a name="1018202"> </a><a href="../PalmOSReference/BtLibRef_Sockets.html#1040185"><code>BtLibSocketCreate</code></a>: create an RFCOMM socket.
  <li value="4"><a name="1018207"> </a><a href="../PalmOSReference/BtLibRef_Sockets.html#1040060"><code>BtLibSocketConnect</code></a>: Create an outbound RFCOMM connection.
</ol>

<h2 class="haH2">
  <a name="1018212"> </a>Bluetooth Virtual Serial Driver <a href="#1017445"><span class="nav">^TOP^</span></a>
</h2>


<p><a name="1018215"> </a>The Bluetooth system implements the serial port profile with a Virtual Serial Driver. This driver has the following characteristics:</p>
<ul type="disc">
  <li><a name="1018216"> </a>Opens a background thread for the Bluetooth stack.
  <li><a name="1018217"> </a>Supports only one current active serial channel (point-to-point connection) at a time.
  <li><a name="1018218"> </a>Is opened explicitly as either a client or a server.
  <li><a name="1018219"> </a>Is utilized, as a client, by the following Palm OS components:
  <ul type="disc">
    <li><a name="1018220"> </a>PPP
    <li><a name="1018221"> </a>HotSync
    <li><a name="1018222"> </a>Telephony
  </ul>
  <li><a name="1018223"> </a>If opened as a server, advertises a list of services (UUIDs) for remote clients to query.
  <li><a name="1018224"> </a>If opened as a client, creates the necessary baseband and RFCOMM connections, based upon information passed in by the opener.
</ul>

<p><a name="1018225"> </a>An RFCOMM-based virtual serial port is far less symmetrical than a physical serial port. In a traditional serial port, there is no need to establish the underlying transport. When establishing a Bluetooth serial port, however, there are roles for a client and a server device on three different stack levels&#8212;ACL, L2CAP, and RFCOMM&#8212;as well as responsibilities for registering with and querying SDP.</p>
<h3 class="hbH3">
  <a name="1018227"> </a>Opening the Serial Port <a href="#1017445"><span class="nav">^TOP^</span></a>
</h3>


<p><a name="1018229"> </a>You can use the new <code>SrmExtOpen</code> function to open a Bluetooth serial port, passing Bluetooth-specific parameters in a custom info block. You should first verify that the port being opened is in fact a Bluetooth serial port, since other types of ports may use the block for other purposes.</p>

<p><a name="1018230"> </a>For the benefit of certain legacy applications, the driver also supports being opened by the old <code>SrmOpen</code> function. In that case, the driver presumes the role of client, performs device discovery with user interaction, and looks for remote channel advertising the Serial Port Service Class.</p>

<p><a name="1018233"> </a>To open an RFCOMM virtual serial port with <code>SrmExtOpen</code>, you need to create a <code>BtVdOpenParams</code> structure. This structure is declared as follows:</p>

<div class="CodeRule"><hr></div><pre class="CodeBlock">
typedef struct {<a name="1018235"> </a>
    BtVdRole role;<a name="1018236"> </a>
    union {<a name="1018237"> </a>
        BtVdOpenParamsClient client;<a name="1018238"> </a>
        BtVdOpenParamsServer server;<a name="1018239"> </a>
    } u;<a name="1018240"> </a>
    Boolean authenticate;<a name="1018241"> </a>
    Boolean encrypt;<a name="1018242"> </a>
} BtVdOpenParams;<a name="1018243"> </a>
</pre><div class="CodeRule"><hr></div>


<p><a name="1018244"> </a>How you populate this structure depends on whether you are opening the serial port as a client or as a server. A client initiates baseband and RFCOMM connections, while a server waits for incoming baseband and RFCOMM connections.</p>

<p><a name="1018245"> </a>If you are acting as a client, set the structure's <code>role</code> member to <code>btVdClient</code> and fill in the <code>client</code> member of the union as described in <a href="BTCompanion.html#1018255">"Opening the Port as a Client."</a> If you are acting as a server, set the structure's <code>role</code> member to <code>btVdServer</code> and fill in the <code>server</code> member of the union as described in <a href="BTCompanion.html#1018280">"Opening the Port as a Server."</a></p>

<p><a name="1018252"> </a>Irrespective of whether you are acting as a client or as a server, set <code>authenticate</code> to <code>true</code> if you require link authentication. Similarly, set <code>encrypt</code> to <code>true</code> if you require link encryption. Link encryption requires link authentication.</p>

<h4 class="hcH4">
  <a name="1018255"> </a>Opening the Port as a Client
</h4>

<p><a name="1018256"> </a>When playing the client role you must specify the address of the remote Bluetooth device and the service to connect to on the remote device. You do this by filling out the <code>client</code> member of the union in the <code>BtVdOpenParams</code> structure. This member is declared to be a <code>BtVdOpenParamsClient</code> structure, which looks like this:</p>

<div class="CodeRule"><hr></div><pre class="CodeBlock">
typedef struct {<a name="1018259"> </a>
    BtLibDeviceAddressType remoteDevAddr;<a name="1018260"> </a>
    BtVdClientMethod method;<a name="1018261"> </a>
    union {<a name="1018262"> </a>
        BtLibRfCommServerIdType channelId;<a name="1018263"> </a>
        BtVdUuidList uuidList;<a name="1018264"> </a>
    } u;<a name="1018265"> </a>
} BtVdOpenParamsClient;<a name="1018266"> </a>
</pre><div class="CodeRule"><hr></div>


<p><a name="1018267"> </a>If you know the address of the Bluetooth device to which you want to connect, supply the address in <code>remoteDevAddr</code>. Otherwise, supply an address value of all zeros; this will cause a Bluetooth device discovery operation to be initiated, allowing the handheld user to choose the device to connect to.</p>

<p><a name="1018268"> </a>When connecting to a remote service using RFCOMM, you have two basic options: </p>
<ul type="disc">
  <li><a name="1018269"> </a>use SDP to look for one or more UUIDs
  <li><a name="1018270"> </a>connect to a specific RFCOMM channel ID
</ul>

<p><a name="1018272"> </a>You normally specify the service to which to connect by providing a list of one or more service class UUIDs. Simply set the structure's <code>method</code> member to <code>btVdUseUuidList </code>and supply a list of UUIDs using the <code>uuidList</code> member of the structure's union. This will trigger a series of SDP queries, searching for each of the specified service classes. The first service class that is found on the remote device will be used. If it suits your application, specify an empty list of service class UUIDs (set the list count of zero); this causes an SDP query to be made for a default Palm-specific service class UUID (953D4FBC-8DA3-11D5-AA62-0030657C543C).</p>

<p><a name="1018273"> </a>The result of a successful SDP query is the RFCOMM server channel to which to connect on the remote device. To facilitate testing, you can bypass SDP querying and directly specify the remote RFCOMM server channel ID. Simply set the structure's <code>method</code> member to <code>btVdUseChannelId</code> and set the <code>channelId</code> member of the structure's union to the server channel ID.</p>

<p><a name="1018275"> </a>The call to <code>SrmExtOpen</code> blocks until the RFCOMM connection is established or it is determined that the connection cannot be established. The driver displays a progress dialog, giving the user the opportunity to cancel the connection attempt.</p>

<p><a name="1018276"> </a><code>SrmExtOpen</code> returns zero if and only if the RFCOMM connection was successfully established.</p>

<h4 class="hcH4">
  <a name="1018280"> </a>Opening the Port as a Server
</h4>

<p><a name="1018281"> </a>Relative to the process of opening the serial port as a client, opening the port as a server is pretty simple. When playing the server role, you need only specify the UUID of the service you wish to advertise. Optionally, you can also specify a user-readable name for that service.</p>

<p><a name="1018282"> </a>Specify the service UUID and user-readable name by filling out the <code>server</code> member of the union in the <code>BtVdOpenParams</code> structure. This member is a <code>BtVdOpenParamsServer</code> structure, which is declared as follows:</p>

<div class="CodeRule"><hr></div><pre class="CodeBlock">
typedef struct {<a name="1018285"> </a>
    BtLibSdpUuidType uuid;<a name="1018286"> </a>
    const Char *name;<a name="1018287"> </a>
} BtVdOpenParamsServer;<a name="1018288"> </a>
</pre><div class="CodeRule"><hr></div>


<p><a name="1018289"> </a>As a convenience, you can specify a null UUID (all binary zeros), in which case the default Palm-specific service class UUID will be advertised. (953D4FBC-8DA3-11D5-AA62-0030657C543C).</p>

<p><a name="1018291"> </a>The call to <code>SrmExtOpen</code> returns immediately, without waiting for an incoming RFCOMM connection. To wait for incoming data, periodically call either <code>SrmReceive</code>, <code>SrmReceiveWait</code>, or <code>SrmReceiveCheck</code>.</p>

<h4 class="hcH4">
  <a name="1018294"> </a>Example
</h4>

<p><a name="1018295"> </a>The following code excerpt illustrates a call to <code>SrmExtOpen</code> that, acting as a client, creates an RFCOMM virtual serial port and connects to a known RFCOMM channel on a remote device:</p>

<div class="CodeRule"><hr></div><pre class="CodeBlock">
Err err;<a name="1018296"> </a>
SrmOpenConfigType config;<a name="1018297"> </a>
BtVdOpenParams btParams;<a name="1018298"> </a>
UInt16 btPortId;<a name="1018299"> </a>
<a name="1018300"> </a>
config.function = 0;                              // must be zero<a name="1018301"> </a>
config.drvrDataP = (MemPtr)&amp;btParams;<a name="1018302"> </a>
config.drvrDataSize = sizeof(BtVdOpenParams);<a name="1018303"> </a>
<a name="1018304"> </a>
btParams.role = btVdClient;                       // we are the client side<a name="1018305"> </a>
btParams.u.client.remoteDevAddr.address[0] = ...; // remote device addr byte 1<a name="1018306"> </a>
    ...<a name="1018307"> </a>
btParams.u.client.remoteDevAddr.address[5] = ...; // remote device addr byte 6<a name="1018308"> </a>
btParams.u.client.method = btVdUseChannelId;<a name="1018309"> </a>
btParams.u.client.u.channelId = 0x53;<a name="1018310"> </a>
<a name="1018311"> </a>
err = SrmExtOpen(<a name="1018312"> </a>
    sysFileCVirtRfComm, // type of port == RFCOMM<a name="1018313"> </a>
    &amp;config,            // port configuration params<a name="1018314"> </a>
    sizeof(config),     // size of port config params<a name="1018315"> </a>
    &amp;btPortId           // receives the id of this virtual serial port instance<a name="1018316"> </a>
);<a name="1018317"> </a>
</pre><div class="CodeRule"><hr></div>


<p><a name="1018318"> </a>Note that this code excerpt will not compile as-is; the remote Bluetooth device address has not been properly specified.</p>
<h3 class="hbH3">
  <a name="1018320"> </a>Palm-to-Palm Communication <a href="#1017445"><span class="nav">^TOP^</span></a>
</h3>


<p><a name="1018321"> </a>Most applications act as clients only. However, in the case of Palm-to-Palm applications, they may need to act as both clients and servers. In this case, the virtual serial driver should initially be configured as a server to advertise its services to the other remote device. At this point, both devices are acting as servers, advertising their services. When a user-initiated action causes one of the devices to reopen the virtual serial driver as a client, it can then discover the remote device and its advertised service&#8212;advertised through a predefined, agreed-upon UUID&#8212;so that a channel can be opened between the two devices.</p>
<h3 class="hbH3">
  <a name="1018323"> </a>How Palm OS Uses the Bluetooth Virtual Serial Driver <a href="#1017445"><span class="nav">^TOP^</span></a>
</h3>


<p><a name="1018324"> </a>Within the Palm OS, HotSync, PPP, and the Telephony Manager can all use Bluetooth, although they can only act as clients.</p>

<p><a name="1018325"> </a>For these clients, the user performs device discovery and device pairing, if appropriate, from within the Connection Panel. These clients can then consult the Connection Panel to determine the address of the remote device, the link key, and the service class to look for on the remote device. For example, if PPP is using the connection profile that indicates that the remote device is a phone or a modem, it looks for the Dialup Networking Service Class UUID. But if the profile indicates that the remote device is a PC or a LAN access point, it looks for the LAN Access Using PPP Service Class UUID.</p>

<h2 class="haH2">
  <a name="1018328"> </a>Bluetooth Exchange Library Support <a href="#1017445"><span class="nav">^TOP^</span></a>
</h2>


<p><a name="1018329"> </a>Accompanying the Bluetooth Library is the Bluetooth Exchange Library, a shared library that allows applications to support Bluetooth using the standard Exchange Manager APIs. The Bluetooth Exchange Library conforms to the Object Push and Generic Object Exchange profiles.</p>

<p><a name="1018330"> </a>For more information about the Exchange Manager, see the "Object Exchange" chapter of the <i>Palm OS Programmer's Companion</i>.</p>
<h3 class="hbH3">
  <a name="1018333"> </a>Detecting the Bluetooth Exchange Library <a href="#1017445"><span class="nav">^TOP^</span></a>
</h3>


<p><a name="1018334"> </a>To check for the presence of the Bluetooth Exchange Library, you use <code>FtrGet</code>:</p>

<div class="CodeRule"><hr></div><pre class="CodeBlock">
err = FtrGet(btexgFtrCreator,
btexgFtrNumVersion, &amp;btExgLibVersion);<a name="1018335"> </a>
</pre><div class="CodeRule"><hr></div>


<p><a name="1018336"> </a>If the Bluetooth Exchange Library is present, <code>FtrGet</code> returns <code>errNone</code>. In this case, the value pointed to by <code>btExgLibVersion</code> contains the version number of the Bluetooth Exchange Library. The format of the version number is <code>0xMMmfsbbb</code>, where <code>MM</code> is the major version, <code>m</code> is the minor version, <code>f</code> is the bug fix level, <code>s</code> is the stage, and <code>bbb</code> is the build number. Stage 3 indicates a release version of the library. Stage 2 indicates a beta release, stage 1 indicates an alpha release, and stage 0 indicates a development release. So, for example, a value of <code>0x01013000</code> would correspond to the released version 1.01 of the Bluetooth Exchange Library.</p>
<h3 class="hbH3">
  <a name="1018338"> </a>Using the Exchange Manager With Bluetooth <a href="#1017445"><span class="nav">^TOP^</span></a>
</h3>


<p><a name="1018339"> </a>Using the Exchange Manager with Bluetooth is almost exactly like using it with IRDA and SMS. The differences are as follows:</p>
<ul type="disc">
  <li><a name="1018340"> </a>The URL you use when you send an object has some special fields specific to Bluetooth.
  <li><a name="1018341"> </a>Your application may want to know the URL of the device or devices with which it is communicating. The Exchange Manager provides a way to get this information.
  <li><a name="1018342"> </a>The <code>ExgGet</code> and <code>ExgRequest</code> functions are not supported with Bluetooth.
</ul>

<p><a name="1018343"> </a>These differences are discussed further in the following sections.</p>

<h4 class="hcH4">
  <a name="1018345"> </a>Bluetooth Exchange URLs
</h4>

<p><a name="1018346"> </a>If you send objects using the Bluetooth Exchange Library and use a URL, you can send the objects to single or multiple devices at the same time depending on the way the URL is formed. A Bluetooth Exchange Library URL can have one of the following forms:</p>

<dl>
<dt><a name="1018347"> </a><code><code>_btobex:</code><i>filename</i></code></dt>
<dt><a name="1018348"> </a><code><code>_btobex://</code><i>filename</i></code></dt>
<dt><a name="1018349"> </a><code><code>_btobex://?_multi/</code><i>filename</i></code></dt>
<dd><a name="1018350"> </a>Performs a device inquiry, presents the available devices to the user, and allows the user to choose one or more devices. Sends the object to all selected devices.</dd>

<dt><a name="1018351"> </a><code><code>_btobex://?_single/</code><i>filename</i></code></dt>
<dd><a name="1018352"> </a>Performs a device inquiry, presents the available devices to the user, and allows the user to choose only one device. Sends the object to that device.</dd>

<dt><a name="1018353"> </a><code><code>_btobex://</code><i>address1</i><!-PS02-><span style="color: #000000;  font-family: Courier; font-style: normal; font-weight: normal; text-decoration: none; text-transform: none; vertical-align: baseline">[,</span><i>address2</i><!-PS02-><span style="color: #000000;  font-family: Courier; font-style: normal; font-weight: normal; text-decoration: none; text-transform: none; vertical-align: baseline">,</span> ...<code>]/</code><i>filename</i></code></dt>
<dd><a name="1018354"> </a>Sends the object to the device(s) with the specified Bluetooth device address(es). The addresses are in the form "<code>xx:xx:xx:xx:xx:xx</code>".</dd>

</dl>

<p><a name="1018355"> </a>Do not combine these URL forms. Doing so may give unintended results.</p>

<h4 class="hcH4">
  <a name="1018358"> </a>Obtaining the URL of a Remote Device
</h4>

<p><a name="1018359"> </a>For some applications you need to know the URL that addresses the remote device from which you receive data. This is especially useful for games. You can get the URL after calling <code>ExgAccept</code> using a <code>ExgControl</code> function code as shown in the following code:</p>

<div class="CodeRule"><hr></div><pre class="CodeBlock">
ExgCtlGetURLType getUrl;<a name="1018360"> </a>
UInt16 getUrlLen;<a name="1018361"> </a>
<a name="1018362"> </a>
// First get the size of the URL<a name="1018363"> </a>
getUrl.socketP = exgSocketP;<a name="1018364"> </a>
getUrl.URLP = NULL;<a name="1018365"> </a>
getUrl.URLSize = 0;<a name="1018366"> </a>
getUrlLen =  sizeof(getUrl);<a name="1018367"> </a>
ExgControl(exgSocketP, exgLibCtlGetURL, &amp;getUrl, &amp;getUrlLen);<a name="1018368"> </a>
<a name="1018369"> </a>
// Now get the URL<a name="1018370"> </a>
getUrl.URLP = MemPtrNew(getUrl.URLSize);<a name="1018371"> </a>
ExgControl(exgSocketP, exgLibCtlGetURL, &amp;getUrl, &amp;getUrlLen);<a name="1018372"> </a>
<a name="1018373"> </a>
// getUrl.URLP points to a null-terminated URL string<a name="1018374"> </a>
// describing the remote device, for example,<a name="1018375"> </a>
// "_btobex://01:23:45:67:89:ab/"<a name="1018376"> </a>
...<a name="1018377"> </a>
// Free the URL after you're done with it<a name="1018378"> </a>
MemPtrFree(getUrl.URLP);<a name="1018379"> </a>
</pre><div class="CodeRule"><hr></div>

<h3 class="hbH3">
  <a name="1018380"> </a>ExgGet and ExgRequest <a href="#1017445"><span class="nav">^TOP^</span></a>
</h3>


<p><a name="1018382"> </a>The Bluetooth Exchange Library does not support the pull functions provided by <code>ExgGet</code> and <code>ExgRequest</code>. If you want to perform these functions, you must use the general Bluetooth Library APIs. See <a href="BTCompanion.html#1017830">"Developing Bluetooth-Enabled Applications"</a>.</p>

<p><a name="1018388"> </a></p>
&nbsp;<br>
</div>
<!--END CONTENT-->

</td>
<td width="5">&nbsp;&nbsp;</td>
</tr>

</table>

<!-- BEGIN FOOTER -->
<table width="100%" border="0" cellspacing="0" cellpadding="0">
<tr>
<td width="7" rowspan="2"><img name="index_x" src="images/shim.gif" width="7" height="33" border="0" alt=""></td>
<td align="left"><img name="dashes" src="images/dashes.gif" width="744" height="3" border="0" alt=""></td>
<td width="10" rowspan="2"><img name="index_x" src="images/shim.gif" width="10" height="33" border="0" alt=""></td>
</tr>
<tr>
<td align="center">
<p class="footer">
Copyright © 1996-2004, PalmSource, Inc. and its affiliates.  All rights reserved. <br>
<a href="http://www.palmsource.com/contact/">Write Us</a> | <a href="http://www.palmos.com/dev/training/">Training</a> | <a href="http://www.palmos.com/dev/support/kb/">Knowledge Base</a> | <a href="Companion2Front.html" target="_blank">Legal</a></p>
<br>
<!--BEGIN BOOK NAVIGATION-->
<p class="nav">
<A href="http://www.palmos.com/dev/support/docs/">Documentation</a>&nbsp;&nbsp;|&nbsp;&nbsp;
<a href="Companion2TOC.html">Table of Contents</a>&nbsp;&nbsp;
             |&nbsp;&nbsp;<a href="SerialCommunication.html">&lt;&nbsp;Previous</a>&nbsp;&nbsp;
             |&nbsp;&nbsp;<a href="NetworkCommunication.html">Next&nbsp;&gt;</a>&nbsp;&nbsp;
             |&nbsp;&nbsp;<a href="Companion2IX.html">Index</a>
</p>
</td>
</tr>
</table>
<!-- END FOOTER -->

</body>
</html>