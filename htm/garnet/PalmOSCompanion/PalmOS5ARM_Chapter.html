<html>
<head>
<title>(68K) Palm OS Garnet ARM Programming  | Palm OS&#174; Programmer's Companion</title> 
<link href="psi_devpubs.css" rel="stylesheet" type="text/css">

<!-- BEGIN META DATA -->
<meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
<META NAME="PSITEMPLATE" CONTENT="1006-007 PalmSource_HTML_2003 20041101">
<META NAME="GENERATOR" CONTENT="Quadralay WebWorks AutoMap 2003 for FrameMaker 8.0.6.2138">
<META NAME="LASTUPDATED" CONTENT="11/22/04 10:43:29">
<!-- END META DATA -->
</head>

<body bgcolor="#ffffff" text="#000000" leftmargin="0" topmargin="0" marginwidth="0" marginheight="0">
<a name="920544"></a>

<!-- BEGIN TOPNAV -->
<table width="100%" border="0" cellspacing="0" cellpadding="0">
<tr>
<td><img src="images/shim.gif" width="7" height="75" border="0" alt=""></td>
<td align="left"><table border="0" cellpadding="0" cellspacing="0" width="744">
<tr>
<td><img name="index_r2_c1" src="images/shim.gif" width="25" height="75" border="0" alt=""></td>
<td valign="top"><table border="0" cellpadding="0" cellspacing="0" width="96">
<tr>
<td><img name="index_r2_c4" src="images/shim.gif" width="96" height="15" border="0" alt=""></td>
</tr>
<tr>
<td><a href="http://www.palmsource.com/"><img name="ps_logo" src="images/ps_logo.gif" width="96" height="54" border="0" alt=""></a></td>
</tr>

</table>
</td>

<td><table border="0" cellpadding="0" cellspacing="0" width="30">
<td><img name="index_x" src="images/shim.gif" width="30" height="75" border="0" alt=""></td>
</table></td>

<!--BEGIN MASTHEAD-->
<td><table border="0" cellpadding="0" cellspacing="0" width="96">
<tr>
<td><img name="index_x" src="images/shim.gif" width="615" height="5" border="0" alt=""></td>
</tr>
<tr>
<td>
<!--BEGIN BOOK NAVIGATION-->
<span class="nav">
<A href="http://www.palmos.com/dev/support/docs/">Documentation</a>&nbsp;&nbsp;|&nbsp;&nbsp;
<a href="CompanionTOC.html">Table of Contents</a>&nbsp;&nbsp;
             |&nbsp;&nbsp;<a href="Security.html">&lt;&nbsp;Previous</a>&nbsp;&nbsp;
             |&nbsp;&nbsp;<a href="DebuggingStrats.html">Next&nbsp;&gt;</a>&nbsp;&nbsp;
             |&nbsp;&nbsp;<a href="CompanionIX.html">Index</a>
</span>
<!--END BOOK NAVIGATION-->
</tr>
<tr>
<td>
<!--BEGIN PAGE TITLE-->
<h2 class="PageTitle">14 &nbsp;&nbsp;
Palm OS Garnet ARM Programming</h2></td>
<!--END PAGE TITLE-->
</tr>
<tr>
<td>
<!--BEGIN BOOK TITLE-->
<p class="BookTitle">Palm OS&#174; Programmer's Companion</p>
<p class="SubTitle">Volume I </p>
<!--END BOOK TITLE-->
</td>
</tr>
<tr>
<td><img name="index_x" src="images/shim.gif" width="615" height="5" border="0" alt=""></td>
</tr>
</table>
</td>
<!--END MASTHEAD-->
</tr>
</table>
<img name="dashes" src="images/dashes.gif" width="744" height="3" border="0" alt=""></td>
</tr>
</table>
<!-- END TOPNAV -->

<table width="100%" border="0" cellspacing="0" cellpadding="0">
<tr>
<td valign="top" width="5"><img name="index_x" src="images/shim.gif" width="5" height="33" border="0" alt=""></td>

<!--BEGIN SIDETOC-->
<td valign="top" width="175">
<div id="sidetoc" valign="bottom">
<h1 class="SideTOC1"><a href="PalmOS5ARM_Chapter.html">14  Palm OS Garnet ARM Programming </a></h1>

   <h2 class="SideTOC2"><a href="#917982">
   Understanding Palm OS Garnet and ARM </a></h2>

      <h3 class="SideTOC3"><a href="#917994">
      Palm Application Compatibility Environment</a></h3>

   <h2 class="SideTOC2"><a href="#918011">
   Using ARM-Native Subroutines </a></h2>

   <h2 class="SideTOC2"><a href="#918026">
   Calling ARM-Native Subroutines </a></h2>

   <h2 class="SideTOC2"><a href="#918044">
   Writing ARM-Native Subroutines </a></h2>

      <h3 class="SideTOC3"><a href="#918074">
      Isolate the Performance-Critical Area in Your 68K Application </a></h3>

      <h3 class="SideTOC3"><a href="#918084">
      Convert the ARM-Native Subroutine to Take One Argument </a></h3>

      <h3 class="SideTOC3"><a href="#918090">
      Handle 68K and ARM Technical Differences </a></h3>

      <h3 class="SideTOC3"><a href="#920755">
      Test the ARM-Native Subroutine </a></h3>

      <h3 class="SideTOC3"><a href="#918201">
      Build the ARM-Native Subroutine </a></h3>

      <h3 class="SideTOC3"><a href="#919997">
      Embed the ARM Code in a 68K Application</a></h3>

   <h2 class="SideTOC2"><a href="#920317">
   Calling Palm OS Functions From ARM Code</a></h2>

      <h3 class="SideTOC3"><a href="#920332">
      Calling a Trap</a></h3>

      <h3 class="SideTOC3"><a href="#920388">
      Calling a Function Using a Function Pointer</a></h3>

   <h2 class="SideTOC2"><a href="#918214">
   Overview of Sample Files </a></h2>

      <h3 class="SideTOC3"><a href="#918217">
      ARM-Native Subroutine Sample Files </a></h3>

      <h3 class="SideTOC3"><a href="#918264">
      Windows DLL Sample Files </a></h3>

</div>
</td>

<td width="5">&nbsp;&nbsp;</td>
<td width="2" background="images/index_r8_c10.gif"><img src="images/shim.gif" width="2" height="75" border="0" alt=""></td>
<td width="5">&nbsp;&nbsp;</td>

<!--END SIDETOC-->

<td valign="top">

<!--BEGIN CONTENT-->
<div id="content" valign="bottom">
<p><a name="917977"> </a>This chapter describes how to write portions of your application using ARM-native code. Most Palm OS<sup>&#174;</sup> Garnet applications do not need native ARM code and will not benefit from using native ARM code. If you have an application that performs adequately on Palm OS Garnet, then you do not need to read this chapter. </p>

<p><a name="917979"> </a>This chapter is intended for developers who have applications that require a performance improvement in order to perform adequately on Palm OS Garnet. It is not intended for all Palm OS application developers.</p>

<h2 class="haH2">
  <a name="917982"> </a>Understanding Palm OS Garnet and ARM  <a href="#920544"><span class="nav">^TOP^</span></a>
</h2>


<p><a name="917984"> </a>Palm OS Garnet is a complete port of the Palm operating system from a 68K processor to an ARM processor. </p>

<dl>
<dt><a name="917986"> </a><b>68K</b></dt>
<dd><a name="917988"> </a>The term <b>68K processor</b> refers to the family of Motorola 68000 processors. </dd>

<dt><a name="917990"> </a><b>ARM</b></dt>
<dd><a name="918941"> </a>The term <b>ARM processor</b> refers to the family of Advanced RISC Machine processors. An ARM processor is a type of 4-byte RISC processor, and is available from many sources. </dd>

</dl>

<p><a name="918942"> </a>Starting in Palm OS Garnet, the entire operating system runs natively on the ARM processor. When an application calls a Palm OS API function, the API function runs at the full speed of the ARM processor. Because most applications spend the bulk of their time executing operating system functions, they get the performance benefit of the ARM processor with no effort. </p>
<h3 class="hbH3">
  <a name="917994"> </a>Palm Application Compatibility Environment <a href="#920544"><span class="nav">^TOP^</span></a>
</h3>


<p><a name="919436"> </a>Palm OS Garnet includes the Palm Application Compatibility Environment (<b>PACE</b>), within which all Palm OS applications run. PACE emulates the 68K-family processor traditionally used in Palm Powered<sup>&#8482;</sup> handhelds, enabling both new and existing applications to run on Palm Powered handhelds that employ an ARM processor.</p>

<p><a name="917997"> </a>Because Palm OS functions are native and not emulated, PACE provides excellent performance for most 68K applications. As a result, most 68K applications will not benefit significantly from being rewritten for ARM. </p>

<p><a name="918001"> </a><a href="PalmOS5ARM_Chapter.html#918003">Figure 14.1</a> shows how PACE provides a compatibility layer between 68K applications and Palm OS Garnet running natively on ARM. </p>

<p class="FFigureCaption">
  <a name="918003"> </a><b>Figure 14.1&nbsp;&nbsp;Palm Application Compatibility Environment</b>
</p>
<div align="left"><img src="images/PACEBlockDiagram.gif" border="0" hspace="0" vspace="0">
</div>

<p><a name="918008"> </a>Because an application's 68K code is emulated in PACE, certain algorithms&#8212;such as those performing data encryption or compression&#8212;may benefit from being rewritten in native ARM instructions. </p>

<h2 class="haH2">
  <a name="918011"> </a>Using ARM-Native Subroutines  <a href="#920544"><span class="nav">^TOP^</span></a>
</h2>


<p><a name="918012"> </a>If you have a processor-intensive 68K algorithm, writing an ARM-native subroutine may improve the performance of your 68K application on Palm OS Garnet. </p>

<p><a name="918014"> </a>An <b>ARM-native subroutine</b> (also called a <b>PACE Native Object</b> or <b>PNO</b>) is not a self-contained application; it is a native ARM function that the 68K application can call as a subroutine. The ARM-native subroutine allows the application to use the full processing power of the ARM-based hardware. </p>

<p><a name="918018"> </a><a href="PalmOS5ARM_Chapter.html#918020">Figure 14.2</a> shows how your 68K application calls your ARM-native subroutine.</p>

<p class="FFigureCaption">
  <a name="918020"> </a><b>Figure 14.2&nbsp;&nbsp;Using PceNativeCall to Call an ARM-Native Subroutine</b>
</p>
<div align="left"><img src="images/PceNativeCall.gif" border="0" hspace="0" vspace="0">
</div>

<h2 class="haH2">
  <a name="918026"> </a>Calling ARM-Native Subroutines  <a href="#920544"><span class="nav">^TOP^</span></a>
</h2>


<p><a name="918027"> </a>To call an ARM-native subroutine from your 68K application, you use the new function <a href="../PalmOSReference/MiscSys.html#1038379"><code>PceNativeCall</code></a>. </p>

<p><a name="918032"> </a>The <code>PceNativeCall</code> function takes two arguments:</p>
<ol type="1">
  <li value="1"><a name="918033"> </a>A pointer to the ARM-native subroutine, generally but not necessarily stored in a code resource. 
   <p><a name="918034"> </a>If the ARM-native subroutine is stored in a resource, the 68K application can simply obtain the resource using <a href="../PalmOSReference/DataAndResourceManager.html#1010054"><code>DmGetResource</code></a> and lock it with <a href="../PalmOSReference/MemoryManager.html#1016446"><code>MemHandleLock</code></a> to get a pointer to the ARM-native subroutine. </p>
  <li value="2"><a name="918036"> </a>A pointer to a data block, allowing the 68K application to exchange data with the ARM-native subroutine. 
</ol>

<p><a name="919812"> </a>Before calling <code>PceNativeCall</code> you must test the processor type:</p>
<ul type="disc">
  <li><a name="919819"> </a>If the processor is ARM, the 68K application should call the ARM function.
  <li><a name="919820"> </a>If the processor is an x86 family processor (that is, the application is running in Palm OS Simulator on Windows), the 68K application should call the Windows DLL that represents the ARM function.
  <li><a name="919821"> </a>Otherwise, the 68K application should either call a 68K version of the function or fail gracefully if the functionality cannot be reasonably incorporated into a 68K application. Note that in this instance your application may be running on a version of Palm OS earlier than Garnet.
</ul>

<p><a name="919825"> </a><a href="PalmOS5ARM_Chapter.html#919827">Listing 14.1</a> illustrates this process. For simplicity, in this example no parameters are passed to the ARM function.</p>
<p class="CCodeCaption">
  <a name="919827"> </a><b>Listing 14.1&nbsp;&nbsp;Calling an ARM function</b>
</p>

<div class="CodeRule"><hr></div><pre class="CodeBlock">
static UInt32 PceNativeResourceCall(DmResType resType, DmResID resID,
char *DLLEntryPointP, void *userCPB) {<a name="919828"> </a>
    UInt32    processorType;<a name="919829"> </a>
    MemHandle armH;<a name="919830"> </a>
    MemPtr    armP;<a name="919831"> </a>
    UInt32    result;<a name="919832"> </a>
<a name="919833"> </a>
    // get the processor type<a name="919834"> </a>
    FtrGet(sysFileCSystem, sysFtrNumProcessorID, &amp;processorType);<a name="919835"> </a>
<a name="919836"> </a>
    if (sysFtrNumProcessorIsARM(processorType)){<a name="919837"> </a>
        // running on ARM; call the actual ARM resource<a name="919838"> </a>
        armH = DmGetResource(resType, resID);<a name="919839"> </a>
        armP = MemHandleLock(armH);<a name="919840"> </a>
<a name="919841"> </a>
        result = PceNativeCall(armP, userCPB);<a name="919842"> </a>
<a name="919843"> </a>
        MemHandleUnlock(armH);<a name="919844"> </a>
        DmReleaseResource(armH);<a name="919845"> </a>
    } else if (processorType == sysFtrNumProcessorx86) {<a name="919846"> </a>
        // running on Simulator; call the DLL<a name="919847"> </a>
        result = PceNativeCall((NativeFuncType *)DLLEntryPointP, userCPB);<a name="919848"> </a>
    } else {<a name="919849"> </a>
        // some other processor; fail gracefully<a name="919850"> </a>
        ErrNonFatalDisplay("Unsupported processor type");<a name="919851"> </a>
        result = -1;<a name="919852"> </a>
    }<a name="919853"> </a>
<a name="919854"> </a>
    return result;<a name="919855"> </a>
}<a name="919856"> </a>
</pre><div class="CodeRule"><hr></div>


<p><a name="919857"> </a>The <code>#defines</code> for the various processor types (all of which are named <code>sysFtrNumProcessor...</code>) can be found in <code>SystemMgr.h</code>.</p>

<h2 class="haH2">
  <a name="918044"> </a>Writing ARM-Native Subroutines  <a href="#920544"><span class="nav">^TOP^</span></a>
</h2>


<p><a name="918045"> </a>The ARM-native subroutine needs to include the proper prototype and the ARM code you want it to contain. A sample ARM-native subroutine, called <code>armlet-simple.c</code>, is included in the SDK to show the minimum amount of code required. </p>

<p><a name="918047"> </a>The ARM-native subroutine can also call Palm OS API functions, and can call back into 68K code. See <a href="PalmOS5ARM_Chapter.html#920317">"Calling Palm OS Functions From ARM Code."</a> The file <code>armlet-oscall.c</code>, also included in the SDK, provides an example of calling a Palm OS function. </p>

<p><a name="918049"> </a>The following sections explain the steps for writing an ARM-native subroutine: </p>
<ol type="1">
  <li value="1"><a name="918055"> </a><a href="PalmOS5ARM_Chapter.html#918074"></a><a href="PalmOS5ARM_Chapter.html#918074">"Isolate the Performance-Critical Area in Your 68K Application"</a>
  <li value="2"><a name="918059"> </a><a href="PalmOS5ARM_Chapter.html#918084">"Convert the ARM-Native Subroutine to Take One Argument"</a>
  <li value="3"><a name="918064"> </a><a href="PalmOS5ARM_Chapter.html#918090">"Handle 68K and ARM Technical Differences"</a>
  <li value="4"><a name="920710"> </a><a href="PalmOS5ARM_Chapter.html#920755">"Test the ARM-Native Subroutine"</a>
  <li value="5"><a name="918072"> </a><a href="PalmOS5ARM_Chapter.html#918201">"Build the ARM-Native Subroutine"</a> 
  <li value="6"><a name="920014"> </a><a href="PalmOS5ARM_Chapter.html#919997">"Embed the ARM Code in a 68K Application"</a>
</ol>
<h3 class="hbH3">
  <a name="918074"> </a>Isolate the Performance-Critical Area in Your 68K Application  <a href="#920544"><span class="nav">^TOP^</span></a>
</h3>


<p><a name="918075"> </a>To decide which algorithms will benefit from being written as an ARM-native subroutine, you should start by doing a performance analysis of your 68K application. If your 68K application runs "fast enough" when you do your performance testing, then there is no reason to write an ARM-native subroutine. </p>
<ul type="disc">
  <li><a name="918078"> </a>Test your 68K application using Palm OS Simulator. Palm OS Simulator is the easiest and best way to test your application for Palm OS Garnet compatibility. Running your application on Palm OS Simulator will show you whether any algorithms behave differently on Palm OS Garnet. 
   <p><a name="918079"> </a>Any algorithms that do extensive calculations, such as data encryption or compression, may run slower on Palm OS Simulator. If you notice a performance difference, then you have found a candidate algorithm that might benefit from being rewritten as an ARM-native subroutine. </p>
  <li><a name="918080"> </a>Test your 68K application using the profiling version of Palm OS Emulator. The profiling version of Palm OS Emulator monitors your application's execution, generating statistics that show which algorithms take the most time. 
   <p><a name="918082"> </a>Emulator can help you pinpoint slow algorithms, but performance on Emulator will not indicate performance on Palm OS Garnet. Emulator does not include the Palm OS Garnet PACE component, but Simulator does. </p>
</ul>

<p><a name="919925"> </a>Functions that make many calls to the operating system typically aren't good candidates to make ARM-native because it is difficult to debug both the "68K side" and the "ARM side" of an application, and because of the overhead involved in byte-swapping the parameters.</p>
<h3 class="hbH3">
  <a name="918084"> </a>Convert the ARM-Native Subroutine to Take One Argument  <a href="#920544"><span class="nav">^TOP^</span></a>
</h3>


<p><a name="918085"> </a>The function <a href="../PalmOSReference/MiscSys.html#1038379"><code>PceNativeCall</code></a>, which you use to call an ARM-native subroutine from your 68K application, takes only two arguments: a pointer to the ARM-native subroutine and a pointer to a data block. As a result, it will be easier to write your subroutine if it takes a single input argument. </p>

<p><a name="919948"> </a>ARM functions that are to be called from the 68K side&#8212;that is, functions that serve as entry points into your ARM code&#8212;must use the following function prototype (defined in <code>PceNativeCall.h</code>):</p>

<div class="CodeRule"><hr></div><pre class="CodeBlock">
typedef unsigned long NativeFuncType (const void *emulStateP,
void *userData68KP, Call68KFuncType *call68KFuncP)<a name="919949"> </a>
</pre><div class="CodeRule"><hr></div>


<p><a name="919950"> </a>The function parameters are defined as follows:</p>

<dl>
<dt><a name="919951"> </a><code>&rarr;  <i><code>emulStateP</code></i></code></dt>
<dd><a name="919952"> </a>A pointer to the (opaque) PACE emulation state. This pointer is used when calling Palm OS functions and application callbacks; see <a href="PalmOS5ARM_Chapter.html#920317">"Calling Palm OS Functions From ARM Code"</a> for more information.</dd>

<dt><a name="919956"> </a><code>&harr;  <i><code>userData68KP</code></i></code></dt>
<dd><a name="919957"> </a>The <code>userDataP</code> argument that was passed in to <code>PceNativeCall</code>, byte-swapped so it can be dereferenced directly by the ARM code. See <a href="PalmOS5ARM_Chapter.html#918090">"Handle 68K and ARM Technical Differences"</a> for tips on accessing the data block indicated by this pointer.</dd>

<dt><a name="919961"> </a><code>&rarr;  <i><code>call68KFunc</code></i></code></dt>
<dd><a name="919962"> </a>A hook to call back into the PACE emulated environment from ARM code. It is used for both OS function calls and application callbacks. See <a href="PalmOS5ARM_Chapter.html#920388">"Calling a Function Using a Function Pointer"</a> for more information.</dd>

</dl>

<p><a name="919966"> </a>The name of your ARM entry-point function must be <code>PNOMain</code>.</p>

<div><hr>
  <a name="920800"> </a> <b>IMPORTANT: </b> If your ARM entry-point function isn't named <code>PNOMain</code>, the compiler will generate a message such as "***[ARMC1000.bin.elf]Error 1". If you use Palm OS Developer Suite and create a "Managed Make 68K PNO C/C++ Project" with the "Simple" template, do not change the name of the entry point function.
<hr>
</div>

<p><a name="920798"> </a>ARM entry-point functions should return a value that is meaningful to the 68K side, since that value is passed back to the calling code. If no value is meaningful, return 0. Both register A0 and D0 are set to this return value, making it meaningful to code that is expecting either a pointer or an immediate result.</p>
<h3 class="hbH3">
  <a name="918090"> </a>Handle 68K and ARM Technical Differences  <a href="#920544"><span class="nav">^TOP^</span></a>
</h3>


<p><a name="918091"> </a>When implementing the ARM-native subroutine, you should be aware of how the 68K processor and the ARM processor are different. The following sections describe some technical considerations that you need to handle in your ARM-native subroutine: </p>
<ul type="disc">
  <li><a name="918095"> </a><a href="PalmOS5ARM_Chapter.html#918105">"Big Endian and Little Endian"</a> 
  <li><a name="918099"> </a><a href="PalmOS5ARM_Chapter.html#918125">"Integer Alignment"</a> 
  <li><a name="918103"> </a><a href="PalmOS5ARM_Chapter.html#918182">"Structure Packing"</a> 
</ul>

<h4 class="hcH4">
  <a name="918105"> </a>Big Endian and Little Endian 
</h4>

<p><a name="918107"> </a>The 68K processor uses big-endian integers; the ARM processor uses little endian. <b>Big</b> and <b>little</b> refer to the order in which the bytes are stored in a multi-byte integer. In big-endian integers, the most significant byte is the first; in little-endian integers, the most significant byte is the last byte.</p>

<p><a name="918109"> </a>This means 2- and 4-byte integers are stored in reverse byte order, and thus must be byte-swapped when exchanged between the ARM and 68K processors. Endianness is only relevant in the context of 2- and 4-byte integers (including pointers). Other types of data, such as strings, don't need to be byte-swapped.</p>

<p><a name="918112"> </a>PACE automatically byte-swaps the <code>PceNativeCall</code> function's <code>userData68KP</code> argument, so it can be de-referenced immediately from within the ARM function with no modification. PACE also automatically byte-swaps the 4-byte return value that is passed back to the calling function.</p>

<p><a name="918114"> </a>PACE doesn't byte-swap any of the data pointed to by the <code>userData68KP</code> argument because PACE doesn't know anything about what kind of data is being passed. (Remember, only 2- and <br>4-byte integers need to be byte-swapped, and the <code>userData68KP</code> argument is simply a pointer to arbitrary data.) </p>

<h5 class="hdH5">
  <a name="918115"> </a>Byte-Swapping Macros for Use in ARM-Native Subroutines 
</h5>

<p><a name="918117"> </a><code>Endianutils.h</code> contains convenience macros to byte-swap 2- and 4-byte integers in your ARM-native subroutine: </p>

<dl>
<dt><a name="918119"> </a><code>ByteSwap16(integer)</code></dt>
<dd><a name="920869"> </a>Byte-swaps a 2-byte (16-bit) integer value. </dd>

<dt><a name="918121"> </a><code>ByteSwap32(integer)</code></dt>
<dd><a name="920889"> </a>Byte-swaps a 4-byte (32-bit) integer value. </dd>

</dl>

<p><a name="918122"> </a>ARM-native subroutines are responsible for byte-swapping integers in the data block as necessary.</p>

<h4 class="hcH4">
  <a name="918125"> </a>Integer Alignment 
</h4>

<p><a name="918126"> </a>ARM processors require that 4-byte integers be aligned on a 4-byte boundary. 68K processors require only even address (2-byte) alignment. </p>

<p><a name="918128"> </a>To handle integer alignment differences, you have the two following options: </p>
<ol type="1">
  <li value="1"><a name="918129"> </a>Allocate data using <a href="../PalmOSReference/MemoryManager.html#1017176"><code>MemPtrNew</code></a>, carefully declaring data structures with appropriate integer alignment. 
   <p><a name="918130"> </a><code>MemPtrNew</code> always returns a 4-byte aligned address, so you can be sure that the data starts on a 4-byte boundary. However, you must also be careful that the data itself is properly aligned. When aligning data objects, recognize that 68K and ARM processors align 4-byte objects differently, as shown in <a href="PalmOS5ARM_Chapter.html#918140">Table 14.1</a>. </p>
</ol>

<p class="caption"><a name="918140"> </a><b>Table 14.1&nbsp;&nbsp;Default Data Object Alignment  </b></p>
<div class="tablediv"><table cellspacing="0" class="tTable">

  <tr valign="top">
    <th><p class="tt"><a name="918146"> </a><b>Data Object Size </b></p>
    </th>
    <th><p class="tt"><a name="918148"> </a><b>68K Processor Alignment </b></p>
    </th>
    <th><p class="tt"><a name="918150"> </a><b>ARM Processor </b></p>
<p class="tt"><a name="918151"> </a><b>Alignment </b></p>
    </th>
  </tr>
  <tr valign="top">
    <td><p class="tt"><a name="918153"> </a>1 byte </p>
    </td>
    <td><p class="tt"><a name="918155"> </a>Any address </p>
    </td>
    <td><p class="tt"><a name="918157"> </a>Any address </p>
    </td>
  </tr>
  <tr valign="top">
    <td><p class="tt"><a name="918159"> </a>2 bytes </p>
    </td>
    <td><p class="tt"><a name="918161"> </a>2-byte alignment (even address) </p>
    </td>
    <td><p class="tt"><a name="918163"> </a>2-byte alignment (even address) </p>
    </td>
  </tr>
  <tr valign="top">
    <td><p class="tt"><a name="918165"> </a>4 bytes</p>
    </td>
    <td><p class="tt"><a name="918167"> </a>2-byte alignment (even address) </p>
    </td>
    <td><p class="tt"><a name="918169"> </a>4-byte alignment (address is a multiple of 4) </p>
    </td>
  </tr>
</table>

</div>

   <p><a name="918171"> </a>If a 4-byte data object is not properly aligned, the ARM processor may attempt to access the object using an address that is a multiple of 4, resulting in a loss of data. </p>
<ol type="1">
  <li value="2"><a name="918173"> </a>Copy 4-byte integers into local variables before using them. 
   <p><a name="918174"> </a><code>Endianutils.h</code> contains convenience macros that you can use to read and write 4-byte values to and from local variables while simultaneously byte-swapping them: </p>
  <ul type="disc">
    <li><a name="918176"> </a><code>Read68KUnaligned32(address)</code> 
      <p><a name="918177"> </a>Reads a value from a specified <code>address</code>. </p>
    <li><a name="918179"> </a><code>Write68KUnaligned32(address, value)</code>
      <p><a name="918180"> </a>Writes a specified <code>value</code> to a specified <code>address</code>. </p>
  </ul>
</ol>

<h4 class="hcH4">
  <a name="918182"> </a>Structure Packing 
</h4>

<p><a name="918184"> </a>Different compilers handle the automatic padding of structures differently. Some compilers automatically add padding bytes to align structures on a given byte boundary depending on the compiler options specified. Use care when declaring structures, or make a local copy of any structure that you use. </p>
<h3 class="hbH3">
  <a name="920755"> </a>Test the ARM-Native Subroutine  <a href="#920544"><span class="nav">^TOP^</span></a>
</h3>


<p><a name="920756"> </a>The ARM-native subroutine will run on Palm OS Garnet on ARM hardware. However, Palm OS Simulator does not run ARM-native code. Instead, Simulator provides an implementation of Palm OS Garnet running on Microsoft Windows. As a result, to test your ARM-native subroutine on Simulator, you need to build the subroutine as a Windows DLL. Simulator's implementation of PACE is built to recognize a subroutine call as a call into a DLL.</p>

<p><a name="920759"> </a>The SDK includes a sample application that builds a DLL with one entry point which has the same function as the sample ARM-native subroutine also included in the SDK.</p>

<p><a name="920760"> </a>When calling a DLL, the first argument passed to <code>PceNativeCall</code> is a pointer to the name of a DLL and the name of the entry point within that DLL that is to be executed, separated by a null character and terminated with a null character (for example, a pointer to the character string <code>"test.dll\0EntryPoint"</code>). </p>

<p><a name="920761"> </a>By default, Simulator will look for the DLL in the directory where <code>PalmSim.exe</code> is running. If you want to place the DLL in a different location, you should specify the full path of the ARM-native subroutine DLL name (for example, <code>"c:\\projects\\armletdll\\test.dll\0EntryPoint"</code>). </p>

<p><a name="920762"> </a>Your 68K application should check the processor type:</p>
<ul type="disc">
  <li><a name="920763"> </a>If the processor is ARM, the 68K application should call the ARM-native subroutine.
  <li><a name="920764"> </a>If the processor is Windows, the 68K application should call the Windows DLL. 
</ul>

<p><a name="920765"> </a>Otherwise, the 68K application should call the 68K version of the subroutine, which assumes the application is running on an earlier version of Palm OS. </p>
<h3 class="hbH3">
  <a name="918201"> </a>Build the ARM-Native Subroutine  <a href="#920544"><span class="nav">^TOP^</span></a>
</h3>


<p><a name="918202"> </a>You will need to use an ARM compiler to build the ARM-native subroutine. PalmSource, Inc. does not provide or support an ARM compiler or development environment, but several are available, such as ARM Developer Suite (ADS) and gcc. </p>

<p><a name="918206"> </a>The compiled object file for the ARM-native subroutine must be linked with the 68K application as a raw binary file. For calculating address offsets, it is generally easiest to put the entry point first in the raw binary file. </p>
<h3 class="hbH3">
  <a name="919997"> </a>Embed the ARM Code in a 68K Application <a href="#920544"><span class="nav">^TOP^</span></a>
</h3>


<p><a name="919998"> </a>Regardless of the mechanism that you use to generate the ARM binary, there are a couple of different ways to get it into a <code>.prc</code> file:</p>
<ul type="disc">
  <li><a name="920830"> </a>Using Palm OS Developer Suite, create a 68K PNO C/C++ project. A Managed Make project will automatically incorporate the ARM binary into your application. A Standard Make project can be set up to do the same.
  <li><a name="919999"> </a>Use CodeWarrior or a tool such as PilRC to place the raw ARM binary into a resource file. Then simply include this resource file in your 68K project. 
  <li><a name="920000"> </a>Copy the resulting binary data into a different resource file as hex data. Use a hex dump utility to process the ARM binary file into a resource.
  <li><a name="920001"> </a>Include the ARM code directly in your application's source as integer arrays. Note, however, that the arrays are interpreted as big-endian by the 68K compiler, and as little-endian by the ARM processor. Thus you must byte swap the integer values to get appropriate opcodes. Also, the array itself must be 4-byte aligned in your source, so insure that your compiler settings are appropriate to produce this.
</ul>

<h2 class="haH2">
  <a name="920317"> </a>Calling Palm OS Functions From ARM Code <a href="#920544"><span class="nav">^TOP^</span></a>
</h2>


<p><a name="920318"> </a>In Palm OS Garnet, native ARM code can call back into the 68K world, either to call Palm OS functions or to call developer-provided callbacks. A single entry point, <code>Call68KFuncType</code>, provides the mechanism for calling both developer-specified 68K functions and OS functions through traps. This function is declared in <code>PceNativeCall.h</code> as follows:</p>

<div class="CodeRule"><hr></div><pre class="CodeBlock">
typedef unsigned long Call68KFuncType(const void *emulStateP,
unsigned long trapOrFunction, const void *argsOnStackP,
unsigned long argsSizeAndwantA0)<a name="920319"> </a>
</pre><div class="CodeRule"><hr></div>


<p><a name="920320"> </a>The function parameters are defined as follows:</p>

<dl>
<dt><a name="920321"> </a><code>&rarr;  <i><code>emulStateP</code></i></code></dt>
<dd><a name="920322"> </a>Pointer to the PACE emulation state. Supply the pointer that was passed to your ARM function by PACE.</dd>

<dt><a name="920323"> </a><code>&rarr;  <i><code>trapOrFunction</code></i></code></dt>
<dd><a name="920325"> </a>The trap number AND'ed with <code>kPceNativeTrapNoMask</code>, or a pointer to the function to call. Any value less than <code>kPceNativeTrapNoMask</code> is treated as a trap number.</dd>

<dt><a name="920326"> </a><code>&rarr;  <i><code>argsOnStackP</code></i></code></dt>
<dd><a name="920327"> </a>Native (little-endian) pointer to a block of memory to be copied to the 68K stack prior to the function call. This memory normally contains the arguments for the 68K function being called. <code>Call68KFuncType</code> pops these values from the 68K stack before returning.</dd>

<dt><a name="920328"> </a><code>&rarr;  <i><code>argsSizeAndwantA0</code></i></code></dt>
<dd><a name="920329"> </a>The number of bytes, in little-endian format, from <code>argsOnStackP</code> that are to be copied to the 68K emulator stack. If the function or trap returns its result in 68K register A0 (as when the result is a pointer type), you must OR the byte count with <code>kPceNativeWantA0</code>.</dd>

</dl>

<p><a name="920330"> </a>The return value from the 68K function (passed either in the 68K register D0 or A0) is returned as the result of this function, based on <code>argsSizeAndwantA0</code>. It is returned in native (little-endian) form.</p>

<p><a name="920331"> </a>Because of the amount of effort involved in getting parameters byte-swapped and properly aligned, if your ARM code routinely needs to call a series of operating system functions you may find it easier to write a small 68K callback function that calls the operating system functions, and then call this 68K function instead.</p>
<h3 class="hbH3">
  <a name="920332"> </a>Calling a Trap <a href="#920544"><span class="nav">^TOP^</span></a>
</h3>


<p><a name="920336"> </a><a href="PalmOS5ARM_Chapter.html#920338">Listing 14.2</a> shows how to call an operating system function from ARM native code using the function's trap number. This sample calls <code>MemPtrNew</code> to allocate a block of 10 bytes, initializes that block, and returns it as the result of the ARM function.</p>
<p class="CCodeCaption">
  <a name="920338"> </a><b>Listing 14.2&nbsp;&nbsp;Calling a Palm OS function from ARM code</b>
</p>

<div class="CodeRule"><hr></div><pre class="CodeBlock">
/* This armlet makes a call (through PACE) to MemPtrNew to allocate a buffer. <a name="920339"> </a>
 * The arguments to the OS function (here just size) must be on the stack, and<a name="920340"> </a>
 * must be in big-endian format.<a name="920341"> </a>
 */<a name="920342"> </a>
<a name="920343"> </a>
#include "PceNativeCall.h"<a name="920344"> </a>
<a name="920345"> </a>
#include "endianutils.h" // byte-swapping macros<a name="920346"> </a>
<a name="920347"> </a>
// from CoreTraps.h<a name="920348"> </a>
#define sysTrapMemPtrNew 0xA013 // we need this in order to call into MemPtrNew<a name="920349"> </a>
<a name="920350"> </a>
// prototype for our OS call convenience function<a name="920351"> </a>
void *PalmOS_MemPtrNew (const void *emulStateP, Call68KFuncType *call68KFuncP,<a name="920352"> </a>
unsigned long sizeLE);<a name="920353"> </a>
<a name="920354"> </a>
// This is the main entry point into the armlet.  It's the first function in<a name="920355"> </a>
// the file so we can calculate its address easily.<a name="920356"> </a>
unsigned long NativeFunction (const void *emulStateP, void *userData68KP,<a name="920357"> </a>
Call68KFuncType *call68KFuncP) {<a name="920358"> </a>
    unsigned char *bufferP;<a name="920359"> </a>
    int i;<a name="920360"> </a>
<a name="920361"> </a>
// allocate 10 bytes of memory using a convenience function<a name="920362"> </a>
    bufferP = (unsigned char*)PalmOS_MemPtrNew(emulStateP, call68KFuncP, 10);<a name="920363"> </a>
<a name="920364"> </a>
// Do something with the bytes in the buffer<a name="920365"> </a>
    for (i = 0; i &lt; 9; i++) bufferP[i] = i+'A'; // write in "ABCDEFGHI"<a name="920366"> </a>
    bufferP[9] = 0;                            // terminate the string<a name="920367"> </a>
<a name="920368"> </a>
    return (unsigned long)bufferP;<a name="920369"> </a>
}<a name="920370"> </a>
<a name="920371"> </a>
<a name="920372"> </a>
// Convenience function for calling MemPtrNew within ARM code<a name="920373"> </a>
void *PalmOS_MemPtrNew(const void *emulStateP, Call68KFuncType *call68KFuncP,<a name="920374"> </a>
unsigned long sizeLE) {<a name="920375"> </a>
    // First, declare the argument(s) that will be passed to the OS call.<a name="920376"> </a>
    // In this case, we're calling MemPtrNew, so we need a size argument.<a name="920377"> </a>
    // Because this code is compiled by an ARM compiler (little endian),<a name="920378"> </a>
    // and MemPtrNew expects its argument to be big endian, swap it.<a name="920379"> </a>
    unsigned long sizeBE = ByteSwap32(sizeLE);<a name="920380"> </a>
<a name="920381"> </a>
    // Call the trap. Note that because MemPtrNew returns a pointer, the byte<a name="920382"> </a>
    // count (the last parameter) must be "OR"d" with kPceNativeWantA0.<a name="920383"> </a>
    return ((void *)((call68KFuncP)(emulStateP,<a name="920384"> </a>
        PceNativeTrapNo(sysTrapMemPtrNew), &amp;sizeBE, 4 | kPceNativeWantA0))); <a name="920385"> </a>
}<a name="920386"> </a>
</pre><div class="CodeRule"><hr></div>

<h3 class="hbH3">
  <a name="920388"> </a>Calling a Function Using a Function Pointer <a href="#920544"><span class="nav">^TOP^</span></a>
</h3>


<p><a name="920392"> </a>The code excerpt in <a href="PalmOS5ARM_Chapter.html#920405">Listing 14.3</a> shows how to pass a 68K callback function pointer to ARM native code, and <a href="PalmOS5ARM_Chapter.html#920430">Listing 14.4</a> shows how to call that 68K function from within the ARM code. The ARM code ultimately accomplishes the same result as in the previous example (calling <code>MemPtrNew</code>), but this example lets the 68K-side callback function do the allocation. Note that the pointer to the callback function is passed to the ARM code as data, embedded in a structure.</p>

<p><a name="920396"> </a>The following is implemented on the 68K side:</p>
<p class="CCodeCaption">
  <a name="920405"> </a><b>Listing 14.3&nbsp;&nbsp;Calling PACE application code from ARM code (68K side)</b>
</p>

<div class="CodeRule"><hr></div><pre class="CodeBlock">
typedef struct MyParamsTag {<a name="920406"> </a>
    void *myAllocateFunctionP;<a name="920407"> </a>
    UInt32 anotherValue;<a name="920408"> </a>
} MyParamsType;<a name="920409"> </a>
<a name="920410"> </a>
// function to allocate 10 bytes<a name="920411"> </a>
void *MyAllocateFunction() {<a name="920412"> </a>
    return MemPtrNew(10);<a name="920413"> </a>
}<a name="920414"> </a>
<a name="920415"> </a>
// code to call the native function, defined in the next listing<a name="920416"> </a>
MyParamsType myParams;<a name="920417"> </a>
MemHandle armChunkH;<a name="920418"> </a>
void *myNativeFuncP;<a name="920419"> </a>
Byte *result;<a name="920420"> </a>
<a name="920421"> </a>
armChunkH = DmGetResource('armc', 0);<a name="920422"> </a>
myNativeFuncP = MemHandleLock(armChunkH);<a name="920423"> </a>
<a name="920424"> </a>
myParams.myAllocateFunctionP  = &amp;MyAllocateFunction;<a name="920425"> </a>
<a name="920426"> </a>
result = (Byte *)PceNativeCall(myNativeFuncP, &amp;myParams);<a name="920427"> </a>
</pre><div class="CodeRule"><hr></div>


<p><a name="920428"> </a>In the ARM file, the following code accepts the callback function pointer and uses the 68K function to allocate the 10-byte memory block:</p>
<p class="CCodeCaption">
  <a name="920430"> </a><b>Listing 14.4&nbsp;&nbsp;Calling PACE application code from ARM code (ARM side)</b>
</p>

<div class="CodeRule"><hr></div><pre class="CodeBlock">
typedef struct MyParamsTag {<a name="920431"> </a>
    void *myAllocateFunctionP;<a name="920432"> </a>
    unsigned long anotherValue;<a name="920433"> </a>
} MyParamsType;<a name="920434"> </a>
<a name="920435"> </a>
unsigned long MyNativeFunc(const void *emulStateP,<a name="920436"> </a>
  void *userData68KP, Call68KFuncType *call68KFunc) {<a name="920437"> </a>
    unsigned char *buffer68K; // array of Byte<a name="920438"> </a>
    unsigned char i; // Byte<a name="920439"> </a>
    void *my68KFuncP;<a name="920440"> </a>
<a name="920441"> </a>
    // get the function pointer out of the passed parameter block<a name="920442"> </a>
    my68KfuncP = ByteSwap4(userData68KP-&gt;myAllocateFunctionP);<a name="920443"> </a>
<a name="920444"> </a>
    // invoke the callback function to allocate 10 bytes<a name="920445"> </a>
    buffer68K = (void *)((call68KFunc)(emulStateP, my68KFuncP, 
        &amp;size, 4 | kPceNativeWantA0));<a name="920446"> </a>
<a name="920447"> </a>
    // do something with the bytes in the buffer<a name="920448"> </a>
    for (i = 10; i &gt; 0; i--)<a name="920449"> </a>
        buffer68K[i] = i;<a name="920450"> </a>
<a name="920451"> </a>
    return (unsigned long)buffer68K;<a name="920452"> </a>
}<a name="920453"> </a>
</pre><div class="CodeRule"><hr></div>


<h2 class="haH2">
  <a name="918214"> </a>Overview of Sample Files  <a href="#920544"><span class="nav">^TOP^</span></a>
</h2>


<p><a name="918216"> </a>The following ARM-native programming samples are included as part of the SDK. </p>
<h3 class="hbH3">
  <a name="918217"> </a>ARM-Native Subroutine Sample Files  <a href="#920544"><span class="nav">^TOP^</span></a>
</h3>


<p><a name="918221"> </a><a href="PalmOS5ARM_Chapter.html#918228">Table 14.2</a> shows the sample files that call ARM code from a 68K application. </p>

<p class="caption"><a name="918228"> </a><b>Table 14.2&nbsp;&nbsp;Calling ARM from 68K Sample Files  </b></p>
<div class="tablediv"><table cellspacing="0" class="tTable">

  <tr valign="top">
    <th><p class="tt"><a name="918232"> </a><b>Filename </b></p>
    </th>
    <th><p class="tt"><a name="918234"> </a><b>Purpose </b></p>
    </th>
  </tr>
  <tr valign="top">
    <td><p class="tt"><a name="918237"> </a><code>armlet-simple.c</code> </p>
<p class="tt"><a name="918238"> </a><code>armlet-simple.bin </code></p>
    </td>
    <td><p class="tt"><a name="918240"> </a>A trivial ARM-native subroutine showing how to pass a pointer from a 68K application. </p>
    </td>
  </tr>
  <tr valign="top">
    <td><p class="tt"><a name="918243"> </a><code>armlet-oscall.c</code> </p>
<p class="tt"><a name="918244"> </a><code>armlet-oscall.bin </code></p>
    </td>
    <td><p class="tt"><a name="918246"> </a>An ARM-native subroutine showing you how to call a Palm OS API function, using <code>MemPtrNew</code> as an example. </p>
    </td>
  </tr>
  <tr valign="top">
    <td><p class="tt"><a name="918248"> </a><code>armlet-endianness_and_alignment.c</code> </p>
<p class="tt"><a name="918250"> </a><code>armlet-endianness_and_alignment.bin </code></p>
    </td>
    <td><p class="tt"><a name="918252"> </a>An ARM-native subroutine showing you how to make sure your data is correctly 4-byte aligned. </p>
    </td>
  </tr>
  <tr valign="top">
    <td><p class="tt"><a name="918255"> </a><code>endianutils.h</code> </p>
    </td>
    <td><p class="tt"><a name="918257"> </a>Macros for doing endian byte-swapping and 4-byte alignment correction. Used by the <code>armlet-oscall.c</code> and <code>armlet-endianness_and_alignment.c</code> files. </p>
    </td>
  </tr>
  <tr valign="top">
    <td><p class="tt"><a name="918260"> </a><code>example_data_type.h</code> </p>
    </td>
    <td><p class="tt"><a name="918262"> </a>Example showing a user-defined structure. Used by the <code>armlet-endianness_and_alignment.c</code> file. </p>
    </td>
  </tr>
</table>

</div>

<h3 class="hbH3">
  <a name="918264"> </a>Windows DLL Sample Files  <a href="#920544"><span class="nav">^TOP^</span></a>
</h3>


<p><a name="918268"> </a><a href="PalmOS5ARM_Chapter.html#918275">Table 14.3</a> table shows the sample files that you can use to build a DLL for testing an ARM subroutine with Palm OS Simulator. For background information, see <a href="PalmOS5ARM_Chapter.html#920755">"Test the ARM-Native Subroutine"</a>.</p>

<p class="caption"><a name="918275"> </a><b>Table 14.3&nbsp;&nbsp;Windows DLL Sample Files - For Testing with Palm OS Simulator  </b></p>
<div class="tablediv"><table cellspacing="0" class="tTable">

  <tr valign="top">
    <th><p class="tt"><a name="918282"> </a><b>Filename </b></p>
    </th>
    <th><p class="tt"><a name="918284"> </a><b>Purpose </b></p>
    </th>
  </tr>
  <tr valign="top">
    <td><p class="tt"><a name="918287"> </a><code>Simple.dsp</code> </p>
    </td>
    <td><p class="tt"><a name="918289"> </a>Visual Studio project file for building a DLL file. </p>
    </td>
  </tr>
  <tr valign="top">
    <td><p class="tt"><a name="918292"> </a><code>SimNative.cpp</code> </p>
    </td>
    <td><p class="tt"><a name="918294"> </a>The main DLL source file. </p>
    </td>
  </tr>
  <tr valign="top">
    <td><p class="tt"><a name="918297"> </a><code>SimNative.h</code> </p>
    </td>
    <td><p class="tt"><a name="918299"> </a>Header file which defines the exports from the DLL file. </p>
    </td>
  </tr>
  <tr valign="top">
    <td><p class="tt"><a name="918302"> </a><code>StdAfx.cpp</code> </p>
    </td>
    <td><p class="tt"><a name="918304"> </a>C++ source file used to build a precompiler header file and precompiled types file. </p>
    </td>
  </tr>
  <tr valign="top">
    <td><p class="tt"><a name="918307"> </a><code>StdAfx.h </code></p>
    </td>
    <td><p class="tt"><a name="918309"> </a>Header file used by <code>StdAfx.cpp</code>. </p>
    </td>
  </tr>
</table>

</div>
&nbsp;<br>
</div>
<!--END CONTENT-->

</td>
<td width="5">&nbsp;&nbsp;</td>
</tr>

</table>

<!-- BEGIN FOOTER -->
<table width="100%" border="0" cellspacing="0" cellpadding="0">
<tr>
<td width="7" rowspan="2"><img name="index_x" src="images/shim.gif" width="7" height="33" border="0" alt=""></td>
<td align="left"><img name="dashes" src="images/dashes.gif" width="744" height="3" border="0" alt=""></td>
<td width="10" rowspan="2"><img name="index_x" src="images/shim.gif" width="10" height="33" border="0" alt=""></td>
</tr>
<tr>
<td align="center">
<p class="footer">
Copyright © 1996-2004, PalmSource, Inc. and its affiliates.  All rights reserved. <br>
<a href="http://www.palmsource.com/contact/">Write Us</a> | <a href="http://www.palmos.com/dev/training/">Training</a> | <a href="http://www.palmos.com/dev/support/kb/">Knowledge Base</a> | <a href="Companion_Front.html" target="_blank">Legal</a></p>
<br>
<!--BEGIN BOOK NAVIGATION-->
<p class="nav">
<A href="http://www.palmos.com/dev/support/docs/">Documentation</a>&nbsp;&nbsp;|&nbsp;&nbsp;
<a href="CompanionTOC.html">Table of Contents</a>&nbsp;&nbsp;
             |&nbsp;&nbsp;<a href="Security.html">&lt;&nbsp;Previous</a>&nbsp;&nbsp;
             |&nbsp;&nbsp;<a href="DebuggingStrats.html">Next&nbsp;&gt;</a>&nbsp;&nbsp;
             |&nbsp;&nbsp;<a href="CompanionIX.html">Index</a>
</p>
</td>
</tr>
</table>
<!-- END FOOTER -->

</body>
</html>