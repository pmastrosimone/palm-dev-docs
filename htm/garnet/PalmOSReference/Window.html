<html>
<head>
<title>(68K) Windows | Palm OS&#174; Programmer's  API Reference</title> 
<link href="psi_devpubs.css" rel="stylesheet" type="text/css">

<!-- BEGIN META DATA -->
<meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
<META NAME="PSITEMPLATE" CONTENT="1006-007 PalmSource_HTML_2003 20041101">
<META NAME="GENERATOR" CONTENT="Quadralay WebWorks AutoMap 2003 for FrameMaker 8.0.6.2138">
<META NAME="LASTUPDATED" CONTENT="11/22/04 10:46:43">
<!-- END META DATA -->
</head>

<body bgcolor="#ffffff" text="#000000" leftmargin="0" topmargin="0" marginwidth="0" marginheight="0">
<a name="1012037"></a>

<!-- BEGIN TOPNAV -->
<table width="100%" border="0" cellspacing="0" cellpadding="0">
<tr>
<td><img src="images/shim.gif" width="7" height="75" border="0" alt=""></td>
<td align="left"><table border="0" cellpadding="0" cellspacing="0" width="744">
<tr>
<td><img name="index_r2_c1" src="images/shim.gif" width="25" height="75" border="0" alt=""></td>
<td valign="top"><table border="0" cellpadding="0" cellspacing="0" width="96">
<tr>
<td><img name="index_r2_c4" src="images/shim.gif" width="96" height="15" border="0" alt=""></td>
</tr>
<tr>
<td><a href="http://www.palmsource.com/"><img name="ps_logo" src="images/ps_logo.gif" width="96" height="54" border="0" alt=""></a></td>
</tr>

</table>
</td>

<td><table border="0" cellpadding="0" cellspacing="0" width="30">
<td><img name="index_x" src="images/shim.gif" width="30" height="75" border="0" alt=""></td>
</table></td>

<!--BEGIN MASTHEAD-->
<td><table border="0" cellpadding="0" cellspacing="0" width="96">
<tr>
<td><img name="index_x" src="images/shim.gif" width="615" height="5" border="0" alt=""></td>
</tr>
<tr>
<td>
<!--BEGIN BOOK NAVIGATION-->
<span class="nav">
<A href="http://www.palmos.com/dev/support/docs/">Documentation</a>&nbsp;&nbsp;|&nbsp;&nbsp;
<a href="ReferenceTOC.html">Table of Contents</a>&nbsp;&nbsp;
             |&nbsp;&nbsp;<a href="VFSMgr.html">&lt;&nbsp;Previous</a>&nbsp;&nbsp;
             |&nbsp;&nbsp;<a href="MiscSys.html">Next&nbsp;&gt;</a>&nbsp;&nbsp;
             |&nbsp;&nbsp;<a href="ReferenceIX.html">Index</a>
</span>
<!--END BOOK NAVIGATION-->
</tr>
<tr>
<td>
<!--BEGIN PAGE TITLE-->
<h2 class="PageTitle">59 &nbsp;&nbsp;
Windows</h2></td>
<!--END PAGE TITLE-->
</tr>
<tr>
<td>
<!--BEGIN BOOK TITLE-->
<p class="BookTitle">Palm OS&#174; Programmer's  API Reference</p>
<p class="SubTitle">Palm OS&#174; 68K SDK </p>
<!--END BOOK TITLE-->
</td>
</tr>
<tr>
<td><img name="index_x" src="images/shim.gif" width="615" height="5" border="0" alt=""></td>
</tr>
</table>
</td>
<!--END MASTHEAD-->
</tr>
</table>
<img name="dashes" src="images/dashes.gif" width="744" height="3" border="0" alt=""></td>
</tr>
</table>
<!-- END TOPNAV -->

<table width="100%" border="0" cellspacing="0" cellpadding="0">
<tr>
<td valign="top" width="5"><img name="index_x" src="images/shim.gif" width="5" height="33" border="0" alt=""></td>

<!--BEGIN SIDETOC-->
<td valign="top" width="175">
<div id="sidetoc" valign="bottom">
<h1 class="SideTOC1-PartTab"><a href="PartII.html">Part II: System Management</a> </h1>
<h1 class="SideTOC1"><a href="Window.html">59  Windows</a></h1>

   <h2 class="SideTOC2"><a href="#1012062">
   Window Data Structures</a></h2>

      <h3 class="SideTOC3"><a href="#1012065">
      CustomPatternType</a></h3>

      <h3 class="SideTOC3"><a href="#1012086">
      DrawStateFlagsType</a></h3>

      <h3 class="SideTOC3"><a href="#1012130">
      DrawStateType</a></h3>

      <h3 class="SideTOC3"><a href="#1012322">
      FrameBitsType</a></h3>

      <h3 class="SideTOC3"><a href="#1012368">
      FrameType</a></h3>

      <h3 class="SideTOC3"><a href="#1012445">
      IndexedColorType</a></h3>

      <h3 class="SideTOC3"><a href="#1012462">
      PatternType</a></h3>

      <h3 class="SideTOC3"><a href="#1012528">
      UnderlineModeType</a></h3>

      <h3 class="SideTOC3"><a href="#1012561">
      WindowFlagsType</a></h3>

      <h3 class="SideTOC3"><a href="#1012632">
      WindowFormatType</a></h3>

      <h3 class="SideTOC3"><a href="#1012667">
      WindowType</a></h3>

      <h3 class="SideTOC3"><a href="#1012784">
      WinDrawOperation</a></h3>

      <h3 class="SideTOC3"><a href="#1012852">
      WinHandle</a></h3>

      <h3 class="SideTOC3"><a href="#1012864">
      WinLineType</a></h3>

      <h3 class="SideTOC3"><a href="#1012901">
      WinPtr</a></h3>

   <h2 class="SideTOC2"><a href="#1012912">
   Window Constants</a></h2>

      <h3 class="SideTOC3"><a href="#1012925">
      Window Coordinate System Constants</a></h3>

   <h2 class="SideTOC2"><a href="#1012994">
   Window Functions</a></h2>

      <h3 class="SideTOC3"><a href="#1012997">
      WinClipRectangle</a></h3>

      <h3 class="SideTOC3"><a href="#1013039">
      WinCopyRectangle</a></h3>

      <h3 class="SideTOC3"><a href="#1013088">
      WinCreateBitmapWindow</a></h3>

      <h3 class="SideTOC3"><a href="#1013152">
      WinCreateOffscreenWindow</a></h3>

      <h3 class="SideTOC3"><a href="#1013215">
      WinCreateWindow</a></h3>

      <h3 class="SideTOC3"><a href="#1013268">
      WinDeleteWindow</a></h3>

      <h3 class="SideTOC3"><a href="#1013298">
      WinDisplayToWindowPt</a></h3>

      <h3 class="SideTOC3"><a href="#1013322">
      WinDrawBitmap</a></h3>

      <h3 class="SideTOC3"><a href="#1013360">
      WinDrawChar</a></h3>

      <h3 class="SideTOC3"><a href="#1013424">
      WinDrawChars</a></h3>

      <h3 class="SideTOC3"><a href="#1013482">
      WinDrawGrayLine</a></h3>

      <h3 class="SideTOC3"><a href="#1013526">
      WinDrawGrayRectangleFrame</a></h3>

      <h3 class="SideTOC3"><a href="#1013566">
      WinDrawInvertedChars</a></h3>

      <h3 class="SideTOC3"><a href="#1013620">
      WinDrawLine</a></h3>

      <h3 class="SideTOC3"><a href="#1013670">
      WinDrawPixel</a></h3>

      <h3 class="SideTOC3"><a href="#1013707">
      WinDrawRectangle</a></h3>

      <h3 class="SideTOC3"><a href="#1013745">
      WinDrawRectangleFrame</a></h3>

      <h3 class="SideTOC3"><a href="#1013790">
      WinDrawTruncChars</a></h3>

      <h3 class="SideTOC3"><a href="#1013856">
      WinEraseChars</a></h3>

      <h3 class="SideTOC3"><a href="#1013906">
      WinEraseLine</a></h3>

      <h3 class="SideTOC3"><a href="#1013948">
      WinErasePixel</a></h3>

      <h3 class="SideTOC3"><a href="#1013985">
      WinEraseRectangle</a></h3>

      <h3 class="SideTOC3"><a href="#1014019">
      WinEraseRectangleFrame</a></h3>

      <h3 class="SideTOC3"><a href="#1014057">
      WinEraseWindow</a></h3>

      <h3 class="SideTOC3"><a href="#1014083">
      WinFillLine</a></h3>

      <h3 class="SideTOC3"><a href="#1014130">
      WinFillRectangle</a></h3>

      <h3 class="SideTOC3"><a href="#1014168">
      WinGetActiveWindow</a></h3>

      <h3 class="SideTOC3"><a href="#1014197">
      WinGetBitmap</a></h3>

      <h3 class="SideTOC3"><a href="#1014219">
      WinGetBounds</a></h3>

      <h3 class="SideTOC3"><a href="#1014266">
      WinGetClip</a></h3>

      <h3 class="SideTOC3"><a href="#1014287">
      WinGetCoordinateSystem</a></h3>

      <h3 class="SideTOC3"><a href="#1014319">
      WinGetDisplayExtent</a></h3>

      <h3 class="SideTOC3"><a href="#1014337">
      WinGetDisplayWindow</a></h3>

      <h3 class="SideTOC3"><a href="#1014365">
      WinGetDrawWindow</a></h3>

      <h3 class="SideTOC3"><a href="#1014391">
      WinGetDrawWindowBounds</a></h3>

      <h3 class="SideTOC3"><a href="#1014416">
      WinGetFirstWindow</a></h3>

      <h3 class="SideTOC3"><a href="#1014438">
      WinGetFramesRectangle</a></h3>

      <h3 class="SideTOC3"><a href="#1014471">
      WinGetPattern</a></h3>

      <h3 class="SideTOC3"><a href="#1014513">
      WinGetPatternType</a></h3>

      <h3 class="SideTOC3"><a href="#1014552">
      WinGetPixel</a></h3>

      <h3 class="SideTOC3"><a href="#1014583">
      WinGetPixelRGB</a></h3>

      <h3 class="SideTOC3"><a href="#1014613">
      WinGetScalingMode</a></h3>

      <h3 class="SideTOC3"><a href="#1014635">
      WinGetSupportedDensity</a></h3>

      <h3 class="SideTOC3"><a href="#1014666">
      WinGetWindowExtent</a></h3>

      <h3 class="SideTOC3"><a href="#1014692">
      WinGetWindowFrameRect</a></h3>

      <h3 class="SideTOC3"><a href="#1014715">
      WinIndexToRGB</a></h3>

      <h3 class="SideTOC3"><a href="#1014749">
      WinInvertChars</a></h3>

      <h3 class="SideTOC3"><a href="#1014810">
      WinInvertLine</a></h3>

      <h3 class="SideTOC3"><a href="#1014855">
      WinInvertPixel</a></h3>

      <h3 class="SideTOC3"><a href="#1014895">
      WinInvertRectangle</a></h3>

      <h3 class="SideTOC3"><a href="#1014933">
      WinInvertRectangleFrame</a></h3>

      <h3 class="SideTOC3"><a href="#1014974">
      WinModal</a></h3>

      <h3 class="SideTOC3"><a href="#1015004">
      WinPaintBitmap</a></h3>

      <h3 class="SideTOC3"><a href="#1015054">
      WinPaintChar</a></h3>

      <h3 class="SideTOC3"><a href="#1015108">
      WinPaintChars</a></h3>

      <h3 class="SideTOC3"><a href="#1015171">
      WinPaintLine</a></h3>

      <h3 class="SideTOC3"><a href="#1015223">
      WinPaintLines</a></h3>

      <h3 class="SideTOC3"><a href="#1015274">
      WinPaintPixel</a></h3>

      <h3 class="SideTOC3"><a href="#1015316">
      WinPaintPixels</a></h3>

      <h3 class="SideTOC3"><a href="#1015358">
      WinPaintRectangle</a></h3>

      <h3 class="SideTOC3"><a href="#1015401">
      WinPaintRectangleFrame</a></h3>

      <h3 class="SideTOC3"><a href="#1015454">
      WinPaintRoundedRectangleFrame</a></h3>

      <h3 class="SideTOC3"><a href="#1015494">
      WinPaintTiledBitmap</a></h3>

      <h3 class="SideTOC3"><a href="#1015523">
      WinPalette</a></h3>

      <h3 class="SideTOC3"><a href="#1015578">
      WinPopDrawState</a></h3>

      <h3 class="SideTOC3"><a href="#1015604">
      WinPushDrawState</a></h3>

      <h3 class="SideTOC3"><a href="#1015632">
      WinResetClip</a></h3>

      <h3 class="SideTOC3"><a href="#1015652">
      WinRestoreBits</a></h3>

      <h3 class="SideTOC3"><a href="#1015682">
      WinRGBToIndex</a></h3>

      <h3 class="SideTOC3"><a href="#1015725">
      WinSaveBit</a></h3>

      <h3 class="SideTOC3"><a href="#1015751">
      WinScaleCoord</a></h3>

      <h3 class="SideTOC3"><a href="#1015787">
      WinScalePoint</a></h3>

      <h3 class="SideTOC3"><a href="#1015823">
      WinScaleRectangle</a></h3>

      <h3 class="SideTOC3"><a href="#1015858">
      WinScreenGetAttribute</a></h3>

      <h3 class="SideTOC3"><a href="#1015956">
      WinScreenLock</a></h3>

      <h3 class="SideTOC3"><a href="#1015990">
      WinScreenMode</a></h3>

      <h3 class="SideTOC3"><a href="#1016195">
      WinScreenUnlock</a></h3>

      <h3 class="SideTOC3"><a href="#1016223">
      WinScrollRectangle</a></h3>

      <h3 class="SideTOC3"><a href="#1016249">
      WinSetActiveWindow</a></h3>

      <h3 class="SideTOC3"><a href="#1016284">
      WinSetBackColor</a></h3>

      <h3 class="SideTOC3"><a href="#1016329">
      WinSetBackColorRGB</a></h3>

      <h3 class="SideTOC3"><a href="#1016385">
      WinSetBounds</a></h3>

      <h3 class="SideTOC3"><a href="#1016415">
      WinSetClip</a></h3>

      <h3 class="SideTOC3"><a href="#1074517">
      WinSetConstraintsSize</a></h3>

      <h3 class="SideTOC3"><a href="#1074566">
      WinSetCoordinateSystem</a></h3>

      <h3 class="SideTOC3"><a href="#1075295">
      WinSetDrawMode</a></h3>

      <h3 class="SideTOC3"><a href="#1016515">
      WinSetDrawWindow</a></h3>

      <h3 class="SideTOC3"><a href="#1016542">
      WinSetForeColor</a></h3>

      <h3 class="SideTOC3"><a href="#1016587">
      WinSetForeColorRGB</a></h3>

      <h3 class="SideTOC3"><a href="#1016643">
      WinSetPattern</a></h3>

      <h3 class="SideTOC3"><a href="#1016683">
      WinSetPatternType</a></h3>

      <h3 class="SideTOC3"><a href="#1016731">
      WinSetScalingMode</a></h3>

      <h3 class="SideTOC3"><a href="#1016815">
      WinSetTextColor</a></h3>

      <h3 class="SideTOC3"><a href="#1016861">
      WinSetTextColorRGB</a></h3>

      <h3 class="SideTOC3"><a href="#1016917">
      WinSetUnderlineMode</a></h3>

      <h3 class="SideTOC3"><a href="#1016949">
      WinUnscaleCoord</a></h3>

      <h3 class="SideTOC3"><a href="#1016985">
      WinUnscalePoint</a></h3>

      <h3 class="SideTOC3"><a href="#1017021">
      WinUnscaleRectangle</a></h3>

      <h3 class="SideTOC3"><a href="#1017055">
      WinValidateHandle</a></h3>

      <h3 class="SideTOC3"><a href="#1017085">
      WinWindowToDisplayPt</a></h3>

</div>
</td>

<td width="5">&nbsp;&nbsp;</td>
<td width="2" background="images/index_r8_c10.gif"><img src="images/shim.gif" width="2" height="75" border="0" alt=""></td>
<td width="5">&nbsp;&nbsp;</td>

<!--END SIDETOC-->

<td valign="top">

<!--BEGIN CONTENT-->
<div id="content" valign="bottom">
<p><a name="1012038"> </a>This chapter provides information about windows by discussing these topics: </p>
<ul type="disc">
  <li><a name="1012042"> </a><a href="Window.html#1012062">Window Data Structures</a> 
  <li><a name="1012046"> </a><a href="Window.html#1012912">Window Constants</a>
  <li><a name="1012050"> </a><a href="Window.html#1012994">Window Functions</a> 
</ul>

<p><a name="1012051"> </a>No resources are associated with window objects.</p>

<p><a name="1012053"> </a>The header file <code>Window.h</code> declares the API that this chapter describes. For more information on windows, see the section <a href="../PalmOSCompanion/UserInterface.html#1007970">"Drawing on the Palm Powered Handheld"</a> in the <i>Palm OS Programmer's Companion</i>, vol. I. </p>

<h2 class="haH2">
  <a name="1012062"> </a>Window Data Structures <a href="#1012037"><span class="nav">^TOP^</span></a>
</h2>


<h3 class="hbH3">
  <a name="1012065"> </a>CustomPatternType Typedef <a href="#1012037"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="1012067"> </a>Purpose 
</h4>

<p><a name="1012069"> </a>The <code>CustomPatternType</code> type holds an 8-by-8 bit pattern that is one bit deep. Each byte specifies a row of the pattern. When drawing, a pattern is tiled to fill a specified region. This pattern is used by <a href="Window.html#1014083"><code>WinFillLine()</code></a> and <a href="Window.html#1014130"><code>WinFillRectangle()</code></a>. </p>

<p><a name="1012079"> </a>The <a href="Window.html#1012462"><code>PatternType</code></a> specifies the name of the current pattern.</p>
<h4>
  <a name="1012080"> </a>Prototype 
</h4>
<pre class="proto"><a name="1012081"></a>typedef UInt8 CustomPatternType [8];
</pre>
<h4>
  <a name="1012082"> </a>Compatibility 
</h4>

<p><a name="1012083"> </a>In pre-3.5 systems, the <code>CustomPatternType</code> is an array of 4 16-bit words. Note the size of this data type has not changed.</p>

<h3 class="hbH3">
  <a name="1012086"> </a>DrawStateFlagsType Struct <a href="#1012037"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="1012088"> </a>Purpose 
</h4>

<p><a name="1012089"> </a>The DrawStateFlagsType structure defines a set of flags that control how bitmaps and text are scaled. Use <a href="Window.html#1016731"><code>WinSetScalingMode()</code></a> to set these flags, and <a href="Window.html#1014613"><code>WinGetScalingMode()</code></a> to obtain the values of these flags.</p>

<div><hr>
  <a name="1012096"> </a> <span class="warning">WARNING! </span> PalmSource, Inc. does not support or provide backward compatibility for the <code>DrawStateFlagsType</code> structure. Never access its structure members directly, or your code may break in future versions. Use the information below for debugging purposes only.
<hr>
</div>
<h4>
  <a name="1012097"> </a>Prototype 
</h4>
<pre class="proto"><a name="1012098"></a>typedef struct DrawStateFlagsType {
  UInt16 unscaledBitmaps:1;
  UInt16 unscaledText:1;
  UInt16 unpaddedText:1;
  UInt16 reserved:13;
} DrawStateFlagsType;
</pre>
<h4>
  <a name="1081342"> </a>Fields 
</h4>

<dl>
<dt><a name="1012107"> </a><code>unscaledBitmaps</code></dt>
<dd><a name="1012109"> </a>If set, low-density bitmaps are used, unscaled.</dd>

<dt><a name="1012111"> </a><code>unscaledText</code></dt>
<dd><a name="1012113"> </a>If set, low density fonts are used, unscaled.</dd>

<dt><a name="1012115"> </a><code>unpaddedText</code></dt>
<dd><a name="1012117"> </a>If set, padding pixels aren't inserted between text glyphs.</dd>

<dt><a name="1012119"> </a><code>reserved</code></dt>
<dd><a name="1012121"> </a>Reserved for future use.</dd>

</dl>
<h4>
  <a name="1012123"> </a>Compatibility 
</h4>

<p><a name="1012127"> </a>Defined only if the <a href="CompatibilityApdx.html#997148">1.5x Display Feature Set</a> is present.</p>

<h3 class="hbH3">
  <a name="1012130"> </a>DrawStateType Struct <a href="#1012037"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="1012132"> </a>Purpose 
</h4>

<p><a name="1012134"> </a>The <code>DrawStateType</code> structure defines the current drawing state, which is the Palm OS<sup>&#174;</sup> implementation of a <b>pen</b>. This drawing state is saved with <a href="Window.html#1015604"><code>WinPushDrawState()</code></a> and restored with <a href="Window.html#1015578"><code>WinPopDrawState()</code></a>. </p>

<div><hr>
  <a name="1012141"> </a> <span class="warning">WARNING! </span> PalmSource, Inc. does not support or provide backward compatibility for the <code>DrawStateType</code> structure. Never access its structure members directly, or your code may break in future versions. Use the information below for debugging purposes only.
<hr>
</div>
<h4>
  <a name="1012142"> </a>Prototype 
</h4>
<pre class="proto"><a name="1012143"></a>typedef struct DrawStateType {
  WinDrawOperation transferMode;
  PatternType pattern;
  UnderlineModeType underlineMode;
  FontID fontId;
  FontPtr font;
  CustomPatternType patternData;
  IndexedColorType foreColor;
  IndexedColorType backColor;
  IndexedColorType textColor;
  UInt8 reserved;
  RGBColorType foreColorRGB;
  RGBColorType backColorRGB;
  RGBColorType textColorRGB;
  UInt16 coordinateSystem;
  DrawStateFlagsType flags;
  Fixed16 scale;
  Fixed16 ntvToActiveScale;
  Fixed16 stdToActiveScale;
  Fixed16 activeToStdScale;
} DrawStateType;
</pre>
<h4>
  <a name="1082206"> </a>Fields 
</h4>

<dl>
<dt><a name="1012167"> </a><code>transferMode</code></dt>
<dd><a name="1012169"> </a>The current transfer mode for color drawing. See <a href="Window.html#1012784"><code>WinDrawOperation</code></a>. Use <a href="Window.html#1075295"><code>WinSetDrawMode()</code></a> to set this value. </dd>

<dt><a name="1012177"> </a><code>pattern</code></dt>
<dd><a name="1012179"> </a>The name of the current pattern. See <a href="Window.html#1012462"><code>PatternType</code></a>. If set to <code>customPattern</code>, the <code>patternData</code> field contains the actual pattern. Use <a href="Window.html#1014513"><code>WinGetPatternType()</code></a> and <a href="Window.html#1016683"><code>WinSetPatternType()</code></a> to retrieve and set this value. </dd>

<dt><a name="1012190"> </a><code>underlineMode</code></dt>
<dd><a name="1012192"> </a>The current underline mode. See <code>UnderlineModeType</code>. Use <a href="Window.html#1016917"><code>WinSetUnderlineMode()</code></a> to set this value. </dd>

<dt><a name="1012197"> </a><code>fontId</code></dt>
<dd><a name="1012199"> </a>The ID of the current font. Use <a href="Font.html#1000753"><code>FntSetFont()</code></a> to set this value. </dd>

<dt><a name="1012204"> </a><code>font</code></dt>
<dd><a name="1012206"> </a>A pointer to the current font. Use <a href="Font.html#1000753"><code>FntSetFont()</code></a> to set this value. </dd>

<dt><a name="1012211"> </a><code>patternData</code></dt>
<dd><a name="1012213"> </a>The current pattern being used by the <code>WinFill</code> functions if <code>pattern</code> is <code>customPattern</code>. See <a href="Window.html#1012065"><code>CustomPatternType</code></a>. Use <a href="Window.html#1014471"><code>WinGetPattern()</code></a> and <a href="Window.html#1016643"><code>WinSetPattern()</code></a> to retrieve and set this value. </dd>

<dt><a name="1012224"> </a><code>foreColor</code></dt>
<dd><a name="1012226"> </a>Index of the current color used for the foreground. Use <a href="Window.html#1016542"><code>WinSetForeColor()</code></a> to set this value. This field is only valid for indexed color bitmaps.</dd>

<dt><a name="1012231"> </a><code>backColor</code></dt>
<dd><a name="1012233"> </a>Index of the current color used for the background. Use <a href="Window.html#1016284"><code>WinSetBackColor()</code></a> to set this value. This field is only valid for indexed color bitmaps.</dd>

<dt><a name="1012238"> </a><code>textColor </code></dt>
<dd><a name="1012240"> </a>Index of the current color used for text. Use <a href="Window.html#1016815"><code>WinSetTextColor()</code></a> to set this value. This field is only valid for indexed color bitmaps.</dd>

<dt><a name="1012245"> </a><code>reserved</code></dt>
<dd><a name="1012247"> </a>Reserved for future use.</dd>

<dt><a name="1012249"> </a><code>foreColorRGB</code></dt>
<dd><a name="1012251"> </a>RGB value of the current color used for the foreground. Use <a href="Window.html#1016587"><code>WinSetForeColorRGB()</code></a> to set this value. This field is only valid for Palm OS 4.0 or later, and only valid for direct color bitmaps.</dd>

<dt><a name="1012256"> </a><code>backColorRGB</code></dt>
<dd><a name="1012258"> </a>RGB value of the current color used for the background. Use <a href="Window.html#1016329"><code>WinSetBackColorRGB()</code></a> to set this value. This field is only valid for Palm OS 4.0 or later, and only valid for direct color bitmaps.</dd>

<dt><a name="1012263"> </a><code>textColorRGB</code></dt>
<dd><a name="1012265"> </a>RGB value of the current color used for text. Use <a href="Window.html#1016861"><code>WinSetTextColorRGB()</code></a> to set this value. This field is only valid for Palm OS 4.0 or later, and only valid for direct color bitmaps.</dd>

<dt><a name="1012270"> </a><code>coordinateSystem</code></dt>
<dd><a name="1012272"> </a>Active coordinate system.</dd>

<dt><a name="1012274"> </a><code>flags</code></dt>
<dd><a name="1012279"> </a>A <a href="Window.html#1012086"><code>DrawStateFlagsType</code></a> structure, the contents of which control the scaling of bitmaps and text.</dd>

<dt><a name="1012281"> </a><code>scale</code></dt>
<dd><a name="1012283"> </a>A fixed point value used to convert from the draw window's active coordinate system to native coordinates. This field is defined only if the <a href="CompatibilityApdx.html#996955">High-Density Display Feature Set</a> is present.</dd>

<dt><a name="1012288"> </a><code>ntvToActiveScale</code></dt>
<dd><a name="1012290"> </a>A fixed point value used to convert from the native coordinate system to the draw window's active coordinate system. This field is defined only if the <a href="CompatibilityApdx.html#996955">High-Density Display Feature Set</a> is present.</dd>

<dt><a name="1012295"> </a><code>stdToActiveScale</code></dt>
<dd><a name="1012297"> </a>A fixed point value used to convert from the standard coordinate system to the draw window's active coordinate system. This field is used internally to convert font metrics, which are stored as standard coordinates. This field is defined only if the <a href="CompatibilityApdx.html#996955">High-Density Display Feature Set</a> is present.</dd>

<dt><a name="1012302"> </a><code>activeToStdScale</code></dt>
<dd><a name="1012304"> </a>The inverse of <code>stdToActive</code>; the active-to-standard scaling factor. This field is defined only if the <a href="CompatibilityApdx.html#996955">High-Density Display Feature Set</a> is present.</dd>

</dl>
<h4>
  <a name="1012309"> </a>Compatibility 
</h4>

<p><a name="1012313"> </a>This type is implemented only if <a href="CompatibilityApdx.html#994671">3.5 New Feature Set</a> is present. The <code>scale</code>, <code>ntvToActiveScale</code>, <code>stdToActiveScale</code>, and <code>activeToStdScale</code> fields are defined only if the <a href="CompatibilityApdx.html#996955">High-Density Display Feature Set</a> is present. The <code>flags</code> field is defined only if the <a href="CompatibilityApdx.html#997148">1.5x Display Feature Set</a> is present; otherwise, the contents of <code>flags</code> are reserved.</p>

<h3 class="hbH3">
  <a name="1012322"> </a>FrameBitsType Struct <a href="#1012037"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="1012324"> </a>Purpose 
</h4>

<p><a name="1012326"> </a>The <code>FrameBitsType</code> structure specifies attributes of a window's frame.</p>

<div><hr>
  <a name="1012327"> </a> <span class="warning">WARNING! </span> PalmSource, Inc. does not support or provide backward compatibility for the <code>FrameBitsType</code> bit field. Never access its bit field members directly, or your code may break in future versions. Use the information below for debugging purposes only. 
<hr>
</div>
<h4>
  <a name="1012328"> </a>Prototype 
</h4>
<pre class="proto"><a name="1012329"></a>typedef union FrameBitsType {
  struct {
    UInt16 cornerDiam  : 8;
    UInt16 reserved_3  : 3;
    UInt16 threeD      : 1;
    UInt16 shadowWidth : 2;
    UInt16 width       : 2;
  } bits;
  UInt16 word;
} FrameBitsType;
</pre>
<h4>
  <a name="1083120"> </a>Fields 
</h4>

<dl>
<dt><a name="1012342"> </a><code><code>cornerDiam</code></code></dt>
<dd><a name="1012344"> </a>Corner radius of frame; maximum is 38. </dd>

<dt><a name="1012346"> </a><code><code>reserved_3</code></code></dt>
<dd><a name="1012348"> </a>Reserved.</dd>

<dt><a name="1012350"> </a><code><code>threeD</code></code></dt>
<dd><a name="1012352"> </a>Set this bit to draw a 3D button. This feature is not currently supported. </dd>

<dt><a name="1012354"> </a><code><code>shadowWidth</code></code></dt>
<dd><a name="1012356"> </a>Width of shadow.</dd>

<dt><a name="1012358"> </a><code><code>width</code></code></dt>
<dd><a name="1012360"> </a>Frame width.</dd>

<dt><a name="1012362"> </a><code><code>word</code></code></dt>
<dd><a name="1012364"> </a>Reserved.</dd>

</dl>

<h3 class="hbH3">
  <a name="1012368"> </a>FrameType Typedef <a href="#1012037"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="1012370"> </a>Purpose 
</h4>

<p><a name="1012372"> </a>The <code>FrameType</code> type specifies a window frame style.</p>
<h4>
  <a name="1012373"> </a>Prototype 
</h4>
<pre class="proto"><a name="1012374"></a>typedef UInt16 FrameType;
</pre>

<p><a name="1012375"> </a>The <code>FrameType</code> can be set to one of the defined frame types shown in the table below, or a custom frame type as defined by a <a href="Window.html#1012322"><code>FrameBitsType</code></a> structure.</p>


<div class="tablediv"><table cellspacing="0" class="tTable">

  <tr valign="top">
    <th><p class="tt"><a name="1012381"> </a><b><span style="color: #000000;  font-style: normal; font-weight: bold; text-decoration: none; text-transform: none; vertical-align: baseline">Constant</span></b></p>
    </th>
    <th><p class="tt"><a name="1012383"> </a><b>Value</b></p>
    </th>
    <th><p class="tt"><a name="1012385"> </a><b>Description</b></p>
    </th>
  </tr>
  <tr valign="top">
    <td><p class="tt"><a name="1012388"> </a><code>noFrame</code></p>
    </td>
    <td><p class="tt"><a name="1012390"> </a>0</p>
    </td>
    <td><p class="tt"><a name="1012392"> </a>No frame</p>
    </td>
  </tr>
  <tr valign="top">
    <td><p class="tt"><a name="1012394"> </a><code>simpleFrame</code></p>
    </td>
    <td><p class="tt"><a name="1012396"> </a>1</p>
    </td>
    <td><p class="tt"><a name="1012398"> </a>Plain rectangular frame</p>
    </td>
  </tr>
  <tr valign="top">
    <td><p class="tt"><a name="1012400"> </a><code>rectangleFrame</code></p>
    </td>
    <td><p class="tt"><a name="1012402"> </a>1</p>
    </td>
    <td><p class="tt"><a name="1012404"> </a>Plain rectangular frame</p>
    </td>
  </tr>
  <tr valign="top">
    <td><p class="tt"><a name="1012406"> </a><code>simple3DFrame</code></p>
    </td>
    <td><p class="tt"><a name="1012408"> </a>0x0012</p>
    </td>
    <td><p class="tt"><a name="1012410"> </a>3D frame with width of 2. This frame type is not supported.</p>
    </td>
  </tr>
  <tr valign="top">
    <td><p class="tt"><a name="1012412"> </a><code>roundFrame</code></p>
    </td>
    <td><p class="tt"><a name="1012414"> </a>0x0401</p>
    </td>
    <td><p class="tt"><a name="1012416"> </a>Round frame with width of 1.</p>
    </td>
  </tr>
  <tr valign="top">
    <td><p class="tt"><a name="1012418"> </a><code>boldRoundFrame</code></p>
    </td>
    <td><p class="tt"><a name="1012420"> </a>0x0702</p>
    </td>
    <td><p class="tt"><a name="1012422"> </a>Round frame with width of 2.</p>
    </td>
  </tr>
  <tr valign="top">
    <td><p class="tt"><a name="1012424"> </a><code>popupFrame</code></p>
    </td>
    <td><p class="tt"><a name="1012426"> </a>0x0205</p>
    </td>
    <td><p class="tt"><a name="1012428"> </a>Popup frame style with slight corner roundness, width of 1 and shadow of 1.</p>
    </td>
  </tr>
  <tr valign="top">
    <td><p class="tt"><a name="1012430"> </a><code>dialogFrame</code></p>
    </td>
    <td><p class="tt"><a name="1012432"> </a>0x0302</p>
    </td>
    <td><p class="tt"><a name="1012434"> </a>Dialog frame style with slight corner roundness and width of 2.</p>
    </td>
  </tr>
  <tr valign="top">
    <td><p class="tt"><a name="1012436"> </a><code>menuFrame</code></p>
    </td>
    <td><p class="tt"><a name="1012438"> </a><code>popupFrame</code></p>
    </td>
    <td><p class="tt"><a name="1012441"> </a>Same as <code>popupFrame.</code></p>
    </td>
  </tr>
</table>

</div>


<h3 class="hbH3">
  <a name="1012445"> </a>IndexedColorType Typedef <a href="#1012037"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="1012447"> </a>Purpose 
</h4>

<p><a name="1012449"> </a>The <code>IndexedColorType</code> type is used to specify a color by its index value; that is, by its location in a color table. Color tables are defined by the <a href="Bitmap.html#998136"><code>ColorTableType</code></a> structure, which is declared in <code>Bitmap.h</code>. The <code>IndexedColorType</code> can hold a 1, 2, 4, or 8-bit index. </p>
<h4>
  <a name="1012453"> </a>Prototype 
</h4>
<pre class="proto"><a name="1012454"></a>typedef UInt8 IndexedColorType;
</pre>
<h4>
  <a name="1012455"> </a>Compatibility 
</h4>

<p><a name="1012459"> </a>This type is implemented only if <a href="CompatibilityApdx.html#994671">3.5 New Feature Set</a> is present.</p>

<h3 class="hbH3">
  <a name="1012462"> </a>PatternType Enum <a href="#1012037"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="1012464"> </a>Purpose 
</h4>

<p><a name="1012466"> </a>The <code>PatternType</code> enumerated type specifies a pattern for drawing. This type is returned by <a href="Window.html#1014513"><code>WinGetPatternType()</code></a> and is used as a parameter to the <a href="Window.html#1016683"><code>WinSetPatternType()</code></a> function.</p>
<h4>
  <a name="1012473"> </a>Prototype 
</h4>
<pre class="proto"><a name="1012474"></a>typedef enum { 
  blackPattern, 
  whitePattern, 
  grayPattern, 
  customPattern,
  lightGrayPattern,
  darkGrayPattern
} PatternType;
</pre>
<h4>
  <a name="1083350"> </a>Constants 
</h4>

<dl>
<dt><a name="1012485"> </a><code><code>blackPattern</code> </code></dt>
<dd><a name="1012487"> </a>Pattern with all bits on.</dd>

<dt><a name="1012489"> </a><code><code>whitePattern</code> </code></dt>
<dd><a name="1012491"> </a>Pattern with all bits off.</dd>

<dt><a name="1012493"> </a><code><code>grayPattern</code> </code></dt>
<dd><a name="1012495"> </a>Pattern with alternating on and off bits.</dd>

<dt><a name="1012497"> </a><code><code>customPattern</code> </code></dt>
<dd><a name="1012499"> </a>Custom pattern specified by <a href="Window.html#1012065"><code>CustomPatternType</code></a>.</dd>

<dt><a name="1012504"> </a><code>lightGrayPattern</code></dt>
<dd><a name="1012506"> </a>Pattern with one out of four bits in each row turned on. This value is defined only if the <a href="CompatibilityApdx.html#996955">High-Density Display Feature Set</a> is present.</dd>

<dt><a name="1012511"> </a><code>darkGrayPattern</code></dt>
<dd><a name="1012513"> </a>Pattern with one out of four bits in each row turned off. This value is defined only if the <a href="CompatibilityApdx.html#996955">High-Density Display Feature Set</a> is present.</dd>

</dl>

<p><a name="1012518"> </a>These patterns all operate with current foreground and background color instead of black and white. In effect, <code>blackPattern</code> is only black if the current foreground color is black. <code>whitePattern</code> uses the current background color. <code>grayPattern</code> and <code>customPattern</code> uses a combination of background and foreground colors.</p>

<p><a name="1012519"> </a>Patterns are expanded to the destination bit depth by the blitter when drawing patterned lines and filled rectangles.</p>

<p><a name="1012520"> </a>The three standard gray patterns&#8212;<code>grayPattern</code>, <code>lightGrayPattern</code>, and <code>darkGrayPattern</code>&#8212;are always drawn by the blitter using the screen density to improve the appearance of gray fills. Custom patterns, however, are stretched as appropriate by the blitter based on the destination density.</p>
<h4>
  <a name="1012521"> </a>Compatibility 
</h4>

<p><a name="1012522"> </a>The <code>lightGrayPattern</code> and <code>darkGrayPattern</code> values are defined only if the <a href="CompatibilityApdx.html#996955">High-Density Display Feature Set</a> is present.</p>

<h3 class="hbH3">
  <a name="1012528"> </a>UnderlineModeType Enum <a href="#1012037"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="1012530"> </a>Purpose 
</h4>

<p><a name="1012532"> </a>The <code>UnderlineModeType</code> enumerated type specifies possible values for the underline mode stored in <a href="Window.html#1012130"><code>DrawStateType</code></a>. </p>
<h4>
  <a name="1012536"> </a>Prototype 
</h4>
<pre class="proto"><a name="1012537"></a>typedef enum { noUnderline, grayUnderline,
solidUnderline, colorUnderline }
UnderlineModeType;
</pre>
<h4>
  <a name="1083367"> </a>Constants 
</h4>

<dl>
<dt><a name="1012541"> </a><code><code>noUnderline</code> </code></dt>
<dd><a name="1012543"> </a>No underline. </dd>

<dt><a name="1012545"> </a><code><code>grayUnderline</code> </code></dt>
<dd><a name="1012547"> </a>Underline is drawn using a dotted line in the current foreground color. </dd>

<dt><a name="1012549"> </a><code><code>solidUnderline</code> </code></dt>
<dd><a name="1012551"> </a>Underline is drawn using a solid line in the foreground color. </dd>

<dt><a name="1012553"> </a><code><code>colorUnderline</code> </code></dt>
<dd><a name="1012555"> </a>Underline is drawn using a solid line in the foreground color. </dd>

</dl>
<h4>
  <a name="1012557"> </a>Compatibility 
</h4>

<p><a name="1012558"> </a>The <code>solidUnderline</code> and <code>colorUnderline</code> options are only available in Palm OS 3.1 and higher. </p>

<h3 class="hbH3">
  <a name="1012561"> </a>WindowFlagsType Struct <a href="#1012037"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="1012563"> </a>Purpose 
</h4>

<p><a name="1012565"> </a>The <code>WindowFlagsType</code> specifies different window attributes.</p>

<div><hr>
  <a name="1012566"> </a> <span class="warning">WARNING! </span> PalmSource, Inc. does not support or provide backward compatibility for the <code>WindowFlagsType</code> bit field. Access it only through the functions described below. Never access its bit field members directly, or your code may break in future versions. Use the information below for debugging purposes only. 
<hr>
</div>
<h4>
  <a name="1012567"> </a>Prototype 
</h4>
<pre class="proto"><a name="1012568"></a>typedef struct WindowFlagsType {
  UInt16 format:1; 
  UInt16 offscreen:1;
  UInt16 modal:1;
  UInt16 focusable:1;
  UInt16 enabled:1;
  UInt16 visible:1;
  UInt16 dialog:1;
  UInt16 freeBitmap:1;
  UInt16 reserved :8;
} WindowFlagsType;
</pre>
<h4>
  <a name="1081207"> </a>Fields 
</h4>

<dl>
<dt><a name="1012582"> </a><code><code>format</code> </code></dt>
<dd><a name="1012584"> </a>If set, use the <code>genericFormat</code>. If 0, use <code>screenFormat</code>. </dd>

<dd><a name="1012585"> </a>Screen format is the native format of the video system; windows in this format can be copied to the display faster. The generic format is device-independent. A window cannot be enabled (that is, accept pen input) unless it uses screen format. </dd>

<dt><a name="1012587"> </a><code><code>offscreen</code> </code></dt>
<dd><a name="1012589"> </a>If set, the window is offscreen. If 0, the window is onscreen. </dd>

<dt><a name="1012591"> </a><code><code>modal</code> </code></dt>
<dd><a name="1012593"> </a>If set, the window is modal. If 0, the window is not modal. You set this value when you create the window. This value is returned by <a href="Window.html#1014974"><code>WinModal()</code></a>.</dd>

<dt><a name="1012598"> </a><code><code>focusable</code> </code></dt>
<dd><a name="1012600"> </a>If set, the window can accept the focus. If 0, the window does not accept the focus. You set this value when you create the window. </dd>

<dt><a name="1012602"> </a><code><code>enabled</code> </code></dt>
<dd><a name="1012604"> </a>If set, the window is enabled. If 0, the window is disabled. </dd>

<dt><a name="1012606"> </a><code><code>visible</code> </code></dt>
<dd><a name="1012608"> </a>If set, the window is visible if it is onscreen. If 0, the window is not visible. </dd>

<dt><a name="1012610"> </a><code><code>dialog</code> </code></dt>
<dd><a name="1012612"> </a>If set, the window is a form. If 0, the window is not a form. The <a href="Form.html#998351"><code>FrmInitForm()</code></a> function sets this value. </dd>

<dt><a name="1012617"> </a><code><code>freeBitmap</code> </code></dt>
<dd><a name="1012619"> </a>If set, free the bitmap when the window is freed. If 0, retain the bitmap after the window is freed. </dd>

<dt><a name="1012621"> </a><code><code>reserved</code> </code></dt>
<dd><a name="1012623"> </a>Reserved for future use. Must be 0.</dd>

</dl>
<h4>
  <a name="1012625"> </a>Compatibility 
</h4>

<p><a name="1012626"> </a>In OS versions previous to 3.5, the <code>freeBitmap</code> flag was not present. Instead, a <code>compressed</code> flag was present, where 0 specified uncompressed and 1 specified compressed. This compressed flag is now part of the <a href="Bitmap.html#997619"><code>BitmapType</code></a>. </p>

<h3 class="hbH3">
  <a name="1012632"> </a>WindowFormatType Enum <a href="#1012037"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="1012634"> </a>Purpose 
</h4>

<p><a name="1012635"> </a>Use this enumeration to specify the window format when creating an offscreen window with the <a href="Window.html#1013152"><code>WinCreateOffscreenWindow()</code></a> function.</p>
<h4>
  <a name="1012639"> </a>Prototype 
</h4>
<pre class="proto"><a name="1012640"></a>typedef enum { 
  screenFormat = 0,
  genericFormat,
  nativeFormat
} WindowFormatType;
</pre>
<h4>
  <a name="1076151"> </a>Constants 
</h4>

<dl>
<dt><a name="1012648"> </a><code>screenFormat</code></dt>
<dd><a name="1012650"> </a>The window's bitmap is allocated using the hardware screen's depth, but for backward compatibility the bitmap associated with the offscreen window is always low density, and the window always uses a coordinate system that directly maps offscreen pixels to coordinates.</dd>

<dt><a name="1012652"> </a><code>genericFormat</code></dt>
<dd><a name="1012654"> </a>Like <code>screenFormat</code>, except that <code>genericFormat</code> offscreen windows do not accept pen input.</dd>

<dt><a name="1012656"> </a><code>nativeFormat</code></dt>
<dd><a name="1012658"> </a>Reflects the actual hardware screen format in all ways, including screen depth, density, and pixel format. Applications must always use the graphic API when drawing to a <code>nativeFormat</code> offscreen window: directly accessing offscreen pixels will produce undefined results. When using this format, the width and height arguments must be specified using the active coordinate system. Like <code>genericFormat</code>, <code>nativeFormat</code> offscreen windows do not accept pen input. </dd>

</dl>
<h4>
  <a name="1012660"> </a>Compatibility 
</h4>

<p><a name="1012663"> </a><code>WindowFormatType</code> is defined only if the <a href="CompatibilityApdx.html#996955">High-Density Display Feature Set</a> is present.</p>

<h3 class="hbH3">
  <a name="1012667"> </a>WindowType Struct <a href="#1012037"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="1012669"> </a>Purpose 
</h4>

<p><a name="1012671"> </a>The <code>WindowType</code> structure represents a window. </p>

<div><hr>
  <a name="1012672"> </a> <span class="warning">WARNING! </span> PalmSource, Inc. does not support or provide backward compatibility for the <code>WindowType</code> structure. Access it only through the functions described below. Never access its structure members directly, or your code may break in future versions. Use the information below for debugging purposes only. 
<hr>
</div>
<h4>
  <a name="1012673"> </a>Prototype 
</h4>
<pre class="proto"><a name="1012674"></a>typedef struct WindowType {
  Coord displayWidthV20;
  Coord displayHeightV20;
  void *displayAddrV20;
  WindowFlagsType windowFlags;
  RectangleType windowBounds;
  AbsRectType clippingBounds;
  BitmapPtr bitmapP;
  FrameBitsType frameType;
  DrawStateType *drawStateP;
  struct WindowType *nextWindow;
} WindowType;
</pre>
<h4>
  <a name="1083796"> </a>Fields 
</h4>

<dl>
<dt><a name="1012689"> </a><code>displayWidthV20 </code></dt>
<dd><a name="1012691"> </a>Width of the window in pre OS 3.5 devices. In OS 3.5, use <a href="Window.html#1014219"><code>WinGetBounds()</code></a> to return the window width.</dd>

<dt><a name="1012696"> </a><code>displayHeightV20 </code></dt>
<dd><a name="1012698"> </a>Height of the window in pre OS 3.5 devices. In OS 3.5, use <a href="Window.html#1014219"><code>WinGetBounds()</code></a> to return the window height.</dd>

<dt><a name="1012703"> </a><code>displayAddrV20 </code></dt>
<dd><a name="1012705"> </a>Pointer to the window display memory buffer in pre OS 3.5 devices. In OS 3.5 or later, call <a href="Window.html#1014197"><code>WinGetBitmap()</code></a> and then <a href="Bitmap.html#998632"><code>BmpGetBits()</code></a> to obtain the window's memory buffer.</dd>

<dd><a name="1012712"> </a>Writing directly to screen memory will not be supported in all devices.</dd>

<dt><a name="1012714"> </a><code>windowFlags </code></dt>
<dd><a name="1012719"> </a>Window attributes (see <a href="Window.html#1012561"><code>WindowFlagsType</code></a>).</dd>

<dt><a name="1012721"> </a><code>windowBounds </code></dt>
<dd><a name="1012723"> </a>Display-relative bounds of the window. Use <a href="Window.html#1014219"><code>WinGetBounds()</code></a> and <a href="Window.html#1016385"><code>WinSetBounds()</code></a> to retrieve and set this value. </dd>

<dt><a name="1012731"> </a><code>clippingBounds </code></dt>
<dd><a name="1012733"> </a>Bounds for clipping any drawing within the window. Use <a href="Window.html#1014266"><code>WinGetClip()</code></a> and <a href="Window.html#1016415"><code>WinSetClip()</code></a> to retrieve and set this value. </dd>

<dt><a name="1012741"> </a><code>bitmapP </code></dt>
<dd><a name="1012743"> </a>Pointer to the window bitmap, which holds the window's contents. Use <a href="Window.html#1014197"><code>WinGetBitmap()</code></a> to retrieve this value. </dd>

<dt><a name="1012748"> </a><code>frameType </code></dt>
<dd><a name="1012753"> </a>Frame attributes; see <a href="Window.html#1012322"><code>FrameBitsType</code></a>.</dd>

<dt><a name="1012755"> </a><code>drawStateP </code></dt>
<dd><a name="1012757"> </a>Pointer to a state of the current transfer mode, pattern mode, font, underline mode, and colors. See <a href="Window.html#1012130"><code>DrawStateType</code></a>. </dd>

<dd><a name="1012761"> </a>Only one drawing state exists in the system. Each window points to the same structure. </dd>

<dt><a name="1012763"> </a><code>nextWindow </code></dt>
<dd><a name="1012765"> </a>Pointer to the next window in a linked list of windows. This linked list of windows is called the active window list. Do not change this field.</dd>

</dl>
<h4>
  <a name="1012767"> </a>Compatibility 
</h4>

<p><a name="1012768"> </a>In OS versions previous to 3.5, this structure is slightly different. Specifically, the <code>bitmapP</code> field is instead a <code>viewOrigin</code> field of type <code>PointType</code> and specified the window origin point on the display. The <code>drawStateP</code> was named <code>gstate</code> and was of type <code>GraphicStatePtr</code>. The complete definition is shown below:</p>

<div class="CodeRule"><hr></div><pre class="CodeBlock">
typedef struct WinTypeStruct {<a name="1012770"> </a>
  Word                   displayWidth;<a name="1012771"> </a>
  Word                   displayHeight;<a name="1012772"> </a>
  VoidPtr                displayAddr;<a name="1012773"> </a>
  WindowFlagsType        windowFlags;<a name="1012774"> </a>
  RectangleType          windowBounds;<a name="1012775"> </a>
  AbsRectType            clippingBounds;<a name="1012776"> </a>
  PointType              viewOrigin;<a name="1012777"> </a>
  FrameBitsType          frameType;<a name="1012778"> </a>
  GraphicStatePtr        gstate;<a name="1012779"> </a>
  struct WinTypeStruct     *nextWindow;<a name="1012780"> </a>
} WindowType;<a name="1012781"> </a>
</pre><div class="CodeRule"><hr></div>


<h3 class="hbH3">
  <a name="1012784"> </a>WinDrawOperation Enum <a href="#1012037"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="1012786"> </a>Purpose 
</h4>

<p><a name="1012788"> </a>The <code>WinDrawOperation</code> enumerated type specifies the transfer mode for color drawing. This type is used as a parameter to the <a href="Window.html#1013039"><code>WinCopyRectangle()</code></a> and <a href="Window.html#1075295"><code>WinSetDrawMode()</code></a> functions. </p>
<h4>
  <a name="1012795"> </a>Prototype 
</h4>
<pre class="proto"><a name="1012796"></a>typedef enum {winPaint, winErase, winMask,
winInvert, winOverlay, winPaintInverse,
winSwap} WinDrawOperation;
</pre>
<h4>
  <a name="1083820"> </a>Constants 
</h4>

<dl>
<dt><a name="1012800"> </a><code><code>winPaint</code></code></dt>
<dd><a name="1012802"> </a>Write color-matched source pixels to the destination. If a bitmap's <code>hasTransparency</code> flag is set, <code>winPaint</code> behaves like <code>winOverlay</code> instead.</dd>

<dt><a name="1012804"> </a><code><code>winErase</code></code></dt>
<dd><a name="1012806"> </a>Write <code>backColor</code> if the source pixel is transparent.</dd>

<dt><a name="1012808"> </a><code><code>winMask</code></code></dt>
<dd><a name="1012810"> </a>Write <code>backColor</code> if the source pixel is not transparent.</dd>

<dt><a name="1012812"> </a><code><code>winInvert</code></code></dt>
<dd><a name="1012814"> </a>Bitwise XOR the color-matched source pixel onto the destination. This mode does not honor the transparent color in any way.</dd>

<dt><a name="1012816"> </a><code><code>winOverlay</code></code></dt>
<dd><a name="1012818"> </a>Write color-matched source pixel to the destination if the source pixel is not transparent. Transparent pixels are skipped. For a 1-bit display, the "off" bits are considered to be the transparent color. Note that this definition of <code>winOverlay</code> is new for Palm OS Garnet; in Palm OS 4.x, the destination is set (only) where the source pixels are "on."</dd>

<dt><a name="1012820"> </a><code><code>winPaintInverse</code></code></dt>
<dd><a name="1012822"> </a>Invert the source pixel color and then proceed as with <code>winPaint</code>.</dd>

<dt><a name="1012824"> </a><code><code>winSwap</code></code></dt>
<dd><a name="1012826"> </a>Swap the <code>backColor</code> and <code>foreColor</code> destination colors if the source is a pattern (the type of pattern is disregarded). If the source is a bitmap, then the bitmap is transferred using <code>winPaint</code> mode instead.</dd>

</dl>

<p><a name="1012828"> </a>Note that 2-bit, 4-bit, and 8-bit source bitmaps that don't have a color table inherit the system default color table for their given depth. 1-bit sources (bitmap, text, and patterns) that don't have a color table are given a color table where entry 0 is the <code>backColor</code> and entry 1 is the <code>foreColor</code> (<code>textColor</code> for text).</p>

<p><a name="1012829"> </a><code>winSwap</code> is not a color invert operation, although a pair of <code>winSwap</code> operations will restore the original graphics data. This mode is used by the OS to select and deselect areas of the screen. It changes destination pixels matching the foreground color to the background color, and changes destination pixels matching the background color to the foreground color. It is a mode available for rectangles, lines, and pixels, but not text or bitmaps. This mode ignores the current pattern.</p>

<h4 class="hcH4">
  <a name="1012832"> </a>The Transparent Color
</h4>

<p><a name="1012833"> </a>As of Palm OS 4.0, bitmaps have a <code>hasTransparency</code> flag and may designate a transparent color. These concepts are augmented somewhat in Palm OS Garnet to make the transfer modes more consistent:</p>
<ul type="disc">
  <li><a name="1012834"> </a>Bitmaps that don't specify any transparent color (text, patterns, and version 0 bitmaps) are assumed to have a transparent color of index 0 and the <code>hasTransparency</code> bit is assumed to be <code>false</code>.
  <li><a name="1012835"> </a>When the <code>hasTransparency</code> flag is set and the transfer mode is <code>winPaint</code>, only the non-transparent pixels are copied to the destination. With text and patterns, the Palm OS assumes that the "off" bits are the ones designated as transparent and acts as if the <code>hasTransparency</code> flag is always false. This assumption retains backwards compatibility and unifies the use of transparency across all source data.
</ul>
<h4>
  <a name="1012836"> </a>Compatibility 
</h4>

<p><a name="1012840"> </a>This type is implemented only if <a href="CompatibilityApdx.html#994671">3.5 New Feature Set</a> is present. In earlier releases, this type is named <code>ScrOperation</code> and its values begin with the prefix <code>scr</code> rather than <code>win</code>. <code>WinDrawOperation</code> is fully compatible with <code>ScrOperation</code>. Transparency is only available if <a href="CompatibilityApdx.html#995256">4.0 New Feature Set</a> is present, and as mentioned in <a href="Window.html#1012832">"The Transparent Color"</a> the behavior of the window drawing modes&#8212;<code>winOverlay</code> in particular&#8212;changes slightly if <a href="CompatibilityApdx.html#997336">5.0 New Feature Set</a> is present.</p>

<h3 class="hbH3">
  <a name="1012852"> </a>WinHandle Typedef <a href="#1012037"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="1012854"> </a>Purpose 
</h4>

<p><a name="1012859"> </a>The <code>WinHandle</code> type is a pointer to a <a href="Window.html#1012667"><code>WindowType</code></a> structure. Note that this may change.</p>
<h4>
  <a name="1012860"> </a>Prototype 
</h4>
<pre class="proto"><a name="1012861"></a>typedef WindowType *WinHandle;
</pre>

<h3 class="hbH3">
  <a name="1012864"> </a>WinLineType Struct <a href="#1012037"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="1012866"> </a>Purpose 
</h4>

<p><a name="1012868"> </a>The <code>WinLineType</code> structure defines a line.</p>
<h4>
  <a name="1012869"> </a>Prototype 
</h4>
<pre class="proto"><a name="1012870"></a>typedef struct WinLineType {
  Coord x1;
  Coord y1;
  Coord x2;
  Coord y2;
} WinLineType;
</pre>
<h4>
  <a name="1084222"> </a>Fields 
</h4>

<dl>
<dt><a name="1012879"> </a><code>x1 </code></dt>
<dd><a name="1012881"> </a>X coordinate of the first endpoint of the line.</dd>

<dt><a name="1012883"> </a><code>y1 </code></dt>
<dd><a name="1012885"> </a>Y coordinate of the first endpoint of the line.</dd>

<dt><a name="1012887"> </a><code>x2 </code></dt>
<dd><a name="1012889"> </a>X coordinate of the second endpoint of the line.</dd>

<dt><a name="1012891"> </a><code>y2 </code></dt>
<dd><a name="1012893"> </a>Y coordinate of the second endpoint of the line.</dd>

</dl>
<h4>
  <a name="1012895"> </a>Compatibility 
</h4>

<p><a name="1012899"> </a>This type is implemented only if <a href="CompatibilityApdx.html#994671">3.5 New Feature Set</a> is present.</p>

<h3 class="hbH3">
  <a name="1012901"> </a>WinPtr Typedef <a href="#1012037"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="1012903"> </a>Purpose 
</h4>

<p><a name="1012908"> </a>The <code>WinPtr</code> type is a pointer to a <a href="Window.html#1012667"><code>WindowType</code></a> structure. </p>
<h4>
  <a name="1012909"> </a>Prototype 
</h4>
<pre class="proto"><a name="1012910"></a>typedef WindowType *WinPtr;
</pre>

<h2 class="haH2">
  <a name="1012912"> </a>Window Constants <a href="#1012037"><span class="nav">^TOP^</span></a>
</h2>


<p><a name="1012919"> </a>If the <a href="CompatibilityApdx.html#997336">5.0 New Feature Set</a> or the <a href="CompatibilityApdx.html#996955">High-Density Display Feature Set</a> are present, the following constants are defined:</p>
<ul type="disc">
  <li><a name="1012923"> </a><a href="Window.html#1012925">Window Coordinate System Constants</a>
</ul>

<h3 class="hbH3">
  <a name="1012925"> </a>Window Coordinate System Constants <a href="#1012037"><span class="nav">^TOP^</span></a>
</h3>


<p><a name="1012926"> </a>These constants specify the coordinate system to be used when drawing within a given window:</p>


<div class="tablediv"><table cellspacing="0" class="tTable">

  <tr valign="top">
    <th><p class="tt"><a name="1012929"> </a><b>Constant</b></p>
    </th>
    <th><p class="tt"><a name="1012931"> </a><b>Value</b></p>
    </th>
    <th><p class="tt"><a name="1012933"> </a><b>Description</b></p>
    </th>
  </tr>
  <tr valign="top">
    <td><p class="tt"><a name="1012936"> </a><code>kCoordinatesNative</code></p>
    </td>
    <td><p class="tt"><a name="1012938"> </a><code>0</code></p>
    </td>
    <td><p class="tt"><a name="1012940"> </a>Use the bitmap's native coordinate system; this enables a 1-to-1 correspondence between coordinates and pixels.</p>
    </td>
  </tr>
  <tr valign="top">
    <td><p class="tt"><a name="1012943"> </a><code>kCoordinatesStandard</code></p>
    </td>
    <td><p class="tt"><a name="1012945"> </a><code>72</code></p>
    </td>
    <td><p class="tt"><a name="1012947"> </a>The coordinate system used by most handhelds running Palm OS 4.0 and earlier. On a single-density handheld, there is one screen pixel per standard coordinate. On a high-density screen, there is more than one screen pixel per standard coordinate. </p>
    </td>
  </tr>
  <tr valign="top">
    <td><p class="tt"><a name="1012950"> </a><code>kCoordinatesOneAndAHalf</code></p>
    </td>
    <td><p class="tt"><a name="1012952"> </a><code>108</code></p>
    </td>
    <td><p class="tt"><a name="1012954"> </a>One and a half times the standard coordinate system.</p>
    </td>
  </tr>
  <tr valign="top">
    <td><p class="tt"><a name="1012957"> </a><code>kCoordinatesDouble</code></p>
    </td>
    <td><p class="tt"><a name="1012959"> </a><code>144</code></p>
    </td>
    <td><p class="tt"><a name="1012961"> </a>Twice the standard coordinate system.</p>
    </td>
  </tr>
  <tr valign="top">
    <td><p class="tt"><a name="1012964"> </a><code>kCoordinatesTriple</code></p>
    </td>
    <td><p class="tt"><a name="1012966"> </a><code>216</code></p>
    </td>
    <td><p class="tt"><a name="1012968"> </a>Three times the standard coordinate system.</p>
    </td>
  </tr>
  <tr valign="top">
    <td><p class="tt"><a name="1012971"> </a><code>kCoordinatesQuadruple</code></p>
    </td>
    <td><p class="tt"><a name="1012973"> </a><code>288</code></p>
    </td>
    <td><p class="tt"><a name="1012975"> </a>Four times the standard coordinate system.</p>
    </td>
  </tr>
</table>

</div>


<div><hr>
  <a name="1012977"> </a> <b>IMPORTANT: </b> Not all coordinate systems listed in the above table are supported in this version of the <a href="CompatibilityApdx.html#996955">High-Density Display Feature Set</a>. For Palm OS Garnet, only <code>kCoordinatesNative</code>, <code>kCoordinatesStandard</code>, and <code>kCoordinatesDouble</code> are supported.
<hr>
</div>

<p><a name="1012981"> </a>Pass one of these constants as an argument to <a href="Window.html#1074566"><code>WinSetCoordinateSystem()</code></a>. These values are returned by <a href="Window.html#1014287"><code>WinGetCoordinateSystem()</code></a>.</p>
<h4>
  <a name="1012988"> </a>Compatibility 
</h4>

<p><a name="1012992"> </a>Defined only if the <a href="CompatibilityApdx.html#996955">High-Density Display Feature Set</a> is present.</p>

<h2 class="haH2">
  <a name="1012994"> </a>Window Functions <a href="#1012037"><span class="nav">^TOP^</span></a>
</h2>


<h3 class="hbH3">
  <a name="1012997"> </a>WinClipRectangle Function <a href="#1012037"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="1012999"> </a>Purpose 
</h4>

<p><a name="1013000"> </a>Shrink the rectangle to make it fit within the clipping region of the current draw window.</p>
<h4>
  <a name="1013001"> </a>Declared In 
</h4>
<code>Window.h<a name="1013002"> </a></code><h4>
  <a name="1013003"> </a>Prototype 
</h4>
<pre class="proto"><a name="1013005"></a>void WinClipRectangle (
   RectangleType *rP
)
</pre>
<h4>
  <a name="1013006"> </a>Parameters 
</h4>

<dl>
<dt><a name="1013007"> </a><code>&harr;  <i><code>rP</code></i></code></dt>
<dd><a name="1013008"> </a>Pointer to a structure holding the rectangle to clip. The rectangle returned is the intersection of the rectangle passed and the clipping bounds of the draw window.</dd>

</dl>
<h4>
  <a name="1013009"> </a>Returns 
</h4>

<p><a name="1013010"> </a>Returns nothing.</p>
<h4>
  <a name="1013011"> </a>Comments 
</h4>

<p><a name="1013012"> </a>This function does not change the clipping rectangle of the window. To modify the window's clipping rectangle, use the <a href="Window.html#1016415"><code>WinSetClip()</code></a> and <a href="Window.html#1015632"><code>WinResetClip()</code></a> functions.</p>

<p><a name="1013019"> </a>The draw window is the window to which all drawing functions send their output. It is returned by <a href="Window.html#1014365"><code>WinGetDrawWindow()</code></a>.</p>
<h4>
  <a name="1013023"> </a>See Also 
</h4>

<p><a name="1013030"> </a><a href="Window.html#1013039"><code>WinCopyRectangle()</code></a>, <a href="Window.html#1013707"><code>WinDrawRectangle()</code></a>, <a href="Window.html#1013985"><code>WinEraseRectangle()</code></a>, <a href="Window.html#1014266"><code>WinGetClip()</code></a> </p>

<h3 class="hbH3">
  <a name="1013039"> </a>WinCopyRectangle Function <a href="#1012037"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="1013041"> </a>Purpose 
</h4>

<p><a name="1013042"> </a>Copy a rectangular region from one place to another (either between windows or within a single window).</p>
<h4>
  <a name="1013043"> </a>Declared In 
</h4>
<code>Window.h<a name="1013044"> </a></code><h4>
  <a name="1013045"> </a>Prototype 
</h4>
<pre class="proto"><a name="1013047"></a>void WinCopyRectangle (
   WinHandle srcWin,
   WinHandle dstWin,
   const RectangleType *srcRect,
   Coord destX,
   Coord destY,
   WinDrawOperation mode
)
</pre>
<h4>
  <a name="1013048"> </a>Parameters 
</h4>

<dl>
<dt><a name="1013049"> </a><code>&rarr;  <i><code>srcWin</code></i></code></dt>
<dd><a name="1013050"> </a>Window from which the rectangle is copied. If <code>NULL</code>, use the draw window. </dd>

<dt><a name="1013051"> </a><code>&rarr;  <i><code>dstWin</code></i></code></dt>
<dd><a name="1013052"> </a>Window to which the rectangle is copied. If <code>NULL</code>, use the draw window. </dd>

<dt><a name="1013053"> </a><code>&rarr;  <i><code>srcRect</code></i></code></dt>
<dd><a name="1013054"> </a>Bounds of the region to copy.</dd>

<dt><a name="1013055"> </a><code>&rarr;  <i><code>destX</code></i></code></dt>
<dd><a name="1013056"> </a>Left bound of the rectangle in destination window.</dd>

<dt><a name="1013057"> </a><code>&rarr;  <i><code>destY</code></i></code></dt>
<dd><a name="1013058"> </a>Top bound of the rectangle in destination window.</dd>

<dt><a name="1013059"> </a><code>&rarr;  <i><code>mode</code></i></code></dt>
<dd><a name="1013060"> </a>The method of transfer from the source to the destination window (see <a href="Window.html#1012784"><code>WinDrawOperation</code></a>).</dd>

</dl>
<h4>
  <a name="1013064"> </a>Returns 
</h4>

<p><a name="1013065"> </a>Returns nothing.</p>
<h4>
  <a name="1013066"> </a>Comments 
</h4>

<p><a name="1013067"> </a>Copies the bits of the window inside the rectangle region. </p>

<p><a name="1013068"> </a>If the destination bitmap is compressed, the mode parameter must be <code>winPaint</code>, and the destination coordinates must be (0,0). If the width of the destination rectangle is less than 16 pixels or if the destination coordinates are not (0,0), then this function turns off compression for the destination bitmap. Normally, you do not copy to a compressed bitmap. Instead, you copy to an uncompressed bitmap and compress it afterwards.</p>
<h4>
  <a name="1013069"> </a>Compatibility 
</h4>

<p><a name="1013070"> </a>In OS versions before 3.5, the <code>mode</code> parameter was defined as type <code>ScrOperation</code>. It is defined as type <code>WinDrawOperation</code> only if <a href="CompatibilityApdx.html#994671">3.5 New Feature Set</a> is present. <code>ScrOperation</code> and <code>WinDrawOperation</code> are fully compatible with each other. </p>

<p><a name="1013074"> </a>In OS versions before 3.5, it was common practice to render a bitmap in an offscreen window and then use <code>WinCopyRectangle</code> to draw it on the screen. In version 3.5 and higher, the preferred method of doing this is to use <a href="Window.html#1013322"><code>WinDrawBitmap()</code></a> or <a href="Window.html#1015004"><code>WinPaintBitmap()</code></a>.</p>
<h4>
  <a name="1013081"> </a>See Also 
</h4>

<p><a name="1013085"> </a><a href="Window.html#1013322"><code>WinDrawBitmap()</code></a> </p>

<h3 class="hbH3">
  <a name="1013088"> </a>WinCreateBitmapWindow Function <a href="#1012037"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="1013090"> </a>Purpose 
</h4>

<p><a name="1013091"> </a>Create a new offscreen window. </p>
<h4>
  <a name="1013092"> </a>Declared In 
</h4>
<code>Window.h<a name="1013093"> </a></code><h4>
  <a name="1013094"> </a>Prototype 
</h4>
<pre class="proto"><a name="1013096"></a>WinHandle WinCreateBitmapWindow(
   BitmapType *bitmapP,
   UInt16 *error
)
</pre>
<h4>
  <a name="1013097"> </a>Parameters 
</h4>

<dl>
<dt><a name="1013098"> </a><code>&rarr;  <i>bitmapP</i></code></dt>
<dd><a name="1013099"> </a>Pointer to a bitmap to associate with the window. (See <a href="Bitmap.html#997619"><code>BitmapType</code></a>.)</dd>

<dt><a name="1013103"> </a><code>&larr;  <i><code>error</code></i></code></dt>
<dd><a name="1013104"> </a>Pointer to any error this function encounters.</dd>

</dl>
<h4>
  <a name="1013105"> </a>Returns 
</h4>

<p><a name="1013106"> </a>Returns the handle of the new window upon success, or <code>NULL</code> if an error occurs. The <code>error</code> parameter contains one of the following:</p>

<dl>
<dt><a name="1013107"> </a><code><code>errNone</code></code></dt>
<dd><a name="1013108"> </a>No error.</dd>

<dt><a name="1013109"> </a><code><code>sysErrParamErr</code></code></dt>
<dd><a name="1013110"> </a>The <code>bitmapP</code> parameter is invalid. The bitmap must be uncompressed and it must have a valid pixel size (1, 2, 4, or 8). It must not be the screen bitmap. </dd>

<dt><a name="1013111"> </a><code><code>sysErrNoFreeResource</code></code></dt>
<dd><a name="1013112"> </a>There is not enough memory to allocate a new window structure. </dd>

</dl>
<h4>
  <a name="1013113"> </a>Comments 
</h4>

<p><a name="1013114"> </a>Use <code>WinCreateBitmapWindow</code> if you want to draw into a previously created bitmap, such as a bitmap created using <a href="Bitmap.html#998480"><code>BmpCreate()</code></a>. </p>

<p><a name="1013118"> </a>This function generates a window wrapper for the specified bitmap. The newly created window is offscreen, uses the generic format (for device independence), and is added to the active window list. Use <a href="Window.html#1016515"><code>WinSetDrawWindow()</code></a> to make it the draw window, and then use the window drawing functions to modify the bitmap. </p>

<p><a name="1013122"> </a>When you use this function to create a window and then delete the window with <a href="Window.html#1013268"><code>WinDeleteWindow()</code></a>, the bitmap is <i>not</i> freed when the window is freed. </p>

<p><a name="1013129"> </a><a href="Window.html#1013152"><code>WinCreateOffscreenWindow()</code></a> uses this function to create its offscreen window. If you call <code>WinCreateOffscreenWindow</code> instead of using this function, the bitmap is freed when <code>WinDeleteWindow</code> is called.</p>

<p><a name="1013130"> </a>The bitmap data will not be blitted properly if the depth of the screen is changed using <a href="Window.html#1015990"><code>WinScreenMode()</code></a> and the new window uses a bitmap that does not define the bitmap's color table. See <a href="Window.html#1015990"><code>WinScreenMode()</code></a> for information on how to work around this limitation.</p>
<h4>
  <a name="1013137"> </a>Compatibility 
</h4>

<p><a name="1013141"> </a>Implemented only if <a href="CompatibilityApdx.html#994671">3.5 New Feature Set</a> is present.</p>
<h4>
  <a name="1013142"> </a>See Also 
</h4>

<p><a name="1013149"> </a><a href="Window.html#1013215"><code>WinCreateWindow()</code></a>, <a href="Window.html#1013152"><code>WinCreateOffscreenWindow()</code></a> </p>

<h3 class="hbH3">
  <a name="1013152"> </a>WinCreateOffscreenWindow Function <a href="#1012037"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="1013154"> </a>Purpose 
</h4>

<p><a name="1013156"> </a>Create a new offscreen window and add it to the window list. </p>
<h4>
  <a name="1013157"> </a>Declared In 
</h4>
<code>Window.h<a name="1013158"> </a></code><h4>
  <a name="1013159"> </a>Prototype 
</h4>
<pre class="proto"><a name="1013161"></a>WinHandle WinCreateOffscreenWindow (
   Coord width,
   Coord height,
   WindowFormatType format,
   UInt16 *error
)
</pre>
<h4>
  <a name="1013163"> </a>Parameters 
</h4>

<dl>
<dt><a name="1013164"> </a><code>&rarr;  <i><code>width</code></i></code></dt>
<dd><a name="1013165"> </a>Width of the window in pixels. The coordinate system you use for this parameter depends upon the value of <code>format</code>.</dd>

<dt><a name="1013166"> </a><code>&rarr;  <i><code>height</code></i></code></dt>
<dd><a name="1013167"> </a>Height of the window in pixels. The coordinate system you use for this parameter depends upon the value of <code>format</code>.</dd>

<dt><a name="1013168"> </a><code>&rarr;  <i><code>format</code></i></code></dt>
<dd><a name="1013169"> </a>One of the window formats defined by <a href="Window.html#1012632"><code>WindowFormatType</code></a>.</dd>

<dt><a name="1013173"> </a><code>&larr;  <i><code>error</code></i></code></dt>
<dd><a name="1013174"> </a>Pointer to any error this function encounters.</dd>

</dl>
<h4>
  <a name="1013175"> </a>Returns 
</h4>

<p><a name="1013176"> </a>Returns the handle of the new window upon success, or <code>NULL</code> if an error occurs. The <code>error</code> parameter contains one of the following:</p>

<dl>
<dt><a name="1013177"> </a><code><code>errNone</code></code></dt>
<dd><a name="1013178"> </a>No error.</dd>

<dt><a name="1013179"> </a><code><code>sysErrParamErr</code></code></dt>
<dd><a name="1013180"> </a>The <code>width</code> or <code>height</code> parameter is <code>NULL</code> or the current color table is invalid. </dd>

<dt><a name="1013181"> </a><code><code>sysErrNoFreeResource</code></code></dt>
<dd><a name="1013182"> </a>There is not enough memory to complete the function.</dd>

</dl>

<p><a name="1013183"> </a>The debug ROM gives a warning if you try to draw to a bad window address. </p>
<h4>
  <a name="1013184"> </a>Comments 
</h4>

<p><a name="1013185"> </a>Windows created with this routine draw to a memory buffer instead of the display. Use this function for temporary drawing operations such as double-buffering or save-behind operations. </p>

<p><a name="1013186"> </a>The memory buffer has two formats: screen format and generic format. Screen format is the native format of the video system; windows in this format can be copied to the display faster. The generic format is device-independent. A window cannot be enabled (that is, accept pen input) unless it uses screen format.</p>

<p><a name="1013190"> </a>This function differs from <a href="Window.html#1013088"><code>WinCreateBitmapWindow()</code></a> in the following ways: </p>
<ul type="disc">
  <li><a name="1013191"> </a><code>WinCreateOffscreenWindow</code> creates a new bitmap in the same depth as the current screen. <code>WinCreateBitmapWindow</code> uses the bitmap you pass in, which may or may not be in the same depth as the current screen. 
  <li><a name="1013192"> </a><code>WinCreateOffscreenWindow</code> uses the screen format you specify. <code>WinCreateBitmapWindow</code> always uses <code>genericFormat</code> for the format argument.
  <li><a name="1013193"> </a>When you delete the window created with <code>WinCreateOffscreenWindow</code>, its bitmap is freed along with the window. The bitmap used in the <code>WinCreateBitmapWindow</code> is not freed when the window is freed.
</ul>

<p><a name="1013194"> </a>Note that if you aren't directly accessing the bits of an offscreen window's bitmap but are just using the APIs, you can always pass <code>nativeFormat</code> for the screen format even on pre-Palm OS Garnet handhelds and things will work as expected. If you need direct access to the bits of the offscreen window's bitmap, however, call <a href="Bitmap.html#998480"><code>BmpCreate()</code></a> and then call <code>WinCreateBitmapWindow</code>. Because you created the bitmap, you know its format and thus can safely manipulate its bits. Calling <code>WinCreateOffscreenWindow</code> with a <code>format</code> argument of <code>nativeFormat</code> can result in a bitmap with an unexpected format: the endianness, number of bits per pixel, and so on would match the screen and therefore be fastest to draw, but your application wouldn't be able to manipulate the pixels directly.</p>

<p><a name="1013198"> </a>The bitmap data will not be blitted properly if the depth of the screen is changed using <a href="Window.html#1015990"><code>WinScreenMode()</code></a> and the new window uses a bitmap that does not define the bitmap's color table. See <a href="Window.html#1015990"><code>WinScreenMode()</code></a> for information on how to work around this limitation.</p>
<h4>
  <a name="1013205"> </a>See Also 
</h4>

<p><a name="1013212"> </a><a href="Window.html#1013215"><code>WinCreateWindow()</code></a>, <a href="Window.html#1015990"><code>WinScreenMode()</code></a>,</p>

<h3 class="hbH3">
  <a name="1013215"> </a>WinCreateWindow Function <a href="#1012037"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="1013217"> </a>Purpose 
</h4>

<p><a name="1013218"> </a>Create a new window and add it to the window list.</p>
<h4>
  <a name="1013219"> </a>Declared In 
</h4>
<code>Window.h<a name="1013220"> </a></code><h4>
  <a name="1013221"> </a>Prototype 
</h4>
<pre class="proto"><a name="1013223"></a>WinHandle WinCreateWindow(
   const RectangleType *bounds,
   FrameType frame,
   Boolean modal,
   Boolean focusable,
   UInt16 *error
)
</pre>
<h4>
  <a name="1013224"> </a>Parameters 
</h4>

<dl>
<dt><a name="1013225"> </a><code>&rarr;  <i><code>bounds</code></i></code></dt>
<dd><a name="1013226"> </a>Display-relative bounds of the window.</dd>

<dt><a name="1013227"> </a><code>&rarr;  <i><code>frame</code></i></code></dt>
<dd><a name="1013231"> </a>Type of frame around the window (see <a href="Window.html#1012368"><code>FrameType</code></a>).</dd>

<dt><a name="1013232"> </a><code>&rarr;  <i><code>modal</code></i></code></dt>
<dd><a name="1013234"> </a><code>true</code> if the window is modal.</dd>

<dt><a name="1013235"> </a><code>&rarr;  <i><code>focusable</code></i></code></dt>
<dd><a name="1013237"> </a><code>true</code> if the window can be the active window.</dd>

<dt><a name="1013238"> </a><code>&larr;  <i><code>error</code></i></code></dt>
<dd><a name="1013239"> </a>Pointer to any error encountered by this function.</dd>

</dl>
<h4>
  <a name="1013240"> </a>Returns 
</h4>

<p><a name="1013241"> </a>Returns the handle of the new window upon success, or <code>NULL</code> if an error occurs. The <code>error</code> parameter contains one of the following:</p>

<dl>
<dt><a name="1013242"> </a><code><code>errNone</code></code></dt>
<dd><a name="1013243"> </a>No error.</dd>

<dt><a name="1013244"> </a><code><code>sysErrNoFreeResource</code></code></dt>
<dd><a name="1013245"> </a>There is not enough memory to complete the operation.</dd>

</dl>
<h4>
  <a name="1013246"> </a>Comments 
</h4>

<p><a name="1013247"> </a>Windows created by this routine draw to the display. See <a href="Window.html#1013152"><code>WinCreateOffscreenWindow()</code></a> for information on drawing off screen.</p>

<p><a name="1013251"> </a>You typically don't call this function directly. Instead, you use <a href="Form.html#998351"><code>FrmInitForm()</code></a> to create form windows from a resource. Forms are much more flexible and have better system support. All forms are windows, but not all windows are forms. </p>

<p><a name="1013255"> </a>The window is created with the bounds and frame type that you specify and uses the bitmap and drawing state of the current draw window. Its clipping region is reset according to the bounds you specify. </p>

<p><a name="1013256"> </a>All window flags are set to 0 except for the modal and focusable flags, which you pass as a parameter to this function. Specifically, newly created windows are disabled and invisible. You must specifically enable the window before the window can accept input. You can do so with <a href="Window.html#1016249"><code>WinSetActiveWindow()</code></a>.</p>
<h4>
  <a name="1013261"> </a>See Also 
</h4>

<p><a name="1013265"> </a><a href="Window.html#1013268"><code>WinDeleteWindow()</code></a> </p>

<h3 class="hbH3">
  <a name="1013268"> </a>WinDeleteWindow Function <a href="#1012037"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="1013270"> </a>Purpose 
</h4>

<p><a name="1013271"> </a>Remove a window from the window list and free the memory used by the window.</p>
<h4>
  <a name="1013272"> </a>Declared In 
</h4>
<code>Window.h<a name="1013273"> </a></code><h4>
  <a name="1013274"> </a>Prototype 
</h4>
<pre class="proto"><a name="1013276"></a>void WinDeleteWindow (
   WinHandle winHandle,
   Boolean eraseIt
)
</pre>
<h4>
  <a name="1013277"> </a>Parameters 
</h4>

<dl>
<dt><a name="1013278"> </a><code>&rarr;  <i><code>winHandle</code></i></code></dt>
<dd><a name="1013279"> </a>Handle of window to delete.</dd>

<dt><a name="1013280"> </a><code>&rarr;  <i><code>eraseIt</code></i></code></dt>
<dd><a name="1013281"> </a>If <code>true</code>, the window is erased before it is deleted. If <code>false</code>, the window is not erased. </dd>

</dl>
<h4>
  <a name="1013282"> </a>Returns 
</h4>

<p><a name="1013283"> </a>Returns nothing.</p>
<h4>
  <a name="1013284"> </a>Comments 
</h4>

<p><a name="1013285"> </a>This function frees all memory associated with the window. Windows created using <a href="Window.html#1013152"><code>WinCreateOffscreenWindow()</code></a> have their bitmaps freed; windows created using <a href="Window.html#1013215"><code>WinCreateWindow()</code></a> or <a href="Window.html#1013088"><code>WinCreateBitmapWindow()</code></a> do not. </p>

<p><a name="1013295"> </a>The <code>eraseIt</code> parameter affects onscreen windows only; offscreen windows are never erased. As a performance optimization, you might set <code>eraseIt</code> to <code>false</code> for an onscreen window if you know that you are going to immediately redraw the area anyway. For example, when the form manager closes a form dialog, it restores the area with the save-behind bits it had stored for that form. For this reason, when the form manager deletes the dialog window, it passes <code>false</code> for <code>eraseIt</code> because the entire area will be redrawn. </p>

<h3 class="hbH3">
  <a name="1013298"> </a>WinDisplayToWindowPt Function <a href="#1012037"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="1013300"> </a>Purpose 
</h4>

<p><a name="1013302"> </a>Convert a display-relative coordinate to a window-relative coordinate. The coordinate returned is relative to the display window.</p>
<h4>
  <a name="1013303"> </a>Declared In 
</h4>
<code>Window.h<a name="1013304"> </a></code><h4>
  <a name="1013305"> </a>Prototype 
</h4>
<pre class="proto"><a name="1013307"></a>void WinDisplayToWindowPt (
   Coord *extentX,
   Coord *extentY
)
</pre>
<h4>
  <a name="1013308"> </a>Parameters 
</h4>

<dl>
<dt><a name="1013309"> </a><code>&harr;  <i><code>extentX</code></i></code></dt>
<dd><a name="1013310"> </a>Pointer to x coordinate to convert.</dd>

<dt><a name="1013311"> </a><code>&harr;  <i><code>extentY</code></i></code></dt>
<dd><a name="1013312"> </a>Pointer to y coordinate to convert.</dd>

</dl>
<h4>
  <a name="1013313"> </a>Returns 
</h4>

<p><a name="1013314"> </a>Returns nothing.</p>
<h4>
  <a name="1013315"> </a>See Also 
</h4>

<p><a name="1013319"> </a><a href="Window.html#1017085"><code>WinWindowToDisplayPt()</code></a></p>

<h3 class="hbH3">
  <a name="1013322"> </a>WinDrawBitmap Function <a href="#1012037"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="1013324"> </a>Purpose 
</h4>

<p><a name="1013325"> </a>Draw a bitmap at the given coordinates in <code>winPaint</code> mode (see <a href="Window.html#1012784"><code>WinDrawOperation</code></a> for mode details).</p>
<h4>
  <a name="1013329"> </a>Declared In 
</h4>
<code>Window.h<a name="1013330"> </a></code><h4>
  <a name="1013331"> </a>Prototype 
</h4>
<pre class="proto"><a name="1013333"></a>void WinDrawBitmap (
   BitmapPtr bitmapP,
   Coord x,
   Coord y
)
</pre>
<h4>
  <a name="1013334"> </a>Parameters 
</h4>

<dl>
<dt><a name="1013335"> </a><code>&rarr;  <i><code>bitmapP</code></i></code></dt>
<dd><a name="1013336"> </a>Pointer to a bitmap.</dd>

<dt><a name="1013337"> </a><code>&rarr;  <i><code>x</code></i></code></dt>
<dd><a name="1013338"> </a>The x coordinate of the top-left corner.</dd>

<dt><a name="1013339"> </a><code>&rarr;  <i><code>y</code></i></code></dt>
<dd><a name="1013340"> </a>The y coordinate of the top-left corner.</dd>

</dl>
<h4>
  <a name="1013341"> </a>Returns 
</h4>

<p><a name="1013342"> </a>Returns nothing.</p>
<h4>
  <a name="1013343"> </a>Comments 
</h4>

<p><a name="1013344"> </a>If the bitmap has multiple depths (is a bitmap family), the closest match less than or equal to the current draw window depth is used. If such a bitmap does not exist, the bitmap with the closest match greater than the draw window depth is used. </p>

<p><a name="1013345"> </a>If the bitmap has its own color table, color conversion to the draw window color table will be applied (on OS 3.5 or later). This color conversion is slow and not recommended. Instead of including a color table in the bitmap, consider using <a href="Window.html#1015523"><code>WinPalette()</code></a> to change the system color table, draw the bitmap, and then change the system color table back when the bitmap is no longer visible. </p>

<p><a name="1013352"> </a>This function differs from <a href="Window.html#1015004"><code>WinPaintBitmap()</code></a> in that this function always uses <code>winPaint</code> mode (copy mode) as the transfer mode. <code>WinPaintBitmap</code> uses the current drawing state transfer mode. </p>
<h4>
  <a name="1013353"> </a>See Also 
</h4>

<p><a name="1013357"> </a><a href="Window.html#1013985"><code>WinEraseRectangle()</code></a> </p>

<h3 class="hbH3">
  <a name="1013360"> </a>WinDrawChar Function <a href="#1012037"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="1013362"> </a>Purpose 
</h4>

<p><a name="1013363"> </a>Draw the specified character in the draw window.</p>
<h4>
  <a name="1013364"> </a>Declared In 
</h4>
<code>Window.h<a name="1013365"> </a></code><h4>
  <a name="1013366"> </a>Prototype 
</h4>
<pre class="proto"><a name="1013367"></a>void WinDrawChar (
   WChar theChar,
   Coord x,
   Coord y
)
</pre>
<h4>
  <a name="1013368"> </a>Parameters 
</h4>

<dl>
<dt><a name="1013369"> </a><code>&rarr;  <i><code>theChar</code></i></code></dt>
<dd><a name="1013370"> </a>The character to draw. This may be either a single-byte character or a multi-byte character. </dd>

<dt><a name="1013371"> </a><code>&rarr;  <i><code>x</code></i></code></dt>
<dd><a name="1013372"> </a>x coordinate of the location where the character is to be drawn (left bound).</dd>

<dt><a name="1013373"> </a><code>&rarr;  <i><code>y</code></i></code></dt>
<dd><a name="1013374"> </a>y coordinate of the location where the character is to be drawn (top bound).</dd>

</dl>
<h4>
  <a name="1013375"> </a>Returns 
</h4>

<p><a name="1013376"> </a>Returns nothing.</p>
<h4>
  <a name="1013377"> </a>Comments 
</h4>

<p><a name="1013381"> </a>Before calling this function, call <a href="Window.html#1016917"><code>WinSetUnderlineMode()</code></a> and <a href="Font.html#1000753"><code>FntSetFont()</code></a> to set the desired underline and font to draw the characters. </p>

<p><a name="1013388"> </a>This function differs from <a href="Window.html#1015054"><code>WinPaintChar()</code></a> in that this function always uses <code>winPaint</code> mode (see <a href="Window.html#1012784"><code>WinDrawOperation</code></a>). This means the on bits are drawn in the text color, the off bits are in the background color, and underlines are in the foreground color. <code>WinPaintChar</code> uses the current drawing state transfer mode instead of <code>winPaint</code>. </p>
<h4>
  <a name="1013392"> </a>Compatibility 
</h4>

<p><a name="1013396"> </a>Implemented only if <a href="CompatibilityApdx.html#993788">3.1 New Feature Set</a> is present. To use this function in code intended to be run on earlier versions of Palm OS, link with the PalmOSGlue library and call <code>WinGlueDrawChar</code>. For more information, see <a href="PalmOSGlueLib.html#1030875">Chapter 80, "PalmOSGlue Library."</a></p>

<div><hr>
  <a name="1013401"> </a> <b>NOTE: </b> Though this function is new in the 3.1 New Feature Set, due to a bug in the 3.1 implementation, when running on Palm OS 3.1 you must link with the PalmOSGlue library and call <code>WinGlueDrawChar</code>, rather than calling <code>WinDrawChar</code>.
<hr>
</div>
<h4>
  <a name="1013402"> </a>See Also 
</h4>

<p><a name="1013409"> </a><a href="Window.html#1013424"><code>WinDrawChars()</code></a>, <a href="Window.html#1013566"><code>WinDrawInvertedChars()</code></a>, <a href="Window.html#1013790"><code>WinDrawTruncChars()</code></a>, <a href="Window.html#1013856"><code>WinEraseChars()</code></a>, <a href="Window.html#1014749"><code>WinInvertChars()</code></a>, <a href="Window.html#1015108"><code>WinPaintChars()</code></a> </p>

<h3 class="hbH3">
  <a name="1013424"> </a>WinDrawChars Function <a href="#1012037"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="1013426"> </a>Purpose 
</h4>

<p><a name="1013427"> </a>Draw the specified characters in the draw window. </p>
<h4>
  <a name="1013428"> </a>Declared In 
</h4>
<code>Window.h<a name="1013429"> </a></code><h4>
  <a name="1013430"> </a>Prototype 
</h4>
<pre class="proto"><a name="1013432"></a>void WinDrawChars (
   const Char *chars,
   Int16 len,
   Coord x,
   Coord y
)
</pre>
<h4>
  <a name="1013433"> </a>Parameters 
</h4>

<dl>
<dt><a name="1013434"> </a><code>&rarr;  <i><code>chars</code></i></code></dt>
<dd><a name="1013435"> </a>Pointer to the characters to draw.</dd>

<dt><a name="1013436"> </a><code>&rarr;  <i><code>len</code></i></code></dt>
<dd><a name="1013437"> </a>Length in bytes of the characters to draw.</dd>

<dt><a name="1013438"> </a><code>&rarr;  <i><code>x</code></i></code></dt>
<dd><a name="1013439"> </a>x coordinate of the first character to draw (left bound).</dd>

<dt><a name="1013440"> </a><code>&rarr;  <i><code>y</code></i></code></dt>
<dd><a name="1013441"> </a>y coordinate of the first character to draw (top bound).</dd>

</dl>
<h4>
  <a name="1013442"> </a>Returns 
</h4>

<p><a name="1013443"> </a>Returns nothing.</p>
<h4>
  <a name="1013444"> </a>Comments 
</h4>

<p><a name="1013445"> </a>This function is useful for printing non-editable status or warning messages on the screen. </p>

<p><a name="1013449"> </a>Before calling this function, call <a href="Window.html#1016917"><code>WinSetUnderlineMode()</code></a> and <a href="Font.html#1000753"><code>FntSetFont()</code></a> to set the desired underline and font to draw the characters. </p>

<p><a name="1013456"> </a>This function differs from <a href="Window.html#1015108"><code>WinPaintChars()</code></a> in that this function always uses <code>winPaint</code> mode (see <a href="Window.html#1012784"><code>WinDrawOperation</code></a>). This means the on bits are drawn in the text color, the off bits are in the background color, and underlines are in the foreground color. <code>WinPaintChar</code> uses the current drawing state transfer mode instead of <code>winPaint</code>. </p>
<h4>
  <a name="1013460"> </a>See Also 
</h4>

<p><a name="1013467"> </a><a href="Window.html#1013360"><code>WinDrawChar()</code></a>, <a href="Window.html#1013566"><code>WinDrawInvertedChars()</code></a>, <a href="Window.html#1013790"><code>WinDrawTruncChars()</code></a>, <a href="Window.html#1013856"><code>WinEraseChars()</code></a>, <a href="Window.html#1014749"><code>WinInvertChars()</code></a>, <a href="Window.html#1015054"><code>WinPaintChar()</code></a> </p>

<h3 class="hbH3">
  <a name="1013482"> </a>WinDrawGrayLine Function <a href="#1012037"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="1013484"> </a>Purpose 
</h4>

<p><a name="1013485"> </a>Draw a dashed line in the draw window.</p>
<h4>
  <a name="1013486"> </a>Declared In 
</h4>
<code>Window.h<a name="1013487"> </a></code><h4>
  <a name="1013488"> </a>Prototype 
</h4>
<pre class="proto"><a name="1013490"></a>void WinDrawGrayLine (
   Coord x1,
   Coord y1,
   Coord x2,
   Coord y2
)
</pre>
<h4>
  <a name="1013491"> </a>Parameters 
</h4>

<dl>
<dt><a name="1013492"> </a><code>&rarr;  <i><code>x1</code></i></code></dt>
<dd><a name="1013493"> </a>x coordinate of line start point.</dd>

<dt><a name="1013494"> </a><code>&rarr;  <i><code>y1</code></i></code></dt>
<dd><a name="1013495"> </a>y coordinate of line start point.</dd>

<dt><a name="1013496"> </a><code>&rarr;  <i><code>x2</code></i></code></dt>
<dd><a name="1013497"> </a>x coordinate of line endpoint.</dd>

<dt><a name="1013498"> </a><code>&rarr;  <i><code>y2</code></i></code></dt>
<dd><a name="1013499"> </a>y coordinate of line endpoint.</dd>

</dl>
<h4>
  <a name="1013500"> </a>Returns 
</h4>

<p><a name="1013501"> </a>Returns nothing.</p>
<h4>
  <a name="1013502"> </a>Comments 
</h4>

<p><a name="1013503"> </a>This routine does not draw in the gray color; it draws with alternating foreground and background pixels. That is, it uses the <code>grayPattern</code> pattern type. </p>
<h4>
  <a name="1013504"> </a>See Also 
</h4>

<p><a name="1013514"> </a><a href="Window.html#1013620"><code>WinDrawLine()</code></a>, <a href="Window.html#1013906"><code>WinEraseLine()</code></a>, <a href="Window.html#1014083"><code>WinFillLine()</code></a>, <a href="Window.html#1014810"><code>WinInvertLine()</code></a>, <a href="Window.html#1015171"><code>WinPaintLine()</code></a>, <a href="Window.html#1015223"><code>WinPaintLines()</code></a> </p>

<h3 class="hbH3">
  <a name="1013526"> </a>WinDrawGrayRectangleFrame Function <a href="#1012037"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="1013528"> </a>Purpose 
</h4>

<p><a name="1013529"> </a>Draw a gray rectangular frame in the draw window.</p>
<h4>
  <a name="1013530"> </a>Declared In 
</h4>
<code>Window.h<a name="1013531"> </a></code><h4>
  <a name="1013532"> </a>Prototype 
</h4>
<pre class="proto"><a name="1013534"></a>void WinDrawGrayRectangleFrame (
   FrameType frame,
   const RectangleType *rP
)
</pre>
<h4>
  <a name="1013535"> </a>Parameters 
</h4>

<dl>
<dt><a name="1013536"> </a><code>&rarr;  <i><code>frame</code></i></code></dt>
<dd><a name="1013540"> </a>Type of frame to draw (see <a href="Window.html#1012368"><code>FrameType</code></a>).</dd>

<dt><a name="1013541"> </a><code>&rarr;  <i><code>rP</code></i></code></dt>
<dd><a name="1013542"> </a>Pointer to the rectangle to frame.</dd>

</dl>
<h4>
  <a name="1013543"> </a>Returns 
</h4>

<p><a name="1013544"> </a>Returns nothing.</p>
<h4>
  <a name="1013545"> </a>Comments 
</h4>

<p><a name="1013546"> </a>This routine does not draw in the gray color; it draws with alternating foreground and background pixels. The standard gray pattern is not used by this routine; rather, the frame is drawn so that the top-left pixel of the frame is always on.</p>
<h4>
  <a name="1013547"> </a>See Also 
</h4>

<p><a name="1013554"> </a><a href="Window.html#1013745"><code>WinDrawRectangleFrame()</code></a>, <a href="Window.html#1014019"><code>WinEraseRectangleFrame()</code></a>, <a href="Window.html#1014438"><code>WinGetFramesRectangle()</code></a>, <a href="Window.html#1014933"><code>WinInvertRectangleFrame()</code></a>, <a href="Window.html#1015401"><code>WinPaintRectangleFrame()</code></a> </p>

<h3 class="hbH3">
  <a name="1013566"> </a>WinDrawInvertedChars Function <a href="#1012037"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="1013568"> </a>Purpose 
</h4>

<p><a name="1013569"> </a>Draw the specified characters inverted (background color) in the draw window. </p>
<h4>
  <a name="1013570"> </a>Declared In 
</h4>
<code>Window.h<a name="1013571"> </a></code><h4>
  <a name="1013572"> </a>Prototype 
</h4>
<pre class="proto"><a name="1013574"></a>void WinDrawInvertedChars (
   const Char *chars,
   Int16 len,
   Coord x,
   Coord y
)
</pre>
<h4>
  <a name="1013575"> </a>Parameters 
</h4>

<dl>
<dt><a name="1013576"> </a><code>&rarr;  <i><code>chars</code></i></code></dt>
<dd><a name="1013577"> </a>Pointer to the characters to draw.</dd>

<dt><a name="1013578"> </a><code>&rarr;  <i><code>len</code></i></code></dt>
<dd><a name="1013579"> </a>Length in bytes of the characters to draw.</dd>

<dt><a name="1013580"> </a><code>&rarr;  <i><code>x</code></i></code></dt>
<dd><a name="1013581"> </a>x coordinate of the first character to draw (left bound).</dd>

<dt><a name="1013582"> </a><code>&rarr;  <i><code>y</code></i></code></dt>
<dd><a name="1013583"> </a>y coordinate of the first character to draw (top bound).</dd>

</dl>
<h4>
  <a name="1013584"> </a>Returns 
</h4>

<p><a name="1013585"> </a>Returns nothing.</p>
<h4>
  <a name="1013586"> </a>Comments 
</h4>

<p><a name="1013587"> </a>This routine draws the <i>on</i> bits and any underline in the background color and the <i>off</i> bits in the text color. (Black and white uses copy NOT mode.) This is the standard function for drawing inverted text.</p>

<p><a name="1013588"> </a>Before calling this function, consider calling <a href="Window.html#1016917"><code>WinSetUnderlineMode()</code></a> and <a href="Font.html#1000753"><code>FntSetFont()</code></a>.</p>
<h4>
  <a name="1013595"> </a>See Also 
</h4>

<p><a name="1013605"> </a><a href="Window.html#1013360"><code>WinDrawChar()</code></a>, <a href="Window.html#1013424"><code>WinDrawChars()</code></a>, <a href="Window.html#1013790"><code>WinDrawTruncChars()</code></a>, <a href="Window.html#1013856"><code>WinEraseChars()</code></a>, <a href="Window.html#1014749"><code>WinInvertChars()</code></a>, <a href="Window.html#1015054"><code>WinPaintChar()</code></a>, <a href="Window.html#1015108"><code>WinPaintChars()</code></a> </p>

<h3 class="hbH3">
  <a name="1013620"> </a>WinDrawLine Function <a href="#1012037"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="1013622"> </a>Purpose 
</h4>

<p><a name="1013623"> </a>Draw a line in the draw window using the current foreground color.</p>
<h4>
  <a name="1013624"> </a>Declared In 
</h4>
<code>Window.h<a name="1013625"> </a></code><h4>
  <a name="1013626"> </a>Prototype 
</h4>
<pre class="proto"><a name="1013628"></a>void WinDrawLine (
   Coord x1,
   Coord y1,
   Coord x2,
   Coord y2
)
</pre>
<h4>
  <a name="1013629"> </a>Parameters 
</h4>

<dl>
<dt><a name="1013630"> </a><code>&rarr;  <i><code>x1</code></i></code></dt>
<dd><a name="1013631"> </a>x coordinate of line start point.</dd>

<dt><a name="1013632"> </a><code>&rarr;  <i><code>y1</code></i></code></dt>
<dd><a name="1013633"> </a>y coordinate of line start point.</dd>

<dt><a name="1013634"> </a><code>&rarr;  <i><code>x2</code></i></code></dt>
<dd><a name="1013635"> </a>x coordinate of line endpoint.</dd>

<dt><a name="1013636"> </a><code>&rarr;  <i><code>y2</code></i></code></dt>
<dd><a name="1013637"> </a>y coordinate of line endpoint.</dd>

</dl>
<h4>
  <a name="1013638"> </a>Returns 
</h4>

<p><a name="1013639"> </a>Returns nothing.</p>
<h4>
  <a name="1013640"> </a>Comments 
</h4>

<p><a name="1013644"> </a>This function differs from <a href="Window.html#1015171"><code>WinPaintLine()</code></a> in that it always uses <code>winPaint</code> mode (see <a href="Window.html#1012784"><code>WinDrawOperation</code></a>). <code>WinPaintLine</code> uses the current drawing state transfer mode instead of <code>winPaint</code>. </p>
<h4>
  <a name="1013648"> </a>See Also 
</h4>

<p><a name="1013658"> </a><a href="Window.html#1013482"><code>WinDrawGrayLine()</code></a>, <a href="Window.html#1013906"><code>WinEraseLine()</code></a>, <a href="Window.html#1014083"><code>WinFillLine()</code></a>, <a href="Window.html#1014810"><code>WinInvertLine()</code></a>, <a href="Window.html#1015171"><code>WinPaintLine()</code></a>, <a href="Window.html#1015223"><code>WinPaintLines()</code></a> </p>

<h3 class="hbH3">
  <a name="1013670"> </a>WinDrawPixel Function <a href="#1012037"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="1013672"> </a>Purpose 
</h4>

<p><a name="1013673"> </a>Draw a pixel in the draw window using the current foreground color.</p>
<h4>
  <a name="1013674"> </a>Declared In 
</h4>
<code>Window.h<a name="1013675"> </a></code><h4>
  <a name="1013676"> </a>Prototype 
</h4>
<pre class="proto"><a name="1013678"></a>void WinDrawPixel (
   Coord x,
   Coord y
)
</pre>
<h4>
  <a name="1013679"> </a>Parameters 
</h4>

<dl>
<dt><a name="1013680"> </a><code>&rarr;  <i><code>x</code></i></code></dt>
<dd><a name="1013681"> </a>Pointer to the x coordinate of a pixel.</dd>

<dt><a name="1013682"> </a><code>&rarr;  <i><code>y</code></i></code></dt>
<dd><a name="1013683"> </a>Pointer to the y coordinate of a pixel.</dd>

</dl>
<h4>
  <a name="1013684"> </a>Returns 
</h4>

<p><a name="1013685"> </a>Returns nothing. May display a fatal error message if the draw window's bitmap is compressed. </p>
<h4>
  <a name="1013686"> </a>Compatibility 
</h4>

<p><a name="1013690"> </a>Implemented only if <a href="CompatibilityApdx.html#994671">3.5 New Feature Set</a> is present.</p>
<h4>
  <a name="1013691"> </a>See Also 
</h4>

<p><a name="1013701"> </a><a href="Window.html#1013948"><code>WinErasePixel()</code></a>, <a href="Window.html#1014855"><code>WinInvertPixel()</code></a>, <a href="Window.html#1015274"><code>WinPaintPixel()</code></a>, <a href="Window.html#1015316"><code>WinPaintPixels()</code></a> </p>

<h3 class="hbH3">
  <a name="1013707"> </a>WinDrawRectangle Function <a href="#1012037"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="1013709"> </a>Purpose 
</h4>

<p><a name="1013710"> </a>Draw a rectangle in the draw window using the current foreground color.</p>
<h4>
  <a name="1013711"> </a>Declared In 
</h4>
<code>Window.h<a name="1013712"> </a></code><h4>
  <a name="1013713"> </a>Prototype 
</h4>
<pre class="proto"><a name="1013715"></a>void WinDrawRectangle (
   const RectangleType *rP,
   UInt16 cornerDiam
)
</pre>
<h4>
  <a name="1013716"> </a>Parameters 
</h4>

<dl>
<dt><a name="1013717"> </a><code>&rarr;  <i><code>rP</code></i></code></dt>
<dd><a name="1013718"> </a>Pointer to the rectangle to draw.</dd>

<dt><a name="1013719"> </a><code>&rarr;  <i><code>cornerDiam</code></i></code></dt>
<dd><a name="1013720"> </a>Radius of rounded corners. Specify zero for square corners.</dd>

</dl>
<h4>
  <a name="1013721"> </a>Returns 
</h4>

<p><a name="1013722"> </a>Returns nothing.</p>
<h4>
  <a name="1013723"> </a>Comments 
</h4>

<p><a name="1013724"> </a>The <code>cornerDiam</code> parameter specifies the radius of four imaginary circles used to form the rounded corners. An imaginary circle is placed within each corner tangent to the rectangle on two sides.</p>

<p><a name="1013728"> </a>This function differs from <a href="Window.html#1015358"><code>WinPaintRectangle()</code></a> in that it always uses <code>winPaint</code> mode (see <a href="Window.html#1012784"><code>WinDrawOperation</code></a>). <code>WinPaintRectangle</code> uses the current drawing state transfer mode instead of <code>winPaint</code>. </p>
<h4>
  <a name="1013732"> </a>See Also 
</h4>

<p><a name="1013739"> </a><a href="Window.html#1013985"><code>WinEraseRectangle()</code></a>, <a href="Window.html#1014130"><code>WinFillRectangle()</code></a>, <a href="Window.html#1014895"><code>WinInvertRectangle()</code></a> </p>

<h3 class="hbH3">
  <a name="1013745"> </a>WinDrawRectangleFrame Function <a href="#1012037"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="1013747"> </a>Purpose 
</h4>

<p><a name="1013748"> </a>Draw a rectangular frame in the draw window using the current foreground color.</p>
<h4>
  <a name="1013750"> </a>Declared In 
</h4>
<code>Window.h<a name="1013751"> </a></code><h4>
  <a name="1013752"> </a>Prototype 
</h4>
<pre class="proto"><a name="1013754"></a>void WinDrawRectangleFrame (
   FrameType frame,
   const RectangleType *rP
)
</pre>
<h4>
  <a name="1013755"> </a>Parameters 
</h4>

<dl>
<dt><a name="1013756"> </a><code>&rarr;  <i><code>frame</code></i></code></dt>
<dd><a name="1013760"> </a>Type of frame to draw (see <a href="Window.html#1012368"><code>FrameType</code></a>).</dd>

<dt><a name="1013761"> </a><code>&rarr;  <i><code>rP</code></i></code></dt>
<dd><a name="1013762"> </a>Pointer to the rectangle to frame.</dd>

</dl>
<h4>
  <a name="1013763"> </a>Returns 
</h4>

<p><a name="1013764"> </a>Returns nothing.</p>
<h4>
  <a name="1013765"> </a>Comments 
</h4>

<p><a name="1013766"> </a>The frame is drawn outside the specified rectangle. </p>

<p><a name="1013770"> </a>This function differs from <a href="Window.html#1015401"><code>WinPaintRectangleFrame()</code></a> in that it always uses <code>winPaint</code> mode (see <a href="Window.html#1012784"><code>WinDrawOperation</code></a>). <code>WinPaintRectangleFrame</code> uses the current drawing state transfer mode instead of <code>winPaint</code>. </p>
<h4>
  <a name="1013774"> </a>See Also 
</h4>

<p><a name="1013780"> </a><a href="Window.html#1013526"><code>WinDrawGrayRectangleFrame()</code></a>, <a href="Window.html#1014019"><code>WinEraseRectangleFrame()</code></a>, <a href="Window.html#1014438"><code>WinGetFramesRectangle()</code></a>, <a href="Window.html#1014933"><code>WinInvertRectangleFrame()</code></a> </p>

<h3 class="hbH3">
  <a name="1013790"> </a>WinDrawTruncChars Function <a href="#1012037"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="1013792"> </a>Purpose 
</h4>

<p><a name="1013793"> </a>Draw the specified characters in the draw window, truncating the characters to the specified width.</p>
<h4>
  <a name="1013794"> </a>Declared In 
</h4>
<code>Window.h<a name="1013795"> </a></code><h4>
  <a name="1013796"> </a>Prototype 
</h4>
<pre class="proto"><a name="1013797"></a>void WinDrawTruncChars (
   const Char *chars,
   Int16 len,
   Coord x,
   Coord y,
   Coord maxWidth
)
</pre>
<h4>
  <a name="1013798"> </a>Parameters 
</h4>

<dl>
<dt><a name="1013799"> </a><code>&rarr;  <i><code>chars</code></i></code></dt>
<dd><a name="1013800"> </a>Pointer to the characters to draw.</dd>

<dt><a name="1013801"> </a><code>&rarr;  <i><code>len</code></i></code></dt>
<dd><a name="1013802"> </a>Length in bytes of the characters to draw.</dd>

<dt><a name="1013803"> </a><code>&rarr;  <i><code>x</code></i></code></dt>
<dd><a name="1013804"> </a>x coordinate of the first character to draw (left bound).</dd>

<dt><a name="1013805"> </a><code>&rarr;  <i><code>y</code></i></code></dt>
<dd><a name="1013806"> </a>y coordinate of the first character to draw (top bound).</dd>

<dt><a name="1013807"> </a><code>&rarr;  <i><code>maxWidth</code></i></code></dt>
<dd><a name="1013808"> </a>Maximum width in pixels of the characters that are to be drawn.</dd>

</dl>
<h4>
  <a name="1013809"> </a>Returns 
</h4>

<p><a name="1013810"> </a>Returns nothing.</p>
<h4>
  <a name="1013811"> </a>Comments 
</h4>

<p><a name="1013812"> </a>Before calling this function, consider calling <a href="Window.html#1016917"><code>WinSetUnderlineMode()</code></a> and <a href="Font.html#1000753"><code>FntSetFont()</code></a>. </p>

<p><a name="1013819"> </a>If drawing all of the specified characters requires more space than <code>maxWidth</code> allows, <code>WinDrawTruncChars</code> draws one less than the number of characters that can fit in <code>maxWidth</code> and then draws an ellipsis (...) in the remaining space. (If the boundary characters are narrower than the ellipsis, more than one character may be dropped to make room.) If <code>maxWidth</code> is narrower than the width of an ellipsis, nothing is drawn. </p>

<p><a name="1013820"> </a>Use this function to truncate text that may contain multi-byte characters. </p>
<h4>
  <a name="1013821"> </a>Compatibility 
</h4>

<p><a name="1013825"> </a>Implemented only if <a href="CompatibilityApdx.html#993788">3.1 New Feature Set</a> is present. To use this function in code intended to be run on earlier versions of Palm OS, link with the PalmOSGlue library and call <code>WinGlueDrawTruncChars</code>. For more information, see <a href="PalmOSGlueLib.html#1030875">Chapter 80, "PalmOSGlue Library."</a></p>

<div><hr>
  <a name="1013830"> </a> <b>NOTE: </b> Though this function is new in the 3.1 New Feature Set, due to a bug in the 3.1 implementation, when running on Palm OS 3.1 you must link with the PalmOSGlue library and call <code>WinGlueDrawTruncChars</code>, rather than calling <code>WinDrawTruncChars</code>.
<hr>
</div>
<h4>
  <a name="1013831"> </a>See Also 
</h4>

<p><a name="1013838"> </a><a href="Window.html#1013360"><code>WinDrawChar()</code></a>, <a href="Window.html#1013424"><code>WinDrawChars()</code></a>, <a href="Window.html#1013566"><code>WinDrawInvertedChars()</code></a>, <a href="Window.html#1013856"><code>WinEraseChars()</code></a>, <a href="Window.html#1014749"><code>WinInvertChars()</code></a>, <a href="Window.html#1015054"><code>WinPaintChar()</code></a>, <a href="Window.html#1015108"><code>WinPaintChars()</code></a> </p>

<h3 class="hbH3">
  <a name="1013856"> </a>WinEraseChars Function <a href="#1012037"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="1013858"> </a>Purpose 
</h4>

<p><a name="1013859"> </a>Erase the specified characters in the draw window.</p>
<h4>
  <a name="1013860"> </a>Declared In 
</h4>
<code>Window.h<a name="1013861"> </a></code><h4>
  <a name="1013862"> </a>Prototype 
</h4>
<pre class="proto"><a name="1013864"></a>void WinEraseChars (
   const Char *chars,
   Int16 len,
   Coord x,
   Coord y
)
</pre>
<h4>
  <a name="1013865"> </a>Parameters 
</h4>

<dl>
<dt><a name="1013866"> </a><code>&rarr;  <i><code>chars</code></i></code></dt>
<dd><a name="1013867"> </a>Pointer to the characters to erase.</dd>

<dt><a name="1013868"> </a><code>&rarr;  <i><code>len</code></i></code></dt>
<dd><a name="1013869"> </a>Length in bytes of the characters to erase.</dd>

<dt><a name="1013870"> </a><code>&rarr;  <i><code>x</code></i></code></dt>
<dd><a name="1013871"> </a>x coordinate of the first character to erase (left bound).</dd>

<dt><a name="1013872"> </a><code>&rarr;  <i><code>y</code></i></code></dt>
<dd><a name="1013873"> </a>y coordinate of the first character to erase (top bound).</dd>

</dl>
<h4>
  <a name="1013874"> </a>Returns 
</h4>

<p><a name="1013875"> </a>Returns nothing.</p>
<h4>
  <a name="1013876"> </a>Comments 
</h4>

<p><a name="1013877"> </a>The <code>winMask</code> transfer mode is used to erase the characters. See <a href="Window.html#1012784"><code>WinDrawOperation</code></a> for more information. This has the effect of erasing only the on bits for the characters rather than the entire text rectangle. This function only works if the foreground color is black and the background color is white. </p>
<h4>
  <a name="1013881"> </a>See Also 
</h4>

<p><a name="1013888"> </a><a href="Window.html#1013360"><code>WinDrawChar()</code></a>, <a href="Window.html#1013424"><code>WinDrawChars()</code></a>, <a href="Window.html#1013566"><code>WinDrawInvertedChars()</code></a>, <a href="Window.html#1013790"><code>WinDrawTruncChars()</code></a>, <a href="Window.html#1014749"><code>WinInvertChars()</code></a>, <a href="Window.html#1015054"><code>WinPaintChar()</code></a>, <a href="Window.html#1015108"><code>WinPaintChars()</code></a> </p>

<h3 class="hbH3">
  <a name="1013906"> </a>WinEraseLine Function <a href="#1012037"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="1013908"> </a>Purpose 
</h4>

<p><a name="1013909"> </a>Draw a line in the draw window using the current background color.</p>
<h4>
  <a name="1013910"> </a>Declared In 
</h4>
<code>Window.h<a name="1013911"> </a></code><h4>
  <a name="1013912"> </a>Prototype 
</h4>
<pre class="proto"><a name="1013914"></a>void WinEraseLine (
   Coord x1,
   Coord y1,
   Coord x2,
   Coord y2
)
</pre>
<h4>
  <a name="1013915"> </a>Parameters 
</h4>

<dl>
<dt><a name="1013916"> </a><code>&rarr;  <i><code>x1</code></i></code></dt>
<dd><a name="1013917"> </a>x coordinate of line start point.</dd>

<dt><a name="1013918"> </a><code>&rarr;  <i><code>y1</code></i></code></dt>
<dd><a name="1013919"> </a>y coordinate of line start point.</dd>

<dt><a name="1013920"> </a><code>&rarr;  <i><code>x2</code></i></code></dt>
<dd><a name="1013921"> </a>x coordinate of line endpoint.</dd>

<dt><a name="1013922"> </a><code>&rarr;  <i><code>y2</code></i></code></dt>
<dd><a name="1013923"> </a>y coordinate of line endpoint.</dd>

</dl>
<h4>
  <a name="1013924"> </a>Returns 
</h4>

<p><a name="1013925"> </a>Returns nothing.</p>
<h4>
  <a name="1013926"> </a>See Also 
</h4>

<p><a name="1013936"> </a><a href="Window.html#1013482"><code>WinDrawGrayLine()</code></a>, <a href="Window.html#1013620"><code>WinDrawLine()</code></a>, <a href="Window.html#1014083"><code>WinFillLine()</code></a>, <a href="Window.html#1014810"><code>WinInvertLine()</code></a>, <a href="Window.html#1015171"><code>WinPaintLine()</code></a>, <a href="Window.html#1015223"><code>WinPaintLines()</code></a> </p>

<h3 class="hbH3">
  <a name="1013948"> </a>WinErasePixel Function <a href="#1012037"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="1013950"> </a>Purpose 
</h4>

<p><a name="1013951"> </a>Draw a pixel in the draw window using the current background color.</p>
<h4>
  <a name="1013952"> </a>Declared In 
</h4>
<code>Window.h<a name="1013953"> </a></code><h4>
  <a name="1013954"> </a>Prototype 
</h4>
<pre class="proto"><a name="1013956"></a>void WinErasePixel (
   Coord x,
   Coord y
)
</pre>
<h4>
  <a name="1013957"> </a>Parameters 
</h4>

<dl>
<dt><a name="1013958"> </a><code>&rarr;  <i><code>x</code></i></code></dt>
<dd><a name="1013959"> </a>Pointer to the x coordinate of a pixel.</dd>

<dt><a name="1013960"> </a><code>&rarr;  <i><code>y</code></i></code></dt>
<dd><a name="1013961"> </a>Pointer to the y coordinate of a pixel.</dd>

</dl>
<h4>
  <a name="1013962"> </a>Returns 
</h4>

<p><a name="1013963"> </a>Returns nothing.</p>
<h4>
  <a name="1013964"> </a>Compatibility 
</h4>

<p><a name="1013968"> </a>Implemented only if <a href="CompatibilityApdx.html#994671">3.5 New Feature Set</a> is present.</p>
<h4>
  <a name="1013969"> </a>See Also 
</h4>

<p><a name="1013979"> </a><a href="Window.html#1013670"><code>WinDrawPixel()</code></a>, <a href="Window.html#1014855"><code>WinInvertPixel()</code></a>, <a href="Window.html#1015274"><code>WinPaintPixel()</code></a>, <a href="Window.html#1015316"><code>WinPaintPixels()</code></a> </p>

<h3 class="hbH3">
  <a name="1013985"> </a>WinEraseRectangle Function <a href="#1012037"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="1013987"> </a>Purpose 
</h4>

<p><a name="1013988"> </a>Draw a rectangle in the draw window using the current background color.</p>
<h4>
  <a name="1013989"> </a>Declared In 
</h4>
<code>Window.h<a name="1013990"> </a></code><h4>
  <a name="1013991"> </a>Prototype 
</h4>
<pre class="proto"><a name="1013993"></a>void WinEraseRectangle (
   const RectangleType *rP,
   UInt16 cornerDiam
)
</pre>
<h4>
  <a name="1013994"> </a>Parameters 
</h4>

<dl>
<dt><a name="1013995"> </a><code>&rarr;  <i><code>rP</code></i></code></dt>
<dd><a name="1013996"> </a>Pointer to the rectangle to erase.</dd>

<dt><a name="1013997"> </a><code>&rarr;  <i><code>cornerDiam</code></i></code></dt>
<dd><a name="1013998"> </a>Radius of rounded corners. Specify zero for square corners.</dd>

</dl>
<h4>
  <a name="1013999"> </a>Returns 
</h4>

<p><a name="1014000"> </a>Returns nothing.</p>
<h4>
  <a name="1014001"> </a>Comments 
</h4>

<p><a name="1014002"> </a>The <code>cornerDiam</code> parameter specifies the radius of four imaginary circles used to form the rounded corners. An imaginary circle is placed within each corner tangent to the rectangle on two sides.</p>
<h4>
  <a name="1014003"> </a>See Also 
</h4>

<p><a name="1014010"> </a><a href="Window.html#1013707"><code>WinDrawRectangle()</code></a>, <a href="Window.html#1014130"><code>WinFillRectangle()</code></a>, <a href="Window.html#1014895"><code>WinInvertRectangle()</code></a>, <a href="Window.html#1015358"><code>WinPaintRectangle()</code></a> </p>

<h3 class="hbH3">
  <a name="1014019"> </a>WinEraseRectangleFrame Function <a href="#1012037"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="1014021"> </a>Purpose 
</h4>

<p><a name="1014022"> </a>Draw a rectangular frame in the draw window using the current background color.</p>
<h4>
  <a name="1014023"> </a>Declared In 
</h4>
<code>Window.h<a name="1014024"> </a></code><h4>
  <a name="1014025"> </a>Prototype 
</h4>
<pre class="proto"><a name="1014027"></a>void WinEraseRectangleFrame (
   FrameType frame,
   const RectangleType *rP
)
</pre>
<h4>
  <a name="1014028"> </a>Parameters 
</h4>

<dl>
<dt><a name="1014029"> </a><code>&rarr;  <i><code>frame</code></i></code></dt>
<dd><a name="1014033"> </a>Type of frame to draw (see <a href="Window.html#1012368"><code>FrameType</code></a>).</dd>

<dt><a name="1014034"> </a><code>&rarr;  <i><code>rP</code></i></code></dt>
<dd><a name="1014035"> </a>Pointer to the rectangle to frame.</dd>

</dl>
<h4>
  <a name="1014036"> </a>Returns 
</h4>

<p><a name="1014037"> </a>Returns nothing.</p>
<h4>
  <a name="1014038"> </a>See Also 
</h4>

<p><a name="1014044"> </a><a href="Window.html#1013526"><code>WinDrawGrayRectangleFrame()</code></a>, <a href="Window.html#1013745"><code>WinDrawRectangleFrame()</code></a>, <a href="Window.html#1014438"><code>WinGetFramesRectangle()</code></a>, <a href="Window.html#1014933"><code>WinInvertRectangleFrame()</code></a>, <a href="Window.html#1015401"><code>WinPaintRectangleFrame()</code></a> </p>

<h3 class="hbH3">
  <a name="1014057"> </a>WinEraseWindow Function <a href="#1012037"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="1014059"> </a>Purpose 
</h4>

<p><a name="1014060"> </a>Erase the contents of the draw window. </p>
<h4>
  <a name="1014061"> </a>Declared In 
</h4>
<code>Window.h<a name="1014062"> </a></code><h4>
  <a name="1014063"> </a>Prototype 
</h4>
<pre class="proto"><a name="1014065"></a>void WinEraseWindow (
   void
)
</pre>
<h4>
  <a name="1014066"> </a>Parameters 
</h4>

<dl>
<dt><a name="1014067"> </a><code>None.</code></dt>
</dl>
<h4>
  <a name="1014068"> </a>Returns 
</h4>

<p><a name="1014069"> </a>Returns nothing.</p>
<h4>
  <a name="1014070"> </a>Comments 
</h4>

<p><a name="1014074"> </a><a href="Window.html#1013985"><code>WinEraseRectangle()</code></a> is used to erase the window. This routine doesn't erase the frame around the draw window. See <a href="Window.html#1014019"><code>WinEraseRectangleFrame()</code></a> and <a href="Window.html#1014692"><code>WinGetWindowFrameRect()</code></a>. </p>

<h3 class="hbH3">
  <a name="1014083"> </a>WinFillLine Function <a href="#1012037"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="1014085"> </a>Purpose 
</h4>

<p><a name="1014086"> </a>Fill a line in the draw window with the current pattern.</p>
<h4>
  <a name="1014087"> </a>Declared In 
</h4>
<code>Window.h<a name="1014088"> </a></code><h4>
  <a name="1014089"> </a>Prototype 
</h4>
<pre class="proto"><a name="1014091"></a>void WinFillLine (
   Coord x1,
   Coord y1,
   Coord x2,
   Coord y2
)
</pre>
<h4>
  <a name="1014092"> </a>Parameters 
</h4>

<dl>
<dt><a name="1014093"> </a><code>&rarr;  <i><code>x1</code></i></code></dt>
<dd><a name="1014094"> </a>x coordinate of line start point.</dd>

<dt><a name="1014095"> </a><code>&rarr;  <i><code>y1</code></i></code></dt>
<dd><a name="1014096"> </a>y coordinate of line start point.</dd>

<dt><a name="1014097"> </a><code>&rarr;  <i><code>x2</code></i></code></dt>
<dd><a name="1014098"> </a>x coordinate of line endpoint.</dd>

<dt><a name="1014099"> </a><code>&rarr;  <i><code>y2</code></i></code></dt>
<dd><a name="1014100"> </a>y coordinate of line endpoint.</dd>

</dl>
<h4>
  <a name="1014101"> </a>Returns 
</h4>

<p><a name="1014102"> </a>Returns nothing.</p>
<h4>
  <a name="1014103"> </a>Comments 
</h4>

<p><a name="1014107"> </a>You can set the current pattern with <a href="Window.html#1016643"><code>WinSetPattern()</code></a>.</p>
<h4>
  <a name="1014108"> </a>See Also 
</h4>

<p><a name="1014118"> </a><a href="Window.html#1013482"><code>WinDrawGrayLine()</code></a>, <a href="Window.html#1013620"><code>WinDrawLine()</code></a>, <a href="Window.html#1013906"><code>WinEraseLine()</code></a>, <a href="Window.html#1014810"><code>WinInvertLine()</code></a>, <a href="Window.html#1015171"><code>WinPaintLine()</code></a>, <a href="Window.html#1015223"><code>WinPaintLines()</code></a> </p>

<h3 class="hbH3">
  <a name="1014130"> </a>WinFillRectangle Function <a href="#1012037"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="1014132"> </a>Purpose 
</h4>

<p><a name="1014133"> </a>Draw a rectangle in the draw window with current pattern.</p>
<h4>
  <a name="1014134"> </a>Declared In 
</h4>
<code>Window.h<a name="1014135"> </a></code><h4>
  <a name="1014136"> </a>Prototype 
</h4>
<pre class="proto"><a name="1014138"></a>void WinFillRectangle (
   const RectangleType *rP,
   UInt16 cornerDiam
)
</pre>
<h4>
  <a name="1014139"> </a>Parameters 
</h4>

<dl>
<dt><a name="1014140"> </a><code>&rarr;  <i><code>rP</code></i></code></dt>
<dd><a name="1014141"> </a>Pointer to the rectangle to draw.</dd>

<dt><a name="1014142"> </a><code>&rarr;  <i><code>cornerDiam</code></i></code></dt>
<dd><a name="1014143"> </a>Radius of rounded corners. Specify zero for square corners.</dd>

</dl>
<h4>
  <a name="1014144"> </a>Returns 
</h4>

<p><a name="1014145"> </a>Returns nothing.</p>
<h4>
  <a name="1014146"> </a>Comments 
</h4>

<p><a name="1014150"> </a>You can set the current pattern with <a href="Window.html#1016643"><code>WinSetPattern()</code></a>.</p>

<p><a name="1014151"> </a>The <code>cornerDiam</code> parameter specifies the radius of four imaginary circles used to form the rounded corners. An imaginary circle is placed within each corner tangent to the rectangle on two sides.</p>
<h4>
  <a name="1014152"> </a>See Also 
</h4>

<p><a name="1014159"> </a><a href="Window.html#1013707"><code>WinDrawRectangle()</code></a>, <a href="Window.html#1013985"><code>WinEraseRectangle()</code></a>, <a href="Window.html#1014895"><code>WinInvertRectangle()</code></a>, <a href="Window.html#1015358"><code>WinPaintRectangle()</code></a> </p>

<h3 class="hbH3">
  <a name="1014168"> </a>WinGetActiveWindow Function <a href="#1012037"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="1014170"> </a>Purpose 
</h4>

<p><a name="1014171"> </a>Return the window handle of the active window.</p>
<h4>
  <a name="1014172"> </a>Declared In 
</h4>
<code>Window.h<a name="1014173"> </a></code><h4>
  <a name="1014174"> </a>Prototype 
</h4>
<pre class="proto"><a name="1014176"></a>WinHandle WinGetActiveWindow (
   void
)
</pre>
<h4>
  <a name="1014177"> </a>Parameters 
</h4>

<dl>
<dt><a name="1014178"> </a><code>None.</code></dt>
</dl>
<h4>
  <a name="1014179"> </a>Returns 
</h4>

<p><a name="1014180"> </a>Returns the handle of the active window. All user input is directed to the active window. </p>
<h4>
  <a name="1014181"> </a>See Also 
</h4>

<p><a name="1014188"> </a><a href="Window.html#1016249"><code>WinSetActiveWindow()</code></a>, <a href="Window.html#1014337"><code>WinGetDisplayWindow()</code></a>, <a href="Window.html#1014416"><code>WinGetFirstWindow()</code></a>, <a href="Window.html#1014365"><code>WinGetDrawWindow()</code></a> </p>

<h3 class="hbH3">
  <a name="1014197"> </a>WinGetBitmap Function <a href="#1012037"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="1014199"> </a>Purpose 
</h4>

<p><a name="1014200"> </a>Return a pointer to a window's bitmap, which holds the window contents. </p>
<h4>
  <a name="1014201"> </a>Declared In 
</h4>
<code>Window.h<a name="1014202"> </a></code><h4>
  <a name="1014203"> </a>Prototype 
</h4>
<pre class="proto"><a name="1014204"></a>BitmapType *WinGetBitmap (
   WinHandle winHandle
)
</pre>
<h4>
  <a name="1014205"> </a>Parameters 
</h4>

<dl>
<dt><a name="1014206"> </a><code>&rarr;  <i><code>winHandle</code></i></code></dt>
<dd><a name="1014207"> </a>Handle of window from which to get the bitmap.</dd>

</dl>
<h4>
  <a name="1014208"> </a>Returns 
</h4>

<p><a name="1014209"> </a>Returns a pointer to the bitmap or <code>NULL</code> if <code>winHandle</code> is invalid.</p>
<h4>
  <a name="1014210"> </a>Comments 
</h4>

<p><a name="1014211"> </a>For onscreen windows, the bitmap returned always represents the whole screen. Thus, the top-left corner of the returned bitmap may not be the top-left corner of the window. </p>
<h4>
  <a name="1014212"> </a>Compatibility 
</h4>

<p><a name="1014216"> </a>Implemented only if <a href="CompatibilityApdx.html#994671">3.5 New Feature Set</a> is present.</p>

<h3 class="hbH3">
  <a name="1014219"> </a>WinGetBounds Function <a href="#1012037"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="1014221"> </a>Purpose 
</h4>

<p><a name="1014222"> </a>Return the bounds of a window in display-relative coordinates.</p>
<h4>
  <a name="1014223"> </a>Declared In 
</h4>
<code>Window.h<a name="1014224"> </a></code><h4>
  <a name="1014225"> </a>Prototype 
</h4>
<pre class="proto"><a name="1014227"></a>void WinGetBounds (
   WinHandle winH,
   RectangleType *rP
)
</pre>
<h4>
  <a name="1014228"> </a>Parameters 
</h4>

<dl>
<dt><a name="1014229"> </a><code>&rarr;  <i><code>winH</code></i></code></dt>
<dd><a name="1014230"> </a>Handle to a window.</dd>

<dt><a name="1014231"> </a><code>&larr;  <i><code>rP</code></i></code></dt>
<dd><a name="1014232"> </a>Pointer to a rectangle.</dd>

</dl>
<h4>
  <a name="1014233"> </a>Returns 
</h4>

<p><a name="1014234"> </a>Returns nothing.</p>
<h4>
  <a name="1014235"> </a>Comments 
</h4>

<p><a name="1014236"> </a>This function returns in <code>rP</code> the bounds of the window represented by <code>winH</code>. This corresponds to the convention used by <a href="Window.html#1016385"><code>WinSetBounds()</code></a>, because it takes a window handle as an argument.</p>
<h4>
  <a name="1014240"> </a>Compatibility 
</h4>

<p><a name="1014241"> </a>The implementation of this function changed in Palm OS version 4.0. If <a href="CompatibilityApdx.html#995256">4.0 New Feature Set</a> is present, it works as documented here. </p>

<p><a name="1014245"> </a>Prior to Palm OS 4.0, <code>WinGetBounds</code> returned the bounds of the draw window, and did not take a window handle as an argument. If an application needed to determine the bounds of an arbitrary window, the application would call <a href="Window.html#1016515"><code>WinSetDrawWindow()</code></a> to temporarily set the draw window to the desired window, then <code>WinGetBounds</code> would be called to get the bounds of the draw window, then <a href="Window.html#1016515"><code>WinSetDrawWindow()</code></a> would be called again to restore the draw window. This is no longer necessary.</p>

<p><a name="1014252"> </a>As of Palm OS 4.0, an application should use <a href="Window.html#1014391"><code>WinGetDrawWindowBounds()</code></a> to get the bounds of the draw window.</p>
<h4>
  <a name="1014256"> </a>See Also 
</h4>

<p><a name="1014263"> </a><a href="Window.html#1014666"><code>WinGetWindowExtent()</code></a>, <a href="Window.html#1014391"><code>WinGetDrawWindowBounds()</code></a></p>

<h3 class="hbH3">
  <a name="1014266"> </a>WinGetClip Function <a href="#1012037"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="1014268"> </a>Purpose 
</h4>

<p><a name="1014269"> </a>Return the clipping rectangle of the draw window.</p>
<h4>
  <a name="1014270"> </a>Declared In 
</h4>
<code>Window.h<a name="1014271"> </a></code><h4>
  <a name="1014272"> </a>Prototype 
</h4>
<pre class="proto"><a name="1014274"></a>void WinGetClip (
   RectangleType *rP
)
</pre>
<h4>
  <a name="1014275"> </a>Parameters 
</h4>

<dl>
<dt><a name="1014276"> </a><code>&larr;  <i><code>rP</code></i></code></dt>
<dd><a name="1014277"> </a>Pointer to a structure to hold the clipping bounds.</dd>

</dl>
<h4>
  <a name="1014278"> </a>Returns 
</h4>

<p><a name="1014279"> </a>Returns nothing.</p>
<h4>
  <a name="1014280"> </a>See Also 
</h4>

<p><a name="1014284"> </a><a href="Window.html#1016415"><code>WinSetClip()</code></a></p>

<h3 class="hbH3">
  <a name="1014287"> </a>WinGetCoordinateSystem Function <a href="#1012037"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="1014289"> </a>Purpose 
</h4>

<p><a name="1014290"> </a>Get the coordinate system</p>
<h4>
  <a name="1014291"> </a>Declared In 
</h4>
<code>Window.h<a name="1014292"> </a></code><h4>
  <a name="1014293"> </a>Prototype 
</h4>
<pre class="proto"><a name="1014294"></a>UInt16 WinGetCoordinateSystem (
   void
)
</pre>
<h4>
  <a name="1014295"> </a>Parameters 
</h4>

<dl>
<dt><a name="1014296"> </a><code>None.</code></dt>
</dl>
<h4>
  <a name="1014297"> </a>Returns 
</h4>

<p><a name="1014298"> </a>Returns a value representing the current coordinate system. See <a href="Window.html#1012925">"Window Coordinate System Constants"</a> for the values that this function can return.</p>
<h4>
  <a name="1014302"> </a>Comments 
</h4>

<p><a name="1014303"> </a>Use this function to determine the active coordinate system. Armed with this information, an application can properly initialize graphic primitive coordinates and dimensions, or can modify the coordinate system with <a href="Window.html#1074566"><code>WinSetCoordinateSystem()</code></a>.</p>
<h4>
  <a name="1014307"> </a>Compatibility 
</h4>

<p><a name="1014311"> </a>Implemented only if the <a href="CompatibilityApdx.html#996955">High-Density Display Feature Set</a> is present.</p>
<h4>
  <a name="1014312"> </a>See Also 
</h4>

<p><a name="1014316"> </a><a href="Window.html#1074566"><code>WinSetCoordinateSystem()</code></a></p>

<h3 class="hbH3">
  <a name="1014319"> </a>WinGetDisplayExtent Function <a href="#1012037"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="1014321"> </a>Purpose 
</h4>

<p><a name="1014322"> </a>Return the width and height of the display (the screen).</p>
<h4>
  <a name="1014323"> </a>Declared In 
</h4>
<code>Window.h<a name="1014324"> </a></code><h4>
  <a name="1014325"> </a>Prototype 
</h4>
<pre class="proto"><a name="1014327"></a>void WinGetDisplayExtent (
   Coord *extentX,
   Coord *extentY
)
</pre>
<h4>
  <a name="1014328"> </a>Parameters 
</h4>

<dl>
<dt><a name="1014329"> </a><code>&larr;  <i><code>extentX</code></i></code></dt>
<dd><a name="1014330"> </a>Pointer to the width of the display in pixels.</dd>

<dt><a name="1014331"> </a><code>&larr;  <i><code>extentY</code></i></code></dt>
<dd><a name="1014332"> </a>Pointer to the height of the display in pixels.</dd>

</dl>
<h4>
  <a name="1014333"> </a>Returns 
</h4>

<p><a name="1014334"> </a>Returns nothing.</p>

<h3 class="hbH3">
  <a name="1014337"> </a>WinGetDisplayWindow Function <a href="#1012037"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="1014339"> </a>Purpose 
</h4>

<p><a name="1014340"> </a>Return the window handle of the display (screen) window.</p>
<h4>
  <a name="1014341"> </a>Declared In 
</h4>
<code>Window.h<a name="1014342"> </a></code><h4>
  <a name="1014343"> </a>Prototype 
</h4>
<pre class="proto"><a name="1014345"></a>WinHandle WinGetDisplayWindow (
   void
)
</pre>
<h4>
  <a name="1014346"> </a>Parameters 
</h4>

<p><a name="1014347"> </a>None.</p>
<h4>
  <a name="1014348"> </a>Returns 
</h4>

<p><a name="1014349"> </a>Returns the handle of display window.</p>
<h4>
  <a name="1014350"> </a>Comments 
</h4>

<p><a name="1014351"> </a>The display window is created by the system at start-up; it has the same size as the Palm OS drawable area of the physical display (screen).</p>
<h4>
  <a name="1014352"> </a>See Also 
</h4>

<p><a name="1014359"> </a><a href="Window.html#1014319"><code>WinGetDisplayExtent()</code></a>, <a href="Window.html#1014168"><code>WinGetActiveWindow()</code></a>, <a href="Window.html#1014365"><code>WinGetDrawWindow()</code></a> </p>

<h3 class="hbH3">
  <a name="1014365"> </a>WinGetDrawWindow Function <a href="#1012037"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="1014367"> </a>Purpose 
</h4>

<p><a name="1014368"> </a>Return the window handle of the current draw window.</p>
<h4>
  <a name="1014369"> </a>Declared In 
</h4>
<code>Window.h<a name="1014370"> </a></code><h4>
  <a name="1014371"> </a>Prototype 
</h4>
<pre class="proto"><a name="1014373"></a>WinHandle WinGetDrawWindow (
   void
)
</pre>
<h4>
  <a name="1014374"> </a>Parameters 
</h4>

<p><a name="1014375"> </a>None.</p>
<h4>
  <a name="1014376"> </a>Returns 
</h4>

<p><a name="1014377"> </a>Returns handle of draw window.</p>
<h4>
  <a name="1014378"> </a>See Also 
</h4>

<p><a name="1014385"> </a><a href="Window.html#1014337"><code>WinGetDisplayWindow()</code></a>, <a href="Window.html#1014168"><code>WinGetActiveWindow()</code></a>, <a href="Window.html#1016515"><code>WinSetDrawWindow()</code></a> </p>

<h3 class="hbH3">
  <a name="1014391"> </a>WinGetDrawWindowBounds Function <a href="#1012037"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="1014393"> </a>Purpose 
</h4>

<p><a name="1014394"> </a>Return the bounds of the draw window.</p>
<h4>
  <a name="1014395"> </a>Declared In 
</h4>
<code>Window.h<a name="1014396"> </a></code><h4>
  <a name="1014397"> </a>Prototype 
</h4>
<pre class="proto"><a name="1014398"></a>void WinGetDrawWindowBounds (
   RectangleType *rP
)
</pre>
<h4>
  <a name="1014399"> </a>Parameters 
</h4>

<dl>
<dt><a name="1014400"> </a><code>&larr;  <i><code>rP</code></i></code></dt>
<dd><a name="1014401"> </a>Pointer to the window bounds.</dd>

</dl>
<h4>
  <a name="1014402"> </a>Returns 
</h4>

<p><a name="1014403"> </a>Returns nothing.</p>
<h4>
  <a name="1014404"> </a>Comments 
</h4>

<p><a name="1014405"> </a>A pointer to the bounds of the draw window is returned. This function is equivalent to <a href="Window.html#1014219"><code>WinGetBounds()</code></a> that was in Palm OS prior to 4.0.</p>
<h4>
  <a name="1014409"> </a>See Also 
</h4>

<p><a name="1014413"> </a><a href="Window.html#1014219"><code>WinGetBounds()</code></a></p>

<h3 class="hbH3">
  <a name="1014416"> </a>WinGetFirstWindow Function <a href="#1012037"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="1014418"> </a>Purpose 
</h4>

<p><a name="1014419"> </a>Return a pointer to the first window in the linked list of windows.</p>
<h4>
  <a name="1014420"> </a>Declared In 
</h4>
<code>Window.h<a name="1014421"> </a></code><h4>
  <a name="1014422"> </a>Prototype 
</h4>
<pre class="proto"><a name="1014424"></a>WinHandle WinGetFirstWindow (
   void
)
</pre>
<h4>
  <a name="1014425"> </a>Parameters 
</h4>

<p><a name="1014426"> </a>None.</p>
<h4>
  <a name="1014427"> </a>Returns 
</h4>

<p><a name="1014428"> </a>Returns handle of first window.</p>
<h4>
  <a name="1014429"> </a>Comments 
</h4>

<p><a name="1014430"> </a>This function is usually used by the system only.</p>
<h4>
  <a name="1075864"> </a>Compatibility 
</h4>

<p><a name="1075968"> </a>If <a href="CompatibilityApdx.html#1029305">Palm OS Cobalt Feature Set</a> is present this function is unimplemented.</p>
<h4>
  <a name="1014431"> </a>See Also 
</h4>

<p><a name="1014435"> </a><a href="Window.html#1014168"><code>WinGetActiveWindow()</code></a> </p>

<h3 class="hbH3">
  <a name="1014438"> </a>WinGetFramesRectangle Function <a href="#1012037"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="1014440"> </a>Purpose 
</h4>

<p><a name="1014441"> </a>Return the rectangle that includes a rectangle together with the specified frame around it.</p>
<h4>
  <a name="1014442"> </a>Declared In 
</h4>
<code>Window.h<a name="1014443"> </a></code><h4>
  <a name="1014444"> </a>Prototype 
</h4>
<pre class="proto"><a name="1014446"></a>void WinGetFramesRectangle (
   FrameType frame,
   const RectangleType *rP,
   RectangleType *obscuredRect
)
</pre>
<h4>
  <a name="1014447"> </a>Parameters 
</h4>

<dl>
<dt><a name="1014448"> </a><code>&rarr;  <i><code>frame</code></i></code></dt>
<dd><a name="1014452"> </a>Type of rectangle frame (see <a href="Window.html#1012368"><code>FrameType</code></a>).</dd>

<dt><a name="1014453"> </a><code>&rarr;  <i><code>rP</code></i></code></dt>
<dd><a name="1014454"> </a>Pointer to the rectangle to frame.</dd>

<dt><a name="1014455"> </a><code>&larr;  <i><code>obscuredRect</code></i></code></dt>
<dd><a name="1014456"> </a>Pointer to the rectangle that includes both the specified rectangle and its frame.</dd>

</dl>
<h4>
  <a name="1014457"> </a>Returns 
</h4>

<p><a name="1014458"> </a>Returns nothing.</p>
<h4>
  <a name="1014459"> </a>Comments 
</h4>

<p><a name="1014460"> </a>Frames are always drawn around (outside) a rectangle.</p>
<h4>
  <a name="1014461"> </a>See Also 
</h4>

<p><a name="1014468"> </a><a href="Window.html#1014692"><code>WinGetWindowFrameRect()</code></a>, <a href="Window.html#1014219"><code>WinGetBounds()</code></a></p>

<h3 class="hbH3">
  <a name="1014471"> </a>WinGetPattern Function <a href="#1012037"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="1014473"> </a>Purpose 
</h4>

<p><a name="1014474"> </a>Return the current fill pattern.</p>
<h4>
  <a name="1014475"> </a>Declared In 
</h4>
<code>Window.h<a name="1014476"> </a></code><h4>
  <a name="1014477"> </a>Prototype 
</h4>
<pre class="proto"><a name="1014479"></a>void WinGetPattern (
   CustomPatternType *patternP
)
</pre>
<h4>
  <a name="1014480"> </a>Parameters 
</h4>

<dl>
<dt><a name="1014481"> </a><code>&larr;  <i><code>patternP</code></i></code></dt>
<dd><a name="1014482"> </a>Buffer where the current pattern is returned (see <a href="Window.html#1012065"><code>CustomPatternType</code></a>).</dd>

</dl>
<h4>
  <a name="1014486"> </a>Returns 
</h4>

<p><a name="1014487"> </a>Returns nothing.</p>
<h4>
  <a name="1014488"> </a>Comments 
</h4>

<p><a name="1014492"> </a>The fill pattern is used by <a href="Window.html#1014083"><code>WinFillLine()</code></a> and <a href="Window.html#1014130"><code>WinFillRectangle()</code></a>.</p>

<p><a name="1014496"> </a>This function returns the value of <code>patternData</code> in the current drawing state. (See <a href="Window.html#1012130"><code>DrawStateType</code></a>.) The <code>patternData</code> field is only set if the pattern field is <code>customPattern</code>. Therefore, it's a good idea to use <a href="Window.html#1014513"><code>WinGetPatternType()</code></a> instead of this function on systems that support <a href="Window.html#1014513"><code>WinGetPatternType()</code></a>.</p>
<h4>
  <a name="1014506"> </a>See Also 
</h4>

<p><a name="1014510"> </a><a href="Window.html#1016643"><code>WinSetPattern()</code></a></p>

<h3 class="hbH3">
  <a name="1014513"> </a>WinGetPatternType Function <a href="#1012037"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="1014515"> </a>Purpose 
</h4>

<p><a name="1014516"> </a>Return the current pattern type. </p>
<h4>
  <a name="1014517"> </a>Declared In 
</h4>
<code>Window.h<a name="1014518"> </a></code><h4>
  <a name="1014519"> </a>Prototype 
</h4>
<pre class="proto"><a name="1014521"></a>PatternType WinGetPatternType (
   void
)
</pre>
<h4>
  <a name="1014522"> </a>Parameters 
</h4>

<dl>
<dt><a name="1014523"> </a><code>None.</code></dt>
</dl>
<h4>
  <a name="1014524"> </a>Returns 
</h4>

<p><a name="1014528"> </a>Returns the current draw window pattern type (see <a href="Window.html#1012462"><code>PatternType</code></a>). If the return value is <code>customPattern</code>, you can retrieve the pattern with <a href="Window.html#1014471"><code>WinGetPattern()</code></a>.</p>
<h4>
  <a name="1014532"> </a>Comments 
</h4>

<p><a name="1014536"> </a>The fill pattern is used by <a href="Window.html#1014083"><code>WinFillLine()</code></a> and <a href="Window.html#1014130"><code>WinFillRectangle()</code></a>.</p>
<h4>
  <a name="1014540"> </a>Compatibility 
</h4>

<p><a name="1014544"> </a>Implemented only if <a href="CompatibilityApdx.html#994671">3.5 New Feature Set</a> is present.</p>
<h4>
  <a name="1014545"> </a>See Also 
</h4>

<p><a name="1014549"> </a><a href="Window.html#1016683"><code>WinSetPatternType()</code></a></p>

<h3 class="hbH3">
  <a name="1014552"> </a>WinGetPixel Function <a href="#1012037"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="1014554"> </a>Purpose 
</h4>

<p><a name="1014555"> </a>Return the color value of a pixel in the current draw window.</p>
<h4>
  <a name="1014556"> </a>Declared In 
</h4>
<code>Window.h<a name="1014557"> </a></code><h4>
  <a name="1014558"> </a>Prototype 
</h4>
<pre class="proto"><a name="1014560"></a>IndexedColorType WinGetPixel (
   Coord x,
   Coord y
)
</pre>
<h4>
  <a name="1014561"> </a>Parameters 
</h4>

<dl>
<dt><a name="1014562"> </a><code>&rarr;  <i><code>x</code></i></code></dt>
<dd><a name="1014563"> </a>Pointer to the x coordinate of a pixel.</dd>

<dt><a name="1014564"> </a><code>&rarr;  <i><code>y</code></i></code></dt>
<dd><a name="1014565"> </a>Pointer to the y coordinate of a pixel.</dd>

</dl>
<h4>
  <a name="1014566"> </a>Returns 
</h4>

<p><a name="1014567"> </a>Returns the indexed color value of the pixel. See <a href="Window.html#1012445"><code>IndexedColorType</code></a>. A return value of 0 means either that the coordinates do not lie in the current draw window or that they do and the color of that pixel is index 0 (typically white). </p>
<h4>
  <a name="1014571"> </a>Compatibility 
</h4>

<p><a name="1014575"> </a>Implemented only if <a href="CompatibilityApdx.html#994671">3.5 New Feature Set</a> is present.</p>
<h4>
  <a name="1014576"> </a>See Also 
</h4>

<p><a name="1014580"> </a><a href="Window.html#1014715"><code>WinIndexToRGB()</code></a> </p>

<h3 class="hbH3">
  <a name="1014583"> </a>WinGetPixelRGB Function <a href="#1012037"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="1014585"> </a>Purpose 
</h4>

<p><a name="1014586"> </a>Return the RGB color values of a pixel in the current draw window.</p>
<h4>
  <a name="1014587"> </a>Declared In 
</h4>
<code>Window.h<a name="1014588"> </a></code><h4>
  <a name="1014589"> </a>Prototype 
</h4>
<pre class="proto"><a name="1014591"></a>Err WinGetPixelRGB (
   Coord x,
   Coord y,
   RGBColorType *rgbP
)
</pre>
<h4>
  <a name="1014592"> </a>Parameters 
</h4>

<dl>
<dt><a name="1014593"> </a><code>&rarr;  <i><code>x</code></i></code></dt>
<dd><a name="1014594"> </a>Pointer to the x coordinate of a pixel.</dd>

<dt><a name="1014595"> </a><code>&rarr;  <i><code>y</code></i></code></dt>
<dd><a name="1014596"> </a>Pointer to the y coordinate of a pixel.</dd>

<dt><a name="1014597"> </a><code>&larr;  <i><code>rgbP</code></i></code></dt>
<dd><a name="1014598"> </a>RGB color components of the pixel.</dd>

</dl>
<h4>
  <a name="1014599"> </a>Returns 
</h4>

<p><a name="1014600"> </a>Returns <code>errNone</code> or <code>sysErrParamErr</code>. <code>sysErrParamErr</code> is returned when the <code>x</code> or <code>y</code> arguments are &lt; 0 or when they are outside the bounds of the draw window.</p>
<h4>
  <a name="1014601"> </a>Comments 
</h4>

<p><a name="1014602"> </a>The RGB color values of the pixel are returned as an <a href="Bitmap.html#998266"><code>RGBColorType</code></a>. This function can be used with both indexed or direct color modes. A return value of <code>sysErrParamErr</code> means that the coordinates do not lie in the current draw window.</p>
<h4>
  <a name="1014606"> </a>Compatibility 
</h4>

<p><a name="1014610"> </a>Implemented only if <a href="CompatibilityApdx.html#995256">4.0 New Feature Set</a> is present.</p>

<h3 class="hbH3">
  <a name="1014613"> </a>WinGetScalingMode Function <a href="#1012037"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="1014615"> </a>Purpose 
</h4>

<p><a name="1014616"> </a>Get the current scaling mode.</p>
<h4>
  <a name="1014617"> </a>Declared In 
</h4>
<code>Window.h<a name="1014618"> </a></code><h4>
  <a name="1014619"> </a>Prototype 
</h4>
<pre class="proto"><a name="1014620"></a>UInt32 WinGetScalingMode (
   void
)
</pre>
<h4>
  <a name="1014621"> </a>Parameters 
</h4>

<dl>
<dt><a name="1014622"> </a><code>None.</code></dt>
</dl>
<h4>
  <a name="1014623"> </a>Returns 
</h4>

<p><a name="1014624"> </a>Returns the current scaling mode. See the description of <a href="Window.html#1016731"><code>WinSetScalingMode()</code></a> for information on interpreting the returned scaling mode value.</p>
<h4>
  <a name="1014628"> </a>Compatibility 
</h4>

<p><a name="1014632"> </a>Implemented only if the <a href="CompatibilityApdx.html#997148">1.5x Display Feature Set</a> is present.</p>

<h3 class="hbH3">
  <a name="1014635"> </a>WinGetSupportedDensity Function <a href="#1012037"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="1014637"> </a>Purpose 
</h4>

<p><a name="1014638"> </a>Enumerate the various display densities supported by the blitter.</p>
<h4>
  <a name="1014639"> </a>Declared In 
</h4>
<code>Window.h<a name="1014640"> </a></code><h4>
  <a name="1014641"> </a>Prototype 
</h4>
<pre class="proto"><a name="1014642"></a>Err WinGetSupportedDensity (
   UInt16 *densityP
)
</pre>
<h4>
  <a name="1014643"> </a>Parameters 
</h4>

<dl>
<dt><a name="1014644"> </a><code>&harr;  <i>densityP</i></code></dt>
<dd><a name="1014645"> </a>Pointer to a supported density value. Set this value to zero before calling this function for the first time. Subsequent calls cause this value to be set to one of the display densities supported by the handheld.</dd>

</dl>
<h4>
  <a name="1014646"> </a>Returns 
</h4>

<p><a name="1014647"> </a>Returns <code>errNone</code> unless the value you supply in <code>*densityP</code> isn't a supported density and isn't zero, in which case this function returns <code>SysErrParamErr</code>. </p>
<h4>
  <a name="1014648"> </a>Comments 
</h4>

<p><a name="1014649"> </a>Initialize <code>*densityP</code> to zero before your application calls this function for the first time. Repeated calls to <code>WinGetSupportedDensity</code> will cause the value pointed to by <code>densityP</code> to change; these values represent the supported display densities, in order from low to high density. After the last supported density value, this function sets <code>*densityP</code> back to zero.</p>

<div><hr>
  <a name="1014650"> </a> <b>NOTE: </b> The densities reported by this function are those that are supported by the blitter. These densities are not necessarily supported by the underlying hardware. A handheld with a low-density screen that is able to scale high-density bitmaps will report that it can handle both high and low density bitmaps. Use <a href="Window.html#1015858"><code>WinScreenGetAttribute()</code></a> to determine the density of the handheld's screen.
<hr>
</div>

<p><a name="1014657"> </a>Density values are defined in <code>Bitmap.h</code>; see the <a href="Bitmap.html#998172"><code>DensityType</code></a> enum. Only those values supported by a given handheld will be returned by <code>WinGetSupportedDensity</code>,. For example, on a handheld with a double-density display this function returns <code>kDensityLow</code>, followed by <code>kDensityDouble</code>, followed by 0. For each supported density, the inverse scaling factor is supported. In this example, the blitter supports pixel-doubling low-density data for a double-density destination, and the blitter supports pixel-halving high-density data for a low-density destination.</p>

<p><a name="1014658"> </a>The value pointed to by <code>densityP</code> should only be zero or one of the density values supported by the handheld. If it has any other value when you call <code>WinGetSupportedDensity</code>, this function will simply return <code>sysErrParamErr</code>.</p>
<h4>
  <a name="1014659"> </a>Compatibility 
</h4>

<p><a name="1014663"> </a>Implemented only if the <a href="CompatibilityApdx.html#996955">High-Density Display Feature Set</a> is present.</p>

<h3 class="hbH3">
  <a name="1014666"> </a>WinGetWindowExtent Function <a href="#1012037"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="1014668"> </a>Purpose 
</h4>

<p><a name="1014669"> </a>Return the width and height of the current draw window.</p>
<h4>
  <a name="1014670"> </a>Declared In 
</h4>
<code>Window.h<a name="1014671"> </a></code><h4>
  <a name="1014672"> </a>Prototype 
</h4>
<pre class="proto"><a name="1014674"></a>void WinGetWindowExtent (
   Coord *extentX,
   Coord *extentY
)
</pre>
<h4>
  <a name="1014675"> </a>Parameters 
</h4>

<dl>
<dt><a name="1014676"> </a><code>&larr;  <i><code>extentX</code></i></code></dt>
<dd><a name="1014677"> </a>Pointer to the width in pixels of the draw window.</dd>

<dt><a name="1014678"> </a><code>&larr;  <i><code>extentY</code></i></code></dt>
<dd><a name="1014679"> </a>Pointer to the height in pixels of the draw window.</dd>

</dl>
<h4>
  <a name="1014680"> </a>Returns 
</h4>

<p><a name="1014681"> </a>Returns nothing.</p>
<h4>
  <a name="1014682"> </a>See Also 
</h4>

<p><a name="1014689"> </a><a href="Window.html#1014219"><code>WinGetBounds()</code></a>, <a href="Window.html#1014692"><code>WinGetWindowFrameRect()</code></a>,</p>

<h3 class="hbH3">
  <a name="1014692"> </a>WinGetWindowFrameRect Function <a href="#1012037"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="1014694"> </a>Purpose 
</h4>

<p><a name="1014695"> </a>Return a rectangle, in display-relative coordinates, that defines the size and location of a window and its frame.</p>
<h4>
  <a name="1014696"> </a>Declared In 
</h4>
<code>Window.h<a name="1014697"> </a></code><h4>
  <a name="1014698"> </a>Prototype 
</h4>
<pre class="proto"><a name="1014700"></a>void WinGetWindowFrameRect (
   WinHandle winHandle,
   RectangleType *r
)
</pre>
<h4>
  <a name="1014701"> </a>Parameters 
</h4>

<dl>
<dt><a name="1014702"> </a><code>&rarr;  <i><code>winHandle</code></i></code></dt>
<dd><a name="1014703"> </a>Handle of window whose coordinates are desired.</dd>

<dt><a name="1014704"> </a><code>&larr;  <i><code>r</code></i></code></dt>
<dd><a name="1014705"> </a>Pointer to the coordinates of the window.</dd>

</dl>
<h4>
  <a name="1014706"> </a>Returns 
</h4>

<p><a name="1014707"> </a>Returns nothing.</p>
<h4>
  <a name="1014708"> </a>See Also 
</h4>

<p><a name="1014712"> </a><a href="Window.html#1014219"><code>WinGetBounds()</code></a></p>

<h3 class="hbH3">
  <a name="1014715"> </a>WinIndexToRGB Function <a href="#1012037"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="1014717"> </a>Purpose 
</h4>

<p><a name="1014718"> </a>Convert an index in the currently active color table to an RGB value.</p>
<h4>
  <a name="1014719"> </a>Declared In 
</h4>
<code>Window.h<a name="1014720"> </a></code><h4>
  <a name="1014721"> </a>Prototype 
</h4>
<pre class="proto"><a name="1014723"></a>void WinIndexToRGB (
   IndexedColorType i,
   RGBColorType *rgbP
)
</pre>
<h4>
  <a name="1014724"> </a>Parameters 
</h4>

<dl>
<dt><a name="1014725"> </a><code>&rarr;  <i>i</i></code></dt>
<dd><a name="1014729"> </a>A color index value. See <a href="Window.html#1012445"><code>IndexedColorType</code></a>. </dd>

<dt><a name="1014730"> </a><code>&larr;  <i>rgbP</i></code></dt>
<dd><a name="1014731"> </a>Pointer to an RGB color value corresponding to the index value <code>i</code>. See <a href="Bitmap.html#998266"><code>RGBColorType</code></a>. </dd>

</dl>
<h4>
  <a name="1014735"> </a>Returns 
</h4>

<p><a name="1014736"> </a>Returns nothing.</p>
<h4>
  <a name="1014737"> </a>Compatibility 
</h4>

<p><a name="1014741"> </a>Implemented only if <a href="CompatibilityApdx.html#994671">3.5 New Feature Set</a> is present.</p>
<h4>
  <a name="1014742"> </a>See Also 
</h4>

<p><a name="1014746"> </a><a href="Window.html#1015682"><code>WinRGBToIndex()</code></a></p>

<h3 class="hbH3">
  <a name="1014749"> </a>WinInvertChars Function <a href="#1012037"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="1014751"> </a>Purpose 
</h4>

<p><a name="1014753"> </a>Invert the specified characters in the draw window.</p>
<h4>
  <a name="1014754"> </a>Declared In 
</h4>
<code>Window.h<a name="1014755"> </a></code><h4>
  <a name="1014756"> </a>Prototype 
</h4>
<pre class="proto"><a name="1014758"></a>void WinInvertChars (
   const Char *chars,
   Int16 len,
   Coord x,
   Coord y
)
</pre>
<h4>
  <a name="1014759"> </a>Parameters 
</h4>

<dl>
<dt><a name="1014760"> </a><code>&rarr;  <i><code>chars</code></i></code></dt>
<dd><a name="1014761"> </a>Pointer to the characters to invert.</dd>

<dt><a name="1014762"> </a><code>&rarr;  <i><code>len</code></i></code></dt>
<dd><a name="1014763"> </a>Length in bytes of the characters to invert.</dd>

<dt><a name="1014764"> </a><code>&rarr;  <i><code>x</code></i></code></dt>
<dd><a name="1014765"> </a>x coordinate of the first character to invert (left bound).</dd>

<dt><a name="1014766"> </a><code>&rarr;  <i><code>y</code></i></code></dt>
<dd><a name="1014767"> </a>y coordinate of the first character to invert (top bound).</dd>

</dl>
<h4>
  <a name="1014768"> </a>Returns 
</h4>

<p><a name="1014769"> </a>Returns nothing.</p>
<h4>
  <a name="1014770"> </a>Comments 
</h4>

<p><a name="1014771"> </a>This function applies the <code>winInvert</code> operation of <a href="Window.html#1012784"><code>WinDrawOperation</code></a> to the characters in the draw window. </p>

<p><a name="1014778"> </a>To perform color inverting, use <a href="Window.html#1016815"><code>WinSetTextColor()</code></a> and <a href="Window.html#1016284"><code>WinSetBackColor()</code></a> to choose the desired colors, and call <a href="Window.html#1015054"><code>WinPaintChar()</code></a>. </p>
<h4>
  <a name="1014785"> </a>See Also 
</h4>

<p><a name="1014792"> </a><a href="Window.html#1013360"><code>WinDrawChar()</code></a>, <a href="Window.html#1013424"><code>WinDrawChars()</code></a>, <a href="Window.html#1013566"><code>WinDrawInvertedChars()</code></a>, <a href="Window.html#1013790"><code>WinDrawTruncChars()</code></a>, <a href="Window.html#1013856"><code>WinEraseChars()</code></a>, <a href="Window.html#1015054"><code>WinPaintChar()</code></a>, <a href="Window.html#1015108"><code>WinPaintChars()</code></a> </p>

<h3 class="hbH3">
  <a name="1014810"> </a>WinInvertLine Function <a href="#1012037"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="1014812"> </a>Purpose 
</h4>

<p><a name="1014816"> </a>Invert a line in the draw window (using the <a href="Window.html#1012784"><code>WinDrawOperation</code></a> <code>winInvert</code>).</p>
<h4>
  <a name="1014817"> </a>Declared In 
</h4>
<code>Window.h<a name="1014818"> </a></code><h4>
  <a name="1014819"> </a>Prototype 
</h4>
<pre class="proto"><a name="1014821"></a>void WinInvertLine (
   Coord x1,
   Coord y1,
   Coord x2,
   Coord y2
)
</pre>
<h4>
  <a name="1014822"> </a>Parameters 
</h4>

<dl>
<dt><a name="1014823"> </a><code>&rarr;  <i><code>x1</code></i></code></dt>
<dd><a name="1014824"> </a>x coordinate of line start point.</dd>

<dt><a name="1014825"> </a><code>&rarr;  <i><code>y1</code></i></code></dt>
<dd><a name="1014826"> </a>y coordinate of line start point.</dd>

<dt><a name="1014827"> </a><code>&rarr;  <i><code>x2</code></i></code></dt>
<dd><a name="1014828"> </a>x coordinate of line endpoint.</dd>

<dt><a name="1014829"> </a><code>&rarr;  <i><code>y2</code></i></code></dt>
<dd><a name="1014830"> </a>y coordinate of line endpoint.</dd>

</dl>
<h4>
  <a name="1014831"> </a>Returns 
</h4>

<p><a name="1014832"> </a>Returns nothing.</p>
<h4>
  <a name="1014833"> </a>See Also 
</h4>

<p><a name="1014843"> </a><a href="Window.html#1013482"><code>WinDrawGrayLine()</code></a>, <a href="Window.html#1013620"><code>WinDrawLine()</code></a>, <a href="Window.html#1013906"><code>WinEraseLine()</code></a>, <a href="Window.html#1014083"><code>WinFillLine()</code></a>, <a href="Window.html#1015171"><code>WinPaintLine()</code></a>, <a href="Window.html#1015223"><code>WinPaintLines()</code></a> </p>

<h3 class="hbH3">
  <a name="1014855"> </a>WinInvertPixel Function <a href="#1012037"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="1014857"> </a>Purpose 
</h4>

<p><a name="1014861"> </a>Invert a pixel in the draw window (using the <a href="Window.html#1012784"><code>WinDrawOperation</code></a> <code>winInvert</code>).</p>
<h4>
  <a name="1014862"> </a>Declared In 
</h4>
<code>Window.h<a name="1014863"> </a></code><h4>
  <a name="1014864"> </a>Prototype 
</h4>
<pre class="proto"><a name="1014866"></a>void WinInvertPixel (
   Coord x,
   Coord y
)
</pre>
<h4>
  <a name="1014867"> </a>Parameters 
</h4>

<dl>
<dt><a name="1014868"> </a><code>&rarr;  <i><code>x</code></i></code></dt>
<dd><a name="1014869"> </a>Pointer to the x coordinate of a pixel.</dd>

<dt><a name="1014870"> </a><code>&rarr;  <i><code>y</code></i></code></dt>
<dd><a name="1014871"> </a>Pointer to the y coordinate of a pixel.</dd>

</dl>
<h4>
  <a name="1014872"> </a>Returns 
</h4>

<p><a name="1014873"> </a>Returns nothing.</p>
<h4>
  <a name="1014874"> </a>Compatibility 
</h4>

<p><a name="1014878"> </a>Implemented only if <a href="CompatibilityApdx.html#994671">3.5 New Feature Set</a> is present.</p>
<h4>
  <a name="1014879"> </a>See Also 
</h4>

<p><a name="1014889"> </a><a href="Window.html#1013670"><code>WinDrawPixel()</code></a>, <a href="Window.html#1013948"><code>WinErasePixel()</code></a>, <a href="Window.html#1015274"><code>WinPaintPixel()</code></a>, <a href="Window.html#1015316"><code>WinPaintPixels()</code></a> </p>

<h3 class="hbH3">
  <a name="1014895"> </a>WinInvertRectangle Function <a href="#1012037"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="1014897"> </a>Purpose 
</h4>

<p><a name="1014898"> </a>Invert a rectangle in the draw window (using the <a href="Window.html#1012784"><code>WinDrawOperation</code></a> <code>winInvert</code>).</p>
<h4>
  <a name="1014902"> </a>Declared In 
</h4>
<code>Window.h<a name="1014903"> </a></code><h4>
  <a name="1014904"> </a>Prototype 
</h4>
<pre class="proto"><a name="1014906"></a>void WinInvertRectangle (
   const RectangleType *rP,
   UInt16 cornerDiam
)
</pre>
<h4>
  <a name="1014907"> </a>Parameters 
</h4>

<dl>
<dt><a name="1014908"> </a><code>&rarr;  <i><code>rP</code></i></code></dt>
<dd><a name="1014909"> </a>Pointer to the rectangle to invert.</dd>

<dt><a name="1014910"> </a><code>&rarr;  <i><code>cornerDiam</code></i></code></dt>
<dd><a name="1014911"> </a>Radius of rounded corners. Specify zero for square corners.</dd>

</dl>
<h4>
  <a name="1014912"> </a>Returns 
</h4>

<p><a name="1014913"> </a>Returns nothing.</p>
<h4>
  <a name="1014914"> </a>Comments 
</h4>

<p><a name="1014915"> </a>The <code>cornerDiam</code> parameter specifies the radius of four imaginary circles used to form the rounded corners. An imaginary circle is placed within each corner tangent to the rectangle on two sides.</p>

<p><a name="1014916"> </a>The operating system itself does not use the inverting routines. Instead, it uses the <code>winSwap</code> transfer mode, or it changes the color selection and uses the <code>WinPaint...</code> routines. </p>
<h4>
  <a name="1014917"> </a>See Also 
</h4>

<p><a name="1014924"> </a><a href="Window.html#1013707"><code>WinDrawRectangle()</code></a>, <a href="Window.html#1013985"><code>WinEraseRectangle()</code></a>, <a href="Window.html#1014130"><code>WinFillRectangle()</code></a>, <a href="Window.html#1015358"><code>WinPaintRectangle()</code></a> </p>

<h3 class="hbH3">
  <a name="1014933"> </a>WinInvertRectangleFrame Function <a href="#1012037"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="1014935"> </a>Purpose 
</h4>

<p><a name="1014936"> </a>Invert a rectangular frame in the draw window (using the <a href="Window.html#1012784"><code>WinDrawOperation</code></a> <code>winInvert</code>).</p>
<h4>
  <a name="1014940"> </a>Declared In 
</h4>
<code>Window.h<a name="1014941"> </a></code><h4>
  <a name="1014942"> </a>Prototype 
</h4>
<pre class="proto"><a name="1014944"></a>void WinInvertRectangleFrame (
   FrameType frame,
   const RectangleType *rP
)
</pre>
<h4>
  <a name="1014945"> </a>Parameters 
</h4>

<dl>
<dt><a name="1014946"> </a><code>&rarr;  <i><code>frame</code></i></code></dt>
<dd><a name="1014950"> </a>Type of frame to draw (see <a href="Window.html#1012368"><code>FrameType</code></a>).</dd>

<dt><a name="1014951"> </a><code>&rarr;  <i><code>rP</code></i></code></dt>
<dd><a name="1014952"> </a>Pointer to the rectangle to frame.</dd>

</dl>
<h4>
  <a name="1014953"> </a>Returns 
</h4>

<p><a name="1014954"> </a>Returns nothing.</p>
<h4>
  <a name="1014955"> </a>See Also 
</h4>

<p><a name="1014961"> </a><a href="Window.html#1013526"><code>WinDrawGrayRectangleFrame()</code></a>, <a href="Window.html#1013745"><code>WinDrawRectangleFrame()</code></a>, <a href="Window.html#1014019"><code>WinEraseRectangleFrame()</code></a>, <a href="Window.html#1014438"><code>WinGetFramesRectangle()</code></a>, <a href="Window.html#1015401"><code>WinPaintRectangleFrame()</code></a> </p>

<h3 class="hbH3">
  <a name="1014974"> </a>WinModal Function <a href="#1012037"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="1014976"> </a>Purpose 
</h4>

<p><a name="1014977"> </a>Return <code>true</code> if the specified window is modal. </p>
<h4>
  <a name="1014978"> </a>Declared In 
</h4>
<code>Window.h<a name="1014979"> </a></code><h4>
  <a name="1014980"> </a>Prototype 
</h4>
<pre class="proto"><a name="1014982"></a>Boolean WinModal (
   WinHandle winHandle
)
</pre>
<h4>
  <a name="1014983"> </a>Parameters 
</h4>

<dl>
<dt><a name="1014984"> </a><code>&rarr;  <i><code>winHandle</code></i></code></dt>
<dd><a name="1014985"> </a>Handle of a window.</dd>

</dl>
<h4>
  <a name="1014986"> </a>Returns 
</h4>

<p><a name="1014987"> </a>Returns <code>true</code> if the window is modal, otherwise <code>false</code>.</p>
<h4>
  <a name="1014988"> </a>Comments 
</h4>

<p><a name="1014990"> </a>A window is modal if it cannot lose the focus. </p>
<h4>
  <a name="1014991"> </a>See Also 
</h4>

<p><a name="1015001"> </a><a href="Form.html#996965"><code>FrmAlert()</code></a>, <a href="Form.html#997090"><code>FrmCustomAlert()</code></a>, <a href="Form.html#997249"><code>FrmDoDialog()</code></a> </p>

<h3 class="hbH3">
  <a name="1015004"> </a>WinPaintBitmap Function <a href="#1012037"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="1015006"> </a>Purpose 
</h4>

<p><a name="1015007"> </a>Draw a bitmap in the current draw window at the specified coordinates with the current draw mode.</p>
<h4>
  <a name="1015008"> </a>Declared In 
</h4>
<code>Window.h<a name="1015009"> </a></code><h4>
  <a name="1015010"> </a>Prototype 
</h4>
<pre class="proto"><a name="1015012"></a>void WinPaintBitmap (
   BitmapType *bitmapP,
   Coord x,
   Coord y
)
</pre>
<h4>
  <a name="1015013"> </a>Parameters 
</h4>

<dl>
<dt><a name="1015014"> </a><code>&rarr;  <i><code>bitmapP</code></i></code></dt>
<dd><a name="1015015"> </a>Pointer to a bitmap.</dd>

<dt><a name="1015016"> </a><code>&rarr;  <i><code>x</code></i></code></dt>
<dd><a name="1015017"> </a>The x coordinate of the top-left corner.</dd>

<dt><a name="1015018"> </a><code>&rarr;  <i><code>y</code></i></code></dt>
<dd><a name="1015019"> </a>The y coordinate of the top-left corner.</dd>

</dl>
<h4>
  <a name="1015020"> </a>Returns 
</h4>

<p><a name="1015021"> </a>Returns nothing.</p>
<h4>
  <a name="1015022"> </a>Comments 
</h4>

<p><a name="1015023"> </a>If the bitmap has multiple depths (is a bitmap family), the closest match less than or equal to the current draw window depth is used. If such a bitmap does not exist, the bitmap with the closest match greater than the draw window depth is used. </p>

<p><a name="1015024"> </a>Using <code>WinPaintBitmap</code> is now recommended instead of the previous practice of rendering bitmaps into an offscreen window and then using <a href="Window.html#1013039"><code>WinCopyRectangle()</code></a> to draw them on screen.</p>

<p><a name="1015031"> </a>The current draw mode is set by <a href="Window.html#1075295"><code>WinSetDrawMode()</code></a>. </p>

<p><a name="1015032"> </a>If the bitmap has its own color table, color conversion to the draw window color table will be applied (on OS 3.5 or later). This color conversion is slow and not recommended. Instead of including a color table in the bitmap, consider using <a href="Window.html#1015523"><code>WinPalette()</code></a> to change the system color table, draw the bitmap, and then change the system color table back when the bitmap is no longer visible. </p>
<h4>
  <a name="1015036"> </a>Compatibility 
</h4>

<p><a name="1015040"> </a>Implemented only if <a href="CompatibilityApdx.html#994671">3.5 New Feature Set</a> is present.</p>
<h4>
  <a name="1015041"> </a>See Also 
</h4>

<p><a name="1015048"> </a><a href="Window.html#1013322"><code>WinDrawBitmap()</code></a>, <a href="Window.html#1013985"><code>WinEraseRectangle()</code></a>, <a href="Window.html#1015494"><code>WinPaintTiledBitmap()</code></a></p>

<h3 class="hbH3">
  <a name="1015054"> </a>WinPaintChar Function <a href="#1012037"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="1015056"> </a>Purpose 
</h4>

<p><a name="1015057"> </a>Draw a character in the draw window using the current drawing state.</p>
<h4>
  <a name="1015058"> </a>Declared In 
</h4>
<code>Window.h<a name="1015059"> </a></code><h4>
  <a name="1015060"> </a>Prototype 
</h4>
<pre class="proto"><a name="1015062"></a>void WinPaintChar (
   WChar theChar,
   Coord x,
   Coord y
)
</pre>
<h4>
  <a name="1015063"> </a>Parameters 
</h4>

<dl>
<dt><a name="1015064"> </a><code>&rarr;  <i><code>theChar</code></i></code></dt>
<dd><a name="1015065"> </a>The character to draw. This may be either a single-byte character or a multi-byte character. </dd>

<dt><a name="1015066"> </a><code>&rarr;  <i><code>x</code></i></code></dt>
<dd><a name="1015067"> </a>x coordinate of the location where the character is to be drawn (left bound).</dd>

<dt><a name="1015068"> </a><code>&rarr;  <i><code>y</code></i></code></dt>
<dd><a name="1015069"> </a>y coordinate of the location where the character is to be drawn (top bound).</dd>

</dl>
<h4>
  <a name="1015070"> </a>Returns 
</h4>

<p><a name="1015071"> </a>Returns nothing.</p>
<h4>
  <a name="1015072"> </a>See Also 
</h4>

<p><a name="1015073"> </a><code>WinPaintChar</code> draws the <i>on</i> bits in the text color and the <i>off</i> bits in the background color, with underlines (if any) drawn in the foreground color using the current drawing mode.</p>

<p><a name="1015074"> </a>This function uses the current drawing state, which is stored in a <a href="Window.html#1012130"><code>DrawStateType</code></a> structure. See the description of that structure to learn the functions you can call to set the drawing state to the values you want. </p>
<h4>
  <a name="1015078"> </a>Compatibility 
</h4>

<p><a name="1015082"> </a>Implemented only if <a href="CompatibilityApdx.html#994671">3.5 New Feature Set</a> is present.</p>
<h4>
  <a name="1015083"> </a>See Also 
</h4>

<p><a name="1015090"> </a><a href="Window.html#1013360"><code>WinDrawChar()</code></a>, <a href="Window.html#1013424"><code>WinDrawChars()</code></a>, <a href="Window.html#1013566"><code>WinDrawInvertedChars()</code></a>, <a href="Window.html#1013790"><code>WinDrawTruncChars()</code></a>, <a href="Window.html#1013856"><code>WinEraseChars()</code></a>, <a href="Window.html#1014749"><code>WinInvertChars()</code></a>, <a href="Window.html#1015108"><code>WinPaintChars()</code></a> </p>

<h3 class="hbH3">
  <a name="1015108"> </a>WinPaintChars Function <a href="#1012037"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="1015110"> </a>Purpose 
</h4>

<p><a name="1015111"> </a>Draw the specified characters in the draw window with the current draw state.</p>
<h4>
  <a name="1015112"> </a>Declared In 
</h4>
<code>Window.h<a name="1015113"> </a></code><h4>
  <a name="1015114"> </a>Prototype 
</h4>
<pre class="proto"><a name="1015116"></a>void WinPaintChars (
   const Char *chars,
   Int16 len,
   Coord x,
   Coord y
)
</pre>
<h4>
  <a name="1015117"> </a>Parameters 
</h4>

<dl>
<dt><a name="1015118"> </a><code>&rarr;  <i><code>chars</code></i></code></dt>
<dd><a name="1015119"> </a>Pointer to the characters to draw.</dd>

<dt><a name="1015120"> </a><code>&rarr;  <i><code>len</code></i></code></dt>
<dd><a name="1015121"> </a>Length in bytes of the characters to draw.</dd>

<dt><a name="1015122"> </a><code>&rarr;  <i><code>x</code></i></code></dt>
<dd><a name="1015123"> </a>x coordinate of the first character to draw (left bound).</dd>

<dt><a name="1015124"> </a><code>&rarr;  <i><code>y</code></i></code></dt>
<dd><a name="1015125"> </a>y coordinate of the first character to draw (top bound).</dd>

</dl>
<h4>
  <a name="1015126"> </a>Returns 
</h4>

<p><a name="1015127"> </a>Returns nothing.</p>
<h4>
  <a name="1015128"> </a>Comments 
</h4>

<p><a name="1015129"> </a><code>WinPaintChars</code> draws the <i>on</i> bits in the text color and the <i>off</i> bits in the background color, with underlines (if any) drawn in the foreground color using the current drawing mode.</p>

<p><a name="1015130"> </a>This function uses the current drawing state, which is stored in a <a href="Window.html#1012130"><code>DrawStateType</code></a> structure. See the description of that structure to learn the functions you can call to set the drawing state to the state you want. </p>

<p><a name="1015134"> </a>Before calling this function, consider calling <a href="Window.html#1016917"><code>WinSetUnderlineMode()</code></a> and <a href="Font.html#1000753"><code>FntSetFont()</code></a>. </p>
<h4>
  <a name="1015141"> </a>Compatibility 
</h4>

<p><a name="1015145"> </a>Implemented only if <a href="CompatibilityApdx.html#994671">3.5 New Feature Set</a> is present.</p>
<h4>
  <a name="1015146"> </a>See Also 
</h4>

<p><a name="1015153"> </a><a href="Window.html#1013360"><code>WinDrawChar()</code></a>, <a href="Window.html#1013424"><code>WinDrawChars()</code></a>, <a href="Window.html#1013566"><code>WinDrawInvertedChars()</code></a>, <a href="Window.html#1013790"><code>WinDrawTruncChars()</code></a>, <a href="Window.html#1013856"><code>WinEraseChars()</code></a>, <a href="Window.html#1014749"><code>WinInvertChars()</code></a>, <a href="Window.html#1015054"><code>WinPaintChar()</code></a> </p>

<h3 class="hbH3">
  <a name="1015171"> </a>WinPaintLine Function <a href="#1012037"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="1015173"> </a>Purpose 
</h4>

<p><a name="1015174"> </a>Draw a line in the draw window using the current drawing state.</p>
<h4>
  <a name="1015175"> </a>Declared In 
</h4>
<code>Window.h<a name="1015176"> </a></code><h4>
  <a name="1015177"> </a>Prototype 
</h4>
<pre class="proto"><a name="1015179"></a>void WinPaintLine (
   Coord x1,
   Coord y1,
   Coord x2,
   Coord y2
)
</pre>
<h4>
  <a name="1015180"> </a>Parameters 
</h4>

<dl>
<dt><a name="1015181"> </a><code>&rarr;  <i><code>x1</code></i></code></dt>
<dd><a name="1015182"> </a>x coordinate of line beginning point.</dd>

<dt><a name="1015183"> </a><code>&rarr;  <i><code>y1</code></i></code></dt>
<dd><a name="1015184"> </a>y coordinate of line beginning point.</dd>

<dt><a name="1015185"> </a><code>&rarr;  <i><code>x2</code></i></code></dt>
<dd><a name="1015186"> </a>x coordinate of line endpoint.</dd>

<dt><a name="1015187"> </a><code>&rarr;  <i><code>y2</code></i></code></dt>
<dd><a name="1015188"> </a>y coordinate of line endpoint.</dd>

</dl>
<h4>
  <a name="1015189"> </a>Returns 
</h4>

<p><a name="1015190"> </a>Returns nothing.</p>
<h4>
  <a name="1015191"> </a>Comments 
</h4>

<p><a name="1015192"> </a>This function uses the current drawing state, which is stored in a <a href="Window.html#1012130"><code>DrawStateType</code></a> structure. See the description of that structure to learn the functions you can call to set the drawing state to the state you want. </p>
<h4>
  <a name="1015196"> </a>Compatibility 
</h4>

<p><a name="1015200"> </a>Implemented only if <a href="CompatibilityApdx.html#994671">3.5 New Feature Set</a> is present.</p>
<h4>
  <a name="1015201"> </a>See Also 
</h4>

<p><a name="1015211"> </a><a href="Window.html#1013620"><code>WinDrawLine()</code></a>, <a href="Window.html#1013482"><code>WinDrawGrayLine()</code></a>, <a href="Window.html#1013906"><code>WinEraseLine()</code></a>, <a href="Window.html#1014083"><code>WinFillLine()</code></a>, <a href="Window.html#1014810"><code>WinInvertLine()</code></a>, <a href="Window.html#1015223"><code>WinPaintLines()</code></a> </p>

<h3 class="hbH3">
  <a name="1015223"> </a>WinPaintLines Function <a href="#1012037"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="1015225"> </a>Purpose 
</h4>

<p><a name="1015226"> </a>Draw several lines in the draw window using the current drawing state.</p>
<h4>
  <a name="1015227"> </a>Declared In 
</h4>
<code>Window.h<a name="1015228"> </a></code><h4>
  <a name="1015229"> </a>Prototype 
</h4>
<pre class="proto"><a name="1015231"></a>void WinPaintLines (
   UInt16 numLines,
   WinLineType lines[]
)
</pre>
<h4>
  <a name="1015232"> </a>Parameters 
</h4>

<dl>
<dt><a name="1015233"> </a><code>&rarr;  <i><code>numLines</code></i></code></dt>
<dd><a name="1015234"> </a>Number of lines to paint.</dd>

<dt><a name="1015235"> </a><code>&rarr;  <i>lines</i></code></dt>
<dd><a name="1015239"> </a>Array of lines. See <a href="Window.html#1012864"><code>WinLineType</code></a>.</dd>

</dl>
<h4>
  <a name="1015240"> </a>Returns 
</h4>

<p><a name="1015241"> </a>Returns nothing.</p>
<h4>
  <a name="1015242"> </a>Comments 
</h4>

<p><a name="1015243"> </a>This function uses the current drawing state, which is stored in a <a href="Window.html#1012130"><code>DrawStateType</code></a> structure. See the description of that structure to learn the functions you can call to set the drawing state to the state you want. </p>
<h4>
  <a name="1015247"> </a>Compatibility 
</h4>

<p><a name="1015251"> </a>Implemented only if <a href="CompatibilityApdx.html#994671">3.5 New Feature Set</a> is present.</p>
<h4>
  <a name="1015252"> </a>See Also 
</h4>

<p><a name="1015262"> </a><a href="Window.html#1013620"><code>WinDrawLine()</code></a>, <a href="Window.html#1013482"><code>WinDrawGrayLine()</code></a>, <a href="Window.html#1013906"><code>WinEraseLine()</code></a>, <a href="Window.html#1014083"><code>WinFillLine()</code></a>, <a href="Window.html#1014810"><code>WinInvertLine()</code></a>, <a href="Window.html#1015171"><code>WinPaintLine()</code></a> </p>

<h3 class="hbH3">
  <a name="1015274"> </a>WinPaintPixel Function <a href="#1012037"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="1015276"> </a>Purpose 
</h4>

<p><a name="1015277"> </a>Render a pixel in the draw window using the current drawing state.</p>
<h4>
  <a name="1015278"> </a>Declared In 
</h4>
<code>Window.h<a name="1015279"> </a></code><h4>
  <a name="1015280"> </a>Prototype 
</h4>
<pre class="proto"><a name="1015282"></a>void WinPaintPixel (
   Coord x,
   Coord y
)
</pre>
<h4>
  <a name="1015283"> </a>Parameters 
</h4>

<dl>
<dt><a name="1015284"> </a><code>&rarr;  <i><code>x</code></i></code></dt>
<dd><a name="1015285"> </a>Pointer to the x coordinate of a pixel.</dd>

<dt><a name="1015286"> </a><code>&rarr;  <i><code>y</code></i></code></dt>
<dd><a name="1015287"> </a>Pointer to the y coordinate of a pixel.</dd>

</dl>
<h4>
  <a name="1015288"> </a>Returns 
</h4>

<p><a name="1015289"> </a>Returns nothing.</p>
<h4>
  <a name="1015290"> </a>Comments 
</h4>

<p><a name="1015291"> </a>This function uses the current drawing state, which is stored in a <a href="Window.html#1012130"><code>DrawStateType</code></a> structure. See the description of that structure to learn the functions you can call to set the drawing state to the state you want. </p>
<h4>
  <a name="1015295"> </a>Compatibility 
</h4>

<p><a name="1015299"> </a>Implemented only if <a href="CompatibilityApdx.html#994671">3.5 New Feature Set</a> is present.</p>
<h4>
  <a name="1015300"> </a>See Also 
</h4>

<p><a name="1015310"> </a><a href="Window.html#1013670"><code>WinDrawPixel()</code></a>, <a href="Window.html#1013948"><code>WinErasePixel()</code></a>, <a href="Window.html#1014855"><code>WinInvertPixel()</code></a>, <a href="Window.html#1015316"><code>WinPaintPixels()</code></a> </p>

<h3 class="hbH3">
  <a name="1015316"> </a>WinPaintPixels Function <a href="#1012037"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="1015318"> </a>Purpose 
</h4>

<p><a name="1015319"> </a>Render several pixels in the draw window using the current drawing state.</p>
<h4>
  <a name="1015320"> </a>Declared In 
</h4>
<code>Window.h<a name="1015321"> </a></code><h4>
  <a name="1015322"> </a>Prototype 
</h4>
<pre class="proto"><a name="1015324"></a>void WinPaintPixels (
   UInt16 numPoints,
   PointType pts[]
)
</pre>
<h4>
  <a name="1015325"> </a>Parameters 
</h4>

<dl>
<dt><a name="1015326"> </a><code>&rarr;  <i>numPoints</i></code></dt>
<dd><a name="1015327"> </a>Number of pixels to paint.</dd>

<dt><a name="1015328"> </a><code>&rarr;  <i>pts</i></code></dt>
<dd><a name="1015329"> </a>Array of pixels.</dd>

</dl>
<h4>
  <a name="1015330"> </a>Returns 
</h4>

<p><a name="1015331"> </a>Returns nothing.</p>
<h4>
  <a name="1015332"> </a>Comments 
</h4>

<p><a name="1015333"> </a>This function uses the current drawing state, which is stored in a <a href="Window.html#1012130"><code>DrawStateType</code></a> structure. See the description of that structure to learn the functions you can call to set the drawing state to the state you want. </p>
<h4>
  <a name="1015337"> </a>Compatibility 
</h4>

<p><a name="1015341"> </a>Implemented only if <a href="CompatibilityApdx.html#994671">3.5 New Feature Set</a> is present.</p>
<h4>
  <a name="1015342"> </a>See Also 
</h4>

<p><a name="1015352"> </a><a href="Window.html#1013670"><code>WinDrawPixel()</code></a>, <a href="Window.html#1013948"><code>WinErasePixel()</code></a>, <a href="Window.html#1014855"><code>WinInvertPixel()</code></a>, <a href="Window.html#1015274"><code>WinPaintPixel()</code></a> </p>

<h3 class="hbH3">
  <a name="1015358"> </a>WinPaintRectangle Function <a href="#1012037"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="1015360"> </a>Purpose 
</h4>

<p><a name="1015361"> </a>Draw a rectangle in the draw window using the current drawing state.</p>
<h4>
  <a name="1015362"> </a>Declared In 
</h4>
<code>Window.h<a name="1015363"> </a></code><h4>
  <a name="1015364"> </a>Prototype 
</h4>
<pre class="proto"><a name="1015366"></a>void WinPaintRectangle (
   const RectangleType *rP,
   UInt16 cornerDiam
)
</pre>
<h4>
  <a name="1015367"> </a>Parameters 
</h4>

<dl>
<dt><a name="1015368"> </a><code>&rarr;  <i><code>rP</code></i></code></dt>
<dd><a name="1015369"> </a>Pointer to the rectangle to draw.</dd>

<dt><a name="1015370"> </a><code>&rarr;  <i><code>cornerDiam</code></i></code></dt>
<dd><a name="1015371"> </a>Radius of rounded corners. Specify zero for square corners.</dd>

</dl>
<h4>
  <a name="1015372"> </a>Returns 
</h4>

<p><a name="1015373"> </a>Returns nothing.</p>
<h4>
  <a name="1015374"> </a>Comments 
</h4>

<p><a name="1015375"> </a>The <code>cornerDiam</code> parameter specifies the radius of four imaginary circles used to form the rounded corners. An imaginary circle is placed within each corner tangent to the rectangle on two sides.</p>

<p><a name="1015376"> </a>This function uses the current drawing state, which is stored in a <a href="Window.html#1012130"><code>DrawStateType</code></a> structure. See the description of that structure to learn the functions you can call to set the drawing state to the state you want. </p>
<h4>
  <a name="1015380"> </a>Compatibility 
</h4>

<p><a name="1015384"> </a>Implemented only if <a href="CompatibilityApdx.html#994671">3.5 New Feature Set</a> is present.</p>
<h4>
  <a name="1015385"> </a>See Also 
</h4>

<p><a name="1015392"> </a><a href="Window.html#1013707"><code>WinDrawRectangle()</code></a>, <a href="Window.html#1013985"><code>WinEraseRectangle()</code></a>, <a href="Window.html#1014130"><code>WinFillRectangle()</code></a>, <a href="Window.html#1014895"><code>WinInvertRectangle()</code></a> </p>

<h3 class="hbH3">
  <a name="1015401"> </a>WinPaintRectangleFrame Function <a href="#1012037"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="1015403"> </a>Purpose 
</h4>

<p><a name="1015404"> </a>Draw a rectangular frame in the draw window using the current drawing state.</p>
<h4>
  <a name="1015406"> </a>Declared In 
</h4>
<code>Window.h<a name="1015407"> </a></code><h4>
  <a name="1015408"> </a>Prototype 
</h4>
<pre class="proto"><a name="1015410"></a>void WinPaintRectangleFrame (
   FrameType frame,
   const RectangleType *rP
)
</pre>
<h4>
  <a name="1015411"> </a>Parameters 
</h4>

<dl>
<dt><a name="1015412"> </a><code>&rarr;  <i><code>frame</code></i></code></dt>
<dd><a name="1015416"> </a>Type of frame to draw (see <a href="Window.html#1012368"><code>FrameType</code></a>).</dd>

<dt><a name="1015417"> </a><code>&rarr;  <i><code>rP</code></i></code></dt>
<dd><a name="1015418"> </a>Pointer to the rectangle to frame.</dd>

</dl>
<h4>
  <a name="1015419"> </a>Returns 
</h4>

<p><a name="1015420"> </a>Returns nothing.</p>
<h4>
  <a name="1015421"> </a>Comments 
</h4>

<p><a name="1015422"> </a>The frame is drawn outside the specified rectangle.</p>

<p><a name="1015423"> </a>This function uses the current drawing state, which is stored in a <a href="Window.html#1012130"><code>DrawStateType</code></a> structure. See the description of that structure to learn the functions you can call to set the drawing state to the state you want. </p>
<h4>
  <a name="1015427"> </a>Compatibility 
</h4>

<p><a name="1015431"> </a>Implemented only if <a href="CompatibilityApdx.html#994671">3.5 New Feature Set</a> is present.</p>
<h4>
  <a name="1015432"> </a>See Also 
</h4>

<p><a name="1015438"> </a><a href="Window.html#1013526"><code>WinDrawGrayRectangleFrame()</code></a>, <a href="Window.html#1013745"><code>WinDrawRectangleFrame()</code></a>, <a href="Window.html#1014019"><code>WinEraseRectangleFrame()</code></a>, <a href="Window.html#1014438"><code>WinGetFramesRectangle()</code></a>, <a href="Window.html#1014933"><code>WinInvertRectangleFrame()</code></a>, <a href="Window.html#1015454"><code>WinPaintRoundedRectangleFrame()</code></a> </p>

<h3 class="hbH3">
  <a name="1015454"> </a>WinPaintRoundedRectangleFrame Function <a href="#1012037"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="1015456"> </a>Purpose 
</h4>

<p><a name="1015457"> </a>Draw a rectangular frame with rounded corners in the draw window using the current drawing state.</p>
<h4>
  <a name="1015458"> </a>Declared In 
</h4>
<code>Window.h<a name="1015459"> </a></code><h4>
  <a name="1015460"> </a>Prototype 
</h4>
<pre class="proto"><a name="1015461"></a>void WinPaintRoundedRectangleFrame (
   const RectangleType *rP,
   Coord width,
   Coord cornerRadius,
   Coord shadowWidth
)
</pre>
<h4>
  <a name="1015462"> </a>Parameters 
</h4>

<dl>
<dt><a name="1015463"> </a><code>&rarr;  <i>rP</i></code></dt>
<dd><a name="1015464"> </a>Pointer to the rectangle to frame.</dd>

<dt><a name="1015465"> </a><code>&rarr;  <i>width</i></code></dt>
<dd><a name="1015466"> </a>The width of the frame, interpreted using the active coordinate system.</dd>

<dt><a name="1015467"> </a><code>&rarr;  <i>cornerRadius</i></code></dt>
<dd><a name="1015468"> </a>The radius of the rectangle's rounded corners, interpreted using the active coordinate system.</dd>

<dt><a name="1015469"> </a><code>&rarr;  <i>shadowWidth</i></code></dt>
<dd><a name="1015470"> </a>The shadow offset, interpreted using the active coordinate system.</dd>

</dl>
<h4>
  <a name="1015471"> </a>Returns 
</h4>

<p><a name="1015472"> </a>Returns nothing.</p>
<h4>
  <a name="1015473"> </a>Comments 
</h4>

<p><a name="1015474"> </a>This function allows you to draw a rectangle with a frame width and corner radius specified in the active coordinate system. It is necessary because <a href="Window.html#1015401"><code>WinPaintRectangleFrame()</code></a> doesn't allow you to draw rounded rectangles with a frame width greater than 2. Note that because there isn't a function that parallels either <a href="Window.html#1013745"><code>WinDrawRectangleFrame()</code></a>, <a href="Window.html#1014019"><code>WinEraseRectangleFrame()</code></a>, or <a href="Window.html#1014933"><code>WinInvertRectangleFrame()</code></a>, you must set the drawing mode and colors as appropriate and use <code>WinPaintRoundedRectangleFrame</code> to achieve the desired effect.</p>
<h4>
  <a name="1015487"> </a>Compatibility 
</h4>

<p><a name="1015491"> </a>Implemented only if the <a href="CompatibilityApdx.html#996955">High-Density Display Feature Set</a> is present.</p>

<h3 class="hbH3">
  <a name="1015494"> </a>WinPaintTiledBitmap Function <a href="#1012037"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="1015496"> </a>Purpose 
</h4>

<p><a name="1015497"> </a>Fill a rectangle with a pattern defined by a bitmap.</p>
<h4>
  <a name="1015498"> </a>Declared In 
</h4>
<code>Window.h<a name="1015499"> </a></code><h4>
  <a name="1015500"> </a>Prototype 
</h4>
<pre class="proto"><a name="1015501"></a>void WinPaintTiledBitmap (
   BitmapType *bitmapP,
   RectangleType *rectP
)
</pre>
<h4>
  <a name="1015502"> </a>Parameters 
</h4>

<dl>
<dt><a name="1015503"> </a><code>&rarr;  <i>bitmapP</i></code></dt>
<dd><a name="1015504"> </a>Pointer to the bitmap that contains the desired pattern.</dd>

<dt><a name="1015505"> </a><code>&rarr;  <i>rectP</i></code></dt>
<dd><a name="1015506"> </a>Pointer to the rectangle that is to be filled.</dd>

</dl>
<h4>
  <a name="1015507"> </a>Returns 
</h4>

<p><a name="1015508"> </a>Returns nothing. On a debug ROM, if either <code>bitmapP</code> or <code>rectP</code> are <code>NULL</code>, an error is displayed.</p>
<h4>
  <a name="1015509"> </a>Comments 
</h4>

<p><a name="1015510"> </a>This function makes it possible for an application to define a pattern that is larger than the standard 8 by 8 custom pattern, and to define high-density custom patterns.</p>

<p><a name="1015511"> </a>The pattern is scaled by the blitter using the density of <code>bitmapP</code> and the density of the screen bitmap.  <code>bitmapP</code> can be a bitmap family; if it is, the Window Manager selects a bitmap using the same algorithm used by <a href="Window.html#1015004"><code>WinPaintBitmap()</code></a>. As with other patterns, the tiled pattern is anchored to the window's origin.</p>

<p><a name="1015515"> </a>If <code>bitmapP</code> does not match the depth or density of the destination bitmap, the blitter converts the bitmap using a temporary buffer. Note that if there isn't enough heap space for the temporary buffer, <code>WinPaintTiledBitmap</code> will be slow.</p>
<h4>
  <a name="1015516"> </a>Compatibility 
</h4>

<p><a name="1015520"> </a>Implemented only if the <a href="CompatibilityApdx.html#996955">High-Density Display Feature Set</a> is present.</p>

<h3 class="hbH3">
  <a name="1015523"> </a>WinPalette Function <a href="#1012037"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="1015525"> </a>Purpose 
</h4>

<p><a name="1015526"> </a>Set or retrieve the palette for the draw window.</p>
<h4>
  <a name="1015527"> </a>Declared In 
</h4>
<code>Window.h<a name="1015528"> </a></code><h4>
  <a name="1015529"> </a>Prototype 
</h4>
<pre class="proto"><a name="1015531"></a>Err WinPalette (
   UInt8 operation,
   Int16 startIndex,
   UInt16 paletteEntries,
   RGBColorType *tableP
)
</pre>
<h4>
  <a name="1015532"> </a>Parameters 
</h4>

<dl>
<dt><a name="1015533"> </a><code>&rarr;  <i><code>operation</code></i></code></dt>
<dd><a name="1015534"> </a>Specify one of the following values:</dd>

<dl>
<dt><a name="1015535"> </a><code><code>winPaletteGet</code></code></dt>
<dd><a name="1015536"> </a>Retrieve the palette. Entries are read from the palette beginning at <code>startIndex</code> and placed into <code>tableP</code> beginning at index 0.</dd>

<dt><a name="1015537"> </a><code><code>winPaletteSet</code></code></dt>
<dd><a name="1015538"> </a>Set the palette. Entries from <code>tableP</code> (beginning at index 0) are set into the palette beginning at <code>startIndex</code> in the palette.</dd>

<dt><a name="1015539"> </a><code><code>winPaletteSetToDefault</code></code></dt>
<dd><a name="1015540"> </a>Set the palette to the default system palette.</dd>

</dl>
<dt><a name="1015541"> </a><code>&rarr;  <i><code>startIndex</code></i></code></dt>
<dd><a name="1015542"> </a>Identifies where in the palette to start reading or writing. Specify <code>WinUseTableIndexes</code> to indicate that the entries are not to be set or read sequentially; instead, the <code>index</code> value in each <code>RGBColorType</code> entry in <code>tableP</code> determines which slot in the palette is to be set or read. You can use this technique to get or set several discontiguous palette entries with a single function call.</dd>

<dt><a name="1015544"> </a><code>&rarr;  <i><code>paletteEntries</code></i></code></dt>
<dd><a name="1015545"> </a>Number of palette entries to get or set.</dd>

<dt><a name="1015546"> </a><code>&harr;  <i><code>tableP</code></i></code></dt>
<dd><a name="1015550"> </a>A pointer to a buffer of <a href="Bitmap.html#998266"><code>RGBColorType</code></a> entries that is either read from or written to, depending on the <code>operation</code> parameter; the table entries from 0 to <code>paletteEntries</code> &#8211; 1 are affected by this routine.</dd>

</dl>
<h4>
  <a name="1015551"> </a>Returns 
</h4>

<p><a name="1015552"> </a>Returns one of the following values: </p>

<dl>
<dt><a name="1015553"> </a><code><code>errNone</code></code></dt>
<dd><a name="1015554"> </a>Success. </dd>

<dt><a name="1015555"> </a><code><code>winErrPalette</code></code></dt>
<dd><a name="1015556"> </a>The current draw window does not have a color table, a set operation has overflowed the color table, or one of the entries in <code>tableP</code> has an invalid index value </dd>

<dt><a name="1015557"> </a><code><code>sysErrParamErr</code></code></dt>
<dd><a name="1015558"> </a>The <code>startIndex</code> value is invalid.</dd>

</dl>
<h4>
  <a name="1015559"> </a>Comments 
</h4>

<p><a name="1015560"> </a>Here are some examples of how this routine works: </p>
<ul type="disc">
  <li><a name="1015561"> </a>If <code>startIndex</code> is 0 and <code>paletteEntries</code> is 10, the first 10 elements of the palette will be set from <code>tableP</code> or will be copied into <code>tableP</code>. 
  <li><a name="1015562"> </a>If <code>startIndex</code> is 10 and <code>paletteEntries</code> is 5, then entries 10, 11, 12, 13, and 14 in the palette will be set from or copied to elements 0, 1, 2, 3, and 4 in <code>tableP</code>. 
  <li><a name="1015564"> </a>If <code>startIndex</code> is <code>WinUseTableIndexes</code> and <code>paletteEntries</code> is 1, then the index value in the <code>RGBColorType</code> of element 0 of <code>tableP</code> will be read from or copied to <code>tableP</code>; in this case, the <code>index</code> field of the <code>RGBColorType</code> will not change.
</ul>

<p><a name="1015565"> </a>During a set operation, this function broadcasts the <a href="Notifications.html#1047736"><code>sysNotifyDisplayChangeEvent</code></a> to notify any interested observer that the color palette has changed. </p>

<p><a name="1015570"> </a>One use for this function is if you need to display a bitmap that uses a color table other than the one in use by the system. You can attach a custom color table to a bitmap, and if you do, the bitmap is drawn using that color table. However, this is a performance drain. As an optimization, you can use <code>WinPalette</code> to change the system color table to match that used by the bitmap, display the bitmap, and use <code>WinPalette</code> to reset the color table when the bitmap is no longer visible. </p>
<h4>
  <a name="1015571"> </a>Compatibility 
</h4>

<p><a name="1015575"> </a>Implemented only if <a href="CompatibilityApdx.html#994671">3.5 New Feature Set</a> is present.</p>

<h3 class="hbH3">
  <a name="1015578"> </a>WinPopDrawState Function <a href="#1012037"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="1015580"> </a>Purpose 
</h4>

<p><a name="1015581"> </a>Restore the draw state values to the last saved set on the stack.</p>
<h4>
  <a name="1015582"> </a>Declared In 
</h4>
<code>Window.h<a name="1015583"> </a></code><h4>
  <a name="1015584"> </a>Prototype 
</h4>
<pre class="proto"><a name="1015586"></a>void WinPopDrawState (
   void
)
</pre>
<h4>
  <a name="1015587"> </a>Parameters 
</h4>

<dl>
<dt><a name="1015588"> </a><code>None.</code></dt>
</dl>
<h4>
  <a name="1015589"> </a>Returns 
</h4>

<p><a name="1015590"> </a>Returns nothing.</p>
<h4>
  <a name="1015591"> </a>Comments 
</h4>

<p><a name="1015592"> </a>Use this routine to restore the draw state saved by the previous call to <a href="Window.html#1015604"><code>WinPushDrawState()</code></a>.</p>

<p><a name="1015596"> </a>After you call this function, the current draw window's <code>drawStateP</code> field points to the restored drawing state. </p>
<h4>
  <a name="1015597"> </a>Compatibility 
</h4>

<p><a name="1015601"> </a>Implemented only if <a href="CompatibilityApdx.html#994671">3.5 New Feature Set</a> is present.</p>

<h3 class="hbH3">
  <a name="1015604"> </a>WinPushDrawState Function <a href="#1012037"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="1015606"> </a>Purpose 
</h4>

<p><a name="1015607"> </a>Save the current draw state values onto the draw state stack.</p>
<h4>
  <a name="1015608"> </a>Declared In 
</h4>
<code>Window.h<a name="1015609"> </a></code><h4>
  <a name="1015610"> </a>Prototype 
</h4>
<pre class="proto"><a name="1015612"></a>void WinPushDrawState (
   void
)
</pre>
<h4>
  <a name="1015613"> </a>Parameters 
</h4>

<dl>
<dt><a name="1015614"> </a><code>None.</code></dt>
</dl>
<h4>
  <a name="1015615"> </a>Returns 
</h4>

<p><a name="1015616"> </a>Returns nothing.</p>
<h4>
  <a name="1015617"> </a>Comments 
</h4>

<p><a name="1015618"> </a>Use this routine to save the current draw state before making changes to it using the functions listed in the <a href="Window.html#1012130"><code>DrawStateType</code></a> structure's description. Call <a href="Window.html#1015578"><code>WinPopDrawState()</code></a> to restore the saved settings.</p>
<h4>
  <a name="1015625"> </a>Compatibility 
</h4>

<p><a name="1015629"> </a>Implemented only if <a href="CompatibilityApdx.html#994671">3.5 New Feature Set</a> is present.</p>

<h3 class="hbH3">
  <a name="1015632"> </a>WinResetClip Function <a href="#1012037"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="1015634"> </a>Purpose 
</h4>

<p><a name="1015635"> </a>Reset the clipping rectangle of the draw window to the portion of the draw window that is within the bounds of the display. </p>
<h4>
  <a name="1015636"> </a>Declared In 
</h4>
<code>Window.h<a name="1015637"> </a></code><h4>
  <a name="1015638"> </a>Prototype 
</h4>
<pre class="proto"><a name="1015640"></a>void WinResetClip (
   void
)
</pre>
<h4>
  <a name="1015641"> </a>Parameters 
</h4>

<dl>
<dt><a name="1015642"> </a><code>None.</code></dt>
</dl>
<h4>
  <a name="1015643"> </a>Returns 
</h4>

<p><a name="1015644"> </a>Returns nothing.</p>
<h4>
  <a name="1015645"> </a>See Also 
</h4>

<p><a name="1015649"> </a><a href="Window.html#1016415"><code>WinSetClip()</code></a></p>

<h3 class="hbH3">
  <a name="1015652"> </a>WinRestoreBits Function <a href="#1012037"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="1015654"> </a>Purpose 
</h4>

<p><a name="1015655"> </a>Copy the contents of the specified window to the draw window and delete the passed window.</p>
<h4>
  <a name="1015656"> </a>Declared In 
</h4>
<code>Window.h<a name="1015657"> </a></code><h4>
  <a name="1015658"> </a>Prototype 
</h4>
<pre class="proto"><a name="1015660"></a>void WinRestoreBits (
   WinHandle winHandle,
   Coord destX,
   Coord destY
)
</pre>
<h4>
  <a name="1015661"> </a>Parameters 
</h4>

<dl>
<dt><a name="1015662"> </a><code>&rarr;  <i><code>winHandle</code></i></code></dt>
<dd><a name="1015663"> </a>Handle of window to copy and delete.</dd>

<dt><a name="1015664"> </a><code>&rarr;  <i><code>destX</code></i></code></dt>
<dd><a name="1015665"> </a>x coordinate in the draw window to copy to.</dd>

<dt><a name="1015666"> </a><code>&rarr;  <i><code>destY</code></i></code></dt>
<dd><a name="1015667"> </a>y coordinate in the draw window to copy to.</dd>

</dl>
<h4>
  <a name="1015668"> </a>Returns 
</h4>

<p><a name="1015669"> </a>Returns nothing.</p>
<h4>
  <a name="1015670"> </a>Comments 
</h4>

<p><a name="1015671"> </a>This routine is generally used to restore a region of the display that was saved with <a href="Window.html#1015725"><code>WinSaveBit()</code></a>.</p>
<h4>
  <a name="1015675"> </a>See Also 
</h4>

<p><a name="1015679"> </a><a href="Window.html#1015725"><code>WinSaveBit()</code></a></p>

<h3 class="hbH3">
  <a name="1015682"> </a>WinRGBToIndex Function <a href="#1012037"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="1015684"> </a>Purpose 
</h4>

<p><a name="1015685"> </a>Convert an RGB value to the index of the closest color in the currently active color lookup table (CLUT).</p>
<h4>
  <a name="1015686"> </a>Declared In 
</h4>
<code>Window.h<a name="1015687"> </a></code><h4>
  <a name="1015688"> </a>Prototype 
</h4>
<pre class="proto"><a name="1015690"></a>IndexedColorType WinRGBToIndex (
   const RGBColorType *rgbP
)
</pre>
<h4>
  <a name="1015691"> </a>Parameters 
</h4>

<dl>
<dt><a name="1015692"> </a><code>&rarr;  <i>rgbP</i></code></dt>
<dd><a name="1015693"> </a>Pointer to an RGB color value.</dd>

</dl>
<h4>
  <a name="1015694"> </a>Returns 
</h4>

<p><a name="1015695"> </a>Returns the index of the closest matching color in the CLUT.</p>
<h4>
  <a name="1015696"> </a>Comments 
</h4>

<p><a name="1015697"> </a>Palm OS 3.5 supports a maximum of 256 colors. The number of possible RGB colors greatly exceeds this amount. For this reason, an exact match may not be available for <code>rgbP</code>. If there is no exact RGB match, then a luminance best-fit is used if the color lookup table is entirely gray scale (red, green, and blue values for each entry are identical), or a shortest-distance fit in RGB space is used if the palette contains colors. RGB shortest distance may not always produce the actual closest perceptible color, but it's relatively fast and works for the system palette.</p>

<p><a name="1015698"> </a><code>WinRGBToIndex</code> uses the draw window's color table to return the appropriate color table index. If the draw window does not have a color table, the default color table of the current screen is used.</p>

<p><a name="1015699"> </a>If the draw window does not have a color table, and if the depth of the draw window and the depth of the screen are different, this function will return an inappropriate index. If this situation exists, the application should either define a color table for the draw window, or use <a href="Window.html#1015990"><code>WinScreenMode()</code></a> to set the screen depth to the same depth as the draw window before calling <code>WinRGBToIndex</code>.</p>

<div><hr>
  <a name="1015703"> </a> <b>NOTE: </b> The bitmap data will not be blitted properly if the depth of the screen is changed using <a href="Window.html#1015990"><code>WinScreenMode()</code></a> and the new window uses a bitmap that does not define the bitmap's color table. See <a href="Window.html#1015990"><code>WinScreenMode()</code></a> for information on how to work around this limitation.
<hr>
</div>
<h4>
  <a name="1015710"> </a>Compatibility 
</h4>

<p><a name="1015714"> </a>Implemented only if <a href="CompatibilityApdx.html#994671">3.5 New Feature Set</a> is present.</p>
<h4>
  <a name="1015715"> </a>See Also 
</h4>

<p><a name="1015722"> </a><a href="Window.html#1014715"><code>WinIndexToRGB()</code></a>, <a href="Window.html#1015990"><code>WinScreenMode()</code></a></p>

<h3 class="hbH3">
  <a name="1015725"> </a>WinSaveBit Function <a href="#1012037"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="1015727"> </a>Purpose 
</h4>

<p><a name="1015728"> </a>Create an offscreen window and copy the specified region from the draw window to the offscreen window.</p>
<h4>
  <a name="1015729"> </a>Declared In 
</h4>
<code>Window.h<a name="1015730"> </a></code><h4>
  <a name="1015731"> </a>Prototype 
</h4>
<pre class="proto"><a name="1015733"></a>WinHandle WinSaveBits (
   const RectangleType *source,
   UInt16 *error
)
</pre>
<h4>
  <a name="1015734"> </a>Parameters 
</h4>

<dl>
<dt><a name="1015735"> </a><code>&rarr;  <i><code>source</code></i></code></dt>
<dd><a name="1015736"> </a>Pointer to the bounds of the region to save, relative to the display.</dd>

<dt><a name="1015737"> </a><code>&larr;  <i><code>error</code></i></code></dt>
<dd><a name="1015738"> </a>Pointer to any error encountered by this function.</dd>

</dl>
<h4>
  <a name="1015739"> </a>Returns 
</h4>

<p><a name="1015740"> </a>Returns the handle of the window containing the saved image, or zero if an error occurred.</p>
<h4>
  <a name="1015741"> </a>Comments 
</h4>

<p><a name="1015742"> </a>The offscreen window is the same size as the region to copy.</p>

<p><a name="1015743"> </a>This function tries to copy the window's bitmap using compressed format if possible. It may display a fatal error message if an error occurs when it tries to shrink the pointer for the compressed bits. </p>
<h4>
  <a name="1015744"> </a>See Also 
</h4>

<p><a name="1015748"> </a><a href="Window.html#1015652"><code>WinRestoreBits()</code></a></p>

<h3 class="hbH3">
  <a name="1015751"> </a>WinScaleCoord Function <a href="#1012037"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="1015753"> </a>Purpose 
</h4>

<p><a name="1015754"> </a>Convert a single coordinate from the standard coordinate system to the active coordinate system.</p>
<h4>
  <a name="1015755"> </a>Declared In 
</h4>
<code>Window.h<a name="1015756"> </a></code><h4>
  <a name="1015757"> </a>Prototype 
</h4>
<pre class="proto"><a name="1015758"></a>Coord WinScaleCoord (
   Coord coord,
   Boolean ceiling
)
</pre>
<h4>
  <a name="1015759"> </a>Parameters 
</h4>

<dl>
<dt><a name="1015760"> </a><code>&rarr;  <i>coord</i></code></dt>
<dd><a name="1015761"> </a>A coordinate in the standard coordinate system.</dd>

<dt><a name="1015762"> </a><code>&rarr;  <i>ceiling</i></code></dt>
<dd><a name="1015763"> </a>Pass <code>true</code> to round up, <code>false</code> to truncate the fractional part when scaling.</dd>

</dl>
<h4>
  <a name="1015764"> </a>Returns 
</h4>

<p><a name="1015765"> </a>Returns the coordinate scaled to the active coordinate system.</p>
<h4>
  <a name="1015766"> </a>Comments 
</h4>

<p><a name="1015767"> </a>This function converts a coordinate by multiplying it by the coordinate scaling factor, and then truncating or rounding the result to an integer value depending on the value of <code>ceiling</code>.</p>

<p><a name="1015768"> </a>If the active coordinate system is <code>kCoordinatesStandard</code>, the returned coordinate is equal to the supplied coordinate.</p>
<h4>
  <a name="1015769"> </a>Compatibility 
</h4>

<p><a name="1015773"> </a>Implemented only if the <a href="CompatibilityApdx.html#996955">High-Density Display Feature Set</a> is present.</p>

<p><a name="1085570"> </a>On Palm OS Cobalt, the scaling algorithm is slightly different. After the coordinate scale factor is applied, what happens next depends upon the value of <code class="par">ceiling</code>:</p>

<p><a name="1085571"> </a>if <code class="par">ceiling</code> == true {</p>

<p><a name="1085572"> </a>   use <code>lfloorf()</code> function when scaleFactor &gt; 1</p>

<p><a name="1085573"> </a>   use <code>lceilf()</code> function when scaleFactor &lt; 1</p>

<p><a name="1085574"> </a>else</p>

<p><a name="1085575"> </a>   use <code>lceilf()</code> function when scaleFactor &gt; 1</p>

<p><a name="1085576"> </a>   use <code>lfloorf()</code> function when scaleFactor &lt; 1</p>

<p><a name="1085577"> </a>}</p>

<p><a name="1085578"> </a>The objective of this algorithm is to ensure that for any <code>Coord</code>, <code>Point</code>, or <code>Rectangle</code> "x", x = unscaled(scaled(x)). </p>
<h4>
  <a name="1015774"> </a>See Also 
</h4>

<p><a name="1015781"> </a><a href="Window.html#1015787"><code>WinScalePoint()</code></a>, <a href="Window.html#1015823"><code>WinScaleRectangle()</code></a>, <a href="Window.html#1016949"><code>WinUnscaleCoord()</code></a></p>

<h3 class="hbH3">
  <a name="1015787"> </a>WinScalePoint Function <a href="#1012037"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="1015789"> </a>Purpose 
</h4>

<p><a name="1015790"> </a>Convert a point from the standard coordinate system to the active coordinate system.</p>
<h4>
  <a name="1015791"> </a>Declared In 
</h4>
<code>Window.h<a name="1015792"> </a></code><h4>
  <a name="1015793"> </a>Prototype 
</h4>
<pre class="proto"><a name="1015794"></a>void WinScalePoint (
   PointType *pointP,
   Boolean ceiling
)
</pre>
<h4>
  <a name="1015795"> </a>Parameters 
</h4>

<dl>
<dt><a name="1015796"> </a><code>&harr;  <i>pointP</i></code></dt>
<dd><a name="1015797"> </a>Pointer to a <code>PointType</code> structure that, before the call, should contain a point's standard coordinate system coordinates. After this function is called the <code>PointType</code> structure contains the coordinates of the point scaled to the active coordinate system.</dd>

<dt><a name="1015798"> </a><code>&rarr;  <i>ceiling</i></code></dt>
<dd><a name="1015799"> </a>Pass <code>true</code> to round up, <code>false</code> to truncate the fractional part when scaling.</dd>

</dl>
<h4>
  <a name="1015800"> </a>Returns 
</h4>

<p><a name="1015801"> </a>Returns nothing. The coordinates of the point indicated by <code>pointP</code> are converted to the active coordinate system.</p>
<h4>
  <a name="1015802"> </a>Comments 
</h4>

<p><a name="1015803"> </a>This function converts a point by multiplying its x and y coordinates by the coordinate scaling factor and then truncating or rounding the results depending on the value of <code>ceiling</code>.</p>

<p><a name="1015804"> </a>If the active coordinate system is <code>kCoordinatesStandard</code>, <code>pointP</code> is not changed by this function.</p>
<h4>
  <a name="1015805"> </a>Compatibility 
</h4>

<p><a name="1015809"> </a>Implemented only if the <a href="CompatibilityApdx.html#996955">High-Density Display Feature Set</a> is present.</p>

<p><a name="1085593"> </a>On Palm OS Cobalt, the scaling algorithm is slightly different. After the coordinate scale factor is applied, what happens next depends upon the value of <code class="par">ceiling</code>:</p>

<p><a name="1085594"> </a>if <code class="par">ceiling</code> == true {</p>

<p><a name="1085595"> </a>   use <code>lfloorf()</code> function when scaleFactor &gt; 1</p>

<p><a name="1085596"> </a>   use <code>lceilf()</code> function when scaleFactor &lt; 1</p>

<p><a name="1085597"> </a>else</p>

<p><a name="1085598"> </a>   use <code>lceilf()</code> function when scaleFactor &gt; 1</p>

<p><a name="1085599"> </a>   use <code>lfloorf()</code> function when scaleFactor &lt; 1</p>

<p><a name="1085600"> </a>}</p>

<p><a name="1085601"> </a>The objective of this algorithm is to ensure that for any <code>Coord</code>, <code>Point</code>, or <code>Rectangle</code> "x", x = unscaled(scaled(x)). </p>
<h4>
  <a name="1015810"> </a>See Also 
</h4>

<p><a name="1015817"> </a><a href="Window.html#1015751"><code>WinScaleCoord()</code></a>, <a href="Window.html#1015823"><code>WinScaleRectangle()</code></a>, <a href="Window.html#1016985"><code>WinUnscalePoint()</code></a></p>

<h3 class="hbH3">
  <a name="1015823"> </a>WinScaleRectangle Function <a href="#1012037"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="1015825"> </a>Purpose 
</h4>

<p><a name="1015826"> </a>Convert a rectangle from the standard coordinate system to the active coordinate system.</p>
<h4>
  <a name="1015827"> </a>Declared In 
</h4>
<code>Window.h<a name="1015828"> </a></code><h4>
  <a name="1015829"> </a>Prototype 
</h4>
<pre class="proto"><a name="1015830"></a>void WinScaleRectangle (
   RectangleType *rectP
)
</pre>
<h4>
  <a name="1015831"> </a>Parameters 
</h4>

<dl>
<dt><a name="1015832"> </a><code>&harr;  <i>rectP</i></code></dt>
<dd><a name="1015833"> </a>Pointer to a <code>RectangleType</code> structure that, before the call, should contain a rectangle's standard coordinate system coordinates. After this function is called the <code>RectangleType</code> structure contains the coordinates of the rectangle scaled to the active coordinate system.</dd>

</dl>
<h4>
  <a name="1015834"> </a>Returns 
</h4>

<p><a name="1015835"> </a>Returns nothing. The coordinates of the rectangle indicated by <code>rectP</code> are converted to the native coordinate system.</p>
<h4>
  <a name="1015836"> </a>Comments 
</h4>

<p><a name="1015837"> </a>This function scales the rectangle's <code>topLeft</code> and <code>extent</code> points by multiplying their <code>x</code> and <code>y</code> coordinates by the coordinate scaling factor. All values are then truncated, but if either <code>topLeft.x</code> or <code>extent.x</code> had a fractional part, <code>extent.x</code> is incremented by 1 (and, similarly, if either <code>topLeft.y</code> or <code>extent.y</code> had a fractional part, <code>extent.y</code> is incremented by 1).</p>

<p><a name="1015838"> </a>If the active coordinate system is <code>kCoordinatesStandard</code>, <code>rectP</code> is not changed by this function.</p>

<p><a name="1015839"> </a>You can use this function when your gadget handler draws using a more precise coordinate system than the Form Manager and needs to convert the form-based bounds of the gadget to the high-density bounds used by the gadget's drawing function.</p>
<h4>
  <a name="1015840"> </a>Compatibility 
</h4>

<p><a name="1015844"> </a>Implemented only if the <a href="CompatibilityApdx.html#996955">High-Density Display Feature Set</a> is present.</p>
<h4>
  <a name="1015845"> </a>See Also 
</h4>

<p><a name="1015852"> </a><a href="Window.html#1015751"><code>WinScaleCoord()</code></a>, <a href="Window.html#1015787"><code>WinScalePoint()</code></a>, <a href="Window.html#1017021"><code>WinUnscaleRectangle()</code></a></p>

<h3 class="hbH3">
  <a name="1015858"> </a>WinScreenGetAttribute Function <a href="#1012037"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="1015860"> </a>Purpose 
</h4>

<p><a name="1015861"> </a>Get various attributes of the screen.</p>
<h4>
  <a name="1015862"> </a>Declared In 
</h4>
<code>Window.h<a name="1015863"> </a></code><h4>
  <a name="1015864"> </a>Prototype 
</h4>
<pre class="proto"><a name="1015865"></a>Err WinScreenGetAttribute (
   WinScreenAttrType selector,
   UInt32 *attrP
)
</pre>
<h4>
  <a name="1015866"> </a>Parameters 
</h4>

<dl>
<dt><a name="1015867"> </a><code>&rarr;  <i>selector</i></code></dt>
<dd><a name="1015868"> </a>A value indicating which attribute to return. See the description of <a href="Window.html#1015885"><code>WinScreenAttrType</code></a> in the Comments section, below, for the values you can supply to this parameter.</dd>

<dt><a name="1015872"> </a><code>&larr;  <i>attrP</i></code></dt>
<dd><a name="1015873"> </a>Pointer to a <code>UInt32</code> into which the specified attribute value is placed by this function.</dd>

</dl>
<h4>
  <a name="1015874"> </a>Returns 
</h4>

<p><a name="1015875"> </a>Returns <code>errNone</code> if the function successfully retrieved the specified attribute, or <code>sysErrParamErr</code> if <code>selector</code> doesn't represent a screen attribute.</p>
<h4>
  <a name="1015876"> </a>Comments 
</h4>

<p><a name="1015877"> </a>This function returns many of the attributes that can be obtained with <a href="Window.html#1015990"><code>WinScreenMode()</code></a>. Unlike <code>WinScreenMode</code>, however, this function can also return the number of bytes used by each row in the screen buffer as well as the number of pixels per inch on the screen's x and y axes.</p>

<p><a name="1015881"> </a>Unlike <code>WinScreenMode</code>, you cannot set any attributes with this function. Also, you cannot use this function to obtain the "color enabled" attribute. And unlike <code>WinScreenMode</code>, this function always returns the true screen dimensions; <code>WinScreenMode</code> converts the dimensions to the active coordinate system.</p>

<p><a name="1015882"> </a>Applications can use the screen resolution information to make intelligent decisions about how to draw primitives on Palm Powered handhelds with different screen resolutions.</p>

<h4 class="hcH4">
  <a name="1015885"> </a>WinScreenAttrType
</h4>

<p><a name="1015886"> </a>This enum defines the selectors that can be used with the <a href="Window.html#1015858"><code>WinScreenGetAttribute()</code></a> function.</p>
<h4>
  <a name="1015890"> </a>Prototype 
</h4>
<pre class="proto"><a name="1015891"></a>typedef enum {
  winScreenWidth,
  winScreenHeight,
  winScreenRowBytes,
  winScreenDepth,
  winScreenAllDepths,
  winScreenDensity,
  winScreenPixelFormat,
  winScreenResolutionX,
  winScreenResolutionY
} WinScreenAttrType;
</pre>
<h4>
  <a name="1084367"> </a>Constants 
</h4>

<dl>
<dt><a name="1015905"> </a><code>winScreenWidth</code></dt>
<dd><a name="1015907"> </a>The width of the screen, in pixels.</dd>

<dt><a name="1015909"> </a><code>winScreenHeight</code></dt>
<dd><a name="1015911"> </a>The height of the screen, in pixels.</dd>

<dt><a name="1015913"> </a><code>winScreenRowBytes</code></dt>
<dd><a name="1015915"> </a>The number of bytes used by each row in the screen buffer.</dd>

<dt><a name="1015917"> </a><code>winScreenDepth</code></dt>
<dd><a name="1015919"> </a>The screen depth.</dd>

<dt><a name="1015921"> </a><code>winScreenAllDepths</code></dt>
<dd><a name="1015923"> </a>All screen depths (in bitmap format).</dd>

<dt><a name="1015925"> </a><code>winScreenDensity</code></dt>
<dd><a name="1015927"> </a>The screen bitmap's density.</dd>

<dt><a name="1015929"> </a><code>winScreenPixelFormat</code></dt>
<dd><a name="1015934"> </a>The <a href="Bitmap.html#998226"><code>PixelFormatType</code></a> appropriate for the screen.</dd>

<dt><a name="1015936"> </a><code>winScreenResolutionX</code></dt>
<dd><a name="1015938"> </a>The number of pixels per inch along the screen's x axis.</dd>

<dt><a name="1015940"> </a><code>winScreenResolutionY</code></dt>
<dd><a name="1015942"> </a>The number of pixels per inch along the screen's y axis.</dd>

</dl>
<h4>
  <a name="1015944"> </a>Compatibility 
</h4>

<p><a name="1015948"> </a>Implemented only if the <a href="CompatibilityApdx.html#996955">High-Density Display Feature Set</a> is present.</p>
<h4>
  <a name="1015949"> </a>See Also 
</h4>

<p><a name="1015953"> </a><a href="Window.html#1015990"><code>WinScreenMode()</code></a></p>

<h3 class="hbH3">
  <a name="1015956"> </a>WinScreenLock Function <a href="#1012037"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="1015958"> </a>Purpose 
</h4>

<p><a name="1015959"> </a>"Lock" the current screen by switching the UI concept of the screen base address to an area that is not reflected on the display.</p>
<h4>
  <a name="1015960"> </a>Declared In 
</h4>
<code>Window.h<a name="1015961"> </a></code><h4>
  <a name="1015962"> </a>Prototype 
</h4>
<pre class="proto"><a name="1015965"></a>UInt8 *WinScreenLock (
   WinLockInitType initMode
)
</pre>
<h4>
  <a name="1015966"> </a>Parameters 
</h4>

<dl>
<dt><a name="1015967"> </a><code>&rarr;  <i>initMode</i></code></dt>
<dd><a name="1015968"> </a>Indicates how to initialize the new screen area. Specify one of the following values:</dd>

<dl>
<dt><a name="1015969"> </a><code><code>winLockCopy</code></code></dt>
<dd><a name="1015970"> </a>Copy old screen to new.</dd>

<dt><a name="1015971"> </a><code><code>winLockErase</code></code></dt>
<dd><a name="1015972"> </a>Erase new screen to white.</dd>

<dt><a name="1015973"> </a><code><code>winLockDontCare</code></code></dt>
<dd><a name="1015974"> </a>Don't do anything</dd>

</dl>
</dl>
<h4>
  <a name="1015975"> </a>Returns 
</h4>

<p><a name="1015976"> </a>Returns a pointer to the new screen base address, or <code>NULL</code> if this routine fails.</p>
<h4>
  <a name="1015977"> </a>Comments 
</h4>

<p><a name="1015978"> </a>This routine can be used to "freeze" the display while doing lengthy drawing operations to avoid a flickering effect. Call <a href="Window.html#1016195"><code>WinScreenUnlock()</code></a> to unlock the display and cause it to be updated with any changes. The screen must be unlocked as many times as it is locked to actually update the display.</p>

<p><a name="1015982"> </a>Because this function copies the screen, using it is a relatively expensive operation. </p>
<h4>
  <a name="1015983"> </a>Compatibility 
</h4>

<p><a name="1015987"> </a>Implemented only if <a href="CompatibilityApdx.html#994671">3.5 New Feature Set</a> is present.</p>

<h3 class="hbH3">
  <a name="1015990"> </a>WinScreenMode Function <a href="#1012037"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="1015992"> </a>Purpose 
</h4>

<p><a name="1015993"> </a>Sets or returns display parameters, including display geometry, bit depth, and color support. </p>
<h4>
  <a name="1015994"> </a>Declared In 
</h4>
<code>Window.h<a name="1015995"> </a></code><h4>
  <a name="1015996"> </a>Prototype 
</h4>
<pre class="proto"><a name="1015998"></a>Err WinScreenMode (
   WinScreenModeOperation operation,
   UInt32 *widthP,
   UInt32 *heightP,
   UInt32 *depthP,
   Boolean *enableColorP
)
</pre>
<h4>
  <a name="1016000"> </a>Parameters 
</h4>

<p><a name="1016001"> </a>The <code>widthP</code>, <code>heightP</code>, <code>depthP</code>, and <code>enableColorP</code> parameters are used in different ways for different operations. See <a href="Window.html#1016040">Comments</a> at the end of this description for details. </p>

<dl>
<dt><a name="1016005"> </a><code>&rarr;  <i>operation</i></code></dt>
<dd><a name="1016007"> </a>The work this function is to perform, as specified by one of the following selectors:</dd>

<dl>
<dt><a name="1016008"> </a><code><code>winScreenModeGet</code></code></dt>
<dd><a name="1016009"> </a>Return the current settings for the display. </dd>

<dt><a name="1016010"> </a><code><code>winScreenModeGetDefaults</code></code></dt>
<dd><a name="1016011"> </a>Return the default settings for the display. </dd>

<dt><a name="1016012"> </a><code><code>winScreenModeGetSupportedDepths</code></code></dt>
<dd><a name="1016013"> </a>Return in <code>depthP</code> a hexadecimal value indicating the supported screen depths. The binary representation of this value defines a bitfield in which the value 1 indicates support for a particular display depth. The position representing a particular bit depth corresponds to the value <code>2</code><!-PS02-><span style="color: #000000;  font-family: Courier; font-style: normal; font-weight: normal; text-decoration: none; text-transform: none; vertical-align: super">(bitDepth-1)</span>. See the <a href="Window.html#1016153">Example</a> at the end of this function description for more information.</dd>

<dt><a name="1016017"> </a><code><code>winScreenModeGetSupportsColor</code></code></dt>
<dd><a name="1016018"> </a>Return <code>true</code> as the value of the <code>enableColorP</code> parameter when color mode can be enabled.</dd>

<dt><a name="1016019"> </a><code><code>winScreenModeSet</code></code></dt>
<dd><a name="1016020"> </a>Change display settings to the values specified by the other arguments to the <code>WinScreenMode </code>function. </dd>

<dt><a name="1016021"> </a><code><code>winScreenModeSetToDefaults</code></code></dt>
<dd><a name="1016022"> </a>Change display settings to default values. </dd>

</dl>
<dt><a name="1016023"> </a><code>&harr;  <i>widthP</i></code></dt>
<dd><a name="1016024"> </a>Pointer to new/old screen width. For backward compatibility, when <code>operation</code> is <code>winScreenModeGet</code> or <code>winScreenModeGetDefaults</code>, a single-density width is returned, even if the handheld has a double-density display. Use <a href="Window.html#1015858"><code>WinScreenGetAttribute()</code></a> to retrieve the true hardware dimensions of the display.</dd>

<dt><a name="1016028"> </a><code>&harr;  <i>heightP</i></code></dt>
<dd><a name="1016029"> </a>Pointer to new/old screen height. For backward compatibility, when <code>operation</code> is <code>winScreenModeGet</code> or <code>winScreenModeGetDefaults</code>, a single-density height is returned, even if the handheld has a double-density display. Use <a href="Window.html#1015858"><code>WinScreenGetAttribute()</code></a> to retrieve the true hardware dimensions of the display.</dd>

<dt><a name="1016033"> </a><code>&harr;  <i><code>depthP</code></i></code></dt>
<dd><a name="1016034"> </a>Pointer to new/old/available screen depth.</dd>

<dt><a name="1016035"> </a><code>&harr;  <i>enableColorP</i></code></dt>
<dd><a name="1016036"> </a>Pass <code>true</code> to enable color drawing mode. The returned value (when using an operation that returns a value through this parameter) simply indicates whether or not the hardware supports color; its value does not change based on the current screen depth.</dd>

</dl>
<h4>
  <a name="1016037"> </a>Returns 
</h4>

<p><a name="1016038"> </a>If no error, returns values as specified by the <code>operation</code> argument. Various invalid arguments may cause this function to return a <code>sysErrParamErr</code> result code. In rare cases, a failed allocation can cause this function to return a <code>memErrNotEnoughSpace</code> error.</p>
<h4>
  <a name="1016040"> </a>Comments   
</h4>

<p><a name="1016041"> </a>The <code>widthP</code>, <code>heightP</code>, <code>depthP</code>, and <code>enableColorP</code> parameters are used in different ways for different operations. All "get" operations overwrite these values with a result when the function returns. The <code>winScreenModeSet</code> operation changes current display parameters when passed valid argument values that are not <code>NULL</code> pointers. The <code>winScreenModeSetToDefaults</code> operation ignores values passed for all of these parameters.</p>

<p><a name="1016045"> </a><a href="Window.html#1016052">Table 59.1</a> summarizes parameter usage for each operation this function performs. </p>

<p class="caption"><a name="1016052"> </a><b>Table 59.1&nbsp;&nbsp;Use of parameters to WinScreenMode function </b></p>
<div class="tablediv"><table cellspacing="0" class="tTable">

  <tr valign="top">
    <th><p class="tt"><a name="1016062"> </a><b>Operation <code>winScreenMode...</code></b></p>
    </th>
    <th><p class="tt"><a name="1016064"> </a><b>widthP</b></p>
    </th>
    <th><p class="tt"><a name="1016066"> </a><b>heightP</b></p>
    </th>
    <th><p class="tt"><a name="1016068"> </a><b>depthP</b></p>
    </th>
    <th><p class="tt"><a name="1016070"> </a><b>enableColorP</b></p>
    </th>
  </tr>
  <tr valign="top">
    <td><p class="tt"><a name="1016072"> </a><code>...Get</code></p>
    </td>
    <td><p class="tt"><a name="1016074"> </a>returned</p>
    </td>
    <td><p class="tt"><a name="1016076"> </a>returned</p>
    </td>
    <td><p class="tt"><a name="1016078"> </a>returned</p>
    </td>
    <td><p class="tt"><a name="1016080"> </a>returned</p>
    </td>
  </tr>
  <tr valign="top">
    <td><p class="tt"><a name="1016082"> </a><code>...GetDefaults</code></p>
    </td>
    <td><p class="tt"><a name="1016084"> </a>returned</p>
    </td>
    <td><p class="tt"><a name="1016086"> </a>returned</p>
    </td>
    <td><p class="tt"><a name="1016088"> </a>returned</p>
    </td>
    <td><p class="tt"><a name="1016090"> </a>returned</p>
    </td>
  </tr>
  <tr valign="top">
    <td><p class="tt"><a name="1016092"> </a><code>...GetSupportedDepths</code></p>
    </td>
    <td><p class="tt"><a name="1016094"> </a>ignored</p>
    </td>
    <td><p class="tt"><a name="1016096"> </a>ignored</p>
    </td>
    <td><p class="tt"><a name="1016098"> </a>returned</p>
    </td>
    <td><p class="tt"><a name="1016100"> </a>pass in</p>
    </td>
  </tr>
  <tr valign="top">
    <td><p class="tt"><a name="1016102"> </a><code>...GetSupportsColor</code></p>
    </td>
    <td><p class="tt"><a name="1016104"> </a>ignored</p>
    </td>
    <td><p class="tt"><a name="1016106"> </a>ignored</p>
    </td>
    <td><p class="tt"><a name="1016108"> </a>pass in</p>
    </td>
    <td><p class="tt"><a name="1016110"> </a>returned</p>
    </td>
  </tr>
  <tr valign="top">
    <td><p class="tt"><a name="1016112"> </a><code>...Set</code></p>
    </td>
    <td><p class="tt"><a name="1016114"> </a>pass in</p>
    </td>
    <td><p class="tt"><a name="1016116"> </a>pass in</p>
    </td>
    <td><p class="tt"><a name="1016118"> </a>pass in</p>
    </td>
    <td><p class="tt"><a name="1016120"> </a>pass in</p>
    </td>
  </tr>
  <tr valign="top">
    <td><p class="tt"><a name="1016122"> </a><code>...SetToDefaults</code></p>
    </td>
    <td><p class="tt"><a name="1016124"> </a>ignored</p>
    </td>
    <td><p class="tt"><a name="1016126"> </a>ignored </p>
    </td>
    <td><p class="tt"><a name="1016128"> </a>ignored</p>
    </td>
    <td><p class="tt"><a name="1016130"> </a>ignored</p>
    </td>
  </tr>
</table>

</div>


<p><a name="1016132"> </a>This function ignores <code>NULL</code> pointer arguments to the <code>widthP</code>, <code>heightP</code>, <code>depthP</code>, and <code>enableColorP</code> parameters; thus, you can pass a <code>NULL</code> pointer for any of these values to leave the current value unchanged. Similarly, when getting values, this function does not return a value for any <code>NULL</code> pointer argument. </p>

<p><a name="1016133"> </a>If you change the display depth, it is recommended that you restore it to its previous state when your application closes, even though the system sets display parameters back to their default values when launching an application. </p>

<p><a name="1016134"> </a>Note that none of the other operations interprets the depth parameter the same way that <code>winScreenModeGetSupportedDepths</code> does. For example, to set the display depth to 8-bit mode, you use 8 (decimal) for the display depth, not 0x80 (128 decimal). </p>

<p><a name="1016135"> </a>When a window is created, and if the window's associated bitmap does not have its own color table, the window will use the system's default color translation tables when a blitting operation occurs to that window. When the system's bit depth changes, the system's default color translation tables are recalculated based on the new screen depth. When the blit occurs at the new screen depth to the offscreen window, the color translation tables are out of sync. </p>

<p><a name="1016136"> </a>To work around this system limitation, developers should either:</p>
<ul type="disc">
  <li><a name="1016137"> </a>allocate offscreen windows after changing the depth, or
  <li><a name="1016141"> </a>use <a href="Window.html#1013088"><code>WinCreateBitmapWindow()</code></a> so that it uses a bitmap with a defined color table.
</ul>

<p><a name="1016142"> </a>The latter workaround causes the system to perform color matching when blitting, so the first workaround may be preferred.</p>
<h4>
  <a name="1016143"> </a>Compatibility 
</h4>

<p><a name="1016147"> </a>Implemented only if <a href="CompatibilityApdx.html#994671">3.5 New Feature Set</a> is present. In OS versions prior to 3.5, this function is called <code>ScrDisplayMode</code>. The prototype for <code>ScrDisplayMode</code> is similar to <code>WinScreenMode</code>: </p>

<div class="CodeRule"><hr></div><pre class="CodeBlock">
Err ScrDisplayMode ( ScrDisplayModeOperation operation,
DWordPtr widthP, DWordPtr heightP,
DWordPtr depthP, BooleanPtr enableColorP)<a name="1016149"> </a>
</pre><div class="CodeRule"><hr></div>


<p><a name="1016150"> </a>The only other difference between <code>ScrDisplayMode</code> and <code>WinScreenMode</code> is that the <code>ScrDisplayModeOperation</code> constants begin with the prefix <code>scrDisplayMode</code> rather than <code>winScreenMode</code>. </p>
<h4>
  <a name="1016153"> </a>Example 
</h4>

<p><a name="1016154"> </a>Here are some additional examples of return values provided by the <code>winScreenModeGetSupportedDepths</code> mode of the <code>WinScreenMode</code> function. </p>

<p><a name="1016155"> </a>This function indicates support for 4-bit drawing by returning a value of <code>0x08</code>, or 2<span style="color: #000000;  font-style: normal; font-weight: normal; text-decoration: none; text-transform: none; vertical-align: super">3</span>, which corresponds to a binary value of <code>1000</code>. Support for bit depths of 2 and 1 is indicated by a return value of <code>0x03</code>. Support for bit depths of 4, 2, and 1 is indicated by <code>0x0B</code>, which is a binary value of <code>1011</code>. Support for bit depths of 16, 8, 4 and 2 is indicated by <code>0x808A</code>. The figure immediately following depicts this final example graphically. <div align="left"><img src="images/WinScreenMode.gif" border="0" hspace="0" vspace="0">
</div></p>

<h4>
  <a name="1016188"> </a>See Also 
</h4>

<p><a name="1016192"> </a><a href="Window.html#1015858"><code>WinScreenGetAttribute()</code></a></p>

<h3 class="hbH3">
  <a name="1016195"> </a>WinScreenUnlock Function <a href="#1012037"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="1016197"> </a>Purpose 
</h4>

<p><a name="1016198"> </a>Unlock the screen and update the display.</p>
<h4>
  <a name="1016199"> </a>Declared In 
</h4>
<code>Window.h<a name="1016200"> </a></code><h4>
  <a name="1016201"> </a>Prototype 
</h4>
<pre class="proto"><a name="1016203"></a>void WinScreenUnlock (
   void
)
</pre>
<h4>
  <a name="1016204"> </a>Parameters 
</h4>

<dl>
<dt><a name="1016205"> </a><code>None.</code></dt>
</dl>
<h4>
  <a name="1016206"> </a>Returns 
</h4>

<p><a name="1016207"> </a>Returns nothing.</p>
<h4>
  <a name="1016209"> </a>Comments 
</h4>

<p><a name="1016210"> </a>The screen must be unlocked as many times as it is locked to actually update the display.</p>
<h4>
  <a name="1016211"> </a>Compatibility 
</h4>

<p><a name="1016215"> </a>Implemented only if <a href="CompatibilityApdx.html#994671">3.5 New Feature Set</a> is present.</p>
<h4>
  <a name="1016216"> </a>See Also 
</h4>

<p><a name="1016220"> </a><a href="Window.html#1015956"><code>WinScreenLock()</code></a></p>

<h3 class="hbH3">
  <a name="1016223"> </a>WinScrollRectangle Function <a href="#1012037"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="1016225"> </a>Purpose 
</h4>

<p><a name="1016226"> </a>Scroll a rectangle in the draw window.</p>
<h4>
  <a name="1016227"> </a>Declared In 
</h4>
<code>Window.h<a name="1016228"> </a></code><h4>
  <a name="1016229"> </a>Prototype 
</h4>
<pre class="proto"><a name="1016231"></a>void WinScrollRectangle (
   const RectangleType *rP,
   WinDirectionType direction,
   Coord distance,
   RectangleType *vacatedP
)
</pre>
<h4>
  <a name="1016233"> </a>Parameters 
</h4>

<dl>
<dt><a name="1016234"> </a><code>&rarr;  <i><code>rP</code></i></code></dt>
<dd><a name="1016235"> </a>Pointer to the rectangle to scroll.</dd>

<dt><a name="1016236"> </a><code>&rarr;  <i><code>direction</code></i></code></dt>
<dd><a name="1016238"> </a>Direction to scroll (<code>winUp</code>, <code>winDown</code>, <code>winLeft</code>, or <code>winRight</code>).</dd>

<dt><a name="1016239"> </a><code>&rarr;  <i><code>distance</code></i></code></dt>
<dd><a name="1016240"> </a>Distance to scroll in pixels.</dd>

<dt><a name="1016241"> </a><code>&larr;  <i><code>vacatedP</code></i></code></dt>
<dd><a name="1016242"> </a>Pointer to the rectangle that needs to be redrawn because it has been vacated as a result of the scroll.</dd>

</dl>
<h4>
  <a name="1016243"> </a>Returns 
</h4>

<p><a name="1016244"> </a>Returns nothing.</p>
<h4>
  <a name="1016245"> </a>Comments 
</h4>

<p><a name="1016246"> </a>The rectangle scrolls within its own bounds. Any portion of the rectangle that is scrolled outside its bounds is clipped.</p>

<h3 class="hbH3">
  <a name="1016249"> </a>WinSetActiveWindow Function <a href="#1012037"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="1016251"> </a>Purpose 
</h4>

<p><a name="1016253"> </a>Make a window the active window.</p>
<h4>
  <a name="1016254"> </a>Declared In 
</h4>
<code>Window.h<a name="1016255"> </a></code><h4>
  <a name="1016256"> </a>Prototype 
</h4>
<pre class="proto"><a name="1016258"></a>void WinSetActiveWindow (
   WinHandle winHandle
)
</pre>
<h4>
  <a name="1016259"> </a>Parameters 
</h4>

<dl>
<dt><a name="1016260"> </a><code>&rarr;  <i><code>winHandle</code></i></code></dt>
<dd><a name="1016261"> </a>Handle of a window.</dd>

</dl>
<h4>
  <a name="1016262"> </a>Returns 
</h4>

<p><a name="1016263"> </a>Returns nothing.</p>
<h4>
  <a name="1016264"> </a>Comments 
</h4>

<p><a name="1016265"> </a>The active window is not actually set in this routine; flags are set to indicate that a window is being exited and another window is being entered. The routine <code>EvtGetEvent</code> sends a <a href="EventRef.html#997992"><code>winExitEvent</code></a> and a <a href="EventRef.html#1026487"><code>winEnterEvent</code></a> when it detects these flags. The active window is set by <code>EvtGetEvent</code> when it sends the <code>winEnterEvent</code>. The draw window is also set to the new active window when the active window is changed. </p>

<p><a name="1016272"> </a>The window is enabled before it is made active. </p>

<p><a name="1016273"> </a>All user input is directed to the active window.</p>
<h4>
  <a name="1016274"> </a>See Also 
</h4>

<p><a name="1016281"> </a><a href="Window.html#1014168"><code>WinGetActiveWindow()</code></a>, <a href="SystemEventManager.html#1071061"><code>EvtGetEvent()</code></a> </p>

<h3 class="hbH3">
  <a name="1016284"> </a>WinSetBackColor Function <a href="#1012037"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="1016286"> </a>Purpose 
</h4>

<p><a name="1016287"> </a>Set the background color to use in subsequent draw operations.</p>
<h4>
  <a name="1016288"> </a>Declared In 
</h4>
<code>Window.h<a name="1016289"> </a></code><h4>
  <a name="1016290"> </a>Prototype 
</h4>
<pre class="proto"><a name="1016292"></a>IndexedColorType WinSetBackColor (
   IndexedColorType backColor
)
</pre>
<h4>
  <a name="1016293"> </a>Parameters 
</h4>

<dl>
<dt><a name="1016294"> </a><code>&rarr;  <i>backColor</i></code></dt>
<dd><a name="1016298"> </a>Color to set; specify a value of type <a href="Window.html#1012445"><code>IndexedColorType</code></a>.</dd>

</dl>
<h4>
  <a name="1016299"> </a>Returns 
</h4>

<p><a name="1016300"> </a>Returns the previous background color index.</p>
<h4>
  <a name="1016301"> </a>Comments 
</h4>

<p><a name="1016302"> </a>This function changes the current drawing state. If necessary, use <a href="Window.html#1015604"><code>WinPushDrawState()</code></a> to preserve the current drawing state before you set this function and use <a href="Window.html#1015578"><code>WinPopDrawState()</code></a> to restore it later. </p>

<p><a name="1016309"> </a>To set the foreground color to a predefined UI color default, use <a href="UIColor.html#996015"><code>UIColorGetTableEntryIndex()</code></a> as an input to this function. For example: </p>

<div class="CodeRule"><hr></div><pre class="CodeBlock">
curColor = WinSetBackColor
(UIColorGetTableEntryIndex(<code>UIFieldBackground</code>));<a name="1016313"> </a>
</pre><div class="CodeRule"><hr></div>

<h4>
  <a name="1016314"> </a>Compatibility 
</h4>

<p><a name="1016318"> </a>Implemented only if <a href="CompatibilityApdx.html#994671">3.5 New Feature Set</a> is present.</p>
<h4>
  <a name="1016319"> </a>See Also 
</h4>

<p><a name="1016326"> </a><a href="Window.html#1016542"><code>WinSetForeColor()</code></a>, <a href="Window.html#1016815"><code>WinSetTextColor()</code></a></p>

<h3 class="hbH3">
  <a name="1016329"> </a>WinSetBackColorRGB Function <a href="#1012037"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="1016331"> </a>Purpose 
</h4>

<p><a name="1016332"> </a>Set the background color to use in subsequent draw operations.</p>
<h4>
  <a name="1016333"> </a>Declared In 
</h4>
<code>Window.h<a name="1016334"> </a></code><h4>
  <a name="1016335"> </a>Prototype 
</h4>
<pre class="proto"><a name="1016337"></a>void WinSetBackColorRGB (
   const RGBColorType *newRgbP,
   RGBColorType *prevRgbP
)
</pre>
<h4>
  <a name="1016338"> </a>Parameters 
</h4>

<dl>
<dt><a name="1016339"> </a><code>&rarr;  <i>newRgbP</i></code></dt>
<dd><a name="1016343"> </a>Color to set; specify a value of type <a href="Bitmap.html#998266"><code>RGBColorType</code></a>.</dd>

<dt><a name="1016344"> </a><code>&larr;  <i>prevRgbP</i></code></dt>
<dd><a name="1016348"> </a>Previous color; specify a value of type <a href="Bitmap.html#998266"><code>RGBColorType</code></a>.</dd>

</dl>
<h4>
  <a name="1016349"> </a>Returns 
</h4>

<p><a name="1016350"> </a>Returns nothing</p>
<h4>
  <a name="1016351"> </a>Comments 
</h4>

<p><a name="1016355"> </a>This function takes new and previous <a href="Bitmap.html#998266"><code>RGBColorType</code></a> arguments. It is okay to set <code>newRgbP</code> or <code>prevRgbP</code> to <code>NULL</code>. If an application only wants to get the current color, the <code>newRgbP</code> argument is set to <code>NULL</code>. If the application does not care about the previous color, <code>prevRgbP</code> can be set to <code>NULL</code>.</p>

<p><a name="1016359"> </a>This function sets the <code>backColorRGB</code> field of the <a href="Window.html#1012130"><code>DrawStateType</code></a> structure to the value specified by <code>newRgbP</code>. It then sets the index field of <code>backColorRGB</code> to the 8 bit system palette entry that most closely matches the RGB components. Finally, it sets the <code>backColor</code> index field of <a href="Window.html#1012130"><code>DrawStateType</code></a> to this index value.</p>

<p><a name="1016363"> </a>This function changes the current drawing state. If necessary, use <a href="Window.html#1015604"><code>WinPushDrawState()</code></a> to preserve the current drawing state before you set this function and use <a href="Window.html#1015578"><code>WinPopDrawState()</code></a> to restore it later. </p>
<h4>
  <a name="1016370"> </a>Compatibility 
</h4>

<p><a name="1016374"> </a>Implemented only if <a href="CompatibilityApdx.html#995256">4.0 New Feature Set</a> is present.</p>
<h4>
  <a name="1016375"> </a>See Also 
</h4>

<p><a name="1016382"> </a><a href="Window.html#1016587"><code>WinSetForeColorRGB()</code></a>, <a href="Window.html#1016861"><code>WinSetTextColorRGB()</code></a></p>

<h3 class="hbH3">
  <a name="1016385"> </a>WinSetBounds Function <a href="#1012037"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="1016387"> </a>Purpose 
</h4>

<p><a name="1016388"> </a>Set the bounds of the window to display-relative coordinates.</p>
<h4>
  <a name="1016389"> </a>Declared In 
</h4>
<code>Window.h<a name="1016390"> </a></code><h4>
  <a name="1016391"> </a>Prototype 
</h4>
<pre class="proto"><a name="1016393"></a>void WinSetBounds (
   WinHandle winHandle,
   const RectangleType *rP
)
</pre>
<h4>
  <a name="1016394"> </a>Parameters 
</h4>

<dl>
<dt><a name="1016395"> </a><code>&rarr;  <i><code>winHandle</code></i></code></dt>
<dd><a name="1016396"> </a>Handle for the window for which to set the bounds.</dd>

<dt><a name="1016397"> </a><code>&rarr;  <i><code>rP</code></i></code></dt>
<dd><a name="1016398"> </a>Pointer to a rectangle to use for bounds.</dd>

</dl>
<h4>
  <a name="1016399"> </a>Returns 
</h4>

<dl>
<dt><a name="1016400"> </a><code>Returns nothing.</code></dt>
</dl>
<h4>
  <a name="1016401"> </a>Comments 
</h4>

<p><a name="1016402"> </a>A visible window cannot have its bounds modified. </p>
<h4>
  <a name="1016403"> </a>Compatibility 
</h4>

<p><a name="1016407"> </a>Implemented only if <a href="CompatibilityApdx.html#992789">2.0 New Feature Set</a> is present.</p>
<h4>
  <a name="1016408"> </a>See Also 
</h4>

<p><a name="1016412"> </a><a href="Window.html#1014219"><code>WinGetBounds()</code></a></p>

<h3 class="hbH3">
  <a name="1016415"> </a>WinSetClip Function <a href="#1012037"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="1016417"> </a>Purpose 
</h4>

<p><a name="1016418"> </a>Set the clipping rectangle of the draw window.</p>
<h4>
  <a name="1016419"> </a>Declared In 
</h4>
<code>Window.h<a name="1016420"> </a></code><h4>
  <a name="1016421"> </a>Prototype 
</h4>
<pre class="proto"><a name="1016423"></a>void WinSetClip (
   const RectangleType *rP
)
</pre>
<h4>
  <a name="1016424"> </a>Parameters 
</h4>

<dl>
<dt><a name="1016425"> </a><code>&rarr;  <i><code>rP</code></i></code></dt>
<dd><a name="1016426"> </a>Pointer to a structure holding the clipping bounds.</dd>

</dl>
<h4>
  <a name="1016427"> </a>Returns 
</h4>

<p><a name="1016428"> </a>Returns nothing.</p>
<h4>
  <a name="1016429"> </a>See Also 
</h4>

<p><a name="1016439"> </a><a href="Window.html#1012997"><code>WinClipRectangle()</code></a>, <a href="Window.html#1016415"><code>WinSetClip()</code></a>, <a href="Window.html#1014266"><code>WinGetClip()</code></a> </p>

<h3 class="hbH3">
  <a name="1074517"> </a>WinSetConstraintsSize Function <a href="#1012037"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="1074519"> </a>Purpose 
</h4>

<p><a name="1074520"> </a>Sets the maximum, preferred, and minimum size constraints for a window.</p>
<h4>
  <a name="1074521"> </a>Declared In 
</h4>
<code>Window.h <a name="1074522"> </a></code><h4>
  <a name="1074523"> </a>Prototype 
</h4>
<pre class="proto"><a name="1074524"></a>Err WinSetConstraintsSize (
   WinHandle winHandle,
   Coord minH,
   Coord prefH,
   Coord maxH,
   Coord minW,
   Coord prefW,
   Coord maxW
)
</pre>
<h4>
  <a name="1074525"> </a>Parameters 
</h4>

<dl>
<dt><a name="1074526"> </a><code>&rarr;  <i><code>winHandle</code></i></code></dt>
<dd><a name="1074527"> </a>A handle to a window. </dd>

<dt><a name="1074528"> </a><code>&rarr;  <i><code>minH</code></i></code></dt>
<dd><a name="1074529"> </a>The minimum height to which this window can be sized in standard coordinates. This value must be less than or equal to 160 pixels.</dd>

<dt><a name="1074530"> </a><code>&rarr;  <i><code>prefH</code></i></code></dt>
<dd><a name="1074531"> </a>The preferred height for this window in standard coordinates.</dd>

<dt><a name="1074532"> </a><code>&rarr;  <i><code>maxH</code></i></code></dt>
<dd><a name="1074533"> </a>The maximum height for this window in standard coordinates. </dd>

<dt><a name="1074534"> </a><code>&rarr;  <i><code>minW</code></i></code></dt>
<dd><a name="1074535"> </a>The minimum width for the window in standard coordinates.</dd>

<dt><a name="1074536"> </a><code>&rarr;  <i><code>prefW</code></i></code></dt>
<dd><a name="1074537"> </a>The preferred width for the window in standard coordinates.</dd>

<dt><a name="1074538"> </a><code>&rarr;  <i><code>maxW</code></i></code></dt>
<dd><a name="1074539"> </a>The maximum width for the window in standard coordinates. </dd>

</dl>
<h4>
  <a name="1074540"> </a>Returns 
</h4>

<p><a name="1074541"> </a>Returns one of the following error codes: </p>

<dl>
<dt><a name="1074542"> </a><code><code>errNone</code></code></dt>
<dd><a name="1074543"> </a>Success. </dd>

<dt><a name="1074545"> </a><code><code>pinErrNoSoftInputArea</code></code></dt>
<dd><a name="1074546"> </a>There is no dynamic input area on this device. </dd>

<dt><a name="1074548"> </a><code><code>pinErrInvalidParam</code></code></dt>
<dd><a name="1074549"> </a>You have specified an invalid parameter. </dd>

</dl>
<h4>
  <a name="1074550"> </a>Comments 
</h4>

<p><a name="1074552"> </a>Applications must call this function in response to a <code>frmLoadEvent</code> or <code>frmOpenEvent</code> to set the size constraints for the window. If the application does not call this function, it is assumed that both the minimum and maximum values for the window are 160 pixels by 160 pixels. </p>
<h4>
  <a name="1074554"> </a>Compatibility 
</h4>

<p><a name="1074558"> </a>Implemented only if the <a href="CompatibilityApdx.html#1026792">Pen Input Manager Feature Set</a> is present. </p>

<h3 class="hbH3">
  <a name="1074566"> </a>WinSetCoordinateSystem Function <a href="#1012037"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="1016476"> </a>Purpose 
</h4>

<p><a name="1016477"> </a>Establish the coordinate system to be used for subsequent drawing operations.</p>
<h4>
  <a name="1016478"> </a>Declared In 
</h4>
<code>Window.h<a name="1016479"> </a></code><h4>
  <a name="1016480"> </a>Prototype 
</h4>
<pre class="proto"><a name="1016481"></a>UInt16 WinSetCoordinateSystem (
   UInt16 coordSys
)
</pre>
<h4>
  <a name="1016482"> </a>Parameters 
</h4>

<dl>
<dt><a name="1016483"> </a><code>&rarr;  <i>coordSys</i></code></dt>
<dd><a name="1016484"> </a>The desired coordinate system. Supply one of the values defined in <a href="Window.html#1012925">"Window Coordinate System Constants."</a></dd>

</dl>
<h4>
  <a name="1016488"> </a>Returns 
</h4>

<p><a name="1016489"> </a>Returns the previous coordinate system value.</p>
<h4>
  <a name="1016490"> </a>Comments 
</h4>

<p><a name="1016491"> </a>This function modifies the <code>scale</code> field in the draw state (a <a href="Window.html#1012130"><code>DrawStateType</code></a> structure). As when making other modifications to a window's draw state, applications should call <a href="Window.html#1015604"><code>WinPushDrawState()</code></a> before modifying the coordinate system. To restore the coordinate system, your application can then call <a href="Window.html#1015578"><code>WinPopDrawState()</code></a>.</p>

<p><a name="1016501"> </a>To calculate the draw state <code>scale</code> field, the Window Manager divides the density of the bitmap associated with the draw window by <code>coordSys</code>. If <code>coordSys</code> is <code>kCoordinatesNative</code>, the Window Manager sets the scale field to 1.0, which to enables 1-to-1 mapping of coordinates to pixels. </p>

<p><a name="1016502"> </a>If you supply a value of <code>kCoordinatesStandard</code> for <code>coordSys</code>, subsequent drawing will use the standard coordinate system.</p>
<h4>
  <a name="1016503"> </a>Compatibility 
</h4>

<p><a name="1016507"> </a>Implemented only if the <a href="CompatibilityApdx.html#996955">High-Density Display Feature Set</a> is present.</p>
<h4>
  <a name="1016508"> </a>See Also 
</h4>

<p><a name="1016512"> </a><a href="Window.html#1014287"><code>WinGetCoordinateSystem()</code></a></p>

<h3 class="hbH3">
  <a name="1075295"> </a>WinSetDrawMode Function <a href="#1012037"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="1075297"> </a>Purpose 
</h4>

<p><a name="1075298"> </a>Set the transfer mode to use in subsequent draw operations.</p>
<h4>
  <a name="1075299"> </a>Declared In 
</h4>
<code>Window.h<a name="1075300"> </a></code><h4>
  <a name="1075301"> </a>Prototype 
</h4>
<pre class="proto"><a name="1075303"></a>WinDrawOperation WinSetDrawMode (
   WinDrawOperation newMode
)
</pre>
<h4>
  <a name="1075304"> </a>Parameters 
</h4>

<dl>
<dt><a name="1075305"> </a><code>&rarr;  <i><code>newMode</code></i></code></dt>
<dd><a name="1075309"> </a>Transfer mode to set; specify one of the <a href="Window.html#1012784"><code>WinDrawOperation</code></a> values.</dd>

</dl>
<h4>
  <a name="1075310"> </a>Returns 
</h4>

<p><a name="1075311"> </a>Returns the previous transfer mode.</p>
<h4>
  <a name="1075312"> </a>Comments 
</h4>

<p><a name="1075313"> </a>This function changes the current drawing state. If necessary, use <a href="Window.html#1015604"><code>WinPushDrawState()</code></a> to preserve the current drawing state before you set this function and use <a href="Window.html#1015578"><code>WinPopDrawState()</code></a> to restore it later. </p>
<h4>
  <a name="1075320"> </a>Compatibility 
</h4>

<p><a name="1075324"> </a>Implemented only if <a href="CompatibilityApdx.html#994671">3.5 New Feature Set</a> is present.</p>

<h3 class="hbH3">
  <a name="1016515"> </a>WinSetDrawWindow Function <a href="#1012037"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="1016517"> </a>Purpose 
</h4>

<p><a name="1016518"> </a>Set the draw window. (All drawing operations are relative to the draw window.)</p>
<h4>
  <a name="1016519"> </a>Declared In 
</h4>
<code>Window.h<a name="1016520"> </a></code><h4>
  <a name="1016521"> </a>Prototype 
</h4>
<pre class="proto"><a name="1016523"></a>WinHandle WinSetDrawWindow (
   WinHandle winHandle
)
</pre>
<h4>
  <a name="1016524"> </a>Parameters 
</h4>

<dl>
<dt><a name="1016525"> </a><code>&rarr;  <i><code>winHandle</code></i></code></dt>
<dd><a name="1016526"> </a>Handle of a window.</dd>

</dl>
<h4>
  <a name="1016527"> </a>Returns 
</h4>

<p><a name="1016528"> </a>Returns the previous draw window. </p>
<h4>
  <a name="1016529"> </a>Compatibility 
</h4>

<p><a name="1016530"> </a>OS versions before 3.5 allowed you to use <code>NULL</code> as a parameter to this function to set the draw window to the display window (or screen window). In version 3.5 and higher, this practice is discouraged. If <code>winHandle</code> is <code>NULL</code>, the debug ROM sets the draw window to <code>badDrawWindowValue</code>, and you are warned if you try to draw to it. </p>
<h4>
  <a name="1016532"> </a>See Also 
</h4>

<p><a name="1016539"> </a><a href="Window.html#1014365"><code>WinGetDrawWindow()</code></a>, <a href="Window.html#1016249"><code>WinSetActiveWindow()</code></a></p>

<h3 class="hbH3">
  <a name="1016542"> </a>WinSetForeColor Function <a href="#1012037"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="1016544"> </a>Purpose 
</h4>

<p><a name="1016545"> </a>Set the foreground color to use in subsequent draw operations.</p>
<h4>
  <a name="1016546"> </a>Declared In 
</h4>
<code>Window.h<a name="1016547"> </a></code><h4>
  <a name="1016548"> </a>Prototype 
</h4>
<pre class="proto"><a name="1016550"></a>IndexedColorType WinSetForeColor (
   IndexedColorType foreColor
)
</pre>
<h4>
  <a name="1016551"> </a>Parameters 
</h4>

<dl>
<dt><a name="1016552"> </a><code>&rarr;  <i>foreColor</i></code></dt>
<dd><a name="1016556"> </a>Color to set; specify a value of type <a href="Window.html#1012445"><code>IndexedColorType</code></a>.</dd>

</dl>
<h4>
  <a name="1016557"> </a>Returns 
</h4>

<p><a name="1016558"> </a>Returns the previous foreground color index.</p>
<h4>
  <a name="1016559"> </a>Comments 
</h4>

<p><a name="1016560"> </a>This function changes the current drawing state. If necessary, use <a href="Window.html#1015604"><code>WinPushDrawState()</code></a> to preserve the current drawing state before you set this function and use <a href="Window.html#1015578"><code>WinPopDrawState()</code></a> to restore it later. </p>

<p><a name="1016567"> </a>To set the foreground color to a predefined UI color default, use <a href="UIColor.html#996015"><code>UIColorGetTableEntryIndex()</code></a> as an input to this function. For example: </p>

<div class="CodeRule"><hr></div><pre class="CodeBlock">
curColor = WinSetForeColor
  (UIColorGetTableEntryIndex 
  (UIObjectForeground));<a name="1016571"> </a>
</pre><div class="CodeRule"><hr></div>

<h4>
  <a name="1016572"> </a>Compatibility 
</h4>

<p><a name="1016576"> </a>Implemented only if <a href="CompatibilityApdx.html#994671">3.5 New Feature Set</a> is present.</p>
<h4>
  <a name="1016577"> </a>See Also 
</h4>

<p><a name="1016584"> </a><a href="Window.html#1016284"><code>WinSetBackColor()</code></a>, <a href="Window.html#1016815"><code>WinSetTextColor()</code></a></p>

<h3 class="hbH3">
  <a name="1016587"> </a>WinSetForeColorRGB Function <a href="#1012037"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="1016589"> </a>Purpose 
</h4>

<p><a name="1016590"> </a>Set the foreground color to use in subsequent draw operations.</p>
<h4>
  <a name="1016591"> </a>Declared In 
</h4>
<code>Window.h<a name="1016592"> </a></code><h4>
  <a name="1016593"> </a>Prototype 
</h4>
<pre class="proto"><a name="1016595"></a>void WinSetForeColorRGB (
   const RGBColorType *newRgbP,
   RGBColorType *prevRgbP
)
</pre>
<h4>
  <a name="1016596"> </a>Parameters 
</h4>

<dl>
<dt><a name="1016597"> </a><code>&rarr;  <i>newRgbP</i></code></dt>
<dd><a name="1016601"> </a>Color to set; specify a value of type <a href="Bitmap.html#998266"><code>RGBColorType</code></a>.</dd>

<dt><a name="1016602"> </a><code>&larr;  <i>prevRgbP</i></code></dt>
<dd><a name="1016606"> </a>Previous color; specify a value of type <a href="Bitmap.html#998266"><code>RGBColorType</code></a>.</dd>

</dl>
<h4>
  <a name="1016607"> </a>Returns 
</h4>

<p><a name="1016608"> </a>Returns nothing.</p>
<h4>
  <a name="1016609"> </a>Comments 
</h4>

<p><a name="1016613"> </a>This function takes new and previous <a href="Bitmap.html#998266"><code>RGBColorType</code></a> arguments. It is okay to set <code>newRgbP</code> or <code>prevRgbP</code> to <code>NULL</code>. If an application only wants to get the current color, the <code>newRgbP</code> argument is set to <code>NULL</code>. If the application does not care about the previous color, <code>prevRgbP</code> can be set to <code>NULL</code>.</p>

<p><a name="1016617"> </a>This function sets the <code>foreColorRGB</code> field of the <a href="Window.html#1012130"><code>DrawStateType</code></a> structure to the value specified by <code>newRgbP</code>. It then sets the index field of <code>foreColorRGB</code> to the 8 bit system palette entry that most closely matches the RGB components. Finally, it sets the <code>foreColor</code> index field of <a href="Window.html#1012130"><code>DrawStateType</code></a> to this index value.</p>

<p><a name="1016621"> </a>This function changes the current drawing state. If necessary, use <a href="Window.html#1015604"><code>WinPushDrawState()</code></a> to preserve the current drawing state before you set this function and use <a href="Window.html#1015578"><code>WinPopDrawState()</code></a> to restore it later. </p>
<h4>
  <a name="1016628"> </a>Compatibility 
</h4>

<p><a name="1016632"> </a>Implemented only if <a href="CompatibilityApdx.html#995256">4.0 New Feature Set</a> is present.</p>
<h4>
  <a name="1016633"> </a>See Also 
</h4>

<p><a name="1016640"> </a><a href="Window.html#1016329"><code>WinSetBackColorRGB()</code></a>, <a href="Window.html#1016861"><code>WinSetTextColorRGB()</code></a></p>

<h3 class="hbH3">
  <a name="1016643"> </a>WinSetPattern Function <a href="#1012037"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="1016645"> </a>Purpose 
</h4>

<p><a name="1016647"> </a>Set the current fill pattern.</p>
<h4>
  <a name="1016648"> </a>Declared In 
</h4>
<code>Window.h<a name="1016649"> </a></code><h4>
  <a name="1016650"> </a>Prototype 
</h4>
<pre class="proto"><a name="1016652"></a>void WinSetPattern (
   const CustomPatternType *patternP
)
</pre>
<h4>
  <a name="1016653"> </a>Parameters 
</h4>

<dl>
<dt><a name="1016654"> </a><code>&rarr;  <i><code>patternP</code></i></code></dt>
<dd><a name="1016658"> </a>Pattern to set (see <a href="Window.html#1012065"><code>CustomPatternType</code></a>).</dd>

</dl>
<h4>
  <a name="1016659"> </a>Returns 
</h4>

<p><a name="1016660"> </a>Returns nothing.</p>
<h4>
  <a name="1016661"> </a>Comments 
</h4>

<p><a name="1016665"> </a>The fill pattern is used by <a href="Window.html#1014083"><code>WinFillLine()</code></a> and <a href="Window.html#1014130"><code>WinFillRectangle()</code></a>.</p>

<p><a name="1016669"> </a>This function changes the current drawing state. If necessary, use <a href="Window.html#1015604"><code>WinPushDrawState()</code></a> to preserve the current drawing state before you set this function and use <a href="Window.html#1015578"><code>WinPopDrawState()</code></a> to restore it later. </p>
<h4>
  <a name="1016676"> </a>See Also 
</h4>

<p><a name="1016680"> </a><a href="Window.html#1014471"><code>WinGetPattern()</code></a></p>

<h3 class="hbH3">
  <a name="1016683"> </a>WinSetPatternType Function <a href="#1012037"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="1016685"> </a>Purpose 
</h4>

<p><a name="1016686"> </a>Set the current pattern type.</p>
<h4>
  <a name="1016687"> </a>Declared In 
</h4>
<code>Window.h<a name="1016688"> </a></code><h4>
  <a name="1016689"> </a>Prototype 
</h4>
<pre class="proto"><a name="1016691"></a>void WinSetPatternType (
   PatternType newPattern
)
</pre>
<h4>
  <a name="1016692"> </a>Parameters 
</h4>

<dl>
<dt><a name="1016693"> </a><code>&rarr;  <i>newPattern</i></code></dt>
<dd><a name="1016697"> </a>Pattern type to set for the draw window (see <a href="Window.html#1012462"><code>PatternType</code></a>).</dd>

</dl>
<h4>
  <a name="1016698"> </a>Returns 
</h4>

<p><a name="1016699"> </a>Returns nothing.</p>
<h4>
  <a name="1016700"> </a>Comments 
</h4>

<p><a name="1016701"> </a>This function sets the <code>pattern</code> field of the drawing state to <code>newPattern</code> and sets the <code>patternData</code> field to <code>NULL</code>. To set <code>patternData</code> to a custom pattern use <a href="Window.html#1016643"><code>WinSetPattern()</code></a>.</p>

<p><a name="1016708"> </a>The fill pattern is used by <a href="Window.html#1014083"><code>WinFillLine()</code></a> and <a href="Window.html#1014130"><code>WinFillRectangle()</code></a>.</p>

<p><a name="1016712"> </a>This function changes the current drawing state. If necessary, use <a href="Window.html#1015604"><code>WinPushDrawState()</code></a> to preserve the current drawing state before you set this function and use <a href="Window.html#1015578"><code>WinPopDrawState()</code></a> to restore it later. </p>
<h4>
  <a name="1016719"> </a>Compatibility 
</h4>

<p><a name="1016723"> </a>Implemented only if <a href="CompatibilityApdx.html#994671">3.5 New Feature Set</a> is present.</p>
<h4>
  <a name="1016724"> </a>See Also 
</h4>

<p><a name="1016728"> </a><a href="Window.html#1014513"><code>WinGetPatternType()</code></a></p>

<h3 class="hbH3">
  <a name="1016731"> </a>WinSetScalingMode Function <a href="#1012037"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="1016733"> </a>Purpose 
</h4>

<p><a name="1016734"> </a>Controls the scaling of bitmaps and fonts, and the spacing between text glyphs.</p>
<h4>
  <a name="1016735"> </a>Declared In 
</h4>
<code>Window.h<a name="1016736"> </a></code><h4>
  <a name="1016737"> </a>Prototype 
</h4>
<pre class="proto"><a name="1016738"></a>UInt32 WinSetScalingMode (
   UInt32 mode
)
</pre>
<h4>
  <a name="1016739"> </a>Parameters 
</h4>

<dl>
<dt><a name="1016740"> </a><code>&rarr;  <i><code>mode</code></i></code></dt>
<dd><a name="1016741"> </a>Specifies whether bitmaps and fonts should be scaled, and whether text glyphs should be aligned on standard coordinates. See the Comments section, below, for details on how to construct the <code>mode</code> value.</dd>

</dl>
<h4>
  <a name="1016742"> </a>Returns 
</h4>

<p><a name="1016743"> </a>Returns the previous scaling mode.</p>
<h4>
  <a name="1016744"> </a>Comments 
</h4>

<p><a name="1016745"> </a>If you need to display a large, low-density bitmap&#8212;for instance, a map or a photograph&#8212;you can use <code>WinSetScalingMode</code> to draw your bitmap unscaled, allowing the user to see more of the bitmap at one time. If you want to draw more, but smaller, text on a handheld that has a high-density display (including 1.5 and double-density), you can use <code>WinSetScalingMode</code> to draw text unscaled. Finally, when the window coordinate system is set to <code>kCoordinatesOneAndAHalf</code> you can use this function to draw text without padding pixels between glyphs, resulting in more consistent kerning for text.</p>

<p><a name="1016746"> </a>On a handheld with a high-density display, if the bitmap being drawn, or the font being used, is part of a family that contains both low- and high-density members, <code>WinSetScalingMode</code> controls which member is used. If <code>kTextScalingOff</code> is set, for instance, the low-density font is used, unscaled, when drawing subsequent text.</p>

<h4 class="hcH4">
  <a name="1016748"> </a>Scaling Mode Values
</h4>

<p><a name="1016749"> </a>Depending on how bitmaps and text should be scaled, OR the appropriate constants from the following table to construct the appropriate scaling mode value.</p>


<div class="tablediv"><table cellspacing="0" class="tTable">

  <tr valign="top">
    <th><p class="tt"><a name="1016752"> </a><b>Constant</b></p>
    </th>
    <th><p class="tt"><a name="1016754"> </a><b>Value</b></p>
    </th>
    <th><p class="tt"><a name="1016756"> </a><b>Description</b></p>
    </th>
  </tr>
  <tr valign="top">
    <td><p class="tt"><a name="1016759"> </a><code>kBitmapScalingOff</code></p>
    </td>
    <td><p class="tt"><a name="1016761"> </a><code>1</code></p>
    </td>
    <td><p class="tt"><a name="1016763"> </a>Turning bitmap scaling off causes the blitter to draw the low-density bitmap family member, unscaled, when the application subsequently calls <a href="Window.html#1013322"><code>WinDrawBitmap()</code></a> or <a href="Window.html#1015004"><code>WinPaintBitmap()</code></a> (even if the bitmap family contains a bitmap who's density matches the window's). This causes your bitmaps to be drawn smaller, as if they were being viewed from a distance. The application uses the coordinates passed to <code>WinDrawBitmap</code> and <a href="Window.html#1013039"><code>WinCopyRectangle()</code></a> to determine where the unscaled low-density bitmap is placed within the larger footprint of the high-density bounds.</p>
    </td>
  </tr>
  <tr valign="top">
    <td><p class="tt"><a name="1016775"> </a><code>kTextScalingOff</code></p>
    </td>
    <td><p class="tt"><a name="1016777"> </a><code>2</code></p>
    </td>
    <td><p class="tt"><a name="1016779"> </a>Turning text scaling off causes the blitter to render text using the low-density family member of the appropriate font, unscaled, when the application subsequently draws text (even if the font family contains a font who's density matches the window's). This results in smaller-sized text being drawn on the screen.</p>
    </td>
  </tr>
  <tr valign="top">
    <td><p class="tt"><a name="1016782"> </a><code>kTextPaddingOff</code></p>
    </td>
    <td><p class="tt"><a name="1016784"> </a><code>4</code></p>
    </td>
    <td>
<p><a name="1016786"> </a>When text padding is turned off, the blitter does not insert pixels between glyphs in order to align glyphs on standard coordinates. (Text padding is on by default.) By setting the <code>kTextPaddingOff</code> bit, an application can lay out text using high density coordinates and preserve the native font's internal kerning. This unpadded mode provides the best appearance of text, but requires the application to use the high-density coordinate system.</p>
    </td>
  </tr>
</table>

</div>


<p><a name="1016791"> </a>When an application calls <a href="Window.html#1074566"><code>WinSetCoordinateSystem()</code></a> to use native coordinates for a high-density window, the operating system turns off text padding. When an application calls <code>WinSetCoordinateSystem</code> to use standard coordinates, the operating system turns text padding on. To use standard coordinates with pixel padding turned off, or to use native coordinates with pixel padding turned on, call <code>WinSetScalingMode</code> after calling <a href="Window.html#1074566"><code>WinSetCoordinateSystem()</code></a>. Note that using standard coordinates with padding off is not recommended since the Font Manager API that measures character widths will return inaccurate widths.</p>

<p><a name="1016795"> </a>The scaling mode flags are part of the window's draw state. In order to ensure that the draw state is properly restored, save that state using <a href="Window.html#1015604"><code>WinPushDrawState()</code></a> before calling functions that alter the draw state&#8212;such as <code>WinSetScalingMode</code> or <code>WinSetCoordinateSystem</code>. After drawing is completed, restore the draw state with <a href="Window.html#1015578"><code>WinPopDrawState()</code></a>.</p>

<p><a name="1016802"> </a>When an application quits, the draw state is restored to the default settings.</p>
<h4>
  <a name="1016803"> </a>Compatibility 
</h4>

<p><a name="1016807"> </a>Implemented only if the <a href="CompatibilityApdx.html#997148">1.5x Display Feature Set</a> is present.</p>
<h4>
  <a name="1016808"> </a>See Also 
</h4>

<p><a name="1016812"> </a><a href="Window.html#1014613"><code>WinGetScalingMode()</code></a></p>

<h3 class="hbH3">
  <a name="1016815"> </a>WinSetTextColor Function <a href="#1012037"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="1016817"> </a>Purpose 
</h4>

<p><a name="1016818"> </a>Set the color to use for drawing characters in subsequent draw operations.</p>
<h4>
  <a name="1016819"> </a>Declared In 
</h4>
<code>Window.h<a name="1016820"> </a></code><h4>
  <a name="1016821"> </a>Prototype 
</h4>
<pre class="proto"><a name="1016823"></a>IndexedColorType WinSetTextColor (
   IndexedColorType textColor
)
</pre>
<h4>
  <a name="1016824"> </a>Parameters 
</h4>

<dl>
<dt><a name="1016825"> </a><code>&rarr;  <i>textColor</i></code></dt>
<dd><a name="1016829"> </a>Color to set; specify a value of type <a href="Window.html#1012445"><code>IndexedColorType</code></a>.</dd>

</dl>
<h4>
  <a name="1016830"> </a>Returns 
</h4>

<p><a name="1016831"> </a>Returns the previous text color index.</p>
<h4>
  <a name="1016832"> </a>Comments 
</h4>

<p><a name="1016833"> </a>This function changes the current drawing state. If necessary, use <a href="Window.html#1015604"><code>WinPushDrawState()</code></a> to preserve the current drawing state before you set this function and use <a href="Window.html#1015578"><code>WinPopDrawState()</code></a> to restore it later. </p>

<p><a name="1016840"> </a>To set the foreground color to a predefined UI color default, use <a href="UIColor.html#996015"><code>UIColorGetTableEntryIndex()</code></a> as an input to this function. For example: </p>

<div class="CodeRule"><hr></div><pre class="CodeBlock">
curColor = WinSetTextColor<a name="1016844"> </a>
  (UIColorGetTableEntryIndex(UIFieldText));<a name="1016845"> </a>
</pre><div class="CodeRule"><hr></div>

<h4>
  <a name="1016846"> </a>Compatibility 
</h4>

<p><a name="1016850"> </a>Implemented only if <a href="CompatibilityApdx.html#994671">3.5 New Feature Set</a> is present.</p>
<h4>
  <a name="1016851"> </a>See Also 
</h4>

<p><a name="1016858"> </a><a href="Window.html#1016284"><code>WinSetBackColor()</code></a>, <a href="Window.html#1016542"><code>WinSetForeColor()</code></a></p>

<h3 class="hbH3">
  <a name="1016861"> </a>WinSetTextColorRGB Function <a href="#1012037"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="1016863"> </a>Purpose 
</h4>

<p><a name="1016864"> </a>Set the color to use for drawing characters in subsequent draw operations.</p>
<h4>
  <a name="1016865"> </a>Declared In 
</h4>
<code>Window.h<a name="1016866"> </a></code><h4>
  <a name="1016867"> </a>Prototype 
</h4>
<pre class="proto"><a name="1016869"></a>void WinSetTextColorRGB (
   const RGBColorType *newRgbP,
   RGBColorType *prevRgbP
)
</pre>
<h4>
  <a name="1016870"> </a>Parameters 
</h4>

<dl>
<dt><a name="1016871"> </a><code>&rarr;  <i>newRgbP</i></code></dt>
<dd><a name="1016875"> </a>Color to set; specify a value of type <a href="Bitmap.html#998266"><code>RGBColorType</code></a>.</dd>

<dt><a name="1016876"> </a><code>&larr;  <i>prevRgbP</i></code></dt>
<dd><a name="1016880"> </a>Previous color; specify a value of type <a href="Bitmap.html#998266"><code>RGBColorType</code></a>.</dd>

</dl>
<h4>
  <a name="1016881"> </a>Returns 
</h4>

<p><a name="1016882"> </a>Returns nothing.</p>
<h4>
  <a name="1016883"> </a>Comments 
</h4>

<p><a name="1016887"> </a>This function takes new and previous <a href="Bitmap.html#998266"><code>RGBColorType</code></a> arguments. It is okay to set <code>newRgbP</code> or <code>prevRgbP</code> to <code>NULL</code>. If an application only wants to get the current color, the <code>newRgbP</code> argument is set to <code>NULL</code>. If the application does not care about the previous color, <code>prevRgbP</code> can be set to <code>NULL</code>.</p>

<p><a name="1016891"> </a>This function sets the <code>textColorRGB</code> field of the <a href="Window.html#1012130"><code>DrawStateType</code></a> structure to the value specified by <code>newRgbP</code>. It then sets the index field of <code>textColorRGB</code> to the 8 bit system palette entry that most closely matches the RGB components. Finally, it sets the <code>textColor</code> index field of <a href="Window.html#1012130"><code>DrawStateType</code></a> to this index value.</p>

<p><a name="1016895"> </a>This function changes the current drawing state. If necessary, use <a href="Window.html#1015604"><code>WinPushDrawState()</code></a> to preserve the current drawing state before you set this function and use <a href="Window.html#1015578"><code>WinPopDrawState()</code></a> to restore it later. </p>
<h4>
  <a name="1016902"> </a>Compatibility 
</h4>

<p><a name="1016906"> </a>Implemented only if <a href="CompatibilityApdx.html#995256">4.0 New Feature Set</a> is present.</p>
<h4>
  <a name="1016907"> </a>See Also 
</h4>

<p><a name="1016914"> </a><a href="Window.html#1016329"><code>WinSetBackColorRGB()</code></a>, <a href="Window.html#1016587"><code>WinSetForeColorRGB()</code></a></p>

<h3 class="hbH3">
  <a name="1016917"> </a>WinSetUnderlineMode Function <a href="#1012037"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="1016919"> </a>Purpose 
</h4>

<p><a name="1016920"> </a>Set the graphic state to enable or disable the underlining of characters.</p>
<h4>
  <a name="1016921"> </a>Declared In 
</h4>
<code>Window.h<a name="1016922"> </a></code><h4>
  <a name="1016923"> </a>Prototype 
</h4>
<pre class="proto"><a name="1016925"></a>UnderlineModeType WinSetUnderlineMode (
   UnderlineModeType mode
)
</pre>
<h4>
  <a name="1016926"> </a>Parameters 
</h4>

<dl>
<dt><a name="1016927"> </a><code>&harr;  <i><code>mode</code></i></code></dt>
<dd><a name="1016931"> </a>New underline mode type; see <a href="Window.html#1012528"><code>UnderlineModeType</code></a><code>.</code></dd>

</dl>
<h4>
  <a name="1016932"> </a>Returns 
</h4>

<p><a name="1016933"> </a>Returns the previous underline mode type.</p>
<h4>
  <a name="1016934"> </a>Comments 
</h4>

<p><a name="1016935"> </a>This function changes the current drawing state. If necessary, use <a href="Window.html#1015604"><code>WinPushDrawState()</code></a> to preserve the current drawing state before you set this function and use <a href="Window.html#1015578"><code>WinPopDrawState()</code></a> to restore it later. </p>
<h4>
  <a name="1016942"> </a>See Also 
</h4>

<p><a name="1016946"> </a><a href="Window.html#1013424"><code>WinDrawChars()</code></a></p>

<h3 class="hbH3">
  <a name="1016949"> </a>WinUnscaleCoord Function <a href="#1012037"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="1016951"> </a>Purpose 
</h4>

<p><a name="1016952"> </a>Convert a single coordinate from the active coordinate system to the standard coordinate system.</p>
<h4>
  <a name="1016953"> </a>Declared In 
</h4>
<code>Window.h<a name="1016954"> </a></code><h4>
  <a name="1016955"> </a>Prototype 
</h4>
<pre class="proto"><a name="1016956"></a>Coord WinUnscaleCoord (
   Coord coord,
   Boolean ceiling
)
</pre>
<h4>
  <a name="1016957"> </a>Parameters 
</h4>

<dl>
<dt><a name="1016958"> </a><code>&rarr;  <i>coord</i></code></dt>
<dd><a name="1016959"> </a>A coordinate in the active coordinate system.</dd>

<dt><a name="1016960"> </a><code>&rarr;  <i>ceiling</i></code></dt>
<dd><a name="1016961"> </a>Pass <code>true</code> to round up, <code>false</code> to truncate the fractional part when scaling.</dd>

</dl>
<h4>
  <a name="1016962"> </a>Returns 
</h4>

<p><a name="1016963"> </a>Returns the coordinate scaled to the standard coordinate system.</p>
<h4>
  <a name="1016964"> </a>Comments 
</h4>

<p><a name="1016965"> </a>This function converts a coordinate by dividing it by the coordinate scaling factor, truncating or rounding the result to an integer value depending on the value of <code>ceiling</code>.</p>

<p><a name="1016966"> </a>If the active coordinate system is <code>kCoordinatesStandard</code>, the returned coordinate is equal to the supplied coordinate.</p>
<h4>
  <a name="1016967"> </a>Compatibility 
</h4>

<p><a name="1016971"> </a>Implemented only if the <a href="CompatibilityApdx.html#996955">High-Density Display Feature Set</a> is present.</p>

<p><a name="1085633"> </a>On Palm OS Cobalt, the scaling algorithm is slightly different. After the coordinate scale factor is applied, what happens next depends upon the value of <code class="par">ceiling</code>:</p>

<p><a name="1085634"> </a>if <code class="par">ceiling</code> == true {</p>

<p><a name="1085635"> </a>   use <code>lfloorf()</code> function when scaleFactor &gt; 1</p>

<p><a name="1085636"> </a>   use <code>lceilf()</code> function when scaleFactor &lt; 1</p>

<p><a name="1085637"> </a>else</p>

<p><a name="1085638"> </a>   use <code>lceilf()</code> function when scaleFactor &gt; 1</p>

<p><a name="1085639"> </a>   use <code>lfloorf()</code> function when scaleFactor &lt; 1</p>

<p><a name="1085640"> </a>}</p>

<p><a name="1085641"> </a>The objective of this algorithm is to ensure that for any <code>Coord</code>, <code>Point</code>, or <code>Rectangle</code> "x", x = unscaled(scaled(x)). </p>
<h4>
  <a name="1016972"> </a>See Also 
</h4>

<p><a name="1016979"> </a><a href="Window.html#1015751"><code>WinScaleCoord()</code></a>, <a href="Window.html#1016985"><code>WinUnscalePoint()</code></a>, <a href="Window.html#1017021"><code>WinUnscaleRectangle()</code></a></p>

<h3 class="hbH3">
  <a name="1016985"> </a>WinUnscalePoint Function <a href="#1012037"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="1016987"> </a>Purpose 
</h4>

<p><a name="1016988"> </a>Convert a point from the active coordinate system to the standard coordinate system.</p>
<h4>
  <a name="1016989"> </a>Declared In 
</h4>
<code>Window.h<a name="1016990"> </a></code><h4>
  <a name="1016991"> </a>Prototype 
</h4>
<pre class="proto"><a name="1016992"></a>void WinUnscalePoint (
   PointType *pointP,
   Boolean ceiling
)
</pre>
<h4>
  <a name="1016993"> </a>Parameters 
</h4>

<dl>
<dt><a name="1016994"> </a><code>&harr;  <i>pointP</i></code></dt>
<dd><a name="1016995"> </a>Pointer to a <code>PointType</code> structure that, before the call, should contain a point's coordinates using the active coordinate system. After this function is called the <code>PointType</code> structure contains the coordinates of the point scaled to the standard coordinate system.</dd>

<dt><a name="1016996"> </a><code>&rarr;  <i>ceiling</i></code></dt>
<dd><a name="1016997"> </a>Pass <code>true</code> to round up, <code>false</code> to truncate the fractional part when scaling.</dd>

</dl>
<h4>
  <a name="1016998"> </a>Returns 
</h4>

<p><a name="1016999"> </a>Returns nothing. The coordinates of the point indicated by <code>pointP</code> are converted to the standard coordinate system.</p>
<h4>
  <a name="1017000"> </a>Comments 
</h4>

<p><a name="1017001"> </a>This function converts a point by dividing its x and y coordinates by the coordinate scaling factor, truncating or rounding the results to integer values depending on the value of <code>ceiling</code>. For instance, the input coordinates (11, 13) are transformed to (6, 7) if the input values represent native coordinates on a handheld with a double-density screen and <code>ceiling</code> is set to <code>true</code>. If <code>ceiling</code> is set to <code>false</code>, the same input coordinates are transformed to (5, 6).</p>

<p><a name="1017002"> </a>If the active coordinate system is <code>kCoordinatesStandard</code>, <code>pointP</code> is not changed by this function.</p>
<h4>
  <a name="1017003"> </a>Compatibility 
</h4>

<p><a name="1017007"> </a>Implemented only if the <a href="CompatibilityApdx.html#996955">High-Density Display Feature Set</a> is present.</p>

<p><a name="1085689"> </a>On Palm OS Cobalt, the scaling algorithm is slightly different. After the coordinate scale factor is applied, what happens next depends upon the value of <code class="par">ceiling</code>:</p>

<p><a name="1085690"> </a>if <code class="par">ceiling</code> == true {</p>

<p><a name="1085691"> </a>   use <code>lfloorf()</code> function when scaleFactor &gt; 1</p>

<p><a name="1085692"> </a>   use <code>lceilf()</code> function when scaleFactor &lt; 1</p>

<p><a name="1085693"> </a>else</p>

<p><a name="1085694"> </a>   use <code>lceilf()</code> function when scaleFactor &gt; 1</p>

<p><a name="1085695"> </a>   use <code>lfloorf()</code> function when scaleFactor &lt; 1</p>

<p><a name="1085696"> </a>}</p>

<p><a name="1085697"> </a>The objective of this algorithm is to ensure that for any <code>Coord</code>, <code>Point</code>, or <code>Rectangle</code> "x", x = unscaled(scaled(x)). </p>
<h4>
  <a name="1017008"> </a>See Also 
</h4>

<p><a name="1017015"> </a><a href="Window.html#1015787"><code>WinScalePoint()</code></a>, <a href="Window.html#1016949"><code>WinUnscaleCoord()</code></a>, <a href="Window.html#1017021"><code>WinUnscaleRectangle()</code></a></p>

<h3 class="hbH3">
  <a name="1017021"> </a>WinUnscaleRectangle Function <a href="#1012037"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="1017023"> </a>Purpose 
</h4>

<p><a name="1017024"> </a>Convert a rectangle from the active coordinate system to the standard coordinate system.</p>
<h4>
  <a name="1017025"> </a>Declared In 
</h4>
<code>Window.h<a name="1017026"> </a></code><h4>
  <a name="1017027"> </a>Prototype 
</h4>
<pre class="proto"><a name="1017028"></a>void WinUnscaleRectangle (
   RectangleType *rectP
)
</pre>
<h4>
  <a name="1017029"> </a>Parameters 
</h4>

<dl>
<dt><a name="1017030"> </a><code>&harr;  <i>rectP</i></code></dt>
<dd><a name="1017031"> </a>Pointer to a <code>RectangleType</code> structure that, before the call, should contain a rectangle's coordinates using the active coordinate system. After this function is called the <code>RectangleType</code> structure contains the coordinates of the rectangle scaled to the standard coordinate system.</dd>

</dl>
<h4>
  <a name="1017032"> </a>Returns 
</h4>

<p><a name="1017033"> </a>Returns nothing. The coordinates of the rectangle indicated by <code>rectP </code>are converted to the standard coordinate system.</p>
<h4>
  <a name="1017034"> </a>Comments 
</h4>

<p><a name="1017035"> </a>This function scales the rectangle's <code>topLeft</code> and <code>extent</code> points by dividing their <code>x</code> and <code>y</code> coordinates by the coordinate scaling factor. All values are then truncated, but if either <code>topLeft.x</code> or <code>extent.x</code> had a fractional part, <code>extent.x</code> is incremented by 1 (and, similarly, if either <code>topLeft.y</code> or <code>extent.y</code> had a fractional part, <code>extent.y</code> is incremented by 1).</p>

<p><a name="1017036"> </a>If the active coordinate system is <code>kCoordinatesStandard</code>, <code>rectP</code> is not changed by this function.</p>
<h4>
  <a name="1017037"> </a>Compatibility 
</h4>

<p><a name="1017041"> </a>Implemented only if the <a href="CompatibilityApdx.html#996955">High-Density Display Feature Set</a> is present.</p>
<h4>
  <a name="1017042"> </a>See Also 
</h4>

<p><a name="1017049"> </a><a href="Window.html#1015823"><code>WinScaleRectangle()</code></a>, <a href="Window.html#1016949"><code>WinUnscaleCoord()</code></a>, <a href="Window.html#1016985"><code>WinUnscalePoint()</code></a></p>

<h3 class="hbH3">
  <a name="1017055"> </a>WinValidateHandle Function <a href="#1012037"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="1017057"> </a>Purpose 
</h4>

<p><a name="1017058"> </a>Return <code>true</code> if the specified handle references a valid window object.</p>
<h4>
  <a name="1017059"> </a>Declared In 
</h4>
<code>Window.h<a name="1017060"> </a></code><h4>
  <a name="1017061"> </a>Prototype 
</h4>
<pre class="proto"><a name="1017062"></a>Boolean WinValidateHandle (
   WinHandle winHandle
)
</pre>
<h4>
  <a name="1017063"> </a>Parameters 
</h4>

<dl>
<dt><a name="1017064"> </a><code>&rarr;  <i>winHandle</i></code></dt>
<dd><a name="1017065"> </a>The handle to be tested. </dd>

</dl>
<h4>
  <a name="1017066"> </a>Returns 
</h4>

<p><a name="1017067"> </a>Returns <code>true</code> if the specified handle references a non-<code>NULL</code> pointer to a window in the active window list, <code>false</code> if the handle references a window whose values are out of sync with the current system state. </p>
<h4>
  <a name="1017068"> </a>Comments 
</h4>

<p><a name="1017069"> </a>For debugging purposes only. Do not include this function in commercial applications. </p>
<h4>
  <a name="1017070"> </a>Compatibility 
</h4>

<p><a name="1017074"> </a>Implemented only if <a href="CompatibilityApdx.html#993158">3.0 New Feature Set</a> is present.</p>
<h4>
  <a name="1017075"> </a>See Also 
</h4>

<p><a name="1017082"> </a><a href="Form.html#999311"><code>FrmValidatePtr()</code></a>, <a href="Form.html#998633"><code>FrmRemoveObject()</code></a> </p>

<h3 class="hbH3">
  <a name="1017085"> </a>WinWindowToDisplayPt Function <a href="#1012037"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="1017087"> </a>Purpose 
</h4>

<p><a name="1017088"> </a>Convert a window-relative coordinate to a display-relative coordinate.</p>
<h4>
  <a name="1017089"> </a>Declared In 
</h4>
<code>Window.h<a name="1017090"> </a></code><h4>
  <a name="1017091"> </a>Prototype 
</h4>
<pre class="proto"><a name="1017093"></a>void WinWindowToDisplayPt (
   Coord *extentX,
   Coord *extentY
)
</pre>
<h4>
  <a name="1017094"> </a>Parameters 
</h4>

<dl>
<dt><a name="1017095"> </a><code>&harr;  <i><code>extentX</code></i></code></dt>
<dd><a name="1017096"> </a>Pointer to x coordinate to convert.</dd>

<dt><a name="1017097"> </a><code>&harr;  <i><code>extentY</code></i></code></dt>
<dd><a name="1017098"> </a>Pointer to y coordinate to convert.</dd>

</dl>
<h4>
  <a name="1017099"> </a>Returns 
</h4>

<p><a name="1017100"> </a>Returns nothing.</p>
<h4>
  <a name="1017101"> </a>Comments 
</h4>

<p><a name="1017102"> </a>The coordinate passed is assumed to be relative to the draw window.</p>
<h4>
  <a name="1017103"> </a>See Also 
</h4>

<p><a name="1017108"> </a><a href="Window.html#1013298"><code>WinDisplayToWindowPt()</code></a><code> </code></p>

<p><a name="1017109"> </a></p>
&nbsp;<br>
</div>
<!--END CONTENT-->

</td>
<td width="5">&nbsp;&nbsp;</td>
</tr>

</table>

<!-- BEGIN FOOTER -->
<table width="100%" border="0" cellspacing="0" cellpadding="0">
<tr>
<td width="7" rowspan="2"><img name="index_x" src="images/shim.gif" width="7" height="33" border="0" alt=""></td>
<td align="left"><img name="dashes" src="images/dashes.gif" width="744" height="3" border="0" alt=""></td>
<td width="10" rowspan="2"><img name="index_x" src="images/shim.gif" width="10" height="33" border="0" alt=""></td>
</tr>
<tr>
<td align="center">
<p class="footer">
Copyright © 1996-2004, PalmSource, Inc. and its affiliates.  All rights reserved. <br>
<a href="http://www.palmsource.com/contact/">Write Us</a> | <a href="http://www.palmos.com/dev/training/">Training</a> | <a href="http://www.palmos.com/dev/support/kb/">Knowledge Base</a> | <a href="Reference_Front.html" target="_blank">Legal</a></p>
<br>
<!--BEGIN BOOK NAVIGATION-->
<p class="nav">
<A href="http://www.palmos.com/dev/support/docs/">Documentation</a>&nbsp;&nbsp;|&nbsp;&nbsp;
<a href="ReferenceTOC.html">Table of Contents</a>&nbsp;&nbsp;
             |&nbsp;&nbsp;<a href="VFSMgr.html">&lt;&nbsp;Previous</a>&nbsp;&nbsp;
             |&nbsp;&nbsp;<a href="MiscSys.html">Next&nbsp;&gt;</a>&nbsp;&nbsp;
             |&nbsp;&nbsp;<a href="ReferenceIX.html">Index</a>
</p>
</td>
</tr>
</table>
<!-- END FOOTER -->

</body>
</html>