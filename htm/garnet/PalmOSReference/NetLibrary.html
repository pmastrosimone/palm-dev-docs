<html>
<head>
<title>(68K) Net Library | Palm OS&#174; Programmer's  API Reference</title> 
<link href="psi_devpubs.css" rel="stylesheet" type="text/css">

<!-- BEGIN META DATA -->
<meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
<META NAME="PSITEMPLATE" CONTENT="1006-007 PalmSource_HTML_2003 20041101">
<META NAME="GENERATOR" CONTENT="Quadralay WebWorks AutoMap 2003 for FrameMaker 8.0.6.2138">
<META NAME="LASTUPDATED" CONTENT="11/22/04 10:46:56">
<!-- END META DATA -->
</head>

<body bgcolor="#ffffff" text="#000000" leftmargin="0" topmargin="0" marginwidth="0" marginheight="0">
<a name="1083561"></a>

<!-- BEGIN TOPNAV -->
<table width="100%" border="0" cellspacing="0" cellpadding="0">
<tr>
<td><img src="images/shim.gif" width="7" height="75" border="0" alt=""></td>
<td align="left"><table border="0" cellpadding="0" cellspacing="0" width="744">
<tr>
<td><img name="index_r2_c1" src="images/shim.gif" width="25" height="75" border="0" alt=""></td>
<td valign="top"><table border="0" cellpadding="0" cellspacing="0" width="96">
<tr>
<td><img name="index_r2_c4" src="images/shim.gif" width="96" height="15" border="0" alt=""></td>
</tr>
<tr>
<td><a href="http://www.palmsource.com/"><img name="ps_logo" src="images/ps_logo.gif" width="96" height="54" border="0" alt=""></a></td>
</tr>

</table>
</td>

<td><table border="0" cellpadding="0" cellspacing="0" width="30">
<td><img name="index_x" src="images/shim.gif" width="30" height="75" border="0" alt=""></td>
</table></td>

<!--BEGIN MASTHEAD-->
<td><table border="0" cellpadding="0" cellspacing="0" width="96">
<tr>
<td><img name="index_x" src="images/shim.gif" width="615" height="5" border="0" alt=""></td>
</tr>
<tr>
<td>
<!--BEGIN BOOK NAVIGATION-->
<span class="nav">
<A href="http://www.palmos.com/dev/support/docs/">Documentation</a>&nbsp;&nbsp;|&nbsp;&nbsp;
<a href="ReferenceTOC.html">Table of Contents</a>&nbsp;&nbsp;
             |&nbsp;&nbsp;<a href="ModemManager.html">&lt;&nbsp;Previous</a>&nbsp;&nbsp;
             |&nbsp;&nbsp;<a href="NetworkUtils.html">Next&nbsp;&gt;</a>&nbsp;&nbsp;
             |&nbsp;&nbsp;<a href="ReferenceIX.html">Index</a>
</span>
<!--END BOOK NAVIGATION-->
</tr>
<tr>
<td>
<!--BEGIN PAGE TITLE-->
<h2 class="PageTitle">66 &nbsp;&nbsp;
Net Library</h2></td>
<!--END PAGE TITLE-->
</tr>
<tr>
<td>
<!--BEGIN BOOK TITLE-->
<p class="BookTitle">Palm OS&#174; Programmer's  API Reference</p>
<p class="SubTitle">Palm OS&#174; 68K SDK </p>
<!--END BOOK TITLE-->
</td>
</tr>
<tr>
<td><img name="index_x" src="images/shim.gif" width="615" height="5" border="0" alt=""></td>
</tr>
</table>
</td>
<!--END MASTHEAD-->
</tr>
</table>
<img name="dashes" src="images/dashes.gif" width="744" height="3" border="0" alt=""></td>
</tr>
</table>
<!-- END TOPNAV -->

<table width="100%" border="0" cellspacing="0" cellpadding="0">
<tr>
<td valign="top" width="5"><img name="index_x" src="images/shim.gif" width="5" height="33" border="0" alt=""></td>

<!--BEGIN SIDETOC-->
<td valign="top" width="175">
<div id="sidetoc" valign="bottom">
<h1 class="SideTOC1-PartTab"><a href="PartIII.html">Part III: Communications</a> </h1>
<h1 class="SideTOC1"><a href="NetLibrary.html">66  Net Library</a></h1>

   <h2 class="SideTOC2"><a href="#1083585">
   Net Library Data Structures</a></h2>

      <h3 class="SideTOC3"><a href="#1083588">
      NetConfigNameType</a></h3>

      <h3 class="SideTOC3"><a href="#1083608">
      NetHostInfoBufType</a></h3>

      <h3 class="SideTOC3"><a href="#1083653">
      NetHostInfoType</a></h3>

      <h3 class="SideTOC3"><a href="#1083695">
      NetServInfoBufType</a></h3>

      <h3 class="SideTOC3"><a href="#1083741">
      NetServInfoType</a></h3>

      <h3 class="SideTOC3"><a href="#1083775">
      NetSocketAddrEnum</a></h3>

      <h3 class="SideTOC3"><a href="#1083798">
      NetSocketAddrINType</a></h3>

      <h3 class="SideTOC3"><a href="#1083827">
      NetSocketAddrRawType</a></h3>

      <h3 class="SideTOC3"><a href="#1083857">
      NetSocketAddrType</a></h3>

      <h3 class="SideTOC3"><a href="#1144345">
      NetSocketNoticeType</a></h3>

      <h3 class="SideTOC3"><a href="#1152367">
      NetSocketRef</a></h3>

      <h3 class="SideTOC3"><a href="#1083882">
      NetSocketTypeEnum</a></h3>

      <h3 class="SideTOC3"><a href="#1160728">
      NoticeTypeEnum</a></h3>

   <h2 class="SideTOC2"><a href="#1153440">
   Net Library Constants</a></h2>

      <h3 class="SideTOC3"><a href="#1153429">
      Configuration Aliases</a></h3>

      <h3 class="SideTOC3"><a href="#1083964">
      I/O Flags</a></h3>

      <h3 class="SideTOC3"><a href="#1154370">
      Socket Notice Trigger Conditions</a></h3>

      <h3 class="SideTOC3"><a href="#1154363">
      Tracing Bits</a></h3>

   <h2 class="SideTOC2"><a href="#1084069">
   Net Library Functions</a></h2>

      <h3 class="SideTOC3"><a href="#1084072">
      NetHToNL</a></h3>

      <h3 class="SideTOC3"><a href="#1084101">
      NetHToNS</a></h3>

      <h3 class="SideTOC3"><a href="#1084129">
      NetLibAddrAToIN</a></h3>

      <h3 class="SideTOC3"><a href="#1084155">
      NetLibAddrINToA</a></h3>

      <h3 class="SideTOC3"><a href="#1084184">
      NetLibClose</a></h3>

      <h3 class="SideTOC3"><a href="#1084231">
      NetLibConfigAliasGet</a></h3>

      <h3 class="SideTOC3"><a href="#1084278">
      NetLibConfigAliasSet</a></h3>

      <h3 class="SideTOC3"><a href="#1084390">
      NetLibConfigDelete</a></h3>

      <h3 class="SideTOC3"><a href="#1084430">
      NetLibConfigIndexFromName</a></h3>

      <h3 class="SideTOC3"><a href="#1084476">
      NetLibConfigList</a></h3>

      <h3 class="SideTOC3"><a href="#1084521">
      NetLibConfigMakeActive</a></h3>

      <h3 class="SideTOC3"><a href="#1084572">
      NetLibConfigRename</a></h3>

      <h3 class="SideTOC3"><a href="#1084615">
      NetLibConfigSaveAs</a></h3>

      <h3 class="SideTOC3"><a href="#1084667">
      NetLibConnectionRefresh</a></h3>

      <h3 class="SideTOC3"><a href="#1084703">
      NetLibDmReceive</a></h3>

      <h3 class="SideTOC3"><a href="#1084768">
      NetLibFinishCloseWait</a></h3>

      <h3 class="SideTOC3"><a href="#1084795">
      NetLibGetHostByAddr</a></h3>

      <h3 class="SideTOC3"><a href="#1084889">
      NetLibGetHostByName</a></h3>

      <h3 class="SideTOC3"><a href="#1084979">
      NetLibGetMailExchangeByName</a></h3>

      <h3 class="SideTOC3"><a href="#1085067">
      NetLibGetServByName</a></h3>

      <h3 class="SideTOC3"><a href="#1085120">
      NetLibIFAttach</a></h3>

      <h3 class="SideTOC3"><a href="#1085167">
      NetLibIFDetach</a></h3>

      <h3 class="SideTOC3"><a href="#1085208">
      NetLibIFDown</a></h3>

      <h3 class="SideTOC3"><a href="#1085260">
      NetLibIFGet</a></h3>

      <h3 class="SideTOC3"><a href="#1085312">
      NetLibIFSettingGet</a></h3>

      <h3 class="SideTOC3"><a href="#1085735">
      NetLibIFSettingSet</a></h3>

      <h3 class="SideTOC3"><a href="#1085807">
      NetLibIFUp</a></h3>

      <h3 class="SideTOC3"><a href="#1085869">
      NetLibMaster</a></h3>

      <h3 class="SideTOC3"><a href="#1086179">
      NetLibOpen</a></h3>

      <h3 class="SideTOC3"><a href="#1086243">
      NetLibOpenConfig</a></h3>

      <h3 class="SideTOC3"><a href="#1086342">
      NetLibOpenCount</a></h3>

      <h3 class="SideTOC3"><a href="#1086371">
      NetLibReceive</a></h3>

      <h3 class="SideTOC3"><a href="#1086458">
      NetLibReceivePB</a></h3>

      <h3 class="SideTOC3"><a href="#1086574">
      NetLibSelect</a></h3>

      <h3 class="SideTOC3"><a href="#1086663">
      NetLibSend</a></h3>

      <h3 class="SideTOC3"><a href="#1086775">
      NetLibSendPB</a></h3>

      <h3 class="SideTOC3"><a href="#1086876">
      NetLibSettingGet</a></h3>

      <h3 class="SideTOC3"><a href="#1087056">
      NetLibSettingSet</a></h3>

      <h3 class="SideTOC3"><a href="#1087121">
      NetLibSocketAccept</a></h3>

      <h3 class="SideTOC3"><a href="#1087195">
      NetLibSocketAddr</a></h3>

      <h3 class="SideTOC3"><a href="#1087258">
      NetLibSocketBind</a></h3>

      <h3 class="SideTOC3"><a href="#1087334">
      NetLibSocketClose</a></h3>

      <h3 class="SideTOC3"><a href="#1087391">
      NetLibSocketConnect</a></h3>

      <h3 class="SideTOC3"><a href="#1087462">
      NetLibSocketListen</a></h3>

      <h3 class="SideTOC3"><a href="#1087549">
      NetLibSocketOpen</a></h3>

      <h3 class="SideTOC3"><a href="#1087652">
      NetLibSocketOptionGet</a></h3>

      <h3 class="SideTOC3"><a href="#1087723">
      NetLibSocketOptionSet</a></h3>

      <h3 class="SideTOC3"><a href="#1088094">
      NetLibSocketShutdown</a></h3>

      <h3 class="SideTOC3"><a href="#1088147">
      NetLibTracePrintF</a></h3>

      <h3 class="SideTOC3"><a href="#1088190">
      NetLibTracePutS</a></h3>

      <h3 class="SideTOC3"><a href="#1088228">
      NetNToHL</a></h3>

      <h3 class="SideTOC3"><a href="#1088259">
      NetNToHS</a></h3>

</div>
</td>

<td width="5">&nbsp;&nbsp;</td>
<td width="2" background="images/index_r8_c10.gif"><img src="images/shim.gif" width="2" height="75" border="0" alt=""></td>
<td width="5">&nbsp;&nbsp;</td>

<!--END SIDETOC-->

<td valign="top">

<!--BEGIN CONTENT-->
<div id="content" valign="bottom">
<p><a name="1083562"> </a>This chapter describes the API available in the net library and its Berkeley sockets equivalents. The header file <code>NetMgr.h</code> declares the net library API. The chapter covers:</p>
<ul type="disc">
  <li><a name="1083567"> </a><a href="NetLibrary.html#1083585">Net Library Data Structures</a>
  <li><a name="1083571"> </a><a href="NetLibrary.html#1153440">Net Library Constants</a>
  <li><a name="1083575"> </a><a href="NetLibrary.html#1084069">Net Library Functions</a>
</ul>

<p><a name="1083578"> </a>For more information on the net library, see the chapter <a href="../PalmOSCompanion2/NetworkCommunication.html#1021267">"Network Communication"</a> in the <i>Palm OS Programmer's Companion</i>, vol. II, <i>Communications</i>. </p>

<h2 class="haH2">
  <a name="1083585"> </a>Net Library Data Structures <a href="#1083561"><span class="nav">^TOP^</span></a>
</h2>


<h3 class="hbH3">
  <a name="1083588"> </a>NetConfigNameType Struct <a href="#1083561"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="1083590"> </a>Purpose 
</h4>

<p><a name="1083594"> </a>The <code>NetConfigNameType</code> structure defines a configuration name. A configuration is a specific set of values for the net library settings. Typically, users set up configurations and assign names to them using the Network preferences panel. </p>
<h4>
  <a name="1083595"> </a>Prototype 
</h4>
<pre class="proto"><a name="1083596"></a>typedef struct {
  Char name[netConfigNameSize];
} NetConfigNameType, NetConfigNamePtr;
</pre>

<p><a name="1083600"> </a><code>name</code> is the configuration's name. The <code>netConfigNameSize</code> constant is currently defined to be 32. </p>
<h4>
  <a name="1083601"> </a>Compatibility 
</h4>

<p><a name="1083605"> </a>Supported only if <a href="CompatibilityApdx.html#993903">3.2 New Feature Set</a> is present.</p>

<h3 class="hbH3">
  <a name="1083608"> </a>NetHostInfoBufType Struct <a href="#1083561"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="1083610"> </a>Purpose 
</h4>

<p><a name="1083612"> </a>The <code>NetHostInfoBufType</code> struct contains information about a host. The <a href="NetLibrary.html#1083653"><code>NetHostInfoType</code></a> struct, which maps to the <code>hostent</code> struct, points to fields in this struct for its information. </p>
<h4>
  <a name="1083616"> </a>Prototype 
</h4>
<pre class="proto"><a name="1083617"></a>typedef struct {
  NetHostInfoType  hostInfo;
  Char name[netDNSMaxDomainName+1];
  Char *aliasList[netDNSMaxAliases+1];
  Char aliases[netDNSMaxAliases] 
[netDNSMaxAliases+1];
  NetIPAddr *addressList[netDNSMaxAddresses];
  NetIPAddr address[netDNSMaxAddresses];
} NetHostInfoBufType, *NetHostInfoBufPtr;
</pre>
<h4>
  <a name="1165116"> </a>Fields 
</h4>

<dl>
<dt><a name="1083630"> </a><code><code>hostInfo</code> </code></dt>
<dd><a name="1083635"> </a>A <a href="NetLibrary.html#1083653"><code>NetHostInfoType</code></a> struct, which maps to the Berkeley UNIX sockets <code>hostent</code> structure. </dd>

<dt><a name="1083637"> </a><code><code>name</code> </code></dt>
<dd><a name="1083639"> </a>Official host name.</dd>

<dt><a name="1083641"> </a><code><code>aliasList</code></code></dt>
<dt><a name="1083642"> </a><code><code>aliases</code> </code></dt>
<dd><a name="1083644"> </a>An array of aliases for the host name.</dd>

<dt><a name="1083646"> </a><code><code>addressList </code></code></dt>
<dt><a name="1083647"> </a><code><code>address</code> </code></dt>
<dd><a name="1083649"> </a>An array of pointers to 32-bit IP addresses in host byte order.</dd>

</dl>

<h3 class="hbH3">
  <a name="1083653"> </a>NetHostInfoType Struct <a href="#1083561"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="1083655"> </a>Purpose 
</h4>

<p><a name="1083657"> </a>The <code>NetHostInfoType</code> structure maps to the Berkeley UNIX sockets <code>hostent</code> structure. It is defined as follows:</p>
<h4>
  <a name="1083659"> </a>Prototype 
</h4>
<pre class="proto"><a name="1083660"></a>typedef struct {
  Char *nameP;
  Char **nameAliasesP;
  UInt16 addrType;
  UInt16 addrLen;
  UInt8 **addrListP;
} NetHostInfoType, *NetHostInfoPtr;
</pre>
<h4>
  <a name="1165173"> </a>Fields 
</h4>

<dl>
<dt><a name="1083670"> </a><code><code>nameP</code> </code></dt>
<dd><a name="1083672"> </a>Official host name.</dd>

<dt><a name="1083674"> </a><code><code>nameAliasesP</code> </code></dt>
<dd><a name="1083676"> </a>An array of aliases for the host name.</dd>

<dt><a name="1083678"> </a><code><code>addrType</code> </code></dt>
<dd><a name="1083680"> </a>The type of the return addresses. See <a href="NetLibrary.html#1083775"><code>NetSocketAddrEnum</code></a>.</dd>

<dt><a name="1083685"> </a><code><code>addrLen</code> </code></dt>
<dd><a name="1083687"> </a>The length in bytes of the return addresses.</dd>

<dt><a name="1083689"> </a><code><code>addrListP</code> </code></dt>
<dd><a name="1083691"> </a>An array of pointers to addresses in host byte order.</dd>

</dl>

<h3 class="hbH3">
  <a name="1083695"> </a>NetServInfoBufType Struct <a href="#1083561"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="1083697"> </a>Purpose 
</h4>

<p><a name="1083699"> </a>The <code>NetServInfoBufType</code> struct contains information about a service. The <a href="NetLibrary.html#1083741"><code>NetServInfoType</code></a> struct, which maps to the <code>servent</code> struct, points to fields in this struct for much of its information. </p>
<h4>
  <a name="1083703"> </a>Prototype 
</h4>
<pre class="proto"><a name="1083704"></a>struct {
  NetServInfoType servInfo;
  Char name[netServMaxName+1];
  Char *aliasList[netServMaxAliases+1];
  Char aliases[netServMaxAliases] 
[netServMaxName];
  Char protoName[netProtoMaxName+1];
  UInt8 reserved;
} NetServInfoBufType, *NetServInfoBufPtr;
</pre>
<h4>
  <a name="1165249"> </a>Fields 
</h4>

<dl>
<dt><a name="1083715"> </a><code><code>servInfo</code> </code></dt>
<dd><a name="1083720"> </a>A <a href="NetLibrary.html#1083741"><code>NetServInfoType</code></a> struct, which maps to the Berkeley UNIX sockets <code>servent</code> structure. </dd>

<dt><a name="1083722"> </a><code><code>name</code></code></dt>
<dd><a name="1083724"> </a>Official name of the service</dd>

<dt><a name="1083726"> </a><code><code>aliasList</code></code></dt>
<dt><a name="1083727"> </a><code><code>aliases</code> </code></dt>
<dd><a name="1083729"> </a>Array of aliases for the service name.</dd>

<dt><a name="1083731"> </a><code><code>protoName</code> </code></dt>
<dd><a name="1083733"> </a>Name of the protocol to use. </dd>

<dt><a name="1083735"> </a><code><code>reserved</code></code></dt>
<dd><a name="1083737"> </a>Reserved for future use.</dd>

</dl>

<h3 class="hbH3">
  <a name="1083741"> </a>NetServInfoType Struct <a href="#1083561"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="1083743"> </a>Purpose 
</h4>

<p><a name="1083746"> </a>The <code>NetServInfoType</code> structure maps to the <code>servent</code> structure in Berkeley UNIX sockets API. It contains information about a service.</p>
<h4>
  <a name="1083747"> </a>Prototype 
</h4>
<pre class="proto"><a name="1083748"></a>struct {
  Char *nameP;
  Char **nameAliasesP;
  UInt16 port;
  Char *protoP;
} NetServInfoType, *NetServInfoPtr;
</pre>
<h4>
  <a name="1166114"> </a>Fields 
</h4>

<dl>
<dt><a name="1083757"> </a><code><code>nameP</code> </code></dt>
<dd><a name="1083759"> </a>Official name of the service</dd>

<dt><a name="1083761"> </a><code><code>nameAliasesP</code> </code></dt>
<dd><a name="1083763"> </a>Array of aliases for the service name.</dd>

<dt><a name="1083765"> </a><code><code>port</code> </code></dt>
<dd><a name="1083767"> </a>Port number for the service.</dd>

<dt><a name="1083769"> </a><code><code>protoP</code> </code></dt>
<dd><a name="1083771"> </a>Name of the protocol to use. </dd>

</dl>

<h3 class="hbH3">
  <a name="1083775"> </a>NetSocketAddrEnum Enum <a href="#1083561"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="1083777"> </a>Purpose 
</h4>

<p><a name="1083779"> </a>The <code>NetSocketAddrEnum</code> enum specifies the address types supported by the net library. </p>
<h4>
  <a name="1083780"> </a>Prototype 
</h4>
<pre class="proto"><a name="1083781"></a>typedef enum {
  netSocketAddrRaw = 0,
  netSocketAddrINET = 2
} NetSocketAddrEnum
</pre>
<h4>
  <a name="1167161"> </a>Fields 
</h4>

<dl>
<dt><a name="1083788"> </a><code><code>netSocketAddrRaw</code> </code></dt>
<dd><a name="1083790"> </a>Raw address. Supported in Palm OS<sup>&#174;</sup> version 3.0 and higher.</dd>

<dt><a name="1083792"> </a><code><code>netSocketAddrINET</code> </code></dt>
<dd><a name="1083794"> </a>IP address.</dd>

</dl>

<h3 class="hbH3">
  <a name="1083798"> </a>NetSocketAddrINType Struct <a href="#1083561"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="1083800"> </a>Purpose 
</h4>

<p><a name="1083802"> </a>The <code>NetSocketAddrINType</code> struct holds an internet socket address, that is, a socket that uses one of the internet protocols. This structure directly maps to the BSD UNIX <code>sockaddr_in</code> structure. </p>
<h4>
  <a name="1083804"> </a>Prototype 
</h4>
<pre class="proto"><a name="1083805"></a>typedef struct NetSocketAddrINType {
  Int16 family;
  UInt16  port;
  NetIPAddr addr;
} NetSocketAddrINType;
</pre>
<h4>
  <a name="1167271"> </a>Fields 
</h4>

<dl>
<dt><a name="1083813"> </a><code><code>family</code> </code></dt>
<dd><a name="1083815"> </a>Address family in host byte order. This is either <code>netSocketAddrINET</code> or <code>netSocketAddrRaw</code>. </dd>

<dt><a name="1083817"> </a><code><code>port</code> </code></dt>
<dd><a name="1083819"> </a>The port in network byte order.</dd>

<dt><a name="1083821"> </a><code><code>addr</code> </code></dt>
<dd><a name="1083823"> </a>The IP address in network byte order. </dd>

</dl>

<h3 class="hbH3">
  <a name="1083827"> </a>NetSocketAddrRawType Struct <a href="#1083561"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="1083829"> </a>Purpose 
</h4>

<p><a name="1083831"> </a>The <code>NetSocketAddrRawType</code> structure holds a raw socket address. </p>
<h4>
  <a name="1083832"> </a>Prototype 
</h4>
<pre class="proto"><a name="1083833"></a>typedef struct NetSocketAddrRawType {
  Int16 family;
  UInt16 ifInstance;
  UInt32 ifCreator;
} NetSocketAddrRawType;
</pre>
<h4>
  <a name="1167410"> </a>Fields 
</h4>

<dl>
<dt><a name="1083841"> </a><code><code>family</code> </code></dt>
<dd><a name="1083843"> </a>Address family in host byte order. This is either <code>netSocketAddrINET</code> or <code>netSocketAddrRaw</code>. </dd>

<dt><a name="1083845"> </a><code><code>ifInstance</code> </code></dt>
<dd><a name="1083847"> </a>The instance number of the interface that the socket uses to send and receive data.</dd>

<dt><a name="1083849"> </a><code><code>ifCreator</code> </code></dt>
<dd><a name="1083851"> </a>The creator of the interface that the socket uses.</dd>

</dl>
<h4>
  <a name="1083853"> </a>Compatibility 
</h4>

<p><a name="1083854"> </a>Raw sockets are supported in Palm OS version 3.0 and higher.</p>

<h3 class="hbH3">
  <a name="1083857"> </a>NetSocketAddrType Struct <a href="#1083561"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="1083859"> </a>Purpose 
</h4>

<p><a name="1083861"> </a>The <code>NetSocketAddrType</code> structure holds a generic socket address. This struct can hold any type of address including Internet addresses. It directly maps to the BSD UNIX <code>sockaddr</code> structure. </p>

<p><a name="1083863"> </a>Note that this structure is the same size as <code>NetSocketAddrINType</code> and <code>NetSocketAddrRawType</code>. This means that one of those two structures can be used for parameters declared to be <code>NetSocketAddrType</code>. </p>
<h4>
  <a name="1083864"> </a>Prototype 
</h4>
<pre class="proto"><a name="1083865"></a>typedef struct NetSocketAddrType {
  Int16 family;
  UInt8 data[14];
} NetSocketAddrType;
</pre>

<h3 class="hbH3">
  <a name="1144345"> </a>NetSocketNoticeType Struct <a href="#1083561"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="1144347"> </a>Purpose 
</h4>

<p><a name="1144349"> </a>The <code>NetSocketNoticeType</code> structure specifies the socket state changes that your application wishes to register for and the means that Net Library should use to communicate with your application&#8212;for example, by notification. </p>

<p><a name="1152706"> </a>When registering your application for a socket notice, call <a href="NetLibrary.html#1087723"><code>NetLibSocketOptionSet()</code></a> and pass in a pointer to a <code>NetSocketNoticeType</code> structure.</p>
<h4>
  <a name="1144352"> </a>Prototype 
</h4>
<pre class="proto"><a name="1150357"></a>typedef struct NetSocketNoticeType {
  Int32 condition;
  NoticeTypeEnum type;
  union{
    struct {
      UInt32 notifyType;
    }notify
    ...
  } notice;
} NetSocketNoticeType;
</pre>
<h4>
  <a name="1164977"> </a>Fields 
</h4>

<dl>
<dt><a name="1152345"> </a><code>condition </code></dt>
<dd><a name="1152347"> </a>Bitifield specifying what socket activity you wish to receive notices for&#8212;closing a socket, socket receiving TCP data, etc. Constants for the bits in this field are defined in <code>NetMgr.h. See </code><a href="NetLibrary.html#1154370">"Socket Notice Trigger Conditions."</a></dd>

<dt><a name="1152349"> </a><code><code>type </code></code></dt>
<dd><a name="1152351"> </a>How net library should communicate with your application. For instance, <code>netSocketNoticeNotify</code> indicates a socket notice that uses notifications (This is the only socket notice type supported in Palm OS Garnet version 5.4). Socket notice type values are defined in <a href="NetLibrary.html#1160728"><code>NoticeTypeEnum</code></a>.</dd>

<dt><a name="1152353"> </a><code><code>notice </code></code></dt>
<dd><a name="1152355"> </a>Union that contains a structure describing the socket notice. The structure is appropriate to the kind of socket notice, as specified in the <code>type</code> field.</dd>

<dt><a name="1152357"> </a><code><code>notify</code></code></dt>
<dd><a name="1152359"> </a>Structure describing the notification that the socket notice is sending to your application.</dd>

<dt><a name="1152361"> </a><code><code>notifyType</code></code></dt>
<dd><a name="1152363"> </a>Socket notification constant that you defined for your application. It must be unique.</dd>

</dl>
<h4>
  <a name="1159425"> </a>Compatibility 
</h4>

<p><a name="1159426"> </a>Implemented if <a href="CompatibilityApdx.html#1024524">5.4 New Feature Set</a> is present.</p>

<h3 class="hbH3">
  <a name="1152367"> </a>NetSocketRef Typedef <a href="#1083561"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="1083873"> </a>Purpose 
</h4>

<p><a name="1083874"> </a>The <code>NetSocketRef</code> defines a socket descriptor. The socket descriptor is created and returned by <a href="NetLibrary.html#1087549"><code>NetLibSocketOpen()</code></a>. It is used in any function that requires access to a socket. </p>
<h4>
  <a name="1083878"> </a>Prototype 
</h4>
<pre class="proto"><a name="1083879"></a>typedef Int16 NetSocketRef
</pre>

<h3 class="hbH3">
  <a name="1083882"> </a>NetSocketTypeEnum Enum <a href="#1083561"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="1083884"> </a>Purpose 
</h4>

<p><a name="1083886"> </a>The <code>NetSocketTypeEnum</code> enum specifies the available socket types. </p>
<h4>
  <a name="1083887"> </a>Prototype 
</h4>
<pre class="proto"><a name="1083888"></a>typedef enum {
  netSocketTypeStream=1,
  netSocketTypeDatagram=2,
  netSocketTypeRaw=3,
  netSocketTypeReliableMsg=4
} NetSocketTypeEnum
</pre>
<h4>
  <a name="1167576"> </a>Constants 
</h4>



<dl>
<dt><a name="1160758"> </a><code><code>netSocketTypeStream</code> </code></dt>
<dd><a name="1160760"> </a>Streams protocol over wireline.</dd>

<dt><a name="1160762"> </a><code><code>netSocketTypeDatagram</code> </code></dt>
<dd><a name="1160764"> </a>UDP protocol.</dd>

<dt><a name="1160766"> </a><code><code>netSocketTypeRaw</code> </code></dt>
<dd><a name="1160768"> </a>Raw mode. </dd>

</dl>
<h4>
  <a name="1160744"> </a>Compatibility 
</h4>

<p><a name="1160748"> </a>Implemented if <a href="CompatibilityApdx.html#1024524">5.4 New Feature Set</a> is present.</p>





<h3 class="hbH3">
  <a name="1160728"> </a>NoticeTypeEnum Enum <a href="#1083561"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="1153471"> </a>Purpose 
</h4>

<p><a name="1154333"> </a>The <code>NoticeTypeEnum</code> specifies the kind of socket notice that an application is registering for. It indicates by what means a change in socket state should be communicated to the application&#8212;for instance, by notifications. Use a <code>NoticeTypeEnum</code> value for the <code>type</code> field of <a href="NetLibrary.html#1144345"><code>NetSocketNoticeType</code></a>.</p>
<h4>
  <a name="1154334"> </a>Prototype 	
</h4>
<pre class="proto"><a name="1159560"></a>typedef enum {
  netSocketNoticeNotify=1,
  netSocketNoticeEvent
  netSocketNoticeMailbox
  netSocketNoticeCallback
  netSocketNoticeWake
} NoticeTypeEnum;
</pre>
<h4>
  <a name="1167630"> </a>Constants 
</h4>

<dl>
<dt><a name="1154239"> </a><code><code>netSocketNoticeNotify</code> </code></dt>
<dd><a name="1154241"> </a>Indicates that socket notice should use notifications to communicate with the application.</dd>

<dt><a name="1159700"> </a><code><code>netSocketNoticeEvent</code></code></dt>
<dd><a name="1159702"> </a>Not supported in Palm OS Garnet version 5.4.</dd>

<dt><a name="1159696"> </a><code><code>netSocketNoticeMailbox</code></code></dt>
<dd><a name="1159698"> </a>Not supported in Palm OS Garnet version 5.4.</dd>

<dt><a name="1159692"> </a><code><code>netSocketNoticeCallback</code></code></dt>
<dd><a name="1159694"> </a>Not supported in Palm OS Garnet version 5.4.</dd>

<dt><a name="1159688"> </a><code><code>netSocketNoticeWake</code></code></dt>
<dd><a name="1159690"> </a>Not supported in Palm OS Garnet version 5.4.</dd>

</dl>
<h4>
  <a name="1160939"> </a>Compatibility 
</h4>

<p><a name="1160943"> </a>Implemented if <a href="CompatibilityApdx.html#1024524">5.4 New Feature Set</a> is present.</p>

<h2 class="haH2">
  <a name="1153440"> </a>Net Library Constants <a href="#1083561"><span class="nav">^TOP^</span></a>
</h2>


<h3 class="hbH3">
  <a name="1153429"> </a>Configuration Aliases <a href="#1083561"><span class="nav">^TOP^</span></a>
</h3>


<p><a name="1083919"> </a>A configuration is a set of specific values for the net library settings. The net library defines a set of built-in configuration aliases for common network setups. These aliases point to configurations instead of holding the actual values themselves. You can specify an alias anywhere in the API you would specify a configuration. </p>

<p><a name="1083920"> </a>The constants listed here specify the alias names. Most of the net library API requires a configuration index rather than a name. Use <a href="NetLibrary.html#1084430"><code>NetLibConfigIndexFromName()</code></a> to obtain the alias's index from the name. </p>
<h4>
  <a name="1173422"> </a>Constants 
</h4>

<dl>
<dt><a name="1083927"> </a><code>netCfgNameDefault </code></dt>
<dd><a name="1083929"> </a>The default configuration.</dd>

<dt><a name="1083932"> </a><code>netCfgNameDefWireline </code></dt>
<dd><a name="1083934"> </a>The default configuration for wireline communications.</dd>

<dt><a name="1083937"> </a><code>netCfgNameDefWireless </code></dt>
<dd><a name="1083939"> </a>The default configuration for wireless communications.</dd>

<dt><a name="1083942"> </a><code>netCfgNameCTPWireline </code></dt>
<dd><a name="1083944"> </a>The default configuration for wireline communications through the Palm Web Clipping Proxy server. </dd>

<dt><a name="1083950"> </a><code>netCfgNameCTPWireless </code></dt>
<dd><a name="1083952"> </a>The default configuration for wireless communications through the Palm Web Clipping Proxy server. </dd>

</dl>
<h4>
  <a name="1173428"> </a>Comments 
</h4>

<p><a name="1083957"> </a>By default, <code>netCfgNameDefault</code> points to the user's default configuration, and all other aliases point to <code>netCfgNameDefault</code> except for <code>netCfgNameCTPWireless</code>, which points to an private wireless configuration. </p>
<h4>
  <a name="1083958"> </a>Compatibility 
</h4>

<p><a name="1083962"> </a>Supported on version 3.2 and later.</p>

<h3 class="hbH3">
  <a name="1083964"> </a>I/O Flags <a href="#1083561"><span class="nav">^TOP^</span></a>
</h3>


<p><a name="1083965"> </a>The I/O flags specify special handling instructions to functions that send and receive data. You can OR these values together to specify more than one.</p>
<h4>
  <a name="1167783"> </a>Constants 
</h4>

<dl>
<dt><a name="1083970"> </a><code>netIOFlagOutOfBand </code></dt>
<dd><a name="1083972"> </a>Process out-of-band data. Available for send calls only. </dd>

<dt><a name="1083975"> </a><code>netIOFlagPeek </code></dt>
<dd><a name="1083977"> </a>Peek at incoming message without dequeuing it.</dd>

<dt><a name="1083980"> </a><code>netIOFlagDontRoute </code></dt>
<dd><a name="1083982"> </a>Send without using routing. This constant is currently ignored. </dd>

</dl>

<h3 class="hbH3">
  <a name="1154370"> </a>Socket Notice Trigger Conditions <a href="#1083561"><span class="nav">^TOP^</span></a>
</h3>

<p class="tt"><a name="1154371"> </a>The socket notice trigger condition is a bitfield that identifies one or more of the state changes associated with a socket&#8212;for instance, closing a socket, a socket receiving TCP data, etc. </p>
<p class="tt"><a name="1155213"> </a>When you register to receive a socket notice, the bitfield is passed to <a href="NetLibrary.html#1087723"><code>NetLibSocketOptionSet()</code></a> in the <code>condition</code> field of the <a href="NetLibrary.html#1144345"><code>NetSocketNoticeType</code></a> structure. When you receive a socket notification, the <code>condition</code> field of the <code>SysNotifyNetSocketType</code> structure contains this bitfield, which you read to determine what state changes the socket has undergone.</p>
<p class="tt"><a name="1156120"> </a>These constants are defined in <code>NetMgr.h</code> as follows:</p>
<h4>
  <a name="1167803"> </a>Constants 
</h4>

<dl>
<dt><a name="1154385"> </a><code>netSocketNoticeErr </code></dt>
<dd><a name="1154387"> </a>Socket error.</dd>

<dt><a name="1154390"> </a><code>netSocketNoticeUDPReceive </code></dt>
<dd><a name="1154392"> </a>Socket received UDP data.</dd>

<dt><a name="1154395"> </a><code>netSocketNoticeTCPReceive</code></dt>
<dd><a name="1154397"> </a>Socket received TCP data.</dd>

<dt><a name="1154403"> </a><code>netSocketNoticeTCPTransmit </code></dt>
<dd><a name="1154405"> </a>Socket transmitted TCP data.</dd>

<dt><a name="1154408"> </a><code>netSocketNoticeTCPRemoteClosed</code></dt>
<dd><a name="1154410"> </a>Remote TCP connection closed.</dd>

<dt><a name="1154419"> </a><code>netSocketNoticeTCPClosed</code></dt>
<dd><a name="1154421"> </a>Local TCP connection closed.</dd>

<dt><a name="1154424"> </a><code>netSocketNoticeConnectInbound</code></dt>
<dd><a name="1154426"> </a>A remote node tried to connect.</dd>

<dt><a name="1154429"> </a><code>netSocketNoticeConnectOutbound</code></dt>
<dd><a name="1154431"> </a>Your application tried to connect to a remote node.</dd>

</dl>
<h4>
  <a name="1168635"> </a>Comments 
</h4>

<p><a name="1154448"> </a>f you wish to receive notice of <i>all</i> socket conditions, use <code>0xFFFFFFFF</code> as the value of the <code class="par">condition</code> field .</p>
<h4>
  <a name="1159959"> </a>Compatibility 
</h4>

<p><a name="1159898"> </a>Implemented if <a href="CompatibilityApdx.html#1024524">5.4 New Feature Set</a> is present.</p>

<h3 class="hbH3">
  <a name="1154363"> </a>Tracing Bits <a href="#1083561"><span class="nav">^TOP^</span></a>
</h3>

<p class="tt"><a name="1083986"> </a>The tracing bits are used to set the level of event tracing. An application can get a list of events in the trace buffer using the <a href="NetLibrary.html#1085869"><code>NetLibMaster()</code></a> call. </p>

<p><a name="1083990"> </a>You can set the tracing for each network interface using <a href="NetLibrary.html#1085735"><code>NetLibIFSettingSet()</code></a> and for the net library in general with <a href="NetLibrary.html#1087056"><code>NetLibSettingSet()</code></a>.</p>
<h4>
  <a name="1173367"> </a>Constants 
</h4>

<dl>
<dt><a name="1084000"> </a><code>netTracingErrors </code></dt>
<dd><a name="1084002"> </a>Record run-time errors. This is the default.</dd>

<dt><a name="1084005"> </a><code>netTracingMsgs </code></dt>
<dd><a name="1084007"> </a>Record application trace messages.</dd>

<dt><a name="1084010"> </a><code>netTracingPkts </code></dt>
<dd><a name="1084012"> </a>Record packet I/O. This bit is obsolete in versions 3.2 and higher, but is mapped to <code>netTracingPktIP</code>. </dd>

<dt><a name="1084018"> </a><code>netTracingFuncs </code></dt>
<dd><a name="1084020"> </a>Record function flow.</dd>

<dt><a name="1084023"> </a><code>netTracingAppMsgs </code></dt>
<dd><a name="1084025"> </a>Record application messages sent using <a href="NetLibrary.html#1088147"><code>NetLibTracePrintF()</code></a> and <a href="NetLibrary.html#1088190"><code>NetLibTracePutS()</code></a>.</dd>

<dt><a name="1084034"> </a><code>netTracingPktIP</code></dt>
<dd><a name="1084036"> </a>Record packet I/O. If this set, the following five options are enabled.</dd>

<dt><a name="1084039"> </a><code>netTracingData40</code></dt>
<dd><a name="1084041"> </a>Record the first 40 bytes of each packet sent or received. This option is mutually exclusive with <code>netTracingData</code>.</dd>

<dt><a name="1084044"> </a><code>netTracingData</code></dt>
<dd><a name="1084046"> </a>Record the entirety of each packet sent or received. This option is mutually exclusive with <code>netTracingData40</code>.</dd>

<dt><a name="1084049"> </a><code>netTracingIFHi</code></dt>
<dd><a name="1084051"> </a>Record packets sent or received at the highest layer of the network interface. This layer is just below the IP layer.</dd>

<dt><a name="1084054"> </a><code>netTracingIFMid</code></dt>
<dd><a name="1084056"> </a>Record packets sent or received at the layer just below the highest layer of the network interface.</dd>

<dt><a name="1084059"> </a><code>netTracingIFLow</code></dt>
<dd><a name="1084061"> </a>Record packets sent or received at the lowest layer of the network interface.</dd>

</dl>
<h4>
  <a name="1084063"> </a>Compatibility 
</h4>

<p><a name="1084064"> </a>The <code>netTracingPktXXX</code> constants are supported only in version 3.2 devices and higher. In previous versions, specify <code>netTracingPkts</code> instead; only the size of the packet is recorded. </p>

<h2 class="haH2">
  <a name="1084069"> </a>Net Library Functions <a href="#1083561"><span class="nav">^TOP^</span></a>
</h2>


<h3 class="hbH3">
  <a name="1084072"> </a>NetHToNL Macro <a href="#1083561"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="1084074"> </a>Purpose 
</h4>

<p><a name="1084075"> </a>Converts a 32-bit value from host to network byte order.</p>
<h4>
  <a name="1084076"> </a>Declared In 
</h4>
<code>NetBitUtils.h<a name="1084077"> </a></code><h4>
  <a name="1084078"> </a>Prototype 
</h4>
<pre class="proto"><a name="1084080"></a>#define NetHToNL (
   x
)
</pre>
<h4>
  <a name="1084081"> </a>Parameters 
</h4>

<dl>
<dt><a name="1084082"> </a><code>&rarr;  <i><code>x</code></i></code></dt>
<dd><a name="1084083"> </a>32-bit value to convert.</dd>

</dl>
<h4>
  <a name="1084084"> </a>Returns 
</h4>

<p><a name="1084085"> </a>Returns <code>x</code> in network byte order.</p>
<h4>
  <a name="1084086"> </a>Sockets Equivalent
</h4>

<p><a name="1084087"> </a><code>htonl()</code></p>
<h4>
  <a name="1084088"> </a>See Also 
</h4>

<p><a name="1084098"> </a><a href="NetLibrary.html#1088259"><code>NetNToHS()</code></a>, <a href="NetLibrary.html#1088228"><code>NetNToHL()</code></a>, <a href="NetLibrary.html#1084101"><code>NetHToNS()</code></a> </p>

<h3 class="hbH3">
  <a name="1084101"> </a>NetHToNS Macro <a href="#1083561"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="1084103"> </a>Purpose 
</h4>

<p><a name="1084104"> </a>Converts a 16-bit value from host to network byte order.</p>
<h4>
  <a name="1084105"> </a>Declared In 
</h4>
<code>NetBitUtils.h<a name="1084106"> </a></code><h4>
  <a name="1084107"> </a>Prototype 
</h4>
<pre class="proto"><a name="1084108"></a>#define NetHToNS (
   x
)
</pre>
<h4>
  <a name="1084109"> </a>Parameters 
</h4>

<dl>
<dt><a name="1084110"> </a><code>&rarr;  <i><code>x</code></i></code></dt>
<dd><a name="1084111"> </a>16-bit value to convert.</dd>

</dl>
<h4>
  <a name="1084112"> </a>Returns 
</h4>

<p><a name="1084113"> </a>Returns <code>x</code> in network byte order.</p>
<h4>
  <a name="1084114"> </a>Sockets Equivalent
</h4>

<p><a name="1084115"> </a><code>htons()</code></p>
<h4>
  <a name="1084116"> </a>See Also 
</h4>

<p><a name="1084126"> </a><a href="NetLibrary.html#1088259"><code>NetNToHS()</code></a>, <a href="NetLibrary.html#1088228"><code>NetNToHL()</code></a>, <a href="NetLibrary.html#1084072"><code>NetHToNL()</code></a> </p>

<h3 class="hbH3">
  <a name="1084129"> </a>NetLibAddrAToIN Function <a href="#1083561"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="1084131"> </a>Purpose 
</h4>

<p><a name="1084132"> </a>Converts an ASCII string representing a dotted decimal IP address into a 32-bit IP address in network byte order.</p>
<h4>
  <a name="1084133"> </a>Declared In 
</h4>
<code>NetMgr.h<a name="1084134"> </a></code><h4>
  <a name="1084135"> </a>Prototype 
</h4>
<pre class="proto"><a name="1084138"></a>NetIPAddr NetLibAddrAToIN (
   UInt16 libRefnum,
   const Char *a
)
</pre>
<h4>
  <a name="1084139"> </a>Parameters 
</h4>

<dl>
<dt><a name="1084140"> </a><code>&rarr;  <i><code>libRefNum</code></i></code></dt>
<dd><a name="1084141"> </a>Reference number of the net library.</dd>

<dt><a name="1084142"> </a><code>&rarr;  <i><code>a</code></i></code></dt>
<dd><a name="1084143"> </a>Pointer to ASCII dotted decimal string.</dd>

</dl>
<h4>
  <a name="1084144"> </a>Returns 
</h4>

<p><a name="1084145"> </a>Returns a 32-bit network byte order IP address or -1 if <code>a</code> doesn't represent a dotted decimal IP address</p>
<h4>
  <a name="1084146"> </a>Sockets Equivalent
</h4>

<p><a name="1084147"> </a><code>UInt32 inet_addr (char *cp)</code></p>
<h4>
  <a name="1084148"> </a>See Also 
</h4>

<p><a name="1084152"> </a><a href="NetLibrary.html#1084155"><code>NetLibAddrINToA()</code></a> </p>

<h3 class="hbH3">
  <a name="1084155"> </a>NetLibAddrINToA Function <a href="#1083561"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="1084157"> </a>Purpose 
</h4>

<p><a name="1084158"> </a>Converts an IP address from 32-bit network byte order into a dotted decimal ASCII string.</p>
<h4>
  <a name="1084159"> </a>Declared In 
</h4>
<code>NetMgr.h<a name="1084160"> </a></code><h4>
  <a name="1084161"> </a>Prototype 
</h4>
<pre class="proto"><a name="1084163"></a>Char *NetLibAddrINToA (
   UInt16 libRefnum,
   NetIPAddr inet,
   Char *spaceP
)
</pre>
<h4>
  <a name="1084165"> </a>Parameters 
</h4>

<dl>
<dt><a name="1084166"> </a><code>&rarr;  <i><code>libRefNum</code></i></code></dt>
<dd><a name="1084167"> </a>Reference number of the net library.</dd>

<dt><a name="1084168"> </a><code>&rarr;  <i><code>inet</code></i></code></dt>
<dd><a name="1084169"> </a>32-bit IP address in network byte order. </dd>

<dt><a name="1084170"> </a><code>&larr;  <i><code>spaceP</code></i></code></dt>
<dd><a name="1084171"> </a>Buffer used to hold the return value.</dd>

</dl>
<h4>
  <a name="1084172"> </a>Returns 
</h4>

<p><a name="1084173"> </a>Returns in <code>spaceP</code> the dotted decimal ASCII string representation of the IP address.</p>
<h4>
  <a name="1084174"> </a>Sockets Equivalent
</h4>

<p><a name="1084175"> </a><code>char *inet_ntoa (struct in_addr in)</code></p>
<h4>
  <a name="1084176"> </a>See Also 
</h4>

<p><a name="1084180"> </a><a href="NetLibrary.html#1084129"><code>NetLibAddrAToIN()</code></a> </p>

<h3 class="hbH3">
  <a name="1084184"> </a>NetLibClose Function <a href="#1083561"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="1084186"> </a>Purpose 
</h4>

<p><a name="1084187"> </a>Closes the net library.</p>
<h4>
  <a name="1084188"> </a>Declared In 
</h4>
<code>NetMgr.h<a name="1084189"> </a></code><h4>
  <a name="1084190"> </a>Prototype 
</h4>
<pre class="proto"><a name="1084192"></a>Err NetLibClose (
   UInt16 libRefnum,
   UInt16 immediate
)
</pre>
<h4>
  <a name="1084193"> </a>Parameters 
</h4>

<dl>
<dt><a name="1084194"> </a><code>&rarr;  <i><code>libRefnum</code></i></code></dt>
<dd><a name="1084195"> </a>Reference number of the net library.</dd>

<dt><a name="1084196"> </a><code>&rarr;  <i><code>immediate</code></i></code></dt>
<dd><a name="1084197"> </a>If <code>true</code>, library will shut down immediately. If <code>false</code>, library will shut down only if close timer expires before another <a href="NetLibrary.html#1086179"><code>NetLibOpen()</code></a> is issued. </dd>

</dl>
<h4>
  <a name="1084201"> </a>Returns 
</h4>

<p><a name="1084202"> </a>Returns one of the following values:</p>

<dl>
<dt><a name="1084203"> </a><code>0</code></dt>
<dd><a name="1084204"> </a>Success.</dd>

<dt><a name="1084206"> </a><code><code>netErrNotOpen</code></code></dt>
<dd><a name="1084207"> </a>Library was not open.</dd>

<dt><a name="1084209"> </a><code><code>netErrStillOpen</code></code></dt>
<dd><a name="1084210"> </a>Not really an error; returned if library is still in use by another application. </dd>

</dl>
<h4>
  <a name="1084211"> </a>Sockets Equivalent
</h4>

<p><a name="1084212"> </a>None.</p>
<h4>
  <a name="1084213"> </a>Comments 
</h4>

<p><a name="1084214"> </a>Applications must call this function when they no longer need the net library. If the net library open count is greater than 1 before this call is made, the count is decremented and <code>netErrStillOpen</code> is returned. If the open count was 1, the library takes the following action:</p>
<ul type="disc">
  <li><a name="1084216"> </a>If <code>immediate</code> is <code>true</code>, the library shuts down immediately. All network interfaces are brought down, the net protocol stack task is terminated, and all memory used by the net library is freed. 
  <li><a name="1084217"> </a>If <code>immediate</code> is <code>false</code>, a close timer is created and this call returns immediately without actually bringing the net library down. Instead it leaves it up and running but marks it as in the "close-wait" state. It remains in this state until either the timer expires or another <code>NetLibOpen</code> is issued. If the timer expires, the library is shut down. If another <code>NetLibOpen</code> call is issued before the timer expires (possibly by another application), the timer is cancelled and the library is marked as fully open.
</ul>

<p><a name="1084218"> </a>In most cases, you should pass <code>false</code> for <code>immediate</code>. This allows the user to quit one Internet application and launch another within a short period of time without having to wait through the process of closing down and then re-establishing dial-up network connections. </p>
<h4>
  <a name="1084219"> </a>See Also 
</h4>

<p><a name="1084226"> </a><a href="NetLibrary.html#1086179"><code>NetLibOpen()</code></a>, <a href="NetLibrary.html#1086342"><code>NetLibOpenCount()</code></a> </p>

<h3 class="hbH3">
  <a name="1084231"> </a>NetLibConfigAliasGet Function <a href="#1083561"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="1084233"> </a>Purpose 
</h4>

<p><a name="1084234"> </a>Return the configuration that an alias points to.</p>
<h4>
  <a name="1084235"> </a>Prototype 
</h4>
<pre class="proto"><a name="1084237"></a>Err NetLibConfigAliasGet (
   UInt16 refNum,
   UInt16 aliasIndex,
   UInt16 *indexP,
   Boolean *isAnotherAliasP
)
</pre>
<h4>
  <a name="1084238"> </a>Parameters 
</h4>

<dl>
<dt><a name="1084239"> </a><code>&rarr;  <i><code>refNum</code></i></code></dt>
<dd><a name="1084240"> </a>Reference number of the net library.</dd>

<dt><a name="1084241"> </a><code>&rarr;  <i><code>aliasIndex</code></i></code></dt>
<dd><a name="1084242"> </a>Index of the alias.</dd>

<dt><a name="1084243"> </a><code>&larr;  <i><code>indexP</code></i></code></dt>
<dd><a name="1084244"> </a>Index of the configuration pointed to by the alias.</dd>

<dt><a name="1084245"> </a><code>&larr;  <i><code>isAnotherAliasP</code></i></code></dt>
<dd><a name="1084246"> </a><code>true</code> if <code>indexP</code> is the index of another alias; <code>false</code> if <code>indexP</code> specifies an actual configuration. </dd>

</dl>
<h4>
  <a name="1084247"> </a>Returns 
</h4>

<p><a name="1084248"> </a>Returns one of the following values:</p>

<dl>
<dt><a name="1084249"> </a><code>0</code></dt>
<dd><a name="1084250"> </a>Success.</dd>

<dt><a name="1084252"> </a><code><code>netErrConfigNotAlias</code></code></dt>
<dd><a name="1084253"> </a>The configuration at <code>aliasIndex</code> is not an alias. </dd>

</dl>

<p><a name="1084255"> </a><code>netErrOutOfCmdBlocks</code> </p>

<dl>
<dt><a name="1084257"> </a><code><code>netErrParamErr</code> </code></dt>
<dd><a name="1084258"> </a>The specified index is out of range or there is no configuration at the index.</dd>

</dl>
<h4>
  <a name="1084259"> </a>Sockets Equivalent
</h4>

<p><a name="1084260"> </a>None</p>
<h4>
  <a name="1084261"> </a>Comments 
</h4>

<p><a name="1084262"> </a>Use this routine to find out which configuration a built-in alias points to. See <a href="NetLibrary.html#1153429">"Configuration Aliases"</a> for a description of the built-in aliases. </p>
<h4>
  <a name="1084266"> </a>Compatibility 
</h4>

<p><a name="1084270"> </a>Implemented only if <a href="CompatibilityApdx.html#993903">3.2 New Feature Set</a> is present.</p>
<h4>
  <a name="1084271"> </a>See Also 
</h4>

<p><a name="1084275"> </a><a href="NetLibrary.html#1084278"><code>NetLibConfigAliasSet()</code></a> </p>

<h3 class="hbH3">
  <a name="1084278"> </a>NetLibConfigAliasSet Function <a href="#1083561"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="1084280"> </a>Purpose 
</h4>

<p><a name="1084281"> </a>Set a built-in alias to point to a defined configuration.</p>
<h4>
  <a name="1084282"> </a>Prototype 
</h4>
<pre class="proto"><a name="1084284"></a>Err NetLibConfigAliasSet (
   UInt16 refNum,
   UInt16 configIndex,
   UInt16 aliasToIndex
)
</pre>
<h4>
  <a name="1084285"> </a>Parameters 
</h4>

<dl>
<dt><a name="1084286"> </a><code>&rarr;  <i><code>refNum</code></i></code></dt>
<dd><a name="1084287"> </a>Reference number of the net library.</dd>

<dt><a name="1084288"> </a><code>&rarr;  <i><code>configIndex</code></i></code></dt>
<dd><a name="1084289"> </a>Index of the built-in alias to be set.</dd>

<dt><a name="1084290"> </a><code>&rarr;  <i><code>aliasToIndex</code></i></code></dt>
<dd><a name="1084291"> </a>Index of the configuration to which the alias should point. You cannot set an alias to point to itself.</dd>

</dl>
<h4>
  <a name="1084292"> </a>Returns 
</h4>

<p><a name="1084293"> </a>Returns one of the following values:</p>

<dl>
<dt><a name="1084294"> </a><code>0</code></dt>
<dd><a name="1084295"> </a>Success.</dd>

<dt><a name="1084297"> </a><code><code>netErrConfigCantPointToAlias</code></code></dt>
<dd><a name="1084298"> </a>The configuration at <code>aliasToIndex</code> is an alias that points to an alias. </dd>

<dt><a name="1084300"> </a><code><code>netErrConfigNotAlias</code></code></dt>
<dd><a name="1084301"> </a>The configuration at <code>configIndex</code> isn't an alias.</dd>

<dt><a name="1084303"> </a><code><code>netErrOutOfCmdBlocks</code></code></dt>
<dd><a name="1084304"> </a></dd>

<dt><a name="1084306"> </a><code><code>netErrParamErr</code> </code></dt>
<dd><a name="1084307"> </a>The specified index is out of range or there's no configuration at the index.</dd>

</dl>
<h4>
  <a name="1084308"> </a>Sockets Equivalent
</h4>

<p><a name="1084309"> </a>None</p>
<h4>
  <a name="1084310"> </a>Comments 
</h4>

<p><a name="1084311"> </a>This function is used by the Network preferences panel when the user edits a configuration. Your application can use it to associate any of the built-in aliases with a defined configuration. </p>

<p><a name="1084315"> </a>The built-in aliases are typically set up as shown in <a href="NetLibrary.html#1084322">Table 66.1</a>. In this example, applications that specify a configuration index of 0 through 3 use a configuration that the user defines. Applications that use index 4 use a private configuration created by the network library. </p>

<p class="caption"><a name="1084322"> </a><b>Table 66.1&nbsp;&nbsp;Example Configuration Table </b></p>
<div class="tablediv"><table cellspacing="0" class="tTable">

  <tr valign="top">
    <th><p class="tt"><a name="1084328"> </a><b>Index</b></p>
    </th>
    <th><p class="tt"><a name="1084330"> </a><b>Name</b></p>
    </th>
    <th><p class="tt"><a name="1084332"> </a><b>Alias To</b></p>
    </th>
  </tr>
  <tr valign="top">
    <td><p class="tt"><a name="1084334"> </a>0</p>
    </td>
    <td><p class="tt"><a name="1084336"> </a>.Default</p>
    </td>
    <td><p class="tt"><a name="1084338"> </a>6</p>
    </td>
  </tr>
  <tr valign="top">
    <td><p class="tt"><a name="1084340"> </a>1</p>
    </td>
    <td><p class="tt"><a name="1084342"> </a>.DefWireline</p>
    </td>
    <td><p class="tt"><a name="1084344"> </a>0</p>
    </td>
  </tr>
  <tr valign="top">
    <td><p class="tt"><a name="1084346"> </a>2</p>
    </td>
    <td><p class="tt"><a name="1084348"> </a>.DefWireless</p>
    </td>
    <td><p class="tt"><a name="1084350"> </a>0</p>
    </td>
  </tr>
  <tr valign="top">
    <td><p class="tt"><a name="1084352"> </a>3</p>
    </td>
    <td><p class="tt"><a name="1084354"> </a>.CTPWireline</p>
    </td>
    <td><p class="tt"><a name="1084356"> </a>0</p>
    </td>
  </tr>
  <tr valign="top">
    <td><p class="tt"><a name="1084358"> </a>4</p>
    </td>
    <td><p class="tt"><a name="1084360"> </a>.CTPWireless</p>
    </td>
    <td><p class="tt"><a name="1084362"> </a>5</p>
    </td>
  </tr>
  <tr valign="top">
    <td><p class="tt"><a name="1084364"> </a>5</p>
    </td>
    <td><p class="tt"><a name="1084366"> </a>_RAMCTP</p>
    </td>
    <td><p class="tt"><a name="1084368"> </a></p>
    </td>
  </tr>
  <tr valign="top">
    <td><p class="tt"><a name="1084370"> </a>6</p>
    </td>
    <td><p class="tt"><a name="1084372"> </a>user-defined</p>
    </td>
    <td><p class="tt"><a name="1084374"> </a></p>
    </td>
  </tr>
</table>

</div>


<p><a name="1084376"> </a>An alias can point to another alias so long as the nesting level is only one deep. That is, if you point an alias to an alias, you'll receive an error if that alias in turn points to another alias. This eliminates the possibility that an alias never resolves to an actual configuration. </p>
<h4>
  <a name="1084378"> </a>Compatibility 
</h4>

<p><a name="1084382"> </a>Implemented only if <a href="CompatibilityApdx.html#993903">3.2 New Feature Set</a> is present.</p>
<h4>
  <a name="1084383"> </a>See Also 
</h4>

<p><a name="1084387"> </a><a href="NetLibrary.html#1084231"><code>NetLibConfigAliasGet()</code></a> </p>

<h3 class="hbH3">
  <a name="1084390"> </a>NetLibConfigDelete Function <a href="#1083561"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="1084392"> </a>Purpose 
</h4>

<p><a name="1084393"> </a>Delete a configuration from the net library's configuration table. </p>
<h4>
  <a name="1084394"> </a>Prototype 
</h4>
<pre class="proto"><a name="1084396"></a>Err NetLibConfigDelete (
   UInt16 refNum,
   UInt16 index
)
</pre>
<h4>
  <a name="1084397"> </a>Parameters 
</h4>

<dl>
<dt><a name="1084398"> </a><code>&rarr;  <i><code>refNum</code></i></code></dt>
<dd><a name="1084399"> </a>Reference number of the net library.</dd>

<dt><a name="1084400"> </a><code>&rarr;  <i><code>index</code></i></code></dt>
<dd><a name="1084401"> </a>Index of the configuration to delete. You cannot delete one of the built-in aliases described in "<a href="NetLibrary.html#1153429"><code>Configuration Aliases</code></a>."</dd>

</dl>
<h4>
  <a name="1084405"> </a>Returns 
</h4>

<p><a name="1084406"> </a>Returns one of the following values:</p>

<dl>
<dt><a name="1084407"> </a><code>0</code></dt>
<dd><a name="1084408"> </a>Success.</dd>

<dt><a name="1084409"> </a><code><code>netErrConfigCantDelete</code> </code></dt>
<dd><a name="1084410"> </a>The configuration at <code>index</code> is a built-in alias.</dd>

</dl>

<p><a name="1084412"> </a><code>netErrOutOfCmdBlocks</code> </p>

<dl>
<dt><a name="1084414"> </a><code><code>netErrParamErr</code> </code></dt>
<dd><a name="1084415"> </a>The specified index is out of range.</dd>

</dl>
<h4>
  <a name="1084416"> </a>Sockets Equivalent
</h4>

<p><a name="1084417"> </a>None</p>
<h4>
  <a name="1084418"> </a>Compatibility 
</h4>

<p><a name="1084422"> </a>Implemented only if <a href="CompatibilityApdx.html#993903">3.2 New Feature Set</a> Set is present.</p>
<h4>
  <a name="1084423"> </a>See Also 
</h4>

<p><a name="1084427"> </a><a href="NetLibrary.html#1084615"><code>NetLibConfigSaveAs()</code></a> </p>

<h3 class="hbH3">
  <a name="1084430"> </a>NetLibConfigIndexFromName Function <a href="#1083561"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="1084432"> </a>Purpose 
</h4>

<p><a name="1084433"> </a>Obtain a configuration's index given its name.</p>
<h4>
  <a name="1084434"> </a>Prototype 
</h4>
<pre class="proto"><a name="1084436"></a>Err NetLibConfigIndexFromName (
   UInt16 refNum,
   NetConfigNamePtr nameP,
   UInt16 *indexP
)
</pre>
<h4>
  <a name="1084437"> </a>Parameters 
</h4>

<dl>
<dt><a name="1084438"> </a><code>&rarr;  <i><code>refNum</code></i></code></dt>
<dd><a name="1084439"> </a>Reference number of the net library.</dd>

<dt><a name="1084440"> </a><code>&rarr;  <i><code>nameP</code></i></code></dt>
<dd><a name="1084444"> </a>Pointer to a configuration name. See <a href="NetLibrary.html#1083588"><code>NetConfigNameType</code></a>. </dd>

<dt><a name="1084445"> </a><code>&larr;  <i><code>indexP</code></i></code></dt>
<dd><a name="1084446"> </a>The index of the configuration with the name <code>*nameP</code>. </dd>

</dl>
<h4>
  <a name="1084447"> </a>Returns 
</h4>

<p><a name="1084448"> </a>Returns one of the following values:</p>

<dl>
<dt><a name="1084449"> </a><code>0</code></dt>
<dd><a name="1084450"> </a>Success.</dd>

<dt><a name="1084452"> </a><code><code>netErrConfigNotFound</code> </code></dt>
<dd><a name="1084453"> </a>A configuration with the specified name could not be found. </dd>

</dl>

<p><a name="1084455"> </a><code>netErrOutOfCmdBlocks</code> </p>
<h4>
  <a name="1084456"> </a>Sockets Equivalent
</h4>

<p><a name="1084457"> </a>None</p>
<h4>
  <a name="1084458"> </a>Comments 
</h4>

<p><a name="1084459"> </a>This function returns the index of a configuration given its name. Your application should store the configuration's index rather than its name because a configuration's name can change. </p>

<p><a name="1084460"> </a>If you pass the name of a built-in alias in <code>nameP</code>, this function returns the index of the alias's entry in the configuration table; it does not return the index that the alias points to. For example, if the alias <code>netCfgNameCTPWireless</code> is stored at index 4 and points to index 5, <code>NetLibConfigIndexFromName</code> returns 4. If you want to obtain the index that an alias points to, use <a href="NetLibrary.html#1084231"><code>NetLibConfigAliasGet()</code></a>. </p>
<h4>
  <a name="1084464"> </a>Compatibility 
</h4>

<p><a name="1084468"> </a>Implemented only if <a href="CompatibilityApdx.html#993903">3.2 New Feature Set</a> is present.</p>
<h4>
  <a name="1084469"> </a>See Also 
</h4>

<p><a name="1084473"> </a><a href="NetLibrary.html#1084476"><code>NetLibConfigList()</code></a> </p>

<h3 class="hbH3">
  <a name="1084476"> </a>NetLibConfigList Function <a href="#1083561"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="1084478"> </a>Purpose 
</h4>

<p><a name="1084479"> </a>Return a list of net library configuration names.</p>
<h4>
  <a name="1084480"> </a>Prototype 
</h4>
<pre class="proto"><a name="1084482"></a>Err NetLibConfigList (
   UInt16 refNum,
   NetConfigNameType nameArray[],
   UInt16 *arrayEntriesP
)
</pre>
<h4>
  <a name="1084483"> </a>Parameters 
</h4>

<dl>
<dt><a name="1084484"> </a><code>&rarr;  <i><code>refNum</code></i></code></dt>
<dd><a name="1084485"> </a>Reference number of the net library.</dd>

<dt><a name="1084486"> </a><code>&larr;  <i><code>nameArray</code></i></code></dt>
<dd><a name="1084487"> </a>The list of defined configurations. See <a href="NetLibrary.html#1083588"><code>NetConfigNameType</code></a>. </dd>

<dt><a name="1084491"> </a><code>&harr;  <i><code>arrayEntriesP</code></i></code></dt>
<dd><a name="1084492"> </a>On entry, contains the number of elements in <code>nameArray</code>. On return, contains the number of elements in <code>nameArray</code> that were actually used. The Net Library currently returns up to 16 entries. If the array is not large enough to hold all the configuration names, this function returns only as many names as the array can hold.</dd>

</dl>
<h4>
  <a name="1084493"> </a>Returns 
</h4>

<p><a name="1084494"> </a>Returns one of the following values:</p>

<dl>
<dt><a name="1084495"> </a><code>0</code></dt>
<dd><a name="1084496"> </a>Success.</dd>

<dt><a name="1084498"> </a><code><code>netErrOutOfCmdBlocks</code> </code></dt>
</dl>
<h4>
  <a name="1084499"> </a>Sockets Equivalent
</h4>

<p><a name="1084500"> </a>None</p>
<h4>
  <a name="1084501"> </a>Comments 
</h4>

<p><a name="1084502"> </a>Use this function to obtain a list of the names of defined network configurations and configuration aliases.</p>

<p><a name="1084503"> </a>Users create specific configurations using the Network preferences panel and associate names with each configuration. This function returns the list of defined configurations.</p>

<p><a name="1084504"> </a>In addition to user-defined configurations, this function also returns built-in configuration aliases and private configurations. The built-in configuration aliases are described in "<a href="NetLibrary.html#1153429"><code>Configuration Aliases</code></a>." Their actual names begin with a period (.). Private configurations have names that begin with an underscore (_).</p>

<div><hr>
  <a name="1084508"> </a> <b>IMPORTANT: </b> If you present the list returned by this function to your application's users, you must first filter out names beginning with a period or an underscore. These names are for internal use only. 
<hr>
</div>

<p><a name="1084509"> </a>Your application should refer to a configuration by its index rather than its name because the name can be changed. To obtain the configuration's index from its name, use <a href="NetLibrary.html#1084430"><code>NetLibConfigIndexFromName()</code></a>.</p>
<h4>
  <a name="1084514"> </a>Compatibility 
</h4>

<p><a name="1084518"> </a>Implemented only if <a href="CompatibilityApdx.html#993903">3.2 New Feature Set</a> is present.</p>

<h3 class="hbH3">
  <a name="1084521"> </a>NetLibConfigMakeActive Function <a href="#1083561"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="1084523"> </a>Purpose 
</h4>

<p><a name="1084524"> </a>Makes the specified configuration current without opening the net library.</p>
<h4>
  <a name="1084525"> </a>Prototype 
</h4>
<pre class="proto"><a name="1084527"></a>Err NetLibConfigMakeActive (
   UInt16 refNum,
   UInt16 configIndex
)
</pre>
<h4>
  <a name="1084528"> </a>Parameters 
</h4>

<dl>
<dt><a name="1084529"> </a><code>&rarr;  <i><code>refNum</code></i></code></dt>
<dd><a name="1084530"> </a>Reference number of the net library.</dd>

<dt><a name="1084531"> </a><code>&rarr;  <i><code>configIndex</code></i></code></dt>
<dd><a name="1084532"> </a>Index of the configuration to use. An index of 0 refers to the default configuration as defined by the Network preferences panel.</dd>

</dl>
<h4>
  <a name="1084533"> </a>Returns 
</h4>

<p><a name="1084534"> </a>Returns one of the following values:</p>

<dl>
<dt><a name="1084535"> </a><code>0</code></dt>
<dd><a name="1084536"> </a>Success.</dd>

</dl>

<p><a name="1084538"> </a><code>netErrBufTooSmall</code> </p>

<p><a name="1084540"> </a><code>netErrConfigAliasErr</code> </p>

<p><a name="1084542"> </a><code>netErrConfigCantDelete</code> </p>

<p><a name="1084544"> </a><code>netErrConfigEmpty</code> </p>

<p><a name="1084546"> </a><code>netErrConfigNotFound</code> </p>

<p><a name="1084548"> </a><code>netErrOutOfCmdBlocks</code> </p>

<p><a name="1084550"> </a><code>netErrParamErr</code> </p>

<p><a name="1084552"> </a><code>netErrPrefNotFound</code> </p>
<h4>
  <a name="1084553"> </a>Sockets Equivalent
</h4>

<p><a name="1084554"> </a>None</p>
<h4>
  <a name="1084555"> </a>Comments 
</h4>

<p><a name="1084556"> </a>This function is used mainly by the Network preferences panel when the user edits and saves network configurations. The Network preferences panel uses this function to make current the configuration the user wants to edit, set the settings appropriately, and then save the configuration using <a href="NetLibrary.html#1084615"><code>NetLibConfigSaveAs()</code></a>. </p>

<p><a name="1084560"> </a>Use this routine to make a specific configuration the current configuration without opening the net library. You should not use it if the net library is already open.</p>

<p><a name="1084564"> </a>Unlike <a href="NetLibrary.html#1086243"><code>NetLibOpenConfig()</code></a>, this routine does not save the current net library configuration so that it can be restored upon close. </p>
<h4>
  <a name="1084565"> </a>Compatibility 
</h4>

<p><a name="1084569"> </a>Implemented only if <a href="CompatibilityApdx.html#993903">3.2 New Feature Set</a> is present.</p>

<h3 class="hbH3">
  <a name="1084572"> </a>NetLibConfigRename Function <a href="#1083561"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="1084574"> </a>Purpose 
</h4>

<p><a name="1084575"> </a>Rename the specified configuration.</p>
<h4>
  <a name="1084576"> </a>Prototype 
</h4>
<pre class="proto"><a name="1084578"></a>Err NetLibConfigRename (
   UInt16 refNum,
   UInt16 index,
   NetConfigNamePtr newNameP
)
</pre>
<h4>
  <a name="1084579"> </a>Parameters 
</h4>

<dl>
<dt><a name="1084580"> </a><code>&rarr;  <i><code>refNum</code></i></code></dt>
<dd><a name="1084581"> </a>Reference number of the net library.</dd>

<dt><a name="1084582"> </a><code>&rarr;  <i><code>configIndex</code></i></code></dt>
<dd><a name="1084583"> </a>Index of the configuration to be renamed.</dd>

<dt><a name="1084584"> </a><code>&rarr;  <i><code>newNameP</code></i></code></dt>
<dd><a name="1084588"> </a>Pointer to the new name. See <a href="NetLibrary.html#1083588"><code>NetConfigNameType</code></a>. The new name must not start with a period (.) or an underscore (_). </dd>

</dl>
<h4>
  <a name="1084589"> </a>Returns 
</h4>

<p><a name="1084590"> </a>Returns one of the following values:</p>

<dl>
<dt><a name="1084591"> </a><code>0</code></dt>
<dd><a name="1084592"> </a>Success.</dd>

<dt><a name="1084594"> </a><code><code>netErrConfigBadName</code></code></dt>
<dd><a name="1084595"> </a>The new name begins with a period. </dd>

<dt><a name="1084597"> </a><code><code>netErrConfigCantDelete</code></code></dt>
<dd><a name="1084598"> </a>The configuration at the specified index is a built-in alias or private configuration that cannot be renamed. </dd>

<dt><a name="1084600"> </a><code><code>netErrOutOfCmdBlocks</code></code></dt>
<dt><a name="1084602"> </a><code><code>netErrParamErr</code></code></dt>
<dd><a name="1084603"> </a>The specified index is out of range or there is no configuration at the index.</dd>

</dl>
<h4>
  <a name="1084604"> </a>Sockets Equivalent
</h4>

<p><a name="1084605"> </a>None</p>
<h4>
  <a name="1084606"> </a>Comments 
</h4>

<p><a name="1084607"> </a>You cannot specify a name beginning with a period (.) or an underscore (_). Names beginning with a period are reserved for the built-in configuration aliases. Names beginning with an underscore are hidden configurations used internally by net library. </p>
<h4>
  <a name="1084608"> </a>Compatibility 
</h4>

<p><a name="1084612"> </a>Implemented only if <a href="CompatibilityApdx.html#993903">3.2 New Feature Set</a> is present.</p>

<h3 class="hbH3">
  <a name="1084615"> </a>NetLibConfigSaveAs Function <a href="#1083561"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="1084617"> </a>Purpose 
</h4>

<p><a name="1084618"> </a>Save the current net library settings as a configuration with the specified name. </p>
<h4>
  <a name="1084619"> </a>Prototype 
</h4>
<pre class="proto"><a name="1084621"></a>Err NetLibConfigSaveAs (
   UInt16 refNum,
   NetConfigNamePtr nameP
)
</pre>
<h4>
  <a name="1084622"> </a>Parameters 
</h4>

<dl>
<dt><a name="1084623"> </a><code>&rarr;  <i><code>refNum</code></i></code></dt>
<dd><a name="1084624"> </a>Reference number of the net library.</dd>

<dt><a name="1084625"> </a><code>&rarr;  <i><code>nameP</code></i></code></dt>
<dd><a name="1084626"> </a>Pointer to a name for the configuration. See <a href="NetLibrary.html#1083588"><code>NetConfigNameType</code></a>. The name must not start with a period (.) or an underscore (_).</dd>

</dl>
<h4>
  <a name="1084630"> </a>Returns 
</h4>

<p><a name="1084631"> </a>Returns one of the following values:</p>

<dl>
<dt><a name="1084632"> </a><code>0</code></dt>
<dd><a name="1084633"> </a>Success.</dd>

<dt><a name="1084635"> </a><code><code>netErrConfigBadName</code></code></dt>
<dd><a name="1084636"> </a>The specified name begins with a period or underscore.</dd>

<dt><a name="1084638"> </a><code><code>netErrConfigTooMany</code></code></dt>
<dd><a name="1084639"> </a>Not enough space to add another configuration. The Net Library can hold up to 16 configuration.</dd>

</dl>

<p><a name="1084641"> </a><code>netErrOutOfCmdBlocks</code></p>
<h4>
  <a name="1084642"> </a>Sockets Equivalent
</h4>

<p><a name="1084643"> </a>None</p>
<h4>
  <a name="1084644"> </a>Comments 
</h4>

<p><a name="1084645"> </a>If the name you specify already exists, its configuration is replaced with this configuration. </p>

<p><a name="1084646"> </a>You cannot specify a name beginning with a period (.) or an underscore (_). Names beginning with a period are reserved for the built-in configuration aliases. Names beginning with an underscore are hidden configurations used internally by net library. </p>

<p><a name="1084647"> </a>The net library assigns an index to this new configuration. The configuration's index remains constant, while its name may change. Use <a href="NetLibrary.html#1084430"><code>NetLibConfigIndexFromName()</code></a> to obtain the configuration's index. </p>
<h4>
  <a name="1084652"> </a>Compatibility 
</h4>

<p><a name="1084656"> </a>Implemented only if <a href="CompatibilityApdx.html#993903">3.2 New Feature Set</a> is present.</p>
<h4>
  <a name="1084657"> </a>See Also 
</h4>

<p><a name="1084664"> </a><a href="NetLibrary.html#1084390"><code>NetLibConfigDelete()</code></a>, <a href="NetLibrary.html#1084572"><code>NetLibConfigRename()</code></a> </p>

<h3 class="hbH3">
  <a name="1084667"> </a>NetLibConnectionRefresh Function <a href="#1083561"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="1084669"> </a>Purpose 
</h4>

<p><a name="1084670"> </a>This routine is a convenience call for applications. It checks the status of all connections and optionally tries to open any that were closed.</p>
<h4>
  <a name="1084671"> </a>Declared In 
</h4>
<code>NetMgr.h<a name="1084672"> </a></code><h4>
  <a name="1084673"> </a>Prototype 
</h4>
<pre class="proto"><a name="1084674"></a>Err NetLibConnectionRefresh (
   UInt16 refNum,
   Boolean refresh,
   UInt8 *allInterfacesUpP,
   UInt16 *netIFErrP
) 
</pre>
<h4>
  <a name="1084675"> </a>Parameters 
</h4>

<dl>
<dt><a name="1084676"> </a><code>&rarr;  <i><code>refnum</code></i></code></dt>
<dd><a name="1084677"> </a>Reference number of the net library.</dd>

<dt><a name="1084678"> </a><code>&rarr;  <i><code>refresh</code></i></code></dt>
<dd><a name="1084679"> </a>If <code>true</code>, any connections that aren't currently open are opened.</dd>

<dt><a name="1084680"> </a><code>&larr;  <i><code>allInterfacesUpP</code></i></code></dt>
<dd><a name="1084681"> </a>Set to <code>true</code> if all connections are open.</dd>

<dt><a name="1084682"> </a><code>&larr;  <i><code>netIFErrP</code></i></code></dt>
<dd><a name="1084683"> </a>First error encountered when reopening connections that were closed. (See <a href="NetLibrary.html#1085807"><code>NetLibIFUp()</code></a> for a list of possible values.) </dd>

</dl>
<h4>
  <a name="1084687"> </a>Returns 
</h4>

<dl>
<dt><a name="1084688"> </a><code>Returns one of the following values:</code></dt>
<dt><a name="1084689"> </a><code>0</code></dt>
<dd><a name="1084690"> </a>Success.</dd>

<dt><a name="1084692"> </a><code><code>netErrBufTooSmall</code> </code></dt>
<dt><a name="1084694"> </a><code><code>netErrOutOfCmdBlocks</code> </code></dt>
<dt><a name="1084696"> </a><code><code>netErrNoInterfaces</code> </code></dt>
</dl>
<h4>
  <a name="1084697"> </a>Sockets Equivalent
</h4>

<p><a name="1084698"> </a>None.</p>
<h4>
  <a name="1084699"> </a>Comments 
</h4>

<p><a name="1084700"> </a>This function determines whether a connection is up based on the internal status of the TCP/IP stack. To test the presence of a "physical connection" (phone line, modem, serial cable), a command should be sent once it's been determined that the logical connection is up. If the physical connection is broken, nothing returns and a timeout error eventually occurs. </p>

<h3 class="hbH3">
  <a name="1084703"> </a>NetLibDmReceive Function <a href="#1083561"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="1084705"> </a>Purpose 
</h4>

<p><a name="1084706"> </a>Receive data from a socket directly into a database record.</p>
<h4>
  <a name="1084707"> </a>Declared In 
</h4>
<code>NetMgr.h<a name="1084708"> </a></code><h4>
  <a name="1084709"> </a>Prototype 
</h4>
<pre class="proto"><a name="1084711"></a>Int16 NetLibDmReceive (
   UInt16 libRefNum,
   NetSocketRef socket,
   void *recordP,
   UInt32 recordOffset,
   UInt16 rcvLen,
   UInt16 flags,
   void *fromAddrP,
   UInt16 *fromLenP,
   Int32 timeout,
   Err *errP
)
</pre>
<h4>
  <a name="1084712"> </a>Parameters 
</h4>

<dl>
<dt><a name="1084713"> </a><code>&rarr;  <i><code>libRefNum</code></i></code></dt>
<dd><a name="1084714"> </a>Reference number of the net library.</dd>

<dt><a name="1084715"> </a><code>&rarr;  <i><code>socket</code></i></code></dt>
<dd><a name="1084716"> </a>Descriptor for the open socket.</dd>

<dt><a name="1084717"> </a><code>&larr;  <i><code>recordP</code></i></code></dt>
<dd><a name="1084718"> </a>Pointer to beginning of record to receive data into. Must be locked for use.</dd>

<dt><a name="1084719"> </a><code>&rarr;  <i><code>recordOffset</code></i></code></dt>
<dd><a name="1084720"> </a>Offset from beginning of record to read data into.</dd>

<dt><a name="1084721"> </a><code>&rarr;  <i><code>rcvLen</code></i></code></dt>
<dd><a name="1084722"> </a>Maximum number of bytes to read.</dd>

<dt><a name="1084723"> </a><code>&rarr;  <i><code>flags</code></i></code></dt>
<dd><a name="1084727"> </a>One or more <code>netIOFlagxxx</code> flags. See "<a href="NetLibrary.html#1083964"><code>I/O Flags</code></a>."</dd>

<dt><a name="1084728"> </a><code>&larr;  <i><code>fromAddrP</code></i></code></dt>
<dd><a name="1084729"> </a>Pointer to buffer to hold address of sender (<code>a </code><a href="NetLibrary.html#1083857"><code>NetSocketAddrType</code></a> struct). Pass <code>NULL</code> if you don't need sender information. </dd>

<dt><a name="1084733"> </a><code>&harr;  <i><code>fromLenP</code></i></code></dt>
<dd><a name="1084734"> </a>On entry, size of <code>fromAddrP</code> buffer. On exit, actual size of returned address in <code>fromAddrP</code>. Pass <code>NULL</code> if you don't need sender information. </dd>

<dt><a name="1084735"> </a><code>&rarr;  <i><code>timeout</code></i></code></dt>
<dd><a name="1084736"> </a>Maximum timeout in system ticks; -1 means wait forever. </dd>

<dt><a name="1084737"> </a><code>&larr;  <i><code>errP</code></i></code></dt>
<dd><a name="1084738"> </a>Contains an error code if the return value is -1.</dd>

</dl>
<h4>
  <a name="1084739"> </a>Returns 
</h4>

<p><a name="1084740"> </a>Returns the number of bytes successfully received. If the return value is 0, the socket has been shut down by the remote host. If the return value is -1, an error has occurred and <code>errP</code> contains one of the following values: </p>

<dl>
<dt><a name="1084741"> </a><code>0</code></dt>
<dd><a name="1084742"> </a>No error.</dd>

<dt><a name="1084744"> </a><code><code>netErrTimeout</code></code></dt>
<dd><a name="1084745"> </a>Call timed out. </dd>

<dt><a name="1084747"> </a><code><code>netErrNotOpen</code></code></dt>
<dd><a name="1084748"> </a>The referenced net library has not been opened yet. </dd>

<dt><a name="1084750"> </a><code><code>netErrParamErr</code></code></dt>
<dt><a name="1084752"> </a><code><code>netErrSocketNotOpen</code></code></dt>
<dt><a name="1084755"> </a><code><code>netErrWouldBlock</code></code></dt>
<dt><a name="1084757"> </a><code><code>netErrUserCancel</code> </code></dt>
<dt><a name="1084759"> </a><code><code>netErrOutOfMemory</code> </code></dt>
</dl>
<h4>
  <a name="1084760"> </a>Comments 
</h4>

<p><a name="1084764"> </a>This call behaves similarly to <a href="NetLibrary.html#1086371"><code>NetLibReceive()</code></a> but reads the data directly into a database record, which is normally write-protected. The caller must pass a pointer to the start of the record and an offset into the record of where to start the read. </p>

<h3 class="hbH3">
  <a name="1084768"> </a>NetLibFinishCloseWait Function <a href="#1083561"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="1084770"> </a>Purpose 
</h4>

<p><a name="1084771"> </a>Forces the net library to do a complete close if it's currently in the close-wait state.</p>
<h4>
  <a name="1084772"> </a>Declared In 
</h4>
<code>NetMgr.h<a name="1084773"> </a></code><h4>
  <a name="1084774"> </a>Prototype 
</h4>
<pre class="proto"><a name="1084776"></a>Err NetLibFinishCloseWait (
   UInt16 libRefnum
)
</pre>
<h4>
  <a name="1084777"> </a>Parameters 
</h4>

<dl>
<dt><a name="1084778"> </a><code>&rarr;  <i><code>libRefnum</code></i></code></dt>
<dd><a name="1084779"> </a>Reference number of the net library.</dd>

</dl>
<h4>
  <a name="1084780"> </a>Returns 
</h4>

<dl>
<dt><a name="1084781"> </a><code>Returns one of the following values:</code></dt>
<dt><a name="1084782"> </a><code>0</code></dt>
<dd><a name="1084783"> </a>Success.</dd>

<dt><a name="1084785"> </a><code><code>netErrTimeout</code> </code></dt>
</dl>
<h4>
  <a name="1084786"> </a>Sockets Equivalent
</h4>

<p><a name="1084787"> </a>None.</p>
<h4>
  <a name="1084788"> </a>Comments 
</h4>

<p><a name="1084789"> </a>This call checks the current open state of the net library. If it's in the close-wait state (see <a href="NetLibrary.html#1084184"><code>NetLibClose()</code></a>), it forces the library to perform an immediate, complete close operation. </p>

<h3 class="hbH3">
  <a name="1084795"> </a>NetLibGetHostByAddr Function <a href="#1083561"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="1084797"> </a>Purpose 
</h4>

<p><a name="1084798"> </a>Looks up a host name given its IP address.</p>
<h4>
  <a name="1084799"> </a>Declared In 
</h4>
<code>NetMgr.h<a name="1084800"> </a></code><h4>
  <a name="1084801"> </a>Prototype 
</h4>
<pre class="proto"><a name="1084803"></a>NetHostInfoPtr NetLibGetHostByAddr(
   UInt16 libRefNum,
   UInt8 *addrP,
   UInt16 len,
   UInt16 type,
   NetHostInfoBufPtr bufP,
   Int32 timeout,
   Err *errP
)
</pre>
<h4>
  <a name="1084804"> </a>Parameters 
</h4>

<dl>
<dt><a name="1084805"> </a><code>&rarr;  <i><code>libRefNum</code></i></code></dt>
<dd><a name="1084806"> </a>Reference number of the net library.</dd>

<dt><a name="1084807"> </a><code>&rarr;  <i><code>addrP</code></i></code></dt>
<dd><a name="1084808"> </a>IP address of host to lookup.</dd>

<dt><a name="1084809"> </a><code>&rarr;  <i><code>len</code></i></code></dt>
<dd><a name="1084810"> </a>Length, in bytes, of <code>*addrP</code>.</dd>

<dt><a name="1084811"> </a><code>&rarr;  <i><code>type</code></i></code></dt>
<dd><a name="1084815"> </a>Type of <code>addrP</code>. See <a href="NetLibrary.html#1083775"><code>NetSocketAddrEnum</code></a>.</dd>

<dt><a name="1084816"> </a><code>&larr;  <i><code>bufP</code></i></code></dt>
<dd><a name="1084820"> </a>Pointer to a <a href="NetLibrary.html#1083608"><code>NetHostInfoBufType</code></a> struct in which to store the results of the lookup. </dd>

<dt><a name="1084821"> </a><code>&rarr;  <i><code>timeout</code></i></code></dt>
<dd><a name="1084822"> </a>Maximum timeout in system ticks; -1 means wait forever. </dd>

<dt><a name="1084823"> </a><code>&larr;  <i><code>errP</code></i></code></dt>
<dd><a name="1084824"> </a>Contains an error code if the return value is 0.</dd>

</dl>
<h4>
  <a name="1084825"> </a>Returns 
</h4>

<p><a name="1084829"> </a>Returns a pointer to the <a href="NetLibrary.html#1083653"><code>NetHostInfoType</code></a> portion of <code>bufP</code> that contains results of the lookup. If the return value is 0, an error has occurred, and <code>errP</code> contains one of the following values:</p>

<dl>
<dt><a name="1084830"> </a><code>0</code></dt>
<dd><a name="1084831"> </a>No error</dd>

<dt><a name="1084833"> </a><code><code>netErrTimeout</code></code></dt>
<dd><a name="1084834"> </a>Call timed out. </dd>

<dt><a name="1084836"> </a><code><code>netErrNotOpen</code></code></dt>
<dd><a name="1084837"> </a>The referenced net library has not been opened yet. </dd>

<dt><a name="1084839"> </a><code>n<code>etErrDNSNameTooLong</code></code></dt>
<dt><a name="1084841"> </a><code><code>netErrDNSBadName</code></code></dt>
<dt><a name="1084843"> </a><code><code>netErrDNSLabelTooLong</code></code></dt>
<dt><a name="1084845"> </a><code><code>netErrDNSAllocationFailure</code></code></dt>
<dt><a name="1084847"> </a><code><code>netErrDNSTimeout</code></code></dt>
<dt><a name="1084849"> </a><code><code>netErrDNSUnreachable</code></code></dt>
<dt><a name="1084851"> </a><code><code>netErrDNSFormat</code></code></dt>
<dt><a name="1084853"> </a><code><code>netErrDNSServerFailure</code></code></dt>
<dt><a name="1084855"> </a><code><code>netErrDNSNonexistantName</code></code></dt>
<dt><a name="1084857"> </a><code><code>netErrDNSNIY</code></code></dt>
<dt><a name="1084859"> </a><code><code>netErrDNSRefused</code></code></dt>
<dt><a name="1084861"> </a><code><code>netErrDNSImpossible</code></code></dt>
<dt><a name="1084863"> </a><code><code>netErrDNSNoRRS</code></code></dt>
<dt><a name="1084865"> </a><code><code>netErrDNSAborted</code></code></dt>
<dt><a name="1084867"> </a><code><code>netErrDNSBadProtocol</code></code></dt>
<dt><a name="1084869"> </a><code><code>netErrDNSTruncated</code></code></dt>
<dt><a name="1084871"> </a><code><code>netErrDNSNoRecursion</code></code></dt>
<dt><a name="1084873"> </a><code><code>netErrDNSIrrelevant</code></code></dt>
<dt><a name="1084875"> </a><code><code>netErrDNSNotInLocalCache</code></code></dt>
<dt><a name="1084877"> </a><code><code>netErrDNSNoPort</code></code></dt>
</dl>
<h4>
  <a name="1084878"> </a>Sockets Equivalent
</h4>

<p><a name="1084879"> </a><code>struct hostent *gethostbyaddr (char *addr,<br>int len, int type);</code></p>
<h4>
  <a name="1084880"> </a>Comments 
</h4>

<p><a name="1084881"> </a>This call queries the domain name server(s) to look up a host name given its IP address.</p>
<h4>
  <a name="1084882"> </a>See Also 
</h4>

<p><a name="1084886"> </a><a href="NetLibrary.html#1084889"><code>NetLibGetHostByName()</code></a> </p>

<h3 class="hbH3">
  <a name="1084889"> </a>NetLibGetHostByName Function <a href="#1083561"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="1084891"> </a>Purpose 
</h4>

<p><a name="1084892"> </a>Looks up a host IP address given a host name.</p>
<h4>
  <a name="1084893"> </a>Declared In 
</h4>
<code>NetMgr.h<a name="1084894"> </a></code><h4>
  <a name="1084895"> </a>Prototype 
</h4>
<pre class="proto"><a name="1084897"></a>NetHostInfoPtr NetLibGetHostByName(
   UInt16 libRefNum,
   const Char *nameP,
   NetHostInfoBufPtr bufP,
   Int32 timeout,
   Err *errP
)
</pre>
<h4>
  <a name="1084898"> </a>Parameters 
</h4>

<dl>
<dt><a name="1084899"> </a><code>&rarr;  <i><code>libRefNum</code></i></code></dt>
<dd><a name="1084900"> </a>Reference number of the net library.</dd>

<dt><a name="1084901"> </a><code>&rarr;  <i><code>nameP</code></i></code></dt>
<dd><a name="1084902"> </a>Name of host to look up.</dd>

<dt><a name="1084903"> </a><code>&larr;  <i><code>bufP</code></i></code></dt>
<dd><a name="1084907"> </a>Pointer to a <a href="NetLibrary.html#1083608"><code>NetHostInfoBufType</code></a> struct in which to store the results of the lookup. </dd>

<dt><a name="1084908"> </a><code>&rarr;  <i><code>timeout</code></i></code></dt>
<dd><a name="1084909"> </a>Maximum timeout in system ticks; -1 means wait forever. </dd>

<dt><a name="1084910"> </a><code>&larr;  <i><code>errP</code></i></code></dt>
<dd><a name="1084911"> </a>Contains an error code if the return value is 0.</dd>

</dl>
<h4>
  <a name="1084912"> </a>Returns 
</h4>

<p><a name="1084916"> </a>Returns a pointer to the <a href="NetLibrary.html#1083653"><code>NetHostInfoType</code></a> portion of <code>bufP</code>, which contains results of the lookup. If the return value is 0, an error has occurred and <code>errP</code> contains one of the following values:</p>

<dl>
<dt><a name="1084917"> </a><code>0</code></dt>
<dd><a name="1084918"> </a>No error</dd>

<dt><a name="1084920"> </a><code><code>netErrTimeout</code></code></dt>
<dd><a name="1084921"> </a>Call timed out. </dd>

<dt><a name="1084923"> </a><code><code>netErrNotOpen</code></code></dt>
<dd><a name="1084924"> </a>The referenced net library has not been opened yet. </dd>

<dt><a name="1084926"> </a><code>n<code>etErrDNSNameTooLong</code></code></dt>
<dt><a name="1084928"> </a><code><code>netErrDNSBadName</code></code></dt>
<dt><a name="1084930"> </a><code><code>netErrDNSLabelTooLong</code></code></dt>
<dt><a name="1084932"> </a><code><code>netErrDNSAllocationFailure</code></code></dt>
<dt><a name="1084934"> </a><code><code>netErrDNSTimeout</code></code></dt>
<dt><a name="1084936"> </a><code><code>netErrDNSUnreachable</code></code></dt>
<dt><a name="1084938"> </a><code><code>netErrDNSFormat</code></code></dt>
<dt><a name="1084940"> </a><code><code>netErrDNSServerFailure</code></code></dt>
<dt><a name="1084942"> </a><code><code>netErrDNSNonexistantName</code></code></dt>
<dt><a name="1084944"> </a><code><code>netErrDNSNIY</code></code></dt>
<dt><a name="1084946"> </a><code><code>netErrDNSRefused</code></code></dt>
<dt><a name="1084948"> </a><code><code>netErrDNSImpossible</code></code></dt>
<dt><a name="1084950"> </a><code><code>netErrDNSNoRRS</code></code></dt>
<dt><a name="1084952"> </a><code><code>netErrDNSAborted</code></code></dt>
<dt><a name="1084954"> </a><code><code>netErrDNSBadProtocol</code></code></dt>
<dt><a name="1084956"> </a><code><code>netErrDNSTruncated</code></code></dt>
<dt><a name="1084958"> </a><code><code>netErrDNSNoRecursion</code></code></dt>
<dt><a name="1084960"> </a><code><code>netErrDNSIrrelevant</code></code></dt>
<dt><a name="1084962"> </a><code><code>netErrDNSNotInLocalCache</code></code></dt>
<dt><a name="1084964"> </a><code><code>netErrDNSNoPort</code></code></dt>
</dl>
<h4>
  <a name="1084965"> </a>Sockets Equivalent
</h4>

<p><a name="1084966"> </a><code>struct hostent *gethostbyname (char *name);</code></p>
<h4>
  <a name="1084967"> </a>Comments 
</h4>

<dl>
<dt><a name="1084968"> </a><code>&rarr;  <i>This call first checks the local name IP address host table in the net library preferences. If the entry is not found, it then queries the domain name server(s). </i></code></dt>
</dl>
<h4>
  <a name="1084969"> </a>See Also 
</h4>

<p><a name="1084975"> </a><a href="NetLibrary.html#1084795"><code>NetLibGetHostByAddr()</code></a>, <a href="NetLibrary.html#1084979"><code>NetLibGetMailExchangeByName()</code></a> </p>

<h3 class="hbH3">
  <a name="1084979"> </a>NetLibGetMailExchangeByName Function <a href="#1083561"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="1084981"> </a>Purpose 
</h4>

<p><a name="1084982"> </a>Looks up the name of a host to use for a given mail exchange. </p>
<h4>
  <a name="1084983"> </a>Declared In 
</h4>
<code>NetMgr.h<a name="1084984"> </a></code><h4>
  <a name="1084985"> </a>Prototype 
</h4>
<pre class="proto"><a name="1084987"></a>Int16 NetLibGetMailExchangeByName(
   UInt16 libRefNum,
   Char *mailNameP,
   UInt16 maxEntries,
   <span style="color: #000000;  font-style: normal; font-weight: normal; text-decoration: none; text-transform: none; vertical-align: baseline"> </span>Char hostNames[][255+1],
   UInt16 priorities[],
   Int32 timeout,
   Err *errP
)
</pre>
<h4>
  <a name="1084988"> </a>Parameters 
</h4>

<dl>
<dt><a name="1084989"> </a><code>&rarr;  <i><code>libRefNum</code></i></code></dt>
<dd><a name="1084990"> </a>Reference number of the net library.</dd>

<dt><a name="1084991"> </a><code>&rarr;  <i><code>mailNameP</code></i></code></dt>
<dd><a name="1084992"> </a>Name of the mail exchange to look up.</dd>

<dt><a name="1084993"> </a><code>&rarr;  <i><code>maxEntries</code></i></code></dt>
<dd><a name="1084994"> </a>Maximum number of host names to return.</dd>

<dt><a name="1084995"> </a><code>&larr;  <i><code>hostNames</code></i></code></dt>
<dd><a name="1084996"> </a>Array of character strings of length <code>255+1</code>. The host name results are stored in this array. This array must be able to hold at least <code>maxEntries</code> host names. </dd>

<dt><a name="1084997"> </a><code>&larr;  <i><code>priorities</code></i></code></dt>
<dd><a name="1084998"> </a>Array of <code>Word</code>s. The priorities of each host name found are stored in this array. This array must be at least <code>maxEntries</code> in length.</dd>

<dt><a name="1084999"> </a><code>&rarr;  <i><code>timeout</code></i></code></dt>
<dd><a name="1085000"> </a>Maximum timeout in system ticks; -1 means wait forever. </dd>

<dt><a name="1085001"> </a><code>&larr;  <i><code>errP</code></i></code></dt>
<dd><a name="1085002"> </a>Contains an error code if the return value is less than 0.</dd>

</dl>
<h4>
  <a name="1085003"> </a>Returns 
</h4>

<p><a name="1085004"> </a>Returns the number of entries successfully found. If the return value is a negative number, an error has occurred, and <code>errP</code> contains one of the following values:</p>

<dl>
<dt><a name="1085005"> </a><code>0</code></dt>
<dd><a name="1085006"> </a>No error</dd>

<dt><a name="1085008"> </a><code><code>netErrTimeout</code></code></dt>
<dd><a name="1085009"> </a>Call timed out. </dd>

<dt><a name="1085011"> </a><code><code>netErrNotOpen</code></code></dt>
<dd><a name="1085012"> </a>The referenced net library has not been opened yet. </dd>

<dt><a name="1085014"> </a><code><code>netErrDNSNameTooLong</code></code></dt>
<dt><a name="1085016"> </a><code><code>netErrDNSBadName</code></code></dt>
<dt><a name="1085018"> </a><code><code>netErrDNSLabelTooLong</code></code></dt>
<dt><a name="1085020"> </a><code><code>netErrDNSAllocationFailure</code></code></dt>
<dt><a name="1085022"> </a><code><code>netErrDNSTimeout</code></code></dt>
<dt><a name="1085024"> </a><code><code>netErrDNSUnreachable</code></code></dt>
<dt><a name="1085026"> </a><code><code>netErrDNSFormat</code></code></dt>
<dt><a name="1085028"> </a><code><code>netErrDNSServerFailure</code></code></dt>
<dt><a name="1085030"> </a><code><code>netErrDNSNonexistantName</code></code></dt>
<dt><a name="1085032"> </a><code><code>netErrDNSNIY</code></code></dt>
<dt><a name="1085034"> </a><code><code>netErrDNSRefused</code></code></dt>
<dt><a name="1085036"> </a><code><code>netErrDNSImpossible</code></code></dt>
<dt><a name="1085038"> </a><code><code>netErrDNSNoRRS</code></code></dt>
<dt><a name="1085040"> </a><code><code>netErrDNSAborted</code></code></dt>
<dt><a name="1085042"> </a><code><code>netErrDNSBadProtocol</code></code></dt>
<dt><a name="1085044"> </a><code><code>netErrDNSTruncated</code></code></dt>
<dt><a name="1085046"> </a><code><code>netErrDNSNoRecursion</code></code></dt>
<dt><a name="1085048"> </a><code><code>netErrDNSIrrelevant</code></code></dt>
<dt><a name="1085050"> </a><code><code>netErrDNSNotInLocalCache</code></code></dt>
<dt><a name="1085052"> </a><code><code>netErrDNSNoPort</code></code></dt>
</dl>
<h4>
  <a name="1085053"> </a>Sockets Equivalent
</h4>

<p><a name="1085054"> </a>None</p>
<h4>
  <a name="1085055"> </a>Comments 
</h4>

<p><a name="1085056"> </a>This call looks up the name(s) of host(s) to use for sending an e-mail. The caller passes the name of the mail exchange in <code>mailNameP</code> and gets back a list of host names to which the mail message can be sent. </p>
<h4>
  <a name="1085057"> </a>See Also 
</h4>

<p><a name="1085064"> </a><a href="NetLibrary.html#1084795"><code>NetLibGetHostByAddr()</code></a>, <a href="NetLibrary.html#1084889"><code>NetLibGetHostByName()</code></a> </p>

<h3 class="hbH3">
  <a name="1085067"> </a>NetLibGetServByName Function <a href="#1083561"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="1085069"> </a>Purpose 
</h4>

<p><a name="1085070"> </a>Looks up the port number for a standard TCP/IP service, given the desired protocol.</p>
<h4>
  <a name="1085071"> </a>Declared In 
</h4>
<code>NetMgr.h<a name="1085072"> </a></code><h4>
  <a name="1085073"> </a>Prototype 
</h4>
<pre class="proto"><a name="1085075"></a>NetServInfoPtr NetLibGetServByName(
   UInt16 libRefNum,
   const Char *servNameP,
   const Char *protoNameP,
   NetServInfoBufPtr bufP,
   Int32 timeout,
   Err *errP
)
</pre>
<h4>
  <a name="1085076"> </a>Parameters 
</h4>

<dl>
<dt><a name="1085077"> </a><code>&rarr;  <i><code>libRefNum</code></i></code></dt>
<dd><a name="1085078"> </a>Reference number of the net library.</dd>

<dt><a name="1085079"> </a><code>&rarr;  <i><code>servNameP</code></i></code></dt>
<dd><a name="1085080"> </a>Name of the service to look up. Possible services are "echo", "discard", "daytime", "qotd", "chargen", "ftp-data", "ftp", "telnet", "smtp", "time", "name", "finger", "pop2", "pop3", "nntp", "imap2".</dd>

<dt><a name="1085081"> </a><code>&rarr;  <i><code>protoNameP</code></i></code></dt>
<dd><a name="1085082"> </a>Desired protocol to use, either "udp" or "tcp". </dd>

<dt><a name="1085083"> </a><code>&larr;  <i><code>bufP</code></i></code></dt>
<dd><a name="1085087"> </a>Pointer to a <a href="NetLibrary.html#1083695"><code>NetServInfoBufType</code></a> struct in which to store the results of the lookup. </dd>

<dt><a name="1085088"> </a><code>&rarr;  <i><code>timeout</code></i></code></dt>
<dd><a name="1085089"> </a>Maximum timeout in system ticks; -1 means wait forever. </dd>

<dt><a name="1085090"> </a><code>&larr;  <i><code>errP</code></i></code></dt>
<dd><a name="1085091"> </a>Contains an error code if the return value is 0.</dd>

</dl>
<h4>
  <a name="1085092"> </a>Returns 
</h4>

<p><a name="1085096"> </a>Returns a pointer to the <a href="NetLibrary.html#1083741"><code>NetServInfoType</code></a> portion of <code>bufP</code> that contains results of the lookup. If the return value is 0, and error has occurred and <code>errP</code> contains one of the following values:</p>

<dl>
<dt><a name="1085097"> </a><code>0</code></dt>
<dd><a name="1085098"> </a>No error</dd>

<dt><a name="1085100"> </a><code><code>netErrTimeout</code></code></dt>
<dd><a name="1085101"> </a>Call timed out. </dd>

<dt><a name="1085103"> </a><code><code>netErrNotOpen</code></code></dt>
<dd><a name="1085104"> </a>The referenced net library has not been opened yet. </dd>

<dt><a name="1085106"> </a><code><code>netErrUnknownProtocol</code></code></dt>
<dt><a name="1085108"> </a><code><code>netErrUnknownService</code></code></dt>
</dl>
<h4>
  <a name="1085109"> </a>Sockets Equivalent
</h4>

<p><a name="1085110"> </a><code>struct servent *getservbyname (char *addr,<br>char *proto);</code></p>
<h4>
  <a name="1085111"> </a>Comments 
</h4>

<p><a name="1085112"> </a>This call is a convenience call for looking up a standard port number given the name of a service and the protocol to use. </p>
<h4>
  <a name="1085113"> </a>See Also 
</h4>

<p><a name="1085117"> </a><a href="NetLibrary.html#1084889"><code>NetLibGetHostByName()</code></a> </p>

<h3 class="hbH3">
  <a name="1085120"> </a>NetLibIFAttach Function <a href="#1083561"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="1085122"> </a>Purpose 
</h4>

<p><a name="1085123"> </a>Attach a new network interface.</p>
<h4>
  <a name="1085124"> </a>Declared In 
</h4>
<code>NetMgr.h<a name="1085125"> </a></code><h4>
  <a name="1085126"> </a>Prototype 
</h4>
<pre class="proto"><a name="1085128"></a>Err NetLibIFAttach (
   UInt16 libRefNum,
   UInt32 ifCreator,
   UInt16 ifInstance,
   Int32 timeout
)
</pre>
<h4>
  <a name="1085129"> </a>Parameters 
</h4>

<dl>
<dt><a name="1085130"> </a><code>&rarr;  <i><code>libRefNum</code></i></code></dt>
<dd><a name="1085131"> </a>Reference number of the net library.</dd>

<dt><a name="1085132"> </a><code>&rarr;  <i><code>ifCreator</code></i></code></dt>
<dd><a name="1085133"> </a>Creator of interface to attach.</dd>

<dt><a name="1085134"> </a><code>&rarr;  <i><code>ifInstance</code></i></code></dt>
<dd><a name="1085135"> </a>Instance number of interface to attach. The instance number is one of the values returned by <a href="NetLibrary.html#1085260"><code>NetLibIFGet()</code></a>. </dd>

<dt><a name="1085139"> </a><code>&rarr;  <i><code>timeout</code></i></code></dt>
<dd><a name="1085140"> </a>Timeout in ticks; -1 means infinite timeout.</dd>

</dl>
<h4>
  <a name="1085141"> </a>Returns 
</h4>

<p><a name="1085142"> </a>Returns one of the following values:</p>

<dl>
<dt><a name="1085143"> </a><code>0</code></dt>
<dd><a name="1085144"> </a>Success.</dd>

<dt><a name="1085146"> </a><code><code>netErrInterfaceNotFound</code></code></dt>
<dt><a name="1085148"> </a><code><code>netErrTooManyInterfaces</code></code></dt>
</dl>
<h4>
  <a name="1085149"> </a>Sockets Equivalent
</h4>

<p><a name="1085150"> </a>None</p>
<h4>
  <a name="1085151"> </a>Comments 
</h4>

<p><a name="1085152"> </a>This call can be used to attach a new network interface to the net library. Network interfaces are self-contained databases of type <code>'neti'</code>. The <code>ifCreator</code> parameter to this function is used to locate the network interface database of the given creator. </p>

<p><a name="1085153"> </a>If the net library is already open when this call is made, the network interface's database will be located and then called to initialize itself and attach itself to the protocol stack in real time. If the net library is not open when this call is made, the creator and instance number of the interface are stored in the active configuration. You need to save the active configuration using <a href="NetLibrary.html#1084615"><code>NetLibConfigSaveAs()</code></a> if you want the interface to be initialized and attached to the stack the next time the net library is opened. </p>
<h4>
  <a name="1085157"> </a>See Also 
</h4>

<p><a name="1085164"> </a><a href="NetLibrary.html#1085260"><code>NetLibIFGet()</code></a>, <a href="NetLibrary.html#1085167"><code>NetLibIFDetach()</code></a> </p>

<h3 class="hbH3">
  <a name="1085167"> </a>NetLibIFDetach Function <a href="#1083561"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="1085169"> </a>Purpose 
</h4>

<p><a name="1085170"> </a>Detach a network interface from the protocol stack.</p>
<h4>
  <a name="1085171"> </a>Declared In 
</h4>
<code>NetMgr.h<a name="1085172"> </a></code><h4>
  <a name="1085173"> </a>Prototype 
</h4>
<pre class="proto"><a name="1085175"></a>Err NetLibIFDetach (
   UInt16 libRefNum,
   UInt32 ifCreator,
   UInt16 ifInstance,
   Int32 timeout
)
</pre>
<h4>
  <a name="1085176"> </a>Parameters 
</h4>

<dl>
<dt><a name="1085177"> </a><code>&rarr;  <i><code>libRefNum</code></i></code></dt>
<dd><a name="1085178"> </a>Reference number of the net library.</dd>

<dt><a name="1085179"> </a><code>&rarr;  <i><code>ifCreator</code></i></code></dt>
<dd><a name="1085180"> </a>Creator of interface to detach.</dd>

<dt><a name="1085181"> </a><code>&rarr;  <i><code>ifInstance</code></i></code></dt>
<dd><a name="1085182"> </a>Instance number of interface to detach.</dd>

<dt><a name="1085183"> </a><code>&rarr;  <i><code>timeout</code></i></code></dt>
<dd><a name="1085184"> </a>Timeout in ticks; -1 means infinite timeout.</dd>

</dl>
<h4>
  <a name="1085185"> </a>Returns 
</h4>

<p><a name="1085186"> </a>Returns one of the following values:</p>

<dl>
<dt><a name="1085187"> </a><code>0</code></dt>
<dd><a name="1085188"> </a>Success.</dd>

<dt><a name="1085190"> </a><code><code>netErrInterfaceNotFound</code></code></dt>
</dl>
<h4>
  <a name="1085191"> </a>Sockets Equivalent
</h4>

<p><a name="1085192"> </a>None</p>
<h4>
  <a name="1085193"> </a>Comments 
</h4>

<p><a name="1085194"> </a>If the net library is already open when this call is made, the interface is brought down and detached from the protocol stack in real time. If the net library is not open when this call is made, the creator and instance number of the interface are removed from the active configuration. You need to save the active configuration using <a href="NetLibrary.html#1084615"><code>NetLibConfigSaveAs()</code></a> if you don't want the interface to be attached the next time the library is opened. </p>
<h4>
  <a name="1085198"> </a>See Also 
</h4>

<p><a name="1085205"> </a><a href="NetLibrary.html#1085260"><code>NetLibIFGet()</code></a>, <a href="NetLibrary.html#1085120"><code>NetLibIFAttach()</code></a> </p>

<h3 class="hbH3">
  <a name="1085208"> </a>NetLibIFDown Function <a href="#1083561"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="1085210"> </a>Purpose 
</h4>

<p><a name="1085211"> </a>Bring an interface down and hang up a connection.</p>
<h4>
  <a name="1085212"> </a>Declared In 
</h4>
<code>NetMgr.h<a name="1085213"> </a></code><h4>
  <a name="1085214"> </a>Prototype 
</h4>
<pre class="proto"><a name="1085216"></a>Err NetLibIFDown (
   UInt16 libRefNum,
   UInt32 ifCreator,
   UInt16 ifInstance,
   Int32 timeout
)
</pre>
<h4>
  <a name="1085217"> </a>Parameters 
</h4>

<dl>
<dt><a name="1085218"> </a><code>&rarr;  <i><code>libRefNum</code></i></code></dt>
<dd><a name="1085219"> </a>Reference number of the net library.</dd>

<dt><a name="1085220"> </a><code>&rarr;  <i><code>ifCreator</code></i></code></dt>
<dd><a name="1085221"> </a>Creator of interface to attach.</dd>

<dt><a name="1085222"> </a><code>&rarr;  <i><code>ifInstance</code></i></code></dt>
<dd><a name="1085223"> </a>Instance number of interface to attach.</dd>

<dt><a name="1085224"> </a><code>&rarr;  <i><code>timeout</code></i></code></dt>
<dd><a name="1085225"> </a>Timeout in ticks; -1 means wait forever.</dd>

</dl>
<h4>
  <a name="1085226"> </a>Returns 
</h4>

<p><a name="1085227"> </a>Returns one of the following values:</p>

<dl>
<dt><a name="1085228"> </a><code>0</code></dt>
<dd><a name="1085229"> </a>Success.</dd>

<dt><a name="1085231"> </a><code><code>netErrNotOpen</code></code></dt>
<dd><a name="1085232"> </a>The referenced net library has not been opened yet. </dd>

<dt><a name="1085234"> </a><code><code>netErrInterfaceNotFound</code></code></dt>
</dl>
<h4>
  <a name="1085235"> </a>Sockets Equivalent
</h4>

<p><a name="1085236"> </a>None</p>
<h4>
  <a name="1085237"> </a>Comments 
</h4>

<p><a name="1085238"> </a>The net library must be open before this call can be made. For dial-up interfaces, this call terminates a connection and hangs up the modem if necessary. </p>

<p><a name="1085242"> </a><a href="NetLibrary.html#1084184"><code>NetLibClose()</code></a> automatically brings down any attached interfaces, so this routine doesn't normally have to be called. </p>

<p><a name="1085243"> </a>If the interface is already down, this routine returns immediately with no error. </p>
<h4>
  <a name="1085244"> </a>See Also 
</h4>

<p><a name="1085254"> </a><a href="NetLibrary.html#1085260"><code>NetLibIFGet()</code></a>, <a href="NetLibrary.html#1085120"><code>NetLibIFAttach()</code></a>, <a href="NetLibrary.html#1085167"><code>NetLibIFDetach()</code></a>, <a href="NetLibrary.html#1085807"><code>NetLibIFUp()</code></a> </p>

<h3 class="hbH3">
  <a name="1085260"> </a>NetLibIFGet Function <a href="#1083561"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="1085262"> </a>Purpose 
</h4>

<p><a name="1085263"> </a>Get the creator and instance number of an installed interface by index.</p>
<h4>
  <a name="1085264"> </a>Declared In 
</h4>
<code>NetMgr.h<a name="1085265"> </a></code><h4>
  <a name="1085266"> </a>Prototype 
</h4>
<pre class="proto"><a name="1085268"></a>Err NetLibIFGet (
   UInt16 libRefNum,
   UInt16 index,
   UInt32 *ifCreatorP,
   UInt16 *ifInstanceP
)
</pre>
<h4>
  <a name="1085269"> </a>Parameters 
</h4>

<dl>
<dt><a name="1085270"> </a><code>&rarr;  <i><code>libRefNum</code></i></code></dt>
<dd><a name="1085271"> </a>Reference number of the net library.</dd>

<dt><a name="1085272"> </a><code>&rarr;  <i><code>index</code></i></code></dt>
<dd><a name="1085273"> </a>Index of the interface to get. Indices start at 0.</dd>

<dt><a name="1085274"> </a><code>&larr;  <i><code>ifCreatorP</code></i></code></dt>
<dd><a name="1085275"> </a>The interface's creator.</dd>

<dt><a name="1085276"> </a><code>&larr;  <i><code>ifInstanceP</code></i></code></dt>
<dd><a name="1085277"> </a>The interface's instance number.</dd>

</dl>
<h4>
  <a name="1085278"> </a>Returns 
</h4>

<p><a name="1085279"> </a>Returns one of the following values:</p>

<dl>
<dt><a name="1085280"> </a><code>0</code></dt>
<dd><a name="1085281"> </a>Success.</dd>

<dt><a name="1085283"> </a><code><code>netErrInvalidInterface</code></code></dt>
<dd><a name="1085284"> </a>Index too high</dd>

<dt><a name="1085286"> </a><code><code>netErrPrefNotFound</code></code></dt>
<dd><a name="1085287"> </a>No current value for setting.</dd>

</dl>
<h4>
  <a name="1085288"> </a>Sockets Equivalent
</h4>

<p><a name="1085289"> </a>None</p>
<h4>
  <a name="1085290"> </a>Comments 
</h4>

<p><a name="1085291"> </a>To get a list of all installed interfaces, call this function with successively increasing indices starting from 0 until the error <code>netErrInvalidInterface</code> is returned. </p>

<p><a name="1085292"> </a>The <code>ifCreator</code> and <code>ifInstance</code> values returned from this call can then be used with the <a href="NetLibrary.html#1086876"><code>NetLibSettingGet()</code></a> call to get more information about that particular interface. </p>
<h4>
  <a name="1085296"> </a>See Also 
</h4>

<p><a name="1085305"> </a><a href="NetLibrary.html#1085120"><code>NetLibIFAttach()</code></a>, <a href="NetLibrary.html#1085167"><code>NetLibIFDetach()</code></a>, "<a href="../PalmOSCompanion2/NetworkCommunication.html#1021507"><code>Settings for Interface Selection</code></a>" in the <i>Palm OS Programmer's Companion</i>, vol. II, <i>Communications</i> </p>

<h3 class="hbH3">
  <a name="1085312"> </a>NetLibIFSettingGet Function <a href="#1083561"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="1085314"> </a>Purpose 
</h4>

<p><a name="1085315"> </a>Retrieves a network interface specific setting.</p>
<h4>
  <a name="1085316"> </a>Declared In 
</h4>
<code>NetMgr.h<a name="1085317"> </a></code><h4>
  <a name="1085318"> </a>Prototype 
</h4>
<pre class="proto"><a name="1085320"></a>Err NetLibIFSettingGet (
   UInt16 libRefNum,
   UInt32 ifCreator,
   UInt16 ifInstance,
   UInt16 setting,
   void *valueP,
   UInt16 *valueLenP
)
</pre>
<h4>
  <a name="1085321"> </a>Parameters 
</h4>

<dl>
<dt><a name="1085322"> </a><code>&rarr;  <i><code>libRefNum</code></i></code></dt>
<dd><a name="1085323"> </a>Reference number of the net library.</dd>

<dt><a name="1085324"> </a><code>&rarr;  <i><code>ifCreator</code></i></code></dt>
<dd><a name="1085325"> </a>Creator of the network interface.</dd>

<dt><a name="1085326"> </a><code>&rarr;  <i><code>ifInstance</code></i></code></dt>
<dd><a name="1085327"> </a>Instance number of the network interface.</dd>

<dt><a name="1085328"> </a><code>&rarr;  <i><code>setting</code></i></code></dt>
<dd><a name="1085330"> </a>Setting to retrieve; one of the <code>NetIFSettingEnum</code> constants.</dd>

<dt><a name="1085331"> </a><code>&larr;  <i><code>valueP</code></i></code></dt>
<dd><a name="1085332"> </a>Space for return value of setting.</dd>

<dt><a name="1085333"> </a><code>&harr;  <i><code>valueLenP</code></i></code></dt>
<dd><a name="1085334"> </a>On entry, size of <code>valueP</code>. On exit, actual size of setting.</dd>

</dl>
<h4>
  <a name="1085335"> </a>Returns 
</h4>

<p><a name="1085336"> </a>Returns one of the following values:</p>

<dl>
<dt><a name="1085337"> </a><code>0</code></dt>
<dd><a name="1085338"> </a>Success.</dd>

<dt><a name="1085340"> </a><code><code>netErrUnknownSetting</code></code></dt>
<dd><a name="1085341"> </a>Invalid setting constant.</dd>

<dt><a name="1085343"> </a><code><code>netErrPrefNotFound</code></code></dt>
<dd><a name="1085344"> </a>No current value for setting.</dd>

<dt><a name="1085346"> </a><code><code>netErrBufTooSmall</code></code></dt>
<dd><a name="1085347"> </a><code>valueP</code> was too small to hold entire setting. Setting value was truncated to fit in <code>valueP</code>.</dd>

<dt><a name="1085349"> </a><code><code>netErrUnimplemented</code></code></dt>
<dt><a name="1085351"> </a><code><code>netErrInterfaceNotFound</code></code></dt>
<dt><a name="1085353"> </a><code><code>netErrBufWrongSize</code></code></dt>
</dl>
<h4>
  <a name="1085354"> </a>Sockets Equivalent
</h4>

<p><a name="1085355"> </a>None</p>
<h4>
  <a name="1085356"> </a>Comments 
</h4>

<p><a name="1085357"> </a>This call can be used to retrieve the current value of any network interface setting. The caller must pass a pointer to a buffer to hold the return value (value<code>P</code>), the size of the buffer (<code>*valueLenP</code>), and the setting ID (<code>setting</code>). The setting ID is one of the constants in the <code>NetIFSettingEnum</code> type. </p>

<p><a name="1085359"> </a>Some settings, such as the login script, are variable size. For these types of settings, you can obtain the actual size required for the buffer by passing 0 for <code>*valueLenP</code>. The required size is returned in <code>valueLenP</code>. </p>

<p><a name="1085363"> </a><a href="NetLibrary.html#1085370">Table 66.2</a> lists the network interface settings and the size of each setting. Some are only applicable to certain types of interfaces. Settings not applicable to a specific interface can be safely ignored and not set to any particular value.</p>

<p class="caption"><a name="1085370"> </a><b>Table 66.2&nbsp;&nbsp;Network Interface Settings </b></p>
<div class="tablediv"><table cellspacing="0" class="tTable">

  <tr valign="top">
    <th><p class="tt"><a name="1085376"> </a><b>netIFSetting...</b></p>
    </th>
    <th><p class="tt"><a name="1085378"> </a><b>Type</b></p>
    </th>
    <th><p class="tt"><a name="1085380"> </a><b>Description</b></p>
    </th>
  </tr>
  <tr valign="top">
    <td><p class="tt"><a name="1085382"> </a><code>ResetAll</code></p>
    </td>
    <td><p class="tt"><a name="1085384"> </a><code>void</code></p>
    </td>
    <td><p class="tt"><a name="1085389"> </a>Use with <a href="NetLibrary.html#1085735"><code>NetLibIFSettingSet()</code></a> only. This clears all other settings for the interface to their default values.</p>
    </td>
  </tr>
  <tr valign="top">
    <td><p class="tt"><a name="1085391"> </a><code>Up</code></p>
    </td>
    <td><p class="tt"><a name="1085393"> </a><code>UInt8</code></p>
    </td>
    <td><p class="tt"><a name="1085395"> </a>Read-only. <code>true</code> if interface is currently up.</p>
    </td>
  </tr>
  <tr valign="top">
    <td><p class="tt"><a name="1085397"> </a><code>Name</code></p>
    </td>
    <td><p class="tt"><a name="1085399"> </a><code>Char[32]</code></p>
    </td>
    <td><p class="tt"><a name="1085401"> </a>Read-only. Name of this interface.</p>
    </td>
  </tr>
  <tr valign="top">
    <td><p class="tt"><a name="1085403"> </a><code>ReqIPAddr</code></p>
    </td>
    <td><p class="tt"><a name="1085405"> </a><code>UInt32</code></p>
    </td>
    <td><p class="tt"><a name="1085407"> </a>IP address of interface. </p>
    </td>
  </tr>
  <tr valign="top">
    <td><p class="tt"><a name="1085409"> </a><code>SubnetMask</code></p>
    </td>
    <td><p class="tt"><a name="1085411"> </a><code>UInt32</code></p>
    </td>
    <td><p class="tt"><a name="1085413"> </a>Subnet mask for interface. Doesn't need to be specified for PPP or SLIP type connections.</p>
    </td>
  </tr>
  <tr valign="top">
    <td><p class="tt"><a name="1085415"> </a><code>Broadcast</code></p>
    </td>
    <td><p class="tt"><a name="1085417"> </a><code>UInt32</code></p>
    </td>
    <td><p class="tt"><a name="1085419"> </a>Broadcast address for interface. Doesn't need to be specified for PPP or SLIP type connections.</p>
    </td>
  </tr>
  <tr valign="top">
    <td><p class="tt"><a name="1085421"> </a><code>Username</code></p>
    </td>
    <td><p class="tt"><a name="1085423"> </a><code>Char[32]</code></p>
    </td>
    <td><p class="tt"><a name="1085425"> </a>User name. Only required if the login script uses the user name substitution escape sequence in it. Call <a href="NetLibrary.html#1085735"><code>NetLibIFSettingSet()</code></a> with a <code>valueLen</code> of 0 to remove this setting. </p>
    </td>
  </tr>
  <tr valign="top">
    <td><p class="tt"><a name="1085430"> </a><code>Password</code></p>
    </td>
    <td><p class="tt"><a name="1085432"> </a><code>Char[32]</code></p>
    </td>
    <td><p class="tt"><a name="1085434"> </a>Password. Only required if the login script uses the password substitution escape sequence in it. Call <a href="NetLibrary.html#1085735"><code>NetLibIFSettingSet()</code></a> with a <code>valueLen</code> of 0 to remove this setting. If the login script uses password substitution and no password setting is set, the user will be prompted for a password at connect time. </p>
    </td>
  </tr>
  <tr valign="top">
    <td><p class="tt"><a name="1085439"> </a><code>AuthUsername</code></p>
    </td>
    <td><p class="tt"><a name="1085441"> </a><code>Char[32]</code></p>
    </td>
    <td><p class="tt"><a name="1085443"> </a>Authentication user name. Only required if the authentication protocol uses a different user name than the what's in the <code>netIFSettingUsername</code> setting. If this setting is empty (<code>valueLen</code> of 0), the Username setting will be used instead. Call <a href="NetLibrary.html#1085735"><code>NetLibIFSettingSet()</code></a> with a <code>valueLen</code> of 0 to remove this setting. </p>
    </td>
  </tr>
  <tr valign="top">
    <td><p class="tt"><a name="1085448"> </a><code>AuthPassword</code></p>
    </td>
    <td><p class="tt"><a name="1085450"> </a><code>Char[32]</code></p>
    </td>
    <td><p class="tt"><a name="1085452"> </a>Authentication password. If "$" then the user will be prompted for the authentication password at connect time. Else, if 0 length, then the <code>netIFSettingPassword</code> setting or the result of its prompt will be used instead. Call <a href="NetLibrary.html#1085735"><code>NetLibIFSettingSet()</code></a> with a <code>valueLen</code> of 0 to remove this setting. </p>
    </td>
  </tr>
  <tr valign="top">
    <td><p class="tt"><a name="1085457"> </a><code>ServiceName</code></p>
    </td>
    <td><p class="tt"><a name="1085459"> </a><code>Char[]</code></p>
    </td>
    <td><p class="tt"><a name="1085461"> </a>Service name. Used for display purposes while showing the connection progress dialog box. Call <a href="NetLibrary.html#1085735"><code>NetLibIFSettingSet()</code></a> with a <code>valueLen</code> of 0 to remove this setting. </p>
    </td>
  </tr>
  <tr valign="top">
    <td><p class="tt"><a name="1085466"> </a><code>LoginScript</code></p>
    </td>
    <td><p class="tt"><a name="1085468"> </a><code>Char[]</code></p>
    </td>
    <td><p class="tt"><a name="1085470"> </a>Login script. Only required if the particular service requires a login sequence. Call <a href="NetLibrary.html#1085735"><code>NetLibIFSettingSet()</code></a> with a <code>valueLen</code> of 0 to remove this setting. See below for a description of the login script format.</p>
    </td>
  </tr>
  <tr valign="top">
    <td><p class="tt"><a name="1085475"> </a><code>ConnectLog</code></p>
    </td>
    <td><p class="tt"><a name="1085477"> </a><code>Char[]</code></p>
    </td>
    <td><p class="tt"><a name="1085479"> </a>Connect log. Generally, this setting is just retrieved, not set. It contains a log of events from the most recent login. To clear this setting, call <a href="NetLibrary.html#1085735"><code>NetLibIFSettingSet()</code></a> with a <code>valueLen</code> of 0. </p>
    </td>
  </tr>
  <tr valign="top">
    <td><p class="tt"><a name="1085484"> </a><code>InactivityTimeout</code></p>
    </td>
    <td><p class="tt"><a name="1085486"> </a><code>UInt16</code></p>
    </td>
    <td><p class="tt"><a name="1085488"> </a>Maximum number of seconds of inactivity allowed. Set to 0 to ignore. </p>
    </td>
  </tr>
  <tr valign="top">
    <td><p class="tt"><a name="1085490"> </a><code>EstablishmentTimeout</code></p>
    </td>
    <td><p class="tt"><a name="1085492"> </a><code>UInt16</code></p>
    </td>
    <td><p class="tt"><a name="1085494"> </a>Maximum delay, in seconds, allowed between each stage of connection establishment or login script line. Must be non-zero. </p>
    </td>
  </tr>
  <tr valign="top">
    <td><p class="tt"><a name="1085496"> </a><code>DynamicIP</code></p>
    </td>
    <td><p class="tt"><a name="1085498"> </a><code>UInt8</code></p>
    </td>
    <td><p class="tt"><a name="1085500"> </a>If non-zero, negotiate for an IP address. If zero, the IP address specified in the <code>netIFSettingReqIPAddr</code> setting will be used. Default is <code>false</code>. </p>
    </td>
  </tr>
  <tr valign="top">
    <td><p class="tt"><a name="1085502"> </a><code>VJCompEnable</code></p>
    </td>
    <td><p class="tt"><a name="1085504"> </a><code>UInt8</code></p>
    </td>
    <td><p class="tt"><a name="1085506"> </a>If non-zero, enable VJ header compression. Default is <code>true</code> for PPP, <code>false</code> for SLIP, and <code>true</code> for CSLIP. </p>
    </td>
  </tr>
  <tr valign="top">
    <td><p class="tt"><a name="1085508"> </a><code>VJCompSlots</code></p>
    </td>
    <td><p class="tt"><a name="1085510"> </a><code>UInt8</code></p>
    </td>
    <td><p class="tt"><a name="1085512"> </a>Number of slots to use for VJ compression. Default is 4 for PPP and 16 for SLIP and CSLIP. More slots require more memory so it is best to keep this number to a minimum. </p>
    </td>
  </tr>
  <tr valign="top">
    <td><p class="tt"><a name="1085514"> </a><code>MTU</code></p>
    </td>
    <td><p class="tt"><a name="1085516"> </a><code>UInt16</code></p>
    </td>
    <td><p class="tt"><a name="1085518"> </a>Maximum transmission unit in octets. Currently not implemented in SLIP or PPP.</p>
    </td>
  </tr>
  <tr valign="top">
    <td><p class="tt"><a name="1085520"> </a><code>AsyncCtlMap</code></p>
    </td>
    <td><p class="tt"><a name="1085522"> </a><code>UInt32</code></p>
    </td>
    <td><p class="tt"><a name="1085524"> </a>Bit mask of characters to escape for PPP. Default is 0.</p>
    </td>
  </tr>
  <tr valign="top">
    <td><p class="tt"><a name="1085526"> </a><code>PortNum</code></p>
    </td>
    <td><p class="tt"><a name="1085528"> </a><code>UInt16</code></p>
    </td>
    <td><p class="tt"><a name="1085530"> </a>Which serial communication port to use. Port 0 is the only port available on the device. </p>
    </td>
  </tr>
  <tr valign="top">
    <td><p class="tt"><a name="1085532"> </a><code>BaudRate</code></p>
    </td>
    <td><p class="tt"><a name="1085534"> </a><code>UInt32</code></p>
    </td>
    <td><p class="tt"><a name="1085536"> </a>Serial port baud rate to use in bits per second. </p>
    </td>
  </tr>
  <tr valign="top">
    <td><p class="tt"><a name="1085538"> </a><code>FlowControl</code></p>
    </td>
    <td><p class="tt"><a name="1085540"> </a><code>UInt8</code></p>
    </td>
    <td><p class="tt"><a name="1085542"> </a>If bit 0 is 1, use hardware handshaking on the serial port. Default is no hardware handshaking. </p>
    </td>
  </tr>
  <tr valign="top">
    <td><p class="tt"><a name="1085544"> </a><code>StopBits</code></p>
    </td>
    <td><p class="tt"><a name="1085546"> </a><code>UInt8</code></p>
    </td>
    <td><p class="tt"><a name="1085548"> </a>Number of stop bits. Default is 1.</p>
    </td>
  </tr>
  <tr valign="top">
    <td><p class="tt"><a name="1085550"> </a><code>ParityOn</code></p>
    </td>
    <td><p class="tt"><a name="1085552"> </a><code>UInt8</code></p>
    </td>
    <td><p class="tt"><a name="1085554"> </a><code>true</code> if parity detection enabled. Default is <code>false</code>.</p>
    </td>
  </tr>
  <tr valign="top">
    <td><p class="tt"><a name="1085556"> </a><code>ParityEven</code></p>
    </td>
    <td><p class="tt"><a name="1085558"> </a><code>UInt8</code></p>
    </td>
    <td><p class="tt"><a name="1085560"> </a><code>true</code> for even parity detection. Default is <code>true</code>.</p>
    </td>
  </tr>
  <tr valign="top">
    <td><p class="tt"><a name="1085562"> </a><code>UseModem</code></p>
    </td>
    <td><p class="tt"><a name="1085564"> </a><code>UInt8</code></p>
    </td>
    <td><p class="tt"><a name="1085566"> </a>If <code>true</code>, dial-up through modem. If <code>false</code>, go direct over serial port</p>
    </td>
  </tr>
  <tr valign="top">
    <td><p class="tt"><a name="1085568"> </a><code>PulseDial</code></p>
    </td>
    <td><p class="tt"><a name="1085570"> </a><code>UInt8</code></p>
    </td>
    <td><p class="tt"><a name="1085572"> </a>If <code>true</code>, pulse dial modem. Else, tone dial. Default is tone dial.</p>
    </td>
  </tr>
  <tr valign="top">
    <td><p class="tt"><a name="1085574"> </a><code>ModemInit</code></p>
    </td>
    <td><p class="tt"><a name="1085576"> </a><code>Char[]</code></p>
    </td>
    <td><p class="tt"><a name="1085578"> </a>Zero-terminated modem initialization string, not including the "AT". If not specified (<code>valueLen</code> of 0), the modem initialization string from system preferences are used.</p>
    </td>
  </tr>
  <tr valign="top">
    <td><p class="tt"><a name="1085580"> </a><code>ModemPhone</code></p>
    </td>
    <td><p class="tt"><a name="1085582"> </a><code>Char[]</code></p>
    </td>
    <td><p class="tt"><a name="1085584"> </a>Zero-terminated modem phone number string. Only required if <code>netIFSettingUseModem</code> is true.</p>
    </td>
  </tr>
  <tr valign="top">
    <td><p class="tt"><a name="1085586"> </a><code>RedialCount</code></p>
    </td>
    <td><p class="tt"><a name="1085588"> </a><code>UInt16</code></p>
    </td>
    <td><p class="tt"><a name="1085590"> </a>Number of times to re-dial modem when trying to establish a connection. Only required if <code>netIFSettingUseModem</code> is true.</p>
    </td>
  </tr>
  <tr valign="top">
    <td><p class="tt"><a name="1085592"> </a><code>DNSQuery</code></p>
    </td>
    <td><p class="tt"><a name="1085594"> </a><code>UInt8</code></p>
    </td>
    <td><p class="tt"><a name="1085596"> </a><code>true</code> if PPP queries for DNS address. The default is <code>true</code>. </p>
    </td>
  </tr>
  <tr valign="top">
    <td><p class="tt"><a name="1085598"> </a><code>TraceBits</code></p>
    </td>
    <td><p class="tt"><a name="1085600"> </a><code>UInt32</code></p>
    </td>
    <td><p class="tt"><a name="1085604"> </a>A bitfield of various trace bits. See "<a href="NetLibrary.html#1154363"><code>Tracing Bits</code></a>."</p>
<p class="tt"><a name="1085606"> </a>An application can get a list of events in the trace buffer using the <a href="NetLibrary.html#1085869"><code>NetLibMaster()</code></a> call. Each interface has its own trace bits setting so that trace event recording in each interface can be selectively enabled or disabled. </p>
    </td>
  </tr>
  <tr valign="top">
    <td><p class="tt"><a name="1085611"> </a><code>ActualIPAddr</code></p>
    </td>
    <td><p class="tt"><a name="1085613"> </a><code>UInt32</code></p>
    </td>
    <td><p class="tt"><a name="1085615"> </a>Read-only. The actual IP address that the interface ends up using. The login script execution engine stores the result of the "g" (get IP address) command here as does the PPP negotiation logic.</p>
    </td>
  </tr>
  <tr valign="top">
    <td><p class="tt"><a name="1085617"> </a><code>ServerIPAddr</code></p>
    </td>
    <td><p class="tt"><a name="1085619"> </a><code>UInt32</code></p>
    </td>
    <td><p class="tt"><a name="1085621"> </a>Read-only. The IP address of the PPP server we're connected to. </p>
    </td>
  </tr>
  <tr valign="top">
    <td><p class="tt"><a name="1085623"> </a><code>BringDownOnPowerDown</code></p>
    </td>
    <td><p class="tt"><a name="1085625"> </a><code>UInt8</code></p>
    </td>
    <td><p class="tt"><a name="1085627"> </a><code>true</code> if the interface is brought down when the Palm OS device is turned off. </p>
    </td>
  </tr>
  <tr valign="top">
    <td><p class="tt"><a name="1085629"> </a><code>RawMode</code></p>
    </td>
    <td><p class="tt"><a name="1085631"> </a><code>UInt32</code></p>
    </td>
    <td><p class="tt"><a name="1085633"> </a>Specifies if the interface is in raw mode. The net library places an interface in raw mode when it is bound to a raw socket in the raw domain. Raw sockets are available in Palm OS version 3.0 and higher. </p>
    </td>
  </tr>
  <tr valign="top">
    <td><p class="tt"><a name="1085635"> </a>DriverVersion</p>
    </td>
    <td><p class="tt"><a name="1085637"> </a>Char[20]</p>
    </td>
    <td><p class="tt"><a name="1085639"> </a>Read-only. The version number of the network interface device driver. This setting is defined only if <a href="CompatibilityApdx.html#997520">5.1 New Feature Set</a> is present.</p>
    </td>
  </tr>
  <tr valign="top">
    <td><p class="tt"><a name="1085644"> </a>FirmwareVersion</p>
    </td>
    <td><p class="tt"><a name="1085646"> </a>Char[20]</p>
    </td>
    <td><p class="tt"><a name="1085648"> </a>Read-only. The firmware version of the network interface device, if any. This setting is defined only if <a href="CompatibilityApdx.html#997520">5.1 New Feature Set</a> is present.</p>
    </td>
  </tr>
  <tr valign="top">
    <td><p class="tt"><a name="1085653"> </a>FirmwareDate</p>
    </td>
    <td><p class="tt"><a name="1085655"> </a>UInt32</p>
    </td>
    <td><p class="tt"><a name="1085657"> </a>Read-only. Firmware date in seconds since midnight, January 1, 1904. This setting is defined only if <a href="CompatibilityApdx.html#997520">5.1 New Feature Set</a> is present.</p>
    </td>
  </tr>
  <tr valign="top">
    <td><p class="tt"><a name="1085662"> </a>80211Device</p>
    </td>
    <td><p class="tt"><a name="1085664"> </a>UInt8</p>
    </td>
    <td><p class="tt"><a name="1085666"> </a>Read-only. Indicates whether or not the interface supports IEEE 802.11 wireless networking. This setting is defined only if <a href="CompatibilityApdx.html#997520">5.1 New Feature Set</a> is present.</p>
    </td>
  </tr>
  <tr valign="top">
    <td><p class="tt"><a name="1085671"> </a>80211ESSID</p>
    </td>
    <td><p class="tt"><a name="1085673"> </a>Char[32]</p>
    </td>
    <td><p class="tt"><a name="1085675"> </a>For IEEE 802.11 interfaces only. The ESS ID of the radio. This setting is defined only if <a href="CompatibilityApdx.html#997520">5.1 New Feature Set</a> is present.</p>
    </td>
  </tr>
  <tr valign="top">
    <td><p class="tt"><a name="1085680"> </a>80211AccessPointBSSID</p>
    </td>
    <td><p class="tt"><a name="1085682"> </a>UInt8[6]</p>
    </td>
    <td><p class="tt"><a name="1085684"> </a>Read-only. For IEEE 802.11 interfaces only. The BSS ID (MAC address) of the access point to which the radio is connected. This setting is defined only if <a href="CompatibilityApdx.html#997520">5.1 New Feature Set</a> is present.</p>
    </td>
  </tr>
  <tr valign="top">
    <td><p class="tt"><a name="1085689"> </a>80211AssociationStatus</p>
    </td>
    <td><p class="tt"><a name="1085691"> </a>UInt8</p>
    </td>
    <td><p class="tt"><a name="1085693"> </a>Read-only. For IEEE 802.11 interfaces only. <code>true</code> if the radio is associated. This setting is defined only if <a href="CompatibilityApdx.html#997520">5.1 New Feature Set</a> is present.</p>
    </td>
  </tr>
  <tr valign="top">
    <td><p class="tt"><a name="1085698"> </a>80211MKKCallSign</p>
    </td>
    <td><p class="tt"><a name="1085700"> </a>Char[15]</p>
    </td>
    <td><p class="tt"><a name="1085702"> </a>Read-only. For IEEE 802.11 interfaces with radios programmed for operation in Japan only. The MKK call sign. This setting is defined only if <a href="CompatibilityApdx.html#997520">5.1 New Feature Set</a> is present.</p>
    </td>
  </tr>
  <tr valign="top">
    <td><p class="tt"><a name="1085707"> </a>80211CountryText</p>
    </td>
    <td><p class="tt"><a name="1085709"> </a>Char[34]</p>
    </td>
    <td>
<p><a name="1085711"> </a>Read-only. For IEEE 802.11 interfaces only. The radio's country code, which the radio uses to check if it operates within a particular country's regulations. This setting is defined only if <a href="CompatibilityApdx.html#997520">5.1 New Feature Set</a> is present.</p>
    </td>
  </tr>
</table>

</div>

<h4>
  <a name="1085716"> </a>See Also 
</h4>

<p><a name="1085723"> </a><a href="NetLibrary.html#1085735"><code>NetLibIFSettingSet()</code></a>, <a href="NetLibrary.html#1086876"><code>NetLibSettingGet()</code></a>, <a href="NetLibrary.html#1087056"><code>NetLibSettingSet()</code></a>, <a href="../PalmOSCompanion2/NetworkCommunication.html#1021543">"Interface Specific Settings"</a> in the <i>Palm OS Programmer's Companion</i>, vol. II, <i>Communications</i> </p>

<h3 class="hbH3">
  <a name="1085735"> </a>NetLibIFSettingSet Function <a href="#1083561"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="1085737"> </a>Purpose 
</h4>

<p><a name="1085738"> </a>Sets a network interface specific setting.</p>
<h4>
  <a name="1085739"> </a>Declared In 
</h4>
<code>NetMgr.h<a name="1085740"> </a></code><h4>
  <a name="1085741"> </a>Prototype 
</h4>
<pre class="proto"><a name="1085743"></a>Err NetLibIFSettingSet (
   UInt16 libRefNum,
   UInt32 ifCreator,
   UInt16 ifInstance,
   UInt16 setting,
   void *valueP,
   UInt16 valueLen
)
</pre>
<h4>
  <a name="1085744"> </a>Parameters 
</h4>

<dl>
<dt><a name="1085745"> </a><code>&rarr;  <i><code>libRefNum</code></i></code></dt>
<dd><a name="1085746"> </a>Reference number of the net library.</dd>

<dt><a name="1085747"> </a><code>&rarr;  <i><code>ifCreator</code></i></code></dt>
<dd><a name="1085748"> </a>Creator of the network interface.</dd>

<dt><a name="1085749"> </a><code>&rarr;  <i><code>ifInstance</code></i></code></dt>
<dd><a name="1085750"> </a>Instance number of the network interface.</dd>

<dt><a name="1085751"> </a><code>&rarr;  <i><code>setting</code></i></code></dt>
<dd><a name="1085753"> </a>The setting to set, one of the <code>NetIFSettingEnum</code> constants. See <a href="NetLibrary.html#1085370">Table 66.2</a>.</dd>

<dt><a name="1085757"> </a><code>&rarr;  <i><code>valueP</code></i></code></dt>
<dd><a name="1085758"> </a>Space new value of setting.</dd>

<dt><a name="1085759"> </a><code>&rarr;  <i><code>valueLen</code></i></code></dt>
<dd><a name="1085760"> </a>Size of new setting.</dd>

</dl>
<h4>
  <a name="1085761"> </a>Returns 
</h4>

<p><a name="1085762"> </a>Returns one of the following values:</p>

<dl>
<dt><a name="1085763"> </a><code>0</code></dt>
<dd><a name="1085764"> </a>Success.</dd>

<dt><a name="1085766"> </a><code><code>netErrUnknownSetting</code></code></dt>
<dd><a name="1085767"> </a>Invalid setting constant.</dd>

<dt><a name="1085769"> </a><code><code>netErrPrefNotFound</code></code></dt>
<dd><a name="1085770"> </a>No current value for setting.</dd>

<dt><a name="1085772"> </a><code><code>netErrUnimplemented</code></code></dt>
<dt><a name="1085774"> </a><code><code>netErrInterfaceNotFound</code></code></dt>
<dt><a name="1085776"> </a><code><code>netErrBufWrongSize</code></code></dt>
<dt><a name="1085778"> </a><code><code>netErrReadOnlySetting</code></code></dt>
</dl>
<h4>
  <a name="1085779"> </a>Sockets Equivalent
</h4>

<p><a name="1085780"> </a>None</p>
<h4>
  <a name="1085781"> </a>Comments 
</h4>

<p><a name="1085782"> </a>This call can be used to set the current value of any network interface setting. The caller must pass a pointer to a buffer which holds the new value (<code>valueP</code>), the size of the buffer (<code>valueLen</code>), and the setting ID (<code>setting</code>). </p>

<p><a name="1085786"> </a>See <a href="NetLibrary.html#1085312"><code>NetLibIFSettingGet()</code></a> for an explanation of each of the settings. </p>

<p><a name="1085787"> </a>Of particular interest is the <code>netIFSettingResetAll</code> setting, which, if used, resets all settings for the interface to their default values. When using this setting, <code>valueP</code> and <code>valueLen</code> are ignored.</p>
<h4>
  <a name="1085788"> </a>See Also 
</h4>

<p><a name="1085795"> </a><a href="NetLibrary.html#1085312"><code>NetLibIFSettingGet()</code></a>, <a href="NetLibrary.html#1086876"><code>NetLibSettingGet()</code></a>, <a href="NetLibrary.html#1087056"><code>NetLibSettingSet()</code></a><code>,</code> <a href="../PalmOSCompanion2/NetworkCommunication.html#1021543">"Interface Specific Settings"</a> in the <i>Palm OS Programmer's Companion</i>, vol. II, <i>Communications</i></p>

<h3 class="hbH3">
  <a name="1085807"> </a>NetLibIFUp Function <a href="#1083561"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="1085809"> </a>Purpose 
</h4>

<p><a name="1085810"> </a>Bring an interface up and establish a connection.</p>
<h4>
  <a name="1085811"> </a>Declared In 
</h4>
<code>NetMgr.h<a name="1085812"> </a></code><h4>
  <a name="1085813"> </a>Prototype 
</h4>
<pre class="proto"><a name="1085815"></a>Err NetLibIFUp (
   UInt16 libRefNum,
   UInt32 ifCreator,
   UInt16 ifInstance
)
</pre>
<h4>
  <a name="1085816"> </a>Parameters 
</h4>

<dl>
<dt><a name="1085817"> </a><code>&rarr;  <i><code>libRefNum</code></i></code></dt>
<dd><a name="1085818"> </a>Reference number of the net library.</dd>

<dt><a name="1085819"> </a><code>&rarr;  <i><code>ifCreator</code></i></code></dt>
<dd><a name="1085820"> </a>Creator of interface to attach.</dd>

<dt><a name="1085821"> </a><code>&rarr;  <i><code>ifInstance</code></i></code></dt>
<dd><a name="1085822"> </a>Instance number of interface to attach.</dd>

</dl>
<h4>
  <a name="1085823"> </a>Returns 
</h4>

<p><a name="1085824"> </a>Returns one of the following values:</p>

<dl>
<dt><a name="1085825"> </a><code>0</code></dt>
<dd><a name="1085826"> </a>Success.</dd>

<dt><a name="1085828"> </a><code><code>netErrNotOpen</code></code></dt>
<dd><a name="1085829"> </a>The referenced net library has not been opened yet. </dd>

<dt><a name="1085831"> </a><code><code>netErrInterfaceNotFound</code></code></dt>
<dt><a name="1085833"> </a><code><code>netErrUserCancel</code></code></dt>
<dt><a name="1085835"> </a><code><code>netErrBadScript</code></code></dt>
<dt><a name="1085837"> </a><code><code>netErrPPPTimeout</code></code></dt>
<dt><a name="1085839"> </a><code><code>netErrAuthFailure</code></code></dt>
<dt><a name="1085841"> </a><code><code>netErrPPPAddressRefused</code></code></dt>
</dl>
<h4>
  <a name="1085842"> </a>Sockets Equivalent
</h4>

<p><a name="1085843"> </a>None</p>
<h4>
  <a name="1085844"> </a>Comments 
</h4>

<p><a name="1085845"> </a>The net library must be open before this call can be made. For dial-up interfaces, this call will dial up the modem if necessary and run through the connect script to establish the connection. </p>

<p><a name="1085852"> </a>If the interface is already up, this routine returns immediately with no error. This call doesn't take a timeout parameter because it relies on each interface to have its own established timeout setting. </p>
<h4>
  <a name="1085853"> </a>See Also 
</h4>

<p><a name="1085863"> </a><a href="NetLibrary.html#1085260"><code>NetLibIFGet()</code></a>, <a href="NetLibrary.html#1085120"><code>NetLibIFAttach()</code></a>, <a href="NetLibrary.html#1085167"><code>NetLibIFDetach()</code></a>, <a href="NetLibrary.html#1085208"><code>NetLibIFDown()</code></a> </p>

<h3 class="hbH3">
  <a name="1085869"> </a>NetLibMaster Function <a href="#1083561"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="1085871"> </a>Purpose 
</h4>

<p><a name="1085872"> </a>Retrieves the network statistics, interface statistics, and the contents of the trace buffer. </p>
<h4>
  <a name="1085873"> </a>Declared In 
</h4>
<code>NetMgr.h<a name="1085874"> </a></code><h4>
  <a name="1085875"> </a>Prototype 
</h4>
<pre class="proto"><a name="1085877"></a>Err NetLibMaster (
   UInt16 libRefNum,
   UInt16 cmd,
   NetMasterPBPtr pbP,
   Int32 timeout
) 
</pre>
<h4>
  <a name="1085879"> </a>Parameters 
</h4>

<dl>
<dt><a name="1085880"> </a><code>&rarr;  <i><code>libRefNum</code></i></code></dt>
<dd><a name="1085881"> </a>Reference number of the net library.</dd>

<dt><a name="1085882"> </a><code>&rarr;  <i><code>cmd</code></i></code></dt>
<dd><a name="1085884"> </a>Function to perform (<code>NetMasterEnum</code> type). The following commands are supported:</dd>

<dl>
<dt><a name="1085888"> </a><code><a href="NetLibrary.html#1085935"><code>netMasterInterfaceInfo</code></a></code></dt>
<dt><a name="1085892"> </a><code><a href="NetLibrary.html#1086061"><code>netMasterInterfaceStats</code></a></code></dt>
<dt><a name="1085896"> </a><code><a href="NetLibrary.html#1086139"><code>netMasterIPStats</code></a></code></dt>
<dt><a name="1085900"> </a><code><a href="NetLibrary.html#1086143"><code>netMasterICMPStats</code></a></code></dt>
<dt><a name="1085904"> </a><code><a href="NetLibrary.html#1086147"><code>netMasterUDPStats</code></a></code></dt>
<dt><a name="1085908"> </a><code><a href="NetLibrary.html#1086151"><code>netMasterTCPStats</code></a></code></dt>
<dt><a name="1085912"> </a><code><a href="NetLibrary.html#1086155"><code>netMasterTraceEventGet</code></a></code></dt>
</dl>
<dt><a name="1085913"> </a><code>&harr;  <i><code>pbP</code></i></code></dt>
<dd><a name="1085914"> </a>Command parameter block.</dd>

<dt><a name="1085915"> </a><code>&rarr;  <i><code>timeout</code></i></code></dt>
<dd><a name="1085916"> </a>Timeout in ticks; -1 means wait forever.</dd>

</dl>
<h4>
  <a name="1085917"> </a>Returns 
</h4>

<p><a name="1085918"> </a>Returns one of the following values:</p>

<dl>
<dt><a name="1085919"> </a><code>0</code></dt>
<dd><a name="1085920"> </a>No error</dd>

<dt><a name="1085922"> </a><code><code>netErrNotOpen</code></code></dt>
<dd><a name="1085923"> </a>The referenced net library has not been opened yet. </dd>

<dt><a name="1085925"> </a><code><code>netErrParamErr</code></code></dt>
<dt><a name="1085927"> </a><code><code>netErrUnimplemented</code></code></dt>
</dl>
<h4>
  <a name="1085928"> </a>Sockets Equivalent
</h4>

<p><a name="1085929"> </a>None</p>
<h4>
  <a name="1085930"> </a>Comments 
</h4>

<p><a name="1085931"> </a>This call allows applications to get detailed information about the net library. This information is usually helpful in debugging network configuration problems. </p>

<p><a name="1085932"> </a>This function takes a command word (<code>cmd</code>) and parameter block pointer (<code>pbP</code>) as arguments and returns its results in the parameter block on exit. Which values you must specify in the parameter block and which values are returned are specific to the command you specify. </p>

<h4 class="hcH4">
  <a name="1085935"> </a>netMasterInterfaceInfo 
</h4>

<p><a name="1085936"> </a>The <code>pbP-&gt;interfaceInfo</code> struct specifies interface information. </p>


<div class="tablediv"><table cellspacing="0" class="tTableNR">

  <tr valign="top">
    <td>
<dl>
<dt><a name="1085939"> </a><code>&rarr;  <i><code> </code></i></code></dt>
</dl>
    </td>
    <td><p class="tt"><a name="1085941"> </a><code>index </code></p>
    </td>
    <td><p class="tt"><a name="1085943"> </a>Index of interface to fetch info about.</p>
    </td>
  </tr>
  <tr valign="top">
    <td>
<dl>
<dt><a name="1085945"> </a><code>&larr;  <i></i></code></dt>
</dl>
    </td>
    <td><p class="tt"><a name="1085947"> </a><code>creator</code></p>
    </td>
    <td><p class="tt"><a name="1085949"> </a>Creator of interface.</p>
    </td>
  </tr>
  <tr valign="top">
    <td>
<dl>
<dt><a name="1085951"> </a><code>&larr;  <i></i></code></dt>
</dl>
    </td>
    <td><p class="tt"><a name="1085953"> </a><code>instance</code></p>
    </td>
    <td><p class="tt"><a name="1085955"> </a>Instance of interface.</p>
    </td>
  </tr>
  <tr valign="top">
    <td>
<dl>
<dt><a name="1085957"> </a><code>&larr;  <i></i></code></dt>
</dl>
    </td>
    <td><p class="tt"><a name="1085959"> </a><code>netIFP</code></p>
    </td>
    <td><p class="tt"><a name="1085961"> </a>Private interface info pointer.</p>
    </td>
  </tr>
  <tr valign="top">
    <td>
<dl>
<dt><a name="1085963"> </a><code>&larr;  <i></i></code></dt>
</dl>
    </td>
    <td><p class="tt"><a name="1085965"> </a><code>drvrName</code></p>
    </td>
    <td><p class="tt"><a name="1085967"> </a>Driver type that interface uses ("PPP", "SLIP", etc.).</p>
    </td>
  </tr>
  <tr valign="top">
    <td>
<dl>
<dt><a name="1085969"> </a><code>&larr;  <i></i></code></dt>
</dl>
    </td>
    <td><p class="tt"><a name="1085971"> </a><code>hwName</code></p>
    </td>
    <td><p class="tt"><a name="1085973"> </a>Hardware driver name ("Serial Library", etc.).</p>
    </td>
  </tr>
  <tr valign="top">
    <td>
<dl>
<dt><a name="1085975"> </a><code>&larr;  <i></i></code></dt>
</dl>
    </td>
    <td><p class="tt"><a name="1085977"> </a><code>localNetHdrLen</code></p>
    </td>
    <td><p class="tt"><a name="1085979"> </a>Number of bytes in local net header.</p>
    </td>
  </tr>
  <tr valign="top">
    <td>
<dl>
<dt><a name="1085981"> </a><code>&larr;  <i></i></code></dt>
</dl>
    </td>
    <td><p class="tt"><a name="1085983"> </a><code>localNetTrailerLen</code> </p>
    </td>
    <td><p class="tt"><a name="1085985"> </a>Number of bytes in local net trailer.</p>
    </td>
  </tr>
  <tr valign="top">
    <td>
<dl>
<dt><a name="1085987"> </a><code>&larr;  <i></i></code></dt>
</dl>
    </td>
    <td><p class="tt"><a name="1085989"> </a><code>localNetMaxFrame</code></p>
    </td>
    <td><p class="tt"><a name="1085991"> </a>Local net maximum frame size.</p>
    </td>
  </tr>
  <tr valign="top">
    <td>
<dl>
<dt><a name="1085993"> </a><code>&larr;  <i></i></code></dt>
</dl>
    </td>
    <td><p class="tt"><a name="1085995"> </a><code>ifName</code></p>
    </td>
    <td><p class="tt"><a name="1085997"> </a>Interface name with instance number concatenated.</p>
    </td>
  </tr>
  <tr valign="top">
    <td>
<dl>
<dt><a name="1085999"> </a><code>&larr;  <i></i></code></dt>
</dl>
    </td>
    <td><p class="tt"><a name="1086001"> </a><code>driverUp</code></p>
    </td>
    <td><p class="tt"><a name="1086003"> </a><code>true</code> if interface driver is up.</p>
    </td>
  </tr>
  <tr valign="top">
    <td>
<dl>
<dt><a name="1086005"> </a><code>&larr;  <i></i></code></dt>
</dl>
    </td>
    <td><p class="tt"><a name="1086007"> </a><code>ifUp</code></p>
    </td>
    <td><p class="tt"><a name="1086009"> </a><code>true</code> if interface media layer is up.</p>
    </td>
  </tr>
  <tr valign="top">
    <td>
<dl>
<dt><a name="1086011"> </a><code>&larr;  <i></i></code></dt>
</dl>
    </td>
    <td><p class="tt"><a name="1086013"> </a><code>hwAddrLen</code></p>
    </td>
    <td><p class="tt"><a name="1086015"> </a>Length of interface's hardware address.</p>
    </td>
  </tr>
  <tr valign="top">
    <td>
<dl>
<dt><a name="1086017"> </a><code>&larr;  <i></i></code></dt>
</dl>
    </td>
    <td><p class="tt"><a name="1086019"> </a><code>hwAddr</code></p>
    </td>
    <td><p class="tt"><a name="1086021"> </a>Interface's hardware address.</p>
    </td>
  </tr>
  <tr valign="top">
    <td>
<dl>
<dt><a name="1086023"> </a><code>&larr;  <i></i></code></dt>
</dl>
    </td>
    <td><p class="tt"><a name="1086025"> </a><code>mtu</code></p>
    </td>
    <td><p class="tt"><a name="1086027"> </a>Maximum transfer unit of interface.</p>
    </td>
  </tr>
  <tr valign="top">
    <td>
<dl>
<dt><a name="1086029"> </a><code>&larr;  <i></i></code></dt>
</dl>
    </td>
    <td><p class="tt"><a name="1086031"> </a><code>speed</code></p>
    </td>
    <td><p class="tt"><a name="1086033"> </a>Speed in bits per second.</p>
    </td>
  </tr>
  <tr valign="top">
    <td>
<dl>
<dt><a name="1086035"> </a><code>&larr;  <i></i></code></dt>
</dl>
    </td>
    <td><p class="tt"><a name="1086037"> </a><code>lastStateChange</code></p>
    </td>
    <td><p class="tt"><a name="1086039"> </a>Time in milliseconds of last state change.</p>
    </td>
  </tr>
  <tr valign="top">
    <td>
<dl>
<dt><a name="1086041"> </a><code>&larr;  <i></i></code></dt>
</dl>
    </td>
    <td><p class="tt"><a name="1086043"> </a><code>ipAddr</code></p>
    </td>
    <td><p class="tt"><a name="1086045"> </a>IP address of interface.</p>
    </td>
  </tr>
  <tr valign="top">
    <td>
<dl>
<dt><a name="1086047"> </a><code>&larr;  <i></i></code></dt>
</dl>
    </td>
    <td><p class="tt"><a name="1086049"> </a><code>subnetMask</code></p>
    </td>
    <td><p class="tt"><a name="1086051"> </a>Subnet mask of local network.</p>
    </td>
  </tr>
  <tr valign="top">
    <td>
<dl>
<dt><a name="1086053"> </a><code>&larr;  <i></i></code></dt>
</dl>
    </td>
    <td><p class="tt"><a name="1086055"> </a><code>broadcast</code></p>
    </td>
    <td><p class="tt"><a name="1086057"> </a>Broadcast address of local network.</p>
    </td>
  </tr>
</table>

</div>


<h4 class="hcH4">
  <a name="1086061"> </a>netMasterInterfaceStats
</h4>

<p><a name="1086062"> </a>The <code>pbP-&gt;interfaceStats</code> structure specifies interface statistics.</p>


<div class="tablediv"><table cellspacing="0" class="tTableNR">

  <tr valign="top">
    <td>
<dl>
<dt><a name="1086065"> </a><code>&rarr;  <i><code> </code></i></code></dt>
</dl>
    </td>
    <td><p class="tt"><a name="1086067"> </a><code>index </code></p>
    </td>
    <td><p class="tt"><a name="1086069"> </a>Index of interface to fetch info about.</p>
    </td>
  </tr>
  <tr valign="top">
    <td>
<dl>
<dt><a name="1086071"> </a><code>&larr;  <i></i></code></dt>
</dl>
    </td>
    <td><p class="tt"><a name="1086073"> </a><code>inOctets</code></p>
    </td>
    <td><p class="tt"><a name="1086075"> </a>Number of octets received.</p>
    </td>
  </tr>
  <tr valign="top">
    <td>
<dl>
<dt><a name="1086077"> </a><code>&larr;  <i></i></code></dt>
</dl>
    </td>
    <td><p class="tt"><a name="1086079"> </a><code>inUcastPkts</code></p>
    </td>
    <td><p class="tt"><a name="1086081"> </a>Number of packets received.</p>
    </td>
  </tr>
  <tr valign="top">
    <td>
<dl>
<dt><a name="1086083"> </a><code>&larr;  <i></i></code></dt>
</dl>
    </td>
    <td><p class="tt"><a name="1086085"> </a><code>inNUcastPkts</code></p>
    </td>
    <td><p class="tt"><a name="1086087"> </a>Number of broadcast packets received.</p>
    </td>
  </tr>
  <tr valign="top">
    <td>
<dl>
<dt><a name="1086089"> </a><code>&larr;  <i></i></code></dt>
</dl>
    </td>
    <td><p class="tt"><a name="1086091"> </a><code>inDiscards</code></p>
    </td>
    <td><p class="tt"><a name="1086093"> </a>Number of incoming packets that were discarded.</p>
    </td>
  </tr>
  <tr valign="top">
    <td>
<dl>
<dt><a name="1086095"> </a><code>&larr;  <i></i></code></dt>
</dl>
    </td>
    <td><p class="tt"><a name="1086097"> </a><code>inErrors</code></p>
    </td>
    <td><p class="tt"><a name="1086099"> </a>Number of packet errors encountered.</p>
    </td>
  </tr>
  <tr valign="top">
    <td>
<dl>
<dt><a name="1086101"> </a><code>&larr;  <i></i></code></dt>
</dl>
    </td>
    <td><p class="tt"><a name="1086103"> </a><code>inUnknownProtos </code></p>
    </td>
    <td><p class="tt"><a name="1086105"> </a>Number of unknown protocols encountered.</p>
    </td>
  </tr>
  <tr valign="top">
    <td>
<dl>
<dt><a name="1086107"> </a><code>&larr;  <i></i></code></dt>
</dl>
    </td>
    <td><p class="tt"><a name="1086109"> </a><code>outOctets</code></p>
    </td>
    <td><p class="tt"><a name="1086111"> </a>Number octets sent.</p>
    </td>
  </tr>
  <tr valign="top">
    <td>
<dl>
<dt><a name="1086113"> </a><code>&larr;  <i></i></code></dt>
</dl>
    </td>
    <td><p class="tt"><a name="1086115"> </a><code>outUcastPkts</code></p>
    </td>
    <td><p class="tt"><a name="1086117"> </a>Number of packets sent.</p>
    </td>
  </tr>
  <tr valign="top">
    <td>
<dl>
<dt><a name="1086119"> </a><code>&larr;  <i></i></code></dt>
</dl>
    </td>
    <td><p class="tt"><a name="1086121"> </a><code>outNUcastPkts</code></p>
    </td>
    <td><p class="tt"><a name="1086123"> </a>Number of broadcast packets sent.</p>
    </td>
  </tr>
  <tr valign="top">
    <td>
<dl>
<dt><a name="1086125"> </a><code>&larr;  <i></i></code></dt>
</dl>
    </td>
    <td><p class="tt"><a name="1086127"> </a><code>outDiscards</code></p>
    </td>
    <td><p class="tt"><a name="1086129"> </a>Number of packets discarded.</p>
    </td>
  </tr>
  <tr valign="top">
    <td>
<dl>
<dt><a name="1086131"> </a><code>&larr;  <i></i></code></dt>
</dl>
    </td>
    <td><p class="tt"><a name="1086133"> </a><code>outErrors</code></p>
    </td>
    <td><p class="tt"><a name="1086135"> </a>Number of outbound packet errors.</p>
    </td>
  </tr>
</table>

</div>


<h4 class="hcH4">
  <a name="1086139"> </a>netMasterIPStats
</h4>

<p><a name="1086140"> </a>The <code>pbP-&gt;ipStats</code> structure contains statistics about the IP protocol. See <code>NetMgr.h</code> for a complete list of statistics returned. </p>

<h4 class="hcH4">
  <a name="1086143"> </a>netMasterICMPStats
</h4>

<p><a name="1086144"> </a>The <code>pbP-&gt;icmpStats</code> structure contains statistics about the ICMP protocol. See <code>NetMgr.h</code> for a complete list of statistics returned. </p>

<h4 class="hcH4">
  <a name="1086147"> </a>netMasterUDPStats
</h4>

<p><a name="1086148"> </a>The <code>pbP-&gt;udpStats</code> structure contains statistics about the UDP protocol. See <code>NetMgr.h</code> for a complete list of statistics returned. </p>

<h4 class="hcH4">
  <a name="1086151"> </a>netMasterTCPStats
</h4>

<p><a name="1086152"> </a>The <code>pbP-&gt;tcpStats</code> structure contains statistics about the TCP protocol. See <code>NetMgr.h</code> for a complete list of statistics returned. </p>

<h4 class="hcH4">
  <a name="1086155"> </a>netMasterTraceEventGet
</h4>

<p><a name="1086156"> </a>The <code>pbP-&gt;traceEventGet</code> structure contains a trace event. </p>


<div class="tablediv"><table cellspacing="0" class="tTableNR">

  <tr valign="top">
    <td>
<dl>
<dt><a name="1086159"> </a><code>&rarr;  <i><code> </code></i></code></dt>
</dl>
    </td>
    <td><p class="tt"><a name="1086161"> </a><code>index</code></p>
    </td>
    <td><p class="tt"><a name="1086163"> </a>Index of event to fetch.</p>
    </td>
  </tr>
  <tr valign="top">
    <td>
<dl>
<dt><a name="1086165"> </a><code>&larr;  <i></i></code></dt>
</dl>
    </td>
    <td><p class="tt"><a name="1086167"> </a><code>textP</code></p>
    </td>
    <td><p class="tt"><a name="1086169"> </a>Pointer to text string to return event in. Should be at least 256 bytes long.</p>
    </td>
  </tr>
</table>

</div>

<h4>
  <a name="1086171"> </a>See Also 
</h4>

<p><a name="1086175"> </a><a href="NetLibrary.html#1087056"><code>NetLibSettingSet()</code></a> </p>

<h3 class="hbH3">
  <a name="1086179"> </a>NetLibOpen Function <a href="#1083561"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="1086181"> </a>Purpose 
</h4>

<p><a name="1086182"> </a>Opens and initializes the net library.</p>
<h4>
  <a name="1086183"> </a>Declared In 
</h4>
<code>NetMgr.h<a name="1086184"> </a></code><h4>
  <a name="1086185"> </a>Prototype 
</h4>
<pre class="proto"><a name="1086187"></a>Err NetLibOpen (
   UInt16 libRefnum,
   UInt16 *netIFErrsP
)
</pre>
<h4>
  <a name="1086188"> </a>Parameters 
</h4>

<dl>
<dt><a name="1086189"> </a><code>&rarr;  <i><code>libRefnum</code></i></code></dt>
<dd><a name="1086190"> </a>Reference number of the net library.</dd>

<dt><a name="1086191"> </a><code>&larr;  <i><code>netIFErrsP</code></i></code></dt>
<dd><a name="1086192"> </a>First error encountered when bringing up network interfaces. (See <a href="NetLibrary.html#1085807"><code>NetLibIFUp()</code></a> for a list of possible values.) </dd>

</dl>
<h4>
  <a name="1086196"> </a>Returns 
</h4>

<p><a name="1086197"> </a>Returns one of the following values:</p>

<dl>
<dt><a name="1086198"> </a><code>0</code></dt>
<dd><a name="1086199"> </a>No error.</dd>

<dt><a name="1086201"> </a><code><code>netErrAlreadyOpen</code></code></dt>
<dd><a name="1086202"> </a>Not really an error; returned if library was already open and the open count was simply incremented.</dd>

<dt><a name="1086204"> </a><code>n<code>etErrOutOfMemory</code></code></dt>
<dd><a name="1086205"> </a>Not enough memory available to open the library.</dd>

<dt><a name="1086207"> </a><code><code>netErrNoInterfaces</code></code></dt>
<dd><a name="1086208"> </a>Incorrect setup.</dd>

<dt><a name="1086210"> </a><code><code>netErrPrefNotFound</code></code></dt>
<dd><a name="1086211"> </a>Incorrect setup.</dd>

</dl>
<h4>
  <a name="1086212"> </a>Comments 
</h4>

<p><a name="1086213"> </a>Applications must call this function before using the net library. If the net library was already open, <code>NetLibOpen</code> increments its open count. Otherwise, it opens the library, initializes it, starts up the net protocol stack component of the library as a separate task, and brings up all attached network interfaces. </p>

<p><a name="1086214"> </a><code>NetLibOpen</code> uses settings saved in the net library's preferences database during initialization. These settings include the interfaces to attach, the IP addresses, etc. It's assumed that these settings have been previously set up by a preference panel or equivalent so an application doesn't normally have to set them up before calling <code>NetLibOpen</code>. </p>

<p><a name="1086217"> </a>If any of the attached interfaces fails to come up, *<code>netIFErrsP</code> will contain the error number of the first interface that encountered a problem.</p>
<h4>
  <a name="1086218"> </a>Compatibility 
</h4>

<p><a name="1086222"> </a><code>NetLibOpen</code> behaves slightly differently in version 3.2 and later than it does in previous releases. In version 3.2 and later, <code>NetLibOpen</code> calls <a href="NetLibrary.html#1086243"><code>NetLibOpenConfig()</code></a> specifying the default configuration. <code>NetLibOpenConfig</code> reverts all settings to their saved, default values before opening the net library.</p>
<h4>
  <a name="1086229"> </a>See Also 
</h4>

<p><a name="1086239"> </a><a href="SystemManager.html#1076670"><code>SysLibFind()</code></a>, <a href="NetLibrary.html#1084184"><code>NetLibClose()</code></a>, <a href="NetLibrary.html#1086342"><code>NetLibOpenCount()</code></a> </p>

<h3 class="hbH3">
  <a name="1086243"> </a>NetLibOpenConfig Function <a href="#1083561"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="1086245"> </a>Purpose 
</h4>

<p><a name="1086246"> </a>Opens and initializes the net library with the specified configuration.</p>
<h4>
  <a name="1086247"> </a>Prototype 
</h4>
<pre class="proto"><a name="1086249"></a>Err NetLibOpenConfig (
   UInt16 refNum,
   UInt16 configIndex,
   UInt32 openFlags,
   UInt16 *netIFErrP
)
</pre>
<h4>
  <a name="1086250"> </a>Parameters 
</h4>

<dl>
<dt><a name="1086251"> </a><code>&rarr;  <i><code>refNum</code></i></code></dt>
<dd><a name="1086252"> </a>Reference number of the net library.</dd>

<dt><a name="1086253"> </a><code>&rarr;  <i><code>configIndex</code></i></code></dt>
<dd><a name="1086254"> </a>Index of the configuration to use. 0 means use the default configuration as defined in the Network preferences panel.</dd>

<dt><a name="1086255"> </a><code>&rarr;  <i><code>openFlags</code></i></code></dt>
<dd><a name="1086256"> </a>Not used. Pass 0 for this parameter. </dd>

<dt><a name="1086257"> </a><code>&larr;  <i><code>netIFErrP</code></i></code></dt>
<dd><a name="1086258"> </a>Pointer to return error code for interfaces. </dd>

</dl>
<h4>
  <a name="1086259"> </a>Returns 
</h4>

<p><a name="1086260"> </a>Returns one of the following values:</p>

<dl>
<dt><a name="1086261"> </a><code>0</code></dt>
<dd><a name="1086262"> </a>No error.</dd>

<dt><a name="1086264"> </a><code><code>memErrNotEnoughSpace</code> </code></dt>
<dt><a name="1086266"> </a><code><code>netErrAlreadyOpen</code></code></dt>
<dd><a name="1086267"> </a>Not really an error; returned if library was already open and the open count was simply incremented.</dd>

<dt><a name="1086269"> </a><code><code>netErrAlreadyOpenWithAnotherConfig</code> </code></dt>
<dd><a name="1086270"> </a>Another application has the net library open with a configuration that is incompatible with the one specified.</dd>

<dt><a name="1086272"> </a><code><code>netErrBufTooSmall</code> </code></dt>
<dt><a name="1086274"> </a><code><code>netErrConfigAliasErr</code> </code></dt>
<dd><a name="1086275"> </a>A configuration alias was specified, but the alias could not be resolved. </dd>

<dt><a name="1086277"> </a><code><code>netErrConfigCantDelete</code> </code></dt>
<dt><a name="1086279"> </a><code><code>netErrConfigEmpty</code> </code></dt>
<dd><a name="1086280"> </a>The configuration is not defined. </dd>

<dt><a name="1086282"> </a><code><code>netErrConfigNotFound</code> </code></dt>
<dd><a name="1086283"> </a>The specified configuration index is invalid.</dd>

<dt><a name="1086285"> </a><code><code>netErrInterfaceNotFound</code> </code></dt>
<dt><a name="1086287"> </a><code><code>netErrOutOfCmdBlocks</code> </code></dt>
<dt><a name="1086289"> </a><code>n<code>etErrOutOfMemory</code></code></dt>
<dd><a name="1086290"> </a>Not enough memory available to open the library.</dd>

<dt><a name="1086292"> </a><code><code>netErrNoInterfaces</code></code></dt>
<dd><a name="1086293"> </a>Incorrect setup.</dd>

<dt><a name="1086295"> </a><code><code>netErrParamErr</code> </code></dt>
<dt><a name="1086297"> </a><code><code>netErrPrefNotFound</code></code></dt>
<dd><a name="1086298"> </a>Incorrect setup.</dd>

<dt><a name="1086300"> </a><code><code>netErrTimeout</code> </code></dt>
</dl>
<h4>
  <a name="1086301"> </a>Sockets Equivalent
</h4>

<p><a name="1086302"> </a>None</p>
<h4>
  <a name="1086303"> </a>Comments 
</h4>

<p><a name="1086307"> </a>Use this routine instead of <a href="NetLibrary.html#1086179"><code>NetLibOpen()</code></a> when you want to open the net library with a non-default configuration. If the default net library configuration is not suitable for your application, you may use one of the built-in aliases to specify a configuration that is suitable (see <a href="NetLibrary.html#1153429">"Configuration Aliases"</a>). </p>

<p><a name="1086311"> </a><code>NetLibOpenConfig</code> tries to open the net library and initialize it with the specified configuration. If another application has the net library open with an incompatible configuration, it returns an error. If the net library is in the close-wait state, this function completely closes the net library and then reopens it using the new configuration. If the net library can be opened with the new configuration, <code>NetLibOpenConfig</code> first saves the current configuration so that it can be restored when your application closes the net library. </p>

<p><a name="1086315"> </a>Typically, applications use the <a href="NetLibrary.html#1084476"><code>NetLibConfigList()</code></a> function to obtain the list of available configurations and present this list to the user. Then they call <a href="NetLibrary.html#1084430"><code>NetLibConfigIndexFromName()</code></a> with the user's selection to get the index of the configuration that the user selected. </p>

<p><a name="1086320"> </a>The constant <code>netConfigIndexCurSettings</code> specifies the current configuration. You can specify <code>netConfigIndexCurSettings</code> as the <code>configIndex</code> for testing purposes. </p>
<h4>
  <a name="1086321"> </a>Compatibility 
</h4>

<p><a name="1086325"> </a>Implemented only if <a href="CompatibilityApdx.html#993903">3.2 New Feature Set</a> is present.</p>
<h4>
  <a name="1086326"> </a>See Also 
</h4>

<p><a name="1086336"> </a><a href="NetLibrary.html#1086179"><code>NetLibOpen()</code></a>, <a href="SystemManager.html#1076670"><code>SysLibFind()</code></a>, <a href="NetLibrary.html#1084184"><code>NetLibClose()</code></a>, <a href="NetLibrary.html#1086342"><code>NetLibOpenCount()</code></a> </p>

<h3 class="hbH3">
  <a name="1086342"> </a>NetLibOpenCount Function <a href="#1083561"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="1086344"> </a>Purpose 
</h4>

<p><a name="1086346"> </a>Retrieves the open count of the net library.</p>
<h4>
  <a name="1086347"> </a>Declared In 
</h4>
<code>NetMgr.h<a name="1086348"> </a></code><h4>
  <a name="1086349"> </a>Prototype 
</h4>
<pre class="proto"><a name="1086351"></a>Err NetLibOpenCount (
   UInt16 refNum,
   UInt16 *countP
)
</pre>
<h4>
  <a name="1086352"> </a>Parameters 
</h4>

<dl>
<dt><a name="1086353"> </a><code>&rarr;  <i><code>refNum</code></i></code></dt>
<dd><a name="1086354"> </a>Reference number of the net library.</dd>

<dt><a name="1086355"> </a><code>&larr;  <i><code>countP</code></i></code></dt>
<dd><a name="1086356"> </a>Contains the open count of the net library upon return. </dd>

</dl>
<h4>
  <a name="1086357"> </a>Returns 
</h4>

<dl>
<dt><a name="1086358"> </a><code>Always returns 0.</code></dt>
</dl>
<h4>
  <a name="1086359"> </a>Sockets Equivalent
</h4>

<p><a name="1086360"> </a>None.</p>
<h4>
  <a name="1086361"> </a>Comments 
</h4>

<p><a name="1086362"> </a>This call will most likely only be used by the Network preferences panel. Most applications will simply call <a href="NetLibrary.html#1086179"><code>NetLibOpen()</code></a> unconditionally during startup and <a href="NetLibrary.html#1084184"><code>NetLibClose()</code></a> when they exit. </p>

<h3 class="hbH3">
  <a name="1086371"> </a>NetLibReceive Function <a href="#1083561"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="1086373"> </a>Purpose 
</h4>

<p><a name="1086374"> </a>Receive data from a socket into a single buffer.</p>
<h4>
  <a name="1086375"> </a>Declared In 
</h4>
<code>NetMgr.h<a name="1086376"> </a></code><h4>
  <a name="1086377"> </a>Prototype 
</h4>
<pre class="proto"><a name="1086379"></a>Int16 NetLibReceive (
   UInt16 libRefNum,
   NetSocketRef socket,
   void *bufP,
   UInt16 bufLen,
   UInt16 flags,
   void *fromAddrP,
   UInt16 *fromLenP,
   Int32 timeout,
   Err *errP
)
</pre>
<h4>
  <a name="1086380"> </a>Parameters 
</h4>

<dl>
<dt><a name="1086381"> </a><code>&rarr;  <i><code>libRefNum</code></i></code></dt>
<dd><a name="1086382"> </a>Reference number of the net library.</dd>

<dt><a name="1086383"> </a><code>&rarr;  <i><code>socket</code></i></code></dt>
<dd><a name="1086384"> </a>Descriptor for the open socket.</dd>

<dt><a name="1086385"> </a><code>&larr;  <i><code>bufP</code></i></code></dt>
<dd><a name="1086386"> </a>Pointer to buffer to hold received data.</dd>

<dt><a name="1086387"> </a><code>&rarr;  <i><code>bufLen</code></i></code></dt>
<dd><a name="1086388"> </a>Length of <code>bufP</code> buffer.</dd>

<dt><a name="1086389"> </a><code>&rarr;  <i><code>flags</code></i></code></dt>
<dd><a name="1086393"> </a>One or more <code>netIOFlagxxx</code> flags. See "<a href="NetLibrary.html#1083964"><code>I/O Flags</code></a>."</dd>

<dt><a name="1086394"> </a><code>&larr;  <i><code>fromAddrP</code></i></code></dt>
<dd><a name="1086395"> </a>Pointer to buffer to hold address of sender (a <a href="NetLibrary.html#1083857"><code>NetSocketAddrType</code></a>).</dd>

<dt><a name="1086399"> </a><code>&harr;  <i><code>fromLenP</code></i></code></dt>
<dd><a name="1086400"> </a>On entry, size of <code>fromAddrP</code> buffer. On exit, actual size of returned address in <code>fromAddrP</code>.</dd>

<dt><a name="1086401"> </a><code>&rarr;  <i><code>timeout</code></i></code></dt>
<dd><a name="1086402"> </a>Maximum timeout in system ticks; -1 means wait forever. </dd>

<dt><a name="1086403"> </a><code>&larr;  <i><code>errP</code></i></code></dt>
<dd><a name="1086404"> </a>Contains an error code if the return value is -1.</dd>

</dl>
<h4>
  <a name="1086405"> </a>Returns 
</h4>

<p><a name="1086406"> </a>Returns the number of bytes successfully received. If the return value is 0, the socket has been shut down by the remote host. If the return value is -1, an error has occurred, and <code>errP</code> contains one of the following values:</p>

<dl>
<dt><a name="1086407"> </a><code>0</code></dt>
<dd><a name="1086408"> </a>No error.</dd>

<dt><a name="1086410"> </a><code><code>netErrTimeout</code></code></dt>
<dd><a name="1086411"> </a>Call timed out. </dd>

<dt><a name="1086413"> </a><code><code>netErrNotOpen</code></code></dt>
<dd><a name="1086414"> </a>The referenced net library has not been opened yet. </dd>

<dt><a name="1086416"> </a><code><code>netErrParamErr</code></code></dt>
<dt><a name="1086418"> </a><code><code>netErrSocketNotOpen</code></code></dt>
<dt><a name="1086420"> </a><code><code>netErrWouldBlock</code></code></dt>
<dt><a name="1086422"> </a><code><code>netErrUserCancel</code> </code></dt>
</dl>
<h4>
  <a name="1086423"> </a>Sockets Equivalent
</h4>

<p><a name="1086424"> </a><code>int recvfrom (int socket, const void *bufP,<br>int bufLen, int flags, const void *fromAddrP,<br>int *fromLenP);</code></p>

<p><a name="1086425"> </a><code>int recv (int socket, const void *bufP,<br>int bufLen, int flags);</code></p>

<p><a name="1086426"> </a><code>int read (int socket, const void *bufP,<br>int bufLen);</code></p>
<h4>
  <a name="1086427"> </a>Comments 
</h4>

<p><a name="1086428"> </a>For stream-based sockets, this call reads whatever bytes are available and returns the number of bytes actually read into the caller's buffer. If there is no data available, this call will block until at least one byte arrives, until the socket is shut down by the remote host, or until a timeout occurs. </p>

<p><a name="1086429"> </a>For datagram-based sockets, this call reads a complete datagram and returns the number of bytes in the datagram. If the caller's buffer is not large enough to hold the entire datagram, the end of the datagram is discarded. If a datagram is not available, this call will block until one arrives, or until the call times out. </p>

<p><a name="1086438"> </a>The data is read into a single buffer pointed to by <code>bufP</code>.</p>
<h4>
  <a name="1086439"> </a>See Also 
</h4>

<p><a name="1086449"> </a><a href="NetLibrary.html#1086371"><code>NetLibReceive()</code></a>, <a href="NetLibrary.html#1084703"><code>NetLibDmReceive()</code></a>, <a href="NetworkUtils.html#1108889"><code>NetUReadN</code></a>, <a href="NetLibrary.html#1086663"><code>NetLibSend()</code></a>, <a href="NetLibrary.html#1086775"><code>NetLibSendPB()</code></a> </p>

<h3 class="hbH3">
  <a name="1086458"> </a>NetLibReceivePB Function <a href="#1083561"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="1086460"> </a>Purpose 
</h4>

<p><a name="1086461"> </a>Receive data from a socket into a multi-buffer gather-read array.</p>
<h4>
  <a name="1086462"> </a>Declared In 
</h4>
<code>NetMgr.h<a name="1086463"> </a></code><h4>
  <a name="1086464"> </a>Prototype 
</h4>
<pre class="proto"><a name="1086466"></a>Int16 NetLibReceivePB (
   UInt16 libRefNum,
   NetSocketRef socket,
   NetIOParamType *pbP,
   UInt16 flags,
   Int32 timeout,
   Err *errP
)
</pre>
<h4>
  <a name="1086467"> </a>Parameters 
</h4>

<dl>
<dt><a name="1086468"> </a><code>&rarr;  <i><code>libRefNum</code></i></code></dt>
<dd><a name="1086469"> </a>Reference number of the net library.</dd>

<dt><a name="1086470"> </a><code>&rarr;  <i><code>socket</code></i></code></dt>
<dd><a name="1086471"> </a>Descriptor for the open socket.</dd>

<dt><a name="1086472"> </a><code>&rarr;  <i><code>pbP</code></i></code></dt>
<dd><a name="1086473"> </a>Pointer to parameter block containing buffer info. </dd>

<dt><a name="1086474"> </a><code>&rarr;  <i><code>flags</code></i></code></dt>
<dd><a name="1086478"> </a>One or more <code>netIOFlagxxx</code> flags. See "<a href="NetLibrary.html#1083964"><code>I/O Flags</code></a>."</dd>

<dt><a name="1086479"> </a><code>&rarr;  <i><code>timeout</code></i></code></dt>
<dd><a name="1086480"> </a>Maximum timeout in system ticks; -1 means wait forever. </dd>

<dt><a name="1086481"> </a><code>&larr;  <i><code>errP</code></i></code></dt>
<dd><a name="1086482"> </a>Contains an error code if the return value is -1.</dd>

</dl>
<h4>
  <a name="1086483"> </a>Returns 
</h4>

<p><a name="1086484"> </a>Returns the number of bytes successfully received. Returns 0 if the socket has been shut down by the remote host. If the return value is -1, an error has occurred, and <code>errP</code> contains one of the following values:</p>

<dl>
<dt><a name="1086485"> </a><code>0</code></dt>
<dd><a name="1086486"> </a>No error.</dd>

<dt><a name="1086488"> </a><code><code>netErrTimeout</code></code></dt>
<dd><a name="1086489"> </a>Call timed out. </dd>

<dt><a name="1086491"> </a><code><code>netErrNotOpen</code></code></dt>
<dd><a name="1086492"> </a>The referenced net library has not been opened yet. </dd>

<dt><a name="1086494"> </a><code><code>netErrParamErr</code></code></dt>
<dt><a name="1086496"> </a><code><code>netErrSocketNotOpen</code></code></dt>
<dt><a name="1086498"> </a><code><code>netErrWouldBlock</code></code></dt>
</dl>
<h4>
  <a name="1086499"> </a>Sockets Equivalent
</h4>

<p><a name="1086500"> </a><code>int recvmsg (int socket, const struct msghdr *pbP,<br>int flags);</code></p>
<h4>
  <a name="1086501"> </a>Comments 
</h4>

<p><a name="1086503"> </a>The <code>pbP</code> parameter is a pointer to a <code>NetIOParamType</code> structure. <code>NetIOParamType</code> is defined as follows:</p>
<h4>
  <a name="1086505"> </a>Prototype 
</h4>
<pre class="proto"><a name="1086506"></a>typedef struct {
  UInt8 *addrP;
  UInt16 addrLen;
  NetIOVecPtr iov;
  UInt16 iovLen;
  UInt8 *accessRights;
  UInt16 accessRightsLen;
} NetIOParamType, *NetIOParamPtr;
</pre>
<h4>
  <a name="1164937"> </a>Fields 
</h4>

<dl>
<dt><a name="1086517"> </a><code><code>addrP</code> </code></dt>
<dd><a name="1086519"> </a>Address of sender, set by <code>NetLibReceivePB</code>. Set to 0 if you don't require this field. </dd>

<dt><a name="1086521"> </a><code><code>addrLen</code> </code></dt>
<dd><a name="1086523"> </a>Length of <code>*addrP</code>.</dd>

<dt><a name="1086525"> </a><code><code>iov</code> </code></dt>
<dd><a name="1086527"> </a>Array of buffers into which the data should be received. <code>NetIOVecPtr</code> is a pointer to a <code>NetIOVecType</code> structure, which has two fields:</dd>

<dl>
<dt><a name="1086530"> </a><code><code>bufP</code></code></dt>
<dd><a name="1086531"> </a>Pointer to a buffer.</dd>

<dt><a name="1086532"> </a><code><code>bufLen</code></code></dt>
<dd><a name="1086533"> </a>Length of <code>bufP</code>. </dd>

</dl>
<dt><a name="1086535"> </a><code><code>iovLen</code> </code></dt>
<dd><a name="1086537"> </a>Length of the <code>iov</code> array.</dd>

<dt><a name="1086539"> </a><code><code>accessRights</code> </code></dt>
<dd><a name="1086541"> </a>Access rights. This field currently isn't used and should be set to 0. </dd>

<dt><a name="1086543"> </a><code><code>accessRightsLen</code> </code></dt>
<dd><a name="1086545"> </a>Length of the <code>*accessRights</code>. This field currently isn't used and should be set to 0. </dd>

</dl>

<p><a name="1086547"> </a>For stream-based sockets, this call reads whatever bytes are available and returns the number of bytes actually read into the caller's buffer. If no data is available, this call will block until at least one byte arrives, until the socket is shut down by the remote host, or until a timeout occurs. </p>

<p><a name="1086548"> </a>For datagram-based sockets, this call reads a complete datagram and returns the number of bytes in the datagram. If the caller's buffer is not large enough to hold the entire datagram, the end of the datagram is discarded. If a datagram is not available, this call will block until one arrives, or until the call times out. </p>

<p><a name="1086557"> </a>The data is read into the gather-read array specified by the <code>pbP-&gt;iov</code> array. </p>
<h4>
  <a name="1086558"> </a>See Also 
</h4>

<p><a name="1086568"> </a><a href="NetLibrary.html#1086371"><code>NetLibReceive()</code></a>, <a href="NetLibrary.html#1084703"><code>NetLibDmReceive()</code></a>, <a href="NetLibrary.html#1086663"><code>NetLibSend()</code></a>, <a href="NetLibrary.html#1086775"><code>NetLibSendPB()</code></a> </p>

<h3 class="hbH3">
  <a name="1086574"> </a>NetLibSelect Function <a href="#1083561"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="1086576"> </a>Purpose 
</h4>

<p><a name="1086577"> </a>Blocks until I/O is ready on one or more descriptors, where a descriptor can represent socket input, socket output, or a user input event like a pen tap or key press.</p>
<h4>
  <a name="1086578"> </a>Declared In 
</h4>
<code>NetMgr.h<a name="1086579"> </a></code><h4>
  <a name="1086580"> </a>Prototype 
</h4>
<pre class="proto"><a name="1086582"></a>Int16 NetLibSelect (
   UInt16 libRefNum,
   UInt16 width,
   NetFDSetType *readFDs,
   NetFDSetType *writeFDs,
   NetFDSetType *exceptFDs,
   Int32 timeout,
   Err *errP
)
</pre>
<h4>
  <a name="1086583"> </a>Parameters 
</h4>

<dl>
<dt><a name="1086584"> </a><code>&rarr;  <i><code>libRefNum</code></i></code></dt>
<dd><a name="1086585"> </a>Reference number of the net library.</dd>

<dt><a name="1086586"> </a><code>&rarr;  <i><code>width</code></i></code></dt>
<dd><a name="1086587"> </a>Number of descriptor bits to check in the <code>readFDs</code>, <code>writeFDs</code>, and <code>exceptFDs</code> descriptor sets. </dd>

<dt><a name="1086588"> </a><code>&harr;  <i><code>readFDs</code></i></code></dt>
<dd><a name="1086590"> </a>Pointer to 32-bit <code>NetFDSetType</code> containing set of bits representing descriptors to check for input.</dd>

<dt><a name="1086591"> </a><code>&harr;  <i><code>writeFDs</code></i></code></dt>
<dd><a name="1086592"> </a>Pointer to 32-bit <code>NetFDSetType</code> containing set of bits representing descriptors to check for output.</dd>

<dt><a name="1086593"> </a><code>&harr;  <i><code>exceptFDs</code></i></code></dt>
<dd><a name="1086594"> </a>Pointer to 32-bit <code>NetFDSetType</code> containing set of bits representing descriptors to check for exception conditions. This parameter is ignored. Upon return, its bits are always cleared.</dd>

<dt><a name="1086595"> </a><code>&rarr;  <i><code>timeout</code></i></code></dt>
<dd><a name="1086596"> </a>Maximum timeout in system ticks; -1 means wait forever. </dd>

<dt><a name="1086597"> </a><code>&larr;  <i><code>errP</code></i></code></dt>
<dd><a name="1086598"> </a>Contains an error code if the return value is -1.</dd>

</dl>
<h4>
  <a name="1086599"> </a>Returns 
</h4>

<p><a name="1086600"> </a>Returns the sum total number of ready file descriptors in *<code>readFDs</code>, *<code>writeFDs</code>, and *<code>exceptFDs</code>. Returns 0 upon timeout. If the return value is -1, an error has occurred, and <code>errP</code> contains one of the following values:</p>

<dl>
<dt><a name="1086601"> </a><code>0</code></dt>
<dd><a name="1086602"> </a>No error</dd>

<dt><a name="1086603"> </a><code><code>netErrTimeout</code></code></dt>
<dd><a name="1086604"> </a>Call timed out. </dd>

<dt><a name="1086606"> </a><code><code>netErrNotOpen</code></code></dt>
<dd><a name="1086607"> </a>The referenced net library has not been opened yet. </dd>

</dl>
<h4>
  <a name="1086608"> </a>Sockets Equivalent
</h4>

<p><a name="1086609"> </a><code>int select (int width, fd_set *readfds,<br>fd_set *writefds, fd_set *exceptfds,<br>struct timeval *timeout);</code></p>
<h4>
  <a name="1086610"> </a>Comments 
</h4>

<p><a name="1086611"> </a>This call blocks until one or more descriptors are ready for I/O. In the Palm OS environment, a descriptor is either a <code>NetSocketRef</code> or the "stdin" descriptor, <code>sysFileDescStdIn</code>. The <code>sysFileDescStdIn</code> descriptor will be ready for input whenever a user event is available like a pen tap or key press. </p>

<p><a name="1086613"> </a>The caller should set which bits in each descriptor set need to be checked by using the <code>netFDZero</code> and <code>netFDSet</code> macros. After this call returns, the macro <code>netFDIsSet</code> can be used to determine which descriptors in each set are actually ready. </p>

<p><a name="1086617"> </a>On exit, the total number of ready descriptors is returned and each descriptor set is updated with the appropriate bits set for each ready descriptor in that set. </p>

<p><a name="1086626"> </a>The following example illustrates how to use this call to check for input on a socket or a user event:</p>

<div class="CodeRule"><hr></div><pre class="CodeBlock">
  Err<span style="color: #000000;  font-style: normal; font-weight: normal; text-decoration: none; text-transform: none; vertical-align: baseline"> </span>    err;<a name="1086627"> </a>
  NetSocketRef    socket;<a name="1086628"> </a>
  NetFDSetType    readFDs,writeFDs,exceptFDs;<a name="1086629"> </a>
  Int16       numFDs;<a name="1086630"> </a>
  UInt16      <span style="color: #000000;  font-style: normal; font-weight: normal; text-decoration: none; text-transform: none; vertical-align: baseline"> </span>width;<a name="1086631"> </a>
 <a name="1086632"> </a>
  // Create the descriptor sets<a name="1086633"> </a>
  netFDZero(&amp;readFDs);<a name="1086634"> </a>
  netFDZero(&amp;writeFDs);<a name="1086635"> </a>
  netFDZero(&amp;exceptFDs);<a name="1086636"> </a>
  netFDSet(sysFileDescStdIn, &amp;readFDs);<a name="1086637"> </a>
  netFDSet(socket, &amp;readFDs);<a name="1086638"> </a>
 <a name="1086639"> </a>
  // Calculate the max descriptor number and <a name="1086640"> </a>
  // use that +1 as the max width. <a name="1086641"> </a>
  // Alternatively, we could simply use the <a name="1086642"> </a>
  // constant netFDSetSize as the width which <a name="1086644"> </a>
  // is simpler but makes the NetLibSelect call <a name="1086645"> </a>
  // slightly slower. <a name="1086646"> </a>
  width = sysFileDescStdIn;<a name="1086647"> </a>
  if (socket &gt; width) width = socket;<a name="1086648"> </a>
 <a name="1086649"> </a>
  // Wait for any one of the descriptors to be <a name="1086650"> </a>
  // ready.<a name="1086651"> </a>
  numFDs = NetLibSelect(AppNetRefnum, width+1,<a name="1086652"> </a>
    &amp;readFDs, &amp;writeFDs, &amp;exceptFDs,<a name="1086653"> </a>
    AppNetTimeout, &amp;err);<a name="1086654"> </a>
</pre><div class="CodeRule"><hr></div>


<p><a name="1086655"> </a>Also see the <code>NetSample</code> example application in the <code>Palm OS Examples</code> folder. The function <code>CmdTelnet</code> in the file <code>CmdTelnet.c</code> shows how to use the Berkeley sockets <code>select</code> function and how to interpret the results. </p>
<h4>
  <a name="1086656"> </a>See Also 
</h4>

<p><a name="1086660"> </a><a href="NetLibrary.html#1087723"><code>NetLibSocketOptionSet()</code></a> </p>

<h3 class="hbH3">
  <a name="1086663"> </a>NetLibSend Function <a href="#1083561"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="1086665"> </a>Purpose 
</h4>

<p><a name="1086666"> </a>Send data to a socket from a single buffer.</p>
<h4>
  <a name="1086667"> </a>Declared In 
</h4>
<code>NetMgr.h<a name="1086668"> </a></code><h4>
  <a name="1086669"> </a>Prototype 
</h4>
<pre class="proto"><a name="1086671"></a>Int16 NetLibSend (
   UInt16 libRefNum,
   NetSocketRef socket,
   void *bufP,
   UInt16 bufLen,
   UInt16 flags,
   void *toAddrP,
   UInt16 toLen,
   Int32 timeout,
   Err *errP
)
</pre>
<h4>
  <a name="1086672"> </a>Parameters 
</h4>

<dl>
<dt><a name="1086673"> </a><code>&rarr;  <i><code>libRefNum</code></i></code></dt>
<dd><a name="1086674"> </a>Reference number of the net library.</dd>

<dt><a name="1086675"> </a><code>&rarr;  <i><code>socket</code></i></code></dt>
<dd><a name="1086676"> </a>Descriptor for the open socket.</dd>

<dt><a name="1086677"> </a><code>&rarr;  <i><code>bufP</code></i></code></dt>
<dd><a name="1086678"> </a>Pointer to data to write.</dd>

<dt><a name="1086679"> </a><code>&rarr;  <i><code>bufLen</code></i></code></dt>
<dd><a name="1086680"> </a>Length of data to write</dd>

<dt><a name="1086681"> </a><code>&rarr;  <i><code>flags</code></i></code></dt>
<dd><a name="1086685"> </a>One or more <code>netIOFlagxxx</code> flags. See "<a href="NetLibrary.html#1083964"><code>I/O Flags</code></a>."</dd>

<dt><a name="1086686"> </a><code>&rarr;  <i><code>toAddrP</code></i></code></dt>
<dd><a name="1086690"> </a>Address to send to (a pointer to a <a href="NetLibrary.html#1083857"><code>NetSocketAddrType</code></a>), or 0.</dd>

<dt><a name="1086691"> </a><code>&rarr;  <i><code>toLen</code></i></code></dt>
<dd><a name="1086692"> </a>Size of <code>toAddrP</code> buffer.</dd>

<dt><a name="1086693"> </a><code>&rarr;  <i><code>timeout</code></i></code></dt>
<dd><a name="1086694"> </a>Maximum timeout in system ticks; -1 means wait forever. </dd>

<dt><a name="1086695"> </a><code>&larr;  <i><code>errP</code></i></code></dt>
<dd><a name="1086696"> </a>Contains an error code if the return value is -1.</dd>

</dl>
<h4>
  <a name="1086697"> </a>Returns 
</h4>

<p><a name="1086698"> </a>Returns the number of bytes successfully sent. Returns 0 if the socket has been shut down by the remote host. If the return value is -1, an error has occurred, and <code>errP</code> contains one of the following values:</p>

<dl>
<dt><a name="1086699"> </a><code>0</code></dt>
<dd><a name="1086700"> </a>No error.</dd>

<dt><a name="1086702"> </a><code><code>netErrTimeout</code></code></dt>
<dd><a name="1086703"> </a>Call timed out. </dd>

<dt><a name="1086705"> </a><code><code>netErrNotOpen</code></code></dt>
<dd><a name="1086706"> </a>The referenced net library has not been opened yet. </dd>

<dt><a name="1086708"> </a><code><code>netErrParamErr</code></code></dt>
<dt><a name="1086710"> </a><code><code>netErrSocketNotOpen</code></code></dt>
<dt><a name="1086712"> </a><code><code>netErrMessageTooBig</code></code></dt>
<dt><a name="1086714"> </a><code><code>netErrSocketNotConnected</code></code></dt>
<dt><a name="1086716"> </a><code><code>netErrSocketClosedByRemote</code></code></dt>
<dt><a name="1086718"> </a><code><code>netErrIPCantFragment</code></code></dt>
<dt><a name="1086720"> </a><code><code>netErrIPNoRoute</code></code></dt>
<dt><a name="1086722"> </a><code><code>netErrIPNoSrc</code></code></dt>
<dt><a name="1086724"> </a><code><code>netErrIPNoDst</code></code></dt>
<dt><a name="1086726"> </a><code><code>netErrIPktOverflow</code></code></dt>
<dt><a name="1086728"> </a><code><code>netErrOutOfCmdBlocks</code> </code></dt>
<dt><a name="1086730"> </a><code><code>netErrOutOfPackets</code> </code></dt>
<dt><a name="1086732"> </a><code><code>netErrInterfaceNotFound</code> </code></dt>
<dt><a name="1086734"> </a><code><code>netErrInterfaceDown</code> </code></dt>
<dt><a name="1086736"> </a><code><code>netErrUnreachableDest</code> </code></dt>
<dt><a name="1086738"> </a><code><code>netErrNoMultiPktAddr</code> </code></dt>
<dt><a name="1086740"> </a><code><code>netErrWouldBlock</code> </code></dt>
</dl>
<h4>
  <a name="1086741"> </a>Sockets Equivalent
</h4>

<p><a name="1086742"> </a><code>int sendto (int socket, const void *bufP,<br>int bufLen, int flags, const void *toAddrP,<br>int toLen);</code></p>

<p><a name="1086743"> </a><code>int send (int socket, const void *bufP,<br>int bufLen, int flags);</code></p>

<p><a name="1086744"> </a><code>int write (int socket, const void *bufP,<br>int bufLen,);</code></p>
<h4>
  <a name="1086745"> </a>Comments 
</h4>

<p><a name="1086746"> </a>This call attempts to write data to the specified socket and returns the number of bytes actually sent, which may be less than or equal to the requested number of bytes. The data is passed in a single buffer that <code>bufP</code> points to.</p>

<p><a name="1086747"> </a>For datagram sockets, you must only send a single packet at a time. If the data is too large to fit in a single UDP packet (1536 bytes), no data is sent and -1 is returned.</p>

<p><a name="1086753"> </a>The <code>toAddrP</code> field applies only to datagram sockets without an existing connection. An error is returned if the datagram socket was previously connected and <code>toAddrP</code> is specified. Stream-based sockets, by definition, must have a connection established with a remote host before data can be written. Raw sockets (supported in Palm OS version 3.0 and higher) must construct the entire IP header, including the destination address, before data can be sent; thus, the address is taken from the data to be sent. </p>

<p><a name="1086754"> </a>If there isn't enough buffer space to send any data, this call will block until there is enough buffer space, or until a timeout.</p>

<div><hr>
  <a name="1086755"> </a> <b>NOTE: </b> For stream-based sockets, this call may write only a portion of the desired data. It always returns the number of bytes actually written. Consequently, the caller should be prepared to call this routine repeatedly until the desired number of bytes have been written, or until it returns 0 or -1. 
<hr>
</div>
<h4>
  <a name="1086756"> </a>See Also 
</h4>

<p><a name="1086766"> </a><a href="NetLibrary.html#1086775"><code>NetLibSendPB()</code></a>, <a href="NetworkUtils.html#1109033"><code>NetUWriteN()</code></a>, <a href="NetLibrary.html#1086371"><code>NetLibReceive()</code></a>, <a href="NetLibrary.html#1086458"><code>NetLibReceivePB()</code></a>, <a href="NetLibrary.html#1084703"><code>NetLibDmReceive()</code></a> </p>

<h3 class="hbH3">
  <a name="1086775"> </a>NetLibSendPB Function <a href="#1083561"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="1086777"> </a>Purpose 
</h4>

<p><a name="1086778"> </a>Send data to a socket from a scatter-write array.</p>
<h4>
  <a name="1086779"> </a>Declared In 
</h4>
<code>NetMgr.h<a name="1086780"> </a></code><h4>
  <a name="1086781"> </a>Prototype 
</h4>
<pre class="proto"><a name="1086783"></a>Int16 NetLibSendPB (
   UInt16 libRefNum,
   NetSocketRef socket,
   NetIOParamType *pbP,
   UInt16 flags,
   Int32 timeout,
   Err *errP
)
</pre>
<h4>
  <a name="1086784"> </a>Parameters 
</h4>

<dl>
<dt><a name="1086785"> </a><code>&rarr;  <i><code>libRefNum</code></i></code></dt>
<dd><a name="1086786"> </a>Reference number of the net library.</dd>

<dt><a name="1086787"> </a><code>&rarr;  <i><code>socket</code></i></code></dt>
<dd><a name="1086788"> </a>Descriptor for the open socket.</dd>

<dt><a name="1086789"> </a><code>&rarr;  <i><code>pbP</code></i></code></dt>
<dd><a name="1086790"> </a>Pointer to parameter block containing buffer info. See the description in <a href="NetLibrary.html#1086458"><code>NetLibReceivePB()</code></a>.</dd>

<dt><a name="1086794"> </a><code>&rarr;  <i><code>flags</code></i></code></dt>
<dd><a name="1086798"> </a>One or more <code>netIOFlagxxx</code> flags. See "<a href="NetLibrary.html#1083964"><code>I/O Flags</code></a>."</dd>

<dt><a name="1086799"> </a><code>&rarr;  <i><code>timeout</code></i></code></dt>
<dd><a name="1086800"> </a>Maximum timeout in system ticks; -1 means wait forever. </dd>

<dt><a name="1086801"> </a><code>&larr;  <i><code>errP</code></i></code></dt>
<dd><a name="1086802"> </a>Contains an error code if the return value is -1.</dd>

</dl>
<h4>
  <a name="1086803"> </a>Returns 
</h4>

<p><a name="1086804"> </a>Returns the number of bytes successfully sent. Returns 0 if the socket has been shut down by the remote host. If the return value is -1, an error has occurred, and <code>errP</code> contains one of the following values:</p>

<dl>
<dt><a name="1086805"> </a><code>0</code></dt>
<dd><a name="1086806"> </a>No error.</dd>

<dt><a name="1086808"> </a><code><code>netErrTimeout</code></code></dt>
<dd><a name="1086809"> </a>Call timed out. </dd>

<dt><a name="1086811"> </a><code><code>netErrNotOpen</code></code></dt>
<dd><a name="1086812"> </a>The referenced net library has not been opened yet. </dd>

<dt><a name="1086814"> </a><code><code>netErrParamErr</code></code></dt>
<dt><a name="1086816"> </a><code><code>netErrSocketNotOpen</code></code></dt>
<dt><a name="1086818"> </a><code><code>netErrMessageTooBig</code></code></dt>
<dt><a name="1086820"> </a><code><code>netErrSocketNotConnected</code></code></dt>
<dt><a name="1086822"> </a><code><code>netErrSocketClosedByRemote</code></code></dt>
<dt><a name="1086824"> </a><code><code>netErrIPCantFragment</code></code></dt>
<dt><a name="1086826"> </a><code><code>netErrIPNoRoute</code></code></dt>
<dt><a name="1086828"> </a><code><code>netErrIPNoSrc</code></code></dt>
<dt><a name="1086830"> </a><code><code>netErrIPNoDst</code></code></dt>
<dt><a name="1086832"> </a><code><code>netErrIPktOverflow</code></code></dt>
<dt><a name="1086834"> </a><code><code>netErrOutOfCmdBlocks</code> </code></dt>
<dt><a name="1086836"> </a><code><code>netErrOutOfPackets</code> </code></dt>
<dt><a name="1086838"> </a><code><code>netErrInterfaceNotFound</code> </code></dt>
<dt><a name="1086840"> </a><code><code>netErrInterfaceDown</code> </code></dt>
<dt><a name="1086842"> </a><code><code>netErrUnreachableDest</code> </code></dt>
<dt><a name="1086844"> </a><code><code>netErrNoMultiPktAddr</code> </code></dt>
<dt><a name="1086846"> </a><code><code>netErrWouldBlock</code> </code></dt>
</dl>
<h4>
  <a name="1086847"> </a>Sockets Equivalent
</h4>

<p><a name="1086848"> </a><code>int sendmsg (int socket, const struct msghdr *pbP,<br>int flags);</code></p>
<h4>
  <a name="1086849"> </a>Comments 
</h4>

<p><a name="1086850"> </a>This call attempts to write data to the given socket and returns the number of bytes actually sent, which may be less than or equal to the requested number of bytes. The data is passed in the scatter-write array specified in the <code>pbP</code> parameter block. </p>

<p><a name="1086851"> </a>For datagram sockets, you must only send a single packet at a time. If the data is too large to fit in a single UDP packet, no data is sent and -1 is returned.</p>

<p><a name="1086857"> </a>The <code>toAddrP</code> field applies only to datagram sockets without an existing connection. An error is returned if the datagram socket was previously connected and <code>toAddrP</code> is specified. Stream-based sockets, by definition, must have a connection established with a remote host before data can be written. Raw sockets (supported in Palm OS version 3.0 and higher) must construct the entire IP header, including the destination address, before data can be sent; thus, the address is taken from the data to be sent. </p>

<p><a name="1086858"> </a>If there isn't enough buffer space to send any data, this call will block until there is space, or until a timeout.</p>

<div><hr>
  <a name="1086859"> </a> <b>NOTE: </b> For stream-based sockets, this call may write only a portion of the desired data. It always returns the number of bytes actually written. Consequently, the caller should be prepared to call this routine repeatedly until the desired number of bytes have been written, or until it returns 0 or -1. 
<hr>
</div>
<h4>
  <a name="1086860"> </a>See Also 
</h4>

<p><a name="1086870"> </a><a href="NetLibrary.html#1086663"><code>NetLibSend()</code></a>, <a href="NetLibrary.html#1086371"><code>NetLibReceive()</code></a>, <a href="NetLibrary.html#1086458"><code>NetLibReceivePB()</code></a>, <a href="NetLibrary.html#1084703"><code>NetLibDmReceive()</code></a> </p>

<h3 class="hbH3">
  <a name="1086876"> </a>NetLibSettingGet Function <a href="#1083561"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="1086878"> </a>Purpose 
</h4>

<p><a name="1086879"> </a>Retrieves a general setting.</p>
<h4>
  <a name="1086880"> </a>Declared In 
</h4>
<code>NetMgr.h<a name="1086881"> </a></code><h4>
  <a name="1086882"> </a>Prototype 
</h4>
<pre class="proto"><a name="1086884"></a>Err NetLibSettingGet (
   UInt16 libRefNum,
   UInt16 setting,
   void *valueP,
   UInt16 *valueLenP
)
</pre>
<h4>
  <a name="1086885"> </a>Parameters 
</h4>

<dl>
<dt><a name="1086886"> </a><code>&rarr;  <i><code>libRefNum</code></i></code></dt>
<dd><a name="1086887"> </a>Reference number of the net library.</dd>

<dt><a name="1086888"> </a><code>&rarr;  <i><code>setting</code></i></code></dt>
<dd><a name="1086890"> </a>Setting to retrieve, one of the <code>NetSettingEnum</code> constants.</dd>

<dt><a name="1086891"> </a><code>&larr;  <i><code>valueP</code></i></code></dt>
<dd><a name="1086892"> </a>Space for return value of setting.</dd>

<dt><a name="1086893"> </a><code>&harr;  <i><code>valueLenP</code></i></code></dt>
<dd><a name="1086894"> </a>On entry, size of <code>valueP</code>. On exit, actual size of setting.</dd>

</dl>
<h4>
  <a name="1086895"> </a>Returns 
</h4>

<p><a name="1086896"> </a>Returns one of the following values:</p>

<dl>
<dt><a name="1086897"> </a><code>0</code></dt>
<dd><a name="1086898"> </a>Success.</dd>

<dt><a name="1086900"> </a><code><code>netErrUnknownSetting</code></code></dt>
<dd><a name="1086901"> </a>Invalid setting constant</dd>

<dt><a name="1086903"> </a><code><code>netErrPrefNotFound</code></code></dt>
<dd><a name="1086904"> </a>No current value for setting</dd>

<dt><a name="1086906"> </a><code><code>netErrBufTooSmall</code></code></dt>
<dd><a name="1086907"> </a><code>valueP</code> was too small to hold entire setting. Setting value was truncated to fit in <code>valueP</code>.</dd>

<dt><a name="1086909"> </a><code><code>netErrBufWrongSize</code></code></dt>
</dl>
<h4>
  <a name="1086910"> </a>Sockets Equivalent
</h4>

<p><a name="1086911"> </a>None</p>
<h4>
  <a name="1086912"> </a>Comments 
</h4>

<p><a name="1086913"> </a>This call retrieves the current value of any general setting. The caller must pass a pointer to a buffer to hold the return value (<code>valueP</code>), the size of the buffer (*<code>valueLenP</code>), and the setting ID (<code>setting</code>). The setting ID is one of the <code>NetSettingEnum</code> constants in the <code>netSettingEnum</code> type. </p>

<p><a name="1086915"> </a>Some settings, such as the host table, are variable size. For these types of settings, you can obtain the actual size required for the buffer by passing 0 for <code>*valueLenP</code>. The required size is returned in <code>valueLenP</code>. </p>

<p><a name="1086919"> </a><a href="NetLibrary.html#1086926">Table 66.3</a> lists the general settings and the type of each setting. </p>

<p class="caption"><a name="1086926"> </a><b>Table 66.3&nbsp;&nbsp;Net Library General Settings </b></p>
<div class="tablediv"><table cellspacing="0" class="tTable">

  <tr valign="top">
    <th><p class="tt"><a name="1086932"> </a><b>netSetting...</b></p>
    </th>
    <th><p class="tt"><a name="1086934"> </a><b>Type</b></p>
    </th>
    <th><p class="tt"><a name="1086936"> </a><b>Description</b></p>
    </th>
  </tr>
  <tr valign="top">
    <td><p class="tt"><a name="1086938"> </a><code>ResetAll</code></p>
    </td>
    <td><p class="tt"><a name="1086940"> </a><code>void</code></p>
    </td>
    <td><p class="tt"><a name="1086945"> </a>Used for <a href="NetLibrary.html#1087056"><code>NetLibSettingSet()</code></a> only. This will clear all other settings to their default values.</p>
    </td>
  </tr>
  <tr valign="top">
    <td><p class="tt"><a name="1086947"> </a><code>PrimaryDNS</code></p>
    </td>
    <td><p class="tt"><a name="1086949"> </a><code>UInt32</code></p>
    </td>
    <td><p class="tt"><a name="1086951"> </a>IP address of primary DNS server. This setting must be set to a non-zero IP address in order to support any of the name lookup calls. </p>
    </td>
  </tr>
  <tr valign="top">
    <td><p class="tt"><a name="1086953"> </a><code>SecondaryDNS</code></p>
    </td>
    <td><p class="tt"><a name="1086955"> </a><code>UInt32</code></p>
    </td>
    <td><p class="tt"><a name="1086957"> </a>IP address of secondary DNS server. Set to 0 to have stack ignore this setting.</p>
    </td>
  </tr>
  <tr valign="top">
    <td><p class="tt"><a name="1086959"> </a><code>DefaultRouter</code></p>
    </td>
    <td><p class="tt"><a name="1086961"> </a><code>UInt32</code></p>
    </td>
    <td><p class="tt"><a name="1086963"> </a>IP address of default router. Default value is 0 which is appropriate for most implementations with only one attached interface (besides loopback). Packets with destination IP addresses that don't lie in the subnet of an attached interface will be sent to this router through the default interface specified by the <code>netSettingDefaultIFCreator</code>/<code>netSettingDefaultIFInstance</code> pair.</p>
    </td>
  </tr>
  <tr valign="top">
    <td><p class="tt"><a name="1086965"> </a><code>DefaultIFCreator</code></p>
    </td>
    <td><p class="tt"><a name="1086967"> </a><code>UInt32</code></p>
    </td>
    <td><p class="tt"><a name="1086969"> </a>Creator of the default network interface. Default value is 0, which is appropriate for most implementations. Packets with destination IP addresses that don't lie in the subnet of a directly attached interface are sent through this interface. If this setting is 0, the stack automatically makes the first non-loopback interface the default interface. </p>
    </td>
  </tr>
  <tr valign="top">
    <td><p class="tt"><a name="1086971"> </a><code>DefaultIFInstance</code></p>
    </td>
    <td><p class="tt"><a name="1086973"> </a><code>UInt16</code></p>
    </td>
    <td><p class="tt"><a name="1086975"> </a>Instance number of the default network interface. Packets with destination IP addresses that don't lie in the subnet of an attached interface are sent through the default interface. Default value is 0.</p>
    </td>
  </tr>
  <tr valign="top">
    <td><p class="tt"><a name="1086977"> </a><code>HostName</code></p>
    </td>
    <td><p class="tt"><a name="1086979"> </a><code>Char[]</code></p>
    </td>
    <td><p class="tt"><a name="1086981"> </a>A zero-terminated character string of 64 bytes or less containing the host name of this machine. This setting is not actually used by the stack. It's present mainly for informative purposes and to support the <code>gethostname</code>/<code>sethostname</code> sockets API calls. To clear the host name, call <a href="NetLibrary.html#1085735"><code>NetLibIFSettingSet()</code></a> with a valueLen of 0.</p>
    </td>
  </tr>
  <tr valign="top">
    <td><p class="tt"><a name="1086988"> </a><code>DomainName</code></p>
    </td>
    <td><p class="tt"><a name="1086990"> </a><code>Char[]</code></p>
    </td>
    <td><p class="tt"><a name="1086992"> </a>A zero-terminated character string of 256 bytes or less containing the default domain. This default domain name is appended to all host names before name lookups are performed. If the name is not found, the host name is looked up again without appending the domain name to it. To have the stack not use the domain name, call <a href="NetLibrary.html#1085735"><code>NetLibIFSettingSet()</code></a> with a <code>valueLen</code> of 0. </p>
    </td>
  </tr>
  <tr valign="top">
    <td><p class="tt"><a name="1086997"> </a><code>HostTbl</code></p>
    </td>
    <td><p class="tt"><a name="1086999"> </a><code>Char[]</code></p>
    </td>
    <td><p class="tt"><a name="1087001"> </a>A null-terminated character string containing the host table. This table is consulted first before sending a DNS query to the DNS server(s). To have the stack not use a host table, call <a href="NetLibrary.html#1085735"><code>NetLibIFSettingSet()</code></a> with a <code>valueLen</code> of 0. The format of a host table is a series of lines separated by '\n' in the following format:</p>
<pre class="sl">host.company.com A 111.222.333.444</pre>
    </td>
  </tr>
  <tr valign="top">
    <td><p class="tt"><a name="1087007"> </a><code>CloseWaitTime</code></p>
    </td>
    <td><p class="tt"><a name="1087009"> </a><code>UInt32</code></p>
    </td>
    <td><p class="tt"><a name="1087011"> </a>The close-wait time in milliseconds. This setting must be specified. See the discussion of the <a href="NetLibrary.html#1084184"><code>NetLibClose()</code></a> call for an explanation of the close-wait time.</p>
    </td>
  </tr>
  <tr valign="top">
    <td><p class="tt"><a name="1087016"> </a><code>TraceBits</code></p>
    </td>
    <td><p class="tt"><a name="1087018"> </a><code>UInt32</code></p>
    </td>
    <td><p class="tt"><a name="1087023"> </a>A bitfield of various trace bits. See "<a href="NetLibrary.html#1154363"><code>Tracing Bits</code></a>." Default value is (<code>netTracingErrors | netTracingAppMsgs</code>). An application can get a list of events in the trace buffer using the <a href="NetLibrary.html#1085869"><code>NetLibMaster()</code></a> call. </p>
    </td>
  </tr>
  <tr valign="top">
    <td><p class="tt"><a name="1087028"> </a><code>TraceSize</code></p>
    </td>
    <td><p class="tt"><a name="1087030"> </a><code>UInt32</code></p>
    </td>
    <td><p class="tt"><a name="1087032"> </a>Maximum trace buffer size in bytes. Setting this setting always clears the existing trace buffer. Default is 2 KB. </p>
    </td>
  </tr>
  <tr valign="top">
    <td><p class="tt"><a name="1087034"> </a><code>TraceRoll</code></p>
    </td>
    <td><p class="tt"><a name="1087036"> </a><code>UInt8</code></p>
    </td>
    <td><p class="tt"><a name="1087038"> </a>Boolean value, default is <code>true</code> (non-zero). If <code>true</code>, trace buffer will roll over when it fills. If <code>false</code>, tracing will stop as soon as trace buffer fills. </p>
    </td>
  </tr>
</table>

</div>

<h4>
  <a name="1087040"> </a>See Also 
</h4>

<p><a name="1087047"> </a><a href="NetLibrary.html#1087056"><code>NetLibSettingSet()</code></a>, <a href="NetLibrary.html#1085735"><code>NetLibIFSettingSet()</code></a>, <a href="NetLibrary.html#1085312"><code>NetLibIFSettingGet()</code></a>, <a href="NetLibrary.html#1085869"><code>NetLibMaster()</code></a> </p>

<h3 class="hbH3">
  <a name="1087056"> </a>NetLibSettingSet Function <a href="#1083561"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="1087058"> </a>Purpose 
</h4>

<p><a name="1087059"> </a>Sets a general setting.</p>
<h4>
  <a name="1087060"> </a>Declared In 
</h4>
<code>NetMgr.h<a name="1087061"> </a></code><h4>
  <a name="1087062"> </a>Prototype 
</h4>
<pre class="proto"><a name="1087064"></a>Err NetLibSettingSet (
   UInt16 libRefNum,
   UInt16 setting,
   void *valueP,
   UInt16 valueLen
)
</pre>
<h4>
  <a name="1087065"> </a>Parameters 
</h4>

<dl>
<dt><a name="1087066"> </a><code>&rarr;  <i><code>libRefNum</code></i></code></dt>
<dd><a name="1087067"> </a>Reference number of the net library.</dd>

<dt><a name="1087068"> </a><code>&rarr;  <i><code>setting</code></i></code></dt>
<dd><a name="1087070"> </a>Setting to set; one of the <code>NetSettingEnum</code> constants. See <a href="NetLibrary.html#1086926">Table 66.3</a>.</dd>

<dt><a name="1087074"> </a><code>&rarr;  <i><code>valueP</code></i></code></dt>
<dd><a name="1087075"> </a>New value for the setting.</dd>

<dt><a name="1087076"> </a><code>&rarr;  <i><code>valueLen</code></i></code></dt>
<dd><a name="1087077"> </a>Size of new setting.</dd>

</dl>
<h4>
  <a name="1087078"> </a>Returns 
</h4>

<p><a name="1087079"> </a>Returns one of the following values:</p>

<dl>
<dt><a name="1087080"> </a><code>0</code></dt>
<dd><a name="1087081"> </a>Success.</dd>

<dt><a name="1087083"> </a><code><code>netErrUnknownSetting</code></code></dt>
<dd><a name="1087084"> </a>Invalid setting constant.</dd>

<dt><a name="1087086"> </a><code><code>netErrInvalidSettingSize</code></code></dt>
<dd><a name="1087087"> </a><code>valueLen</code> was invalid for the given setting.</dd>

<dt><a name="1087089"> </a><code><code>netErrBufWrongSize</code></code></dt>
<dt><a name="1087091"> </a><code><code>netErrReadOnlySetting</code></code></dt>
</dl>
<h4>
  <a name="1087092"> </a>Sockets Equivalent
</h4>

<p><a name="1087093"> </a>None</p>
<h4>
  <a name="1087094"> </a>Comments 
</h4>

<p><a name="1087095"> </a>This call can be used to set the current value of any general setting. The caller must pass a pointer to a buffer which holds the new value (<code>valueP</code>), the size of the buffer (<code>valueLen</code>), and the setting ID (<code>setting</code>). The setting ID is one of the<code> netSettingXXX</code> constants in the <code>NetSettingEnum</code> type.</p>

<p><a name="1087096"> </a>If the net library is not open at the time this call is made, the setting is stored in the active configuration. You need to save the active configuration using <a href="NetLibrary.html#1084615"><code>NetLibConfigSaveAs()</code></a> if you want the new value of the setting to be used the next time the net library is opened.</p>

<p><a name="1087103"> </a>See <a href="NetLibrary.html#1086876"><code>NetLibSettingGet()</code></a> for an explanation of each of the settings. </p>

<p><a name="1087104"> </a>Of particular interest is the <code>netSettingResetAll</code> setting, which, if used, will reset all general settings to their default values. When using this setting, <code>valueP</code> and <code>valueLen</code> are ignored.</p>
<h4>
  <a name="1087105"> </a>See Also 
</h4>

<p><a name="1087112"> </a><a href="NetLibrary.html#1086876"><code>NetLibSettingGet()</code></a>, <a href="NetLibrary.html#1087056"><code>NetLibSettingSet()</code></a>, <a href="NetLibrary.html#1085735"><code>NetLibIFSettingSet()</code></a>, <a href="NetLibrary.html#1085869"><code>NetLibMaster()</code></a> </p>

<h3 class="hbH3">
  <a name="1087121"> </a>NetLibSocketAccept Function <a href="#1083561"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="1087123"> </a>Purpose 
</h4>

<p><a name="1087124"> </a>Accept a connection from a stream-based socket.</p>
<h4>
  <a name="1087125"> </a>Declared In 
</h4>
<code>NetMgr.h<a name="1087126"> </a></code><h4>
  <a name="1087127"> </a>Prototype 
</h4>
<pre class="proto"><a name="1087129"></a>Int16 NetLibSocketAccept (
   UInt16 libRefnum,
   NetSocketRef socket,
   NetSocketAddrType *sockAddrP,
   Int16 *addrLenP,
   Int32 timeout,
   Err *errP
)
</pre>
<h4>
  <a name="1087130"> </a>Parameters 
</h4>

<dl>
<dt><a name="1087131"> </a><code>&rarr;  <i><code>libRefNum</code></i></code></dt>
<dd><a name="1087132"> </a>Reference number of the net library.</dd>

<dt><a name="1087133"> </a><code>&rarr;  <i><code>socket</code></i></code></dt>
<dd><a name="1087134"> </a>Descriptor for the open socket.</dd>

<dt><a name="1087135"> </a><code>&larr;  <i><code>sockAddrP</code></i></code></dt>
<dd><a name="1087136"> </a>Address of remote host is returned here.</dd>

<dt><a name="1087137"> </a><code>&harr;  <i><code>addrLenP</code></i></code></dt>
<dd><a name="1087138"> </a>On entry, length of <code>sockAddrP</code> buffer in bytes. On exit, length of returned address stored in *<code>sockAddrP</code>.</dd>

<dt><a name="1087139"> </a><code>&rarr;  <i><code>timeout</code></i></code></dt>
<dd><a name="1087140"> </a>Maximum timeout in system ticks; -1 means wait forever. </dd>

<dt><a name="1087141"> </a><code>&larr;  <i><code>errP</code></i></code></dt>
<dd><a name="1087142"> </a>Contains an error code if the return value is -1.</dd>

</dl>
<h4>
  <a name="1087143"> </a>Returns 
</h4>

<p><a name="1087144"> </a>Returns the <code>NetSocketRef</code> of the new socket. If the return value is -1, an error has occurred, and <code>errP</code> contains one of the following values:</p>

<dl>
<dt><a name="1087145"> </a><code>0</code></dt>
<dd><a name="1087146"> </a>No error.</dd>

<dt><a name="1087148"> </a><code><code>netErrTimeout</code></code></dt>
<dd><a name="1087149"> </a>Call timed out. </dd>

<dt><a name="1087151"> </a><code><code>netErrNotOpen</code></code></dt>
<dd><a name="1087152"> </a>The referenced net library has not been opened yet. </dd>

<dt><a name="1087154"> </a><code><code>netErrParamErr</code></code></dt>
<dt><a name="1087156"> </a><code><code>netErrSocketNotOpen</code></code></dt>
<dt><a name="1087158"> </a><code><code>netErrSocketNotConnected</code></code></dt>
<dt><a name="1087160"> </a><code><code>netErrSocketClosedByRemote</code></code></dt>
<dt><a name="1087162"> </a><code><code>netErrWrongSocketType</code></code></dt>
<dt><a name="1087164"> </a><code><code>netErrSocketNotListening</code></code></dt>
<dt><a name="1087166"> </a><code><code>netErrUnimplemented</code> </code></dt>
</dl>
<h4>
  <a name="1087167"> </a>Sockets Equivalent
</h4>

<p><a name="1087168"> </a><code>int accept (int socket, void *sockAddrP,<br>int *addrLenP);</code></p>
<h4>
  <a name="1087169"> </a>Comments 
</h4>

<p><a name="1087170"> </a>Accepts the next connection request from a remote client. This call is only applicable to stream-based sockets. Before calling <code>NetLibSocketAccept</code> on a socket, a server application needs to:</p>
<ul type="disc">
  <li><a name="1087175"> </a>Open the socket (<a href="NetLibrary.html#1087549"><code>NetLibSocketOpen()</code></a>). 
  <li><a name="1087179"> </a>Bind the socket to a local address (<a href="NetLibrary.html#1087258"><code>NetLibSocketBind()</code></a>).
  <li><a name="1087180"> </a>Set the maximum pending connection-request queue length (<a href="NetLibrary.html#1087462"><code>NetLibSocketListen()</code></a>). 
</ul>

<p><a name="1087184"> </a><code>NetLibSocketAccept</code> will block until a successful connection request is obtained from a remote client. After a successful connection is made, this call returns with the address of the remote host in <code>*sockAddrP</code> and the socket descriptor of a <span style="color: #000000;  font-style: normal; font-weight: bold; text-decoration: none; text-transform: none; vertical-align: baseline">new</span> socket as the return value. You then use the new socket to send and receive data. </p>
<h4>
  <a name="1087185"> </a>See Also 
</h4>

<p><a name="1087192"> </a><a href="NetLibrary.html#1087258"><code>NetLibSocketBind()</code></a>, <a href="NetLibrary.html#1087462"><code>NetLibSocketListen()</code></a> </p>

<h3 class="hbH3">
  <a name="1087195"> </a>NetLibSocketAddr Function <a href="#1083561"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="1087197"> </a>Purpose 
</h4>

<p><a name="1087198"> </a>Returns the local and remote addresses currently associated with a socket.</p>
<h4>
  <a name="1087199"> </a>Declared In 
</h4>
<code>NetMgr.h<a name="1087200"> </a></code><h4>
  <a name="1087201"> </a>Prototype 
</h4>
<pre class="proto"><a name="1087203"></a>Int16 NetLibSocketAddr (
   UInt16 libRefnum,
   NetSocketRef socketRef,
   NetSocketAddrType *locAddrP,
   Int16 *locAddrLenP,
   NetSocketAddrType *remAddrP,
   Int16 *remAddrLenP,
   Int32 timeout,
   Err *errP
)
</pre>
<h4>
  <a name="1087204"> </a>Parameters 
</h4>

<dl>
<dt><a name="1087205"> </a><code>&rarr;  <i><code>libRefNum</code></i></code></dt>
<dd><a name="1087206"> </a>Reference number of the net library.</dd>

<dt><a name="1087207"> </a><code>&rarr;  <i><code>socketRef</code></i></code></dt>
<dd><a name="1087208"> </a>Descriptor for the open socket.</dd>

<dt><a name="1087209"> </a><code>&larr;  <i><code>locAddrP</code></i></code></dt>
<dd><a name="1087210"> </a>Local address of socket is returned here.</dd>

<dt><a name="1087211"> </a><code>&harr;  <i><code>locAddrLenP</code></i></code></dt>
<dd><a name="1087212"> </a>On entry, length of <code>locAddrP</code> buffer in bytes. On exit, length of returned address stored in *<code>locAddrP</code>.</dd>

<dt><a name="1087213"> </a><code>&larr;  <i><code>remAddrP</code></i></code></dt>
<dd><a name="1087214"> </a>Address of remote host is returned here.</dd>

<dt><a name="1087215"> </a><code>&harr;  <i><code>remAddrLenP</code></i></code></dt>
<dd><a name="1087216"> </a>On entry, length of <code>remAddrP</code> buffer in bytes. On exit, length of returned address stored in *<code>remAddrP</code>.</dd>

<dt><a name="1087217"> </a><code>&rarr;  <i><code>timeout</code></i></code></dt>
<dd><a name="1087218"> </a>Maximum timeout in system ticks; -1 means wait forever. </dd>

<dt><a name="1087219"> </a><code>&larr;  <i><code>errP</code></i></code></dt>
<dd><a name="1087220"> </a>Contains an error code if the return value is -1.</dd>

</dl>
<h4>
  <a name="1087221"> </a>Returns 
</h4>

<p><a name="1087222"> </a>Returns 0 upon success and -1 if an error occurred. If the return value is -1, <code>errP</code> contains one of the following values:</p>

<dl>
<dt><a name="1087223"> </a><code>0</code></dt>
<dd><a name="1087224"> </a>No error.</dd>

<dt><a name="1087226"> </a><code><code>netErrTimeout</code></code></dt>
<dd><a name="1087227"> </a>Call timed out. </dd>

<dt><a name="1087229"> </a><code><code>netErrNotOpen</code></code></dt>
<dd><a name="1087230"> </a>The referenced net library has not been opened yet. </dd>

<dt><a name="1087232"> </a><code><code>netErrParamErr</code></code></dt>
<dt><a name="1087234"> </a><code><code>netErrSocketNotOpen</code></code></dt>
<dt><a name="1087236"> </a><code><code>netErrSocketClosedByRemote</code></code></dt>
<dt><a name="1087238"> </a><code><code>netErrOutOfCmdBlocks</code> </code></dt>
</dl>
<h4>
  <a name="1087239"> </a>Sockets Equivalent
</h4>

<p><a name="1087240"> </a><code>int getpeername (int s, struct sockaddr *name,<br>int *namelen);</code></p>

<p><a name="1087241"> </a><code>int getsockname (int s, struct sockaddr *name,<br>int *namelen);</code></p>
<h4>
  <a name="1087242"> </a>Comments 
</h4>

<p><a name="1087243"> </a>This call is mainly useful for stream-based sockets. It allows the caller to find out what address was bound to a connected socket and the address of the remote host that it's connected to. </p>

<p><a name="1087244"> </a>In Palm OS version 3.0 and higher, if you pass a raw socket to this function, it returns the instance number and creator of the interface to which the socket is bound. </p>
<h4>
  <a name="1087245"> </a>See Also 
</h4>

<p><a name="1087252"> </a><a href="NetLibrary.html#1087258"><code>NetLibSocketBind()</code></a>, <a href="NetLibrary.html#1087391"><code>NetLibSocketConnect()</code></a>, <a href="NetLibrary.html#1087121"><code>NetLibSocketAccept()</code></a> </p>

<h3 class="hbH3">
  <a name="1087258"> </a>NetLibSocketBind Function <a href="#1083561"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="1087260"> </a>Purpose 
</h4>

<p><a name="1087261"> </a>Assign a local address to a socket.</p>
<h4>
  <a name="1087262"> </a>Declared In 
</h4>
<code>NetMgr.h<a name="1087263"> </a></code><h4>
  <a name="1087264"> </a>Prototype 
</h4>
<pre class="proto"><a name="1087266"></a>Int16 NetLibSocketBind (
   UInt16 libRefnum,
   NetSocketRef socket,
   NetSocketAddrType *sockAddrP,
   Int16 addrLen,
   Int32 timeout,
   Err *errP
)
</pre>
<h4>
  <a name="1087267"> </a>Parameters 
</h4>

<dl>
<dt><a name="1087268"> </a><code>&rarr;  <i><code>libRefNum</code></i></code></dt>
<dd><a name="1087269"> </a>Reference number of the net library.</dd>

<dt><a name="1087270"> </a><code>&rarr;  <i><code>socket</code></i></code></dt>
<dd><a name="1087271"> </a>Descriptor for the open socket.</dd>

<dt><a name="1087272"> </a><code>&rarr;  <i><code>sockAddrP</code></i></code></dt>
<dd><a name="1087273"> </a>Pointer to the address to give to the socket. This can be a <a href="NetLibrary.html#1083798"><code>NetSocketAddrINType</code></a> or a <a href="NetLibrary.html#1083827"><code>NetSocketAddrRawType</code></a>.</dd>

<dt><a name="1087280"> </a><code>&rarr;  <i><code>addrLen</code></i></code></dt>
<dd><a name="1087281"> </a>Length of address in *<code>sockAddrP</code>.</dd>

<dt><a name="1087282"> </a><code>&rarr;  <i><code>timeout</code></i></code></dt>
<dd><a name="1087283"> </a>Maximum timeout in system ticks; -1 means wait forever. </dd>

<dt><a name="1087284"> </a><code>&larr;  <i><code>errP</code></i></code></dt>
<dd><a name="1087285"> </a>Contains an error code if the return value is -1.</dd>

</dl>
<h4>
  <a name="1087286"> </a>Returns 
</h4>

<p><a name="1087287"> </a>Returns 0 upon success and -1 if an error occurred. If an error occurred, <code>errP</code> contains one of the following values:</p>

<dl>
<dt><a name="1087288"> </a><code>0</code></dt>
<dd><a name="1087289"> </a>No error.</dd>

<dt><a name="1087291"> </a><code><code>netErrTimeout</code></code></dt>
<dd><a name="1087292"> </a>Call timed out. </dd>

<dt><a name="1087294"> </a><code><code>netErrNotOpen</code></code></dt>
<dd><a name="1087295"> </a>The referenced net library has not been opened yet. </dd>

<dt><a name="1087297"> </a><code><code>netErrParamErr</code></code></dt>
<dt><a name="1087299"> </a><code><code>netErrSocketNotOpen</code></code></dt>
<dt><a name="1087301"> </a><code><code>netErrSocketAlreadyConnected </code></code></dt>
<dt><a name="1087303"> </a><code><code>netErrSocketClosedByRemote </code></code></dt>
<dt><a name="1087305"> </a><code><code>netErrOutOfCmdBlocks</code> </code></dt>
</dl>
<h4>
  <a name="1087306"> </a>Sockets Equivalent
</h4>

<p><a name="1087307"> </a><code>int bind (int socket, const void *sockAddrP,<br>int addrLen);</code></p>
<h4>
  <a name="1087308"> </a>Comments 
</h4>

<p><a name="1087309"> </a>Applications that want to wait for an incoming connection request from a remote host must call this function. After calling <code>NetLibSocketBind</code>, applications can call <a href="NetLibrary.html#1087462"><code>NetLibSocketListen()</code></a> and then <a href="NetLibrary.html#1087121"><code>NetLibSocketAccept()</code></a> to make the socket ready to accept connection requests.</p>
<h4>
  <a name="1087316"> </a>Compatibility 
</h4>

<p><a name="1087317"> </a>Raw sockets are only supported in Palm OS version 3.0 and higher. See <a href="NetLibrary.html#1087549"><code>NetLibSocketOpen()</code></a> for instructions on how to bind raw sockets. </p>
<h4>
  <a name="1087321"> </a>See Also 
</h4>

<p><a name="1087328"> </a><a href="NetLibrary.html#1087391"><code>NetLibSocketConnect()</code></a>, <a href="NetLibrary.html#1087462"><code>NetLibSocketListen()</code></a>, <a href="NetLibrary.html#1087121"><code>NetLibSocketAccept()</code></a> </p>

<h3 class="hbH3">
  <a name="1087334"> </a>NetLibSocketClose Function <a href="#1083561"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="1087336"> </a>Purpose 
</h4>

<p><a name="1087337"> </a>Close a socket.</p>
<h4>
  <a name="1087338"> </a>Declared In 
</h4>
<code>NetMgr.h<a name="1087339"> </a></code><h4>
  <a name="1087340"> </a>Prototype 
</h4>
<pre class="proto"><a name="1087342"></a>Int16 NetLibSocketClose (
   UInt16 libRefnum,
   NetSocketRef socket,
   Int32 timeout,
   Err *errP
)
</pre>
<h4>
  <a name="1087343"> </a>Parameters 
</h4>

<dl>
<dt><a name="1087344"> </a><code>&rarr;  <i><code>libRefNum</code></i></code></dt>
<dd><a name="1087345"> </a>Reference number of the net library.</dd>

<dt><a name="1087346"> </a><code>&rarr;  <i><code>socket</code></i></code></dt>
<dd><a name="1087347"> </a>Descriptor for the open socket.</dd>

<dt><a name="1087348"> </a><code>&rarr;  <i><code>timeout</code></i></code></dt>
<dd><a name="1087349"> </a>Maximum timeout in system ticks; -1 means wait forever. </dd>

<dt><a name="1087350"> </a><code>&larr;  <i><code>errP</code></i></code></dt>
<dd><a name="1087351"> </a>Contains an error code if the return value is -1.</dd>

</dl>
<h4>
  <a name="1087352"> </a>Returns 
</h4>

<p><a name="1087353"> </a>Returns 0 upon success and -1 if an error occurred. If an error occurred, <code>errP</code> contains one of the following values:</p>

<dl>
<dt><a name="1087354"> </a><code>0</code></dt>
<dd><a name="1087355"> </a>No error.</dd>

<dt><a name="1087357"> </a><code><code>netErrTimeout</code></code></dt>
<dd><a name="1087358"> </a>Call timed out. </dd>

<dt><a name="1087360"> </a><code><code>netErrNotOpen</code></code></dt>
<dd><a name="1087361"> </a>The referenced net library has not been opened yet. </dd>

<dt><a name="1087363"> </a><code><code>netErrParamErr</code></code></dt>
<dt><a name="1087365"> </a><code><code>netErrSocketNotOpen</code></code></dt>
<dt><a name="1087367"> </a><code><code>netErrOutOfCmdBlocks</code> </code></dt>
</dl>
<h4>
  <a name="1087368"> </a>Sockets Equivalent
</h4>

<p><a name="1087369"> </a><code>int close (int socket);</code></p>
<h4>
  <a name="1087370"> </a>Comments 
</h4>

<p><a name="1087371"> </a>Closes down a socket and frees all memory associated with it. </p>
<h4>
  <a name="1087381"> </a>See Also 
</h4>

<p><a name="1087388"> </a><a href="NetLibrary.html#1087549"><code>NetLibSocketOpen()</code></a>, <a href="NetLibrary.html#1088094"><code>NetLibSocketShutdown()</code></a> </p>

<h3 class="hbH3">
  <a name="1087391"> </a>NetLibSocketConnect Function <a href="#1083561"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="1087393"> </a>Purpose 
</h4>

<p><a name="1087394"> </a>Assign a destination address to a socket and initiate three-way handshake if it's stream based.</p>
<h4>
  <a name="1087395"> </a>Declared In 
</h4>
<code>NetMgr.h<a name="1087396"> </a></code><h4>
  <a name="1087397"> </a>Prototype 
</h4>
<pre class="proto"><a name="1087399"></a>Int16 NetLibSocketConnect (
   UInt16 libRefnum,
   NetSocketRef socket,
   NetSocketAddrType *sockAddrP,
   Int16 addrLen,
   Int32 timeout,
   Err *errP
)
</pre>
<h4>
  <a name="1087400"> </a>Parameters 
</h4>

<dl>
<dt><a name="1087401"> </a><code>&rarr;  <i><code>libRefNum</code></i></code></dt>
<dd><a name="1087402"> </a>Reference number of the net library.</dd>

<dt><a name="1087403"> </a><code>&rarr;  <i><code>socket</code></i></code></dt>
<dd><a name="1087404"> </a>Descriptor for the open socket.</dd>

<dt><a name="1087405"> </a><code>&rarr;  <i><code>sockAddrP</code></i></code></dt>
<dd><a name="1087406"> </a>Pointer to address to connect to.</dd>

<dt><a name="1087407"> </a><code>&rarr;  <i><code>addrLen</code></i></code></dt>
<dd><a name="1087408"> </a>Length of address in *<code>sockAddrP.</code></dd>

<dt><a name="1087409"> </a><code>&rarr;  <i><code>timeout</code></i></code></dt>
<dd><a name="1087410"> </a>Maximum timeout in system ticks; -1 means wait forever. </dd>

<dt><a name="1087411"> </a><code>&larr;  <i><code>errP</code></i></code></dt>
<dd><a name="1087412"> </a>Contains an error code if the return value is -1.</dd>

</dl>
<h4>
  <a name="1087413"> </a>Returns 
</h4>

<p><a name="1087414"> </a>Returns 0 upon success and -1 if an error occurred. If an error occurred, <code>errP</code> contains one of the following values:</p>

<dl>
<dt><a name="1087415"> </a><code>0</code></dt>
<dd><a name="1087416"> </a>No error.</dd>

<dt><a name="1087418"> </a><code><code>netErrTimeout</code></code></dt>
<dd><a name="1087419"> </a>Call timed out. </dd>

<dt><a name="1087421"> </a><code><code>netErrNotOpen</code></code></dt>
<dd><a name="1087422"> </a>The referenced net library has not been opened yet. </dd>

<dt><a name="1087424"> </a><code><code>netErrParamErr</code></code></dt>
<dt><a name="1087426"> </a><code><code>netErrSocketNotOpen</code></code></dt>
<dt><a name="1087428"> </a><code><code>netErrSocketBusy</code></code></dt>
<dt><a name="1087430"> </a><code><code>netErrNoInterfaces</code></code></dt>
<dd><a name="1087431"> </a>Incorrect setup.</dd>

<dt><a name="1087433"> </a><code><code>netErrPortInUse</code></code></dt>
<dt><a name="1087435"> </a><code><code>netErrQuietTimeNotElapsed</code></code></dt>
<dt><a name="1087437"> </a><code><code>netErrInternal</code></code></dt>
<dt><a name="1087439"> </a><code><code>netErrSocketAlreadyConnected </code></code></dt>
<dt><a name="1087441"> </a><code><code>netErrSocketClosedByRemote</code></code></dt>
<dt><a name="1087443"> </a><code><code>netErrTooManyTCPConnections</code></code></dt>
<dt><a name="1087445"> </a><code><code>netErrWouldBlock</code> </code></dt>
<dt><a name="1087447"> </a><code><code>netErrWrongSocketType</code> </code></dt>
<dt><a name="1087449"> </a><code><code>netErrOutOfCmdBlocks</code> </code></dt>
</dl>
<h4>
  <a name="1087450"> </a>Sockets Equivalent
</h4>

<p><a name="1087451"> </a><code>int connect (int socket, const void *sockAddrP,<br>int addrLen);</code></p>
<h4>
  <a name="1087452"> </a>See Also 
</h4>

<p><a name="1087459"> </a><a href="NetLibrary.html#1087258"><code>NetLibSocketBind()</code></a>, <a href="NetworkUtils.html#1108919"><code>NetUTCPOpen()</code></a> </p>

<h3 class="hbH3">
  <a name="1087462"> </a>NetLibSocketListen Function <a href="#1083561"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="1087464"> </a>Purpose 
</h4>

<p><a name="1087465"> </a>Put a stream-based socket into passive listen mode.</p>
<h4>
  <a name="1087466"> </a>Declared In 
</h4>
<code>NetMgr.h<a name="1087467"> </a></code><h4>
  <a name="1087468"> </a>Prototype 
</h4>
<pre class="proto"><a name="1087470"></a>Int16 NetLibSocketListen (
   UInt16 libRefnum,
   NetSocketRef socket,
   UInt16 queueLen,
   Int32 timeout,
   Err *errP
)
</pre>
<h4>
  <a name="1087471"> </a>Parameters 
</h4>

<dl>
<dt><a name="1087472"> </a><code>&rarr;  <i><code>libRefNum</code></i></code></dt>
<dd><a name="1087473"> </a>Reference number of the net library.</dd>

<dt><a name="1087474"> </a><code>&rarr;  <i><code>socket</code></i></code></dt>
<dd><a name="1087475"> </a>Descriptor for the open socket.</dd>

<dt><a name="1087476"> </a><code>&rarr;  <i><code>queueLen</code></i></code></dt>
<dd><a name="1087477"> </a>Maximum number of pending connections allowed.</dd>

<dt><a name="1087478"> </a><code>&rarr;  <i><code>timeout</code></i></code></dt>
<dd><a name="1087479"> </a>Maximum timeout in system ticks; -1 means wait forever. </dd>

<dt><a name="1087480"> </a><code>&larr;  <i><code>errP</code></i></code></dt>
<dd><a name="1087481"> </a>Contains an error code if the return value is -1.</dd>

</dl>
<h4>
  <a name="1087482"> </a>Returns 
</h4>

<p><a name="1087483"> </a>Returns 0 upon success and -1 if an error occurred. If an error occurred, <code>errP</code> contains one of the following values:</p>

<dl>
<dt><a name="1087484"> </a><code>0</code></dt>
<dd><a name="1087485"> </a>No error.</dd>

<dt><a name="1087487"> </a><code><code>netErrTimeout</code></code></dt>
<dd><a name="1087488"> </a>Call timed out. </dd>

<dt><a name="1087490"> </a><code><code>netErrNotOpen</code></code></dt>
<dd><a name="1087491"> </a>The referenced net library has not been opened yet. </dd>

<dt><a name="1087493"> </a><code><code>netErrParamErr</code></code></dt>
<dt><a name="1087495"> </a><code><code>netErrOutOfResources</code></code></dt>
<dt><a name="1087497"> </a><code><code>netErrSocketNotOpen</code></code></dt>
<dt><a name="1087499"> </a><code><code>netErrSocketBusy</code></code></dt>
<dt><a name="1087501"> </a><code><code>netErrNoInterfaces</code></code></dt>
<dd><a name="1087502"> </a>Incorrect setup.</dd>

<dt><a name="1087504"> </a><code><code>netErrPortInUse</code></code></dt>
<dt><a name="1087506"> </a><code><code>netErrInternal</code></code></dt>
<dt><a name="1087508"> </a><code><code>netErrSocketAlreadyConnected </code></code></dt>
<dt><a name="1087510"> </a><code><code>netErrSocketClosedByRemote</code></code></dt>
<dt><a name="1087512"> </a><code><code>netErrWrongSocketType</code></code></dt>
<dt><a name="1087523"> </a><code><code>netErrQuietTimeNotElapsed</code> </code></dt>
<dt><a name="1087525"> </a><code><code>netErrOutOfCmdBlocks</code> </code></dt>
</dl>
<h4>
  <a name="1087526"> </a>Sockets Equivalent
</h4>

<p><a name="1087527"> </a><code>int listen (int socket, int queueLen);</code></p>
<h4>
  <a name="1087528"> </a>Comments 
</h4>

<p><a name="1087529"> </a>Sets the maximum allowable length of the queue for pending connections. This call is only applicable to stream-based (TCP/IP) sockets. </p>

<p><a name="1087530"> </a>After a socket is created and bound to a local address using <a href="NetLibrary.html#1087258"><code>NetLibSocketBind()</code></a>, a server application can call <code>NetLibSocketListen</code> and then <a href="NetLibrary.html#1087121"><code>NetLibSocketAccept()</code></a> to accept connections from remote clients. </p>

<p><a name="1087538"> </a>The <code>queueLen</code> is currently quietly limited to 1 (higher values are ignored).</p>
<h4>
  <a name="1087539"> </a>See Also 
</h4>

<p><a name="1087546"> </a><a href="NetLibrary.html#1087258"><code>NetLibSocketBind()</code></a>, <a href="NetLibrary.html#1087121"><code>NetLibSocketAccept()</code></a> </p>

<h3 class="hbH3">
  <a name="1087549"> </a>NetLibSocketOpen Function <a href="#1083561"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="1087551"> </a>Purpose 
</h4>

<p><a name="1087552"> </a>Open a new socket.</p>
<h4>
  <a name="1087553"> </a>Declared In 
</h4>
<code>NetMgr.h<a name="1087554"> </a></code><h4>
  <a name="1087555"> </a>Prototype 
</h4>
<pre class="proto"><a name="1087558"></a>NetSocketRef NetLibSocketOpen (
   UInt16 libRefnum,
   NetSocketAddrEnum domain,
   NetSocketTypeEnum type,
   Int16 protocol,
   Int32 timeout,
   Err *errP
)
</pre>
<h4>
  <a name="1087559"> </a>Parameters 
</h4>

<dl>
<dt><a name="1087560"> </a><code>&rarr;  <i><code>libRefNum</code></i></code></dt>
<dd><a name="1087561"> </a>Reference number of the net library.</dd>

<dt><a name="1087562"> </a><code>&rarr;  <i><code>domain</code></i></code></dt>
<dd><a name="1087566"> </a>Address domain. See <a href="NetLibrary.html#1083775"><code>NetSocketAddrEnum</code></a>.</dd>

<dt><a name="1087567"> </a><code>&rarr;  <i><code>type</code></i></code></dt>
<dd><a name="1087571"> </a>Desired type of connection. See <a href="NetLibrary.html#1083882"><code>NetSocketTypeEnum</code></a>.</dd>

<dt><a name="1087572"> </a><code>&rarr;  <i><code>protocol</code></i></code></dt>
<dd><a name="1087573"> </a>Protocol to use. This parameter is currently ignored. </dd>

<dd><a name="1087574"> </a>For raw sockets in the <code>netSocketAddrINET</code> domain, specify one of the following:</dd>

<dl>
<dt><a name="1087576"> </a><code><code>netSocketProtoIPTCP</code> </code></dt>
<dt><a name="1087578"> </a><code><code>netSocketProtoIPUDP</code> </code></dt>
<dt><a name="1087580"> </a><code><code>netSocketProtoIPRAW</code> </code></dt>
</dl>
<dd><a name="1087581"> </a>For all other socket types or for raw sockets in the raw domain, this parameter is ignored. </dd>

<dt><a name="1087582"> </a><code>&rarr;  <i><code>timeout</code></i></code></dt>
<dd><a name="1087583"> </a>Maximum timeout in system ticks; -1 means wait forever. </dd>

<dt><a name="1087584"> </a><code>&larr;  <i><code>errP</code></i></code></dt>
<dd><a name="1087585"> </a>Contains an error code if the return value is -1.</dd>

</dl>
<h4>
  <a name="1087586"> </a>Returns 
</h4>

<p><a name="1087587"> </a>Returns the <code>NetSocketRef</code> of the opened socket or -1 if an error occurred. If an error occurred, <code>errP</code> contains one of the following values:</p>

<dl>
<dt><a name="1087588"> </a><code>0</code></dt>
<dd><a name="1087589"> </a>No error.</dd>

<dt><a name="1087591"> </a><code><code>netErrTimeout</code></code></dt>
<dd><a name="1087592"> </a>Call timed out. </dd>

<dt><a name="1087594"> </a><code><code>netErrNotOpen</code></code></dt>
<dd><a name="1087595"> </a>The referenced net library has not been opened yet. </dd>

<dt><a name="1087597"> </a><code><code>netErrParamErr</code></code></dt>
<dt><a name="1087599"> </a><code><code>netErrNoMoreSockets</code></code></dt>
<dt><a name="1087601"> </a><code><code>netErrOutOfCmdBlocks</code> </code></dt>
<dt><a name="1087603"> </a><code><code>netErrOutOfMemory</code> </code></dt>
</dl>
<h4>
  <a name="1087604"> </a>Sockets Equivalent
</h4>

<p><a name="1087605"> </a><code>int socket (int domain, int type, int protocol);</code></p>
<h4>
  <a name="1087606"> </a>Comments 
</h4>

<p><a name="1087607"> </a>Allocates memory for a new socket and opens it. </p>

<p><a name="1087608"> </a>Raw sockets are supported in Palm OS version 3.0 and higher. Two types of raw sockets are supported:</p>
<ul type="disc">
  <li><a name="1087610"> </a>Raw sockets in the <code>netSocketAddrINET</code> domain
   <p><a name="1087611"> </a>In this case, you must bind the socket to an IP address using <a href="NetLibrary.html#1087258"><code>NetLibSocketBind()</code></a>, passing a <a href="NetLibrary.html#1083798"><code>NetSocketAddrINType</code></a> structure for the socket address. The port field is ignored.</p>
   <p><a name="1087618"> </a>For applications that use raw sockets in the INET domain, the net library checks the destination IP address of all incoming packets to see if it matches any of those raw sockets. If it does, the packet is enqueued directly into the matching socket and is <i>not</i> passed to the protocol stack. </p>
   <p><a name="1087619"> </a>When an application sends data through raw sockets in the IP domain, the net library packages the data into a packet and passes it directly to the interface's send routine. You are responsible for forming the entire IP header, including any necessary checksums, source and destination IP address, and so on. </p>
  <li><a name="1087621"> </a>Raw sockets in the <code>netSocketAddrRaw</code> domain with no protocol
   <p><a name="1087622"> </a>In this case, you must bind the socket to an interface using <a href="NetLibrary.html#1087258"><code>NetLibSocketBind()</code></a>, passing a <a href="NetLibrary.html#1083827"><code>NetSocketAddrRawType</code></a> structure for the socket address. The instance and creator specify which interface the caller wants to receive raw packets from. </p>
   <p><a name="1087629"> </a>When an interface is bound to a raw socket with no protocol, the net library places that interface into raw mode. In raw mode, the interface passes all incoming packets, no matter what the link layer protocol, to its raw receive function. </p>
   <p><a name="1087630"> </a>When an application sends data through a raw socket with no protocol, the net library packages the data into a packet and passes it directly to the interface's send routine. </p>
   <p><a name="1087631"> </a>The interface remains in raw mode until the raw socket is closed.</p>
</ul>
<h4>
  <a name="1087640"> </a>Compatibility 
</h4>

<p><a name="1087641"> </a>Raw sockets supported only in Palm OS version 3.0 and higher.</p>
<h4>
  <a name="1087642"> </a>See Also 
</h4>

<p><a name="1087649"> </a><a href="NetLibrary.html#1087334"><code>NetLibSocketClose()</code></a>, <a href="NetworkUtils.html#1108919"><code>NetUTCPOpen()</code></a> </p>

<h3 class="hbH3">
  <a name="1087652"> </a>NetLibSocketOptionGet Function <a href="#1083561"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="1087654"> </a>Purpose 
</h4>

<p><a name="1087655"> </a>Retrieves the current value of a socket option.</p>
<h4>
  <a name="1087656"> </a>Declared In 
</h4>
<code>NetMgr.h<a name="1087657"> </a></code><h4>
  <a name="1087658"> </a>Prototype 
</h4>
<pre class="proto"><a name="1087660"></a>Int16 NetLibSocketOptionGet (
   UInt16 libRefnum,
   NetSocketRef socket,
   UInt16 level,
   UInt16 option,
   void *optValueP,
   UInt16 *optValueLenP,
   Int32 timeout,
   Err *errP
)
</pre>
<h4>
  <a name="1087661"> </a>Parameters 
</h4>

<dl>
<dt><a name="1087662"> </a><code>&rarr;  <i><code>libRefNum</code></i></code></dt>
<dd><a name="1087663"> </a>Reference number of the net library.</dd>

<dt><a name="1087664"> </a><code>&rarr;  <i><code>socket</code></i></code></dt>
<dd><a name="1087665"> </a>Descriptor for the open socket.</dd>

<dt><a name="1087666"> </a><code>&rarr;  <i><code>level</code></i></code></dt>
<dd><a name="1087668"> </a>Level of the option, one of the <code>NetSocketOptLevelEnum</code> constants. See <a href="NetLibrary.html#1087723"><code>NetLibSocketOptionSet()</code></a>. </dd>

<dt><a name="1087672"> </a><code>&rarr;  <i><code>option</code></i></code></dt>
<dd><a name="1087674"> </a>One of the <code>NetSocketOptEnum</code> constants. See <a href="NetLibrary.html#1087723"><code>NetLibSocketOptionSet()</code></a>. </dd>

<dt><a name="1087678"> </a><code>&larr;  <i><code>optValueP</code></i></code></dt>
<dd><a name="1087679"> </a>Pointer to variable holding new value of option.</dd>

<dt><a name="1087680"> </a><code>&harr;  <i><code>optValueLenP</code></i></code></dt>
<dd><a name="1087681"> </a>Size of variable pointed to by <code>optValueP</code> on entry. Actual size of return value on exit. </dd>

<dt><a name="1087682"> </a><code>&rarr;  <i><code>timeout</code></i></code></dt>
<dd><a name="1087683"> </a>Maximum timeout in system ticks; -1 means wait forever. </dd>

<dt><a name="1087684"> </a><code>&larr;  <i><code>errP</code></i></code></dt>
<dd><a name="1087685"> </a>Contains an error code if the return value is -1.</dd>

</dl>
<h4>
  <a name="1087686"> </a>Returns 
</h4>

<p><a name="1087687"> </a>Returns 0 upon success and -1 if an error occurred. If an error occurred, <code>errP</code> contains one of the following values:</p>

<dl>
<dt><a name="1087688"> </a><code>0</code></dt>
<dd><a name="1087689"> </a>No error.</dd>

<dt><a name="1087691"> </a><code><code>netErrTimeout</code></code></dt>
<dd><a name="1087692"> </a>Call timed out. </dd>

<dt><a name="1087694"> </a><code><code>netErrNotOpen</code></code></dt>
<dd><a name="1087695"> </a>The referenced net library has not been opened yet. </dd>

<dt><a name="1087697"> </a><code><code>netErrParamErr</code></code></dt>
<dt><a name="1087699"> </a><code><code>netErrSocketNotOpen</code></code></dt>
<dt><a name="1087701"> </a><code><code>netErrUnimplemented</code></code></dt>
<dt><a name="1087703"> </a><code><code>netErrWrongSocketType</code></code></dt>
<dt><a name="1087705"> </a><code><code>netErrInvalidSettingSize</code> </code></dt>
</dl>
<h4>
  <a name="1087706"> </a>Sockets Equivalent
</h4>

<div class="CodeRule"><hr></div><pre class="CodeBlock">
<code>int getsockopt (int socket, int level, int option,
const void *optValueP, int *optValueLenP);</code><a name="1087707"> </a>
</pre><div class="CodeRule"><hr></div>

<h4>
  <a name="1087708"> </a>Comments 
</h4>

<p><a name="1087709"> </a>Returns the current value of a socket option. The caller passes a pointer to a variable to hold the returned value (in <code>optValueP</code>) and the size of this variable (in <code>*optValueLenP</code>). On exit, <code>*optValueP</code> is updated with the actual size of the return value. </p>

<p><a name="1087710"> </a>For all of the fixed size options (every option except <code>netSocketOptIPOptions</code>), <code>*optValueLenP</code> is unmodified on exit and this call does its best to return the value in the caller's desired type size. </p>

<p><a name="1087711"> </a>For compatibility with existing Internet applications, this call is quite flexible on the <code>*optValueLenP</code> parameter. If the desired type for an option is <code>FLAG</code>, this call supports an <code>*optValueLenP</code> of 1, 2, or 4. If the desired type for an option is <code>int</code>, it supports an <code>*optValueLenP</code> of 2 or 4. </p>

<p><a name="1087715"> </a>See <a href="NetLibrary.html#1087723"><code>NetLibSocketOptionSet()</code></a> for a list of available options. </p>
<h4>
  <a name="1087716"> </a>See Also 
</h4>

<p><a name="1087720"> </a><a href="NetLibrary.html#1087723"><code>NetLibSocketOptionSet()</code></a> </p>

<h3 class="hbH3">
  <a name="1087723"> </a>NetLibSocketOptionSet Function <a href="#1083561"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="1087725"> </a>Purpose 
</h4>

<p><a name="1087726"> </a>Set a socket option.</p>
<h4>
  <a name="1087727"> </a>Declared In 
</h4>
<code>NetMgr.h<a name="1087728"> </a></code><h4>
  <a name="1087729"> </a>Prototype 
</h4>
<pre class="proto"><a name="1087731"></a>Int16 NetLibSocketOptionSet (
   UInt16 libRefnum,
   NetSocketRef socket,
   UInt16 level,
   UInt16 option,
   void *optValueP,
   UInt16 optValueLen,
   Int32 timeout,
   Err *errP
)
</pre>
<h4>
  <a name="1087732"> </a>Parameters 
</h4>

<dl>
<dt><a name="1087733"> </a><code>&rarr;  <i><code>libRefNum</code></i></code></dt>
<dd><a name="1087734"> </a>Reference number of the net library.</dd>

<dt><a name="1087735"> </a><code>&rarr;  <i><code>socket</code></i></code></dt>
<dd><a name="1087736"> </a>Descriptor for the open socket.</dd>

<dt><a name="1087737"> </a><code>&rarr;  <i><code>level</code></i></code></dt>
<dd><a name="1087739"> </a>Level of the option, one of the <code>NetSocketOptLevelEnum</code> constants. See the comments section. </dd>

<dt><a name="1087740"> </a><code>&rarr;  <i><code>option</code></i></code></dt>
<dd><a name="1087742"> </a>One of the <code>NetSocketOptEnum</code> constants. See the comments section. </dd>

<dt><a name="1087743"> </a><code>&rarr;  <i><code>optValueP</code></i></code></dt>
<dd><a name="1087744"> </a>Pointer to the variable holding the new value of the option.</dd>

<dt><a name="1087745"> </a><code>&rarr;  <i><code>optValueLen</code></i></code></dt>
<dd><a name="1087746"> </a>Size of variable pointed to by <code>optValueP.</code></dd>

<dt><a name="1087747"> </a><code>&rarr;  <i><code>timeout</code></i></code></dt>
<dd><a name="1087748"> </a>Maximum timeout in system ticks; -1 means wait forever. </dd>

<dt><a name="1087749"> </a><code>&larr;  <i><code>errP</code></i></code></dt>
<dd><a name="1087750"> </a>Contains an error code if the return value is -1.</dd>

</dl>
<h4>
  <a name="1087751"> </a>Returns 
</h4>

<p><a name="1087752"> </a>Returns 0 upon success and -1 if an error occurred. If an error occurred, <code>errP</code> contains one of the following values:</p>

<dl>
<dt><a name="1087753"> </a><code>0</code></dt>
<dd><a name="1087754"> </a>No error.</dd>

<dt><a name="1087756"> </a><code><code>netErrTimeout</code></code></dt>
<dd><a name="1087757"> </a>Call timed out. </dd>

<dt><a name="1087759"> </a><code><code>netErrNotOpen</code></code></dt>
<dd><a name="1087760"> </a>The referenced net library has not been opened yet. </dd>

<dt><a name="1087762"> </a><code><code>netErrParamErr</code></code></dt>
<dt><a name="1087764"> </a><code><code>netErrSocketNotOpen</code></code></dt>
<dt><a name="1087766"> </a><code><code>netErrUnimplemented</code></code></dt>
<dt><a name="1087768"> </a><code><code>netErrWrongSocketType</code></code></dt>
<dt><a name="1087770"> </a><code><code>netErrInvalidSettingSize</code> </code></dt>
</dl>
<h4>
  <a name="1087771"> </a>Sockets Equivalent
</h4>

<p><a name="1087772"> </a><code>int setsockopt (int socketRef, int level,<br>int option, const void *optValueP,<br>int optValueLen);</code></p>
<h4>
  <a name="1087773"> </a>Comments 
</h4>

<p><a name="1087774"> </a>Sets various options associated with a socket. The caller passes a pointer to the new option value in <code>optValueP</code> and the size of the option in <code>optValueLen</code>. </p>

<p><a name="1087778"> </a><a href="NetLibrary.html#1087794">Table 66.4</a> lists the available options. </p>
<ul type="disc">
  <li><a name="1087779"> </a>The Level column specifies the option level, which is one of the <code>netSocketOptLevelXXX</code> constants. 
  <li><a name="1087780"> </a>The Option column lists the option, which is one of the <code>netSocketOptXXX</code> constants. 
  <li><a name="1087781"> </a>The G/S column lists whether this option can be fetched with the <a href="NetLibrary.html#1087652"><code>NetLibSocketOptionGet()</code></a> call (G) and/or set (S) with this call. 
  <li><a name="1087785"> </a>The type column lists the data type of the option. 
  <li><a name="1087786"> </a>The I column specifies whether or not this option is currently implemented.
</ul>

<p class="caption"><a name="1087794"> </a><b>Table 66.4&nbsp;&nbsp;Net Library Socket Options </b></p>
<div class="tablediv"><table cellspacing="0" class="tTable">

  <tr valign="top">
    <th><p class="tt"><a name="1087806"> </a><b>netSocket<br>OptLevel... </b></p>
    </th>
    <th><p class="tt"><a name="1087808"> </a><b><br>netSocketOpt...</b></p>
    </th>
    <th><p class="tt"><a name="1087810"> </a><b><br>G/S</b></p>
    </th>
    <th><p class="tt"><a name="1087812"> </a><b><br>Type </b></p>
    </th>
    <th><p class="tt"><a name="1087814"> </a><b><br>I</b></p>
    </th>
    <th><p class="tt"><a name="1087816"> </a><b><br>Description</b></p>
    </th>
  </tr>
  <tr valign="top">
    <td><p class="tt"><a name="1087818"> </a>IP</p>
    </td>
    <td><p class="tt"><a name="1087820"> </a>IPOptions </p>
    </td>
    <td><p class="tt"><a name="1087822"> </a>GS</p>
    </td>
    <td><p class="tt"><a name="1087824"> </a><code>UInt8[]</code></p>
    </td>
    <td><p class="tt"><a name="1087826"> </a>N</p>
    </td>
    <td><p class="tt"><a name="1087828"> </a>Options in IP Header</p>
    </td>
  </tr>
  <tr valign="top">
    <td><p class="tt"><a name="1087830"> </a>TCP</p>
    </td>
    <td><p class="tt"><a name="1087832"> </a>TCPNoDelay</p>
    </td>
    <td><p class="tt"><a name="1087834"> </a>GS</p>
    </td>
    <td><p class="tt"><a name="1087836"> </a><code>FLAG</code></p>
    </td>
    <td><p class="tt"><a name="1087838"> </a>Y</p>
    </td>
    <td><p class="tt"><a name="1087840"> </a>Don't delay send to coalesce packets</p>
    </td>
  </tr>
  <tr valign="top">
    <td><p class="tt"><a name="1087842"> </a>TCP</p>
    </td>
    <td><p class="tt"><a name="1087844"> </a>TCPMaxSeg</p>
    </td>
    <td><p class="tt"><a name="1087846"> </a>G</p>
    </td>
    <td><p class="tt"><a name="1087848"> </a><code>int</code></p>
    </td>
    <td><p class="tt"><a name="1087850"> </a>Y</p>
    </td>
    <td><p class="tt"><a name="1087852"> </a>Get TCP maximum segment size</p>
    </td>
  </tr>
  <tr valign="top">
    <td><p class="tt"><a name="1087854"> </a>Socket</p>
    </td>
    <td><p class="tt"><a name="1087856"> </a>SockDebug</p>
    </td>
    <td><p class="tt"><a name="1087858"> </a>GS</p>
    </td>
    <td><p class="tt"><a name="1087860"> </a><code>FLAG</code></p>
    </td>
    <td><p class="tt"><a name="1087862"> </a>N</p>
    </td>
    <td><p class="tt"><a name="1087864"> </a>Turn on recording of debug info</p>
    </td>
  </tr>
  <tr valign="top">
    <td><p class="tt"><a name="1087866"> </a>Socket</p>
    </td>
    <td><p class="tt"><a name="1087868"> </a>SockAcceptConn</p>
    </td>
    <td><p class="tt"><a name="1087870"> </a>G</p>
    </td>
    <td><p class="tt"><a name="1087872"> </a><code>FLAG</code></p>
    </td>
    <td><p class="tt"><a name="1087874"> </a>N</p>
    </td>
    <td><p class="tt"><a name="1087876"> </a>Socket has had listen</p>
    </td>
  </tr>
  <tr valign="top">
    <td><p class="tt"><a name="1087878"> </a>Socket</p>
    </td>
    <td><p class="tt"><a name="1087880"> </a>SockReuseAddr</p>
    </td>
    <td><p class="tt"><a name="1087882"> </a>GS</p>
    </td>
    <td><p class="tt"><a name="1087884"> </a><code>FLAG</code></p>
    </td>
    <td><p class="tt"><a name="1087886"> </a>N</p>
    </td>
    <td><p class="tt"><a name="1087888"> </a>Allow local address reuse</p>
    </td>
  </tr>
  <tr valign="top">
    <td><p class="tt"><a name="1087890"> </a>Socket</p>
    </td>
    <td><p class="tt"><a name="1087892"> </a>SockKeepAlive</p>
    </td>
    <td><p class="tt"><a name="1087894"> </a>GS</p>
    </td>
    <td><p class="tt"><a name="1087896"> </a><code>FLAG</code></p>
    </td>
    <td><p class="tt"><a name="1087898"> </a>Y</p>
    </td>
    <td><p class="tt"><a name="1087900"> </a>Keep connections alive</p>
    </td>
  </tr>
  <tr valign="top">
    <td><p class="tt"><a name="1087902"> </a>Socket</p>
    </td>
    <td><p class="tt"><a name="1087904"> </a>SockDontRoute</p>
    </td>
    <td><p class="tt"><a name="1087906"> </a>GS</p>
    </td>
    <td><p class="tt"><a name="1087908"> </a><code>FLAG</code></p>
    </td>
    <td><p class="tt"><a name="1087910"> </a>N</p>
    </td>
    <td><p class="tt"><a name="1087912"> </a>Just use interface addresses</p>
    </td>
  </tr>
  <tr valign="top">
    <td><p class="tt"><a name="1087914"> </a>Socket</p>
    </td>
    <td><p class="tt"><a name="1087916"> </a>SockBroadcast</p>
    </td>
    <td><p class="tt"><a name="1087918"> </a>GS</p>
    </td>
    <td><p class="tt"><a name="1087920"> </a><code>FLAG</code></p>
    </td>
    <td><p class="tt"><a name="1087922"> </a>N</p>
    </td>
    <td><p class="tt"><a name="1087924"> </a>Permit sending of broadcast messages</p>
    </td>
  </tr>
  <tr valign="top">
    <td><p class="tt"><a name="1087926"> </a>Socket</p>
    </td>
    <td><p class="tt"><a name="1087928"> </a>SockUseLoopback</p>
    </td>
    <td><p class="tt"><a name="1087930"> </a>GS</p>
    </td>
    <td><p class="tt"><a name="1087932"> </a><code>FLAG</code></p>
    </td>
    <td><p class="tt"><a name="1087934"> </a>N</p>
    </td>
    <td><p class="tt"><a name="1087936"> </a>Bypass hardware when possible</p>
    </td>
  </tr>
  <tr valign="top">
    <td><p class="tt"><a name="1087938"> </a>Socket</p>
    </td>
    <td><p class="tt"><a name="1087940"> </a>SockLinger</p>
    </td>
    <td><p class="tt"><a name="1087942"> </a>GS</p>
    </td>
    <td><p class="tt"><a name="1087944"> </a><code>NetSocketLingerType </code></p>
    </td>
    <td><p class="tt"><a name="1087946"> </a>Y</p>
    </td>
    <td><p class="tt"><a name="1087948"> </a>Linger on close if data present</p>
<p class="tt"><a name="1087950"> </a><code>NetSocketLingerType</code> is a structure with two fields: <code>onOff</code> (<code>true</code> or <code>false</code>) and <code>time</code> (linger time in seconds).</p>
    </td>
  </tr>
  <tr valign="top">
    <td><p class="tt"><a name="1087952"> </a>Socket</p>
    </td>
    <td><p class="tt"><a name="1087954"> </a>SockOOBInLine</p>
    </td>
    <td><p class="tt"><a name="1087956"> </a>GS</p>
    </td>
    <td><p class="tt"><a name="1087958"> </a><code>FLAG</code></p>
    </td>
    <td><p class="tt"><a name="1087960"> </a>N</p>
    </td>
    <td><p class="tt"><a name="1087962"> </a>Leave received OOB data in-line</p>
    </td>
  </tr>
  <tr valign="top">
    <td><p class="tt"><a name="1087964"> </a>Socket</p>
    </td>
    <td><p class="tt"><a name="1087966"> </a>SockSndBufSize</p>
    </td>
    <td><p class="tt"><a name="1087968"> </a>GS</p>
    </td>
    <td><p class="tt"><a name="1087970"> </a><code>int</code></p>
    </td>
    <td><p class="tt"><a name="1087972"> </a>N</p>
    </td>
    <td><p class="tt"><a name="1087974"> </a>Send buffer size</p>
    </td>
  </tr>
  <tr valign="top">
    <td><p class="tt"><a name="1087976"> </a>Socket</p>
    </td>
    <td><p class="tt"><a name="1087978"> </a>SockRcvBufSize</p>
    </td>
    <td><p class="tt"><a name="1087980"> </a>GS</p>
    </td>
    <td><p class="tt"><a name="1087982"> </a><code>int</code></p>
    </td>
    <td><p class="tt"><a name="1087984"> </a>N</p>
    </td>
    <td><p class="tt"><a name="1087986"> </a>Receive buffer size</p>
    </td>
  </tr>
  <tr valign="top">
    <td><p class="tt"><a name="1087988"> </a>Socket</p>
    </td>
    <td><p class="tt"><a name="1087990"> </a>SockSndLowWater </p>
    </td>
    <td><p class="tt"><a name="1087992"> </a>GS</p>
    </td>
    <td><p class="tt"><a name="1087994"> </a><code>int</code></p>
    </td>
    <td><p class="tt"><a name="1087996"> </a>N</p>
    </td>
    <td><p class="tt"><a name="1087998"> </a>Send low-water mark</p>
    </td>
  </tr>
  <tr valign="top">
    <td><p class="tt"><a name="1088000"> </a>Socket</p>
    </td>
    <td><p class="tt"><a name="1088002"> </a>SockRcvLowWater </p>
    </td>
    <td><p class="tt"><a name="1088004"> </a>GS</p>
    </td>
    <td><p class="tt"><a name="1088006"> </a><code>int</code></p>
    </td>
    <td><p class="tt"><a name="1088008"> </a>N</p>
    </td>
    <td><p class="tt"><a name="1088010"> </a>Receive low-water mark</p>
    </td>
  </tr>
  <tr valign="top">
    <td><p class="tt"><a name="1088012"> </a>Socket</p>
    </td>
    <td><p class="tt"><a name="1088014"> </a>SockSndTimeout</p>
    </td>
    <td><p class="tt"><a name="1088016"> </a>GS</p>
    </td>
    <td><p class="tt"><a name="1088018"> </a><code>int</code></p>
    </td>
    <td><p class="tt"><a name="1088020"> </a>N</p>
    </td>
    <td><p class="tt"><a name="1088022"> </a>Send timeout</p>
    </td>
  </tr>
  <tr valign="top">
    <td><p class="tt"><a name="1088024"> </a>Socket</p>
    </td>
    <td><p class="tt"><a name="1088026"> </a>SockRcvTimeout</p>
    </td>
    <td><p class="tt"><a name="1088028"> </a>GS</p>
    </td>
    <td><p class="tt"><a name="1088030"> </a><code>int</code></p>
    </td>
    <td><p class="tt"><a name="1088032"> </a>N</p>
    </td>
    <td><p class="tt"><a name="1088034"> </a>Receive timeout</p>
    </td>
  </tr>
  <tr valign="top">
    <td><p class="tt"><a name="1088036"> </a>Socket</p>
    </td>
    <td><p class="tt"><a name="1088038"> </a>SockErrorStatus</p>
    </td>
    <td><p class="tt"><a name="1088040"> </a>G</p>
    </td>
    <td><p class="tt"><a name="1088042"> </a><code>int</code></p>
    </td>
    <td><p class="tt"><a name="1088044"> </a>Y</p>
    </td>
    <td><p class="tt"><a name="1088046"> </a>Get error status and clear</p>
    </td>
  </tr>
  <tr valign="top">
    <td><p class="tt"><a name="1088048"> </a>Socket</p>
    </td>
    <td><p class="tt"><a name="1088050"> </a>SockSocketType</p>
    </td>
    <td><p class="tt"><a name="1088052"> </a>G</p>
    </td>
    <td><p class="tt"><a name="1088054"> </a><code>int</code></p>
    </td>
    <td><p class="tt"><a name="1088056"> </a>Y</p>
    </td>
    <td><p class="tt"><a name="1088058"> </a>Get socket type</p>
    </td>
  </tr>
  <tr valign="top">
    <td><p class="tt"><a name="1088060"> </a>Socket</p>
    </td>
    <td><p class="tt"><a name="1088062"> </a>SockNonBlocking</p>
    </td>
    <td><p class="tt"><a name="1088064"> </a>GS</p>
    </td>
    <td><p class="tt"><a name="1088066"> </a><code>FLAG</code></p>
    </td>
    <td><p class="tt"><a name="1088068"> </a>Y</p>
    </td>
    <td><p class="tt"><a name="1088070"> </a>Set non-blocking mode on/off</p>
    </td>
  </tr>
  <tr valign="top">
    <td><p class="tt"><a name="1144157"> </a>Socket</p>
    </td>
    <td><p class="tt"><a name="1144159"> </a>SockNotice</p>
    </td>
    <td><p class="tt"><a name="1144161"> </a>S</p>
    </td>
    <td><p class="tt"><a name="1144163"> </a><a href="NetLibrary.html#1144345"><code>NetSocketNoticeType</code></a></p>
    </td>
    <td><p class="tt"><a name="1144165"> </a>Y</p>
    </td>
    <td><p class="tts"><a name="1144167"> </a>Enable socket notices. Your application will receive a notice when certain socket conditions occur. Specify conditions you want to watch in the <br><code>optValueP-&gt;conditions</code> field.</p>
    </td>
  </tr>
  <tr valign="top">
    <td><p class="tt"><a name="1088072"> </a>Socket</p>
    </td>
    <td><p class="tt"><a name="1088074"> </a>SockRequireErrClear</p>
    </td>
    <td><p class="tt"><a name="1088076"> </a>GS</p>
    </td>
    <td><p class="tt"><a name="1088078"> </a>FLAG</p>
    </td>
    <td><p class="tt"><a name="1088080"> </a>Y</p>
    </td>
    <td><p class="tt"><a name="1088082"> </a>Return the current error status for all subsequent socket function calls until the error is cleared.</p>
    </td>
  </tr>
</table>

</div>


<p><a name="1088084"> </a>For compatibility with existing Internet applications, this call is quite flexible on the <code>optValueLen</code> parameter. If the desired type for an option is <code>FLAG</code>, this call accepts an <code>optValueLen</code> of 1, 2, or 4. If the desired type for an option is <code>int</code>, it accepts an <code>optValueLen</code> of 2 or 4. </p>

<p><a name="1088085"> </a>Except for the <code>netSocketOptSockNonBlocking</code> option, all options listed above have equivalents in the sockets API. The <code>netSocketOptSockNonBlocking</code> option was added to this call in the net library in order to implement the functionality of the UNIX <code>fcntl()</code> control call, which can be used to turn nonblocking mode on and off for sockets. </p>
<h4>
  <a name="1088087"> </a>See Also 
</h4>

<p><a name="1088091"> </a><a href="NetLibrary.html#1087652"><code>NetLibSocketOptionGet()</code></a> </p>

<h3 class="hbH3">
  <a name="1088094"> </a>NetLibSocketShutdown Function <a href="#1083561"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="1088096"> </a>Purpose 
</h4>

<p><a name="1088097"> </a>Shut down a socket in one or both directions.</p>
<h4>
  <a name="1088098"> </a>Declared In 
</h4>
<code>NetMgr.h<a name="1088099"> </a></code><h4>
  <a name="1088100"> </a>Prototype 
</h4>
<pre class="proto"><a name="1088102"></a>Int16 NetLibSocketShutdown (
   UInt16 libRefnum,
   NetSocketRef socket,
   Int16 direction,
   Int32 timeout,
   Err *errP
)
</pre>
<h4>
  <a name="1088103"> </a>Parameters 
</h4>

<dl>
<dt><a name="1088104"> </a><code>&rarr;  <i><code>libRefNum</code></i></code></dt>
<dd><a name="1088105"> </a>Reference number of the net library.</dd>

<dt><a name="1088106"> </a><code>&rarr;  <i><code>socket</code></i></code></dt>
<dd><a name="1088107"> </a>Descriptor for the open socket.</dd>

<dt><a name="1088108"> </a><code>&rarr;  <i><code>direction</code></i></code></dt>
<dd><a name="1088110"> </a>Direction to shut down. One of the <code>NetSocketDirEnum</code> constants. Specifically:</dd>

<dl>
<dt><a name="1088112"> </a><code><code>netSocketDirInput</code></code></dt>
<dt><a name="1088114"> </a><code><code>netSocketDirOutput</code></code></dt>
<dt><a name="1088116"> </a><code><code>netSocketDirBoth</code></code></dt>
</dl>
<dt><a name="1088117"> </a><code>&rarr;  <i><code>timeout</code></i></code></dt>
<dd><a name="1088118"> </a>Maximum timeout in system ticks; -1 means wait forever. </dd>

<dt><a name="1088119"> </a><code>&larr;  <i><code>errP</code></i></code></dt>
<dd><a name="1088120"> </a>Contains an error code if the return value is -1.</dd>

</dl>
<h4>
  <a name="1088121"> </a>Returns 
</h4>

<p><a name="1088122"> </a>Returns 0 upon success and -1 if an error occurred. If an error occurred, <code>errP</code> contains one of the following values:</p>

<dl>
<dt><a name="1088123"> </a><code>0</code></dt>
<dd><a name="1088124"> </a>No error.</dd>

<dt><a name="1088126"> </a><code><code>netErrTimeout</code></code></dt>
<dd><a name="1088127"> </a>Call timed out. </dd>

<dt><a name="1088129"> </a><code><code>netErrNotOpen</code></code></dt>
<dd><a name="1088130"> </a>The referenced net library has not been opened yet. </dd>

<dt><a name="1088132"> </a><code><code>netErrParamErr</code></code></dt>
<dt><a name="1088134"> </a><code><code>netErrSocketNotOpen</code></code></dt>
<dt><a name="1088136"> </a><code><code>netErrNoMultiPktAddr</code> </code></dt>
<dt><a name="1088138"> </a><code><code>netErrOutOfCmdBlocks</code> </code></dt>
</dl>
<h4>
  <a name="1088139"> </a>Sockets Equivalent
</h4>

<p><a name="1088140"> </a><code>int shutdown (int socket, int direction);</code></p>
<h4>
  <a name="1088141"> </a>Comments 
</h4>

<p><a name="1088142"> </a>Shuts down communication in one or both directions on a socket. </p>

<p><a name="1088143"> </a>If direction is <code>netSocketDirInput</code>, the socket is marked as down in the receive direction and further read operations from it return a <code>netErrSocketInputShutdown</code> error. </p>

<h3 class="hbH3">
  <a name="1088147"> </a>NetLibTracePrintF Function <a href="#1083561"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="1088149"> </a>Purpose 
</h4>

<p><a name="1088150"> </a>Store debugging information in the net library's trace buffer. </p>
<h4>
  <a name="1088151"> </a>Declared In 
</h4>
<code>NetMgr.h<a name="1088152"> </a></code><h4>
  <a name="1088153"> </a>Prototype 
</h4>
<pre class="proto"><a name="1088155"></a>Err NetLibTracePrintF (
   UInt16 libRefNum,
   const Char *formatStr,
   ...
)
</pre>
<h4>
  <a name="1088156"> </a>Parameters 
</h4>

<dl>
<dt><a name="1088157"> </a><code>&rarr;  <i><code>libRefNum</code></i></code></dt>
<dd><a name="1088158"> </a>Reference number of the net library.</dd>

<dt><a name="1088159"> </a><code>&rarr;  <i><code>formatStr</code></i></code></dt>
<dd><a name="1088160"> </a>A <code>printf</code> style format string.</dd>

<dt><a name="1088161"> </a><code>&rarr;  <i>...</i></code></dt>
<dd><a name="1088162"> </a>Arguments to the format string.</dd>

</dl>
<h4>
  <a name="1088163"> </a>Returns 
</h4>

<p><a name="1088165"> </a>Returns 0 upon success or <code>netErrNotOpen</code> if the net library has not been opened. </p>
<h4>
  <a name="1088166"> </a>Sockets Equivalent
</h4>

<p><a name="1088167"> </a>None</p>
<h4>
  <a name="1088168"> </a>Comments 
</h4>

<p><a name="1088169"> </a>This call is a convenient debugging tool for developing Internet applications. It stores a message into the net library's trace buffer, which can later be dumped using the <a href="NetLibrary.html#1085869"><code>NetLibMaster()</code></a> call. The net library's trace buffer is used to store run-time errors that the net library encounters as well as errors and messages from network interfaces and from applications that use this call. </p>

<p><a name="1088173"> </a>The <code>formatStr</code> parameter is a <code>printf</code> style format string which supports the following format specifiers:</p>

<p><a name="1088174"> </a>%d, %i, %u, %x, %s, %c </p>

<p><a name="1088175"> </a>but it does <i>not</i> support field widths, leading 0's etc. </p>

<p><a name="1088176"> </a>Note that the <code>netTracingAppMsgs</code> bit of the <code>netSettingTraceBits</code> setting must be set using the call <code>NetLibSettingSet(...netSettingTraceBits...)</code>. Otherwise, this routine will do nothing. </p>
<h4>
  <a name="1088177"> </a>See Also 
</h4>

<p><a name="1088184"> </a><a href="NetLibrary.html#1088190"><code>NetLibTracePutS()</code></a>, <a href="NetLibrary.html#1085869"><code>NetLibMaster()</code></a>, <a href="NetLibrary.html#1087056"><code>NetLibSettingSet()</code></a> </p>

<h3 class="hbH3">
  <a name="1088190"> </a>NetLibTracePutS Function <a href="#1083561"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="1088192"> </a>Purpose 
</h4>

<p><a name="1088193"> </a>Store debugging information in the net library's trace buffer. </p>
<h4>
  <a name="1088194"> </a>Declared In 
</h4>
<code>NetMgr.h<a name="1088195"> </a></code><h4>
  <a name="1088196"> </a>Prototype 
</h4>
<pre class="proto"><a name="1088198"></a>Err NetLibTracePutS (
   UInt16 libRefNum,
   Char *strP
)
</pre>
<h4>
  <a name="1088199"> </a>Parameters 
</h4>

<dl>
<dt><a name="1088200"> </a><code>&rarr;  <i><code>libRefNum</code></i></code></dt>
<dd><a name="1088201"> </a>Reference number of the net library.</dd>

<dt><a name="1088202"> </a><code>&rarr;  <i><code>strP</code></i></code></dt>
<dd><a name="1088203"> </a>String to store in the trace buffer.</dd>

</dl>
<h4>
  <a name="1088204"> </a>Returns 
</h4>

<p><a name="1088206"> </a>Returns 0 upon success or <code>netErrNotOpen</code> if the net library has not been opened. </p>
<h4>
  <a name="1088207"> </a>Sockets Equivalent
</h4>

<p><a name="1088208"> </a>None</p>
<h4>
  <a name="1088209"> </a>Comments 
</h4>

<p><a name="1088210"> </a>This call is a convenient debugging tool for developing Internet applications. It will store a message into the net library's trace buffer which can later be dumped using the <a href="NetLibrary.html#1085869"><code>NetLibMaster()</code></a> call. The net library's trace buffer is used to store run-time errors that the net library encounters as well as errors and messages from network interfaces and from applications that use this call. </p>

<p><a name="1088214"> </a>Note the <code>netTracingAppMsgs</code> bit of the <code>netSettingTraceBits</code> setting must be set using the <code>NetLibSettingSet(...netSettingTraceBits...)</code> call or this routine will do nothing. </p>
<h4>
  <a name="1088215"> </a>See Also 
</h4>

<p><a name="1088222"> </a><a href="NetLibrary.html#1088147"><code>NetLibTracePrintF()</code></a>, <a href="NetLibrary.html#1085869"><code>NetLibMaster()</code></a>, <a href="NetLibrary.html#1087056"><code>NetLibSettingSet()</code></a></p>

<h3 class="hbH3">
  <a name="1088228"> </a>NetNToHL Macro <a href="#1083561"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="1088230"> </a>Purpose 
</h4>

<p><a name="1088231"> </a>Converts a 32-bit value from network to host byte order.</p>
<h4>
  <a name="1088232"> </a>Declared In 
</h4>
<code>NetBitUtils.h<a name="1088233"> </a></code><h4>
  <a name="1088234"> </a>Prototype 
</h4>
<pre class="proto"><a name="1088236"></a>#define NetNToHL (
   x
)
</pre>
<h4>
  <a name="1088237"> </a>Parameters 
</h4>

<dl>
<dt><a name="1088238"> </a><code>&rarr;  <i><code>x</code></i></code></dt>
<dd><a name="1088239"> </a>32-bit value to convert.</dd>

</dl>
<h4>
  <a name="1088240"> </a>Returns 
</h4>

<p><a name="1088241"> </a>Returns <code>x</code> in host byte order.</p>
<h4>
  <a name="1088242"> </a>Errors
</h4>

<p><a name="1088243"> </a>none</p>
<h4>
  <a name="1088244"> </a>Sockets Equivalent
</h4>

<p><a name="1088245"> </a><code>ntohl()</code></p>
<h4>
  <a name="1088246"> </a>See Also 
</h4>

<p><a name="1088256"> </a><a href="NetLibrary.html#1088259"><code>NetNToHS()</code></a>, <a href="NetLibrary.html#1084072"><code>NetHToNL()</code></a>, <a href="NetLibrary.html#1084101"><code>NetHToNS()</code></a> </p>

<h3 class="hbH3">
  <a name="1088259"> </a>NetNToHS Macro <a href="#1083561"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="1088261"> </a>Purpose 
</h4>

<p><a name="1088262"> </a>Converts a 16-bit value from network to host byte order.</p>
<h4>
  <a name="1088263"> </a>Declared In 
</h4>
<code>NetBitUtils.h<a name="1088264"> </a></code><h4>
  <a name="1088265"> </a>Prototype 
</h4>
<pre class="proto"><a name="1088267"></a>#define NetNToHS (
   x
)
</pre>
<h4>
  <a name="1088268"> </a>Parameters 
</h4>

<dl>
<dt><a name="1088269"> </a><code>&rarr;  <i><code>x</code></i></code></dt>
<dd><a name="1088270"> </a>16-bit value to convert.</dd>

</dl>
<h4>
  <a name="1088271"> </a>Returns 
</h4>

<p><a name="1088272"> </a>Returns <code>x</code> in host byte order.</p>
<h4>
  <a name="1088273"> </a>Errors
</h4>

<p><a name="1088274"> </a>None</p>
<h4>
  <a name="1088275"> </a>Sockets Equivalent
</h4>

<p><a name="1088276"> </a><code>ntohs()</code></p>
<h4>
  <a name="1088277"> </a>See Also 
</h4>

<p><a name="1088287"> </a><a href="NetLibrary.html#1084072"><code>NetHToNL()</code></a>, <a href="NetLibrary.html#1088228"><code>NetNToHL()</code></a>, <a href="NetLibrary.html#1084101"><code>NetHToNS()</code></a></p>

<p><a name="1088288"> </a></p>
&nbsp;<br>
</div>
<!--END CONTENT-->

</td>
<td width="5">&nbsp;&nbsp;</td>
</tr>

</table>

<!-- BEGIN FOOTER -->
<table width="100%" border="0" cellspacing="0" cellpadding="0">
<tr>
<td width="7" rowspan="2"><img name="index_x" src="images/shim.gif" width="7" height="33" border="0" alt=""></td>
<td align="left"><img name="dashes" src="images/dashes.gif" width="744" height="3" border="0" alt=""></td>
<td width="10" rowspan="2"><img name="index_x" src="images/shim.gif" width="10" height="33" border="0" alt=""></td>
</tr>
<tr>
<td align="center">
<p class="footer">
Copyright © 1996-2004, PalmSource, Inc. and its affiliates.  All rights reserved. <br>
<a href="http://www.palmsource.com/contact/">Write Us</a> | <a href="http://www.palmos.com/dev/training/">Training</a> | <a href="http://www.palmos.com/dev/support/kb/">Knowledge Base</a> | <a href="Reference_Front.html" target="_blank">Legal</a></p>
<br>
<!--BEGIN BOOK NAVIGATION-->
<p class="nav">
<A href="http://www.palmos.com/dev/support/docs/">Documentation</a>&nbsp;&nbsp;|&nbsp;&nbsp;
<a href="ReferenceTOC.html">Table of Contents</a>&nbsp;&nbsp;
             |&nbsp;&nbsp;<a href="ModemManager.html">&lt;&nbsp;Previous</a>&nbsp;&nbsp;
             |&nbsp;&nbsp;<a href="NetworkUtils.html">Next&nbsp;&gt;</a>&nbsp;&nbsp;
             |&nbsp;&nbsp;<a href="ReferenceIX.html">Index</a>
</p>
</td>
</tr>
</table>
<!-- END FOOTER -->

</body>
</html>