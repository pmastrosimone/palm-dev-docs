<html>
<head>
<title>(68K) Virtual Drivers | Palm OS&#174; Programmer's  API Reference</title> 
<link href="psi_devpubs.css" rel="stylesheet" type="text/css">

<!-- BEGIN META DATA -->
<meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
<META NAME="PSITEMPLATE" CONTENT="1006-007 PalmSource_HTML_2003 20041101">
<META NAME="GENERATOR" CONTENT="Quadralay WebWorks AutoMap 2003 for FrameMaker 8.0.6.2138">
<META NAME="LASTUPDATED" CONTENT="11/22/04 10:47:05">
<!-- END META DATA -->
</head>

<body bgcolor="#ffffff" text="#000000" leftmargin="0" topmargin="0" marginwidth="0" marginheight="0">
<a name="995796"></a>

<!-- BEGIN TOPNAV -->
<table width="100%" border="0" cellspacing="0" cellpadding="0">
<tr>
<td><img src="images/shim.gif" width="7" height="75" border="0" alt=""></td>
<td align="left"><table border="0" cellpadding="0" cellspacing="0" width="744">
<tr>
<td><img name="index_r2_c1" src="images/shim.gif" width="25" height="75" border="0" alt=""></td>
<td valign="top"><table border="0" cellpadding="0" cellspacing="0" width="96">
<tr>
<td><img name="index_r2_c4" src="images/shim.gif" width="96" height="15" border="0" alt=""></td>
</tr>
<tr>
<td><a href="http://www.palmsource.com/"><img name="ps_logo" src="images/ps_logo.gif" width="96" height="54" border="0" alt=""></a></td>
</tr>

</table>
</td>

<td><table border="0" cellpadding="0" cellspacing="0" width="30">
<td><img name="index_x" src="images/shim.gif" width="30" height="75" border="0" alt=""></td>
</table></td>

<!--BEGIN MASTHEAD-->
<td><table border="0" cellpadding="0" cellspacing="0" width="96">
<tr>
<td><img name="index_x" src="images/shim.gif" width="615" height="5" border="0" alt=""></td>
</tr>
<tr>
<td>
<!--BEGIN BOOK NAVIGATION-->
<span class="nav">
<A href="http://www.palmos.com/dev/support/docs/">Documentation</a>&nbsp;&nbsp;|&nbsp;&nbsp;
<a href="ReferenceTOC.html">Table of Contents</a>&nbsp;&nbsp;
             |&nbsp;&nbsp;<a href="ScriptPlugin.html">&lt;&nbsp;Previous</a>&nbsp;&nbsp;
             |&nbsp;&nbsp;<a href="SerialManager.html">Next&nbsp;&gt;</a>&nbsp;&nbsp;
             |&nbsp;&nbsp;<a href="ReferenceIX.html">Index</a>
</span>
<!--END BOOK NAVIGATION-->
</tr>
<tr>
<td>
<!--BEGIN PAGE TITLE-->
<h2 class="PageTitle">69 &nbsp;&nbsp;
Virtual Drivers</h2></td>
<!--END PAGE TITLE-->
</tr>
<tr>
<td>
<!--BEGIN BOOK TITLE-->
<p class="BookTitle">Palm OS&#174; Programmer's  API Reference</p>
<p class="SubTitle">Palm OS&#174; 68K SDK </p>
<!--END BOOK TITLE-->
</td>
</tr>
<tr>
<td><img name="index_x" src="images/shim.gif" width="615" height="5" border="0" alt=""></td>
</tr>
</table>
</td>
<!--END MASTHEAD-->
</tr>
</table>
<img name="dashes" src="images/dashes.gif" width="744" height="3" border="0" alt=""></td>
</tr>
</table>
<!-- END TOPNAV -->

<table width="100%" border="0" cellspacing="0" cellpadding="0">
<tr>
<td valign="top" width="5"><img name="index_x" src="images/shim.gif" width="5" height="33" border="0" alt=""></td>

<!--BEGIN SIDETOC-->
<td valign="top" width="175">
<div id="sidetoc" valign="bottom">
<h1 class="SideTOC1-PartTab"><a href="PartIII.html">Part III: Communications</a> </h1>
<h1 class="SideTOC1"><a href="SerialDriver.html">69  Virtual Drivers</a></h1>

   <h2 class="SideTOC2"><a href="#995829">
   Driver Data Structures</a></h2>

      <h3 class="SideTOC3"><a href="#995832">
      DrvrInfoType</a></h3>

      <h3 class="SideTOC3"><a href="#995904">
      DrvrRcvQType</a></h3>

      <h3 class="SideTOC3"><a href="#995972">
      DrvrStatusEnum</a></h3>

      <h3 class="SideTOC3"><a href="#996027">
      SrmRcvQType</a></h3>

      <h3 class="SideTOC3"><a href="#996070">
      VdrvAPIType</a></h3>

      <h3 class="SideTOC3"><a href="#996137">
      VdrvConfigType</a></h3>

      <h3 class="SideTOC3"><a href="#996221">
      VdrvCtlOpCodeEnum</a></h3>

   <h2 class="SideTOC2"><a href="#996456">
   Driver Constants</a></h2>

      <h3 class="SideTOC3"><a href="#996458">
      Driver Version Constants</a></h3>

      <h3 class="SideTOC3"><a href="#996503">
      Port Feature Constants</a></h3>

   <h2 class="SideTOC2"><a href="#996585">
   Virtual Driver-Defined Functions</a></h2>

      <h3 class="SideTOC3"><a href="#996591">
      DrvEntryPointProcPtr</a></h3>

      <h3 class="SideTOC3"><a href="#996637">
      VdrvCloseProcPtr</a></h3>

      <h3 class="SideTOC3"><a href="#996659">
      VdrvControlProcPtr</a></h3>

      <h3 class="SideTOC3"><a href="#996766">
      VdrvControlCustomProcPtr</a></h3>

      <h3 class="SideTOC3"><a href="#996805">
      VdrvOpenProcPtr</a></h3>

      <h3 class="SideTOC3"><a href="#996835">
      VdrvOpenProcV4Ptr</a></h3>

      <h3 class="SideTOC3"><a href="#996872">
      VdrvStatusProcPtr</a></h3>

      <h3 class="SideTOC3"><a href="#996898">
      VdrvWriteProcPtr</a></h3>

   <h2 class="SideTOC2"><a href="#996923">
   Serial Manager Queue Functions</a></h2>

      <h3 class="SideTOC3"><a href="#996935">
      GetSizeProcPtr</a></h3>

      <h3 class="SideTOC3"><a href="#996958">
      GetSpaceProcPtr</a></h3>

      <h3 class="SideTOC3"><a href="#996980">
      SignalCheckPtr</a></h3>

      <h3 class="SideTOC3"><a href="#997011">
      WriteBlockProcPtr</a></h3>

      <h3 class="SideTOC3"><a href="#997041">
      WriteByteProcPtr</a></h3>

</div>
</td>

<td width="5">&nbsp;&nbsp;</td>
<td width="2" background="images/index_r8_c10.gif"><img src="images/shim.gif" width="2" height="75" border="0" alt=""></td>
<td width="5">&nbsp;&nbsp;</td>

<!--END SIDETOC-->

<td valign="top">

<!--BEGIN CONTENT-->
<div id="content" valign="bottom">
<p><a name="995799"> </a>This chapter provides reference material for the Serial Manager virtual device driver API:</p>
<ul type="disc">
  <li><a name="995803"> </a><a href="SerialDriver.html#995829">Driver Data Structures</a>
  <li><a name="995807"> </a><a href="SerialDriver.html#996456">Driver Constants</a>
  <li><a name="995811"> </a><a href="SerialDriver.html#996585">Virtual Driver-Defined Functions</a>
  <li><a name="995815"> </a><a href="SerialDriver.html#996923">Serial Manager Queue Functions</a>
</ul>

<p><a name="995818"> </a>The header files <code>SerialVdrv.h</code> and <code>SerialDrvr.h </code>declare the virtual driver API. For more information on writing device drivers for the Serial Manager, see section <a href="../PalmOSCompanion2/SerialCommunication.html#1018913">"Writing a Virtual Device Driver"</a> in the <a href="../PalmOSCompanion2/SerialCommunication.html#1018070">"Serial Communication"</a> chapter of <i>Palm OS Programmer's Companion</i>, vol. II, <i>Communications</i>. </p>

<h2 class="haH2">
  <a name="995829"> </a>Driver Data Structures <a href="#995796"><span class="nav">^TOP^</span></a>
</h2>


<h3 class="hbH3">
  <a name="995832"> </a>DrvrInfoType Struct <a href="#995796"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="995834"> </a>Purpose 
</h4>

<p><a name="995836"> </a>The <code>DrvrInfoType</code> structure defines information about the serial hardware. It is passed to and filled in by the <a href="SerialDriver.html#996591"><code>DrvEntryPointProcPtr()</code></a> for a virtual driver.</p>
<h4>
  <a name="995840"> </a>Prototype 
</h4>
<pre class="proto"><a name="995841"></a>typedef struct {
  UInt32 drvrID;
  UInt32 drvrVersion;
  UInt32 maxBaudRate;
  UInt32 handshakeThreshold;
  UInt32 portFlags;
  const Char *portDesc;
  DrvrIRQEnum irqType;
  UInt8 multipleEnumerations;
  UInt32 dbCreator;
} DrvrInfoType;
</pre>
<h4>
  <a name="1010054"> </a>Fields 
</h4>

<dl>
<dt><a name="995855"> </a><code><code>drvrID</code> </code></dt>
<dd><a name="995857"> </a>4-character creator type, such as 'u328'.</dd>

<dt><a name="995859"> </a><code><code>drvrVersion</code> </code></dt>
<dd><a name="995861"> </a>Version of code that works for this hardware. See <a href="SerialDriver.html#996458">Driver Version Constants</a>.</dd>

<dt><a name="995866"> </a><code><code>maxBaudRate</code> </code></dt>
<dd><a name="995868"> </a>Maximum baud rate supported by this hardware.</dd>

<dt><a name="995870"> </a><code><code>handshakeThreshold</code> </code></dt>
<dd><a name="995872"> </a>Baud rate at which the use of hardware handshaking is necessary.</dd>

<dt><a name="995874"> </a><code><code>portFlags</code> </code></dt>
<dd><a name="995876"> </a>Bit flags denoting features of this hardware. The flags are described in <a href="SerialDriver.html#996503">Port Feature Constants</a>.</dd>

<dt><a name="995881"> </a><code><code>portDesc</code> </code></dt>
<dd><a name="995883"> </a>Pointer to null-terminated string describing this hardware. This string appears in the Connection panel to describe the port to the user (only if the <code>portCncMgrVisible</code> bit in <code>portFlags</code> is set). Can be <code>NULL</code> if the driver contains a resource (of type 'tSTR' and id <code>kPortDescStrID</code>) that supplies this string.</dd>

<dt><a name="995885"> </a><code><code>irqType</code> </code></dt>
<dd><a name="995887"> </a>IRQ line being used for this hardware. For a virtual driver, specify <code>drvrIRQNone</code>.</dd>

<dt><a name="995889"> </a><code><code>multipleEnumerations</code> </code></dt>
<dd><a name="995891"> </a>The number of entries in the driver table required for this driver. If 0, the driver has a single entry. </dd>

<dt><a name="995893"> </a><code><code>dbCreator</code> </code></dt>
<dd><a name="995895"> </a>Creator ID of the database containing this driver. </dd>

</dl>
<h4>
  <a name="995897"> </a>Compatibility 
</h4>

<p><a name="995898"> </a>The <code>multipleEnumerations</code> and <code>dbCreator</code> fields are only defined if <a href="CompatibilityApdx.html#994556">New Serial Manager Feature Set Version 2</a> is present. </p>

<h3 class="hbH3">
  <a name="995904"> </a>DrvrRcvQType Struct <a href="#995796"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="995906"> </a>Purpose 
</h4>

<p><a name="995908"> </a>The <code>DrvrRcvQType</code> structure defines the virtual driver receive buffer and function pointers to functions that access and save data to the buffer. A pointer to this structure is passed to the <a href="SerialDriver.html#996805"><code>VdrvOpenProcPtr()</code></a> function. The <code>DrvrHWRcvQPtr</code> type defines a pointer to a <code>DrvrRcvQType</code> structure.</p>
<h4>
  <a name="995912"> </a>Prototype 
</h4>
<pre class="proto"><a name="995913"></a>typedef struct DrvrRcvQType {
  void *rcvQ;
  WriteByteProcPtr qWriteByte;
  WriteBlockProcPtr qWriteBlock;
  GetSizeProcPtr qGetSize;
  GetSpaceProcPtr qGetSpace;
  SignalCheckPtr qSignalCheck;
} DrvrRcvQType;
</pre>
<pre class="proto"><a name="995922"></a>typedef DrvrRcvQType *DrvrHWRcvQPtr;
</pre>
<h4>
  <a name="1011017"> </a>Fields 
</h4>

<dl>
<dt><a name="995926"> </a><code><code>rcvQ</code> </code></dt>
<dd><a name="995928"> </a>Pointer to the receive buffer.</dd>

<dt><a name="995930"> </a><code><code>qWriteByte</code> </code></dt>
<dd><a name="995932"> </a>Function pointer to a function that the virtual driver can use to write one byte to the Serial Manager's receive queue. See the <a href="SerialDriver.html#997041"><code>WriteByteProcPtr()</code></a> function.</dd>

<dt><a name="995937"> </a><code><code>qWriteBlock</code> </code></dt>
<dd><a name="995939"> </a>Function pointer to a function that the virtual driver can use to write a block of bytes to the Serial Manager's receive queue. See the <a href="SerialDriver.html#997011"><code>WriteBlockProcPtr()</code></a> function.</dd>

<dt><a name="995944"> </a><code><code>qGetSize</code> </code></dt>
<dd><a name="995946"> </a>Function pointer to a function that the virtual driver can use to get the total size of the Serial Manager's receive queue. See the <a href="SerialDriver.html#996935"><code>GetSizeProcPtr()</code></a> function.</dd>

<dt><a name="995951"> </a><code><code>qGetSpace</code> </code></dt>
<dd><a name="995953"> </a>Function pointer to a function that the virtual driver can use to get the available space in the Serial Manager's receive queue. See the <a href="SerialDriver.html#996958"><code>GetSpaceProcPtr()</code></a> function.</dd>

<dt><a name="995958"> </a><code><code>qSignalCheck</code> </code></dt>
<dd><a name="995960"> </a>Function pointer to a function that the virtual driver can use to perform a signal check for the Serial Manager's receive queue. See the <a href="SerialDriver.html#996980"><code>SignalCheckPtr()</code></a> function. </dd>

</dl>
<h4>
  <a name="995965"> </a>Compatibility 
</h4>

<p><a name="995968"> </a>The <code>qSignalCheck</code> field is only defined if <a href="CompatibilityApdx.html#994556">New Serial Manager Feature Set Version 2</a> is present. </p>

<h3 class="hbH3">
  <a name="995972"> </a>DrvrStatusEnum Enum <a href="#995796"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="995974"> </a>Purpose 
</h4>

<p><a name="995976"> </a>The <code>DrvrStatusEnum</code> enumerated type specifies serial status bit flags. Return these enumerated types from the <a href="SerialDriver.html#996872"><code>VdrvStatusProcPtr()</code></a> call.</p>
<h4>
  <a name="995980"> </a>Prototype 
</h4>
<pre class="proto"><a name="995981"></a>typedef enum DrvrStatusEnum {
  drvrStatusCtsOn = 0x0001,
  drvrStatusRtsOn = 0x0002,
  drvrStatusDsrOn = 0x0004,
  drvrStatusTxFifoFull = 0x0008,
  drvrStatusTxFifoEmpty = 0x0010,
  drvrStatusBreakAsserted = 0x0020,
  drvrStatusDataReady = 0x0040,
  drvrStatusLineErr = 0x0080
} DrvrStatusEnum;
</pre>
<h4>
  <a name="1011057"> </a>Constants 
</h4>

<dl>
<dt><a name="995994"> </a><code><code>drvrStatusCtsOn</code> </code></dt>
<dd><a name="995996"> </a>Set if CTS line is active.</dd>

<dt><a name="995998"> </a><code><code>drvrStatusRtsOn</code> </code></dt>
<dd><a name="996000"> </a>Set if RTS line is active.</dd>

<dt><a name="996002"> </a><code><code>drvrStatusDsrOn</code> </code></dt>
<dd><a name="996004"> </a>Set if DSR is on.</dd>

<dt><a name="996006"> </a><code><code>drvrStatusTxFifoFull</code> </code></dt>
<dd><a name="996008"> </a>Set if transmit FIFO is full; cleared if FIFO has space.</dd>

<dt><a name="996010"> </a><code><code>drvrStatusTxFifoEmpty</code> </code></dt>
<dd><a name="996012"> </a>Set if transmit FIFO is empty.</dd>

<dt><a name="996014"> </a><code><code>drvrStatusBreakAsserted</code> </code></dt>
<dd><a name="996016"> </a>Set if sending break characters is enabled.</dd>

<dt><a name="996018"> </a><code><code>drvrStatusDataReady</code> </code></dt>
<dd><a name="996020"> </a>Used by debugger only.</dd>

<dt><a name="996022"> </a><code><code>drvrStatusLineErr</code> </code></dt>
<dd><a name="996024"> </a>Used by debugger only.</dd>

</dl>

<h3 class="hbH3">
  <a name="996027"> </a>SrmRcvQType Struct <a href="#995796"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="996029"> </a>Purpose 
</h4>

<p><a name="996031"> </a>The <code>SrmRcvQType</code> structure defines the Serial Manager receive queue. This queue is passed as a parameter to the virtual driver. </p>
<h4>
  <a name="996032"> </a>Prototype 
</h4>
<pre class="proto"><a name="996033"></a>typedef struct SrmRcvQType {
  UInt32 qStart;
  UInt32 qEnd;
  UInt32 qSize;
  UInt8 *qData;
  void *qPort;
} SrmRcvQType;
</pre>
<h4>
  <a name="1011119"> </a>Fields 
</h4>

<dl>
<dt><a name="996043"> </a><code><code>qStart</code> </code></dt>
<dd><a name="996045"> </a>The start of the queue. </dd>

<dt><a name="996047"> </a><code><code>qEnd</code> </code></dt>
<dd><a name="996049"> </a>The end of the queue. </dd>

<dt><a name="996051"> </a><code><code>qSize</code> </code></dt>
<dd><a name="996053"> </a>The size of the queue. </dd>

<dt><a name="996055"> </a><code><code>qData</code> </code></dt>
<dd><a name="996057"> </a>The data currently in the queue. </dd>

<dt><a name="996059"> </a><code><code>qPort</code> </code></dt>
<dd><a name="996061"> </a>A pointer to the current foreground port. </dd>

</dl>
<h4>
  <a name="996063"> </a>Compatibility 
</h4>

<p><a name="996064"> </a>The <code>SrmRcvQType</code> structure was previously a private structure. It is declared publicly if <a href="CompatibilityApdx.html#994556">New Serial Manager Feature Set Version 2</a> is present. </p>

<h3 class="hbH3">
  <a name="996070"> </a>VdrvAPIType Struct <a href="#995796"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="996072"> </a>Purpose 
</h4>

<p><a name="996074"> </a>The <code>VdrvAPIType</code> structure defines function pointers to the required virtual driver functions. When passed a pointer to this structure in the <a href="SerialDriver.html#996591"><code>DrvEntryPointProcPtr()</code></a> function, that function must fill in the pointers to the virtual driver functions appropriately.</p>
<h4>
  <a name="996078"> </a>Prototype 
</h4>
<pre class="proto"><a name="996079"></a>typedef struct {
  VdrvOpenProcPtr drvOpen;
  VdrvCloseProcPtr drvClose;
  VdrvControlProcPtr drvControl;
  VdrvStatusProcPtr drvStatus;
  VdrvReadProcPtr drvRead;
  VdrvWriteProcPtr drvWrite;
  VdrvOpenProcV4Ptr drvOpenV4;
  VdrvControlCustomProcPtr drvControlCustom;
} VdrvAPIType;
</pre>
<h4>
  <a name="1011201"> </a>Fields 
</h4>

<dl>
<dt><a name="996092"> </a><code><code>drvOpen</code> </code></dt>
<dd><a name="996094"> </a>Pointer to the driver open function.</dd>

<dt><a name="996096"> </a><code><code>drvClose</code> </code></dt>
<dd><a name="996098"> </a>Pointer to the driver close function.</dd>

<dt><a name="996100"> </a><code><code>drvControl</code> </code></dt>
<dd><a name="996102"> </a>Pointer to the driver control function.</dd>

<dt><a name="996104"> </a><code><code>drvStatus</code> </code></dt>
<dd><a name="996106"> </a>Pointer to the driver status function.</dd>

<dt><a name="996108"> </a><code><code>drvRead</code> </code></dt>
<dd><a name="996110"> </a>Pointer to the driver read function.</dd>

<dt><a name="996112"> </a><code><code>drvWrite</code> </code></dt>
<dd><a name="996114"> </a>Pointer to the driver write function.</dd>

<dt><a name="996116"> </a><code><code>drvOpenV4</code> </code></dt>
<dd><a name="996120"> </a>Pointer to the driver open function for <a href="CompatibilityApdx.html#994556">New Serial Manager Feature Set Version 2</a>. </dd>

<dt><a name="996123"> </a><code><code>drvControlCustom</code> </code></dt>
<dd><a name="996125"> </a>Pointer to the driver custom control function. </dd>

</dl>
<h4>
  <a name="996127"> </a>Compatibility 
</h4>

<p><a name="996130"> </a><code>drvOpenV4</code> and <code>drvControlCustom</code> are declared if both <a href="CompatibilityApdx.html#994556">New Serial Manager Feature Set Version 2</a> and <a href="CompatibilityApdx.html#995256">4.0 New Feature Set</a> are present. </p>

<h3 class="hbH3">
  <a name="996137"> </a>VdrvConfigType Struct <a href="#995796"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="996139"> </a>Purpose 
</h4>

<p><a name="996141"> </a>The <code>VdrvConfigType</code> structure specifies parameters for opening a serial port. This structure is passed as a parameter to <a href="SerialDriver.html#996835"><code>VdrvOpenProcV4Ptr()</code></a>. </p>
<h4>
  <a name="996145"> </a>Prototype 
</h4>
<pre class="proto"><a name="996146"></a>typedef struct VdrvConfigType {
  UInt32 baud;
  UInt32 drvrId;
  UInt32 function;
  MemPtr drvrDataP;
  UInt16 drvrDataSize;
  UInt32 sysReserved1;
  UInt32 sysReserved2; 
} VdrvConfigType;
</pre>
<h4>
  <a name="1011334"> </a>Fields 
</h4>

<dl>
<dt><a name="996158"> </a><code><code>baud</code> </code></dt>
<dd><a name="996160"> </a>Baud rate at which to open the connection. Serial drivers that do not require baud rates ignore this field. </dd>

<dt><a name="996162"> </a><code><code>drvrId</code> </code></dt>
<dd><a name="996164"> </a>Creator ID of the application or library that is using the Serial Manager. </dd>

<dt><a name="996166"> </a><code><code>function</code> </code></dt>
<dd><a name="996168"> </a>The reason why the port was opened. Specify the creator ID of the application that is opening the port or one of the following values: </dd>

<dl>
<dt><a name="996170"> </a><code><code>serFncUndefined</code> </code></dt>
<dd><a name="996171"> </a>Undefined function. This is the default value for this field.</dd>

<dt><a name="996173"> </a><code><code>serFncPPPSession</code></code></dt>
<dd><a name="996174"> </a>The connection is to be used for the PPP interface. </dd>

<dt><a name="996176"> </a><code><code>serFncSLIPSession</code></code></dt>
<dd><a name="996177"> </a>The connection is to be used for the SLIP session. </dd>

<dt><a name="996179"> </a><code><code>serFncDebugger</code></code></dt>
<dd><a name="996180"> </a>The connection is to be used for a debugging session. </dd>

<dt><a name="996182"> </a><code><code>serFncHotSync</code></code></dt>
<dd><a name="996183"> </a>The connection is to be used for a HotSync operation. </dd>

<dt><a name="996185"> </a><code><code>serFncConsole</code> </code></dt>
<dd><a name="996186"> </a>The connection is to the debugging console. </dd>

<dt><a name="996188"> </a><code><code>serFncTelephony</code> </code></dt>
<dd><a name="996189"> </a>The connection is to the telephony library. </dd>

</dl>
<dd><a name="996193"> </a>The <code>function</code> field is used by protocols such as USB and Bluetooth that perform different setup tasks based on which type of application is using them. RS-232 drivers ignore this parameter. </dd>

<dt><a name="996195"> </a><code><code>drvrDataP</code> </code></dt>
<dd><a name="996197"> </a>Pointer to a driver-specific data block. </dd>

<dt><a name="996199"> </a><code><code>drvrDataSize</code> </code></dt>
<dd><a name="996201"> </a>The size of the data block pointed to by <code>drvrDataP</code>. </dd>

<dt><a name="996203"> </a><code><code>sysReserved1</code> </code></dt>
<dd><a name="996205"> </a>Reserved for future use. </dd>

<dt><a name="996207"> </a><code><code>sysReserved2</code> </code></dt>
<dd><a name="996209"> </a>Reserved for future use. </dd>

</dl>
<h4>
  <a name="996211"> </a>Compatibility 
</h4>

<p><a name="996214"> </a>This structure is only defined if both <a href="CompatibilityApdx.html#994556">New Serial Manager Feature Set Version 2</a> and <a href="CompatibilityApdx.html#995256">4.0 New Feature Set</a> are present. </p>

<h3 class="hbH3">
  <a name="996221"> </a>VdrvCtlOpCodeEnum Enum <a href="#995796"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="996223"> </a>Purpose 
</h4>

<p><a name="996225"> </a>The <code>VdrvCtlOpCodeEnum</code> enumerated type specifies a serial control operation. You should handle each of these constants when passed for the <code>controlCode</code> parameter to the <a href="SerialDriver.html#996659"><code>VdrvControlProcPtr()</code></a> call.</p>
<h4>
  <a name="996229"> </a>Prototype 
</h4>
<pre class="proto"><a name="996230"></a>typedef enum VdrvCtlOpCodeEnum {
  vdrvOpCodeNoOp = 0, 
  vdrvOpCodeSetBaudRate = 0x1000,
  vdrvOpCodeSetSettingsFlags,
  vdrvOpCodeSetCtsTimeout,
  vdrvOpCodeClearErr,
  vdrvOpCodeSetSleepMode,
  vdrvOpCodeSetWakeupMode,
  vdrvOpCodeFIFOCount,
  vdrvOpCodeStartBreak,
  vdrvOpCodeStopBreak,
  vdrvOpCodeStartLoopback,
  vdrvOpCodeStopLoopback,
  vdrvOpCodeFlushTxFIFO,
  vdrvOpCodeFlushRxFIFO,
  vdrvOpCodeSendBufferedData,
  vdrvOpCodeRcvCheckIdle,
  vdrvOpCodeEmuSetBlockingHook,
  vdrvOpCodeGetOptTransmitSize,
  vdrvOpCodeGetMaxRcvBlockSize,
  vdrvOpCodeNotifyBytesReadFromQ,
  vdrvOpCodeSetDTRAsserted,
  vdrvOpCodeGetDTRAsserted,
  vdrvOpCodeWaitForConfiguration,
  vdrvOpCodeGetUSBDeviceDescriptor,
  vdrvOpCodeGetUSBConfigDescriptor,
  vdrvOpCodeEnableIRDA,
  vdrvOpCodeDisableIRDA,
  vdrvOpCodeEnableUART,
  vdrvOpCodeDisableUART,
  vdrvOpCodeRxEnable,
  vdrvOpCodeRxDisable,
  vdrvOpCodeLineEnable,
  vdrvOpCodeEnableUARTInterrupts,
  vdrvOpCodeDisableUARTInterrupts,
  vdrvOpCodeSetReceiveQueue,
  vdrvOpCodeSaveState,
  vdrvOpCodeRestoreState,
  vdrvOpCodeSetYieldPortCallback,
  vdrvOpCodesetYieldPortRefCon,
  vdrvOpCodeUserDef = 0x2000,
  vdrvOpCodeSystem = 0x7000,
  vdrvOpCodeCustom = 0x8000
} VdrvCtlOpCodeEnum;
</pre>
<h4>
  <a name="1011348"> </a>Constants 
</h4>

<dl>
<dt><a name="996277"> </a><code>vdvrOpCodeSetBaudRate </code></dt>
<dd><a name="996279"> </a>Sets the baud rate.</dd>

<dt><a name="996281"> </a><code>vdvrOpCodeSetSettingsFlags </code></dt>
<dd><a name="996283"> </a>Sets the data transmission options. The bit flags are described in <a href="SerialManager.html#1020831">Serial Settings Constants</a>.</dd>

<dt><a name="996288"> </a><code>vdrvOpCodeSetCtsTimeout </code></dt>
<dd><a name="996290"> </a>Hardware handshake timeout.</dd>

<dt><a name="996292"> </a><code>vdvrOpCodeClearErr </code></dt>
<dd><a name="996294"> </a>Clears the hardware error state.</dd>

<dt><a name="996296"> </a><code>vdvrOpCodeSetSleepMode </code></dt>
<dd><a name="996298"> </a>Puts the port in sleep mode (not typically used for virtual drivers).</dd>

<dt><a name="996300"> </a><code>vdvrOpCodeSetWakeupMode </code></dt>
<dd><a name="996302"> </a>Wakes up the port from sleep mode (not typically used for virtual drivers).</dd>

<dt><a name="996304"> </a><code>vdvrOpCodeFIFOCount </code></dt>
<dd><a name="996306"> </a>Returns the number of bytes currently in the FIFO (or best estimate). </dd>

<dt><a name="996308"> </a><code>vdvrOpCodeStartBreak </code></dt>
<dd><a name="996310"> </a>Sends a break character or enables the sending of break characters.</dd>

<dt><a name="996312"> </a><code>vdvrOpCodeStopBreak </code></dt>
<dd><a name="996314"> </a>Stops sending break characters.</dd>

<dt><a name="996316"> </a><code>vdvrOpCodeStartLoopback </code></dt>
<dd><a name="996318"> </a>Starts loopback mode (not typically used for virtual drivers).</dd>

<dt><a name="996320"> </a><code>vdvrOpCodeStopLoopback </code></dt>
<dd><a name="996322"> </a>Stops loopback mode (not typically used for virtual drivers).</dd>

<dt><a name="996324"> </a><code>vdrvOpCodeFlushTxFIFO </code></dt>
<dd><a name="996326"> </a>Flushes the contents of the transmit FIFO.</dd>

<dt><a name="996328"> </a><code>vdrvOpCodeFlushRxFIFO </code></dt>
<dd><a name="996330"> </a>Flushes the contents of the receive FIFO.</dd>

<dt><a name="996332"> </a><code>vdrvOpCodeSendBufferedData </code></dt>
<dd><a name="996334"> </a>Notifies virtual device to send any buffered data it has not emptied from its internal buffers.</dd>

<dt><a name="996336"> </a><code>vdrvOpCodeRcvCheckIdle </code></dt>
<dd><a name="996338"> </a>Called periodically to allow the virtual device time to check if there is data to be received. Because virtual devices execute in the same thread as applications, they can be prevented from handling notifications of received data.</dd>

<dt><a name="996340"> </a><code>vdrvOpCodeEmuSetBlockingHook </code></dt>
<dd><a name="996342"> </a>Special op code for the Simulator.</dd>

<dt><a name="996344"> </a><code>vdrvOpCodeGetOptTransmitSize </code></dt>
<dd><a name="996346"> </a>Returns the optimum buffer size for sending data or returns 0 to specify any buffer size is acceptable.</dd>

<dt><a name="996348"> </a><code>vdrvOpCodeGetMaxRcvBlockSize </code></dt>
<dd><a name="996350"> </a>Returns the maximum receive block size that the Serial Manager should request from the virtual device. Can be used to implement flow control.</dd>

<dt><a name="996352"> </a><code>vdrvOpCodeNotifyBytesReadFromQ </code></dt>
<dd><a name="996354"> </a>Tells the virtual device that some number of bytes have been read from the receive queue by the client application. Can be used to implement flow control.</dd>

<dt><a name="996356"> </a><code><code>vdrvOpCodeSetDTRAsserted</code> </code></dt>
<dd><a name="996358"> </a>Asserts or de-asserts the DTR signal. </dd>

<dt><a name="996360"> </a><code><code>vdrvOpCodeGetDTRAsserted</code> </code></dt>
<dd><a name="996362"> </a>Gets the status of the DTR signal. </dd>

<dt><a name="996364"> </a><code><code>vdrvOpCodeWaitForConfiguration</code> </code></dt>
<dd><a name="996366"> </a>Waits for USB enumeration to complete. Called from the send and receive functions of the Serial Manager. The driver should have a timeout for how long it waits for enumeration to complete. The driver should return with no error if enumeration has already occurred or has occurred within the driver's timeout. If the enumeration has not occurred within the driver's timeout, the driver should return <code>serErrTimeOut</code>. </dd>

<dt><a name="996368"> </a><code><code>vdrvOpCodeGetUSBDeviceDescriptor</code> </code></dt>
<dd><a name="996370"> </a>Retrieves the device descriptor of a USB driver. Used to gather information about the device's capabilities. Implementation of this op code is optional. If the driver chooses to implement this op code, then the driver should return a pointer to the device descriptor. A driver that chooses not to implement this op code should return <code>serErrNotSupported</code>. </dd>

<dt><a name="996372"> </a><code><code>vdrvOpCodeGetUSBConfigDescriptor</code> </code></dt>
<dd><a name="996374"> </a>Retrieves the configuration descriptor of a USB driver. Used to gather information about the device's capabilities. Implementation of this op code is optional. If the driver chooses to implement this op code, then the driver should return a pointer to the device descriptor. A driver that chooses not to implement this op code should return <code>serErrNotSupported</code>. </dd>

<dt><a name="996376"> </a><code><code>vdrvOpCodeEnableIRDA</code> </code></dt>
<dd><a name="996378"> </a>Enable the IrDA mode and power up the IR line drivers.</dd>

<dt><a name="996380"> </a><code><code>vdrvOpCodeDisableIRDA</code> </code></dt>
<dd><a name="996382"> </a>Disable the IrDA mode and disable the IR line drivers.</dd>

<dt><a name="996384"> </a><code><code>vdrvOpCodeEnableUART</code> </code></dt>
<dd><a name="996386"> </a>Powers up the UART and the line drivers.</dd>

<dt><a name="996388"> </a><code><code>vdrvOpCodeDisableUART</code> </code></dt>
<dd><a name="996390"> </a>Powers down the UART and the line drivers.</dd>

<dt><a name="996392"> </a><code><code>vdrvOpCodeRxEnable</code> </code></dt>
<dd><a name="996394"> </a>Enables the receive FIFO, enables UART interrupts, and does whatever else is necessary to allow the UART to receive data.</dd>

<dt><a name="996396"> </a><code><code>vdrvOpCodeRxDisable</code> </code></dt>
<dd><a name="996398"> </a>Disables the receive FIFO and UART interrupts and does whatever is needed to prevent the UART from receiving data.</dd>

<dt><a name="996400"> </a><code><code>vdrvOpCodeLineEnable</code> </code></dt>
<dd><a name="996402"> </a>Enables the main serial line driver for the UART.</dd>

<dt><a name="996404"> </a><code><code>vdrvOpCodeEnableUARTInterrupts</code> </code></dt>
<dd><a name="996406"> </a>Enables the appropriate UART receive interrupts.</dd>

<dt><a name="996408"> </a><code><code>vdrvOpCodeDisableUARTInterrupts</code> </code></dt>
<dd><a name="996410"> </a>Disables all UART interrupts.</dd>

<dt><a name="996412"> </a><code><code>vdrvOpCodeSetReceiveQueue</code> </code></dt>
<dd><a name="996414"> </a>This op code is used by the Serial Manager to set the driver's receive queue. This control code is called when a driver that has previously been opened as a background port is opened as a fully open bidirectional port. </dd>

<dt><a name="996416"> </a><code><code>vdrvOpCodeSaveState</code> </code></dt>
<dd><a name="996418"> </a>Invoked when this port is yielded. This is a hook for the driver to save any current state. </dd>

<dt><a name="996420"> </a><code><code>vdrvOpCodeRestoreState</code> </code></dt>
<dd><a name="996422"> </a>Invoked when the foreground port is closed and this port can become the foreground port. </dd>

<dt><a name="996424"> </a><code><code>vdrvOpCodeSetYieldPortCallback</code> </code></dt>
<dd><a name="996426"> </a>Set the function to be called if the Serial Manager attempts to open another port when this one is open. This op code is for system use only. </dd>

<dt><a name="996428"> </a><code><code>vdrvOpCodeSetYieldPortRefCon</code> </code></dt>
<dd><a name="996430"> </a>Data to pass to the yield port callback function. System use only. </dd>

<dt><a name="996432"> </a><code>vdvrOpCodeUserDef </code></dt>
<dd><a name="996434"> </a>User defined function invoked through <a href="SerialManager.html#1021112"><code>SrmControl()</code></a>.</dd>

<dt><a name="996439"> </a><code>vdrvOpCodeSystem </code></dt>
<dd><a name="996441"> </a>Reserves op codes between 0x7000 and 0x8000 for system use. </dd>

<dt><a name="996443"> </a><code>vdrvOpCodeCustom </code></dt>
<dd><a name="996445"> </a>Reserves op codes greater than 0x8000 for driver-specific use. </dd>

</dl>
<h4>
  <a name="996447"> </a>Compatibility 
</h4>

<p><a name="996448"> </a>The op codes starting at <code>vdrvOpCodeWaitForConfiguration</code> are defined only if <a href="CompatibilityApdx.html#994556">New Serial Manager Feature Set Version 2</a> is present. The op codes for yieldable ports and custom operations are defined only if both <a href="CompatibilityApdx.html#995256">4.0 New Feature Set</a> is present as well. </p>

<h2 class="haH2">
  <a name="996456"> </a>Driver Constants <a href="#995796"><span class="nav">^TOP^</span></a>
</h2>


<h3 class="hbH3">
  <a name="996458"> </a>Driver Version Constants <a href="#995796"><span class="nav">^TOP^</span></a>
</h3>


<p><a name="996459"> </a>The driver version constants specify which version of the driver API is implemented by this driver. The <a href="SerialDriver.html#996591"><code>DrvEntryPointProcPtr()</code></a> function passes this value back to the Serial Manager in the <code>drvrVersion</code> field of the <a href="SerialDriver.html#995832"><code>DrvrInfoType</code></a> function. </p>


<div class="tablediv"><table cellspacing="0" class="tTable">

  <tr valign="top">
    <th><p class="tt"><a name="996468"> </a><b><span style="color: #000000;  font-style: normal; font-weight: bold; text-decoration: none; text-transform: none; vertical-align: baseline">Constant</span></b></p>
    </th>
    <th><p class="tt"><a name="996470"> </a><b>Value</b></p>
    </th>
    <th><p class="tt"><a name="996472"> </a><b>Description</b></p>
    </th>
  </tr>
  <tr valign="top">
    <td><p class="tt"><a name="996475"> </a><code>kDrvrVersion</code> </p>
    </td>
    <td><p class="tt"><a name="996477"> </a>4</p>
    </td>
    <td><p class="tt"><a name="996479"> </a>The latest version of the API. </p>
    </td>
  </tr>
  <tr valign="top">
    <td><p class="tt"><a name="996482"> </a><code>kDrvrVersion3</code> </p>
    </td>
    <td><p class="tt"><a name="996484"> </a>3</p>
    </td>
    <td><p class="tt"><a name="996486"> </a>The version of the driver API that corresponds to <a href="CompatibilityApdx.html#994402">New Serial Manager Feature Set Version 1</a> (which ships with roughly Palm OS<sup>&#174;</sup> 3.3 up to Palm OS 4.0). </p>
    </td>
  </tr>
  <tr valign="top">
    <td><p class="tt"><a name="996492"> </a><code>kDrvrVersion4</code> </p>
    </td>
    <td><p class="tt"><a name="996494"> </a>4</p>
    </td>
    <td><p class="tt"><a name="996496"> </a>The version of the driver API that corresponds to <a href="CompatibilityApdx.html#994556">New Serial Manager Feature Set Version 2</a> (which ships with roughly Palm OS 4.0 and higher). </p>
    </td>
  </tr>
</table>

</div>


<h3 class="hbH3">
  <a name="996503"> </a>Port Feature Constants <a href="#995796"><span class="nav">^TOP^</span></a>
</h3>


<p><a name="996504"> </a>The port feature constants are flags that describe serial hardware capabilities.</p>


<div class="tablediv"><table cellspacing="0" class="tTable">

  <tr valign="top">
    <th><p class="tt"><a name="996507"> </a><b>Constant</b></p>
    </th>
    <th><p class="tt"><a name="996509"> </a><b>Value</b></p>
    </th>
    <th><p class="tt"><a name="996511"> </a><b>Description</b></p>
    </th>
  </tr>
  <tr valign="top">
    <td><p class="tt"><a name="996513"> </a><code>portPhysicalPort</code> </p>
    </td>
    <td><p class="tt"><a name="996515"> </a>0x00000001 </p>
    </td>
    <td><p class="tt"><a name="996517"> </a>Should be set for a physical port, unset for a virtual port.</p>
    </td>
  </tr>
  <tr valign="top">
    <td><p class="tt"><a name="996519"> </a><code>portBkgndModeSupported</code> </p>
    </td>
    <td><p class="tt"><a name="996521"> </a>0x00000002</p>
    </td>
    <td><p class="tt"><a name="996523"> </a>Denotes that this port can be used for background ports. This flag is only applicable to virtual drivers. Background mode support is implied on physical drivers. </p>
    </td>
  </tr>
  <tr valign="top">
    <td><p class="tt"><a name="996525"> </a><code>portRS232Capable</code> </p>
    </td>
    <td><p class="tt"><a name="996527"> </a>0x00000004 </p>
    </td>
    <td><p class="tt"><a name="996529"> </a>Set if this hardware has an RS-232 port.</p>
    </td>
  </tr>
  <tr valign="top">
    <td><p class="tt"><a name="996531"> </a><code>portIRDACapable</code> </p>
    </td>
    <td><p class="tt"><a name="996533"> </a>0x00000008 </p>
    </td>
    <td><p class="tt"><a name="996535"> </a>Set if this hardware has an IR port and supports IrDA mode.</p>
    </td>
  </tr>
  <tr valign="top">
    <td><p class="tt"><a name="996537"> </a><code>portCradlePort</code> </p>
    </td>
    <td><p class="tt"><a name="996539"> </a>0x00000010 </p>
    </td>
    <td><p class="tt"><a name="996541"> </a>Set if this hardware controls the cradle port.</p>
    </td>
  </tr>
  <tr valign="top">
    <td><p class="tt"><a name="996543"> </a><code>portExternalPort</code> </p>
    </td>
    <td><p class="tt"><a name="996545"> </a>0x00000020 </p>
    </td>
    <td><p class="tt"><a name="996547"> </a>Set if this hardware port is external or on a memory card.</p>
    </td>
  </tr>
  <tr valign="top">
    <td><p class="tt"><a name="996549"> </a><code>portModemPort</code> </p>
    </td>
    <td><p class="tt"><a name="996551"> </a>0x00000040 </p>
    </td>
    <td><p class="tt"><a name="996553"> </a>Set if this hardware communicates with a modem.</p>
    </td>
  </tr>
  <tr valign="top">
    <td><p class="tt"><a name="996555"> </a><code>portCncMgrVisible</code> </p>
    </td>
    <td><p class="tt"><a name="996557"> </a>0x00000080 </p>
    </td>
    <td><p class="tt"><a name="996559"> </a>Set if this serial port's name is to be displayed in the Connection panel.</p>
    </td>
  </tr>
  <tr valign="top">
    <td><p class="tt"><a name="996561"> </a><code>portConsolePort</code> </p>
    </td>
    <td><p class="tt"><a name="996563"> </a>0x00000100</p>
    </td>
    <td><p class="tt"><a name="996565"> </a>Denotes this hardware controls the console port. </p>
    </td>
  </tr>
  <tr valign="top">
    <td><p class="tt"><a name="996567"> </a><code>portUSBCapable</code> </p>
    </td>
    <td><p class="tt"><a name="996569"> </a>0x00000200 </p>
    </td>
    <td><p class="tt"><a name="996571"> </a>Set if this hardware has a USB port. </p>
    </td>
  </tr>
  <tr valign="top">
    <td><p class="tt"><a name="996573"> </a><code>portPrivateUse</code> </p>
    </td>
    <td><p class="tt"><a name="996575"> </a>0x00001000 </p>
    </td>
    <td><p class="tt"><a name="996577"> </a>Set if this driver is for special software and not general applications.</p>
    </td>
  </tr>
</table>

</div>

<h4>
  <a name="996579"> </a>Compatibility 
</h4>

<p><a name="996582"> </a>USB support is only available if <a href="CompatibilityApdx.html#994556">New Serial Manager Feature Set Version 2</a> is present. </p>

<h2 class="haH2">
  <a name="996585"> </a>Virtual Driver-Defined Functions <a href="#995796"><span class="nav">^TOP^</span></a>
</h2>


<p><a name="996587"> </a>The functions in this section must be defined by your virtual driver.</p>

<h3 class="hbH3">
  <a name="996591"> </a>DrvEntryPointProcPtr Function <a href="#995796"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="996593"> </a>Purpose 
</h4>

<p><a name="996594"> </a>Entry point for the virtual driver.</p>
<h4>
  <a name="996595"> </a>Declared In 
</h4>
<code>SerialDrvr.h<a name="996596"> </a></code><h4>
  <a name="996597"> </a>Prototype 
</h4>
<pre class="proto"><a name="996598"></a>Err (
   *DrvEntryPointProcPtr
) (
   DrvrEntryOpCodeEnum opCode,
   void *uartData
)
</pre>
<h4>
  <a name="996599"> </a>Parameters 
</h4>

<dl>
<dt><a name="996600"> </a><code>&rarr;  <i><code>opCode</code></i></code></dt>
<dd><a name="996601"> </a>Entry function code.</dd>

<dt><a name="996602"> </a><code>&harr;  <i><code>uartData</code></i></code></dt>
<dd><a name="996603"> </a>Pointer to data specific to <code>opCode</code>.</dd>

</dl>
<h4>
  <a name="996604"> </a>Returns 
</h4>

<dl>
<dt><a name="996605"> </a><code><code>errNone</code> </code></dt>
<dd><a name="996606"> </a>No error.</dd>

<dt><a name="996607"> </a><code>-1</code></dt>
<dd><a name="996608"> </a>The op code is invalid or the hardware could not be found.</dd>

</dl>
<h4>
  <a name="996609"> </a>Comments 
</h4>

<p><a name="996610"> </a>This function's purpose is based on the value of the <code>opCode</code> parameter. The three possible codes are <code>drvrEntryGetUartFeatures,</code> <code>drvrEntryGetDrvrFuncts</code>, and <code>drvrEntryGetUartFtrsNEntries</code>.</p>

<p><a name="996611"> </a><code>DrvEntryPoint</code> is called with the <code>drvrEntryGetUartFeatures</code> code when the Serial Manager is installed into the system at boot time and is looking for all installed drivers. When this op code is set, the <code>uartData</code> pointer points to a <a href="SerialDriver.html#995832"><code>DrvrInfoType</code></a> structure. This function does not allocate the structure, it just fills in the fields with information.</p>

<p><a name="996615"> </a>This function should check to make sure the associated serial device can operate under the current OS and system settings. If the hardware cannot be found, the function should leave the <code>DrvrInfoType</code> struct untouched and return a -1 error.</p>

<p><a name="996616"> </a>The driver needs to supply a string that describes the port it manages. This string is displayed to the user in the Connection panel and is returned by the <a href="SerialManager.html#1021514"><code>SrmGetDeviceInfo()</code></a> function. To set this string, copy it into the <code>portDesc</code> field of the <code>DrvrInfoType</code> structure. Alternatively, you can supply this string in a driver resource of type 'tSTR' and id <code>kPortDescStrID</code>.</p>

<p><a name="996620"> </a>If the <code>DrvrInfoType</code> structure has a positive value in the <code>multipleEnumerations</code> field upon return, the Serial Manager defines one port for each entry in the driver table. The <code>DrvEntryPoint</code> function is called again, this time with the <code>drvrEntryGetUartFtrsNEntries</code> code. The <code>uartData</code> pointer points to a new <code>DrvrInfoType</code> structure whose <code>multipleEnumerations</code> field indicates which port is to be defined. The function should supply all information specific to this port. </p>

<p><a name="996621"> </a><code>DrvEntryPoint</code> is called with the <code>drvrEntryGetDrvrFuncts</code> code when a virtual port is opened. The <code>uartData</code> pointer points to a <a href="SerialDriver.html#996070"><code>VdrvAPIType</code></a> structure and <code>DrvEntryPoint</code> must fill in the fields of this structure with appropriate function pointers.</p>
<h4>
  <a name="996625"> </a>Compatibility 
</h4>

<p><a name="996629"> </a>Implemented only if <a href="CompatibilityApdx.html#994402">New Serial Manager Feature Set Version 1</a> is present.</p>

<p><a name="996632"> </a>The <code>drvrEntryGetUartFtrsNEntries</code> is only supported if <a href="CompatibilityApdx.html#994556">New Serial Manager Feature Set Version 2</a> is present. This function is fully backwards compatible. Passing 0 for the <code>multipleEnumerations</code> field defines a single port for the driver. </p>

<h3 class="hbH3">
  <a name="996637"> </a>VdrvCloseProcPtr Function <a href="#995796"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="996639"> </a>Purpose 
</h4>

<p><a name="996640"> </a>Handles all activities needed to close the virtual device.</p>
<h4>
  <a name="996641"> </a>Declared In 
</h4>
<code>SerialDrvr.h<a name="996642"> </a></code><h4>
  <a name="996643"> </a>Prototype 
</h4>
<pre class="proto"><a name="996644"></a>Err (
   *VdrvCloseProcPtr
) (
   VdrvDataPtr drvrData
)
</pre>
<h4>
  <a name="996645"> </a>Parameters 
</h4>

<dl>
<dt><a name="996646"> </a><code>&rarr;  <i><code>drvrData</code></i></code></dt>
<dd><a name="996647"> </a>Pointer to the driver's private global area.</dd>

</dl>
<h4>
  <a name="996648"> </a>Returns 
</h4>

<dl>
<dt><a name="996649"> </a><code><code>errNone</code> </code></dt>
<dd><a name="996650"> </a>No error.</dd>

</dl>
<h4>
  <a name="996651"> </a>Compatibility 
</h4>

<p><a name="996655"> </a>Implemented only if <a href="CompatibilityApdx.html#994402">New Serial Manager Feature Set Version 1</a> is present.</p>

<h3 class="hbH3">
  <a name="996659"> </a>VdrvControlProcPtr Function <a href="#995796"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="996661"> </a>Purpose 
</h4>

<p><a name="996662"> </a>Extends the <code>SrmControl</code> function to the level of the virtual device.</p>
<h4>
  <a name="996663"> </a>Declared In 
</h4>
<code>SerialDrvr.h<a name="996664"> </a></code><h4>
  <a name="996665"> </a>Prototype 
</h4>
<pre class="proto"><a name="996666"></a>Err (
   *VdrvControlProcPtr
) (
   VdrvDataPtr drvrData,
   VdrvCtlOpCodeEnum controlCode,
   void *controlData,
   UInt16 *controlDataLen
)
</pre>
<h4>
  <a name="996667"> </a>Parameters 
</h4>

<dl>
<dt><a name="996668"> </a><code>&rarr;  <i><code>drvrData</code></i></code></dt>
<dd><a name="996669"> </a>Pointer to the driver's private global area.</dd>

<dt><a name="996670"> </a><code>&rarr;  <i><code>controlCode</code></i></code></dt>
<dd><a name="996671"> </a>Control function op code. One of the op codes listed in the <a href="SerialDriver.html#996221"><code>VdrvCtlOpCodeEnum</code></a> type.</dd>

<dt><a name="996675"> </a><code>&harr;  <i><code>controlData</code></i></code></dt>
<dd><a name="996676"> </a>Pointer to data for the specified control function.</dd>

<dt><a name="996677"> </a><code>&harr;  <i><code>controlDataLen</code></i></code></dt>
<dd><a name="996678"> </a>Pointer to length of control data being passed in or out.</dd>

</dl>
<h4>
  <a name="996679"> </a>Returns 
</h4>

<dl>
<dt><a name="996680"> </a><code><code>errNone</code></code></dt>
<dd><a name="996681"> </a>No error.</dd>

<dt><a name="996682"> </a><code><code>serErrNotSupported</code></code></dt>
<dd><a name="996683"> </a><code>controlCode</code> not supported.</dd>

<dt><a name="996684"> </a><code><code>serErrBadParam</code></code></dt>
<dd><a name="996685"> </a><code>controlData</code> or <code>controlDataLen</code> is bad.</dd>

</dl>
<h4>
  <a name="996686"> </a>Comments 
</h4>

<p><a name="996687"> </a>This function should support the op codes listed in the <a href="SerialDriver.html#996221"><code>VdrvCtlOpCodeEnum</code></a> type. If this function does not support an op code, it must return the <code>serErrNotSupported</code> error code for that op code.</p>

<p><a name="996694"> </a><a href="SerialDriver.html#996701">Table 69.1</a> shows what is passed for the <code>controlData</code> and <code>controlDataLen</code> parameters for each of the control codes that use them. Control codes not listed do not use these parameters.</p>

<p class="caption"><a name="996701"> </a><b>Table 69.1&nbsp;&nbsp;VDrvControlProcPtr Parameters </b></p>
<div class="tablediv"><table cellspacing="0" class="tTable">

  <tr valign="top">
    <td><p class="tt"><a name="996705"> </a><code>vdvrOpCodeSetBaudRate</code> </p>
    </td>
    <td>
<dl>
<dt><a name="996707"> </a><code>&rarr;  <i><code>controlData</code> = Pointer to <code>Int32</code> (baud rate), </i></code></dt>
<dt><a name="996708"> </a><code>&rarr;  <i><code>controlDataLen</code> = Pointer to <code>sizeof(Int32)</code>.</i></code></dt>
</dl>
    </td>
  </tr>
  <tr valign="top">
    <td><p class="tt"><a name="996710"> </a><code>vdvrOpCodeSetSettingsFlags</code> </p>
    </td>
    <td>
<dl>
<dt><a name="996712"> </a><code>&rarr;  <i><code>controlData</code> = Pointer to <code>UInt32</code> (bitfield; see <a href="SerialManager.html#1020831">Serial Settings Constants</a>)</i></code></dt>
<dt><a name="996716"> </a><code>&rarr;  <i><code>controlDataLen</code> = Pointer to <code>sizeof(UInt32)</code> </i></code></dt>
</dl>
    </td>
  </tr>
  <tr valign="top">
    <td><p class="tt"><a name="996718"> </a><code>vdvrOpCodeFIFOCount</code> </p>
    </td>
    <td>
<dl>
<dt><a name="996720"> </a><code>&rarr;  <i><code>controlData</code> = Pointer to <code>Int16</code>, which contains the number of bytes in the FIFO. </i></code></dt>
<dt><a name="996721"> </a><code>&rarr;  <i><code>controlDataLen</code> = Pointer to <code>sizeof(Int16)</code>.</i></code></dt>
</dl>
    </td>
  </tr>
  <tr valign="top">
    <td><p class="tt"><a name="996723"> </a><code>vdrvOpCodeGetOptTransmitSize</code> </p>
    </td>
    <td>
<dl>
<dt><a name="996725"> </a><code>&larr;  <i><code>controlData</code> = Pointer to <code>Int32</code> (buffer size),</i></code></dt>
<dt><a name="996726"> </a><code>&larr;  <i><code>controlDataLen</code> = Pointer to <code>sizeof(Int32)</code>.</i></code></dt>
</dl>
<p class="tt"><a name="996727"> </a>Return the optimum buffer size for sending data, or 0 to specify any buffer size is acceptable.</p>
    </td>
  </tr>
  <tr valign="top">
    <td><p class="tt"><a name="996729"> </a><code>vdrvOpCodeGetMaxRcvBlockSize</code> </p>
    </td>
    <td>
<dl>
<dt><a name="996731"> </a><code>&larr;  <i><code>controlData</code> = Pointer to <code>Int32</code> (block size),</i></code></dt>
<dt><a name="996732"> </a><code>&larr;  <i><code>controlDataLen</code> = Pointer to <code>sizeof(Int32)</code>.</i></code></dt>
</dl>
<p class="tt"><a name="996733"> </a>Return the maximum block size that the Serial Manager should request from the virtual device.</p>
    </td>
  </tr>
  <tr valign="top">
    <td><p class="tt"><a name="996735"> </a><code>vdrvOpCodeNotifyBytes<br>ReadFromQ</code> </p>
    </td>
    <td>
<dl>
<dt><a name="996737"> </a><code>&rarr;  <i><code>controlData</code> = Pointer to <code>Int32</code> (number of bytes read),</i></code></dt>
<dt><a name="996738"> </a><code>&rarr;  <i><code>controlDataLen</code> = Pointer to <code>sizeof(Int32)</code>.</i></code></dt>
</dl>
    </td>
  </tr>
  <tr valign="top">
    <td><p class="tt"><a name="996740"> </a><code>vdrvOpCodeSetDTRAsserted</code> </p>
    </td>
    <td>
<dl>
<dt><a name="996742"> </a><code>&rarr;  <i><code>controlData</code> = Pointer to Boolean indicating whether to enable or disable DTR. </i></code></dt>
<dt><a name="996743"> </a><code>&rarr;  <i><code>controlDataLen</code> = Pointer to <code>sizeof(Boolean)</code> </i></code></dt>
</dl>
    </td>
  </tr>
  <tr valign="top">
    <td><p class="tt"><a name="996745"> </a><code>vdrvOpCodeGetDTRAsserted</code> </p>
    </td>
    <td>
<dl>
<dt><a name="996747"> </a><code>&larr;  <i><code>controlData</code> = Pointer to Boolean indicating whether DTR is enabled. </i></code></dt>
<dt><a name="996748"> </a><code>&larr;  <i><code>controlDataLen</code> = Pointer to <code>sizeof(Boolean)</code> </i></code></dt>
</dl>
    </td>
  </tr>
  <tr valign="top">
    <td><p class="tt"><a name="996750"> </a><code>vdvrOpCodeUserDef</code> </p>
    </td>
    <td>
<dl>
<dt><a name="996752"> </a><code>&harr;  <i><code>controlData </code>= Pointer from <a href="SerialManager.html#1021112"><code>SrmControl()</code></a> (user-defined data), </i></code></dt>
<dt><a name="996756"> </a><code>&harr;  <i><code>controlDataLen </code>= Pointer to <code>sizeof(Int32)</code>.</i></code></dt>
</dl>
    </td>
  </tr>
</table>

</div>

<h4>
  <a name="996758"> </a>Compatibility 
</h4>

<p><a name="996762"> </a>Implemented only if <a href="CompatibilityApdx.html#994402">New Serial Manager Feature Set Version 1</a> is present.</p>

<h3 class="hbH3">
  <a name="996766"> </a>VdrvControlCustomProcPtr Function <a href="#995796"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="996768"> </a>Purpose 
</h4>

<p><a name="996769"> </a>Extends the <code>SrmCustomControl</code> function to the level of the virtual device.</p>
<h4>
  <a name="996770"> </a>Declared In 
</h4>
<code>SerialDrvr.h<a name="996771"> </a></code><h4>
  <a name="996772"> </a>Prototype 
</h4>
<pre class="proto"><a name="996773"></a>Err (
   *VdrvControlCustomProcPtr
) (
   VdrvDataPtr drvrData,
   UInt16 opCode,
   UInt32 creator,
   void *controlData,
   void *controlDataLenP
)
</pre>
<h4>
  <a name="996774"> </a>Parameters 
</h4>

<dl>
<dt><a name="996775"> </a><code>&rarr;  <i><code>drvrData</code></i></code></dt>
<dd><a name="996776"> </a>Pointer to the driver's private global area.</dd>

<dt><a name="996777"> </a><code>&rarr;  <i><code>controlCode</code></i></code></dt>
<dd><a name="996778"> </a>Control function op code. </dd>

<dt><a name="996779"> </a><code>&rarr;  <i><code>creator</code></i></code></dt>
<dd><a name="996780"> </a>Creator ID of the driver that defines the op code. The combination of creator ID and op code uniquely identifies the operation to be performed. </dd>

<dt><a name="996781"> </a><code>&harr;  <i><code>controlData</code></i></code></dt>
<dd><a name="996782"> </a>Pointer to data for the specified control function.</dd>

<dt><a name="996783"> </a><code>&harr;  <i><code>controlDataLen</code></i></code></dt>
<dd><a name="996784"> </a>Pointer to length of control data being passed in or out.</dd>

</dl>
<h4>
  <a name="996785"> </a>Returns 
</h4>

<dl>
<dt><a name="996786"> </a><code><code>errNone</code></code></dt>
<dd><a name="996787"> </a>No error.</dd>

<dt><a name="996788"> </a><code><code>serErrNotSupported</code></code></dt>
<dd><a name="996789"> </a><code>controlCode</code> not supported.</dd>

<dt><a name="996790"> </a><code><code>serErrBadParam</code></code></dt>
<dd><a name="996791"> </a><code>controlData</code> or <code>controlDataLen</code> is bad.</dd>

</dl>
<h4>
  <a name="996792"> </a>Comments 
</h4>

<p><a name="996793"> </a>This function is a mechanism for a virtual driver to create control codes specific to that driver, allowing for the support of new technologies that have interfaces through the Serial Manager. </p>
<h4>
  <a name="996794"> </a>Compatibility 
</h4>

<p><a name="996798"> </a>Implemented only if both <a href="CompatibilityApdx.html#994556">New Serial Manager Feature Set Version 2</a> and <a href="CompatibilityApdx.html#995256">4.0 New Feature Set</a> are present. </p>

<h3 class="hbH3">
  <a name="996805"> </a>VdrvOpenProcPtr Function <a href="#995796"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="996807"> </a>Purpose 
</h4>

<p><a name="996808"> </a>Initializes the virtual device to begin communication.</p>
<h4>
  <a name="996809"> </a>Declared In 
</h4>
<code>SerialDrvr.h<a name="996810"> </a></code><h4>
  <a name="996811"> </a>Prototype 
</h4>
<pre class="proto"><a name="996812"></a>Err (
   *VdrvOpenProcPtr
) (
   VdrvDataPtr *drvrData,
   UInt32 baudRate,
   DrvrHWRcvQPtr rcvQP
)
</pre>
<h4>
  <a name="996813"> </a>Parameters 
</h4>

<dl>
<dt><a name="996814"> </a><code>&harr;  <i><code>drvrData</code></i></code></dt>
<dd><a name="996815"> </a>Pointer to a pointer to the driver's private global area (allocated by this function). A pointer to this private global area is passed to the other virtual driver functions.</dd>

<dt><a name="996816"> </a><code>&rarr;  <i><code>baudRate</code></i></code></dt>
<dd><a name="996817"> </a>Initial baud rate setting.</dd>

<dt><a name="996818"> </a><code>&rarr;  <i><code>rcvQP</code></i></code></dt>
<dd><a name="996819"> </a>Pointer to the driver's receive queue buffer structure. For details on the fields, see <a href="SerialDriver.html#995904"><code>DrvrRcvQType</code></a>.</dd>

</dl>
<h4>
  <a name="996823"> </a>Returns 
</h4>

<dl>
<dt><a name="996824"> </a><code><code>errNone</code> </code></dt>
<dd><a name="996825"> </a>No error.</dd>

</dl>
<h4>
  <a name="996826"> </a>Comments 
</h4>

<p><a name="996827"> </a>This function must allocate and initialize any global variables (and pass back a pointer to a pointer to them in <code>drvrDataP</code>), do any set-up necessary for communicating with other software, and save the <code>rcvQP</code> pointer since it will need the functions and pointers to structures enclosed within to be able to save received data into the Serial Manager's receive queue.</p>
<h4>
  <a name="996828"> </a>Compatibility 
</h4>

<p><a name="996832"> </a>Implemented only if <a href="CompatibilityApdx.html#994402">New Serial Manager Feature Set Version 1</a> is present.</p>

<h3 class="hbH3">
  <a name="996835"> </a>VdrvOpenProcV4Ptr Function <a href="#995796"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="996837"> </a>Purpose 
</h4>

<p><a name="996838"> </a>Initializes the virtual device to begin communication.</p>
<h4>
  <a name="996839"> </a>Declared In 
</h4>
<code>SerialDrvr.h<a name="996840"> </a></code><h4>
  <a name="996841"> </a>Prototype 
</h4>
<pre class="proto"><a name="996842"></a>Err (
   *VdrvOpenProcV4Ptr
) (
   VdrvDataPtr *drvrData,
   VdrvConfigPtr configP,
   DrvrHWRcvQPtr rcvQP
)
</pre>
<h4>
  <a name="996843"> </a>Parameters 
</h4>

<dl>
<dt><a name="996844"> </a><code>&harr;  <i><code>drvrData</code></i></code></dt>
<dd><a name="996845"> </a>Pointer to a pointer to the driver's private global area (allocated by this function). A pointer to this private global area is passed to the other virtual driver functions.</dd>

<dt><a name="996846"> </a><code>&rarr;  <i><code>configP</code></i></code></dt>
<dd><a name="996847"> </a>Pointer to the configuration structure specifying the port's properties. See <a href="SerialDriver.html#996137"><code>VdrvConfigType</code></a>.</dd>

<dt><a name="996851"> </a><code>&rarr;  <i><code>rcvQP</code></i></code></dt>
<dd><a name="996852"> </a>Pointer to the driver's receive queue buffer structure. For details on the fields, see <a href="SerialDriver.html#995904"><code>DrvrRcvQType</code></a>.</dd>

</dl>
<h4>
  <a name="996856"> </a>Returns 
</h4>

<dl>
<dt><a name="996857"> </a><code><code>errNone</code> </code></dt>
<dd><a name="996858"> </a>No error.</dd>

</dl>
<h4>
  <a name="996859"> </a>Comments 
</h4>

<p><a name="996860"> </a>This function must allocate and initialize any global variables (and pass back a pointer to a pointer to them in <code>drvrDataP</code>), do any set-up necessary for communicating with other software, and save the <code>rcvQP</code> pointer since it will need the functions and pointers to structures enclosed within to be able to save received data into the Serial Manager's receive queue.</p>
<h4>
  <a name="996861"> </a>Compatibility 
</h4>

<p><a name="996865"> </a>Implemented only if both <a href="CompatibilityApdx.html#994556">New Serial Manager Feature Set Version 2</a> and <a href="CompatibilityApdx.html#995256">4.0 New Feature Set</a> are present. </p>

<h3 class="hbH3">
  <a name="996872"> </a>VdrvStatusProcPtr Function <a href="#995796"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="996874"> </a>Purpose 
</h4>

<p><a name="996875"> </a>Returns virtual device status.</p>
<h4>
  <a name="996876"> </a>Declared In 
</h4>
<code>SerialDrvr.h<a name="996877"> </a></code><h4>
  <a name="996878"> </a>Prototype 
</h4>
<pre class="proto"><a name="996879"></a>UInt16 (
   *VDrvStatusProcPtr
) (
   VdrvDataPtr drvrData
)
</pre>
<h4>
  <a name="996880"> </a>Parameters 
</h4>

<dl>
<dt><a name="996881"> </a><code>&rarr;  <i><code>drvrData</code></i></code></dt>
<dd><a name="996882"> </a>Pointer to the driver's private global area.</dd>

</dl>
<h4>
  <a name="996883"> </a>Returns 
</h4>

<p><a name="996884"> </a>An unsigned long bitfield denoting the status of the virtual device, but only if the virtual device is emulating hardware. The individual bit flags are described in the <a href="SerialDriver.html#995972"><code>DrvrStatusEnum</code></a> type.</p>
<h4>
  <a name="996888"> </a>Comments 
</h4>

<p><a name="996889"> </a>Generally, status is returned only to the client application using the virtual device. The Serial Manager does not use status information from virtual devices.</p>
<h4>
  <a name="996890"> </a>Compatibility 
</h4>

<p><a name="996894"> </a>Implemented only if <a href="CompatibilityApdx.html#994402">New Serial Manager Feature Set Version 1</a> is present.</p>

<h3 class="hbH3">
  <a name="996898"> </a>VdrvWriteProcPtr Function <a href="#995796"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="996900"> </a>Purpose 
</h4>

<p><a name="996901"> </a>Writes a block of bytes.</p>
<h4>
  <a name="996902"> </a>Declared In 
</h4>
<code>SerialDrvr.h<a name="996903"> </a></code><h4>
  <a name="996904"> </a>Prototype 
</h4>
<pre class="proto"><a name="996905"></a>UInt32 (
   *VdrvWriteProcPtr
) (
   VdrvDataPtr drvrDataP,
   void *bufP,
   UInt32 size,
   Err *errP
)
</pre>
<h4>
  <a name="996906"> </a>Parameters 
</h4>

<dl>
<dt><a name="996907"> </a><code>&rarr;  <i><code>drvrDataP</code></i></code></dt>
<dd><a name="996908"> </a>Pointer to the driver's private global area.</dd>

<dt><a name="996909"> </a><code>&rarr;  <i><code>bufP</code></i></code></dt>
<dd><a name="996910"> </a>Pointer to buffer containing the data to be written to the virtual device.</dd>

<dt><a name="996911"> </a><code>&rarr;  <i><code>size</code></i></code></dt>
<dd><a name="996912"> </a>Number of bytes in the buffer <code>bufP</code>.</dd>

<dt><a name="996913"> </a><code>&larr;  <i><code>errP</code></i></code></dt>
<dd><a name="996914"> </a>Pointer to an error code resulting from the operation. Zero is returned if there is no error.</dd>

</dl>
<h4>
  <a name="996915"> </a>Returns 
</h4>

<p><a name="996916"> </a>Returns the actual number of bytes written.</p>
<h4>
  <a name="996917"> </a>Compatibility 
</h4>

<p><a name="996921"> </a>Implemented only if <a href="CompatibilityApdx.html#994402">New Serial Manager Feature Set Version 1</a> is present.</p>

<h2 class="haH2">
  <a name="996923"> </a>Serial Manager Queue Functions <a href="#995796"><span class="nav">^TOP^</span></a>
</h2>


<p><a name="996925"> </a>The functions in this section are supplied by the Serial Manager to the virtual driver through the <a href="SerialDriver.html#995904"><code>DrvrRcvQType</code></a> passed to the <a href="SerialDriver.html#996805"><code>VdrvOpenProcPtr()</code></a> function.</p>

<h3 class="hbH3">
  <a name="996935"> </a>GetSizeProcPtr Function <a href="#995796"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="996937"> </a>Purpose 
</h4>

<p><a name="996938"> </a>Returns the total size of the Serial Manager's receive queue.</p>
<h4>
  <a name="996939"> </a>Declared In 
</h4>
<code>SerialDrvr.h<a name="996940"> </a></code><h4>
  <a name="996941"> </a>Prototype 
</h4>
<pre class="proto"><a name="996942"></a>typedef UInt32 (
   *GetSizeProcPtr
) (
   void *theQ
)
</pre>
<h4>
  <a name="996943"> </a>Parameters 
</h4>

<dl>
<dt><a name="996944"> </a><code>&rarr;  <i><code>theQ</code></i></code></dt>
<dd><a name="996945"> </a>Pointer to the receive queue.</dd>

</dl>
<h4>
  <a name="996946"> </a>Returns 
</h4>

<p><a name="996947"> </a>Size in bytes of the Serial Manager's receive queue.</p>
<h4>
  <a name="996948"> </a>Comments 
</h4>

<p><a name="996949"> </a>This function is useful for implementing flow control.</p>
<h4>
  <a name="996950"> </a>Compatibility 
</h4>

<p><a name="996954"> </a>Implemented only if <a href="CompatibilityApdx.html#994402">New Serial Manager Feature Set Version 1</a> is present.</p>

<h3 class="hbH3">
  <a name="996958"> </a>GetSpaceProcPtr Function <a href="#995796"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="996960"> </a>Purpose 
</h4>

<p><a name="996961"> </a>Returns the available space in the Serial Manager's receive queue.</p>
<h4>
  <a name="996962"> </a>Declared In 
</h4>
<code>SerialDrvr.h<a name="996963"> </a></code><h4>
  <a name="996964"> </a>Prototype 
</h4>
<pre class="proto"><a name="996965"></a>typedef UInt32 (
   *GetSpaceProcPtr
) (
   void *theQ
)
</pre>
<h4>
  <a name="996966"> </a>Parameters 
</h4>

<dl>
<dt><a name="996967"> </a><code>&rarr;  <i><code>theQ</code></i></code></dt>
<dd><a name="996968"> </a>Pointer to the receive queue.</dd>

</dl>
<h4>
  <a name="996969"> </a>Returns 
</h4>

<p><a name="996970"> </a>Size in bytes of the available space in the Serial Manager's receive queue.</p>
<h4>
  <a name="996971"> </a>Comments 
</h4>

<p><a name="996972"> </a>This function is useful for implementing flow control.</p>
<h4>
  <a name="996973"> </a>Compatibility 
</h4>

<p><a name="996977"> </a>Implemented only if <a href="CompatibilityApdx.html#994402">New Serial Manager Feature Set Version 1</a> is present.</p>

<h3 class="hbH3">
  <a name="996980"> </a>SignalCheckPtr Function <a href="#995796"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="996982"> </a>Purpose 
</h4>

<p><a name="996983"> </a>Check the queue to see if the semaphore needs to be signalled. </p>
<h4>
  <a name="996984"> </a>Declared In 
</h4>
<code>SerialDrvr.h<a name="996985"> </a></code><h4>
  <a name="996986"> </a>Prototype 
</h4>
<pre class="proto"><a name="996987"></a>typedef void (
   *SignalCheckPtr
) (
   void *theQ,
   UInt16 lineErrsP
)
</pre>
<h4>
  <a name="996988"> </a>Parameters 
</h4>

<dl>
<dt><a name="996989"> </a><code>&rarr;  <i><code>theQ</code></i></code></dt>
<dd><a name="996990"> </a>Pointer to the receive queue. </dd>

<dt><a name="996991"> </a><code>&rarr;  <i><code>lineErrsP</code></i></code></dt>
<dd><a name="996992"> </a>Any serial line errors received should be reported here. </dd>

</dl>
<h4>
  <a name="996993"> </a>Returns 
</h4>

<p><a name="996994"> </a>Returns nothing.</p>
<h4>
  <a name="996995"> </a>Comments 
</h4>

<p><a name="996996"> </a>This function signals that there is data to be received without writing anything to the receive queue. The <a href="SerialDriver.html#997041"><code>WriteByteProcPtr()</code></a> and <a href="SerialDriver.html#997011"><code>WriteBlockProcPtr()</code></a> functions also signal that there is data to be received after they have written the data to the queue. </p>
<h4>
  <a name="997003"> </a>Compatibility 
</h4>

<p><a name="997007"> </a>Implemented only if <a href="CompatibilityApdx.html#994556">New Serial Manager Feature Set Version 2</a> is present. </p>

<h3 class="hbH3">
  <a name="997011"> </a>WriteBlockProcPtr Function <a href="#995796"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="997013"> </a>Purpose 
</h4>

<p><a name="997014"> </a>Writes a block of bytes to the Serial Manager's receive queue.</p>
<h4>
  <a name="997015"> </a>Declared In 
</h4>
<code>SerialDrvr.h<a name="997016"> </a></code><h4>
  <a name="997017"> </a>Prototype 
</h4>
<pre class="proto"><a name="997018"></a>typedef Err (
   *WriteBlockProcPtr
) (
   void *theQ,
   UInt8 *bufP,
   UInt16 size,
   UInt16 lineErrs
)
</pre>
<h4>
  <a name="997019"> </a>Parameters 
</h4>

<dl>
<dt><a name="997020"> </a><code>&rarr;  <i><code>theQ</code></i></code></dt>
<dd><a name="997021"> </a>Pointer to the receive queue.</dd>

<dt><a name="997022"> </a><code>&rarr;  <i><code>bufP</code></i></code></dt>
<dd><a name="997023"> </a>Pointer to the buffer holding bytes to be written.</dd>

<dt><a name="997024"> </a><code>&rarr;  <i><code>size</code></i></code></dt>
<dd><a name="997025"> </a>Size of <code>bufP</code>. </dd>

<dt><a name="997026"> </a><code>&rarr;  <i><code>lineErrs</code></i></code></dt>
<dd><a name="997027"> </a>Any serial line errors received should be reported here.</dd>

</dl>
<h4>
  <a name="997028"> </a>Returns 
</h4>

<dl>
<dt><a name="997029"> </a><code><code>errNone</code> </code></dt>
<dd><a name="997030"> </a>No error.</dd>

<dt><a name="997031"> </a><code><code>serErrLineErr</code></code></dt>
<dd><a name="997032"> </a>There was a software overrun line error.</dd>

</dl>
<h4>
  <a name="997033"> </a>Compatibility 
</h4>

<p><a name="997037"> </a>Implemented only if <a href="CompatibilityApdx.html#994402">New Serial Manager Feature Set Version 1</a> is present.</p>

<h3 class="hbH3">
  <a name="997041"> </a>WriteByteProcPtr Function <a href="#995796"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="997043"> </a>Purpose 
</h4>

<p><a name="997044"> </a>Writes one byte to the Serial Manager's receive queue.</p>
<h4>
  <a name="997045"> </a>Declared In 
</h4>
<code>SerialDrvr.h<a name="997046"> </a></code><h4>
  <a name="997047"> </a>Prototype 
</h4>
<pre class="proto"><a name="997048"></a>typedef Err (
   *WriteByteProcPtr
) (
   void *theQ,
   UInt8 theByte,
   UInt16 lineErrs
)
</pre>
<h4>
  <a name="997049"> </a>Parameters 
</h4>

<dl>
<dt><a name="997050"> </a><code>&rarr;  <i><code>theQ</code></i></code></dt>
<dd><a name="997051"> </a>Pointer to the receive queue.</dd>

<dt><a name="997052"> </a><code>&rarr;  <i><code>theByte</code></i></code></dt>
<dd><a name="997053"> </a>The byte to be written to the queue.</dd>

<dt><a name="997054"> </a><code>&rarr;  <i><code>lineErrs</code></i></code></dt>
<dd><a name="997055"> </a>Any serial line errors received should be reported here.</dd>

</dl>
<h4>
  <a name="997056"> </a>Returns 
</h4>

<dl>
<dt><a name="997057"> </a><code><code>errNone</code> </code></dt>
<dd><a name="997058"> </a>No error.</dd>

<dt><a name="997059"> </a><code><code>serErrLineErr</code></code></dt>
<dd><a name="997060"> </a>There was a software overrun line error.</dd>

</dl>
<h4>
  <a name="997061"> </a>Compatibility 
</h4>

<p><a name="997065"> </a>Implemented only if <a href="CompatibilityApdx.html#994402">New Serial Manager Feature Set Version 1</a> is present.</p>

<p><a name="997066"> </a></p>
&nbsp;<br>
</div>
<!--END CONTENT-->

</td>
<td width="5">&nbsp;&nbsp;</td>
</tr>

</table>

<!-- BEGIN FOOTER -->
<table width="100%" border="0" cellspacing="0" cellpadding="0">
<tr>
<td width="7" rowspan="2"><img name="index_x" src="images/shim.gif" width="7" height="33" border="0" alt=""></td>
<td align="left"><img name="dashes" src="images/dashes.gif" width="744" height="3" border="0" alt=""></td>
<td width="10" rowspan="2"><img name="index_x" src="images/shim.gif" width="10" height="33" border="0" alt=""></td>
</tr>
<tr>
<td align="center">
<p class="footer">
Copyright © 1996-2004, PalmSource, Inc. and its affiliates.  All rights reserved. <br>
<a href="http://www.palmsource.com/contact/">Write Us</a> | <a href="http://www.palmos.com/dev/training/">Training</a> | <a href="http://www.palmos.com/dev/support/kb/">Knowledge Base</a> | <a href="Reference_Front.html" target="_blank">Legal</a></p>
<br>
<!--BEGIN BOOK NAVIGATION-->
<p class="nav">
<A href="http://www.palmos.com/dev/support/docs/">Documentation</a>&nbsp;&nbsp;|&nbsp;&nbsp;
<a href="ReferenceTOC.html">Table of Contents</a>&nbsp;&nbsp;
             |&nbsp;&nbsp;<a href="ScriptPlugin.html">&lt;&nbsp;Previous</a>&nbsp;&nbsp;
             |&nbsp;&nbsp;<a href="SerialManager.html">Next&nbsp;&gt;</a>&nbsp;&nbsp;
             |&nbsp;&nbsp;<a href="ReferenceIX.html">Index</a>
</p>
</td>
</tr>
</table>
<!-- END FOOTER -->

</body>
</html>