<html>
<head>
<title>(68K) Debug Manager | Palm OS&#174; Programmer's  API Reference</title> 
<link href="psi_devpubs.css" rel="stylesheet" type="text/css">

<!-- BEGIN META DATA -->
<meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
<META NAME="PSITEMPLATE" CONTENT="1006-007 PalmSource_HTML_2003 20041101">
<META NAME="GENERATOR" CONTENT="Quadralay WebWorks AutoMap 2003 for FrameMaker 8.0.6.2138">
<META NAME="LASTUPDATED" CONTENT="11/22/04 10:46:19">
<!-- END META DATA -->
</head>

<body bgcolor="#ffffff" text="#000000" leftmargin="0" topmargin="0" marginwidth="0" marginheight="0">
<a name="993177"></a>

<!-- BEGIN TOPNAV -->
<table width="100%" border="0" cellspacing="0" cellpadding="0">
<tr>
<td><img src="images/shim.gif" width="7" height="75" border="0" alt=""></td>
<td align="left"><table border="0" cellpadding="0" cellspacing="0" width="744">
<tr>
<td><img name="index_r2_c1" src="images/shim.gif" width="25" height="75" border="0" alt=""></td>
<td valign="top"><table border="0" cellpadding="0" cellspacing="0" width="96">
<tr>
<td><img name="index_r2_c4" src="images/shim.gif" width="96" height="15" border="0" alt=""></td>
</tr>
<tr>
<td><a href="http://www.palmsource.com/"><img name="ps_logo" src="images/ps_logo.gif" width="96" height="54" border="0" alt=""></a></td>
</tr>

</table>
</td>

<td><table border="0" cellpadding="0" cellspacing="0" width="30">
<td><img name="index_x" src="images/shim.gif" width="30" height="75" border="0" alt=""></td>
</table></td>

<!--BEGIN MASTHEAD-->
<td><table border="0" cellpadding="0" cellspacing="0" width="96">
<tr>
<td><img name="index_x" src="images/shim.gif" width="615" height="5" border="0" alt=""></td>
</tr>
<tr>
<td>
<!--BEGIN BOOK NAVIGATION-->
<span class="nav">
<A href="http://www.palmos.com/dev/support/docs/">Documentation</a>&nbsp;&nbsp;|&nbsp;&nbsp;
<a href="ReferenceTOC.html">Table of Contents</a>&nbsp;&nbsp;
             |&nbsp;&nbsp;<a href="DataAndResourceManager.html">&lt;&nbsp;Previous</a>&nbsp;&nbsp;
             |&nbsp;&nbsp;<a href="ErrorManager.html">Next&nbsp;&gt;</a>&nbsp;&nbsp;
             |&nbsp;&nbsp;<a href="ReferenceIX.html">Index</a>
</span>
<!--END BOOK NAVIGATION-->
</tr>
<tr>
<td>
<!--BEGIN PAGE TITLE-->
<h2 class="PageTitle">31 &nbsp;&nbsp;
Debug Manager</h2></td>
<!--END PAGE TITLE-->
</tr>
<tr>
<td>
<!--BEGIN BOOK TITLE-->
<p class="BookTitle">Palm OS&#174; Programmer's  API Reference</p>
<p class="SubTitle">Palm OS&#174; 68K SDK </p>
<!--END BOOK TITLE-->
</td>
</tr>
<tr>
<td><img name="index_x" src="images/shim.gif" width="615" height="5" border="0" alt=""></td>
</tr>
</table>
</td>
<!--END MASTHEAD-->
</tr>
</table>
<img name="dashes" src="images/dashes.gif" width="744" height="3" border="0" alt=""></td>
</tr>
</table>
<!-- END TOPNAV -->

<table width="100%" border="0" cellspacing="0" cellpadding="0">
<tr>
<td valign="top" width="5"><img name="index_x" src="images/shim.gif" width="5" height="33" border="0" alt=""></td>

<!--BEGIN SIDETOC-->
<td valign="top" width="175">
<div id="sidetoc" valign="bottom">
<h1 class="SideTOC1-PartTab"><a href="PartII.html">Part II: System Management</a> </h1>
<h1 class="SideTOC1"><a href="DebugMgr.html">31  Debug Manager</a></h1>

   <h2 class="SideTOC2"><a href="#993185">
   Debug Manager Structures and Types</a></h2>

      <h3 class="SideTOC3"><a href="#993193">
      DbgCtlEnumInfoType</a></h3>

      <h3 class="SideTOC3"><a href="#993229">
      DbgCtlHandlerInfoType</a></h3>

   <h2 class="SideTOC2"><a href="#993531">
   Debug Manager Constants</a></h2>

      <h3 class="SideTOC3"><a href="#993559">
      DbgControl() Constants</a></h3>

      <h3 class="SideTOC3"><a href="#995217">
      System-Defined Debug Control Operations</a></h3>

   <h2 class="SideTOC2"><a href="#993945">
   Debug Manager Functions and Macros</a></h2>

      <h3 class="SideTOC3"><a href="#993993">
      DbgBreak</a></h3>

      <h3 class="SideTOC3"><a href="#994033">
      DbgCommSettings</a></h3>

      <h3 class="SideTOC3"><a href="#994131">
      DbgGetMessage</a></h3>

      <h3 class="SideTOC3"><a href="#994177">
      DbgInit</a></h3>

      <h3 class="SideTOC3"><a href="#994279">
      DbgMessage</a></h3>

      <h3 class="SideTOC3"><a href="#994321">
      DbgSrcBreak</a></h3>

      <h3 class="SideTOC3"><a href="#994361">
      DbgSrcMessage</a></h3>

   <h2 class="SideTOC2"><a href="#994407">
   Application-Defined Functions</a></h2>

      <h3 class="SideTOC3"><a href="#994447">
      DbgControlFuncType</a></h3>

      <h3 class="SideTOC3"><a href="#994540">
      DbgCtlEnumCallbackFunc</a></h3>

</div>
</td>

<td width="5">&nbsp;&nbsp;</td>
<td width="2" background="images/index_r8_c10.gif"><img src="images/shim.gif" width="2" height="75" border="0" alt=""></td>
<td width="5">&nbsp;&nbsp;</td>

<!--END SIDETOC-->

<td valign="top">

<!--BEGIN CONTENT-->
<div id="content" valign="bottom">
<p><a name="993179"> </a>The Debug Manager provides a set of debugger functions that go above and beyond what is provided in ROM.</p>
   <blockquote class = "bq"><a name="993191"> </a><a href="DebugMgr.html#993185">Debug Manager Structures and Types</a></blockquote>
   <blockquote class = "bq"><a name="993537"> </a><a href="DebugMgr.html#993531">Debug Manager Constants</a></blockquote>
   <blockquote class = "bq"><a name="993951"> </a><a href="DebugMgr.html#993945">Debug Manager Functions and Macros</a></blockquote>
   <blockquote class = "bq"><a name="994413"> </a><a href="DebugMgr.html#994407">Application-Defined Functions</a></blockquote>

<p><a name="993181"> </a>The header file <code>DebugMgr.h</code> declares the API that this chapter describes.</p>

<h2 class="haH2">
  <a name="993185"> </a>Debug Manager Structures and Types <a href="#993177"><span class="nav">^TOP^</span></a>
</h2>


<h3 class="hbH3">
  <a name="993193"> </a>DbgCtlEnumInfoType Struct <a href="#993177"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="993198"> </a>Purpose 
</h4>

<p><a name="993201"> </a></p>
<h4>
  <a name="993203"> </a>Declared In 
</h4>
<code>DebugMgr.h<a name="993206"> </a></code><h4>
  <a name="993208"> </a>Prototype 
</h4>
<pre class="proto"><a name="993211"></a>typedef struct DbgCtlEnumInfoType {
   DbgCtlEnumCallbackFunc *enumFuncP;
   void *callbackDataP;
} DbgCtlEnumInfoType
</pre>
<h4>
  <a name="993213"> </a>Fields 
</h4>

<dl>
<dt><a name="993216"> </a><code>enumFuncP</code></dt>
<dd><a name="993218"> </a></dd>

<dt><a name="993220"> </a><code>callbackDataP</code></dt>
<dd><a name="993222"> </a></dd>

</dl>
<h4>
  <a name="993224"> </a>Comments 
</h4>

<p><a name="993227"> </a></p>

<h3 class="hbH3">
  <a name="993229"> </a>DbgCtlHandlerInfoType Struct <a href="#993177"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="993234"> </a>Purpose 
</h4>

<p><a name="993237"> </a></p>
<h4>
  <a name="993239"> </a>Declared In 
</h4>
<code>DebugMgr.h<a name="993242"> </a></code><h4>
  <a name="993244"> </a>Prototype 
</h4>
<pre class="proto"><a name="993247"></a>typedef struct DbgCtlHandlerInfoType {
   DbgControlFuncType *handlerFuncP;
   UInt32 version;
   Boolean enabled;
   Char name[dbgCtlHandlerNameLen+1];
   Char ver[dbgCtlHandlerVerLen+1];
   UInt8 reserved1;
   UInt32 dwReserved;
} DbgCtlHandlerInfoType
</pre>
<h4>
  <a name="993303"> </a>Fields 
</h4>

<dl>
<dt><a name="993354"> </a><code>handlerFuncP</code></dt>
<dd><a name="993404"> </a>Pointer to the handler's <code>DbgControl()</code> function. This function's prototype must match that declared by <a href="DebugMgr.html#994447"><code>DbgControlFuncType()</code></a>.</dd>

<dt><a name="993454"> </a><code>version</code></dt>
<dd><a name="993504"> </a>Numeric version number (handler-defined).</dd>

<dt><a name="993506"> </a><code>enabled</code></dt>
<dd><a name="993508"> </a><code>true</code> if the handler is enabled; <code>false</code> if it isn't.</dd>

<dt><a name="993510"> </a><code>name</code></dt>
<dd><a name="993512"> </a>Null-terminated handler name. This name should not exceed <code>dbgCtlHandlerNameLen</code> characters in length (not counting the null terminator).</dd>

<dt><a name="993514"> </a><code>ver</code></dt>
<dd><a name="995147"> </a>Null-terminated handler version string. This string should not exceed <code>dbgCtlHandlerVerLen</code> characters in length (not counting the null terminator).</dd>

<dt><a name="993518"> </a><code>reserved1</code></dt>
<dd><a name="993520"> </a>Reserved for future use.</dd>

<dt><a name="993522"> </a><code>dwReserved</code></dt>
<dd><a name="993524"> </a>Reserved field. <i>The caller must initialize this field to zero</i>.</dd>

</dl>

<h2 class="haH2">
  <a name="993531"> </a>Debug Manager Constants <a href="#993177"><span class="nav">^TOP^</span></a>
</h2>


<h3 class="hbH3">
  <a name="993559"> </a>DbgControl() Constants <a href="#993177"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="993561"> </a>Purpose 
</h4>

<p><a name="993578"> </a>Constants used in conjunction with <code>DbgControl()</code>.</p>
<h4>
  <a name="993580"> </a>Declared In 
</h4>
<code>DebugMgr.h<a name="993605"> </a></code><h4>
  <a name="993638"> </a>Constants 
</h4>

<dl>
<dt><a name="993691"> </a><code>extern DbgControlFuncType DbgControl</code></dt>
<dd><a name="993747"> </a></dd>

<dt><a name="993805"> </a><code>#define dbgCtlAllHandlersID 0</code></dt>
<dd><a name="994746"> </a>Value that can be supplied to <a href="DebugMgr.html#994447"><code>DbgControlFuncType()</code></a> to indicate that the operation is to be handled by all handlers.</dd>

<dt><a name="993865"> </a><code>#define dbgCtlFirstCustomOp 0x8000</code></dt>
<dd><a name="994844"> </a>Debug handler operations are numbered beginning with this value. The system reserves all operation number values less than this one.</dd>

<dt><a name="993869"> </a><code>#define dbgCtlHandled true</code></dt>
<dd><a name="994665"> </a>Value returned by <a href="DebugMgr.html#994447"><code>DbgControlFuncType()</code></a> to indicate that the debug control operation was handled.</dd>

<dt><a name="993873"> </a><code>#define dbgCtlHandlerNameLen 31</code></dt>
<dd><a name="993875"> </a>Maximum handler name length, not including the terminating null character.</dd>

<dt><a name="993877"> </a><code>#define dbgCtlHandlerVerLen 15</code></dt>
<dd><a name="994774"> </a>Maximum handler version string length, not including the terminating null character.</dd>

<dt><a name="993879"> </a><code>#define dbgCtlNotHandled false</code></dt>
<dd><a name="995216"> </a>Value returned by <a href="DebugMgr.html#994447"><code>DbgControlFuncType()</code></a> to indicate that the debug control operation was not handled.</dd>

</dl>

<h3 class="hbH3">
  <a name="995217"> </a>System-Defined Debug Control Operations Enum <a href="#993177"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="993895"> </a>Purpose 
</h4>

<p><a name="993898"> </a>Opcodes for system-defined debug control operations. These values are passed in the <code class="par">op</code> parameter of the <a href="DebugMgr.html#994447"><code>DbgControlFuncType()</code></a> function.</p>
<h4>
  <a name="993900"> </a>Declared In 
</h4>
<code>DebugMgr.h<a name="993903"> </a></code><h4>
  <a name="993905"> </a>Constants 
</h4>

<dl>
<dt><a name="993908"> </a><code>dbgCtlOpEnumHandlers = 1</code></dt>
<dd><a name="995552"> </a>Enumerate all handlers. The <code class="par">handlerID</code> parameter must be set to <code>dbgCtlAllHandlersID</code>. </dd>

<dt><a name="993912"> </a><code>dbgCtlOpGetHandlerInfo</code></dt>
<dd><a name="993914"> </a>Get information about a specific handler. </dd>

<dt><a name="993916"> </a><code>dbgCtlOpEnableHandler</code></dt>
<dd><a name="993918"> </a>Enable the specified handler. <code>dbgCtlAllHandlersID</code> can be supplied for the <code class="par">handlerID</code> parameter to enable all handlers. The <code class="par">paramP</code> and <code class="par">dwParamP</code> parameters are ignored.</dd>

<dt><a name="993924"> </a><code>dbgCtlOpDisableHandler</code></dt>
<dd><a name="997005"> </a>Disable the specified handler. <code>dbgCtlAllHandlersID</code> can be supplied for the <code class="par">handlerID</code> parameter to disable all handlers. The <code class="par">paramP</code> and <code class="par">dwParamP</code> parameters are ignored.</dd>

<dt><a name="993928"> </a><code>dbgCtlOpGetEnabledStatus</code></dt>
<dd><a name="997294"> </a>Determine whether a specific handler is enabled. When making this call, <code class="par">dwParamP</code> should point to a <code>UInt32</code> that will be set to a non-zero value if the handler is enabled, or to zero if it is disabled. The <code class="par">paramP</code> parameter is ignored.</dd>

<dt><a name="993932"> </a><code>dbgCtlOpGetVersion</code></dt>
<dd><a name="993934"> </a>Obtain the version number for a specific handler. When making this call, <code class="par">dwParamP</code> should point to a <code>UInt32</code> that will receive the handler's version number. The <code class="par">paramP</code> parameter is ignored.</dd>

<dt><a name="993936"> </a><code>dbgCtlOpLAST</code></dt>
<dd><a name="993938"> </a>Not a valid operation code, this value represents the next unused operation code value.</dd>

</dl>

<h2 class="haH2">
  <a name="993945"> </a>Debug Manager Functions and Macros <a href="#993177"><span class="nav">^TOP^</span></a>
</h2>


<h3 class="hbH3">
  <a name="993993"> </a>DbgBreak Function <a href="#993177"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="993998"> </a>Purpose 
</h4>

<p><a name="995582"> </a>Connects to the assembly-level debugger and halts execution.</p>
<h4>
  <a name="994003"> </a>Declared In 
</h4>
<code>DebugMgr.h<a name="994006"> </a></code><h4>
  <a name="994008"> </a>Prototype 
</h4>
<pre class="proto"><a name="994011"></a>void DbgBreak (
   void
)
</pre>
<h4>
  <a name="994013"> </a>Parameters 
</h4>

<p><a name="994016"> </a>None.</p>
<h4>
  <a name="994018"> </a>Returns 
</h4>

<p><a name="994021"> </a>Nothing.</p>
<h4>
  <a name="996137"> </a>See Also 
</h4>

<p><a name="996347"> </a><a href="DebugMgr.html#994321"><code>DbgSrcBreak()</code></a></p>

<h3 class="hbH3">
  <a name="994033"> </a>DbgCommSettings Function <a href="#993177"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="994038"> </a>Purpose 
</h4>

<p><a name="994041"> </a>Retrieve or change the communications settings used by the debugger.</p>
<h4>
  <a name="994043"> </a>Declared In 
</h4>
<code>DebugMgr.h<a name="994046"> </a></code><h4>
  <a name="994048"> </a>Prototype 
</h4>
<pre class="proto"><a name="994051"></a>Err DbgCommSettings (
   UInt32 <code class="par">*baudP</code>,
   UInt32 <code class="par">*flagsP</code>
)
</pre>
<h4>
  <a name="994053"> </a>Parameters 
</h4>

<dl>
<dt><a name="994056"> </a><code>&harr;  <i>baudP</i></code></dt>
<dd><a name="994058"> </a>To retrieve the current settings, set <code class="par">*baudP</code> to zero. Upon return, <code class="par">*baudP</code> will contain the current baud rate. To change the current settings, set <code class="par">*baudP</code> to the new baud rate.</dd>

<dt><a name="994064"> </a><code>&harr;  <i>flagsP</i></code></dt>
<dd><a name="994114"> </a>If <code class="par">*baudP</code> is set to zero, the communications settings flags are retrieved along with the baud rate and stored in <code class="par">*flagsP</code>. If *<code class="par">baudP</code> is nonzero, <code class="par">*flagsP </code>should contain the desired communications settings flags; see <a href="SerialManager.html#1020831">"Serial Settings Constants"</a> for the set of flags that can be combined to make up <code class="par">*flagsP</code>.</dd>

</dl>
<h4>
  <a name="994116"> </a>Returns 
</h4>

<p><a name="994119"> </a><code>errNone</code> if the operation completed successfully, or <code>serErrNotOpen</code> if the debugger communications library is not open.</p>

<h3 class="hbH3">
  <a name="994131"> </a>DbgGetMessage Function <a href="#993177"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="994136"> </a>Purpose 
</h4>

<p><a name="994139"> </a>Wait for, and then retrieve, a message packet from the host.</p>
<h4>
  <a name="994141"> </a>Declared In 
</h4>
<code>DebugMgr.h<a name="994144"> </a></code><h4>
  <a name="994146"> </a>Prototype 
</h4>
<pre class="proto"><a name="994149"></a>Char *DbgGetMessage (
   UInt8 <code class="par">*bufferP</code>,
   Int32 <code class="par">timeout</code>
)
</pre>
<h4>
  <a name="994151"> </a>Parameters 
</h4>

<dl>
<dt><a name="994154"> </a><code>&larr;  <i>bufferP</i></code></dt>
<dd><a name="994156"> </a>Pointer to a pre-allocated buffer into which the message is to be written. When allocating memory for this buffer , note that it must be at least <code>sysPktMaxBodySize</code> bytes in length.</dd>

<dt><a name="994158"> </a><code>&rarr;  <i>timeout</i></code></dt>
<dd><a name="998125"> </a>Maximum number of system ticks to wait for the beginning of the packet. A timeout value of <code>-1</code> means that the function should wait forever.</dd>

</dl>
<h4>
  <a name="994162"> </a>Returns 
</h4>

<p><a name="994165"> </a>A pointer to the start of the text in the received packet, or zero if an error occurred. Note that the returned pointer will <i>not</i> be the same as the supplied buffer pointer.</p>
<h4>
  <a name="994167"> </a>Comments 
</h4>

<p><a name="994170"> </a>Use this function to obtain text input from the serial port.</p>
<h4>
  <a name="994172"> </a>See Also 
</h4>

<p><a name="994175"> </a><a href="DebugMgr.html#994279"><code>DbgMessage()</code></a></p>

<h3 class="hbH3">
  <a name="994177"> </a>DbgInit Function <a href="#993177"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="994182"> </a>Purpose 
</h4>

<p><a name="994185"> </a>Initialize the debugger and the debugger's serial port.</p>
<h4>
  <a name="994187"> </a>Declared In 
</h4>
<code>DebugMgr.h<a name="994190"> </a></code><h4>
  <a name="994192"> </a>Prototype 
</h4>
<pre class="proto"><a name="994195"></a>Int32 DbgInit (
   MemPtr <code class="par">spaceP</code>,
   MemPtr <code class="par">dispatchTableP[]</code>,
   Boolean <code class="par">openComm</code>
)
</pre>
<h4>
  <a name="994197"> </a>Parameters 
</h4>

<dl>
<dt><a name="994200"> </a><code>&larr;  <i>spaceP</i></code></dt>
<dd><a name="994202"> </a>Pointer to a pre-allocated block of memory to be used for debugger globals. This block of memory should be at least 64 bytes in length.</dd>

<dt><a name="994208"> </a><code>&rarr;  <i>dispatchTableP</i></code></dt>
<dd><a name="998311"> </a>Pointer to system dispatch table, where debugger traps get installed.</dd>

<dt><a name="994260"> </a><code>&rarr;  <i>openComm</i></code></dt>
<dd><a name="994262"> </a>Pass <code>true</code> to open communications and display a welcome message, or <code>false</code> to skip this step.</dd>

</dl>
<h4>
  <a name="994264"> </a>Returns 
</h4>

<p><a name="994267"> </a>The number of bytes used for globals.</p>
<h4>
  <a name="994269"> </a>Comments 
</h4>

<p><a name="994272"> </a>This function is called for you at boot time. Applications do not need to call this function.</p>

<h3 class="hbH3">
  <a name="994279"> </a>DbgMessage Function <a href="#993177"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="994284"> </a>Purpose 
</h4>

<p><a name="995734"> </a>Sends a null-terminated string to the current debug device.</p>
<h4>
  <a name="994289"> </a>Declared In 
</h4>
<code>DebugMgr.h<a name="994292"> </a></code><h4>
  <a name="994294"> </a>Prototype 
</h4>
<pre class="proto"><a name="994297"></a>void DbgMessage (
   const Char <code class="par">*aStr</code>
)
</pre>
<h4>
  <a name="994299"> </a>Parameters 
</h4>

<dl>
<dt><a name="994302"> </a><code>&rarr;  <i>aStr</i></code></dt>
<dd><a name="995906"> </a>The null-terminated string to be sent to the current debug device.</dd>

</dl>
<h4>
  <a name="994306"> </a>Returns 
</h4>

<p><a name="994309"> </a>Nothing.</p>
<h4>
  <a name="998517"> </a>See Also 
</h4>

<p><a name="998680"> </a><a href="DebugMgr.html#994131"><code>DbgGetMessage()</code></a>, <a href="DebugMgr.html#994361"><code>DbgSrcMessage()</code></a></p>

<h3 class="hbH3">
  <a name="994321"> </a>DbgSrcBreak Function <a href="#993177"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="994326"> </a>Purpose 
</h4>

<p><a name="998922"> </a>Connects to the source-level debugger and halts execution.</p>
<h4>
  <a name="994331"> </a>Declared In 
</h4>
<code>DebugMgr.h<a name="994334"> </a></code><h4>
  <a name="994336"> </a>Prototype 
</h4>
<pre class="proto"><a name="994339"></a>void DbgSrcBreak (
   void
)
</pre>
<h4>
  <a name="994341"> </a>Parameters 
</h4>

<p><a name="994344"> </a>None.</p>
<h4>
  <a name="994346"> </a>Returns 
</h4>

<p><a name="994349"> </a>Nothing.</p>
<h4>
  <a name="994356"> </a>See Also 
</h4>

<p><a name="994359"> </a><a href="DebugMgr.html#993993"><code>DbgBreak()</code></a></p>

<h3 class="hbH3">
  <a name="994361"> </a>DbgSrcMessage Function <a href="#993177"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="994370"> </a>Purpose 
</h4>

<p><a name="994373"> </a>Displays a message to the source-level debugger.</p>
<h4>
  <a name="994375"> </a>Declared In 
</h4>
<code>DebugMgr.h<a name="994378"> </a></code><h4>
  <a name="994380"> </a>Prototype 
</h4>
<pre class="proto"><a name="994383"></a>void DbgSrcMessage (
   const Char <code class="par">*debugStr</code>
)
</pre>
<h4>
  <a name="994385"> </a>Parameters 
</h4>

<dl>
<dt><a name="994388"> </a><code>&rarr;  <i>debugStr</i></code></dt>
<dd><a name="994390"> </a>A null-terminated string.</dd>

</dl>
<h4>
  <a name="994392"> </a>Returns 
</h4>

<p><a name="998994"> </a>Nothing.</p>
<h4>
  <a name="994402"> </a>See Also 
</h4>

<p><a name="994405"> </a><a href="DebugMgr.html#994279"><code>DbgMessage()</code></a></p>

<h2 class="haH2">
  <a name="994407"> </a>Application-Defined Functions <a href="#993177"><span class="nav">^TOP^</span></a>
</h2>


<h3 class="hbH3">
  <a name="994447"> </a>DbgControlFuncType Function <a href="#993177"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="994452"> </a>Purpose 
</h4>

<p><a name="996628"> </a>Debug control function for implementing debug tracing and other such functions via debug handlers. The system's default implementation of this function (named <code>DbgControl()</code>) does nothing, simply returning <code>dbgCtlNotHandled</code>.</p>
<h4>
  <a name="994457"> </a>Declared In 
</h4>
<code>DebugMgr.h<a name="994460"> </a></code><h4>
  <a name="994462"> </a>Prototype 
</h4>
<pre class="proto"><a name="994465"></a>Boolean DbgControlFuncType (
   UInt32 <code class="par">handlerID</code>,
   UInt16 <code class="par">op</code>,
   void <code class="par">*paramP</code>,
   UInt32 <code class="par">*dwParamP</code>
)
</pre>
<h4>
  <a name="994467"> </a>Parameters 
</h4>

<dl>
<dt><a name="994470"> </a><code>&rarr;  <i>handlerID</i></code></dt>
<dd><a name="994472"> </a>ID of the debug handler that is to handle this call. A value of <code>dbgCtlAllHandlersID</code> indicates that each handler is to execute the specified operation and then pass the call down the chain for the next handler to execute.</dd>

<dt><a name="994474"> </a><code>&rarr;  <i>op</i></code></dt>
<dd><a name="994476"> </a>Operation ID specific to the handler specified by <code class="par">handlerID</code>. See <a href="DebugMgr.html#995217">"System-Defined Debug Control Operations"</a> for a number of operation IDs defined by the system.</dd>

<dt><a name="994478"> </a><code>&harr;  <i>paramP</i></code></dt>
<dd><a name="994480"> </a>pointer to data specific to the reqested operation.</dd>

<dt><a name="994482"> </a><code>&harr;  <i>dwParamP</i></code></dt>
<dd><a name="994484"> </a>Pointer to a <code>UInt32</code> value specific to the requested operation.</dd>

</dl>
<h4>
  <a name="994486"> </a>Returns 
</h4>

<p><a name="994495"> </a><code>dbgCtlHandled</code> if the specified handler handled the requested operation, or <code>dbgCtlNotHandled</code> if it didn't.</p>
<h4>
  <a name="994505"> </a>Comments 
</h4>

<p><a name="996520"> </a>The default implementation does nothing, leaving the real work up to "debug handlers." Debug handlers will be implemented as system extensions.  As they are loaded, extensions will override the <code>DbgControl()</code> function call and chain to those handlers loaded before them. </p>

<p><a name="999108"> </a>When a debug control call is made by the client, a handler ID of the handler that implements the functionality is passed in as the first parameter.  The handler ID is the unique creator ID of the handler.  When a handler is called, it will first examine the handler ID: if it matches its own, the handler will execute the command and return; if the handler ID does not match, the handler must pass the call down the chain and return the value from that call. </p>

<p><a name="999103"> </a>The operation to be performed is indicated by the parameter <code class="par">op</code>. Operation codes are specific to each handler, meaning that that the same operation code values may be used by different handlers. Operation code values defined by handlers must begin at <code>dbgCtlFirstCustomOp</code>. The special handler ID of <code>dbgCtlAllHandlersID</code> applies to all handlers.  When this handler ID is passed, each handler is responsible for executing the requested action and then passing the call down the chain. </p>

<p><a name="999113"> </a>The last two parameters are defined by each handler for its own operations.</p>

<h3 class="hbH3">
  <a name="994540"> </a>DbgCtlEnumCallbackFunc Function <a href="#993177"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="994553"> </a>Purpose 
</h4>

<p><a name="994556"> </a></p>
<h4>
  <a name="994558"> </a>Declared In 
</h4>
<code>DebugMgr.h<a name="994561"> </a></code><h4>
  <a name="994563"> </a>Prototype 
</h4>
<pre class="proto"><a name="994566"></a>void DbgCtlEnumCallbackFunc (
   void <code class="par">*callbackDataP</code>,
   UInt32 <code class="par">handlerID</code>,
   DbgControlFuncType <code class="par">*handlerFuncP</code>
)
</pre>
<h4>
  <a name="994568"> </a>Parameters 
</h4>

<dl>
<dt><a name="994571"> </a><code>callbackDataP</code></dt>
<dd><a name="994573"> </a></dd>

<dt><a name="994575"> </a><code>&rarr;  <i>handlerID</i></code></dt>
<dd><a name="994577"> </a></dd>

<dt><a name="994579"> </a><code>handlerFuncP</code></dt>
<dd><a name="994581"> </a></dd>

</dl>
<h4>
  <a name="994583"> </a>Returns 
</h4>

<p><a name="994586"> </a>Nothing.</p>

<p><a name="993173"> </a></p>
&nbsp;<br>
</div>
<!--END CONTENT-->

</td>
<td width="5">&nbsp;&nbsp;</td>
</tr>

</table>

<!-- BEGIN FOOTER -->
<table width="100%" border="0" cellspacing="0" cellpadding="0">
<tr>
<td width="7" rowspan="2"><img name="index_x" src="images/shim.gif" width="7" height="33" border="0" alt=""></td>
<td align="left"><img name="dashes" src="images/dashes.gif" width="744" height="3" border="0" alt=""></td>
<td width="10" rowspan="2"><img name="index_x" src="images/shim.gif" width="10" height="33" border="0" alt=""></td>
</tr>
<tr>
<td align="center">
<p class="footer">
Copyright © 1996-2004, PalmSource, Inc. and its affiliates.  All rights reserved. <br>
<a href="http://www.palmsource.com/contact/">Write Us</a> | <a href="http://www.palmos.com/dev/training/">Training</a> | <a href="http://www.palmos.com/dev/support/kb/">Knowledge Base</a> | <a href="Reference_Front.html" target="_blank">Legal</a></p>
<br>
<!--BEGIN BOOK NAVIGATION-->
<p class="nav">
<A href="http://www.palmos.com/dev/support/docs/">Documentation</a>&nbsp;&nbsp;|&nbsp;&nbsp;
<a href="ReferenceTOC.html">Table of Contents</a>&nbsp;&nbsp;
             |&nbsp;&nbsp;<a href="DataAndResourceManager.html">&lt;&nbsp;Previous</a>&nbsp;&nbsp;
             |&nbsp;&nbsp;<a href="ErrorManager.html">Next&nbsp;&gt;</a>&nbsp;&nbsp;
             |&nbsp;&nbsp;<a href="ReferenceIX.html">Index</a>
</p>
</td>
</tr>
</table>
<!-- END FOOTER -->

</body>
</html>