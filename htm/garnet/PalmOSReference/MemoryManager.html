<html>
<head>
<title>(68K) Memory Manager | Palm OS&#174; Programmer's  API Reference</title> 
<link href="psi_devpubs.css" rel="stylesheet" type="text/css">

<!-- BEGIN META DATA -->
<meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
<META NAME="PSITEMPLATE" CONTENT="1006-007 PalmSource_HTML_2003 20041101">
<META NAME="GENERATOR" CONTENT="Quadralay WebWorks AutoMap 2003 for FrameMaker 8.0.6.2138">
<META NAME="LASTUPDATED" CONTENT="11/22/04 10:46:27">
<!-- END META DATA -->
</head>

<body bgcolor="#ffffff" text="#000000" leftmargin="0" topmargin="0" marginwidth="0" marginheight="0">
<a name="1016260"></a>

<!-- BEGIN TOPNAV -->
<table width="100%" border="0" cellspacing="0" cellpadding="0">
<tr>
<td><img src="images/shim.gif" width="7" height="75" border="0" alt=""></td>
<td align="left"><table border="0" cellpadding="0" cellspacing="0" width="744">
<tr>
<td><img name="index_r2_c1" src="images/shim.gif" width="25" height="75" border="0" alt=""></td>
<td valign="top"><table border="0" cellpadding="0" cellspacing="0" width="96">
<tr>
<td><img name="index_r2_c4" src="images/shim.gif" width="96" height="15" border="0" alt=""></td>
</tr>
<tr>
<td><a href="http://www.palmsource.com/"><img name="ps_logo" src="images/ps_logo.gif" width="96" height="54" border="0" alt=""></a></td>
</tr>

</table>
</td>

<td><table border="0" cellpadding="0" cellspacing="0" width="30">
<td><img name="index_x" src="images/shim.gif" width="30" height="75" border="0" alt=""></td>
</table></td>

<!--BEGIN MASTHEAD-->
<td><table border="0" cellpadding="0" cellspacing="0" width="96">
<tr>
<td><img name="index_x" src="images/shim.gif" width="615" height="5" border="0" alt=""></td>
</tr>
<tr>
<td>
<!--BEGIN BOOK NAVIGATION-->
<span class="nav">
<A href="http://www.palmos.com/dev/support/docs/">Documentation</a>&nbsp;&nbsp;|&nbsp;&nbsp;
<a href="ReferenceTOC.html">Table of Contents</a>&nbsp;&nbsp;
             |&nbsp;&nbsp;<a href="LocaleMgr.html">&lt;&nbsp;Previous</a>&nbsp;&nbsp;
             |&nbsp;&nbsp;<a href="NotifyMgr.html">Next&nbsp;&gt;</a>&nbsp;&nbsp;
             |&nbsp;&nbsp;<a href="ReferenceIX.html">Index</a>
</span>
<!--END BOOK NAVIGATION-->
</tr>
<tr>
<td>
<!--BEGIN PAGE TITLE-->
<h2 class="PageTitle">42 &nbsp;&nbsp;
Memory Manager</h2></td>
<!--END PAGE TITLE-->
</tr>
<tr>
<td>
<!--BEGIN BOOK TITLE-->
<p class="BookTitle">Palm OS&#174; Programmer's  API Reference</p>
<p class="SubTitle">Palm OS&#174; 68K SDK </p>
<!--END BOOK TITLE-->
</td>
</tr>
<tr>
<td><img name="index_x" src="images/shim.gif" width="615" height="5" border="0" alt=""></td>
</tr>
</table>
</td>
<!--END MASTHEAD-->
</tr>
</table>
<img name="dashes" src="images/dashes.gif" width="744" height="3" border="0" alt=""></td>
</tr>
</table>
<!-- END TOPNAV -->

<table width="100%" border="0" cellspacing="0" cellpadding="0">
<tr>
<td valign="top" width="5"><img name="index_x" src="images/shim.gif" width="5" height="33" border="0" alt=""></td>

<!--BEGIN SIDETOC-->
<td valign="top" width="175">
<div id="sidetoc" valign="bottom">
<h1 class="SideTOC1-PartTab"><a href="PartII.html">Part II: System Management</a> </h1>
<h1 class="SideTOC1"><a href="MemoryManager.html">42  Memory Manager</a></h1>

   <h2 class="SideTOC2"><a href="#1016272">
   Memory Manager Functions</a></h2>

      <h3 class="SideTOC3"><a href="#1016275">
      MemCardInfo</a></h3>

      <h3 class="SideTOC3"><a href="#1016307">
      MemCmp</a></h3>

      <h3 class="SideTOC3"><a href="#1016334">
      MemDebugMode</a></h3>

      <h3 class="SideTOC3"><a href="#1016352">
      MemHandleCardNo</a></h3>

      <h3 class="SideTOC3"><a href="#1016375">
      MemHandleDataStorage</a></h3>

      <h3 class="SideTOC3"><a href="#1016400">
      MemHandleFree</a></h3>

      <h3 class="SideTOC3"><a href="#1016423">
      MemHandleHeapID</a></h3>

      <h3 class="SideTOC3"><a href="#1016446">
      MemHandleLock</a></h3>

      <h3 class="SideTOC3"><a href="#1016474">
      MemHandleNew</a></h3>

      <h3 class="SideTOC3"><a href="#1016510">
      MemHandleResize</a></h3>

      <h3 class="SideTOC3"><a href="#1016553">
      MemHandleSetOwner</a></h3>

      <h3 class="SideTOC3"><a href="#1016582">
      MemHandleSize</a></h3>

      <h3 class="SideTOC3"><a href="#1016606">
      MemHandleToLocalID</a></h3>

      <h3 class="SideTOC3"><a href="#1016633">
      MemHandleUnlock</a></h3>

      <h3 class="SideTOC3"><a href="#1016662">
      MemHeapCheck</a></h3>

      <h3 class="SideTOC3"><a href="#1016686">
      MemHeapCompact</a></h3>

      <h3 class="SideTOC3"><a href="#1016706">
      MemHeapDynamic</a></h3>

      <h3 class="SideTOC3"><a href="#1016734">
      MemHeapFlags</a></h3>

      <h3 class="SideTOC3"><a href="#1016761">
      MemHeapFreeBytes</a></h3>

      <h3 class="SideTOC3"><a href="#1016804">
      MemHeapID</a></h3>

      <h3 class="SideTOC3"><a href="#1016834">
      MemHeapScramble</a></h3>

      <h3 class="SideTOC3"><a href="#1016862">
      MemHeapSize</a></h3>

      <h3 class="SideTOC3"><a href="#1016886">
      MemLocalIDKind</a></h3>

      <h3 class="SideTOC3"><a href="#1016904">
      MemLocalIDToGlobal</a></h3>

      <h3 class="SideTOC3"><a href="#1016931">
      MemLocalIDToLockedPtr</a></h3>

      <h3 class="SideTOC3"><a href="#1016967">
      MemLocalIDToPtr</a></h3>

      <h3 class="SideTOC3"><a href="#1016995">
      MemMove</a></h3>

      <h3 class="SideTOC3"><a href="#1017025">
      MemNumCards</a></h3>

      <h3 class="SideTOC3"><a href="#1017040">
      MemNumHeaps</a></h3>

      <h3 class="SideTOC3"><a href="#1017071">
      MemNumRAMHeaps</a></h3>

      <h3 class="SideTOC3"><a href="#1017092">
      MemPtrCardNo</a></h3>

      <h3 class="SideTOC3"><a href="#1017113">
      MemPtrDataStorage</a></h3>

      <h3 class="SideTOC3"><a href="#1017137">
      MemPtrFree</a></h3>

      <h3 class="SideTOC3"><a href="#1017157">
      MemPtrHeapID</a></h3>

      <h3 class="SideTOC3"><a href="#1017176">
      MemPtrNew</a></h3>

      <h3 class="SideTOC3"><a href="#1017202">
      MemPtrRecoverHandle</a></h3>

      <h3 class="SideTOC3"><a href="#1017220">
      MemPtrResize</a></h3>

      <h3 class="SideTOC3"><a href="#1017249">
      MemPtrSetOwner</a></h3>

      <h3 class="SideTOC3"><a href="#1017278">
      MemPtrSize</a></h3>

      <h3 class="SideTOC3"><a href="#1017296">
      MemPtrToLocalID</a></h3>

      <h3 class="SideTOC3"><a href="#1017320">
      MemPtrUnlock</a></h3>

      <h3 class="SideTOC3"><a href="#1017344">
      MemSet</a></h3>

      <h3 class="SideTOC3"><a href="#1017372">
      MemSetDebugMode</a></h3>

      <h3 class="SideTOC3"><a href="#1017392">
      MemStoreInfo</a></h3>

</div>
</td>

<td width="5">&nbsp;&nbsp;</td>
<td width="2" background="images/index_r8_c10.gif"><img src="images/shim.gif" width="2" height="75" border="0" alt=""></td>
<td width="5">&nbsp;&nbsp;</td>

<!--END SIDETOC-->

<td valign="top">

<!--BEGIN CONTENT-->
<div id="content" valign="bottom">
<p><a name="1016263"> </a>This chapter provides reference information for the memory manager. The memory manager API is declared in the header file <code>MemoryMgr.h</code>. </p>

<p><a name="1016265"> </a>For more information on the memory manager, see the chapter <a href="../PalmOSCompanion/Memory.html#1025850">"Memory"</a> in the <i>Palm OS Programmer's Companion</i>, vol. I. </p>

<h2 class="haH2">
  <a name="1016272"> </a>Memory Manager Functions <a href="#1016260"><span class="nav">^TOP^</span></a>
</h2>


<h3 class="hbH3">
  <a name="1016275"> </a>MemCardInfo Function <a href="#1016260"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="1016277"> </a>Purpose 
</h4>

<p><a name="1016279"> </a>Return information about a memory card.</p>
<h4>
  <a name="1016280"> </a>Declared In 
</h4>
<code>MemoryMgr.h<a name="1016281"> </a></code><h4>
  <a name="1016282"> </a>Prototype 
</h4>
<pre class="proto"><a name="1016283"></a>Err MemCardInfo (
   UInt16 cardNo,
   Char *cardNameP,
   Char *manufNameP,
   UInt16 *versionP,
   UInt32 *crDateP,
   UInt32 *romSizeP,
   UInt32 *ramSizeP,
   UInt32 *freeBytesP
)
</pre>
<h4>
  <a name="1016284"> </a>Parameters 
</h4>

<dl>
<dt><a name="1016285"> </a><code><code>cardNo</code></code></dt>
<dd><a name="1016286"> </a>Card number.</dd>

<dt><a name="1016287"> </a><code><code>cardNameP</code></code></dt>
<dd><a name="1016288"> </a>Pointer to character array (32 bytes), or 0. </dd>

<dt><a name="1016289"> </a><code><code>manufNameP</code></code></dt>
<dd><a name="1016290"> </a>Pointer to character array (32 bytes), or 0. </dd>

<dt><a name="1016291"> </a><code><code>versionP</code></code></dt>
<dd><a name="1016292"> </a>Pointer to version variable, or 0.</dd>

<dt><a name="1016293"> </a><code><code>crDateP</code></code></dt>
<dd><a name="1016294"> </a>Pointer to creation date variable, or 0.</dd>

<dt><a name="1016295"> </a><code><code>romSizeP</code></code></dt>
<dd><a name="1016296"> </a>Pointer to ROM size variable, or 0.</dd>

<dt><a name="1016297"> </a><code><code>ramSizeP</code></code></dt>
<dd><a name="1016298"> </a>Pointer to RAM size variable, or 0.</dd>

<dt><a name="1016299"> </a><code><code>freeBytesP</code></code></dt>
<dd><a name="1016300"> </a>Pointer to free byte-count variable, or 0.</dd>

</dl>
<h4>
  <a name="1016301"> </a>Returns 
</h4>

<p><a name="1016302"> </a>Returns 0 if no error.</p>
<h4>
  <a name="1016303"> </a>Comments 
</h4>

<p><a name="1016304"> </a>Pass 0 for those variables that you don't want returned. </p>

<h3 class="hbH3">
  <a name="1016307"> </a>MemCmp Function <a href="#1016260"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="1016309"> </a>Purpose 
</h4>

<p><a name="1016311"> </a>Compare two blocks of memory.</p>

<div><hr>
  <a name="1016312"> </a> <b>NOTE: </b> Blocks are compared as unsigned bytes. 
<hr>
</div>
<h4>
  <a name="1016313"> </a>Declared In 
</h4>
<code>MemoryMgr.h<a name="1016314"> </a></code><h4>
  <a name="1016315"> </a>Prototype 
</h4>
<pre class="proto"><a name="1016316"></a>Int16 MemCmp (
   const void *s1,
   const void *s2,
   Int32 numBytes
)
</pre>
<h4>
  <a name="1016317"> </a>Parameters 
</h4>

<dl>
<dt><a name="1016318"> </a><code><code>s1, s2</code></code></dt>
<dd><a name="1016319"> </a>Pointers to block of memory.</dd>

<dt><a name="1016320"> </a><code><code>numBytes</code></code></dt>
<dd><a name="1016321"> </a>Number of bytes to compare. </dd>

</dl>
<h4>
  <a name="1016322"> </a>Returns 
</h4>

<p><a name="1016323"> </a>Zero if they match, non-zero if not:</p>

<p><a name="1016324"> </a>+ if <code>s1</code> &gt; <code>s2</code> </p>

<p><a name="1016325"> </a>- if <code>s1</code> &lt; <code>s2</code> </p>
<h4>
  <a name="1016326"> </a>Compatibility 
</h4>

<p><a name="1016330"> </a>Implemented only if <a href="CompatibilityApdx.html#992789">2.0 New Feature Set</a> is present.</p>

<p><a name="1016331"> </a><code>MemCmp</code> can be used to test the equality of blocks in memory on all versions that support <code>MemCmp</code>; however, testing the sort ordering of blocks in memory works reliably only on Palm OS<sup>&#174;</sup> versions 3.5 and higher. On versions earlier than 3.2, <code>MemCmp</code> always returns a positive value if the blocks are unequal. On versions 3.2 and 3.3, <code>MemCmp</code> reliably returns positive to indicate <code>s1</code> &gt; <code>s2</code> and negative to indicate <code>s1</code> &lt; <code>s2</code> <i>only</i> if the characters that differ are less than 128 apart. If the difference is greater than that, <code>MemCmp</code> may return positive when it should return negative and vice versa. </p>

<h3 class="hbH3">
  <a name="1016334"> </a>MemDebugMode Function <a href="#1016260"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="1016336"> </a>Purpose 
</h4>

<p><a name="1016338"> </a>Return the current debugging mode of the memory manager.</p>
<h4>
  <a name="1016339"> </a>Declared In 
</h4>
<code>MemoryMgr.h<a name="1016340"> </a></code><h4>
  <a name="1016341"> </a>Prototype 
</h4>
<pre class="proto"><a name="1016342"></a>UInt16 MemDebugMode (
   void
)
</pre>
<h4>
  <a name="1016343"> </a>Parameters 
</h4>

<p><a name="1016344"> </a>No parameters.</p>
<h4>
  <a name="1016345"> </a>Returns 
</h4>

<p><a name="1016349"> </a>Returns debug flags as described for <a href="MemoryManager.html#1017372"><code>MemSetDebugMode()</code></a>.</p>

<h3 class="hbH3">
  <a name="1016352"> </a>MemHandleCardNo Function <a href="#1016260"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="1016354"> </a>Purpose 
</h4>

<p><a name="1016356"> </a>Return the card number a chunk resides in.</p>
<h4>
  <a name="1016357"> </a>Declared In 
</h4>
<code>MemoryMgr.h<a name="1016358"> </a></code><h4>
  <a name="1016359"> </a>Prototype 
</h4>
<pre class="proto"><a name="1016360"></a>UInt16 MemHandleCardNo (
   MemHandle h
)
</pre>
<h4>
  <a name="1016361"> </a>Parameters 
</h4>

<dl>
<dt><a name="1016362"> </a><code>&rarr;  <i><code>h</code></i></code></dt>
<dd><a name="1016363"> </a>Chunk handle.</dd>

</dl>
<h4>
  <a name="1016364"> </a>Returns 
</h4>

<p><a name="1016365"> </a>Returns the card number.</p>
<h4>
  <a name="1016366"> </a>Comments 
</h4>

<p><a name="1016367"> </a>Call this routine to retrieve the card number (0 or 1) a movable chunk resides on. </p>
<h4>
  <a name="1016368"> </a>See Also 
</h4>

<p><a name="1016372"> </a><a href="MemoryManager.html#1017092"><code>MemPtrCardNo()</code></a> </p>

<h3 class="hbH3">
  <a name="1016375"> </a>MemHandleDataStorage Function <a href="#1016260"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="1016377"> </a>Purpose 
</h4>

<p><a name="1016379"> </a>Return <code>true</code> if the given handle is part of a data storage heap. If not, it's a handle in the dynamic heap.</p>
<h4>
  <a name="1016381"> </a>Declared In 
</h4>
<code>MemoryMgr.h<a name="1016382"> </a></code><h4>
  <a name="1016383"> </a>Prototype 
</h4>
<pre class="proto"><a name="1016385"></a>Boolean MemHandleDataStorage (
   MemHandle h
) 
</pre>
<h4>
  <a name="1016386"> </a>Parameters 
</h4>

<dl>
<dt><a name="1016387"> </a><code>&rarr;  <i><code>h</code></i></code></dt>
<dd><a name="1016388"> </a>Chunk handle.</dd>

</dl>
<h4>
  <a name="1016389"> </a>Returns 
</h4>

<p><a name="1016390"> </a>Returns <code>true</code> if the handle is part of a data storage heap.</p>
<h4>
  <a name="1016391"> </a>Comments 
</h4>

<p><a name="1016392"> </a>Called by Fields package routines to determine if they need to worry about data storage write-protection when editing a text field.</p>
<h4>
  <a name="1016393"> </a>See Also 
</h4>

<p><a name="1016397"> </a><a href="MemoryManager.html#1017113"><code>MemPtrDataStorage()</code></a> </p>

<h3 class="hbH3">
  <a name="1016400"> </a>MemHandleFree Function <a href="#1016260"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="1016402"> </a>Purpose 
</h4>

<p><a name="1016404"> </a>Dispose of a movable chunk.</p>
<h4>
  <a name="1016405"> </a>Declared In 
</h4>
<code>MemoryMgr.h<a name="1016406"> </a></code><h4>
  <a name="1016407"> </a>Prototype 
</h4>
<pre class="proto"><a name="1016408"></a>Err MemHandleFree (
   MemHandle h
)
</pre>
<h4>
  <a name="1016409"> </a>Parameters 
</h4>

<dl>
<dt><a name="1016410"> </a><code>&rarr;  <i><code>h</code></i></code></dt>
<dd><a name="1016411"> </a>Chunk handle.</dd>

</dl>
<h4>
  <a name="1016412"> </a>Returns 
</h4>

<p><a name="1016413"> </a>Returns 0 if no error, or <code>memErrInvalidParam</code> if an error occurs.</p>
<h4>
  <a name="1016414"> </a>Comments 
</h4>

<p><a name="1016415"> </a>Call this routine to dispose of a movable chunk.</p>
<h4>
  <a name="1016416"> </a>See Also 
</h4>

<p><a name="1016420"> </a><a href="MemoryManager.html#1016474"><code>MemHandleNew()</code></a> </p>

<h3 class="hbH3">
  <a name="1016423"> </a>MemHandleHeapID Function <a href="#1016260"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="1016425"> </a>Purpose 
</h4>

<p><a name="1016427"> </a>Return the heap ID of a chunk.</p>
<h4>
  <a name="1016428"> </a>Declared In 
</h4>
<code>MemoryMgr.h<a name="1016429"> </a></code><h4>
  <a name="1016430"> </a>Prototype 
</h4>
<pre class="proto"><a name="1016431"></a>UInt16 MemHandleHeapID (
   MemHandle h
)
</pre>
<h4>
  <a name="1016432"> </a>Parameters 
</h4>

<dl>
<dt><a name="1016433"> </a><code>&rarr;  <i><code>h</code></i></code></dt>
<dd><a name="1016434"> </a>Chunk handle.</dd>

</dl>
<h4>
  <a name="1016435"> </a>Returns 
</h4>

<p><a name="1016436"> </a>Returns the heap ID of a chunk.</p>
<h4>
  <a name="1016437"> </a>Comments 
</h4>

<p><a name="1016438"> </a>Call this routine to get the heap ID of the heap a chunk resides in.</p>
<h4>
  <a name="1016439"> </a>See Also 
</h4>

<p><a name="1016443"> </a><a href="MemoryManager.html#1017157"><code>MemPtrHeapID()</code></a> </p>

<h3 class="hbH3">
  <a name="1016446"> </a>MemHandleLock Function <a href="#1016260"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="1016448"> </a>Purpose 
</h4>

<p><a name="1016449"> </a>Lock a chunk and obtain a pointer to the chunk's data.</p>
<h4>
  <a name="1016450"> </a>Declared In 
</h4>
<code>MemoryMgr.h<a name="1016451"> </a></code><h4>
  <a name="1016452"> </a>Prototype 
</h4>
<pre class="proto"><a name="1016454"></a>MemPtr MemHandleLock (
   MemHandle h
)
</pre>
<h4>
  <a name="1016455"> </a>Parameters 
</h4>

<dl>
<dt><a name="1016456"> </a><code>&rarr;  <i><code>h</code></i></code></dt>
<dd><a name="1016457"> </a>Chunk handle.</dd>

</dl>
<h4>
  <a name="1016458"> </a>Returns 
</h4>

<p><a name="1016459"> </a>Returns a pointer to the chunk.</p>
<h4>
  <a name="1016460"> </a>Comments 
</h4>

<p><a name="1016462"> </a>Call this routine to lock a chunk and obtain a pointer to the chunk.</p>

<p><a name="1016463"> </a><code>MemHandleLock</code> and <code>MemHandleUnlock</code> should be used in pairs.</p>
<h4>
  <a name="1016464"> </a>See Also 
</h4>

<p><a name="1016471"> </a><a href="MemoryManager.html#1016474"><code>MemHandleNew()</code></a>, <a href="MemoryManager.html#1016633"><code>MemHandleUnlock()</code></a></p>

<h3 class="hbH3">
  <a name="1016474"> </a>MemHandleNew Function <a href="#1016260"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="1016476"> </a>Purpose 
</h4>

<p><a name="1016478"> </a>Allocate a new movable chunk in the dynamic heap and returns a handle to it. </p>
<h4>
  <a name="1016479"> </a>Declared In 
</h4>
<code>MemoryMgr.h<a name="1016480"> </a></code><h4>
  <a name="1016481"> </a>Prototype 
</h4>
<pre class="proto"><a name="1016483"></a>MemHandle MemHandleNew (
   UInt32 size
)
</pre>
<h4>
  <a name="1016484"> </a>Parameters 
</h4>

<dl>
<dt><a name="1016485"> </a><code>&rarr;  <i><code>size</code></i></code></dt>
<dd><a name="1016486"> </a>The desired size of the chunk.</dd>

</dl>
<h4>
  <a name="1016487"> </a>Returns 
</h4>

<p><a name="1016488"> </a>Returns a handle to the new chunk, or 0 if unsuccessful.</p>
<h4>
  <a name="1016489"> </a>Comments 
</h4>

<p><a name="1016490"> </a>Use this call to allocate dynamic memory. Before you can write data to the memory chunk that <code>MemHandleNew</code> allocates, you must call <a href="MemoryManager.html#1016446"><code>MemHandleLock()</code></a> to lock the chunk and get a pointer to it. </p>
<h4>
  <a name="1016494"> </a>See Also 
</h4>

<p><a name="1016504"> </a><a href="MemoryManager.html#1017137"><code>MemPtrFree()</code></a>, <a href="MemoryManager.html#1017176"><code>MemPtrNew()</code></a>, <a href="MemoryManager.html#1016400"><code>MemHandleFree()</code></a>, <a href="MemoryManager.html#1016446"><code>MemHandleLock()</code></a></p>

<h3 class="hbH3">
  <a name="1016510"> </a>MemHandleResize Function <a href="#1016260"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="1016512"> </a>Purpose 
</h4>

<p><a name="1016513"> </a>Resize a chunk.</p>
<h4>
  <a name="1016514"> </a>Declared In 
</h4>
<code>MemoryMgr.h<a name="1016515"> </a></code><h4>
  <a name="1016516"> </a>Prototype 
</h4>
<pre class="proto"><a name="1016518"></a>Err MemHandleResize (
   MemHandle h,
   UInt32 newSize
)
</pre>
<h4>
  <a name="1016519"> </a>Parameters 
</h4>

<dl>
<dt><a name="1016520"> </a><code>&rarr;  <i><code>h</code></i></code></dt>
<dd><a name="1016521"> </a>Chunk handle.</dd>

<dt><a name="1016522"> </a><code>&rarr;  <i><code>newSize</code></i></code></dt>
<dd><a name="1016523"> </a>The new desired size.</dd>

</dl>
<h4>
  <a name="1016524"> </a>Returns 
</h4>

<dl>
<dt><a name="1016525"> </a><code>0</code></dt>
<dd><a name="1016526"> </a>No error.</dd>

<dt><a name="1016528"> </a><code><code>memErrInvalidParam</code></code></dt>
<dd><a name="1016529"> </a>Invalid parameter passed.</dd>

<dt><a name="1016531"> </a><code><code>memErrNotEnoughSpace</code></code></dt>
<dd><a name="1016532"> </a>Not enough free space in heap to grow chunk.</dd>

<dt><a name="1016534"> </a><code><code>memErrChunkLocked</code></code></dt>
<dd><a name="1016535"> </a>Can't grow chunk because it's locked. </dd>

</dl>
<h4>
  <a name="1016536"> </a>Comments 
</h4>

<p><a name="1016537"> </a>Call this routine to resize a chunk. This routine is always successful when shrinking the size of a chunk, even if the chunk is locked. When growing a chunk, it first attempts to grab free space immediately following the chunk so that the chunk does not have to move. If the chunk has to move to another free area of the heap to grow, it must be movable and have a lock count of 0. </p>

<p><a name="1016538"> </a>On devices running version 2.0 or earlier of Palm OS, the <code>MemHandleResize</code> function tries to resize the chunk only within the same heap, whereas <a href="DataAndResourceManager.html#1011281"><code>DmResizeRecord()</code></a> will look for space in other data heaps if it can't find enough space in the original heap. </p>
<h4>
  <a name="1016542"> </a>See Also 
</h4>

<p><a name="1016549"> </a><a href="MemoryManager.html#1016474"><code>MemHandleNew()</code></a>, <a href="MemoryManager.html#1016582"><code>MemHandleSize()</code></a></p>

<h3 class="hbH3">
  <a name="1016553"> </a>MemHandleSetOwner Function <a href="#1016260"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="1016555"> </a>Purpose 
</h4>

<p><a name="1016556"> </a>Set the owner ID of a chunk.</p>
<h4>
  <a name="1016557"> </a>Declared In 
</h4>
<code>MemoryMgr.h<a name="1016558"> </a></code><h4>
  <a name="1016559"> </a>Prototype 
</h4>
<pre class="proto"><a name="1016561"></a>Err MemHandleSetOwner (
   MemHandle h,
   UInt16 owner
)
</pre>
<h4>
  <a name="1016562"> </a>Parameters 
</h4>

<dl>
<dt><a name="1016563"> </a><code>&rarr;  <i><code>h</code></i></code></dt>
<dd><a name="1016564"> </a>Chunk handle.</dd>

<dt><a name="1016565"> </a><code>&rarr;  <i><code>owner</code></i></code></dt>
<dd><a name="1016566"> </a>New owner ID of the chunk. Specify 0 to set the owner to the operating system.</dd>

</dl>
<h4>
  <a name="1016567"> </a>Returns 
</h4>

<p><a name="1016568"> </a>Returns 0 if no error, or <code>memErrInvalidParam</code> if an error occurs.</p>
<h4>
  <a name="1016569"> </a>Comments 
</h4>

<p><a name="1016570"> </a>When you allocate a parameter block to pass to <a href="SystemManager.html#1076980"><code>SysUIAppSwitch()</code></a> or <a href="SystemManager.html#1075905"><code>SysAppLaunch()</code></a>, you must call <a href="MemoryManager.html#1017249"><code>MemPtrSetOwner()</code></a> to grant ownership of the parameter block chunk to the OS (your application is originally set as the owner). If the parameter block structure references any chunks by handle, you also must call <code>MemHandleSetOwner</code> to grant ownership of those blocks to the OS. If you don't change the ownership of these chunks, they will get freed before the application you're launching has a chance to use them.</p>

<div><hr>
  <a name="1043013"> </a> <b>IMPORTANT: </b> Once you have granted ownership of a memory chunk to the system, do not attempt to free it yourself. The operating system will free it when the application invoked with <code>SysUIAppSwitch()</code> or <code>SysAppLaunch()</code> quits.
<hr>
</div>

<h3 class="hbH3">
  <a name="1016582"> </a>MemHandleSize Function <a href="#1016260"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="1016584"> </a>Purpose 
</h4>

<p><a name="1016586"> </a>Return the requested size of a chunk.</p>
<h4>
  <a name="1016587"> </a>Declared In 
</h4>
<code>MemoryMgr.h<a name="1016588"> </a></code><h4>
  <a name="1016589"> </a>Prototype 
</h4>
<pre class="proto"><a name="1016591"></a>UInt32 MemHandleSize (
   MemHandle h
)
</pre>
<h4>
  <a name="1016592"> </a>Parameters 
</h4>

<dl>
<dt><a name="1016593"> </a><code>&rarr;  <i><code>h</code></i></code></dt>
<dd><a name="1016594"> </a>Chunk handle.</dd>

</dl>
<h4>
  <a name="1016595"> </a>Returns 
</h4>

<p><a name="1016596"> </a>Returns the requested size of the chunk.</p>
<h4>
  <a name="1016597"> </a>Comments 
</h4>

<p><a name="1016598"> </a>Call this routine to get the size originally requested for a chunk.</p>
<h4>
  <a name="1016599"> </a>See Also 
</h4>

<p><a name="1016603"> </a><a href="MemoryManager.html#1016510"><code>MemHandleResize()</code></a></p>

<h3 class="hbH3">
  <a name="1016606"> </a>MemHandleToLocalID Function <a href="#1016260"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="1016608"> </a>Purpose 
</h4>

<p><a name="1016609"> </a>Convert a handle into a local chunk ID which is card relative.</p>
<h4>
  <a name="1016610"> </a>Declared In 
</h4>
<code>MemoryMgr.h<a name="1016611"> </a></code><h4>
  <a name="1016612"> </a>Prototype 
</h4>
<pre class="proto"><a name="1016614"></a>LocalID MemHandleToLocalID (
   MemHandle h
)
</pre>
<h4>
  <a name="1016615"> </a>Parameters 
</h4>

<dl>
<dt><a name="1016616"> </a><code>&rarr;  <i><code>h</code></i></code></dt>
<dd><a name="1016617"> </a>Chunk handle.</dd>

</dl>
<h4>
  <a name="1016618"> </a>Returns 
</h4>

<p><a name="1016619"> </a>Returns local ID, or NULL (0) if unsuccessful.</p>
<h4>
  <a name="1016620"> </a>Comments 
</h4>

<p><a name="1016622"> </a>Call this routine to convert a chunk handle to a local ID.</p>
<h4>
  <a name="1016623"> </a>See Also 
</h4>

<p><a name="1016630"> </a><a href="MemoryManager.html#1016904"><code>MemLocalIDToGlobal()</code></a>, <a href="MemoryManager.html#1016931"><code>MemLocalIDToLockedPtr()</code></a></p>

<h3 class="hbH3">
  <a name="1016633"> </a>MemHandleUnlock Function <a href="#1016260"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="1016635"> </a>Purpose 
</h4>

<p><a name="1016637"> </a>Unlock a chunk given a chunk handle.</p>
<h4>
  <a name="1016638"> </a>Declared In 
</h4>
<code>MemoryMgr.h<a name="1016639"> </a></code><h4>
  <a name="1016640"> </a>Prototype 
</h4>
<pre class="proto"><a name="1016642"></a>Err MemHandleUnlock (
   MemHandle h
)
</pre>
<h4>
  <a name="1016643"> </a>Parameters 
</h4>

<dl>
<dt><a name="1016644"> </a><code>&rarr;  <i><code>h</code></i></code></dt>
<dd><a name="1016645"> </a>The chunk handle.</dd>

</dl>
<h4>
  <a name="1016646"> </a>Returns 
</h4>

<dl>
<dt><a name="1016647"> </a><code>0</code></dt>
<dd><a name="1016648"> </a>No error.</dd>

<dt><a name="1016650"> </a><code><code>memErrInvalidParam</code></code></dt>
<dd><a name="1016651"> </a>Invalid parameter passed.</dd>

</dl>
<h4>
  <a name="1016652"> </a>Comments 
</h4>

<p><a name="1016653"> </a>Call this routine to decrement the lock count for a chunk. </p>

<p><a name="1016654"> </a><code>MemHandleLock</code> and <code>MemHandleUnlock</code> should be used in pairs.</p>
<h4>
  <a name="1016655"> </a>See Also 
</h4>

<p><a name="1016659"> </a><a href="MemoryManager.html#1016446"><code>MemHandleLock()</code></a> </p>

<h3 class="hbH3">
  <a name="1016662"> </a>MemHeapCheck Function <a href="#1016260"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="1016664"> </a>Purpose 
</h4>

<p><a name="1016665"> </a>Check validity of a given heap.</p>
<h4>
  <a name="1016666"> </a>Declared In 
</h4>
<code>MemoryMgr.h<a name="1016667"> </a></code><h4>
  <a name="1016668"> </a>Prototype 
</h4>
<pre class="proto"><a name="1016670"></a>Err MemHeapCheck (
   UInt16 heapID
)
</pre>
<h4>
  <a name="1016671"> </a>Parameters 
</h4>

<dl>
<dt><a name="1016672"> </a><code><code>heapID</code></code></dt>
<dd><a name="1016673"> </a>ID of heap to check.</dd>

</dl>
<h4>
  <a name="1016674"> </a>Returns 
</h4>

<p><a name="1016675"> </a>Returns 0 if no error. </p>
<h4>
  <a name="1016676"> </a>See Also 
</h4>

<p><a name="1016683"> </a><a href="MemoryManager.html#1016334"><code>MemDebugMode()</code></a>, <a href="MemoryManager.html#1017372"><code>MemSetDebugMode()</code></a></p>

<h3 class="hbH3">
  <a name="1016686"> </a>MemHeapCompact Function <a href="#1016260"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="1016688"> </a>Purpose 
</h4>

<p><a name="1016689"> </a>Compact a heap.</p>
<h4>
  <a name="1016690"> </a>Declared In 
</h4>
<code>MemoryMgr.h<a name="1016691"> </a></code><h4>
  <a name="1016692"> </a>Prototype 
</h4>
<pre class="proto"><a name="1016694"></a>Err MemHeapCompact (
   UInt16 heapID
)
</pre>
<h4>
  <a name="1016695"> </a>Parameters 
</h4>

<dl>
<dt><a name="1016696"> </a><code>&rarr;  <i><code>heapID</code></i></code></dt>
<dd><a name="1016697"> </a>ID of the heap to compact.</dd>

</dl>
<h4>
  <a name="1016698"> </a>Returns 
</h4>

<p><a name="1016699"> </a>Always returns 0.</p>
<h4>
  <a name="1016700"> </a>Comments 
</h4>

<p><a name="1016701"> </a>Most applications never need to call this function explicitly. The system software calls this function at various times; for example, during memory allocation (if sufficient free space is not available) and during system reboot.</p>

<p><a name="1016703"> </a>Call this routine to compact a heap and merge all free space. This routine attempts to move all movable chunks to the start of the heap and merge all free space in the center of the heap.</p>

<h3 class="hbH3">
  <a name="1016706"> </a>MemHeapDynamic Function <a href="#1016260"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="1016708"> </a>Purpose 
</h4>

<p><a name="1016710"> </a>Return <code>true</code> if the given heap is a dynamic heap.</p>
<h4>
  <a name="1016711"> </a>Declared In 
</h4>
<code>MemoryMgr.h<a name="1016712"> </a></code><h4>
  <a name="1016713"> </a>Prototype 
</h4>
<pre class="proto"><a name="1016715"></a>Boolean MemHeapDynamic (
   UInt16 heapID
) 
</pre>
<h4>
  <a name="1016716"> </a>Parameters 
</h4>

<dl>
<dt><a name="1016717"> </a><code><code>heapID</code> </code></dt>
<dd><a name="1016718"> </a>ID of the heap to be tested.</dd>

</dl>
<h4>
  <a name="1016719"> </a>Returns 
</h4>

<p><a name="1016720"> </a>Returns <code>true</code> if dynamic, <code>false</code> if not.</p>
<h4>
  <a name="1016721"> </a>Comments 
</h4>

<p><a name="1016722"> </a>Dynamic heaps are used for volatile storage, application stacks, globals, and dynamically allocated memory. </p>

<div><hr>
  <a name="1016723"> </a> <b>NOTE: </b> In Palm OS 3.5, the dynamic heap is sized based on the amount of memory available, and is generally larger than before.
<hr>
</div>
<h4>
  <a name="1016724"> </a>See Also 
</h4>

<p><a name="1016731"> </a><a href="MemoryManager.html#1017040"><code>MemNumHeaps()</code></a>, <a href="MemoryManager.html#1016804"><code>MemHeapID()</code></a></p>

<h3 class="hbH3">
  <a name="1016734"> </a>MemHeapFlags Function <a href="#1016260"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="1016736"> </a>Purpose 
</h4>

<p><a name="1016737"> </a>Return the heap flags for a heap.</p>
<h4>
  <a name="1016738"> </a>Declared In 
</h4>
<code>MemoryMgr.h<a name="1016739"> </a></code><h4>
  <a name="1016740"> </a>Prototype 
</h4>
<pre class="proto"><a name="1016742"></a>UInt16 MemHeapFlags (
   UInt16 heapID
)
</pre>
<h4>
  <a name="1016743"> </a>Parameters 
</h4>

<dl>
<dt><a name="1016744"> </a><code>&rarr;  <i><code>heapID</code></i></code></dt>
<dd><a name="1016745"> </a>ID of heap.</dd>

</dl>
<h4>
  <a name="1016746"> </a>Returns 
</h4>

<p><a name="1016747"> </a>Returns the heap flags.</p>
<h4>
  <a name="1016748"> </a>Comments 
</h4>

<p><a name="1016749"> </a>Call this routine to retrieve the heap flags for a heap. The flags can be examined to determine if the heap is ROM based or not. ROM-based heaps have the <code>memHeapFlagReadOnly</code> bit set (the <code>memHeapFlagReadOnly</code> mask has a value of <code>0x0001</code>).</p>
<h4>
  <a name="1016751"> </a>See Also 
</h4>

<p><a name="1016758"> </a><a href="MemoryManager.html#1017040"><code>MemNumHeaps()</code></a>, <a href="MemoryManager.html#1016804"><code>MemHeapID()</code></a></p>

<h3 class="hbH3">
  <a name="1016761"> </a>MemHeapFreeBytes Function <a href="#1016260"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="1016763"> </a>Purpose 
</h4>

<p><a name="1016764"> </a>Return the total number of free bytes in a heap and the size of the largest free chunk in the heap.</p>
<h4>
  <a name="1016766"> </a>Declared In 
</h4>
<code>MemoryMgr.h<a name="1016767"> </a></code><h4>
  <a name="1016768"> </a>Prototype 
</h4>
<pre class="proto"><a name="1016770"></a>Err MemHeapFreeBytes (
   UInt16 heapID,
   UInt32 *freeP,
   UInt32 *maxP
)
</pre>
<h4>
  <a name="1016771"> </a>Parameters 
</h4>

<dl>
<dt><a name="1016772"> </a><code>&rarr;  <i><code>heapID</code></i></code></dt>
<dd><a name="1016773"> </a>ID of heap.</dd>

<dt><a name="1016774"> </a><code>&harr;  <i><code>freeP</code></i></code></dt>
<dd><a name="1016775"> </a>Pointer to a variable of type <code>UInt32</code> for free bytes.</dd>

<dt><a name="1016776"> </a><code>&harr;  <i><code>maxP</code></i></code></dt>
<dd><a name="1016777"> </a>Pointer to a variable of type <code>UInt32</code> for max free chunk size. Do not pass <code>NULL</code> for this argument. </dd>

</dl>
<h4>
  <a name="1016778"> </a>Returns 
</h4>

<p><a name="1016779"> </a>Always returns 0.</p>
<h4>
  <a name="1016780"> </a>Comments 
</h4>

<p><a name="1016781"> </a>This routine doesn't compact the heap but may be used to determine in advance whether an allocation request will succeed. Before allocating memory, call this function and test the value returned in maxP to determine whether enough free space to fulfill your allocation request exists. If not, you may make more space available by calling the <a href="MemoryManager.html#1016686"><code>MemHeapCompact()</code></a> function. Note that both <a href="MemoryManager.html#1017176"><code>MemPtrNew()</code></a> and <a href="MemoryManager.html#1016474"><code>MemHandleNew()</code></a> automatically compact the heap if necessary.</p>
<h4>
  <a name="1016791"> </a>See Also 
</h4>

<p><a name="1016801"> </a><a href="MemoryManager.html#1016862"><code>MemHeapSize()</code></a>, <a href="MemoryManager.html#1016804"><code>MemHeapID()</code></a>, <a href="MemoryManager.html#1016686"><code>MemHeapCompact()</code></a></p>

<h3 class="hbH3">
  <a name="1016804"> </a>MemHeapID Function <a href="#1016260"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="1016806"> </a>Purpose 
</h4>

<p><a name="1016807"> </a>Return the heap ID for a heap, given its index and the card number.</p>
<h4>
  <a name="1016808"> </a>Declared In 
</h4>
<code>MemoryMgr.h<a name="1016809"> </a></code><h4>
  <a name="1016810"> </a>Prototype 
</h4>
<pre class="proto"><a name="1016812"></a>UInt16 MemHeapID (
   UInt16 cardNo,
   UInt16 heapIndex
)
</pre>
<h4>
  <a name="1016813"> </a>Parameters 
</h4>

<dl>
<dt><a name="1016814"> </a><code>&rarr;  <i><code>cardNo</code></i></code></dt>
<dd><a name="1016815"> </a>The card number, either 0 or 1.</dd>

<dt><a name="1016816"> </a><code>&rarr;  <i><code>heapIndex</code></i></code></dt>
<dd><a name="1016821"> </a>The heap index, anywhere from 0 to <a href="MemoryManager.html#1017040"><code>MemNumHeaps()</code></a> - 1.</dd>

</dl>
<h4>
  <a name="1016822"> </a>Returns 
</h4>

<p><a name="1016823"> </a>Returns the heap ID.</p>
<h4>
  <a name="1016824"> </a>Comments 
</h4>

<p><a name="1016826"> </a>Call this routine to retrieve the heap ID of a heap, given the heap index and the card number. A heap ID must be used to obtain information on a heap such as its size, free bytes, etc., and is also passed to any routines which manipulate heaps.</p>
<h4>
  <a name="1016827"> </a>See Also 
</h4>

<p><a name="1016831"> </a><a href="MemoryManager.html#1017040"><code>MemNumHeaps()</code></a> </p>

<h3 class="hbH3">
  <a name="1016834"> </a>MemHeapScramble Function <a href="#1016260"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="1016836"> </a>Purpose 
</h4>

<p><a name="1016837"> </a>Scramble the specified heap. </p>
<h4>
  <a name="1016838"> </a>Declared In 
</h4>
<code>MemoryMgr.h<a name="1016839"> </a></code><h4>
  <a name="1016840"> </a>Prototype 
</h4>
<pre class="proto"><a name="1016842"></a>Err MemHeapScramble (
   UInt16 heapID
)
</pre>
<h4>
  <a name="1016843"> </a>Parameters 
</h4>

<dl>
<dt><a name="1016844"> </a><code><code>heapID</code></code></dt>
<dd><a name="1016845"> </a>ID of heap to scramble.</dd>

</dl>
<h4>
  <a name="1016846"> </a>Comments 
</h4>

<p><a name="1016847"> </a>The system attempts to move each movable chunk.</p>

<p><a name="1016849"> </a>Useful for debugging.</p>
<h4>
  <a name="1016850"> </a>Returns 
</h4>

<p><a name="1016851"> </a>Always returns 0.</p>
<h4>
  <a name="1016852"> </a>See Also 
</h4>

<p><a name="1016859"> </a><a href="MemoryManager.html#1016334"><code>MemDebugMode()</code></a>, <a href="MemoryManager.html#1017372"><code>MemSetDebugMode()</code></a></p>

<h3 class="hbH3">
  <a name="1016862"> </a>MemHeapSize Function <a href="#1016260"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="1016864"> </a>Purpose 
</h4>

<p><a name="1016865"> </a>Return the total size of a heap including the heap header.</p>
<h4>
  <a name="1016866"> </a>Declared In 
</h4>
<code>MemoryMgr.h<a name="1016867"> </a></code><h4>
  <a name="1016868"> </a>Prototype 
</h4>
<pre class="proto"><a name="1016870"></a>UInt32 MemHeapSize (
   UInt16 heapID
)
</pre>
<h4>
  <a name="1016871"> </a>Parameters 
</h4>

<dl>
<dt><a name="1016872"> </a><code>&rarr;  <i><code>heapID</code></i></code></dt>
<dd><a name="1016873"> </a>ID of heap.</dd>

</dl>
<h4>
  <a name="1016874"> </a>Returns 
</h4>

<p><a name="1016875"> </a>Returns the total size of the heap.</p>
<h4>
  <a name="1016876"> </a>See Also 
</h4>

<p><a name="1016883"> </a><a href="MemoryManager.html#1016761"><code>MemHeapFreeBytes()</code></a>, <a href="MemoryManager.html#1016804"><code>MemHeapID()</code></a></p>

<h3 class="hbH3">
  <a name="1016886"> </a>MemLocalIDKind Function <a href="#1016260"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="1016888"> </a>Purpose 
</h4>

<p><a name="1016889"> </a>Return whether or not a local ID references a handle or a pointer.</p>
<h4>
  <a name="1016890"> </a>Declared In 
</h4>
<code>MemoryMgr.h<a name="1016891"> </a></code><h4>
  <a name="1016892"> </a>Prototype 
</h4>
<pre class="proto"><a name="1016894"></a>LocalIDKind MemLocalIDKind (
   LocalID local
)
</pre>
<h4>
  <a name="1016895"> </a>Parameters 
</h4>

<dl>
<dt><a name="1016896"> </a><code>&rarr;  <i><code>local</code></i></code></dt>
<dd><a name="1016897"> </a>Local ID to query</dd>

</dl>
<h4>
  <a name="1016898"> </a>Returns 
</h4>

<p><a name="1016899"> </a>Returns <code>LocalIDKind</code>, or a <code>memIDHandle</code> or <code>memIDPtr</code> (see <code>MemoryMgr.h</code>).</p>
<h4>
  <a name="1016900"> </a>Comments 
</h4>

<p><a name="1016901"> </a>This routine determines if the given local ID is to a nonmovable (<code>memIDPtr</code>) or movable (<code>memIDHandle</code>) chunk. </p>

<h3 class="hbH3">
  <a name="1016904"> </a>MemLocalIDToGlobal Function <a href="#1016260"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="1016906"> </a>Purpose 
</h4>

<p><a name="1016908"> </a>Convert a local ID, which is card relative, into a global pointer in the designated card.</p>
<h4>
  <a name="1016909"> </a>Declared In 
</h4>
<code>MemoryMgr.h<a name="1016910"> </a></code><h4>
  <a name="1016911"> </a>Prototype 
</h4>
<pre class="proto"><a name="1016913"></a>MemPtr MemLocalIDToGlobal (
   LocalID local,
   UInt16 cardNo
)
</pre>
<h4>
  <a name="1016914"> </a>Parameters 
</h4>

<dl>
<dt><a name="1016915"> </a><code>&rarr;  <i><code>local</code></i></code></dt>
<dd><a name="1016916"> </a>The local ID to convert.</dd>

<dt><a name="1016917"> </a><code>&rarr;  <i><code>cardNo</code></i></code></dt>
<dd><a name="1016918"> </a>Memory card the chunk resides in.</dd>

</dl>
<h4>
  <a name="1016919"> </a>Returns 
</h4>

<p><a name="1016920"> </a>Returns pointer or handle to chunk.</p>
<h4>
  <a name="1016921"> </a>See Also 
</h4>

<p><a name="1016928"> </a><a href="MemoryManager.html#1016886"><code>MemLocalIDKind()</code></a>, <a href="MemoryManager.html#1016931"><code>MemLocalIDToLockedPtr()</code></a></p>

<h3 class="hbH3">
  <a name="1016931"> </a>MemLocalIDToLockedPtr Function <a href="#1016260"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="1016933"> </a>Purpose 
</h4>

<p><a name="1016934"> </a>Return a pointer to a chunk given its local ID and card number.</p>

<p><a name="1016935"> </a>If the local ID references a movable chunk handle, this routine automatically locks the chunk before returning.</p>
<h4>
  <a name="1016936"> </a>Declared In 
</h4>
<code>MemoryMgr.h<a name="1016937"> </a></code><h4>
  <a name="1016938"> </a>Prototype 
</h4>
<pre class="proto"><a name="1016940"></a>MemPtr MemLocalIDToLockedPtr (
   LocalID local,
   UInt16 cardNo
)
</pre>
<h4>
  <a name="1016941"> </a>Parameters 
</h4>

<dl>
<dt><a name="1016942"> </a><code><code>local</code></code></dt>
<dd><a name="1016943"> </a>Local chunk ID. </dd>

<dt><a name="1016944"> </a><code><code>cardNo</code></code></dt>
<dd><a name="1016945"> </a>Card number.</dd>

</dl>
<h4>
  <a name="1016946"> </a>Returns 
</h4>

<p><a name="1016947"> </a>Returns pointer to chunk, or 0 if an error occurs.</p>
<h4>
  <a name="1016948"> </a>See Also 
</h4>

<p><a name="1016955"> </a><a href="MemoryManager.html#1016904"><code>MemLocalIDToGlobal()</code></a>, <a href="MemoryManager.html#1016967"><code>MemLocalIDToPtr()</code></a>, <a href="MemoryManager.html#1016886"><code>MemLocalIDKind()</code></a>, <a href="MemoryManager.html#1017296"><code>MemPtrToLocalID()</code></a>, <a href="MemoryManager.html#1016606"><code>MemHandleToLocalID()</code></a></p>

<h3 class="hbH3">
  <a name="1016967"> </a>MemLocalIDToPtr Function <a href="#1016260"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="1016969"> </a>Purpose 
</h4>

<p><a name="1016970"> </a>Return pointer to chunk, given the local ID and card number.</p>
<h4>
  <a name="1016971"> </a>Declared In 
</h4>
<code>MemoryMgr.h<a name="1016972"> </a></code><h4>
  <a name="1016973"> </a>Prototype 
</h4>
<pre class="proto"><a name="1016975"></a>MemPtr MemLocalIDToPtr (
   LocalID local,
   UInt16 cardNo
)
</pre>
<h4>
  <a name="1016976"> </a>Parameters 
</h4>

<dl>
<dt><a name="1016977"> </a><code>&rarr;  <i><code>local</code></i></code></dt>
<dd><a name="1016978"> </a>Local ID to query.</dd>

<dt><a name="1016979"> </a><code>&rarr;  <i><code>cardNo</code></i></code></dt>
<dd><a name="1016980"> </a>Card number the chunk resides in.</dd>

</dl>
<h4>
  <a name="1016981"> </a>Returns 
</h4>

<p><a name="1016982"> </a>Returns a pointer to the chunk, or 0 if error.</p>
<h4>
  <a name="1016983"> </a>Comments 
</h4>

<p><a name="1016984"> </a>If the local ID references a movable chunk and that chunk is <span style="color: #000000;  font-style: normal; font-weight: bold; text-decoration: none; text-transform: none; vertical-align: baseline">not</span> locked, this function returns 0 to indicate an error.</p>
<h4>
  <a name="1016985"> </a>See Also 
</h4>

<p><a name="1016992"> </a><a href="MemoryManager.html#1016904"><code>MemLocalIDToGlobal()</code></a>, <a href="MemoryManager.html#1016931"><code>MemLocalIDToLockedPtr()</code></a></p>

<h3 class="hbH3">
  <a name="1016995"> </a>MemMove Function <a href="#1016260"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="1016997"> </a>Purpose 
</h4>

<p><a name="1016999"> </a>Copy a number of bytes from one location to another in the dynamic heap. </p>
<h4>
  <a name="1017000"> </a>Declared In 
</h4>
<code>MemoryMgr.h<a name="1017001"> </a></code><h4>
  <a name="1017002"> </a>Prototype 
</h4>
<pre class="proto"><a name="1017004"></a>Err MemMove (
   void *destP,
   const void *sourceP,
   Int32 numBytes
)
</pre>
<h4>
  <a name="1017005"> </a>Parameters 
</h4>

<dl>
<dt><a name="1017006"> </a><code><code>destP</code></code></dt>
<dd><a name="1017007"> </a>Pointer to destination.</dd>

<dt><a name="1017008"> </a><code><code>sourceP</code></code></dt>
<dd><a name="1017009"> </a>Pointer to source.</dd>

<dt><a name="1017010"> </a><code><code>numBytes</code></code></dt>
<dd><a name="1017011"> </a>Number of bytes to move.</dd>

</dl>
<h4>
  <a name="1017012"> </a>Returns 
</h4>

<p><a name="1017013"> </a>Always returns 0.</p>
<h4>
  <a name="1017014"> </a>Comments 
</h4>

<p><a name="1017015"> </a>Like the ISO C libary call <code>memmove</code>, this function copies <i>numBytes</i> bytes from the object pointed to by <i>sourceP</i> into the object pointed to by <i>destP</i>. The source and destination may overlap; the copy is always done in a non-destructive manner.</p>

<p><a name="1017016"> </a>For operations where the destination is in a data heap, see <a href="DataAndResourceManager.html#1011500"><code>DmSet()</code></a>, <a href="DataAndResourceManager.html#1052867"><code>DmWrite()</code></a>, and related functions.</p>

<h3 class="hbH3">
  <a name="1017025"> </a>MemNumCards Function <a href="#1016260"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="1017027"> </a>Purpose 
</h4>

<p><a name="1017028"> </a>Return the number of memory card slots in the system. Not all slots need to be populated.</p>
<h4>
  <a name="1017029"> </a>Declared In 
</h4>
<code>MemoryMgr.h<a name="1017030"> </a></code><h4>
  <a name="1017031"> </a>Prototype 
</h4>
<pre class="proto"><a name="1017033"></a>UInt16 MemNumCards (
   void
)
</pre>
<h4>
  <a name="1017034"> </a>Parameters 
</h4>

<p><a name="1017035"> </a>None.</p>
<h4>
  <a name="1017036"> </a>Returns 
</h4>

<p><a name="1017037"> </a>Returns number of slots in the system.</p>

<h3 class="hbH3">
  <a name="1017040"> </a>MemNumHeaps Function <a href="#1016260"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="1017042"> </a>Purpose 
</h4>

<p><a name="1017043"> </a>Return the number of heaps available on a particular card.</p>
<h4>
  <a name="1017044"> </a>Declared In 
</h4>
<code>MemoryMgr.h<a name="1017045"> </a></code><h4>
  <a name="1017046"> </a>Prototype 
</h4>
<pre class="proto"><a name="1017048"></a>UInt16 MemNumHeaps (
   UInt16 cardNo
)
</pre>
<h4>
  <a name="1017049"> </a>Parameters 
</h4>

<dl>
<dt><a name="1017050"> </a><code>&rarr;  <i><code>cardNo</code></i></code></dt>
<dd><a name="1017051"> </a>The card number; either 0 or 1.</dd>

</dl>
<h4>
  <a name="1017052"> </a>Returns 
</h4>

<p><a name="1017054"> </a>Number of heaps available, including ROM- and RAM-based heaps.</p>
<h4>
  <a name="1017055"> </a>Comments 
</h4>

<p><a name="1017056"> </a>Call this routine to retrieve the total number of heaps on a memory card. The information can be obtained by calling <a href="MemoryManager.html#1016862"><code>MemHeapSize()</code></a>, <a href="MemoryManager.html#1016761"><code>MemHeapFreeBytes()</code></a>, and <a href="MemoryManager.html#1016734"><code>MemHeapFlags()</code></a> on each heap using its heap ID. The heap ID is obtained by calling <a href="MemoryManager.html#1016804"><code>MemHeapID()</code></a> with the card number and the heap index, which can be any value from 0 to <code>MemNumHeaps</code>.</p>

<h3 class="hbH3">
  <a name="1017071"> </a>MemNumRAMHeaps Function <a href="#1016260"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="1017073"> </a>Purpose 
</h4>

<p><a name="1017074"> </a>Return the number of RAM heaps in the given card.</p>
<h4>
  <a name="1017075"> </a>Declared In 
</h4>
<code>MemoryMgr.h<a name="1017076"> </a></code><h4>
  <a name="1017077"> </a>Prototype 
</h4>
<pre class="proto"><a name="1017079"></a>UInt16 MemNumRAMHeaps (
   UInt16 cardNo
)
</pre>
<h4>
  <a name="1017080"> </a>Parameters 
</h4>

<dl>
<dt><a name="1017081"> </a><code><code>cardNo</code></code></dt>
<dd><a name="1017082"> </a>The card number.</dd>

</dl>
<h4>
  <a name="1017083"> </a>Returns 
</h4>

<p><a name="1017084"> </a>Returns the number of RAM heaps.</p>
<h4>
  <a name="1017085"> </a>See Also 
</h4>

<p><a name="1017089"> </a><a href="MemoryManager.html#1017025"><code>MemNumCards()</code></a> </p>

<h3 class="hbH3">
  <a name="1017092"> </a>MemPtrCardNo Function <a href="#1016260"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="1017094"> </a>Purpose 
</h4>

<p><a name="1017095"> </a>Return the card number (0 or 1) a nonmovable chunk resides on.</p>
<h4>
  <a name="1017096"> </a>Declared In 
</h4>
<code>MemoryMgr.h<a name="1017097"> </a></code><h4>
  <a name="1017098"> </a>Prototype 
</h4>
<pre class="proto"><a name="1017100"></a>UInt16 MemPtrCardNo (
   MemPtr p
)
</pre>
<h4>
  <a name="1017101"> </a>Parameters 
</h4>

<dl>
<dt><a name="1017102"> </a><code>&rarr;  <i><code>p</code></i></code></dt>
<dd><a name="1017103"> </a>Pointer to the chunk.</dd>

</dl>
<h4>
  <a name="1017104"> </a>Returns 
</h4>

<p><a name="1017105"> </a>Returns the card number.</p>
<h4>
  <a name="1017106"> </a>See Also 
</h4>

<p><a name="1017110"> </a><a href="MemoryManager.html#1016352"><code>MemHandleCardNo()</code></a> </p>

<h3 class="hbH3">
  <a name="1017113"> </a>MemPtrDataStorage Function <a href="#1016260"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="1017115"> </a>Purpose 
</h4>

<p><a name="1017116"> </a>Return <code>true</code> if the given pointer is part of a data storage heap; if not, it is a pointer in the dynamic heap.</p>
<h4>
  <a name="1017117"> </a>Declared In 
</h4>
<code>MemoryMgr.h<a name="1017118"> </a></code><h4>
  <a name="1017119"> </a>Prototype 
</h4>
<pre class="proto"><a name="1017121"></a>Boolean MemPtrDataStorage (
   MemPtr p
)
</pre>
<h4>
  <a name="1017122"> </a>Parameters 
</h4>

<dl>
<dt><a name="1017123"> </a><code><code>p</code></code></dt>
<dd><a name="1017124"> </a>Pointer to a chunk.</dd>

</dl>
<h4>
  <a name="1017125"> </a>Returns 
</h4>

<p><a name="1017127"> </a>Returns <code>true</code> if the chunk is part of a data storage heap.</p>
<h4>
  <a name="1017128"> </a>Comments 
</h4>

<p><a name="1017129"> </a>Called by Fields package to determine if it needs to worry about data storage write-protection when editing a text field.</p>
<h4>
  <a name="1017130"> </a>See Also 
</h4>

<p><a name="1017134"> </a><a href="MemoryManager.html#1016706"><code>MemHeapDynamic()</code></a></p>

<h3 class="hbH3">
  <a name="1017137"> </a>MemPtrFree Macro <a href="#1016260"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="1017139"> </a>Purpose 
</h4>

<p><a name="1017140"> </a>Dispose of a chunk.</p>
<h4>
  <a name="1017141"> </a>Declared In 
</h4>
<code>MemoryMgr.h<a name="1017142"> </a></code><h4>
  <a name="1017143"> </a>Prototype 
</h4>
<pre class="proto"><a name="1017145"></a>#define MemPtrFree (
   p
)
</pre>
<h4>
  <a name="1017146"> </a>Parameters 
</h4>

<dl>
<dt><a name="1017147"> </a><code>&rarr;  <i><code>p</code></i></code></dt>
<dd><a name="1017148"> </a>Pointer to a chunk.</dd>

</dl>
<h4>
  <a name="1017149"> </a>Returns 
</h4>

<dl>
<dt><a name="1017150"> </a><code>0</code></dt>
<dd><a name="1017152"> </a>If no error or <code>memErrInvalidParam</code> (invalid parameter).</dd>

</dl>
<h4>
  <a name="1017153"> </a>Comments 
</h4>

<p><a name="1017154"> </a>Call this routine to dispose of a nonmovable chunk. </p>

<h3 class="hbH3">
  <a name="1017157"> </a>MemPtrHeapID Function <a href="#1016260"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="1017159"> </a>Purpose 
</h4>

<p><a name="1017162"> </a>Return the heap ID of a chunk.</p>
<h4>
  <a name="1017163"> </a>Declared In 
</h4>
<code>MemoryMgr.h<a name="1017164"> </a></code><h4>
  <a name="1017165"> </a>Prototype 
</h4>
<pre class="proto"><a name="1017166"></a>UInt16 MemPtrHeapID (
   MemPtr p
)
</pre>
<h4>
  <a name="1017167"> </a>Parameters 
</h4>

<dl>
<dt><a name="1017168"> </a><code>&rarr;  <i><code>p</code></i></code></dt>
<dd><a name="1017169"> </a>Pointer to the chunk.</dd>

</dl>
<h4>
  <a name="1017170"> </a>Returns 
</h4>

<p><a name="1017171"> </a>Returns the heap ID of a chunk.</p>
<h4>
  <a name="1017172"> </a>Comments 
</h4>

<p><a name="1017173"> </a>Call this routine to get the heap ID of the heap a chunk resides in.</p>

<h3 class="hbH3">
  <a name="1017176"> </a>MemPtrNew Function <a href="#1016260"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="1017178"> </a>Purpose 
</h4>

<p><a name="1017180"> </a>Allocate a new nonmovable chunk in the dynamic heap.</p>
<h4>
  <a name="1017181"> </a>Declared In 
</h4>
<code>MemoryMgr.h<a name="1017182"> </a></code><h4>
  <a name="1017183"> </a>Prototype 
</h4>
<pre class="proto"><a name="1017185"></a>MemPtr MemPtrNew (
   UInt32 size
)
</pre>
<h4>
  <a name="1017186"> </a>Parameters 
</h4>

<dl>
<dt><a name="1017187"> </a><code>&rarr;  <i><code>size</code></i></code></dt>
<dd><a name="1017188"> </a>The desired size of the chunk.</dd>

</dl>
<h4>
  <a name="1017189"> </a>Returns 
</h4>

<p><a name="1017190"> </a>Returns pointer to the new chunk, or 0 if unsuccessful.</p>
<h4>
  <a name="1017191"> </a>Comments 
</h4>

<p><a name="1017192"> </a>This routine allocates a nonmovable chunk in the dynamic heap and returns a pointer to the chunk. Applications can use it when allocating dynamic memory. Note that chunks range in size from 1 byte to slightly less than 64KB; you cannot allocate a single chunk larger than this.</p>

<p><a name="1017193"> </a>In Palm OS 3.5, the dynamic heap is sized based on the amount of memory available, and is generally larger than before.</p>

<div><hr>
  <a name="1017194"> </a> <b>NOTE: </b> You cannot allocate a zero-size reference block.
<hr>
</div>
<h4>
  <a name="1017195"> </a>See Also 
</h4>

<p><a name="1017199"> </a><a href="PalmOSGlueLib.html#1032127"><code>MemGluePtrNew()</code></a></p>

<h3 class="hbH3">
  <a name="1017202"> </a>MemPtrRecoverHandle Function <a href="#1016260"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="1017204"> </a>Purpose 
</h4>

<p><a name="1017205"> </a>Recover the handle of a movable chunk, given a pointer to its data.</p>
<h4>
  <a name="1017206"> </a>Declared In 
</h4>
<code>MemoryMgr.h<a name="1017207"> </a></code><h4>
  <a name="1017208"> </a>Prototype 
</h4>
<pre class="proto"><a name="1017210"></a>MemHandle MemPtrRecoverHandle (
   MemPtr p
)
</pre>
<h4>
  <a name="1017211"> </a>Parameters 
</h4>

<dl>
<dt><a name="1017212"> </a><code>&rarr;  <i><code>p</code></i></code></dt>
<dd><a name="1017213"> </a>Pointer to the chunk.</dd>

</dl>
<h4>
  <a name="1017214"> </a>Returns 
</h4>

<p><a name="1017215"> </a>Returns the handle of the chunk, or 0 if unsuccessful.</p>
<h4>
  <a name="1017216"> </a>Comments 
</h4>

<p><a name="1017217"> </a>Don't call this function for pointers in ROM or nonmovable data chunks.</p>

<h3 class="hbH3">
  <a name="1017220"> </a>MemPtrResize Function <a href="#1016260"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="1017222"> </a>Purpose 
</h4>

<p><a name="1017223"> </a>Resize a chunk.</p>
<h4>
  <a name="1017224"> </a>Declared In 
</h4>
<code>MemoryMgr.h<a name="1017225"> </a></code><h4>
  <a name="1017226"> </a>Prototype 
</h4>
<pre class="proto"><a name="1017228"></a>Err MemPtrResize (
   MemPtr p,
   UInt32 newSize
)
</pre>
<h4>
  <a name="1017229"> </a>Parameters 
</h4>

<dl>
<dt><a name="1017230"> </a><code>&rarr;  <i><code>p</code></i></code></dt>
<dd><a name="1017231"> </a>Pointer to the chunk.</dd>

<dt><a name="1017232"> </a><code>&rarr;  <i><code>newSize</code></i></code></dt>
<dd><a name="1017233"> </a>The new desired size.</dd>

</dl>
<h4>
  <a name="1017234"> </a>Returns 
</h4>

<p><a name="1017235"> </a>Returns 0 if no error, or <code>memErrNotEnoughSpace</code> <code>memErrInvalidParam</code>, or <code>memErrChunkLocked</code> if an error occurs.</p>
<h4>
  <a name="1017236"> </a>Comments 
</h4>

<p><a name="1017237"> </a>Call this routine to resize a locked chunk. This routine is always successful when shrinking the size of a chunk. When growing a chunk, it attempts to use free space immediately following the chunk.</p>
<h4>
  <a name="1017238"> </a>See Also 
</h4>

<p><a name="1017245"> </a><a href="MemoryManager.html#1017278"><code>MemPtrSize()</code></a>, <a href="MemoryManager.html#1016510"><code>MemHandleResize()</code></a> </p>

<h3 class="hbH3">
  <a name="1017249"> </a>MemPtrSetOwner Function <a href="#1016260"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="1017251"> </a>Purpose 
</h4>

<p><a name="1017252"> </a>Set the owner ID of a chunk.</p>
<h4>
  <a name="1017253"> </a>Declared In 
</h4>
<code>MemoryMgr.h<a name="1017254"> </a></code><h4>
  <a name="1017255"> </a>Prototype 
</h4>
<pre class="proto"><a name="1017257"></a>Err MemPtrSetOwner (
   MemPtr p,
   UInt16 owner
)
</pre>
<h4>
  <a name="1017258"> </a>Parameters 
</h4>

<dl>
<dt><a name="1017259"> </a><code>&rarr;  <i><code>p</code></i></code></dt>
<dd><a name="1017260"> </a>Pointer to the chunk.</dd>

<dt><a name="1017261"> </a><code>&rarr;  <i><code>owner</code></i></code></dt>
<dd><a name="1017262"> </a>New owner ID of the chunk. Specify 0 to set the owner to the operating system.</dd>

</dl>
<h4>
  <a name="1017263"> </a>Returns 
</h4>

<p><a name="1017264"> </a>Returns 0 if no error, or <code>memErrInvalidParam</code> if an error occurs.</p>
<h4>
  <a name="1017265"> </a>Comments 
</h4>

<p><a name="1017266"> </a>When you allocate a parameter block to pass to <a href="SystemManager.html#1076980"><code>SysUIAppSwitch()</code></a> or <a href="SystemManager.html#1075905"><code>SysAppLaunch()</code></a>, you must call <code>MemPtrSetOwner()</code> or <a href="MemoryManager.html#1016553"><code>MemHandleSetOwner()</code></a> to grant ownership of the parameter block chunk, and any other chunks referenced in it, to the OS (your application is originally set as the owner). If you don't change the ownership of the parameter block, it will get freed before the application you're launching has a chance to use it.</p>

<div><hr>
  <a name="1042973"> </a> <b>IMPORTANT: </b> Once you have granted ownership of a memory chunk to the system, do not attempt to free it yourself. The operating system will free it when the application invoked with <code>SysUIAppSwitch()</code> or <code>SysAppLaunch()</code> quits.
<hr>
</div>

<h3 class="hbH3">
  <a name="1017278"> </a>MemPtrSize Function <a href="#1016260"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="1017280"> </a>Purpose 
</h4>

<p><a name="1017281"> </a>Return the size of a chunk.</p>
<h4>
  <a name="1017282"> </a>Declared In 
</h4>
<code>MemoryMgr.h<a name="1017283"> </a></code><h4>
  <a name="1017284"> </a>Prototype 
</h4>
<pre class="proto"><a name="1017286"></a>UInt32 MemPtrSize (
   MemPtr p
)
</pre>
<h4>
  <a name="1017287"> </a>Parameters 
</h4>

<dl>
<dt><a name="1017288"> </a><code>&rarr;  <i><code>p</code></i></code></dt>
<dd><a name="1017289"> </a>Pointer to the chunk.</dd>

</dl>
<h4>
  <a name="1017290"> </a>Returns 
</h4>

<p><a name="1017291"> </a>The requested size of the chunk.</p>
<h4>
  <a name="1017292"> </a>Comments 
</h4>

<p><a name="1017293"> </a>Call this routine to get the original requested size of a chunk.</p>

<h3 class="hbH3">
  <a name="1017296"> </a>MemPtrToLocalID Function <a href="#1016260"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="1017298"> </a>Purpose 
</h4>

<p><a name="1017299"> </a>Convert a pointer into a card-relative local chunk ID. </p>
<h4>
  <a name="1017300"> </a>Declared In 
</h4>
<code>MemoryMgr.h<a name="1017301"> </a></code><h4>
  <a name="1017302"> </a>Prototype 
</h4>
<pre class="proto"><a name="1017304"></a>LocalID MemPtrToLocalID (
   MemPtr p
)
</pre>
<h4>
  <a name="1017305"> </a>Parameters 
</h4>

<dl>
<dt><a name="1017306"> </a><code>&rarr;  <i><code>p</code></i></code></dt>
<dd><a name="1017307"> </a>Pointer to a chunk.</dd>

</dl>
<h4>
  <a name="1017308"> </a>Returns 
</h4>

<p><a name="1017309"> </a>Returns the local ID of the chunk.</p>
<h4>
  <a name="1017310"> </a>Comments 
</h4>

<p><a name="1017312"> </a>Call this routine to convert a chunk pointer to a local ID.</p>
<h4>
  <a name="1017313"> </a>See Also 
</h4>

<p><a name="1017317"> </a><a href="MemoryManager.html#1016967"><code>MemLocalIDToPtr()</code></a> </p>

<h3 class="hbH3">
  <a name="1017320"> </a>MemPtrUnlock Function <a href="#1016260"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="1017322"> </a>Purpose 
</h4>

<p><a name="1017323"> </a>Unlock a chunk, given a pointer to the chunk.</p>
<h4>
  <a name="1017324"> </a>Declared In 
</h4>
<code>MemoryMgr.h<a name="1017325"> </a></code><h4>
  <a name="1017326"> </a>Prototype 
</h4>
<pre class="proto"><a name="1017328"></a>Err MemPtrUnlock (
   MemPtr p
)
</pre>
<h4>
  <a name="1017329"> </a>Parameters 
</h4>

<dl>
<dt><a name="1017330"> </a><code><code>p</code></code></dt>
<dd><a name="1017331"> </a>Pointer to a chunk.</dd>

</dl>
<h4>
  <a name="1017332"> </a>Returns 
</h4>

<p><a name="1017333"> </a>0 if no error, or <code>memErrInvalidParam</code> if an error occurs.</p>
<h4>
  <a name="1017334"> </a>Comments 
</h4>

<p><a name="1017336"> </a>A chunk must <span style="color: #000000;  font-style: normal; font-weight: bold; text-decoration: none; text-transform: none; vertical-align: baseline">not</span> be unlocked more times than it was locked. </p>
<h4>
  <a name="1017337"> </a>See Also 
</h4>

<p><a name="1017341"> </a><a href="MemoryManager.html#1016446"><code>MemHandleLock()</code></a> </p>

<h3 class="hbH3">
  <a name="1017344"> </a>MemSet Function <a href="#1016260"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="1017346"> </a>Purpose 
</h4>

<p><a name="1017347"> </a>Set a memory range in a dynamic heap to a specific value.</p>
<h4>
  <a name="1017348"> </a>Declared In 
</h4>
<code>MemoryMgr.h<a name="1017349"> </a></code><h4>
  <a name="1017350"> </a>Prototype 
</h4>
<pre class="proto"><a name="1017352"></a>Err MemSet (
   void *dstP,
   Int32 numBytes,
   UInt8 value
)
</pre>
<h4>
  <a name="1017353"> </a>Parameters 
</h4>

<dl>
<dt><a name="1017354"> </a><code><code>dstP</code></code></dt>
<dd><a name="1017355"> </a>Pointer to the destination.</dd>

<dt><a name="1017356"> </a><code><code>numBytes</code></code></dt>
<dd><a name="1017357"> </a>Number of bytes to set.</dd>

<dt><a name="1017358"> </a><code><code>value</code></code></dt>
<dd><a name="1017359"> </a>Value to set.</dd>

</dl>
<h4>
  <a name="1017360"> </a>Returns 
</h4>

<p><a name="1017361"> </a>Always returns 0.</p>
<h4>
  <a name="1017362"> </a>Comments 
</h4>

<p><a name="1017363"> </a>For operations where the destination is in a data heap, see <a href="DataAndResourceManager.html#1011500"><code>DmSet()</code></a>, <a href="DataAndResourceManager.html#1052867"><code>DmWrite()</code></a>, and related functions.</p>

<h3 class="hbH3">
  <a name="1017372"> </a>MemSetDebugMode Function <a href="#1016260"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="1017374"> </a>Purpose 
</h4>

<p><a name="1017376"> </a>Set the debugging mode of the memory manager.</p>
<h4>
  <a name="1017377"> </a>Declared In 
</h4>
<code>MemoryMgr.h<a name="1017378"> </a></code><h4>
  <a name="1017379"> </a>Prototype 
</h4>
<pre class="proto"><a name="1017381"></a>Err MemSetDebugMode (
   UInt16 flags
)
</pre>
<h4>
  <a name="1017382"> </a>Parameters 
</h4>

<dl>
<dt><a name="1017383"> </a><code><code>flags</code></code></dt>
<dd><a name="1017384"> </a>Debug flags.</dd>

</dl>
<h4>
  <a name="1017385"> </a>Comments 
</h4>

<p><a name="1017386"> </a>Use the logical OR operator (<code>|</code>) to provide any combination of one, more, or none of the following flags:</p>

<p><a name="1017387"> </a><code>memDebugModeCheckOnChange<br>memDebugModeCheckOnAll<br>memDebugModeScrambleOnChange<br>memDebugModeScrambleOnAll<br>memDebugModeFillFree<br>memDebugModeAllHeaps<br>memDebugModeRecordMinDynHeapFree</code></p>
<h4>
  <a name="1017388"> </a>Returns 
</h4>

<p><a name="1017389"> </a>Returns 0 if no error, or -1 if an error occurs.</p>

<h3 class="hbH3">
  <a name="1017392"> </a>MemStoreInfo Function <a href="#1016260"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="1017394"> </a>Purpose 
</h4>

<p><a name="1017395"> </a>Return information on either the RAM store or the ROM store for a memory card.</p>
<h4>
  <a name="1017396"> </a>Declared In 
</h4>
<code>MemoryMgr.h<a name="1017397"> </a></code><h4>
  <a name="1017398"> </a>Prototype 
</h4>
<pre class="proto"><a name="1017400"></a>Err MemStoreInfo (
   UInt16 cardNo,
   UInt16 storeNumber,
   UInt16 *versionP,
   UInt16 *flagsP,
   Char *nameP,
   UInt32 *crDateP,
   UInt32 *bckUpDateP,
   UInt32 *heapListOffsetP,
   UInt32 *initCodeOffset1P,
   UInt32 *initCodeOffset2P,
   LocalID *databaseDirIDP
)
</pre>
<h4>
  <a name="1017401"> </a>Parameters 
</h4>

<dl>
<dt><a name="1017402"> </a><code>&rarr;  <i><code>cardNo</code></i></code></dt>
<dd><a name="1017403"> </a>Card number, either 0 or 1.</dd>

<dt><a name="1017404"> </a><code>&rarr;  <i><code>storeNumber</code></i></code></dt>
<dd><a name="1017405"> </a>Store number; 0 for ROM, 1 for RAM.</dd>

<dt><a name="1017406"> </a><code>&harr;  <i><code>versionP</code></i></code></dt>
<dd><a name="1017407"> </a>Pointer to version variable, or 0.</dd>

<dt><a name="1017408"> </a><code>&harr;  <i><code>flagsP</code></i></code></dt>
<dd><a name="1017409"> </a>Pointer to flags variable, or 0.</dd>

<dt><a name="1017410"> </a><code>&harr;  <i><code>nameP</code></i></code></dt>
<dd><a name="1017411"> </a>Pointer to character array (32 bytes), or 0.</dd>

<dt><a name="1017412"> </a><code>&harr;  <i><code>crDateP</code></i></code></dt>
<dd><a name="1017413"> </a>Pointer to creation date variable, or 0.</dd>

<dt><a name="1017414"> </a><code>&harr;  <i><code>bckUpDateP</code></i></code></dt>
<dd><a name="1017415"> </a>Pointer to backup date variable, or 0.</dd>

<dt><a name="1017416"> </a><code>&harr;  <i><code>heapListOffsetP</code></i></code></dt>
<dd><a name="1017417"> </a>Pointer to <code>heapListOffset</code> variable, or 0.</dd>

<dt><a name="1017418"> </a><code>&harr;  <i><code>initCodeOffset1P</code></i></code></dt>
<dd><a name="1017419"> </a>Pointer to <code>initCodeOffset1</code> variable, or 0.</dd>

<dt><a name="1017420"> </a><code>&harr;  <i><code>initCodeOffset2P</code></i></code></dt>
<dd><a name="1017421"> </a>Pointer to <code>initCodeOffset2</code> variable, or 0.</dd>

<dt><a name="1017422"> </a><code>&harr;  <i><code>databaseDirIDP</code></i></code></dt>
<dd><a name="1017423"> </a>Pointer to database directory chunk ID variable, or 0.</dd>

</dl>
<h4>
  <a name="1017424"> </a>Returns 
</h4>

<p><a name="1017425"> </a>Returns 0 if no error, or <code>memErrCardNotPresent</code>, <code>memErrRAMOnlyCard</code>, or <code>memErrInvalidStoreHeader</code> if an error occurs.</p>
<h4>
  <a name="1017426"> </a>Comments 
</h4>

<p><a name="1017427"> </a>Call this routine to retrieve any or all information on either the RAM store or the ROM store for a card. Pass 0 for variables that you don't wish returned.</p>

<p><a name="1017428"> </a></p>
&nbsp;<br>
</div>
<!--END CONTENT-->

</td>
<td width="5">&nbsp;&nbsp;</td>
</tr>

</table>

<!-- BEGIN FOOTER -->
<table width="100%" border="0" cellspacing="0" cellpadding="0">
<tr>
<td width="7" rowspan="2"><img name="index_x" src="images/shim.gif" width="7" height="33" border="0" alt=""></td>
<td align="left"><img name="dashes" src="images/dashes.gif" width="744" height="3" border="0" alt=""></td>
<td width="10" rowspan="2"><img name="index_x" src="images/shim.gif" width="10" height="33" border="0" alt=""></td>
</tr>
<tr>
<td align="center">
<p class="footer">
Copyright © 1996-2004, PalmSource, Inc. and its affiliates.  All rights reserved. <br>
<a href="http://www.palmsource.com/contact/">Write Us</a> | <a href="http://www.palmos.com/dev/training/">Training</a> | <a href="http://www.palmos.com/dev/support/kb/">Knowledge Base</a> | <a href="Reference_Front.html" target="_blank">Legal</a></p>
<br>
<!--BEGIN BOOK NAVIGATION-->
<p class="nav">
<A href="http://www.palmos.com/dev/support/docs/">Documentation</a>&nbsp;&nbsp;|&nbsp;&nbsp;
<a href="ReferenceTOC.html">Table of Contents</a>&nbsp;&nbsp;
             |&nbsp;&nbsp;<a href="LocaleMgr.html">&lt;&nbsp;Previous</a>&nbsp;&nbsp;
             |&nbsp;&nbsp;<a href="NotifyMgr.html">Next&nbsp;&gt;</a>&nbsp;&nbsp;
             |&nbsp;&nbsp;<a href="ReferenceIX.html">Index</a>
</p>
</td>
</tr>
</table>
<!-- END FOOTER -->

</body>
</html>