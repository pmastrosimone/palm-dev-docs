<html>
<head>
<title>(68K) Virtual File System Manager | Palm OS&#174; Programmer's  API Reference</title> 
<link href="psi_devpubs.css" rel="stylesheet" type="text/css">

<!-- BEGIN META DATA -->
<meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
<META NAME="PSITEMPLATE" CONTENT="1006-007 PalmSource_HTML_2003 20041101">
<META NAME="GENERATOR" CONTENT="Quadralay WebWorks AutoMap 2003 for FrameMaker 8.0.6.2138">
<META NAME="LASTUPDATED" CONTENT="11/22/04 10:46:41">
<!-- END META DATA -->
</head>

<body bgcolor="#ffffff" text="#000000" leftmargin="0" topmargin="0" marginwidth="0" marginheight="0">
<a name="995797"></a>

<!-- BEGIN TOPNAV -->
<table width="100%" border="0" cellspacing="0" cellpadding="0">
<tr>
<td><img src="images/shim.gif" width="7" height="75" border="0" alt=""></td>
<td align="left"><table border="0" cellpadding="0" cellspacing="0" width="744">
<tr>
<td><img name="index_r2_c1" src="images/shim.gif" width="25" height="75" border="0" alt=""></td>
<td valign="top"><table border="0" cellpadding="0" cellspacing="0" width="96">
<tr>
<td><img name="index_r2_c4" src="images/shim.gif" width="96" height="15" border="0" alt=""></td>
</tr>
<tr>
<td><a href="http://www.palmsource.com/"><img name="ps_logo" src="images/ps_logo.gif" width="96" height="54" border="0" alt=""></a></td>
</tr>

</table>
</td>

<td><table border="0" cellpadding="0" cellspacing="0" width="30">
<td><img name="index_x" src="images/shim.gif" width="30" height="75" border="0" alt=""></td>
</table></td>

<!--BEGIN MASTHEAD-->
<td><table border="0" cellpadding="0" cellspacing="0" width="96">
<tr>
<td><img name="index_x" src="images/shim.gif" width="615" height="5" border="0" alt=""></td>
</tr>
<tr>
<td>
<!--BEGIN BOOK NAVIGATION-->
<span class="nav">
<A href="http://www.palmos.com/dev/support/docs/">Documentation</a>&nbsp;&nbsp;|&nbsp;&nbsp;
<a href="ReferenceTOC.html">Table of Contents</a>&nbsp;&nbsp;
             |&nbsp;&nbsp;<a href="DateAndTimeManager.html">&lt;&nbsp;Previous</a>&nbsp;&nbsp;
             |&nbsp;&nbsp;<a href="Window.html">Next&nbsp;&gt;</a>&nbsp;&nbsp;
             |&nbsp;&nbsp;<a href="ReferenceIX.html">Index</a>
</span>
<!--END BOOK NAVIGATION-->
</tr>
<tr>
<td>
<!--BEGIN PAGE TITLE-->
<h2 class="PageTitle">58 &nbsp;&nbsp;
Virtual File System Manager</h2></td>
<!--END PAGE TITLE-->
</tr>
<tr>
<td>
<!--BEGIN BOOK TITLE-->
<p class="BookTitle">Palm OS&#174; Programmer's  API Reference</p>
<p class="SubTitle">Palm OS&#174; 68K SDK </p>
<!--END BOOK TITLE-->
</td>
</tr>
<tr>
<td><img name="index_x" src="images/shim.gif" width="615" height="5" border="0" alt=""></td>
</tr>
</table>
</td>
<!--END MASTHEAD-->
</tr>
</table>
<img name="dashes" src="images/dashes.gif" width="744" height="3" border="0" alt=""></td>
</tr>
</table>
<!-- END TOPNAV -->

<table width="100%" border="0" cellspacing="0" cellpadding="0">
<tr>
<td valign="top" width="5"><img name="index_x" src="images/shim.gif" width="5" height="33" border="0" alt=""></td>

<!--BEGIN SIDETOC-->
<td valign="top" width="175">
<div id="sidetoc" valign="bottom">
<h1 class="SideTOC1-PartTab"><a href="PartII.html">Part II: System Management</a> </h1>
<h1 class="SideTOC1"><a href="VFSMgr.html">58  Virtual File System Manager</a></h1>

   <h2 class="SideTOC2"><a href="#995830">
   VFS Manager Data Structures</a></h2>

      <h3 class="SideTOC3"><a href="#995833">
      FileInfoType</a></h3>

      <h3 class="SideTOC3"><a href="#995866">
      FileRef</a></h3>

      <h3 class="SideTOC3"><a href="#995874">
      VFSAnyMountParamType</a></h3>

      <h3 class="SideTOC3"><a href="#995918">
      VFSSlotMountParamType</a></h3>

      <h3 class="SideTOC3"><a href="#995951">
      VFSPOSEMountParamType</a></h3>

      <h3 class="SideTOC3"><a href="#995976">
      VolumeInfoType</a></h3>

   <h2 class="SideTOC2"><a href="#996048">
   VFS Manager Constants</a></h2>

      <h3 class="SideTOC3"><a href="#996050">
      Defined File Systems</a></h3>

      <h3 class="SideTOC3"><a href="#996150">
      Open Mode Constants</a></h3>

      <h3 class="SideTOC3"><a href="#996221">
      File and Directory Attributes</a></h3>

      <h3 class="SideTOC3"><a href="#996290">
      Volume Attributes</a></h3>

      <h3 class="SideTOC3"><a href="#996325">
      Volume Mount Classes</a></h3>

      <h3 class="SideTOC3"><a href="#996362">
      Error Codes</a></h3>

   <h2 class="SideTOC2"><a href="#996469">
   VFS Manager Functions</a></h2>

      <h3 class="SideTOC3"><a href="#996472">
      VFSCustomControl</a></h3>

      <h3 class="SideTOC3"><a href="#996516">
      VFSDirCreate</a></h3>

      <h3 class="SideTOC3"><a href="#996564">
      VFSDirEntryEnumerate</a></h3>

      <h3 class="SideTOC3"><a href="#996644">
      VFSExportDatabaseToFile</a></h3>

      <h3 class="SideTOC3"><a href="#996699">
      VFSExportDatabaseToFileCustom</a></h3>

      <h3 class="SideTOC3"><a href="#996765">
      VFSFileClose</a></h3>

      <h3 class="SideTOC3"><a href="#996797">
      VFSFileCreate</a></h3>

      <h3 class="SideTOC3"><a href="#996863">
      VFSFileDBGetRecord</a></h3>

      <h3 class="SideTOC3"><a href="#996932">
      VFSFileDBGetResource</a></h3>

      <h3 class="SideTOC3"><a href="#996981">
      VFSFileDBInfo</a></h3>

      <h3 class="SideTOC3"><a href="#997086">
      VFSFileDelete</a></h3>

      <h3 class="SideTOC3"><a href="#997129">
      VFSFileEOF</a></h3>

      <h3 class="SideTOC3"><a href="#997164">
      VFSFileGetAttributes</a></h3>

      <h3 class="SideTOC3"><a href="#997211">
      VFSFileGetDate</a></h3>

      <h3 class="SideTOC3"><a href="#997263">
      VFSFileOpen</a></h3>

      <h3 class="SideTOC3"><a href="#997327">
      VFSFileRead</a></h3>

      <h3 class="SideTOC3"><a href="#997389">
      VFSFileReadData</a></h3>

      <h3 class="SideTOC3"><a href="#997456">
      VFSFileRename</a></h3>

      <h3 class="SideTOC3"><a href="#997512">
      VFSFileResize</a></h3>

      <h3 class="SideTOC3"><a href="#997556">
      VFSFileSeek</a></h3>

      <h3 class="SideTOC3"><a href="#997611">
      VFSFileSetAttributes</a></h3>

      <h3 class="SideTOC3"><a href="#997665">
      VFSFileSetDate</a></h3>

      <h3 class="SideTOC3"><a href="#997718">
      VFSFileSize</a></h3>

      <h3 class="SideTOC3"><a href="#997764">
      VFSFileTell</a></h3>

      <h3 class="SideTOC3"><a href="#997807">
      VFSFileWrite</a></h3>

      <h3 class="SideTOC3"><a href="#997864">
      VFSGetDefaultDirectory</a></h3>

      <h3 class="SideTOC3"><a href="#997916">
      VFSImportDatabaseFromFile</a></h3>

      <h3 class="SideTOC3"><a href="#997978">
      VFSImportDatabaseFromFileCustom</a></h3>

      <h3 class="SideTOC3"><a href="#998046">
      VFSInstallFSLib</a></h3>

      <h3 class="SideTOC3"><a href="#998087">
      VFSRegisterDefaultDirectory</a></h3>

      <h3 class="SideTOC3"><a href="#998135">
      VFSRemoveFSLib</a></h3>

      <h3 class="SideTOC3"><a href="#998166">
      VFSUnregisterDefaultDirectory</a></h3>

      <h3 class="SideTOC3"><a href="#998210">
      VFSVolumeEnumerate</a></h3>

      <h3 class="SideTOC3"><a href="#998257">
      VFSVolumeFormat</a></h3>

      <h3 class="SideTOC3"><a href="#998338">
      VFSVolumeGetLabel</a></h3>

      <h3 class="SideTOC3"><a href="#998384">
      VFSVolumeInfo</a></h3>

      <h3 class="SideTOC3"><a href="#998428">
      VFSVolumeMount</a></h3>

      <h3 class="SideTOC3"><a href="#998519">
      VFSVolumeSetLabel</a></h3>

      <h3 class="SideTOC3"><a href="#998574">
      VFSVolumeSize</a></h3>

      <h3 class="SideTOC3"><a href="#998615">
      VFSVolumeUnmount</a></h3>

   <h2 class="SideTOC2"><a href="#998655">
   Application-Defined Functions</a></h2>

      <h3 class="SideTOC3"><a href="#998658">
      VFSExportProcPtr</a></h3>

      <h3 class="SideTOC3"><a href="#998701">
      VFSImportProcPtr</a></h3>

</div>
</td>

<td width="5">&nbsp;&nbsp;</td>
<td width="2" background="images/index_r8_c10.gif"><img src="images/shim.gif" width="2" height="75" border="0" alt=""></td>
<td width="5">&nbsp;&nbsp;</td>

<!--END SIDETOC-->

<td valign="top">

<!--BEGIN CONTENT-->
<div id="content" valign="bottom">
<p><a name="995801"> </a>The Virtual File System (VFS) Manager is a layer of software that manages all installed file system libraries. It provides a unified API to application developers while allowing them to seamlessly access many different types of file systems &#8212;such as VFAT, HFS, and NFS&#8212;on many different types of media, including Compact Flash, Memory Stick, and SmartMedia.This chapter provides reference material for the VFS Manager API as follows:</p>
<ul type="disc">
  <li><a name="995805"> </a><a href="VFSMgr.html#995830">VFS Manager Data Structures</a>
  <li><a name="995809"> </a><a href="VFSMgr.html#996048">VFS Manager Constants</a>
  <li><a name="995813"> </a><a href="VFSMgr.html#996469">VFS Manager Functions</a>
  <li><a name="995817"> </a><a href="VFSMgr.html#998655">Application-Defined Functions</a>
</ul>

<p><a name="995818"> </a>The header file <code>VFSMgr.h</code> declares the VFS Manager API. For more information on the VFS Manager, see <a href="../PalmOSCompanion/ExpAndVFSConcepts.html#1031615">Chapter 7, "Expansion,"</a> in <i>Palm OS Programmer's Companion</i>, vol. I.</p>

<p><a name="995825"> </a>Note that the VFS Manager is an optional system extension; the functions described in this chapter are implemented only if the <a href="CompatibilityApdx.html#996319">VFS Manager Feature Set</a> is present.</p>

<h2 class="haH2">
  <a name="995830"> </a>VFS Manager Data Structures <a href="#995797"><span class="nav">^TOP^</span></a>
</h2>


<h3 class="hbH3">
  <a name="995833"> </a>FileInfoType Struct <a href="#995797"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="995835"> </a>Purpose 
</h4>

<p><a name="995836"> </a>The <code>FileInfoType</code> structure contains information about a specified file or directory. This information is returned as a parameter to <a href="VFSMgr.html#996564"><code>VFSDirEntryEnumerate()</code></a>. The structure is defined as follows:</p>
<h4>
  <a name="995840"> </a>Prototype 
</h4>
<pre class="proto"><a name="995841"></a>typedef struct FileInfoTag {
  UInt32 attributes;
  Char *nameP;
  UInt16 nameBufLen;
} FileInfoType, *FileInfoPtr;
</pre>
<h4>
  <a name="1028418"> </a>Fields 
</h4>

<dl>
<dt><a name="995849"> </a><code><code>attributes</code></code></dt>
<dd><a name="995853"> </a>Characteristics of the file or directory. See <a href="VFSMgr.html#996221">File and Directory Attributes</a> for the bits that make up this field.</dd>

<dt><a name="995856"> </a><code><code>nameP</code></code></dt>
<dd><a name="995858"> </a>Pointer to the buffer that receives the full name of the file or directory. Initialize this parameter to <code>NULL</code> if you don't want to receive the name.</dd>

<dt><a name="995860"> </a><code><code>nameBufLen</code></code></dt>
<dd><a name="995862"> </a>Size of the <code>nameP</code> buffer, in bytes.</dd>

</dl>

<h3 class="hbH3">
  <a name="995866"> </a>FileRef Typedef <a href="#995797"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="995868"> </a>Purpose 
</h4>

<p><a name="995869"> </a>The <code>FileRef</code> type is used to encode references to files and directories.</p>
<h4>
  <a name="995870"> </a>Prototype 
</h4>
<pre class="proto"><a name="995871"></a>typedef UInt32 FileRef;
</pre>

<h3 class="hbH3">
  <a name="995874"> </a>VFSAnyMountParamType Struct <a href="#995797"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="995876"> </a>Purpose 
</h4>

<p><a name="995877"> </a>The <code>VFSAnyMountParamType</code> structure is a base structure for <a href="VFSMgr.html#995918"><code>VFSSlotMountParamType</code></a>, <a href="VFSMgr.html#995951"><code>VFSPOSEMountParamType</code></a>, and other similar structures that may be defined in the future. Use one or the other according to how you set the <code>mountClass</code> parameter. </p>
<h4>
  <a name="995884"> </a>Prototype 
</h4>
<pre class="proto"><a name="995885"></a>typedef struct VFSAnyMountParamTag {
  UInt16 volRefNum;
  UInt16 reserved;
  UInt32 mountClass;
} VFSAnyMountParamType;
</pre>
<pre class="proto"><a name="995891"></a>typedef VFSAnyMountParamType 
*VFSAnyMountParamPtr;
</pre>
<h4>
  <a name="1028527"> </a>Fields 
</h4>

<dl>
<dt><a name="995895"> </a><code><code>volRefNum</code></code></dt>
<dd><a name="995897"> </a>The volume reference number. This is initially obtained when you successfully mount a volume. It can then be used to format a volume with <a href="VFSMgr.html#998257"><code>VFSVolumeFormat()</code></a> or unmount a volume with <a href="VFSMgr.html#998615"><code>VFSVolumeUnmount</code></a>. </dd>

<dt><a name="995905"> </a><code><code>reserved</code></code></dt>
<dd><a name="995907"> </a>Reserved for future use.</dd>

<dt><a name="995909"> </a><code><code>mountClass</code></code></dt>
<dd><a name="995911"> </a>Defines the type of mount to use with the specified volume. See <a href="VFSMgr.html#996325">Volume Mount Classes</a> for a list of mount types.</dd>

</dl>

<h3 class="hbH3">
  <a name="995918"> </a>VFSSlotMountParamType Struct <a href="#995797"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="995920"> </a>Purpose 
</h4>

<p><a name="995921"> </a>The <code>VFSSlotMountParamType </code>structure is used when you are mounting a card located in an Expansion Manager slot. The <code>vfsMountParam-&gt;mountClass</code> field must be set to <code>VFSMountClass_SlotDriver</code>. </p>
<h4>
  <a name="995922"> </a>Prototype 
</h4>
<pre class="proto"><a name="995923"></a>typedef struct VFSSlotMountParamTag {
  VFSAnyMountParamType vfsMountParam;
  UInt16 slotLibRefNum;
  UInt16 slotRefNum;
} VFSSlotMountParamType;
</pre>
<h4>
  <a name="1028637"> </a>Fields 
</h4>

<dl>
<dt><a name="995931"> </a><code><code>vfsMountParam</code></code></dt>
<dd><a name="995933"> </a>See the description of <a href="VFSMgr.html#995874"><code>VFSAnyMountParamType</code></a> for an explanation of the fields in this structure. Set <code>vfsMountParam-&gt;mountClass</code> to <code>VFSMountClass_SlotDriver</code> to mount an Expansion Manager slot.</dd>

<dt><a name="995938"> </a><code><code>slotLibRefNum</code></code></dt>
<dd><a name="995940"> </a>Reference number for the slot driver library allocated to the given slot number. Obtain this field by calling <a href="ExpansionManager.html#1033391"><code>ExpSlotLibFind()</code></a>.</dd>

<dt><a name="995945"> </a><code><code>slotRefNum</code></code></dt>
<dd><a name="995947"> </a>Number of the slot to be mounted.</dd>

</dl>

<h3 class="hbH3">
  <a name="995951"> </a>VFSPOSEMountParamType Struct <a href="#995797"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="995953"> </a>Purpose 
</h4>

<p><a name="995954"> </a>The <code>VFSPOSEMountParamType </code>structure is used when you are mounting a volume through the Palm OS<sup>&#174;</sup> Emulator. The <code>vfsMountParam-&gt;mountClass</code> must be set to <code>VFSMountClass_POSE</code>. Note that ordinary applications and file systems shouldn't use <code>VFSPOSEMountParamType</code>.</p>
<h4>
  <a name="995955"> </a>Prototype 
</h4>
<pre class="proto"><a name="995956"></a>typedef struct VFSPOSEMountParamTag {
  VFSAnyMountParamType vfsMountParam; 
  UInt8 poseSlotNum;
} VFSPOSEMountParamType;
</pre>
<h4>
  <a name="1028696"> </a>Fields 
</h4>

<dl>
<dt><a name="995963"> </a><code><code>vfsMountParam</code></code></dt>
<dd><a name="995965"> </a>See the description of <a href="VFSMgr.html#995874"><code>VFSAnyMountParamType</code></a> for an explanation of the fields in this structure. Set <code>vfsMountParam-&gt;mountClass</code> to <code>VFSMountClass_POSE</code> to mount a virtual slot.</dd>

<dt><a name="995970"> </a><code><code>poseSlotNum</code></code></dt>
<dd><a name="995972"> </a>Number of the virtual slot number to be mounted by the Palm OS Emulator.</dd>

</dl>

<h3 class="hbH3">
  <a name="995976"> </a>VolumeInfoType Struct <a href="#995797"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="995978"> </a>Purpose 
</h4>

<p><a name="995979"> </a>The <code>VolumeInfoType</code> structure defines information that is returned to <a href="VFSMgr.html#998384"><code>VFSVolumeInfo()</code></a> and used throughout the VFS functions.</p>
<h4>
  <a name="995983"> </a>Prototype 
</h4>
<pre class="proto"><a name="995984"></a>typedef struct VolumeInfoTag {
  UInt32 attributes;
  UInt32 fsType;
  UInt32 fsCreator;
  UInt32 mountClass;
  UInt16 slotLibRefNum;
  UInt16 slotRefNum;
  UInt32 mediaType;
  UInt32 reserved;
} VolumeInfoType, *VolumeInfoPtr;
</pre>
<h4>
  <a name="1031166"> </a>Fields 
</h4>

<dl>
<dt><a name="995997"> </a><code><code>attributes</code></code></dt>
<dd><a name="996001"> </a>Characteristics of the volume. See <a href="VFSMgr.html#996290">Volume Attributes</a> for the bits that make up this field.</dd>

<dt><a name="996004"> </a><code><code>fsType</code></code></dt>
<dd><a name="996006"> </a>File system type for this volume. See <a href="VFSMgr.html#996050">Defined File Systems</a> for a list of the supported file systems.</dd>

<dt><a name="996011"> </a><code><code>fsCreator</code></code></dt>
<dd><a name="996013"> </a>Creator ID of this volume's file system driver. This information is used with <a href="VFSMgr.html#996472"><code>VFSCustomControl()</code></a>.</dd>

<dt><a name="996018"> </a><code><code>mountClass</code></code></dt>
<dd><a name="996020"> </a>Mount class that mounted this volume. The supported mount classes are listed under <a href="VFSMgr.html#996325">Volume Mount Classes</a>.</dd>

<dt><a name="996025"> </a><code><code>slotLibRefNum</code></code></dt>
<dd><a name="996027"> </a>Reference to the slot driver library with which the volume is mounted. This field is only valid when the mount class is <code>vfsMountClass_SlotDriver</code>.</dd>

<dt><a name="996029"> </a><code><code>slotRefNum</code></code></dt>
<dd><a name="996031"> </a>Slot number where the card containing the volume is loaded. This field is only valid when the mount class is <code>vfsMountClass_SlotDriver</code>.</dd>

<dt><a name="996033"> </a><code><code>mediaType</code></code></dt>
<dd><a name="996037"> </a>Type of card media. See <a href="ExpansionManager.html#1033049">Defined Media Types</a> in the <a href="ExpansionManager.html#1032894">Expansion Manager</a> chapter for the list of values. This field is only valid when the mount class is <code>vfsMountClass_SlotDriver</code>.</dd>

<dt><a name="996043"> </a><code><code>reserved</code></code></dt>
<dd><a name="996045"> </a>Reserved for future use.</dd>

</dl>

<h2 class="haH2">
  <a name="996048"> </a>VFS Manager Constants <a href="#995797"><span class="nav">^TOP^</span></a>
</h2>


<h3 class="hbH3">
  <a name="996050"> </a>Defined File Systems <a href="#995797"><span class="nav">^TOP^</span></a>
</h3>


<p><a name="996051"> </a>The following file systems are currently defined by the VFS Manager. These values are used with <a href="VFSMgr.html#998384"><code>VFSVolumeInfo()</code></a> in the <span style="color: #000000;  font-family: Courier; font-style: normal; font-weight: normal; text-decoration: none; text-transform: none; vertical-align: baseline">VolumeInfoType.fsType</span> parameter.</p>


<div class="tablediv"><table cellspacing="0" class="tTable">

  <tr valign="top">
    <th><p class="tt"><a name="996057"> </a><b><span style="color: #000000;  font-style: normal; font-weight: bold; text-decoration: none; text-transform: none; vertical-align: baseline">Constant</span></b></p>
    </th>
    <th><p class="tt"><a name="996059"> </a><b>Value</b></p>
    </th>
    <th><p class="tt"><a name="996061"> </a><b>Description</b></p>
    </th>
  </tr>
  <tr valign="top">
    <td><p class="tts"><a name="996064"> </a><code>vfsFilesystemType_AFS</code></p>
    </td>
    <td><p class="tt"><a name="996066"> </a><code>'afsu'</code></p>
    </td>
    <td><p class="tt"><a name="996068"> </a>Unix Andrew file system</p>
    </td>
  </tr>
  <tr valign="top">
    <td><p class="tts"><a name="996071"> </a><code>vfsFilesystemType_EXT2</code></p>
    </td>
    <td><p class="tt"><a name="996073"> </a><code>'ext2'</code></p>
    </td>
    <td><p class="tt"><a name="996075"> </a>Linux file system</p>
    </td>
  </tr>
  <tr valign="top">
    <td><p class="tts"><a name="996078"> </a><code>vfsFilesystemType_FAT</code></p>
    </td>
    <td><p class="tt"><a name="996080"> </a><code>'fats'</code></p>
    </td>
    <td><p class="tt"><a name="996082"> </a>FAT12 and FAT16, which only handles 8.3 filenames</p>
    </td>
  </tr>
  <tr valign="top">
    <td><p class="tts"><a name="996085"> </a><code>vfsFilesystemType_FFS</code></p>
    </td>
    <td><p class="tt"><a name="996087"> </a><code>'ffsb'</code></p>
    </td>
    <td><p class="tt"><a name="996089"> </a>Unix Berkeley block based file system</p>
    </td>
  </tr>
  <tr valign="top">
    <td><p class="tts"><a name="996092"> </a><code>vfsFilesystemType_HFS</code></p>
    </td>
    <td><p class="tt"><a name="996094"> </a><code>'hfss'</code></p>
    </td>
    <td><p class="tt"><a name="996096"> </a>Macintosh standard hierarchical file system</p>
    </td>
  </tr>
  <tr valign="top">
    <td><p class="tts"><a name="996099"> </a><code>vfsFilesystemType_HFSPlus</code></p>
    </td>
    <td><p class="tt"><a name="996101"> </a><code>'hfse'</code></p>
    </td>
    <td><p class="tt"><a name="996103"> </a>Macintosh extended hierarchical file system</p>
    </td>
  </tr>
  <tr valign="top">
    <td><p class="tts"><a name="996106"> </a><code>vfsFilesystemType_HPFS</code></p>
    </td>
    <td><p class="tt"><a name="996108"> </a><code>'hpfs'</code></p>
    </td>
    <td><p class="tt"><a name="996110"> </a>OS2 High Performance file system</p>
    </td>
  </tr>
  <tr valign="top">
    <td><p class="tts"><a name="996113"> </a><code>vfsFilesystemType_MFS</code></p>
    </td>
    <td><p class="tt"><a name="996115"> </a><code>'mfso'</code></p>
    </td>
    <td><p class="tt"><a name="996117"> </a>Macintosh original file system</p>
    </td>
  </tr>
  <tr valign="top">
    <td><p class="tts"><a name="996120"> </a><code>vfsFilesystemType_NFS</code></p>
    </td>
    <td><p class="tt"><a name="996122"> </a><code>'nfsu'</code></p>
    </td>
    <td><p class="tt"><a name="996124"> </a>Unix Networked file system</p>
    </td>
  </tr>
  <tr valign="top">
    <td><p class="tts"><a name="996127"> </a><code>vfsFilesystemType_Novell</code></p>
    </td>
    <td><p class="tt"><a name="996129"> </a><code>'novl'</code></p>
    </td>
    <td><p class="tt"><a name="996131"> </a>Novell file system</p>
    </td>
  </tr>
  <tr valign="top">
    <td><p class="tts"><a name="996134"> </a><code>vfsFilesystemType_NTFS</code></p>
    </td>
    <td><p class="tt"><a name="996136"> </a><code>'ntfs'</code></p>
    </td>
    <td><p class="tt"><a name="996138"> </a>Windows NT file system</p>
    </td>
  </tr>
  <tr valign="top">
    <td><p class="tts"><a name="996141"> </a><code>vfsFilesystemType_VFAT</code></p>
    </td>
    <td><p class="tt"><a name="996143"> </a><code>'vfat'</code></p>
    </td>
    <td><p class="tt"><a name="996145"> </a>FAT12 and FAT16 extended to handle long filenames</p>
    </td>
  </tr>
</table>

</div>


<h3 class="hbH3">
  <a name="996150"> </a>Open Mode Constants <a href="#995797"><span class="nav">^TOP^</span></a>
</h3>


<p><a name="996151"> </a>This section describes constants that are used for the <code>openMode</code> parameter to the <a href="VFSMgr.html#997263"><code>VFSFileOpen()</code></a> function. These constants specify the mode in which a file or directory is opened. </p>


<div class="tablediv"><table cellspacing="0" class="tTable">

  <tr valign="top">
    <th><p class="tt"><a name="996157"> </a><b>Constant</b></p>
    </th>
    <th><p class="tt"><a name="996159"> </a><b>Value</b></p>
    </th>
    <th><p class="tt"><a name="996161"> </a><b>Description</b></p>
    </th>
  </tr>
  <tr valign="top">
    <td><p class="tt"><a name="996164"> </a><code>vfsModeExclusive</code></p>
    </td>
    <td><p class="tt"><a name="996166"> </a><code>0x0001U</code></p>
    </td>
    <td><p class="tt"><a name="996168"> </a>Open and lock the file or directory. This mode excludes anyone else from using the file or directory until it is closed. </p>
    </td>
  </tr>
  <tr valign="top">
    <td><p class="tt"><a name="996171"> </a><code>vfsModeRead</code></p>
    </td>
    <td><p class="tt"><a name="996173"> </a><code>0x0002U</code></p>
    </td>
    <td><p class="tt"><a name="996175"> </a>Open for read access.</p>
    </td>
  </tr>
  <tr valign="top">
    <td><p class="tt"><a name="996178"> </a><code>vfsModeWrite</code></p>
    </td>
    <td><p class="tt"><a name="996180"> </a><code>0x0004U | vfsModeExclusive</code></p>
    </td>
    <td><p class="tt"><a name="996182"> </a>Open for write access. </p>
    </td>
  </tr>
  <tr valign="top">
    <td><p class="tt"><a name="996185"> </a><code>vfsModeReadWrite</code></p>
    </td>
    <td><p class="tt"><a name="996187"> </a><code>vfsModeWrite | vfsModeRead</code></p>
    </td>
    <td><p class="tt"><a name="996189"> </a>Open for read/write access.</p>
    </td>
  </tr>
  <tr valign="top">
    <td><p class="tt"><a name="996192"> </a><code>vfsModeCreate</code></p>
    </td>
    <td><p class="tt"><a name="996194"> </a><code>0x0008U</code></p>
    </td>
    <td><p class="tt"><a name="996196"> </a>Create the file if it doesn't already exist. This open mode is implemented in the VFS layer, rather than in the file system library.</p>
    </td>
  </tr>
  <tr valign="top">
    <td><p class="tt"><a name="996199"> </a><code>vfsModeTruncate</code></p>
    </td>
    <td><p class="tt"><a name="996201"> </a><code>0x0010U</code></p>
    </td>
    <td><p class="tt"><a name="996203"> </a>Truncate the file to zero (0) bytes after opening, removing all existing data. This open mode is implemented in the VFS layer, rather than in the file system library. </p>
    </td>
  </tr>
  <tr valign="top">
    <td><p class="tt"><a name="996206"> </a><code>vfsModeVFSLayerOnly</code></p>
    </td>
    <td><p class="tt"><a name="996208"> </a><code>vfsModeCreate | vfsModeTruncate | vfsModeLeaveOpen</code></p>
    </td>
    <td><p class="tt"><a name="996210"> </a>Mask used to isolate those flags that are only used by the VFS layer. These flags are not passed to the file system layer.</p>
    </td>
  </tr>
  <tr valign="top">
    <td><p class="tt"><a name="996213"> </a><code>vfsModeLeaveOpen</code></p>
    </td>
    <td><p class="tt"><a name="996215"> </a><code>0x0020U</code></p>
    </td>
    <td><p class="tt"><a name="996217"> </a>Leave the file open even after the </p>
<p class="tt"><a name="996218"> </a>application exits.</p>
    </td>
  </tr>
</table>

</div>


<h3 class="hbH3">
  <a name="996221"> </a>File and Directory Attributes <a href="#995797"><span class="nav">^TOP^</span></a>
</h3>


<p><a name="996222"> </a>The constants in the following table define bits that can be used individually or in combination when setting or interpreting the file attributes for a given file or directory. See <a href="VFSMgr.html#997164"><code>VFSFileGetAttributes()</code></a>, <a href="VFSMgr.html#997611"><code>VFSFileSetAttributes()</code></a>, and the <a href="VFSMgr.html#995833">FileInfoType</a> data structure for specific use.</p>


<div class="tablediv"><table cellspacing="0" class="tTable">

  <tr valign="top">
    <th><p class="tt"><a name="996234"> </a><b>Constant</b></p>
    </th>
    <th><p class="tt"><a name="996236"> </a><b>Value</b></p>
    </th>
    <th><p class="tt"><a name="996238"> </a><b>Description</b></p>
    </th>
  </tr>
  <tr valign="top">
    <td><p class="tt"><a name="996241"> </a><code>vfsFileAttrReadOnly</code></p>
    </td>
    <td><p class="tt"><a name="996243"> </a><code>0x00000001UL</code></p>
    </td>
    <td><p class="tt"><a name="996245"> </a>Read-only file or directory</p>
    </td>
  </tr>
  <tr valign="top">
    <td><p class="tt"><a name="996248"> </a><code>vfsFileAttrHidden</code></p>
    </td>
    <td><p class="tt"><a name="996250"> </a><code>0x00000002UL</code></p>
    </td>
    <td><p class="tt"><a name="996252"> </a>Hidden file or directory</p>
    </td>
  </tr>
  <tr valign="top">
    <td><p class="tt"><a name="996255"> </a><code>vfsFileAttrSystem</code></p>
    </td>
    <td><p class="tt"><a name="996257"> </a><code>0x00000004UL</code></p>
    </td>
    <td><p class="tt"><a name="996259"> </a>System file or directory</p>
    </td>
  </tr>
  <tr valign="top">
    <td><p class="tt"><a name="996262"> </a><code>vfsFileAttrVolumeLabel</code></p>
    </td>
    <td><p class="tt"><a name="996264"> </a><code>0x00000008UL</code></p>
    </td>
    <td><p class="tt"><a name="996266"> </a>Volume label</p>
    </td>
  </tr>
  <tr valign="top">
    <td><p class="tt"><a name="996269"> </a><code>vfsFileAttrDirectory</code></p>
    </td>
    <td><p class="tt"><a name="996271"> </a><code>0x00000010UL</code></p>
    </td>
    <td><p class="tt"><a name="996273"> </a>Directory</p>
    </td>
  </tr>
  <tr valign="top">
    <td><p class="tt"><a name="996276"> </a><code>vfsFileAttrArchive</code></p>
    </td>
    <td><p class="tt"><a name="996278"> </a><code>0x00000020UL</code></p>
    </td>
    <td><p class="tt"><a name="996280"> </a>Archived file or directory</p>
    </td>
  </tr>
  <tr valign="top">
    <td><p class="tt"><a name="996283"> </a><code>vfsFileAttrLink</code></p>
    </td>
    <td><p class="tt"><a name="996285"> </a><code>0x00000040UL</code></p>
    </td>
    <td><p class="tt"><a name="996287"> </a>Link to another file or directory</p>
    </td>
  </tr>
</table>

</div>


<h3 class="hbH3">
  <a name="996290"> </a>Volume Attributes <a href="#995797"><span class="nav">^TOP^</span></a>
</h3>


<p><a name="996291"> </a>The constants in the following table define bits that can be used individually or in combination to make up the attributes field in the <a href="VFSMgr.html#995976"><code>VolumeInfoType</code></a> structure.</p>


<div class="tablediv"><table cellspacing="0" class="tTable">

  <tr valign="top">
    <th><p class="tt"><a name="996297"> </a><b>Constant</b></p>
    </th>
    <th><p class="tt"><a name="996299"> </a><b>Value</b></p>
    </th>
    <th><p class="tt"><a name="996301"> </a><b>Description</b></p>
    </th>
  </tr>
  <tr valign="top">
    <td><p class="tt"><a name="996304"> </a><code>vfsVolumeAttrHidden</code></p>
    </td>
    <td><p class="tt"><a name="996306"> </a><code>0x00000004UL</code></p>
    </td>
    <td><p class="tt"><a name="996308"> </a>The volume should not be visible to the user.</p>
    </td>
  </tr>
  <tr valign="top">
    <td><p class="tt"><a name="1031282"> </a><code>vfsVolumeAttrNonRemovable</code></p>
    </td>
    <td><p class="tt"><a name="1031296"> </a><code>0x00000008UL</code></p>
    </td>
    <td><p class="tt"><a name="1031286"> </a>The media cannot be removed.</p>
    </td>
  </tr>
  <tr valign="top">
    <td><p class="tt"><a name="996311"> </a><code>vfsVolumeAttrReadOnly</code></p>
    </td>
    <td><p class="tt"><a name="996313"> </a><code>0x00000002UL</code></p>
    </td>
    <td><p class="tt"><a name="996315"> </a>The volume is read only.</p>
    </td>
  </tr>
  <tr valign="top">
    <td><p class="tt"><a name="996318"> </a><code>vfsVolumeAttrSlotBased</code></p>
    </td>
    <td><p class="tt"><a name="996320"> </a><code>0x00000001UL</code></p>
    </td>
    <td><p class="tt"><a name="996322"> </a>Reserved. Check the mount class to determine how a volume is mounted.</p>
    </td>
  </tr>
</table>

</div>


<h3 class="hbH3">
  <a name="996325"> </a>Volume Mount Classes <a href="#995797"><span class="nav">^TOP^</span></a>
</h3>


<p><a name="996326"> </a>The following constants define how a given volume is mounted. The <code>mountClass</code> field in the <a href="VFSMgr.html#995874"><code>VFSAnyMountParamType</code></a> and <a href="VFSMgr.html#995976"><code>VolumeInfoType</code></a> structures takes on one of these values.</p>


<div class="tablediv"><table cellspacing="0" class="tTable">

  <tr valign="top">
    <th><p class="tt"><a name="996335"> </a><b>Constant</b></p>
    </th>
    <th><p class="tt"><a name="996337"> </a><b>Value</b></p>
    </th>
    <th><p class="tt"><a name="996339"> </a><b>Description</b></p>
    </th>
  </tr>
  <tr valign="top">
    <td><p class="tt"><a name="996342"> </a><code>vfsMountClass_POSE</code></p>
    </td>
    <td><p class="tt"><a name="996344"> </a><code>'pose'</code></p>
    </td>
    <td><p class="tt"><a name="996346"> </a>Mount the volume through the Palm OS Emulator. This is used for testing.</p>
    </td>
  </tr>
  <tr valign="top">
    <td><p class="tt"><a name="996349"> </a><code>vfsMountClass_Simulator</code></p>
    </td>
    <td><p class="tt"><a name="996351"> </a><code>sysFileTSimulator</code></p>
    </td>
    <td><p class="tt"><a name="996353"> </a>Mount the volume through the simulator. This is used for testing.</p>
    </td>
  </tr>
  <tr valign="top">
    <td><p class="tt"><a name="996356"> </a><code>vfsMountClass_SlotDriver</code></p>
    </td>
    <td><p class="tt"><a name="996358"> </a><code>sysFileTSlotDriver</code></p>
    </td>
    <td><p class="tt"><a name="996360"> </a>Mount the volume with a slot driver shared library.</p>
    </td>
  </tr>
</table>

</div>


<h3 class="hbH3">
  <a name="996362"> </a>Error Codes <a href="#995797"><span class="nav">^TOP^</span></a>
</h3>


<p><a name="996363"> </a>The VFS Manager defines the following error codes:</p>


<div class="tablediv"><table cellspacing="0" class="tTable">

  <tr valign="top">
    <th><p class="tt"><a name="996366"> </a><b>Constant</b></p>
    </th>
    <th><p class="tt"><a name="996368"> </a><b>Description</b></p>
    </th>
  </tr>
  <tr valign="top">
    <td><p class="tt"><a name="996371"> </a><code>vfsErrBadData</code></p>
    </td>
    <td><p class="tt"><a name="996373"> </a>The operation could not be completed because of invalid data.</p>
    </td>
  </tr>
  <tr valign="top">
    <td><p class="tt"><a name="996376"> </a><code>vfsErrBadName</code></p>
    </td>
    <td><p class="tt"><a name="996378"> </a>Invalid filename, path, or volume label.</p>
    </td>
  </tr>
  <tr valign="top">
    <td><p class="tt"><a name="996381"> </a><code>vfsErrBufferOverflow</code></p>
    </td>
    <td><p class="tt"><a name="996383"> </a>The supplied buffer is too small.</p>
    </td>
  </tr>
  <tr valign="top">
    <td><p class="tt"><a name="996386"> </a><code>vfsErrDirectoryNotFound</code></p>
    </td>
    <td><p class="tt"><a name="996388"> </a>Returned when the path leading up to the file does not exist.</p>
    </td>
  </tr>
  <tr valign="top">
    <td><p class="tt"><a name="996391"> </a><code>vfsErrDirNotEmpty</code></p>
    </td>
    <td><p class="tt"><a name="996393"> </a>The directory is not empty and therefore cannot be deleted.</p>
    </td>
  </tr>
  <tr valign="top">
    <td><p class="tt"><a name="996396"> </a><code>vfsErrFileAlreadyExists</code></p>
    </td>
    <td><p class="tt"><a name="996398"> </a>A file with this name exists already in this location.</p>
    </td>
  </tr>
  <tr valign="top">
    <td><p class="tt"><a name="996401"> </a><code>vfsErrFileBadRef</code></p>
    </td>
    <td><p class="tt"><a name="996403"> </a>The file reference is invalid: it has been closed or was not obtained from <a href="VFSMgr.html#997263"><code>VFSFileOpen()</code></a>.</p>
    </td>
  </tr>
  <tr valign="top">
    <td><p class="tt"><a name="996409"> </a><code>vfsErrFileEOF</code></p>
    </td>
    <td><p class="tt"><a name="996411"> </a>The file pointer is at the end of the file.</p>
    </td>
  </tr>
  <tr valign="top">
    <td><p class="tt"><a name="996414"> </a><code>vfsErrFileGeneric</code></p>
    </td>
    <td><p class="tt"><a name="996416"> </a>Generic file error.</p>
    </td>
  </tr>
  <tr valign="top">
    <td><p class="tt"><a name="996419"> </a><code>vfsErrFileNotFound</code></p>
    </td>
    <td><p class="tt"><a name="996421"> </a>The file was not found at the specified location.</p>
    </td>
  </tr>
  <tr valign="top">
    <td><p class="tt"><a name="996424"> </a><code>vfsErrFilePermissionDenied</code></p>
    </td>
    <td><p class="tt"><a name="996426"> </a>The requested permissions could not be granted.</p>
    </td>
  </tr>
  <tr valign="top">
    <td><p class="tt"><a name="996429"> </a><code>vfsErrFileStillOpen</code></p>
    </td>
    <td><p class="tt"><a name="996431"> </a>Returned from the underlying file system's delete function if the file is still open.</p>
    </td>
  </tr>
  <tr valign="top">
    <td><p class="tt"><a name="996434"> </a><code>vfsErrIsADirectory</code></p>
    </td>
    <td><p class="tt"><a name="996436"> </a>This operation can only be performed on a regular file, not a directory.</p>
    </td>
  </tr>
  <tr valign="top">
    <td><p class="tt"><a name="996439"> </a><code>vfsErrNameShortened</code></p>
    </td>
    <td><p class="tt"><a name="996441"> </a>A volume name or filename was automatically shortened to conform to the file system specification.</p>
    </td>
  </tr>
  <tr valign="top">
    <td><p class="tt"><a name="996444"> </a><code>vfsErrNoFileSystem</code></p>
    </td>
    <td><p class="tt"><a name="996446"> </a>None of the installed file systems support this operation.</p>
    </td>
  </tr>
  <tr valign="top">
    <td><p class="tt"><a name="996449"> </a><code>vfsErrNotADirectory</code></p>
    </td>
    <td><p class="tt"><a name="996451"> </a>This operation can only performed on a directory.</p>
    </td>
  </tr>
  <tr valign="top">
    <td><p class="tt"><a name="996454"> </a><code>vfsErrVolumeBadRef</code></p>
    </td>
    <td><p class="tt"><a name="996456"> </a>The volume reference number is invalid.</p>
    </td>
  </tr>
  <tr valign="top">
    <td><p class="tt"><a name="996459"> </a><code>vfsErrVolumeFull</code></p>
    </td>
    <td><p class="tt"><a name="996461"> </a>There is insufficient space left on the volume.</p>
    </td>
  </tr>
  <tr valign="top">
    <td><p class="tt"><a name="996464"> </a><code>vfsErrVolumeStillMounted</code></p>
    </td>
    <td><p class="tt"><a name="996466"> </a>Returned from the underlying file system's format function if the volume is still mounted.</p>
    </td>
  </tr>
</table>

</div>


<h2 class="haH2">
  <a name="996469"> </a>VFS Manager Functions <a href="#995797"><span class="nav">^TOP^</span></a>
</h2>


<h3 class="hbH3">
  <a name="996472"> </a>VFSCustomControl Function <a href="#995797"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="996474"> </a>Purpose 
</h4>

<p><a name="996475"> </a>Make a custom API call to a particular file system, given its creator ID. You can use <a href="VFSMgr.html#998384"><code>VFSVolumeInfo()</code></a> to determine the creator ID of the file system for a given volume.</p>
<h4>
  <a name="996479"> </a>Declared In 
</h4>
<code>VfsMgr.h<a name="996480"> </a></code><h4>
  <a name="996481"> </a>Prototype 
</h4>
<pre class="proto"><a name="996482"></a>Err VFSCustomControl(
   UInt32 fsCreator,
   UInt32 apiCreator,
   UInt16 apiSelector,
   void *valueP,
   UInt16 *valueLenP
)
</pre>
<h4>
  <a name="996483"> </a>Parameters 
</h4>

<dl>
<dt><a name="996484"> </a><code>&rarr;  <i><code>fsCreator</code></i></code></dt>
<dd><a name="996485"> </a>Creator of the file system to call. A value of zero (0) tells the VFS Manager to check each registered file system, looking for one which supports the call.</dd>

<dt><a name="996486"> </a><code>&rarr;  <i><code>apiCreator</code></i></code></dt>
<dd><a name="996487"> </a>Registered creator ID.</dd>

<dt><a name="996488"> </a><code>&rarr;  <i><code>apiSelector</code></i></code></dt>
<dd><a name="996489"> </a>Custom operation to perform.</dd>

<dt><a name="996490"> </a><code>&harr;  <i><code>valueP</code></i></code></dt>
<dd><a name="996491"> </a>A pointer to a buffer containing data specific to the operation. On exit, depending on the function of the particular custom call and on the value of <code>valueLenP</code>, the contents of this buffer may have been updated.</dd>

<dt><a name="996492"> </a><code>&harr;  <i><code>valueLenP</code></i></code></dt>
<dd><a name="996493"> </a>On entry, points to the size of the <code>valueP</code> buffer. On exit, this value reflects the size of the data written to the <code>valueP</code> buffer. If <code>valueLenP</code> is <code>NULL</code>, <code>valueP</code> is passed to the file system but is not updated on exit.</dd>

</dl>
<h4>
  <a name="996494"> </a>Returns 
</h4>

<p><a name="996495"> </a>Returns one of the following error codes:</p>

<dl>
<dt><a name="996496"> </a><code><code>errNone</code></code></dt>
<dd><a name="996497"> </a>No error.</dd>

<dt><a name="996498"> </a><code><code>expErrNotOpen</code></code></dt>
<dd><a name="996499"> </a>The file system library necessary for this call has not been installed or has not been opened.</dd>

<dt><a name="996500"> </a><code><code>expErrUnsupportedOperation</code></code></dt>
<dd><a name="996501"> </a>The specified opcode and/or creator is unsupported or undefined.</dd>

<dt><a name="996502"> </a><code><code>sysErrParamErr</code></code></dt>
<dd><a name="996503"> </a>The <code>valueP</code> buffer is too small.</dd>

<dt><a name="996504"> </a><code><code>vfsErrNoFileSystem</code></code></dt>
<dd><a name="996505"> </a>VFS Manager cannot find an appropriate file system to handle the request.</dd>

</dl>
<h4>
  <a name="996506"> </a>Comments 
</h4>

<p><a name="996507"> </a>The driver identifies the call and its API by a registered creator ID and a selector. This allows file system developers to extend the API by defining selectors for their creator IDs. It also allows file system developers to support selectors (and custom calls) defined by other file system developers. </p>

<p><a name="996508"> </a>This function must return <code>expErrUnsupportedOperation</code> for all unsupported or undefined opcodes and/or creators.</p>
<h4>
  <a name="996509"> </a>Compatibility 
</h4>

<p><a name="996513"> </a>Implemented only if the <a href="CompatibilityApdx.html#996319">VFS Manager Feature Set</a> is present.</p>

<h3 class="hbH3">
  <a name="996516"> </a>VFSDirCreate Function <a href="#995797"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="996518"> </a>Purpose 
</h4>

<p><a name="996519"> </a>Create a new directory.</p>
<h4>
  <a name="996520"> </a>Declared In 
</h4>
<code>VfsMgr.h<a name="996521"> </a></code><h4>
  <a name="996522"> </a>Prototype 
</h4>
<pre class="proto"><a name="996523"></a>Err VFSDirCreate(
   UInt16 volRefNum,
   const Char *dirNameP
)
</pre>
<h4>
  <a name="996524"> </a>Parameters 
</h4>

<dl>
<dt><a name="996525"> </a><code>&rarr;  <i><code>volRefNum</code></i></code></dt>
<dd><a name="996526"> </a>Volume reference number returned from <a href="VFSMgr.html#998210"><code>VFSVolumeEnumerate()</code></a>.</dd>

<dt><a name="996530"> </a><code>&rarr;  <i><code>dirNameP</code></i></code></dt>
<dd><a name="996531"> </a>Pointer to the full path of the directory to be created.</dd>

</dl>
<h4>
  <a name="996532"> </a>Returns 
</h4>

<p><a name="996533"> </a>Returns one of the following error codes:</p>

<dl>
<dt><a name="996534"> </a><code><code>errNone</code> </code></dt>
<dd><a name="996535"> </a>No error</dd>

<dt><a name="996536"> </a><code><code>expErrNotOpen</code></code></dt>
<dd><a name="996537"> </a>The file system library necessary for this call has not been installed or has not been opened.</dd>

<dt><a name="996538"> </a><code><code>vfsErrBadName</code></code></dt>
<dd><a name="996539"> </a>Some or all of the path, up to but not including the last component specified in the <code>dirNameP</code> parameter, does not exist.</dd>

<dt><a name="996540"> </a><code><code>vfsErrFileAlreadyExists</code></code></dt>
<dd><a name="996541"> </a>A file with this name already exists in this location.</dd>

<dt><a name="996542"> </a><code><code>vfsErrNoFileSystem</code></code></dt>
<dd><a name="996543"> </a>The VFS Manager cannot find an appropriate file system to handle the request.</dd>

<dt><a name="996544"> </a><code><code>vfsErrVolumeBadRef</code></code></dt>
<dd><a name="996545"> </a>The volume has not been mounted.</dd>

<dt><a name="996546"> </a><code><code>vfsErrVolumeFull</code></code></dt>
<dd><a name="996547"> </a>There is not enough space left on the volume.</dd>

</dl>
<h4>
  <a name="996548"> </a>Comments 
</h4>

<p><a name="996549"> </a>All parts of the path except the last component must already exist. The <code>vfsFileAttrDirectory</code> attribute is set with this function.</p>

<p><a name="996553"> </a><a href="VFSMgr.html#996516"><code>VFSDirCreate()</code></a> does not open the directory. Any operations you want to perform on this directory require a reference, which is obtained through a call to <a href="VFSMgr.html#997263"><code>VFSFileOpen()</code></a>.</p>
<h4>
  <a name="996557"> </a>Compatibility 
</h4>

<p><a name="996561"> </a>Implemented only if the <a href="CompatibilityApdx.html#996319">VFS Manager Feature Set</a> is present.</p>

<h3 class="hbH3">
  <a name="996564"> </a>VFSDirEntryEnumerate Function <a href="#995797"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="996566"> </a>Purpose 
</h4>

<p><a name="996567"> </a>Enumerate the entries in a given directory. Entries can include files, links, and other directories.</p>
<h4>
  <a name="996568"> </a>Declared In 
</h4>
<code>VfsMgr.h<a name="996569"> </a></code><h4>
  <a name="996570"> </a>Prototype 
</h4>
<pre class="proto"><a name="996571"></a>Err VFSDirEntryEnumerate (
   FileRef dirRef,
   UInt32 *dirEntryIteratorP,
   FileInfoType *infoP
)
</pre>
<h4>
  <a name="996572"> </a>Parameters 
</h4>

<dl>
<dt><a name="996573"> </a><code>&rarr;  <i><code>dirRef</code></i></code></dt>
<dd><a name="996577"> </a>Directory reference returned from <a href="VFSMgr.html#997263"><code>VFSFileOpen()</code></a>.</dd>

<dt><a name="996578"> </a><code>&harr;  <i><code>dirEntryIteratorP </code></i></code></dt>
<dd><a name="996579"> </a>Pointer to the index of the last entry enumerated. For the first iteration, initialize this parameter to the constant <code>vfsIteratorStart</code>. Upon return, this references the next entry in the directory. If <code>infoP</code> is the last entry, this parameter is set to <code>vfsIteratorStop</code>.</dd>

<dt><a name="996580"> </a><code>&harr;  <i><code>infoP</code></i></code></dt>
<dd><a name="996584"> </a>Pointer to the <a href="VFSMgr.html#995833"><code>FileInfoType</code></a> data structure that contains information about the given directory entry. The <code>nameP</code> and <code>nameBufLen</code> fields in this structure must be initialized prior to calling <code>VFSDirEntryEnumerate</code>.</dd>

</dl>
<h4>
  <a name="996585"> </a>Returns 
</h4>

<p><a name="996586"> </a>Returns one of the following error codes:</p>

<dl>
<dt><a name="996587"> </a><code><code>errNone</code></code></dt>
<dd><a name="996588"> </a>No error.</dd>

<dt><a name="996589"> </a><code><code>expErrEnumerationEmpty</code></code></dt>
<dd><a name="996590"> </a>There are no directory entries left to enumerate.</dd>

<dt><a name="996591"> </a><code><code>expErrNotOpen</code></code></dt>
<dd><a name="996592"> </a>The file system library necessary for this call has not been installed or has not been opened.</dd>

<dt><a name="996593"> </a><code><code>sysErrParamErr</code></code></dt>
<dd><a name="996594"> </a>The <code>dirEntryIteratorP</code> is not valid.</dd>

<dt><a name="996595"> </a><code><code>vfsErrFileBadRef</code></code></dt>
<dd><a name="996596"> </a>The specified file reference is invalid.</dd>

<dt><a name="996597"> </a><code><code>vfsErrIsNotADirectory</code></code></dt>
<dd><a name="996598"> </a>The specified file reference is valid, but does not point to a directory. </dd>

<dt><a name="996599"> </a><code><code>vfsErrNoFileSystem</code></code></dt>
<dd><a name="996600"> </a>The VFS Manager cannot find an appropriate file system to handle the request.</dd>

</dl>
<h4>
  <a name="996601"> </a>Comments 
</h4>

<p><a name="996602"> </a>The directory to be enumerated must first be opened with <a href="VFSMgr.html#997263"><code>VFSFileOpen()</code></a> in order to obtain a file reference. In order to obtain information on all entries in a directory you must make repeated calls to <code>VFSDirEntryEnumerate</code> inside a loop. Boundaries on the iteration are the defined constants <code>vfsIteratorStart</code> and <code>vfsIteratorStop</code>. Before the first call to <code>VFSDirEntryEnumerate</code>, <code>dirEntryIteratorP</code> should be initialized to <code>vfsIteratorStart</code>. Each iteration then changes the value pointed to by <code>dirEntryIteratorP</code>. When information on the last entry in the directory is returned, <code>dirEntryIteratorP</code> is set to <code>vfsIteratorStop</code>.</p>

<div><hr>
  <a name="996606"> </a> <span class="warning">WARNING! </span> Creating, renaming, or deleting any file or directory invalidates the enumeration. After any such operation, the enumeration will need to be restarted.
<hr>
</div>
<h4>
  <a name="996607"> </a>Example 
</h4>

<p><a name="996608"> </a>The following code excerpt illustrates how to use <code>VFSDirEntryEnumerate</code>.</p>

<div class="CodeRule"><hr></div><pre class="CodeBlock">
FileInfoType info;<a name="996609"> </a>
FileRef dirRef;<a name="996610"> </a>
UInt32 dirIterator;<a name="996611"> </a>
Char *fileName = MemPtrNew(256);  // should check for err<a name="996612"> </a>
 <a name="996613"> </a>
// open the directory first, to get the directory reference<a name="996614"> </a>
// volRefNum must have already been defined<a name="996615"> </a>
err = VFSFileOpen(volRefNum, "/", vfsModeRead, &amp;dirRef);<a name="996616"> </a>
if(err == errNone) {<a name="996617"> </a>
 <a name="996618"> </a>
   info.nameP = fileName;    // point to local buffer<a name="996619"> </a>
   info.nameBufLen = 256;<a name="996620"> </a>
   dirIterator = vfsIteratorStart<a name="996621"> </a>
   while (dirIterator != vfsIteratorStop) {<a name="996622"> </a>
      // Get the next file<a name="996623"> </a>
      err = VFSDirEntryEnumerate (dirRef, &amp;dirIterator,
         &amp;info);<a name="996624"> </a>
      if (err == errNone) {<a name="996625"> </a>
         // Do something with the directory entry information<a name="996626"> </a>
         // Pull the attributes from info.attributes<a name="996627"> </a>
         // The file name is in fileName<a name="996628"> </a>
      } else {<a name="996629"> </a>
         // handle error, possibly by breaking out of the 
loop<a name="996630"> </a>
      }<a name="996631"> </a>
   } else {<a name="996632"> </a>
      // handle directory open error here<a name="996633"> </a>
   }<a name="996634"> </a>
   MemPtrFree(fileName);<a name="996635"> </a>
}<a name="996636"> </a>
</pre><div class="CodeRule"><hr></div>

<h4>
  <a name="996637"> </a>Compatibility 
</h4>

<p><a name="996641"> </a>Implemented only if the <a href="CompatibilityApdx.html#996319">VFS Manager Feature Set</a> is present.</p>

<h3 class="hbH3">
  <a name="996644"> </a>VFSExportDatabaseToFile Function <a href="#995797"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="996646"> </a>Purpose 
</h4>

<p><a name="996647"> </a>Save the specified database to a <code>.pdb</code> or .<code>prc</code> file on an external storage card. </p>
<h4>
  <a name="996648"> </a>Declared In 
</h4>
<code>VfsMgr.h<a name="996649"> </a></code><h4>
  <a name="996650"> </a>Prototype 
</h4>
<pre class="proto"><a name="996651"></a>Err VFSExportDatabaseToFile (
   UInt16 volRefNum,
   const Char *pathNameP,
   UInt16 cardNo,
   LocalID dbID
) 
</pre>
<h4>
  <a name="996652"> </a>Parameters 
</h4>

<dl>
<dt><a name="996653"> </a><code>&rarr;  <i><code>volRefNum</code></i></code></dt>
<dd><a name="996654"> </a>Volume on which the destination file should be created.</dd>

<dt><a name="996655"> </a><code>&rarr;  <i><code>pathNameP</code></i></code></dt>
<dd><a name="996656"> </a>Pointer to the complete path and name of the destination file to be created.</dd>

<dt><a name="996657"> </a><code>&rarr;  <i><code>cardNo</code></i></code></dt>
<dd><a name="996658"> </a>Card number on which the <code>.pdb</code> or <code>.prc</code> being exported resides.</dd>

<dt><a name="996659"> </a><code>&rarr;  <i><code>dbID</code></i></code></dt>
<dd><a name="996660"> </a>ID of the database being exported.</dd>

</dl>
<h4>
  <a name="996661"> </a>Returns 
</h4>

<p><a name="996662"> </a>Returns one of the following error codes:</p>

<dl>
<dt><a name="996663"> </a><code><code>errNone</code> </code></dt>
<dd><a name="996664"> </a>No error</dd>

<dt><a name="996665"> </a><code><code>expErrNotEnoughPower</code></code></dt>
<dd><a name="996666"> </a>There is insufficient battery power to perform the database export operation.</dd>

<dt><a name="996667"> </a><code><code>vfsErrBadName</code></code></dt>
<dd><a name="996668"> </a>The path name specified in <code>pathNameP</code> is not valid.</dd>

</dl>
<h4>
  <a name="996669"> </a>Comments 
</h4>

<p><a name="996670"> </a>This utility function exports a database from main memory to a <code>.pdb</code> or <code>.prc</code> file on an external storage card. This function is the opposite of <a href="VFSMgr.html#997916"><code>VFSImportDatabaseFromFile()</code></a>. It first creates the file specified in the <code>pathNameP</code> parameter with <a href="VFSMgr.html#996797"><code>VFSFileCreate()</code></a>. After opening the file the Exchange Manager function <a href="ExchangeManager.html#1055648"><code>ExgDBWrite()</code></a> is called with an internal callback function for exporting the file from the Data Manager. The Exchange Manager makes repeated calls to this callback function, which receives the data back in blocks. Once all the data has been exported, VFS Manager closes the file.</p>

<p><a name="996680"> </a>This function is used, for example, to copy applications from main memory to a storage card.</p>
<h4>
  <a name="996681"> </a>Compatibility 
</h4>

<p><a name="996685"> </a>Implemented only if the <a href="CompatibilityApdx.html#996319">VFS Manager Feature Set</a> is present.</p>
<h4>
  <a name="996686"> </a>See Also 
</h4>

<p><a name="996693"> </a><a href="VFSMgr.html#996699"><code>VFSExportDatabaseToFileCustom()</code></a>, <a href="VFSMgr.html#997807"><code>VFSFileWrite()</code></a>, <a href="VFSMgr.html#997916"><code>VFSImportDatabaseFromFile()</code></a></p>

<h3 class="hbH3">
  <a name="996699"> </a>VFSExportDatabaseToFileCustom Function <a href="#995797"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="996701"> </a>Purpose 
</h4>

<p><a name="996702"> </a>Saves the specified database to a .<code>pdb</code> or .<code>prc</code> file on an external storage card. This function differs from <a href="VFSMgr.html#996644"><code>VFSExportDatabaseToFile()</code></a> in that it allows you to track the progress of the export operation.</p>
<h4>
  <a name="996706"> </a>Declared In 
</h4>
<code>VfsMgr.h<a name="996707"> </a></code><h4>
  <a name="996708"> </a>Prototype 
</h4>
<pre class="proto"><a name="996709"></a>Err VFSExportDatabaseToFileCustom(
   UInt16 volRefNum,
   const Char *pathNameP,
   UInt16 cardNo,
   LocalID dbID,
   VFSExportProcPtr exportProcP,
   void *userDataP
) 
</pre>
<h4>
  <a name="996710"> </a>Parameters 
</h4>

<dl>
<dt><a name="996711"> </a><code>&rarr;  <i><code>volRefNum</code></i></code></dt>
<dd><a name="996712"> </a>Volume on which the destination file should be created.</dd>

<dt><a name="996713"> </a><code>&rarr;  <i><code>pathNameP</code></i></code></dt>
<dd><a name="996714"> </a>Pointer to the complete path and name of the destination file to be created.</dd>

<dt><a name="996715"> </a><code>&rarr;  <i><code>cardNo</code></i></code></dt>
<dd><a name="996716"> </a>Card number on which the <code>.pdb</code> or <code>.prc</code> being exported resides.</dd>

<dt><a name="996717"> </a><code>&rarr;  <i><code>dbID</code></i></code></dt>
<dd><a name="996718"> </a>ID of the database being exported.</dd>

<dt><a name="996719"> </a><code>&rarr;  <i><code>exportProcP</code></i></code></dt>
<dd><a name="996720"> </a>User-defined callback function that tracks the progress of the export. This function should allow the user to cancel the export. Pass <code>NULL</code> if you don't have a progress callback function. See <a href="VFSMgr.html#998658"><code>VFSExportProcPtr()</code></a> for the requirements of this function.</dd>

<dt><a name="996724"> </a><code>&rarr;  <i><code>userDataP</code></i></code></dt>
<dd><a name="996725"> </a>Pointer to any data you want to pass to the callback function specified in <code>exportProcP</code>. This information is not used internally by the VFS Manager. Pass <code>NULL</code> if you don't have a progress callback function or if that function doesn't need any such data.</dd>

</dl>
<h4>
  <a name="996726"> </a>Returns 
</h4>

<p><a name="996727"> </a>Returns one of the following error codes:</p>

<dl>
<dt><a name="996728"> </a><code><code>errNone </code></code></dt>
<dd><a name="996729"> </a>No error.</dd>

<dt><a name="996730"> </a><code><code>expErrNotEnoughPower</code></code></dt>
<dd><a name="996731"> </a>There is insufficient battery power to perform the database export operation.</dd>

<dt><a name="996732"> </a><code><code>vfsErrBadName</code></code></dt>
<dd><a name="996733"> </a>The path name specified in <code>pathNameP</code> is not valid.</dd>

</dl>

<p><a name="996734"> </a>This function can also return any error code other than <code>errNone</code> produced by your callback function.</p>
<h4>
  <a name="996735"> </a>Comments 
</h4>

<p><a name="996739"> </a>This function is similar to <a href="VFSMgr.html#996644"><code>VFSExportDatabaseToFile()</code></a> in that it exports a database from main memory to a <code>.pdb</code> or<code> .prc</code> file on an external storage card. It extends the functionality by allowing you to specify a callback function that tracks the progress of the export. It first creates the file specified in the <code>pathNameP</code> parameter with <a href="VFSMgr.html#996797"><code>VFSFileCreate()</code></a>. After opening the file, the Exchange Manager function <a href="ExchangeManager.html#1055648"><code>ExgDBWrite()</code></a> is called with an internal callback function for exporting the file from the Data Manager. Exchange Manager makes repeated calls to this function, which receives the data back in blocks. The progress tracker, if one has been specified, is also called every time a new chunk of data is passed back. Once all the data has been exported, the VFS Manager closes the file.</p>

<p><a name="996746"> </a>This function is used, for example, to copy applications from main memory to a storage card.</p>
<h4>
  <a name="996747"> </a>Compatibility 
</h4>

<p><a name="996751"> </a>Implemented only if the <a href="CompatibilityApdx.html#996319">VFS Manager Feature Set</a> is present.</p>
<h4>
  <a name="996752"> </a>See Also 
</h4>

<p><a name="996759"> </a><a href="VFSMgr.html#996644"><code>VFSExportDatabaseToFile()</code></a>, <a href="VFSMgr.html#997807"><code>VFSFileWrite()</code></a>, <a href="VFSMgr.html#997978"><code>VFSImportDatabaseFromFileCustom()</code></a></p>

<h3 class="hbH3">
  <a name="996765"> </a>VFSFileClose Function <a href="#995797"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="996767"> </a>Purpose 
</h4>

<p><a name="996768"> </a>Closes a file or directory that has been opened with <a href="VFSMgr.html#997263"><code>VFSFileOpen()</code></a>.</p>
<h4>
  <a name="996772"> </a>Declared In 
</h4>
<code>VfsMgr.h<a name="996773"> </a></code><h4>
  <a name="996774"> </a>Prototype 
</h4>
<pre class="proto"><a name="996775"></a>Err VFSFileClose (
   FileRef fileRef
)
</pre>
<h4>
  <a name="996776"> </a>Parameters 
</h4>

<dl>
<dt><a name="996777"> </a><code>&rarr;  <i><code>fileRef</code></i></code></dt>
<dd><a name="996781"> </a>File reference number returned from <a href="VFSMgr.html#997263"><code>VFSFileOpen()</code></a>.</dd>

</dl>
<h4>
  <a name="996782"> </a>Returns 
</h4>

<p><a name="996783"> </a>Returns one of the following error codes:</p>

<dl>
<dt><a name="996784"> </a><code><code>errNone</code> </code></dt>
<dd><a name="996785"> </a>No error.</dd>

<dt><a name="996786"> </a><code><code>expErrNotOpen</code></code></dt>
<dd><a name="996787"> </a>The file system library necessary for this call has not been installed or has not been opened.</dd>

<dt><a name="996788"> </a><code><code>vfsErrFileBadRef</code></code></dt>
<dd><a name="996789"> </a>The specified file reference is invalid.</dd>

</dl>
<h4>
  <a name="996790"> </a>Compatibility 
</h4>

<p><a name="996794"> </a>Implemented only if the <a href="CompatibilityApdx.html#996319">VFS Manager Feature Set</a> is present.</p>

<h3 class="hbH3">
  <a name="996797"> </a>VFSFileCreate Function <a href="#995797"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="996799"> </a>Purpose 
</h4>

<p><a name="996800"> </a>Create a file. This function cannot be used to create a directory; use <a href="VFSMgr.html#996516"><code>VFSDirCreate()</code></a> instead.</p>
<h4>
  <a name="996804"> </a>Declared In 
</h4>
<code>VfsMgr.h<a name="996805"> </a></code><h4>
  <a name="996806"> </a>Prototype 
</h4>
<pre class="proto"><a name="996807"></a>Err VFSFileCreate(
   UInt16 volRefNum,
   const Char *pathNameP
)
</pre>
<h4>
  <a name="996808"> </a>Parameters 
</h4>

<dl>
<dt><a name="996809"> </a><code>&rarr;  <i><code>volRefNum</code></i></code></dt>
<dd><a name="996810"> </a>Reference number of the volume on which to create the file. This volume reference number is returned from <a href="VFSMgr.html#998210"><code>VFSVolumeEnumerate()</code></a>.</dd>

<dt><a name="996814"> </a><code>&rarr;  <i><code>pathNameP</code></i></code></dt>
<dd><a name="996815"> </a>Pointer to the full path of the file to be created. All parts of the path, excluding the filename, must already exist.</dd>

</dl>
<h4>
  <a name="996816"> </a>Returns 
</h4>

<p><a name="996817"> </a>Returns one of the following error codes:</p>

<dl>
<dt><a name="996818"> </a><code><code>errNone</code> </code></dt>
<dd><a name="996819"> </a>No error.</dd>

<dt><a name="996820"> </a><code><code>expErrNotOpen</code></code></dt>
<dd><a name="996821"> </a>The file system library necessary for this call has not been installed or has not been opened.</dd>

<dt><a name="996822"> </a><code><code>vfsErrBadName</code></code></dt>
<dd><a name="996823"> </a>The <code>pathNameP</code> is invalid.</dd>

<dt><a name="996824"> </a><code><code>vfsErrFileAlreadyExists</code></code></dt>
<dd><a name="996825"> </a>A file with this name already exists in this location.</dd>

<dt><a name="996826"> </a><code><code>vfsErrNoFileSystem</code></code></dt>
<dd><a name="996827"> </a>The VFS Manager cannot find an appropriate file system to handle the request.</dd>

<dt><a name="996828"> </a><code><code>vfsErrVolumeBadRef</code></code></dt>
<dd><a name="996829"> </a>The volume has not been mounted.</dd>

<dt><a name="996830"> </a><code><code>vfsErrVolumeFull</code></code></dt>
<dd><a name="996831"> </a>There is not enough space left on the volume.</dd>

</dl>
<h4>
  <a name="996832"> </a>Comments 
</h4>

<p><a name="996833"> </a>It is the responsibility of the file system library to ensure that all filenames are translated into a format that is compatible with the native format of the file system, such as the 8.3 convention for a FAT file system without long filename support. See <a href="../PalmOSCompanion/ExpAndVFSConcepts.html#1032372">Naming Files</a> in the <a href="../PalmOSCompanion/ExpAndVFSConcepts.html#1031615">Expansion</a> chapter of the <i>Palm OS Programmer's Companion</i>, vol. I for a description of how to construct a valid path.</p>

<p><a name="996846"> </a>This function does not open the file. Use <a href="VFSMgr.html#997263"><code>VFSFileOpen()</code></a> to open the file. </p>

<p><a name="996847"> </a>This function should not be used to create a directory. To create a directory use <a href="VFSMgr.html#996516"><code>VFSDirCreate()</code></a>.</p>
<h4>
  <a name="996851"> </a>Compatibility 
</h4>

<p><a name="996855"> </a>Implemented only if the <a href="CompatibilityApdx.html#996319">VFS Manager Feature Set</a> is present.</p>
<h4>
  <a name="996856"> </a>See Also 
</h4>

<p><a name="996860"> </a><a href="VFSMgr.html#997086"><code>VFSFileDelete()</code></a></p>

<h3 class="hbH3">
  <a name="996863"> </a>VFSFileDBGetRecord Function <a href="#995797"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="996865"> </a>Purpose 
</h4>

<p><a name="996866"> </a>Load a record from an opened <code>.pdb</code> file on an external card into the storage heap.</p>
<h4>
  <a name="996867"> </a>Declared In 
</h4>
<code>VfsMgr.h<a name="996868"> </a></code><h4>
  <a name="996869"> </a>Prototype 
</h4>
<pre class="proto"><a name="996870"></a>Err VFSFileDBGetRecord (
   FileRef ref,
   UInt16 recIndex,
   MemHandle *recHP,
   UInt8 *recAttrP,
   UInt32 *uniqueIDP
)
</pre>
<h4>
  <a name="996871"> </a>Parameters 
</h4>

<dl>
<dt><a name="996872"> </a><code>&rarr;  <i><code>ref</code></i></code></dt>
<dd><a name="996876"> </a>The file reference returned from <a href="VFSMgr.html#997263"><code>VFSFileOpen()</code></a>. Note that the open file must be a <code>.pdb </code>file.</dd>

<dt><a name="996877"> </a><code>&rarr;  <i><code>recIndex</code></i></code></dt>
<dd><a name="996878"> </a>The index of the record to load.</dd>

<dt><a name="996879"> </a><code>&larr;  <i><code>recHP</code></i></code></dt>
<dd><a name="996880"> </a>Pointer to the record data's handle in the storage heap. If <code>NULL</code> is returned in this parameter there is either no data in this field or an error occurred reading this data from the file. If the handle is not <code>NULL</code>, you must dispose of the allocated handle using <a href="MemoryManager.html#1016400"><code>MemHandleFree()</code></a>. </dd>

<dt><a name="996884"> </a><code>&larr;  <i><code>recAttrP</code></i></code></dt>
<dd><a name="996885"> </a>Pointer to the attributes of the record. The values returned are identical to the atttributes returned from <a href="DataAndResourceManager.html#1011009"><code>DmRecordInfo()</code></a>. See <a href="DataAndResourceManager.html#1008189">Record Attribute Constants</a> in the <a href="DataAndResourceManager.html#1008042">Data and Resource Manager</a> chapter for a description of each attribute. Pass <code>NULL</code> for this parameter if you do not want to retrieve this information.</dd>

<dt><a name="996895"> </a><code>&larr;  <i><code>uniqueIDP</code></i></code></dt>
<dd><a name="996896"> </a>Pointer to the unique identifier for this record. Pass <code>NULL</code> for this parameter if you do not want to retrieve this information.</dd>

</dl>
<h4>
  <a name="996897"> </a>Returns 
</h4>

<p><a name="996898"> </a>Returns one of the following error codes:</p>

<dl>
<dt><a name="996899"> </a><code><code>errNone</code> </code></dt>
<dd><a name="996900"> </a>No error.</dd>

<dt><a name="996901"> </a><code><code>dmErrIndexOutOfRange</code></code></dt>
<dd><a name="996902"> </a>The <code>recIndex</code> is out of range.</dd>

<dt><a name="996903"> </a><code><code>dmErrNotRecordDB</code></code></dt>
<dd><a name="996904"> </a>The file referenced by <code>ref</code> is not a record database.</dd>

<dt><a name="996905"> </a><code><code>memErrNotEnoughSpace</code></code></dt>
<dd><a name="996906"> </a>There is not enough space in memory for the requested record entry.</dd>

<dt><a name="996907"> </a><code><code>sysErrParamErr</code></code></dt>
<dd><a name="996908"> </a>A <code>NULL</code> value was passed in for the <code>recHP</code>, <code>recAttrP</code>, and <code>uniqueIDP</code> parameters.</dd>

<dt><a name="996909"> </a><code><code>vfsErrBadData</code></code></dt>
<dd><a name="996910"> </a>The local offsets (<code>localChunkID</code>) from the top of the <code>.pdb</code> to the start of the raw record data for this entry are out of order.</dd>

</dl>
<h4>
  <a name="996911"> </a>Comments 
</h4>

<p><a name="996915"> </a>This function is analogous to <a href="DataAndResourceManager.html#1010008"><code>DmGetRecord()</code></a> but works with files on an external card rather than databases in main memory. This function allocates a handle of the appropriate size from the storage heap and returns it in the <code>recHP</code> parameter. The caller is responsible for freeing this memory, using <a href="MemoryManager.html#1016400"><code>MemHandleFree()</code></a>, when it is no longer needed.</p>

<div><hr>
  <a name="996919"> </a> <b>NOTE: </b> This function is not efficient for multiple accesses and should be used sparingly.
<hr>
</div>
<h4>
  <a name="996920"> </a>Compatibility 
</h4>

<p><a name="996924"> </a>Implemented only if the <a href="CompatibilityApdx.html#996319">VFS Manager Feature Set</a> is present.</p>
<h4>
  <a name="996925"> </a>See Also 
</h4>

<p><a name="996929"> </a><a href="VFSMgr.html#997389"><code>VFSFileReadData()</code></a></p>

<h3 class="hbH3">
  <a name="996932"> </a>VFSFileDBGetResource Function <a href="#995797"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="996934"> </a>Purpose 
</h4>

<p><a name="996935"> </a>Load a resource into the storage heap from an opened <code>.prc</code> file.</p>
<h4>
  <a name="996936"> </a>Declared In 
</h4>
<code>VfsMgr.h<a name="996937"> </a></code><h4>
  <a name="996938"> </a>Prototype 
</h4>
<pre class="proto"><a name="996939"></a>Err VFSFileDBGetResource (
   FileRef ref,
   DmResType type,
   DmResID resID,
   MemHandle *resHP
) 
</pre>
<h4>
  <a name="996940"> </a>Parameters 
</h4>

<dl>
<dt><a name="996941"> </a><code>&rarr;  <i><code>ref</code></i></code></dt>
<dd><a name="996945"> </a>The file reference returned from <a href="VFSMgr.html#997263"><code>VFSFileOpen()</code></a>. Note that the open file must be a <code>.prc</code> file.</dd>

<dt><a name="996946"> </a><code>&rarr;  <i><code>type</code></i></code></dt>
<dd><a name="996949"> </a>The type of resource to load. See the <a href="DataAndResourceManager.html#1008042">Data and Resource Manager</a> chapter for more information on resources.</dd>

<dt><a name="996951"> </a><code>&rarr;  <i><code>resID</code></i></code></dt>
<dd><a name="996952"> </a>The ID of resource to load.</dd>

<dt><a name="996953"> </a><code>&larr;  <i><code>resHP</code></i></code></dt>
<dd><a name="996954"> </a>Pointer to the resource data handle that was loaded into memory.</dd>

</dl>
<h4>
  <a name="996955"> </a>Returns 
</h4>

<p><a name="996956"> </a>Returns one of the following error codes:</p>

<dl>
<dt><a name="996957"> </a><code><code>errNone</code> </code></dt>
<dd><a name="996958"> </a>No error.</dd>

<dt><a name="996959"> </a><code><code>dmErrNotResourceDB</code></code></dt>
<dd><a name="996960"> </a>The file referenced by <code>ref</code> is not a resource database.</dd>

<dt><a name="996961"> </a><code><code>dmErrResourceNotFound</code></code></dt>
<dd><a name="996962"> </a>The requested resource was not found.</dd>

<dt><a name="996963"> </a><code><code>memErrNotEnoughSpace</code></code></dt>
<dd><a name="996964"> </a>There is not enough space in memory for the requested resource entries.</dd>

<dt><a name="996965"> </a><code><code>sysErrParamErr</code></code></dt>
<dd><a name="996966"> </a><code>resHP</code> is <code>NULL</code>.</dd>

</dl>
<h4>
  <a name="996967"> </a>Comments 
</h4>

<p><a name="996968"> </a>This function locates the specified resource in the open <code>.prc</code> file. See the <i>Palm OS File Format Specification</i> for more information on the layout of <code>.prc</code> files. </p>

<p><a name="996969"> </a>Once the resource is found, <code>VFSFileDBGetResource</code> allocates a handle of the appropriate size in the storage heap and reads it into memory. The handle to this memory location is returned through the <code>resHP</code> parameter. The caller is responsible for freeing this memory, using <a href="MemoryManager.html#1016400"><code>MemHandleFree()</code></a>, when it is no longer needed.</p>

<div><hr>
  <a name="996973"> </a> <b>NOTE: </b> This function is not efficient for multiple accesses and should be used sparingly.
<hr>
</div>
<h4>
  <a name="996974"> </a>Compatibility 
</h4>

<p><a name="996978"> </a>Implemented only if the <a href="CompatibilityApdx.html#996319">VFS Manager Feature Set</a> is present.</p>

<h3 class="hbH3">
  <a name="996981"> </a>VFSFileDBInfo Function <a href="#995797"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="996983"> </a>Purpose 
</h4>

<p><a name="996984"> </a>Get information about a database represented by an open <code>.prc</code> or <code>.pdb</code> file.</p>
<h4>
  <a name="996985"> </a>Declared In 
</h4>
<code>VfsMgr.h<a name="996986"> </a></code><h4>
  <a name="996987"> </a>Prototype 
</h4>
<pre class="proto"><a name="996988"></a>Err VFSFileDBInfo (
   FileRef ref,
   Char *nameP,
   UInt16 *attributesP,
   UInt16 *versionP,
   UInt32 *crDateP,
   UInt32 *modDateP,
   UInt32 *bckUpDateP,
   UInt32 *modNumP,
   MemHandle *appInfoHP,
   MemHandle *sortInfoHP,
   UInt32 *typeP,
   UInt32 *creatorP,
   UInt16 *numRecordsP
) 
</pre>
<h4>
  <a name="996989"> </a>Parameters 
</h4>

<dl>
<dt><a name="996990"> </a><code>&rarr;  <i><code>ref</code></i></code></dt>
<dd><a name="996994"> </a>The file reference returned from <a href="VFSMgr.html#997263"><code>VFSFileOpen()</code></a>. Note that the open file must be a <code>.prc</code> or <code>.pdb</code> file.</dd>

<dt><a name="996995"> </a><code>&larr;  <i><code>nameP</code></i></code></dt>
<dd><a name="996996"> </a>Pointer to a 32-byte character array in which the database name is returned. Pass <code>NULL</code> for this parameter if you do not want to retrieve the database name.</dd>

<dt><a name="996997"> </a><code>&larr;  <i><code>attributesP</code></i></code></dt>
<dd><a name="996998"> </a>Pointer to the database attributes stored in the file. The values returned are identical to the atttributes returned from <a href="DataAndResourceManager.html#1008974"><code>DmDatabaseInfo()</code></a>. See the <a href="DataAndResourceManager.html#1008258">Database Attribute Constants</a> section for a description of each attribute. Pass <code>NULL</code> for this parameter if you do not want to retrieve the database's attributes.</dd>

<dt><a name="997005"> </a><code>&larr;  <i><code>versionP</code></i></code></dt>
<dd><a name="997006"> </a>Pointer to the application-specific version number of the database. The default version number is zero (0). Pass <code>NULL</code> for this parameter if you do not want to retrieve the version number.</dd>

<dt><a name="997007"> </a><code>&larr;  <i><code>crDateP</code></i></code></dt>
<dd><a name="997008"> </a>Pointer to the date the database was created, expressed in seconds since midnight (00:00:00) January 1, 1904. Pass <code>NULL</code> for this parameter if you do not want to retrieve the creation date.</dd>

<dt><a name="997009"> </a><code>&larr;  <i><code>modDateP</code></i></code></dt>
<dd><a name="997010"> </a>Pointer to the date the database was last modified, expressed in seconds since midnight (00:00:00) January 1, 1904. A database's modification date is updated only if a change has been made to the database when it is opened with write access. Pass <code>NULL</code> for this parameter if you do not want to retrieve the database's modification date.</dd>

<dt><a name="997011"> </a><code>&larr;  <i><code>bckUpDateP</code></i></code></dt>
<dd><a name="997012"> </a>Pointer to the date the database was last backed up, expressed in seconds since midnight (00:00:00) January 1, 1904. Pass <code>NULL</code> for this parameter if you do not want to retrieve the database's backup date.</dd>

<dt><a name="997013"> </a><code>&larr;  <i><code>modNumP</code></i></code></dt>
<dd><a name="997014"> </a>Pointer to the number of times the database was modified. This number is updated every time a record is added, modified, or deleted. Pass <code>NULL</code> for this parameter if you do not want to retrieve the modification count.</dd>

<dt><a name="997015"> </a><code>&larr;  <i><code>appInfoHP</code></i></code></dt>
<dd><a name="997016"> </a>Pointer to the application info block handle. If <code>NULL</code> is returned in this parameter, either there is no data in this field or an error occurred reading this data from the file. If a value other than <code>NULL</code> is returned, you must dispose of the allocated handle using <a href="MemoryManager.html#1016400"><code>MemHandleFree()</code></a>. If you do not want to retrieve the application info block, pass <code>NULL</code> for this parameter</dd>

<dt><a name="997020"> </a><code>&larr;  <i><code>sortInfoHP</code></i></code></dt>
<dd><a name="997021"> </a>Pointer to the sort info block handle. If <code>NULL</code> is returned in this parameter, either there is no data in this field or an error occurred reading this data from the file. If a value other than <code>NULL</code> is returned, you must dispose of the allocated handle using <a href="MemoryManager.html#1016400"><code>MemHandleFree()</code></a>. Pass <code>NULL</code> for this parameter if you do not want to retrieve the sort info block handle.</dd>

<dt><a name="997025"> </a><code>&larr;  <i><code>typeP</code></i></code></dt>
<dd><a name="997026"> </a>Pointer to the type of database as it was created. This may be a user-defined database type or a database type defined by the Palm OS. Some of the more common database types returned here are:</dd>

</dl>


<div class="tablediv"><table cellspacing="0" class="tTable">

  <tr valign="top">
    <th><p class="tt"><a name="997029"> </a><b>Type</b></p>
    </th>
    <th><p class="tt"><a name="997031"> </a><b>Description</b></p>
    </th>
  </tr>
  <tr valign="top">
    <td><p class="tt"><a name="997033"> </a><code>'appl'</code></p>
    </td>
    <td><p class="tt"><a name="997035"> </a>Standard Palm<sup>&#8482;</sup> application (resource database)</p>
    </td>
  </tr>
  <tr valign="top">
    <td><p class="tt"><a name="997037"> </a><code>'libr'</code></p>
    </td>
    <td><p class="tt"><a name="997039"> </a>Standard shared library</p>
    </td>
  </tr>
  <tr valign="top">
    <td><p class="tt"><a name="997041"> </a><code>'libf'</code></p>
    </td>
    <td><p class="tt"><a name="997043"> </a>File system shared library</p>
    </td>
  </tr>
  <tr valign="top">
    <td><p class="tt"><a name="997045"> </a><code>'libs'</code></p>
    </td>
    <td><p class="tt"><a name="997047"> </a>Slot driver shared library</p>
    </td>
  </tr>
  <tr valign="top">
    <td><p class="tt"><a name="997049"> </a><code>'data'</code></p>
    </td>
    <td><p class="tt"><a name="997051"> </a>Standard Palm data file (record database)</p>
    </td>
  </tr>
</table>

</div>


<dl>
<dd><a name="997053"> </a>Pass <code>NULL</code> for this parameter if you do not want to retrieve the database's type.</dd>

<dt><a name="997054"> </a><code>&larr;  <i><code>creatorP</code></i></code></dt>
<dd><a name="997055"> </a>Pointer to the database's creator. Pass NULL for this parameter if you do not want to retrieve this information.</dd>

<dt><a name="997056"> </a><code>&larr;  <i><code>numRecordsP</code></i></code></dt>
<dd><a name="997057"> </a>Pointer to the number of records in the database. Pass <code>NULL</code> for this parameter if you do not want to retrieve this information.</dd>

</dl>
<h4>
  <a name="997058"> </a>Returns 
</h4>

<p><a name="997059"> </a>Returns one of the following error codes:</p>

<dl>
<dt><a name="997060"> </a><code><code>errNone</code> </code></dt>
<dd><a name="997061"> </a>No error</dd>

<dt><a name="997062"> </a><code><code>memErrNotEnoughSpace</code></code></dt>
<dd><a name="997063"> </a>There is not enough space in memory for the database header.</dd>

<dt><a name="997064"> </a><code><code>vfsErrBadData</code></code></dt>
<dd><a name="997065"> </a>The file referenced by the <code>ref</code> parameter is too small to contain a database header, or the database header is corrupted.</dd>

</dl>
<h4>
  <a name="997066"> </a>Comments 
</h4>

<p><a name="997070"> </a>This function is analogous to <a href="DataAndResourceManager.html#1008974"><code>DmDatabaseInfo()</code></a>, but it works with files on an external card rather than with databases in main memory. See the <i>Palm OS File Format Specification </i>for a description of the header block in  <code>.prc</code> and <code>.pdb </code>files. </p>
<h4>
  <a name="997071"> </a>Compatibility 
</h4>

<p><a name="997075"> </a>Implemented only if the <a href="CompatibilityApdx.html#996319">VFS Manager Feature Set</a> is present.</p>
<h4>
  <a name="997076"> </a>See Also 
</h4>

<p><a name="997083"> </a><a href="VFSMgr.html#997164"><code>VFSFileGetAttributes()</code></a>, <a href="VFSMgr.html#997211"><code>VFSFileGetDate()</code></a></p>

<h3 class="hbH3">
  <a name="997086"> </a>VFSFileDelete Function <a href="#995797"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="997088"> </a>Purpose 
</h4>

<p><a name="997089"> </a>Deletes a closed file or directory.</p>
<h4>
  <a name="997090"> </a>Declared In 
</h4>
<code>VfsMgr.h<a name="997091"> </a></code><h4>
  <a name="997092"> </a>Prototype 
</h4>
<pre class="proto"><a name="997093"></a>Err VFSFileDelete(
   UInt16 volRefNum,
   const Char *pathNameP
)
</pre>
<h4>
  <a name="997094"> </a>Parameters 
</h4>

<dl>
<dt><a name="997095"> </a><code>&rarr;  <i><code>volRefNum</code></i></code></dt>
<dd><a name="997096"> </a>Volume reference number returned from <a href="VFSMgr.html#998210"><code>VFSVolumeEnumerate()</code></a>.</dd>

<dt><a name="997100"> </a><code>&rarr;  <i><code>pathNameP</code></i></code></dt>
<dd><a name="997101"> </a>Pointer to the full path of the file or directory to be deleted.</dd>

</dl>
<h4>
  <a name="997102"> </a>Returns 
</h4>

<p><a name="997103"> </a>Returns one of the following error codes:</p>

<dl>
<dt><a name="997104"> </a><code><code>errNone</code> </code></dt>
<dd><a name="997105"> </a>No error.</dd>

<dt><a name="997106"> </a><code><code>expErrNotOpen</code></code></dt>
<dd><a name="997107"> </a>The file system library necessary for this call has not been installed or has not been opened.</dd>

<dt><a name="997108"> </a><code><code>vfsErrBadName</code></code></dt>
<dd><a name="997109"> </a>The path name specified in <code>pathNameP</code> is not valid.</dd>

<dt><a name="997110"> </a><code><code>vfsErrDirNotEmpty</code></code></dt>
<dd><a name="997111"> </a>The directory being deleted is not empty.</dd>

<dt><a name="997112"> </a><code><code>vfsErrFileStillOpen</code></code></dt>
<dd><a name="997113"> </a>The file is still open.</dd>

<dt><a name="997114"> </a><code><code>vfsErrFileNotFound</code></code></dt>
<dd><a name="997115"> </a>The file could not be found.</dd>

<dt><a name="997116"> </a><code><code>vfsErrFilePermissionDenied</code></code></dt>
<dd><a name="997117"> </a>The requested permissions could not be granted.</dd>

<dt><a name="997118"> </a><code><code>vfsErrNoFileSystem</code></code></dt>
<dd><a name="997119"> </a>The VFS Manager cannot find an appropriate file system to handle the request.</dd>

<dt><a name="997120"> </a><code><code>vfsErrVolumeBadRef</code></code></dt>
<dd><a name="997121"> </a>The volume has not been mounted.</dd>

</dl>
<h4>
  <a name="997122"> </a>Compatibility 
</h4>

<p><a name="997126"> </a>Implemented only if the <a href="CompatibilityApdx.html#996319">VFS Manager Feature Set</a> is present.</p>

<h3 class="hbH3">
  <a name="997129"> </a>VFSFileEOF Function <a href="#995797"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="997131"> </a>Purpose 
</h4>

<p><a name="997132"> </a>Get end-of-file status for an open file. This function only operates on files and cannot be used with directories.</p>
<h4>
  <a name="997133"> </a>Declared In 
</h4>
<code>VfsMgr.h<a name="997134"> </a></code><h4>
  <a name="997135"> </a>Prototype 
</h4>
<pre class="proto"><a name="997136"></a>Err VFSFileEOF (
   FileRef fileRef
)
</pre>
<h4>
  <a name="997137"> </a>Parameters 
</h4>

<dl>
<dt><a name="997138"> </a><code>&rarr;  <i><code>fileRef</code></i></code></dt>
<dd><a name="997142"> </a>File reference returned from <a href="VFSMgr.html#997263"><code>VFSFileOpen()</code></a>.</dd>

</dl>
<h4>
  <a name="997143"> </a>Returns 
</h4>

<p><a name="997144"> </a>Returns one of the following error codes:</p>

<dl>
<dt><a name="997145"> </a><code><code>errNone</code> </code></dt>
<dd><a name="997146"> </a>No error. File pointer is not at end of the file.</dd>

<dt><a name="997147"> </a><code><code>vfsErrFileEOF</code></code></dt>
<dd><a name="997148"> </a>The file pointer is at the end of file.</dd>

<dt><a name="997149"> </a><code><code>expErrNotOpen</code></code></dt>
<dd><a name="997150"> </a>The file system library necessary for this call has not been installed or has not been opened.</dd>

<dt><a name="997151"> </a><code><code>vfsErrFileBadRef</code></code></dt>
<dd><a name="997152"> </a>The specified file reference is invalid.</dd>

<dt><a name="997153"> </a><code><code>vfsErrIsADirectory</code></code></dt>
<dd><a name="997154"> </a>The specified file reference points to a directory instead of a file. This is an invalid operation on a directory.</dd>

<dt><a name="997155"> </a><code><code>vfsErrNoFileSystem</code></code></dt>
<dd><a name="997156"> </a>The VFS Manager cannot find an appropriate file system to handle the request.</dd>

</dl>
<h4>
  <a name="997157"> </a>Compatibility 
</h4>

<p><a name="997161"> </a>Implemented only if the <a href="CompatibilityApdx.html#996319">VFS Manager Feature Set</a> is present.</p>

<h3 class="hbH3">
  <a name="997164"> </a>VFSFileGetAttributes Function <a href="#995797"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="997166"> </a>Purpose 
</h4>

<p><a name="997167"> </a>Obtain the attributes of an open file or directory.</p>
<h4>
  <a name="997168"> </a>Declared In 
</h4>
<code>VfsMgr.h<a name="997169"> </a></code><h4>
  <a name="997170"> </a>Prototype 
</h4>
<pre class="proto"><a name="997171"></a>Err VFSFileGetAttributes (
   FileRef fileRef,
   UInt32 *attributesP
)
</pre>
<h4>
  <a name="997172"> </a>Parameters 
</h4>

<dl>
<dt><a name="997173"> </a><code>&rarr;  <i><code>fileRef</code></i></code></dt>
<dd><a name="997177"> </a>File reference returned from <a href="VFSMgr.html#997263"><code>VFSFileOpen()</code></a>.</dd>

<dt><a name="997178"> </a><code>&larr;  <i><code>attributesP</code></i></code></dt>
<dd><a name="997179"> </a>Pointer to the attributes associated with the file or directory. See <a href="VFSMgr.html#996221">File and Directory Attributes</a> for a list of values that can be returned through this parameter.</dd>

</dl>
<h4>
  <a name="997183"> </a>Returns 
</h4>

<p><a name="997184"> </a>Returns one of the following error codes:</p>

<dl>
<dt><a name="997185"> </a><code><code>errNone</code> </code></dt>
<dd><a name="997186"> </a>No error</dd>

<dt><a name="997187"> </a><code><code>expErrNotOpen</code></code></dt>
<dd><a name="997188"> </a>The file system library necessary for this call has not been installed or has not been opened.</dd>

<dt><a name="997189"> </a><code><code>vfsErrFileBadRef</code></code></dt>
<dd><a name="997190"> </a>The specified file reference is invalid.</dd>

<dt><a name="997191"> </a><code><code>vfsErrNoFileSystem</code></code></dt>
<dd><a name="997192"> </a>The VFS Manager cannot find an appropriate file system to handle the request.</dd>

</dl>
<h4>
  <a name="997193"> </a>Compatibility 
</h4>

<p><a name="997197"> </a>Implemented only if the <a href="CompatibilityApdx.html#996319">VFS Manager Feature Set</a> is present.</p>
<h4>
  <a name="997198"> </a>See Also 
</h4>

<p><a name="997205"> </a><a href="VFSMgr.html#996981"><code>VFSFileDBInfo()</code></a>, <a href="VFSMgr.html#997211"><code>VFSFileGetDate()</code></a>, <a href="VFSMgr.html#997611"><code>VFSFileSetAttributes()</code></a></p>

<h3 class="hbH3">
  <a name="997211"> </a>VFSFileGetDate Function <a href="#995797"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="997213"> </a>Purpose 
</h4>

<p><a name="997214"> </a>Obtain the dates on an open file or directory.</p>
<h4>
  <a name="997215"> </a>Declared In 
</h4>
<code>VfsMgr.h<a name="997216"> </a></code><h4>
  <a name="997217"> </a>Prototype 
</h4>
<pre class="proto"><a name="997218"></a>Err VFSFileGetDate (
   FileRef fileRef,
   UInt16 whichDate,
   UInt32 *dateP
)
</pre>
<h4>
  <a name="997219"> </a>Parameters 
</h4>

<dl>
<dt><a name="997220"> </a><code>&rarr;  <i><code>fileRef</code></i></code></dt>
<dd><a name="997224"> </a>File reference returned from <a href="VFSMgr.html#997263"><code>VFSFileOpen()</code></a>.</dd>

<dt><a name="997225"> </a><code>&rarr;  <i><code>whichDate</code></i></code></dt>
<dd><a name="997226"> </a>Specifies which date&#8212;creation, modification, or last access&#8212;you want. Supply one of the following values:</dd>

<dt><a name="997227"> </a><code><code>vfsFileDateCreated</code></code></dt>
<dt><a name="997228"> </a><code><code>vfsFileDateModified</code></code></dt>
<dt><a name="997229"> </a><code><code>vfsFileDateAccessed</code></code></dt>
<dd><a name="997230"> </a>Note that not all file systems are required to support the above dates. If the supplied date type is not supported by the file system, <code>VFSFileGetDate</code> returns <code>expErrUnsupportedOperation</code>. </dd>

<dt><a name="997231"> </a><code>&larr;  <i><code>dateP</code></i></code></dt>
<dd><a name="997232"> </a>Pointer to the requested date. This field is expressed in the standard Palm OS date format &#8212; the number of seconds since midnight (00:00:00) January 1, 1904. </dd>

</dl>
<h4>
  <a name="997233"> </a>Returns 
</h4>

<p><a name="997234"> </a>Returns one of the following error codes:</p>

<dl>
<dt><a name="997235"> </a><code><code>errNone</code> </code></dt>
<dd><a name="997236"> </a>No error.</dd>

<dt><a name="997237"> </a><code><code>expErrNotOpen</code></code></dt>
<dd><a name="997238"> </a>The file system library necessary for this call has not been installed or has not been opened.</dd>

<dt><a name="997239"> </a><code><code>expErrUnsupportedOperation</code></code></dt>
<dd><a name="997240"> </a>The specified date type is not supported by the underlying file system.</dd>

<dt><a name="997241"> </a><code><code>vfsErrFileBadRef</code></code></dt>
<dd><a name="997242"> </a>The specified file reference is invalid.</dd>

<dt><a name="997243"> </a><code><code>sysErrParamErr</code></code></dt>
<dd><a name="997244"> </a>The <code>whichDate</code> parameter is not one of the defined constants.</dd>

</dl>
<h4>
  <a name="997245"> </a>Compatibility 
</h4>

<p><a name="997249"> </a>Implemented only if the <a href="CompatibilityApdx.html#996319">VFS Manager Feature Set</a> is present.</p>
<h4>
  <a name="997250"> </a>See Also 
</h4>

<p><a name="997257"> </a><a href="VFSMgr.html#996981"><code>VFSFileDBInfo()</code></a>, <a href="VFSMgr.html#997164"><code>VFSFileGetAttributes()</code></a>, <a href="VFSMgr.html#997665"><code>VFSFileSetDate()</code></a></p>

<h3 class="hbH3">
  <a name="997263"> </a>VFSFileOpen Function <a href="#995797"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="997265"> </a>Purpose 
</h4>

<p><a name="997266"> </a>Opens a file or directory and returns a reference for it.</p>
<h4>
  <a name="997267"> </a>Declared In 
</h4>
<code>VfsMgr.h<a name="997268"> </a></code><h4>
  <a name="997269"> </a>Prototype 
</h4>
<pre class="proto"><a name="997271"></a>Err VFSFileOpen (
   UInt16 volRefNum,
   const Char *pathNameP,
   UInt16 openMode,
   FileRef *fileRefP
)
</pre>
<h4>
  <a name="997272"> </a>Parameters 
</h4>

<dl>
<dt><a name="997273"> </a><code>&rarr;  <i><code>volRefNum</code></i></code></dt>
<dd><a name="997274"> </a>The volume reference number returned from <a href="VFSMgr.html#998210"><code>VFSVolumeEnumerate()</code></a>.</dd>

<dt><a name="997278"> </a><code>&rarr;  <i><code>pathNameP</code></i></code></dt>
<dd><a name="997279"> </a>Pointer to the full path of the file or directory to be opened. This must be a valid path. It cannot be empty and can not contain null characters. The format of the pathname should match what the underlying file system supports. See <a href="../PalmOSCompanion/ExpAndVFSConcepts.html#1032372">"Naming Files"</a> in <a href="../PalmOSCompanion/ExpAndVFSConcepts.html#1031615">Chapter 7, "Expansion,"</a> of the <i>Palm OS Programmer's Companion</i>, vol. I for a description of how to construct a valid path.</dd>

<dt><a name="997289"> </a><code>&rarr;  <i><code>openMode</code></i></code></dt>
<dd><a name="997292"> </a>Mode to use when opening the file. See the <a href="VFSMgr.html#996150">Open Mode Constants</a> section for a list of accepted modes.</dd>

<dt><a name="997294"> </a><code>&larr;  <i><code>fileRefP</code></i></code></dt>
<dd><a name="997295"> </a>Pointer to the opened file or directory reference which is supplied to various other <code>VFSFile... </code>operations. This value is filled in on return.</dd>

</dl>
<h4>
  <a name="997296"> </a>Returns 
</h4>

<p><a name="997297"> </a>Returns one of the following error codes:</p>

<dl>
<dt><a name="997298"> </a><code><code>errNone</code> </code></dt>
<dd><a name="997299"> </a>No error.</dd>

<dt><a name="997300"> </a><code><code>expErrCardReadOnly</code></code></dt>
<dd><a name="997301"> </a>The open mode requested includes write access but the file is read-only.</dd>

<dt><a name="997302"> </a><code><code>expErrNotOpen</code></code></dt>
<dd><a name="997303"> </a>The file system library necessary for this call has not been installed or has not been opened.</dd>

<dt><a name="997304"> </a><code><code>vfsErrBadName</code></code></dt>
<dd><a name="997305"> </a>The <code>pathNameP</code> parameter is invalid.</dd>

<dt><a name="997306"> </a><code><code>vfsErrFileNotFound</code></code></dt>
<dd><a name="997307"> </a>The specified file or directory could not be found.</dd>

<dt><a name="997308"> </a><code><code>vfsErrFilePermissionDenied</code></code></dt>
<dd><a name="997309"> </a>The file cannot be opened in the requested open mode, or it has already been opened with <code>vfsModeExclusive</code>.</dd>

<dt><a name="997310"> </a><code><code>vfsErrVolumeBadRef</code></code></dt>
<dd><a name="997311"> </a>The specified volume has not been mounted.</dd>

</dl>
<h4>
  <a name="997312"> </a>Compatibility 
</h4>

<p><a name="997316"> </a>Implemented only if the <a href="CompatibilityApdx.html#996319">VFS Manager Feature Set</a> is present.</p>
<h4>
  <a name="997317"> </a>See Also 
</h4>

<p><a name="997324"> </a><a href="VFSMgr.html#996765"><code>VFSFileClose()</code></a>, <a href="VFSMgr.html#996564"><code>VFSDirEntryEnumerate()</code></a></p>

<h3 class="hbH3">
  <a name="997327"> </a>VFSFileRead Function <a href="#995797"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="997329"> </a>Purpose 
</h4>

<p><a name="997330"> </a>Read data from a file into the dynamic heap. This function only operates on files and cannot be used with directories; use <a href="VFSMgr.html#996564"><code>VFSDirEntryEnumerate()</code></a> to explore the contents of a directory.</p>
<h4>
  <a name="997334"> </a>Declared In 
</h4>
<code>VfsMgr.h<a name="997335"> </a></code><h4>
  <a name="997336"> </a>Prototype 
</h4>
<pre class="proto"><a name="997337"></a>Err VFSFileRead (
   FileRef fileRef,
   UInt32 numBytes,
   void *bufP,
   UInt32 *numBytesReadP
)
</pre>
<h4>
  <a name="997338"> </a>Parameters 
</h4>

<dl>
<dt><a name="997339"> </a><code>&rarr;  <i><code>fileRef</code></i></code></dt>
<dd><a name="997343"> </a>File reference returned from <a href="VFSMgr.html#997263"><code>VFSFileOpen()</code></a>.</dd>

<dt><a name="997344"> </a><code>&rarr;  <i><code>numBytes</code></i></code></dt>
<dd><a name="997345"> </a>Number of bytes to read.</dd>

<dt><a name="997346"> </a><code>&larr;  <i><code>bufP</code></i></code></dt>
<dd><a name="997347"> </a>Pointer to the destination chunk where the data is to be stored. This can be a pointer to any writable memory.</dd>

<dt><a name="997348"> </a><code>&larr;  <i><code>numBytesReadP</code></i></code></dt>
<dd><a name="997349"> </a>Pointer to an unsigned integer that reflects the number of bytes actually read. This value is set on return and does not need to be initialized. If no bytes are read the value is set to zero. Pass <code>NULL</code> for this parameter if you do not need to know how many bytes were read.</dd>

</dl>
<h4>
  <a name="997350"> </a>Returns 
</h4>

<p><a name="997351"> </a>Returns one of the following error codes:</p>

<dl>
<dt><a name="997352"> </a><code><code>errNone</code> </code></dt>
<dd><a name="997353"> </a>No error.</dd>

<dt><a name="997354"> </a><code><code>expErrNotOpen</code></code></dt>
<dd><a name="997355"> </a>The file system library necessary for this call has not been installed or has not been opened.</dd>

<dt><a name="997356"> </a><code><code>vfsErrFileBadRef</code></code></dt>
<dd><a name="997357"> </a>The specified file reference is invalid.</dd>

<dt><a name="997358"> </a><code><code>vfsErrFileEOF</code></code></dt>
<dd><a name="997359"> </a>The end of the file has been reached.</dd>

<dt><a name="997360"> </a><code><code>vfsErrFilePermissionDenied</code></code></dt>
<dd><a name="997361"> </a>Read permission is not enabled for this file.</dd>

<dt><a name="997362"> </a><code><code>vfsErrIsADirectory</code></code></dt>
<dd><a name="997363"> </a>The specified file reference is for a directory instead of a file. This is an invalid operation on a directory.</dd>

<dt><a name="997364"> </a><code><code>vfsErrNoFileSystem</code></code></dt>
<dd><a name="997365"> </a>The VFS Manager cannot find an appropriate file system to handle the request.</dd>

</dl>
<h4>
  <a name="997366"> </a>Comments 
</h4>

<p><a name="997370"> </a>The file system does not use <a href="DataAndResourceManager.html#1052867"><code>DmWrite()</code></a> and cannot be used to read data into the storage heap.</p>
<h4>
  <a name="997371"> </a>Compatibility 
</h4>

<p><a name="997375"> </a>Implemented only if the <a href="CompatibilityApdx.html#996319">VFS Manager Feature Set</a> is present.</p>
<h4>
  <a name="997376"> </a>See Also 
</h4>

<p><a name="997383"> </a><a href="VFSMgr.html#997389"><code>VFSFileReadData()</code></a>, <a href="VFSMgr.html#997807"><code>VFSFileWrite()</code></a>, <a href="VFSMgr.html#997916"><code>VFSImportDatabaseFromFile()</code></a></p>

<h3 class="hbH3">
  <a name="997389"> </a>VFSFileReadData Function <a href="#995797"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="997391"> </a>Purpose 
</h4>

<p><a name="997392"> </a>Read data from a file into a chunk of memory in the storage heap. This function only operates on files and cannot be used with directories; use <a href="VFSMgr.html#996564"><code>VFSDirEntryEnumerate()</code></a> to explore the contents of a directory.</p>
<h4>
  <a name="997396"> </a>Declared In 
</h4>
<code>VfsMgr.h<a name="997397"> </a></code><h4>
  <a name="997398"> </a>Prototype 
</h4>
<pre class="proto"><a name="997399"></a>Err VFSFileReadData (
   FileRef fileRef,
   UInt32 numBytes,
   void *bufBaseP,
   UInt32 offset,
   UInt32 *numBytesReadP
)
</pre>
<h4>
  <a name="997400"> </a>Parameters 
</h4>

<dl>
<dt><a name="997401"> </a><code>&rarr;  <i><code>fileRef</code></i></code></dt>
<dd><a name="997405"> </a>File reference returned in <a href="VFSMgr.html#997263"><code>VFSFileOpen()</code></a>.</dd>

<dt><a name="997406"> </a><code>&rarr;  <i><code>numBytes</code></i></code></dt>
<dd><a name="997407"> </a>Number of bytes to read.</dd>

<dt><a name="997408"> </a><code>&larr;  <i><code>bufBaseP</code></i></code></dt>
<dd><a name="997409"> </a>Pointer to the destination chunk in the storage heap where the data is to be stored. This pointer must be obtained through the appropriate call to the <a href="MemoryManager.html#1016260">Memory Manager</a> API.</dd>

<dt><a name="997413"> </a><code>&rarr;  <i><code>offset</code></i></code></dt>
<dd><a name="997414"> </a>Offset, in bytes, within the <code>bufBaseP</code> chunk where the data is to be written. </dd>

<dt><a name="997415"> </a><code>&larr;  <i><code>numBytesReadP</code></i></code></dt>
<dd><a name="997416"> </a>Pointer to an unsigned integer that reflects the number of bytes actually read. This value is set on return and does not need to be initialized. If no bytes are read, the value is set to zero. Pass <code>NULL</code> for this parameter if you do not need to know how many bytes were read.</dd>

</dl>
<h4>
  <a name="997417"> </a>Returns 
</h4>

<p><a name="997418"> </a>Returns one of the following error codes:</p>

<dl>
<dt><a name="997419"> </a><code><code>errNone</code> </code></dt>
<dd><a name="997420"> </a>No error.</dd>

<dt><a name="997421"> </a><code><code>expErrNotOpen</code></code></dt>
<dd><a name="997422"> </a>The file system library necessary for this call has not been installed or has not been opened.</dd>

<dt><a name="997423"> </a><code><code>vfsErrFileBadRef</code></code></dt>
<dd><a name="997424"> </a>The specified file reference is invalid.</dd>

<dt><a name="997425"> </a><code><code>vfsErrFileEOF</code></code></dt>
<dd><a name="997426"> </a>The end of the file has been reached.</dd>

<dt><a name="997427"> </a><code><code>vfsErrFilePermissionDenied</code></code></dt>
<dd><a name="997428"> </a>Read permission is not enabled for this file.</dd>

<dt><a name="997429"> </a><code><code>vfsErrIsADirectory</code></code></dt>
<dd><a name="997430"> </a>The specified file reference is for a directory instead of a file. This is an invalid operation on a directory.</dd>

<dt><a name="997431"> </a><code><code>vfsErrNoFileSystem</code></code></dt>
<dd><a name="997432"> </a>The VFS Manager cannot find an appropriate file system to handle the request.</dd>

</dl>
<h4>
  <a name="997433"> </a>Comments 
</h4>

<p><a name="997434"> </a>When data is read from an external card with <code>VFSFileReadData</code>, it is copied into a chunk of memory in the storage heap. This chunk <i>must</i> be allocated by the application before the call to <a href="VFSMgr.html#997389"><code>VFSFileReadData()</code></a>. This function calls <a href="DataAndResourceManager.html#1052867"><code>DmWrite()</code></a> to put the data in the storage heap. </p>
<h4>
  <a name="997441"> </a>Compatibility 
</h4>

<p><a name="997445"> </a>Implemented only if the <a href="CompatibilityApdx.html#996319">VFS Manager Feature Set</a> is present.</p>
<h4>
  <a name="997446"> </a>See Also 
</h4>

<p><a name="997453"> </a><a href="VFSMgr.html#997327"><code>VFSFileRead()</code></a>, <a href="VFSMgr.html#997807"><code>VFSFileWrite()</code></a></p>

<h3 class="hbH3">
  <a name="997456"> </a>VFSFileRename Function <a href="#995797"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="997458"> </a>Purpose 
</h4>

<p><a name="997459"> </a>Rename a closed file or directory. This function cannot be used to move a file to another directory within the file system.</p>
<h4>
  <a name="997460"> </a>Declared In 
</h4>
<code>VfsMgr.h<a name="997461"> </a></code><h4>
  <a name="997462"> </a>Prototype 
</h4>
<pre class="proto"><a name="997463"></a>Err VFSFileRename (
   UInt16 volRefNum,
   const Char *pathNameP,
   const Char *newNameP
)
</pre>
<h4>
  <a name="997464"> </a>Parameters 
</h4>

<dl>
<dt><a name="997465"> </a><code>&rarr;  <i><code>volRefNum</code></i></code></dt>
<dd><a name="997466"> </a>Volume reference number returned from <a href="VFSMgr.html#998210"><code>VFSVolumeEnumerate()</code></a>.</dd>

<dt><a name="997470"> </a><code>&rarr;  <i><code>pathNameP</code></i></code></dt>
<dd><a name="997471"> </a>Pointer to the full path of the file or directory to be renamed.</dd>

<dt><a name="997472"> </a><code>&rarr;  <i><code>newNameP</code></i></code></dt>
<dd><a name="997473"> </a>Pointer to the new filename. Note that this is the name of the file only and does not include the path to the file.</dd>

</dl>
<h4>
  <a name="997474"> </a>Returns 
</h4>

<p><a name="997475"> </a>Returns one of the following error codes:</p>

<dl>
<dt><a name="997476"> </a><code><code>errNone</code> </code></dt>
<dd><a name="997477"> </a>No error.</dd>

<dt><a name="997478"> </a><code><code>expErrNotOpen</code></code></dt>
<dd><a name="997479"> </a>The file system library necessary for this call has not been installed or has not been opened.</dd>

<dt><a name="997480"> </a><code><code>vfsErrBadName</code></code></dt>
<dd><a name="997481"> </a>The name provided in either <code>pathNameP</code> or <code>newNameP</code> is invalid. This is also returned if the string pointed to by <code>newNameP</code> is a path, rather than a filename.</dd>

<dt><a name="997482"> </a><code><code>vfsErrFileAlreadyExists</code></code></dt>
<dd><a name="997483"> </a>A file with the new name already exists in this location.</dd>

<dt><a name="997484"> </a><code><code>vfsErrFileNotFound</code></code></dt>
<dd><a name="997485"> </a>The source file could not be found.</dd>

<dt><a name="997486"> </a><code><code>vfsErrFilePermissionDenied</code></code></dt>
<dd><a name="997487"> </a>Write permission is not enabled for this file.</dd>

<dt><a name="997488"> </a><code><code>vfsErrNoFileSystem</code></code></dt>
<dd><a name="997489"> </a>The VFS Manager cannot find an appropriate file system to handle the request.</dd>

<dt><a name="997490"> </a><code><code>vfsErrVolumeBadRef</code></code></dt>
<dd><a name="997491"> </a>The volume has not been mounted.</dd>

<dt><a name="997492"> </a><code><code>vfsErrVolumeFull</code></code></dt>
<dd><a name="997493"> </a>There is not enough space left on the volume.</dd>

</dl>
<h4>
  <a name="997494"> </a>Comments 
</h4>

<div><hr>
  <a name="997495"> </a> <span class="warning">WARNING! </span> This function invalidates directory enumeration. You cannot continue enumerating files after renaming one of them with this function. If you need to operate on additional files in the directory, you must first restart the enumeration.
<hr>
</div>
<h4>
  <a name="997496"> </a>Example 
</h4>

<p><a name="997497"> </a>Below is an example of how to use <code>VFSFileRename</code>. Note that the renamed file remains in the <code>/PALM/Programs</code> directory; <code>VFSFileRename</code> can't be used to move files from one directory to another.</p>

<div class="CodeRule"><hr></div><pre class="CodeBlock">
// volRefNum must have been previously defined; most likely,<a name="997498"> </a>
// it was returned by VFSVolumeEnumerate<a name="997499"> </a>
 <a name="997500"> </a>
err = VFSFileRename(volRefNum, "/PALM/Programs/foo.prc",
   "bar.prc");<a name="997501"> </a>
if (err != errNone) {<a name="997502"> </a>
      // handle error...<a name="997503"> </a>
}<a name="997504"> </a>
</pre><div class="CodeRule"><hr></div>

<h4>
  <a name="997505"> </a>Compatibility 
</h4>

<p><a name="997509"> </a>Implemented only if the <a href="CompatibilityApdx.html#996319">VFS Manager Feature Set</a> is present.</p>

<h3 class="hbH3">
  <a name="997512"> </a>VFSFileResize Function <a href="#995797"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="997514"> </a>Purpose 
</h4>

<p><a name="997515"> </a>Change the size of an open file. This function only operates on files and cannot be used with directories.</p>
<h4>
  <a name="997516"> </a>Declared In 
</h4>
<code>VfsMgr.h<a name="997517"> </a></code><h4>
  <a name="997518"> </a>Prototype 
</h4>
<pre class="proto"><a name="997519"></a>Err VFSFileResize (
   FileRef fileRef,
   UInt32 newSize
)
</pre>
<h4>
  <a name="997520"> </a>Parameters 
</h4>

<dl>
<dt><a name="997521"> </a><code>&rarr;  <i><code>fileRef</code></i></code></dt>
<dd><a name="997525"> </a>File reference returned from <a href="VFSMgr.html#997263"><code>VFSFileOpen()</code></a>.</dd>

<dt><a name="997526"> </a><code>&rarr;  <i><code>newSize</code></i></code></dt>
<dd><a name="997527"> </a>The desired new size of the file. This can be larger or smaller then the current file size.</dd>

</dl>
<h4>
  <a name="997528"> </a>Returns 
</h4>

<p><a name="997529"> </a>Returns one of the following error codes:</p>

<dl>
<dt><a name="997530"> </a><code><code>errNone</code> </code></dt>
<dd><a name="997531"> </a>No error.</dd>

<dt><a name="997532"> </a><code><code>expErrNotOpen</code></code></dt>
<dd><a name="997533"> </a>The file system library necessary for this call has not been installed or has not been opened.</dd>

<dt><a name="997534"> </a><code><code>vfsErrFileBadRef</code></code></dt>
<dd><a name="997535"> </a>The specified file reference is invalid.</dd>

<dt><a name="997536"> </a><code><code>vfsErrIsADirectory</code></code></dt>
<dd><a name="997537"> </a>The specified file reference points to a directory instead of a file. This is an invalid operation on a directory.</dd>

<dt><a name="997538"> </a><code><code>vfsErrNoFileSystem</code></code></dt>
<dd><a name="997539"> </a>The VFS Manager cannot find an appropriate file system to handle the request.</dd>

<dt><a name="997540"> </a><code><code>vfsErrVolumeFull</code></code></dt>
<dd><a name="997541"> </a>There is not enough space left on the volume.</dd>

</dl>
<h4>
  <a name="997542"> </a>Comments 
</h4>

<p><a name="997543"> </a>The location of the file pointer is undefined after a call to this function.</p>
<h4>
  <a name="997544"> </a>Compatibility 
</h4>

<p><a name="997548"> </a>Implemented only if the <a href="CompatibilityApdx.html#996319">VFS Manager Feature Set</a> is present.</p>
<h4>
  <a name="997549"> </a>See Also 
</h4>

<p><a name="997553"> </a><a href="VFSMgr.html#997718"><code>VFSFileSize()</code></a></p>

<h3 class="hbH3">
  <a name="997556"> </a>VFSFileSeek Function <a href="#995797"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="997558"> </a>Purpose 
</h4>

<p><a name="997559"> </a>Set the position within an open file from which to read or write. This function only operates on files and cannot be used with directories.</p>
<h4>
  <a name="997560"> </a>Declared In 
</h4>
<code>VfsMgr.h<a name="997561"> </a></code><h4>
  <a name="997562"> </a>Prototype 
</h4>
<pre class="proto"><a name="997563"></a>Err VFSFileSeek (
   FileRef fileRef,
   FileOrigin origin,
   Int32 offset
)
</pre>
<h4>
  <a name="997564"> </a>Parameters 
</h4>

<dl>
<dt><a name="997565"> </a><code>&rarr;  <i><code>fileRef</code></i></code></dt>
<dd><a name="997569"> </a>File reference returned from <a href="VFSMgr.html#997263"><code>VFSFileOpen()</code></a>.</dd>

<dt><a name="997570"> </a><code>&rarr;  <i><code>origin</code></i></code></dt>
<dd><a name="997571"> </a>Origin to use when calculating the new position. The <code>offset</code> parameter indicates the desired new position relative to this origin, which can be one of the following:</dd>

<dl>
<dt><a name="997572"> </a><code><code>vfsOriginBeginning</code></code></dt>
<dd><a name="997573"> </a>The beginning of the file.</dd>

<dt><a name="997574"> </a><code><code>vfsOriginCurrent</code></code></dt>
<dd><a name="997575"> </a>The current position within the file.</dd>

<dt><a name="997576"> </a><code><code>vfsOriginEnd</code></code></dt>
<dd><a name="997577"> </a>The end of the file. Only negative offsets are allowed when <code>origin</code> is set to <code>vfsOriginEnd</code>.</dd>

</dl>
<dt><a name="997578"> </a><code>&rarr;  <i><code>offset</code></i></code></dt>
<dd><a name="997579"> </a>Offset, either positive or negative, from the origin to which the current position should be set. A value of zero (0) positions you at the specified origin.</dd>

</dl>
<h4>
  <a name="997580"> </a>Returns 
</h4>

<p><a name="997581"> </a>Returns one of the following error codes:</p>

<dl>
<dt><a name="997582"> </a><code><code>errNone</code> </code></dt>
<dd><a name="997583"> </a>No error.</dd>

<dt><a name="997584"> </a><code><code>expErrNotOpen</code></code></dt>
<dd><a name="997585"> </a>The file system library necessary for this call has not been installed or has not been opened.</dd>

<dt><a name="997586"> </a><code><code>vfsErrFileBadRef</code></code></dt>
<dd><a name="997587"> </a>The specified file reference is invalid.</dd>

<dt><a name="997588"> </a><code><code>vfsErrFileEOF</code></code></dt>
<dd><a name="997589"> </a>The file pointer is at the end of file.</dd>

<dt><a name="997590"> </a><code><code>vfsErrIsADirectory</code></code></dt>
<dd><a name="997591"> </a>The specified file reference points to a directory instead of a file. This is an invalid operation on a directory.</dd>

<dt><a name="997592"> </a><code><code>sysErrParamErr</code></code></dt>
<dd><a name="997593"> </a>The specified origin is not one of the defined constants.</dd>

</dl>
<h4>
  <a name="997594"> </a>Comments 
</h4>

<p><a name="997595"> </a>During a call to this function, if the resulting position would be beyond the end of the file, it sets the position to the end of the file.</p>
<h4>
  <a name="997596"> </a>Compatibility 
</h4>

<p><a name="997600"> </a>Implemented only if the <a href="CompatibilityApdx.html#996319">VFS Manager Feature Set</a> is present.</p>
<h4>
  <a name="997601"> </a>See Also 
</h4>

<p><a name="997608"> </a><a href="VFSMgr.html#997718"><code>VFSFileSize()</code></a>, <a href="VFSMgr.html#997764"><code>VFSFileTell()</code></a></p>

<h3 class="hbH3">
  <a name="997611"> </a>VFSFileSetAttributes Function <a href="#995797"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="997613"> </a>Purpose 
</h4>

<p><a name="997614"> </a>Change the attributes of an open file or directory.</p>
<h4>
  <a name="997615"> </a>Declared In 
</h4>
<code>VfsMgr.h<a name="997616"> </a></code><h4>
  <a name="997617"> </a>Prototype 
</h4>
<pre class="proto"><a name="997618"></a>Err VFSFileSetAttributes (
   FileRef fileRef,
   UInt32 attributes
)
</pre>
<h4>
  <a name="997619"> </a>Parameters 
</h4>

<dl>
<dt><a name="997620"> </a><code>&rarr;  <i><code>fileRef</code></i></code></dt>
<dd><a name="997624"> </a>File reference returned from <a href="VFSMgr.html#997263"><code>VFSFileOpen()</code></a>.</dd>

<dt><a name="997625"> </a><code>&rarr;  <i><code>attributes</code></i></code></dt>
<dd><a name="997628"> </a>Attributes to associate with the file or directory. See <a href="VFSMgr.html#996221">File and Directory Attributes</a> for a list of values you can use when setting this parameter:</dd>

</dl>
<h4>
  <a name="997630"> </a>Returns 
</h4>

<p><a name="997631"> </a>Returns one of the following error codes:</p>

<dl>
<dt><a name="997632"> </a><code><code>errNone</code></code></dt>
<dd><a name="997633"> </a>No error.</dd>

<dt><a name="997634"> </a><code><code>expErrNotOpen</code></code></dt>
<dd><a name="997635"> </a>The file system library necessary for this call has not been installed or has not been opened.</dd>

<dt><a name="997636"> </a><code><code>sysErrParamErr</code></code></dt>
<dd><a name="997637"> </a>One of the parameters is invalid.</dd>

<dt><a name="997638"> </a><code><code>vfsErrFileBadRef</code></code></dt>
<dd><a name="997639"> </a>The specified file reference is invalid.</dd>

<dt><a name="997640"> </a><code><code>vfsErrNoFileSystem</code></code></dt>
<dd><a name="997641"> </a>The VFS Manager cannot find an appropriate file system to handle the request.</dd>

</dl>
<h4>
  <a name="997642"> </a>Comments 
</h4>

<div><hr>
  <a name="997643"> </a> <b>NOTE: </b> You cannot use this function to set the <code>vfsFileAttrDirectory</code> or <code>vfsFileAttrVolumeLabel</code> attributes. The <code>vfsFileAttrDirectory</code> is set when you call <a href="VFSMgr.html#996516"><code>VFSDirCreate()</code></a>. The <code>vfsFileAttrVolumeLabel</code> is set when you call <a href="VFSMgr.html#998519"><code>VFSVolumeSetLabel()</code></a>. This function may fail when setting other attributes, depending on the underlying file system.
<hr>
</div>
<h4>
  <a name="997650"> </a>Compatibility 
</h4>

<p><a name="997654"> </a>Implemented only if the <a href="CompatibilityApdx.html#996319">VFS Manager Feature Set</a> is present.</p>
<h4>
  <a name="997655"> </a>See Also 
</h4>

<p><a name="997662"> </a><a href="VFSMgr.html#997164"><code>VFSFileGetAttributes()</code></a>, <a href="VFSMgr.html#997665"><code>VFSFileSetDate()</code></a></p>

<h3 class="hbH3">
  <a name="997665"> </a>VFSFileSetDate Function <a href="#995797"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="997667"> </a>Purpose 
</h4>

<p><a name="997668"> </a>Changes the dates on an open file or directory.</p>
<h4>
  <a name="997669"> </a>Declared In 
</h4>
<code>VfsMgr.h<a name="997670"> </a></code><h4>
  <a name="997671"> </a>Prototype 
</h4>
<pre class="proto"><a name="997672"></a>Err VFSFileSetDate (
   FileRef fileRef,
   UInt16 whichDate,
   UInt32 date
)
</pre>
<h4>
  <a name="997673"> </a>Parameters 
</h4>

<dl>
<dt><a name="997674"> </a><code>&rarr;  <i><code>fileRef</code></i></code></dt>
<dd><a name="997678"> </a>File reference returned in <a href="VFSMgr.html#997263"><code>VFSFileOpen()</code></a>.</dd>

<dt><a name="997679"> </a><code>&rarr;  <i><code>whichDate</code></i></code></dt>
<dd><a name="997680"> </a>Specifies which date&#8212;creation, modification, or last access&#8212;to modify. Supply one of the following values:</dd>

<dt><a name="997681"> </a><code><code>vfsFileDateCreated</code></code></dt>
<dt><a name="997682"> </a><code><code>vfsFileDateModified</code></code></dt>
<dt><a name="997683"> </a><code><code>vfsFileDateAccessed</code></code></dt>
<dd><a name="997684"> </a>Note that not all file systems are required to support the above dates. If the supplied date type is not supported by the file system, <code>VFSFileGetDate</code> returns <code>expErrUnsupportedOperation</code>. </dd>

<dt><a name="997685"> </a><code>&rarr;  <i><code>date</code></i></code></dt>
<dd><a name="997686"> </a>The new date. This field should be expressed in the standard Palm OS date format &#8212; the number of seconds since midnight (00:00:00) January 1, 1904.</dd>

</dl>
<h4>
  <a name="997687"> </a>Returns 
</h4>

<p><a name="997688"> </a>Returns one of the following error codes:</p>

<dl>
<dt><a name="997689"> </a><code><code>errNone</code> </code></dt>
<dd><a name="997690"> </a>No error.</dd>

<dt><a name="997691"> </a><code><code>expErrNotOpen</code></code></dt>
<dd><a name="997692"> </a>The file system library necessary for this call has not been installed or has not been opened.</dd>

<dt><a name="997693"> </a><code><code>expErrUnsupportedOperation</code></code></dt>
<dd><a name="997694"> </a>The specified date type is not supported by the underlying file system.</dd>

<dt><a name="997695"> </a><code><code>sysErrParamErr</code></code></dt>
<dd><a name="997696"> </a>The <code>whichDate</code> parameter is not one of the defined constants.</dd>

<dt><a name="997697"> </a><code><code>vfsErrFileBadRef</code></code></dt>
<dd><a name="997698"> </a>The specified file reference is invalid.</dd>

<dt><a name="997699"> </a><code><code>vfsErrFilePermissionDenied</code></code></dt>
<dd><a name="997700"> </a>Write permission is not enabled for this file.</dd>

<dt><a name="997701"> </a><code><code>vfsErrNoFileSystem</code></code></dt>
<dd><a name="997702"> </a>The VFS Manager cannot find an appropriate file system to handle the request.</dd>

</dl>
<h4>
  <a name="997703"> </a>Compatibility 
</h4>

<p><a name="997707"> </a>Implemented only if the <a href="CompatibilityApdx.html#996319">VFS Manager Feature Set</a> is present.</p>
<h4>
  <a name="997708"> </a>See Also 
</h4>

<p><a name="997715"> </a><a href="VFSMgr.html#997211"><code>VFSFileGetDate()</code></a>, <a href="VFSMgr.html#997611"><code>VFSFileSetAttributes()</code></a></p>

<h3 class="hbH3">
  <a name="997718"> </a>VFSFileSize Function <a href="#995797"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="997720"> </a>Purpose 
</h4>

<p><a name="997721"> </a>Obtain the size of an open file. This function only operates on files and cannot be used with directories.</p>
<h4>
  <a name="997722"> </a>Declared In 
</h4>
<code>VfsMgr.h<a name="997723"> </a></code><h4>
  <a name="997724"> </a>Prototype 
</h4>
<pre class="proto"><a name="997725"></a>Err VFSFileSize (
   FileRef fileRef,
   UInt32 *fileSizeP
)
</pre>
<h4>
  <a name="997726"> </a>Parameters 
</h4>

<dl>
<dt><a name="997727"> </a><code>&rarr;  <i><code>fileRef</code></i></code></dt>
<dd><a name="997731"> </a>File reference returned from <a href="VFSMgr.html#997263"><code>VFSFileOpen()</code></a>.</dd>

<dt><a name="997732"> </a><code>&larr;  <i><code>fileSizeP</code></i></code></dt>
<dd><a name="997733"> </a>Pointer to the size of the open file.</dd>

</dl>
<h4>
  <a name="997734"> </a>Returns 
</h4>

<p><a name="997735"> </a>Returns one of the following error codes:</p>

<dl>
<dt><a name="997736"> </a><code><code>errNone</code> </code></dt>
<dd><a name="997737"> </a>No error.</dd>

<dt><a name="997738"> </a><code><code>expErrNotOpen</code></code></dt>
<dd><a name="997739"> </a>The file system library necessary for this call has not been installed or has not been opened.</dd>

<dt><a name="997740"> </a><code><code>vfsErrFileBadRef</code></code></dt>
<dd><a name="997741"> </a>The specified file reference is invalid.</dd>

<dt><a name="997742"> </a><code><code>vfsErrIsADirectory</code></code></dt>
<dd><a name="997743"> </a>The specified file reference points to a directory instead of a file. This is an invalid operation on a directory.</dd>

<dt><a name="997744"> </a><code><code>vfsErrNoFileSystem</code></code></dt>
<dd><a name="997745"> </a>The VFS Manager cannot find an appropriate file system to handle the request.</dd>

</dl>
<h4>
  <a name="997746"> </a>Compatibility 
</h4>

<p><a name="997750"> </a>Implemented only if the <a href="CompatibilityApdx.html#996319">VFS Manager Feature Set</a> is present.</p>
<h4>
  <a name="997751"> </a>See Also 
</h4>

<p><a name="997761"> </a><a href="VFSMgr.html#997512"><code>VFSFileResize()</code></a>, <a href="VFSMgr.html#997764"><code>VFSFileTell()</code></a>, <a href="VFSMgr.html#998574"><code>VFSVolumeSize()</code></a></p>

<h3 class="hbH3">
  <a name="997764"> </a>VFSFileTell Function <a href="#995797"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="997766"> </a>Purpose 
</h4>

<p><a name="997767"> </a>Get the current position of the file pointer within an open file. This function only operates on files and cannot be used with directories.</p>
<h4>
  <a name="997768"> </a>Declared In 
</h4>
<code>VfsMgr.h<a name="997769"> </a></code><h4>
  <a name="997770"> </a>Prototype 
</h4>
<pre class="proto"><a name="997771"></a>Err VFSFileTell (
   FileRef fileRef,
   UInt32 *filePosP
)
</pre>
<h4>
  <a name="997772"> </a>Parameters 
</h4>

<dl>
<dt><a name="997773"> </a><code>&rarr;  <i><code>fileRef</code></i></code></dt>
<dd><a name="997777"> </a>File reference returned from <a href="VFSMgr.html#997263"><code>VFSFileOpen()</code></a>.</dd>

<dt><a name="997778"> </a><code>&larr;  <i><code>filePosP</code></i></code></dt>
<dd><a name="997779"> </a>Pointer to the current file position.</dd>

</dl>
<h4>
  <a name="997780"> </a>Returns 
</h4>

<p><a name="997781"> </a>Returns one of the following error codes:</p>

<dl>
<dt><a name="997782"> </a><code><code>errNone</code> </code></dt>
<dd><a name="997783"> </a>No error.</dd>

<dt><a name="997784"> </a><code><code>expErrNotOpen</code></code></dt>
<dd><a name="997785"> </a>The file system library necessary for this call has not been installed or has not been opened.</dd>

<dt><a name="997786"> </a><code><code>vfsErrFileBadRef</code></code></dt>
<dd><a name="997787"> </a>The specified file reference is invalid.</dd>

<dt><a name="997788"> </a><code><code>vfsErrIsADirectory</code></code></dt>
<dd><a name="997789"> </a>The specified file reference points to a directory instead of a file. This is an invalid operation on a directory.</dd>

<dt><a name="997790"> </a><code><code>vfsErrNoFileSystem</code></code></dt>
<dd><a name="997791"> </a>The VFS Manager cannot find an appropriate file system to handle the request.</dd>

</dl>
<h4>
  <a name="997792"> </a>Compatibility 
</h4>

<p><a name="997796"> </a>Implemented only if the <a href="CompatibilityApdx.html#996319">VFS Manager Feature Set</a> is present.</p>
<h4>
  <a name="997797"> </a>See Also 
</h4>

<p><a name="997804"> </a><a href="VFSMgr.html#997556"><code>VFSFileSeek()</code></a>, <a href="VFSMgr.html#997718"><code>VFSFileSize()</code></a></p>

<h3 class="hbH3">
  <a name="997807"> </a>VFSFileWrite Function <a href="#995797"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="997809"> </a>Purpose 
</h4>

<p><a name="997810"> </a>Write data to an open file. This function only operates on files and cannot be used with directories.</p>
<h4>
  <a name="997811"> </a>Declared In 
</h4>
<code>VfsMgr.h<a name="997812"> </a></code><h4>
  <a name="997813"> </a>Prototype 
</h4>
<pre class="proto"><a name="997814"></a>Err VFSFileWrite (
   FileRef fileRef,
   UInt32 numBytes,
   const void *dataP,
   UInt32 *numBytesWrittenP
)
</pre>
<h4>
  <a name="997815"> </a>Parameters 
</h4>

<dl>
<dt><a name="997816"> </a><code>&rarr;  <i><code>fileRef</code></i></code></dt>
<dd><a name="997820"> </a>File reference returned from <a href="VFSMgr.html#997263"><code>VFSFileOpen()</code></a>.</dd>

<dt><a name="997821"> </a><code>&rarr;  <i><code>numBytes</code></i></code></dt>
<dd><a name="997822"> </a>The number of bytes to write.</dd>

<dt><a name="997823"> </a><code>&rarr;  <i><code>dataP</code></i></code></dt>
<dd><a name="997824"> </a>Pointer to the data that is to be written.</dd>

<dt><a name="997825"> </a><code>&larr;  <i><code>numBytesWrittenP</code></i></code></dt>
<dd><a name="997826"> </a>Pointer to an unsigned integer that reflects the number of bytes actually written. This value is set on return and does not need to be initialized. If no bytes are written the value is set to zero. Pass <code>NULL</code> for this parameter if you do not need to know how many bytes were written. </dd>

</dl>
<h4>
  <a name="997827"> </a>Returns 
</h4>

<p><a name="997828"> </a>Returns one of the following error codes:</p>

<dl>
<dt><a name="997829"> </a><code><code>errNone</code> </code></dt>
<dd><a name="997830"> </a>No error.</dd>

<dt><a name="997831"> </a><code><code>expErrNotOpen</code></code></dt>
<dd><a name="997832"> </a>The file system library necessary for this call has not been installed or has not been opened.</dd>

<dt><a name="997833"> </a><code><code>vfsErrFileBadRef</code></code></dt>
<dd><a name="997834"> </a>The specified file reference is invalid.</dd>

<dt><a name="997835"> </a><code><code>vfsErrFilePermissionDenied</code></code></dt>
<dd><a name="997836"> </a>Write permission is not enabled for this file.</dd>

<dt><a name="997837"> </a><code><code>vfsErrIsADirectory</code></code></dt>
<dd><a name="997838"> </a>The specified file reference points to a directory instead of a file. This is an invalid operation on a directory.</dd>

<dt><a name="997839"> </a><code><code>vfsErrNoFileSystem</code></code></dt>
<dd><a name="997840"> </a>The VFS Manager cannot find an appropriate file system to handle the request.</dd>

<dt><a name="997841"> </a><code><code>vfsErrVolumeFull</code></code></dt>
<dd><a name="997842"> </a>There is not enough space left on the volume.</dd>

</dl>
<h4>
  <a name="997843"> </a>Compatibility 
</h4>

<p><a name="997847"> </a>Implemented only if the <a href="CompatibilityApdx.html#996319">VFS Manager Feature Set</a> is present.</p>
<h4>
  <a name="997848"> </a>See Also 
</h4>

<p><a name="997854"> </a><a href="VFSMgr.html#996644"><code>VFSExportDatabaseToFile()</code></a>, <a href="VFSMgr.html#996699"><code>VFSExportDatabaseToFileCustom()</code></a>, <a href="VFSMgr.html#997327"><code>VFSFileRead()</code></a>, <a href="VFSMgr.html#997389"><code>VFSFileReadData()</code></a></p>

<h3 class="hbH3">
  <a name="997864"> </a>VFSGetDefaultDirectory Function <a href="#995797"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="997866"> </a>Purpose 
</h4>

<p><a name="997867"> </a>Determine the default location on the given volume for files of a particular type.</p>
<h4>
  <a name="997868"> </a>Declared In 
</h4>
<code>VfsMgr.h<a name="997869"> </a></code><h4>
  <a name="997870"> </a>Prototype 
</h4>
<pre class="proto"><a name="997871"></a>Err VFSGetDefaultDirectory (
   UInt16 volRefNum,
   const Char *fileTypeStr,
   Char *pathStr,
   UInt16 *bufLenP
)
</pre>
<h4>
  <a name="997872"> </a>Parameters 
</h4>

<dl>
<dt><a name="997873"> </a><code>&rarr;  <i><code>volRefNum</code></i></code></dt>
<dd><a name="997874"> </a>Volume reference number returned from <a href="VFSMgr.html#998210"><code>VFSVolumeEnumerate()</code></a>.</dd>

<dt><a name="997878"> </a><code>&rarr;  <i><code>fileTypeStr</code></i></code></dt>
<dd><a name="997879"> </a>Pointer to the requested file type, as a null-terminated string. The file type may either be a MIME media type/subtype pair, such as "image/jpeg", "text/plain", or "audio/basic"; or a file extension, such as "<code>.jpeg</code>."</dd>

<dt><a name="997880"> </a><code>&larr;  <i><code>pathStr</code></i></code></dt>
<dd><a name="997881"> </a>Pointer to the buffer which receives the default directory path for the requested file type.</dd>

<dt><a name="997882"> </a><code>&harr;  <i><code>bufLenP</code></i></code></dt>
<dd><a name="997884"> </a>Pointer to the size of the path. Set this to the size of <code>pathStr</code> buffer on input. Reflects the number of bytes copied to <code>pathStr</code> on output.</dd>

</dl>
<h4>
  <a name="997885"> </a>Returns 
</h4>

<p><a name="997886"> </a>Returns one of the following error codes:</p>

<dl>
<dt><a name="997887"> </a><code><code>errNone</code> </code></dt>
<dd><a name="997888"> </a>No error.</dd>

<dt><a name="997889"> </a><code><code>vfsErrBadName</code></code></dt>
<dd><a name="997890"> </a>There is no default directory registered for the requested file type.</dd>

<dt><a name="997891"> </a><code><code>vfsErrBufferOverflow</code></code></dt>
<dd><a name="997892"> </a>A match was found, but the <code>pathStr</code> buffer is too small to hold the resulting path string. A partial path is returned in <code>pathStr</code>.</dd>

<dt><a name="997893"> </a><code><code>vfsErrFileNotFound</code></code></dt>
<dd><a name="997894"> </a>No match was found for the specified volume. The error could have occurred with either the media type specified for this volume or the file type requested.</dd>

</dl>
<h4>
  <a name="997895"> </a>Comments 
</h4>

<p><a name="997896"> </a>This function returns the complete path to the default directory registered for the specified file type. A default directory can be registered for each type of media supported. The directory should be registered under media and file type. Note that this directory is typically a "root" directory for the file type; any subdirectories under this root directory should also be searched for files of the appropriate type.</p>

<p><a name="997897"> </a>This function can be used by an image viewer application, for example, to find the directory containing images without having to know what type of media the volume was on. This could be <br>"/DCIM", "/images", or something else depending on the type of media.</p>
<h4>
  <a name="997898"> </a>Compatibility 
</h4>

<p><a name="997902"> </a>Implemented only if the <a href="CompatibilityApdx.html#996319">VFS Manager Feature Set</a> is present.</p>
<h4>
  <a name="997903"> </a>See Also 
</h4>

<p><a name="997909"> </a><a href="VFSMgr.html#996564"><code>VFSDirEntryEnumerate()</code></a>, <a href="VFSMgr.html#998087"><code>VFSRegisterDefaultDirectory()</code></a>, <a href="VFSMgr.html#998166"><code>VFSUnregisterDefaultDirectory()</code></a></p>

<h3 class="hbH3">
  <a name="997916"> </a>VFSImportDatabaseFromFile Function <a href="#995797"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="997918"> </a>Purpose 
</h4>

<p><a name="997919"> </a>Creates a database from a <code>.pdb</code> or .<code>prc</code> file on an external storage card.</p>
<h4>
  <a name="997920"> </a>Declared In 
</h4>
<code>VfsMgr.h<a name="997921"> </a></code><h4>
  <a name="997922"> </a>Prototype 
</h4>
<pre class="proto"><a name="997923"></a>Err VFSImportDatabaseFromFile (
   UInt16 volRefNum,
   const Char *pathNameP,
   UInt16 *cardNoP,
   LocalID *dbIDP
)
</pre>
<h4>
  <a name="997924"> </a>Parameters 
</h4>

<dl>
<dt><a name="997925"> </a><code>&rarr;  <i><code>volRefNum</code></i></code></dt>
<dd><a name="997926"> </a>Volume on which the source file resides.</dd>

<dt><a name="997927"> </a><code>&rarr;  <i><code>pathNameP</code></i></code></dt>
<dd><a name="997928"> </a>Pointer to the full path and name of the source file.</dd>

<dt><a name="997929"> </a><code>&larr;  <i><code>cardNoP </code></i></code></dt>
<dd><a name="997930"> </a>Pointer to a variable that receives the card number of the newly-created database. If the database already resides in the storage heap, the card number of the existing database is returned along with the error <code>dmErrAlreadyExists</code>.</dd>

<dt><a name="997931"> </a><code>&larr;  <i><code>dbIDP</code></i></code></dt>
<dd><a name="997932"> </a>Pointer to a variable that receives the database ID of the new database. If the database already resides in the storage heap, the database ID of the existing database is returned along with the error <code>dmErrAlreadyExists</code>.</dd>

</dl>
<h4>
  <a name="997933"> </a>Returns 
</h4>

<p><a name="997934"> </a>Returns one of the following error codes:</p>

<dl>
<dt><a name="997935"> </a><code><code>errNone</code> </code></dt>
<dd><a name="997936"> </a>No error.</dd>

<dt><a name="997937"> </a><code><code>dmErrAlreadyExists</code></code></dt>
<dd><a name="997938"> </a>The <code>.prc</code> or <code>.pdb</code> file already exists in the storage heap. In this case the <code>cardNoP</code> and <code>dbIDP</code> are set to point to the existing file.</dd>

<dt><a name="997939"> </a><code><code>expErrNotEnoughPower</code></code></dt>
<dd><a name="997940"> </a>There is insufficient battery power to complete the requested operation.</dd>

<dt><a name="997941"> </a><code><code>vfsErrBadName</code></code></dt>
<dd><a name="997942"> </a>The path name specified in <code>pathNameP</code> is not valid.</dd>

</dl>
<h4>
  <a name="997943"> </a>Comments 
</h4>

<p><a name="997944"> </a>This utility function imports a <code>.pdb</code> or <code>.prc</code> file resident on an external storage card into a new database in the storage heap. It first calls <a href="VFSMgr.html#997263"><code>VFSFileOpen()</code></a> to open the file specified in <code>pathNameP</code>. Assuming that a corresponding <code>.prc</code> or <code>.pdb</code> does not already exist in the storage heap, <a href="VFSMgr.html#997916"><code>VFSImportDatabaseFromFile()</code></a><span style="color: #000000;  font-family: Courier; font-style: normal; font-weight: normal; text-decoration: none; text-transform: none; vertical-align: baseline"> </span>calls the Exchange Manager function <a href="ExchangeManager.html#1055573"><code>ExgDBRead()</code></a> with an internal callback function for importing a file to the Data Manager. The Exchange Manager makes repeated calls to this function, which passes the data back in blocks. Once the file has been successfully imported, the owner (the imported file, if it's an executable, or the associated application if it is not) is sent a <a href="AppLaunchCodes.html#1012389"><code>sysAppLaunchCmdSyncNotify</code></a> launch code to make it aware of the new database.</p>

<p><a name="997957"> </a>This function only imports the specified <code>.pdb</code> or <code>.prc</code> file; it does not import bundled databases or overlays. If there are bundled databases and/or overlays associated with the <code>.pdb</code> or <code>.prc</code> file you are importing, you will need to write additional code to explicitly handle them.</p>

<p><a name="997958"> </a>This function doesn't provide any progress indication to the user. If you need to provide feedback to the user as the file import progresses, use <a href="VFSMgr.html#997978"><code>VFSImportDatabaseFromFileCustom()</code></a> instead.</p>

<p><a name="997962"> </a>This function is used, for example, to copy applications from a storage card to main memory.</p>
<h4>
  <a name="997963"> </a>Compatibility 
</h4>

<p><a name="997967"> </a>Implemented only if the <a href="CompatibilityApdx.html#996319">VFS Manager Feature Set</a> is present.</p>
<h4>
  <a name="997968"> </a>See Also 
</h4>

<p><a name="997975"> </a><a href="VFSMgr.html#996644"><code>VFSExportDatabaseToFile()</code></a>, <a href="VFSMgr.html#997327"><code>VFSFileRead()</code></a></p>

<h3 class="hbH3">
  <a name="997978"> </a>VFSImportDatabaseFromFileCustom Function <a href="#995797"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="997980"> </a>Purpose 
</h4>

<p><a name="997981"> </a>Create a database from the specified .<code>pdb</code> or <code>.prc</code> file on an external storage card. This function differs from <a href="VFSMgr.html#997916"><code>VFSImportDatabaseFromFile()</code></a> in that it allows you to track the progress of the import operation.</p>
<h4>
  <a name="997985"> </a>Declared In 
</h4>
<code>VfsMgr.h<a name="997986"> </a></code><h4>
  <a name="997987"> </a>Prototype 
</h4>
<pre class="proto"><a name="997988"></a>Err VFSImportDatabaseFromFileCustom (
   UInt16 volRefNum,
   const Char *pathNameP,
   UInt16 *cardNoP,
   LocalID *dbIDP,
   VFSImportProcPtr importProcP,
   void *userDataP
)
</pre>
<h4>
  <a name="997989"> </a>Parameters 
</h4>

<dl>
<dt><a name="997990"> </a><code>&rarr;  <i><code>volRefNum</code></i></code></dt>
<dd><a name="997991"> </a>Volume on which the source file resides.</dd>

<dt><a name="997992"> </a><code>&rarr;  <i><code>pathNameP</code></i></code></dt>
<dd><a name="997993"> </a>Pointer to the full path and name of the source file.</dd>

<dt><a name="997994"> </a><code>&larr;  <i><code>cardNoP </code></i></code></dt>
<dd><a name="997995"> </a>Pointer to the variable that receives the card number of the newly-created database. If the database already resides in the storage heap, the card number of the existing database is returned along with the error <code>dmErrAlreadyExists</code>.</dd>

<dt><a name="997996"> </a><code>&larr;  <i><code>dbIDP</code></i></code></dt>
<dd><a name="997997"> </a>Pointer to the variable that receives the database ID of the new database. If the database already resides in the storage heap, the database ID of the existing database is returned along with the error <code>dmErrAlreadyExists</code>.</dd>

<dt><a name="997998"> </a><code>&rarr;  <i>importProcP</i></code></dt>
<dd><a name="997999"> </a>User-defined callback function that tracks the progress of the import. This function should allow the user to cancel the import. Pass <code>NULL</code> if you don't have a progress callback function. See <a href="VFSMgr.html#998701"><code>VFSImportProcPtr()</code></a> for the requirements of this function.</dd>

<dt><a name="998003"> </a><code>&rarr;  <i><code>userDataP</code></i></code></dt>
<dd><a name="998004"> </a>Pointer to any data you want to pass to the callback function specified in <code>importProcP</code>. This information is not used internally by the VFS Manager. Pass <code>NULL</code> if you don't have a progress callback function, or if that function doesn't need any such data.</dd>

</dl>
<h4>
  <a name="998005"> </a>Returns 
</h4>

<p><a name="998006"> </a>Returns one of the following error codes:</p>

<dl>
<dt><a name="998007"> </a><code><code>errNone</code> </code></dt>
<dd><a name="998008"> </a>No error</dd>

<dt><a name="998009"> </a><code><code>vfsErrBadName</code></code></dt>
<dd><a name="998010"> </a>The path name specified in <code>pathNameP</code> is not valid.</dd>

<dt><a name="998011"> </a><code><code>expErrNotEnoughPower</code></code></dt>
<dd><a name="998012"> </a>The power required to import a database is not available.</dd>

<dt><a name="998013"> </a><code><code>dmErrAlreadyExists</code></code></dt>
<dd><a name="998014"> </a>The <code>.prc</code> or <code>.pdb</code> file already exists in main memory. In this case the <code>cardNoP</code> and <code>dbIDP</code> are set to point to the existing file.</dd>

</dl>
<h4>
  <a name="998015"> </a>Comments 
</h4>

<p><a name="998019"> </a>This function is similar to <a href="VFSMgr.html#997916"><code>VFSImportDatabaseFromFile()</code></a> in that it imports a <code>.pdb</code> or<code> .prc</code> file on an external storage card into a new database on the storage heap. It extends the functionality by allowing you to specify a callback function that tracks the progress of the export. It first calls <a href="VFSMgr.html#997263"><code>VFSFileOpen()</code></a> to open the file specified in <code>pathNameP</code>. If a corresponding <code>.prc</code> or <code> .pdb</code> does not already exist in main memory, it calls the Exchange Manager function <a href="ExchangeManager.html#1055573"><code>ExgDBRead()</code></a> with an internal callback function for importing the file from the Data Manager. The Exchange Manager makes repeated calls to this function, which receives the data back in blocks. The progress tracker, if one has been specified, is also called every time a new chunk of data is passed back. Once the file has been successfully imported, the owner (the imported file, if it's an executable, or the associated application if it is not) is sent a <a href="AppLaunchCodes.html#1012389"><code>sysAppLaunchCmdSyncNotify</code></a> launch code to make it aware of the new database.</p>

<p><a name="998029"> </a>Like <code>VFSImportDatabaseFromFile</code>, this function only imports the specified <code>.pdb</code> or <code>.prc</code> file; it does not import bundled databases or overlays.</p>

<p><a name="998030"> </a>This function is used, for example, to copy applications from a storage card to main memory.</p>
<h4>
  <a name="998031"> </a>Compatibility 
</h4>

<p><a name="998035"> </a>Implemented only if the <a href="CompatibilityApdx.html#996319">VFS Manager Feature Set</a> is present.</p>
<h4>
  <a name="998036"> </a>See Also 
</h4>

<p><a name="998043"> </a><a href="VFSMgr.html#997327"><code>VFSFileRead()</code></a>, <a href="VFSMgr.html#996699"><code>VFSExportDatabaseToFileCustom()</code></a></p>

<h3 class="hbH3">
  <a name="998046"> </a>VFSInstallFSLib Function <a href="#995797"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="998048"> </a>Purpose 
</h4>

<p><a name="998049"> </a>Install a file system library so that the VFS Manager can use it.</p>
<h4>
  <a name="998050"> </a>Declared In 
</h4>
<code>VfsMgr.h<a name="998051"> </a></code><h4>
  <a name="998052"> </a>Prototype 
</h4>
<pre class="proto"><a name="998053"></a>Err VFSInstallFSLib (
   UInt32 creator,
   UInt16 *fsLibRefNumP
)
</pre>
<h4>
  <a name="998054"> </a>Parameters 
</h4>

<dl>
<dt><a name="998055"> </a><code>&rarr;  <i><code>creator</code></i></code></dt>
<dd><a name="998056"> </a>Creator ID of the database containing the file system library to be installed.</dd>

<dt><a name="998057"> </a><code>&larr;  <i><code>fsLibRefNumP</code></i></code></dt>
<dd><a name="998058"> </a>Pointer to the reference number for the newly installed file system library. Supply <code>NULL</code> for this parameter if you don't need the library reference number.</dd>

</dl>
<h4>
  <a name="998059"> </a>Returns 
</h4>

<p><a name="998060"> </a>If the file system library was loaded and installed without error, <code>errNone</code> is returned. Any error generated by the underlying file system while opening the file system library or determining its type will be returned from <code>VFSInstallFSLib</code>. Other errors that can be generated during the file system library installation process include:</p>

<dl>
<dt><a name="998061"> </a><code><code>expErrIncompatibleAPIVer</code></code></dt>
<dd><a name="998062"> </a>The file system library has an incompatible API version.</dd>

<dt><a name="998063"> </a><code><code>expErrNotOpen</code></code></dt>
<dd><a name="998064"> </a>The file system library necessary for this call has not been installed or has not been opened.</dd>

<dt><a name="998065"> </a><code><code>memErrNotEnoughSpace</code>, <code>memErrChunkNotLocked</code>, or <code>memErrChunkLocked</code></code></dt>
<dd><a name="998066"> </a>A memory problem occurred while inserting the library reference into the list of installed libraries.</dd>

<dt><a name="998067"> </a><code><code>sysErrLibNotFound</code>, <code>sysErrNoFreeRAM</code>, <code>sysErrNoFreeLibSlots</code> (or some other error returned from the library's install entry point)</code></dt>
<dd><a name="998068"> </a>An error occurred while loading the library.</dd>

</dl>
<h4>
  <a name="998069"> </a>Comments 
</h4>

<p><a name="998073"> </a>This function calls <a href="SystemManager.html#1076720"><code>SysLibLoad()</code></a> to load the file system library into the library table. Once loaded the appropriate file system is asked to open the library. At boot time <code>VFSInstallFSLib</code> is called internally by the Expansion Manager to load all installed file system libraries and initialize them for use. </p>

<p><a name="998074"> </a><code>VFSInstallFSLib</code> is not normally called by applications.</p>
<h4>
  <a name="998075"> </a>Compatibility 
</h4>

<p><a name="998079"> </a>Implemented only if the <a href="CompatibilityApdx.html#996319">VFS Manager Feature Set</a> is present. This function is not implemented, however, if <a href="CompatibilityApdx.html#1029305">Palm OS Cobalt Feature Set</a> is present.</p>
<h4>
  <a name="998080"> </a>See Also 
</h4>

<p><a name="998084"> </a><a href="VFSMgr.html#998135"><code>VFSRemoveFSLib()</code></a></p>

<h3 class="hbH3">
  <a name="998087"> </a>VFSRegisterDefaultDirectory Function <a href="#995797"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="998089"> </a>Purpose 
</h4>

<p><a name="998090"> </a>Registers a specific directory as the default location for files of a given type on a particular kind of external storage card. This function is generally called by a slot driver for files and media types that are supported by that slot driver.</p>
<h4>
  <a name="998091"> </a>Declared In 
</h4>
<code>VfsMgr.h<a name="998092"> </a></code><h4>
  <a name="998093"> </a>Prototype 
</h4>
<pre class="proto"><a name="998094"></a>Err VFSRegisterDefaultDirectory (
   const Char *fileTypeStr,
   UInt32 mediaType,
   const Char *pathStr
)
</pre>
<h4>
  <a name="998095"> </a>Parameters 
</h4>

<dl>
<dt><a name="998096"> </a><code>&rarr;  <i><code>fileTypeStr</code></i></code></dt>
<dd><a name="998097"> </a>Pointer to the file type to register. This is a null-terminated string that can either be a MIME media type/subtype pair, such as "image/jpeg", "text/plain", or "audio/basic"; or a file extension, such as "<code>.jpeg</code>".</dd>

<dt><a name="998098"> </a><code>&rarr;  <i><code>mediaType</code></i></code></dt>
<dd><a name="998099"> </a>Type of card media for which the default directory is being associated. See <a href="ExpansionManager.html#1033049">Defined Media Types</a> in the <a href="ExpansionManager.html#1032894">Expansion Manager</a> chapter for the list of accepted values.</dd>

<dt><a name="998106"> </a><code>&rarr;  <i><code>pathStr</code></i></code></dt>
<dd><a name="998108"> </a>Pointer to the default directory path to be associated with the specified file type. This string must be null-terminated, and must be the full path to the directory.</dd>

</dl>
<h4>
  <a name="998109"> </a>Returns 
</h4>

<p><a name="998110"> </a>Returns one of the following error codes:</p>

<dl>
<dt><a name="998111"> </a><code><code>errNone</code> </code></dt>
<dd><a name="998112"> </a>No error.</dd>

<dt><a name="998113"> </a><code><code>sysErrParamErr</code></code></dt>
<dd><a name="998114"> </a>Either the <code>fileTypeStr</code> parameter is <code>NULL</code> or the <code>pathStr</code> parameter is <code>NULL</code>.</dd>

<dt><a name="998115"> </a><code><code>vfsErrFileAlreadyExists</code> </code></dt>
<dd><a name="998116"> </a>A default directory has already been registered for this file type on the specified card media type.</dd>

</dl>
<h4>
  <a name="998117"> </a>Comments 
</h4>

<p><a name="998118"> </a>This function first verifies that a default directory has not already been registered for the specified combination of file type and media type, and returns <code>vfsErrFileAlreadyExists</code> if one has been registered. To change an existing entry in the registry, you must first remove the existing entry with a call to <a href="VFSMgr.html#998166"><code>VFSUnregisterDefaultDirectory()</code></a> before re-registering it with <code>VFSRegisterDefaultDirectory</code>.</p>

<p><a name="998122"> </a>The specified directory registered for a given file type is intended to be the "root" default directory. If a given default directory has one or more subdirectories, applications should also search those subdirectories for files of the appropriate type.</p>
<h4>
  <a name="998123"> </a>Compatibility 
</h4>

<p><a name="998127"> </a>Implemented only if the <a href="CompatibilityApdx.html#996319">VFS Manager Feature Set</a> is present.</p>
<h4>
  <a name="998128"> </a>See Also 
</h4>

<p><a name="998132"> </a><a href="VFSMgr.html#997864"><code>VFSGetDefaultDirectory()</code></a></p>

<h3 class="hbH3">
  <a name="998135"> </a>VFSRemoveFSLib Function <a href="#995797"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="998137"> </a>Purpose 
</h4>

<p><a name="998138"> </a>Remove a file system library from the library table, so that the VFS Manager can no longer use it.</p>
<h4>
  <a name="998139"> </a>Declared In 
</h4>
<code>VfsMgr.h<a name="998140"> </a></code><h4>
  <a name="998141"> </a>Prototype 
</h4>
<pre class="proto"><a name="998142"></a>Err VFSRemoveFSLib (
   UInt16 fsLibRefNum
)
</pre>
<h4>
  <a name="998143"> </a>Parameters 
</h4>

<dl>
<dt><a name="998144"> </a><code>&rarr;  <i><code>fsLibRefNum</code></i></code></dt>
<dd><a name="998145"> </a>Library reference number of the file system library to remove from the library table.</dd>

</dl>
<h4>
  <a name="998146"> </a>Returns 
</h4>

<p><a name="998147"> </a>Returns one of the following error codes:</p>

<dl>
<dt><a name="998148"> </a><code><code>errNone</code></code></dt>
<dd><a name="998149"> </a>No error.</dd>

<dt><a name="998150"> </a><code><code>expErrNotOpen</code></code></dt>
<dd><a name="998151"> </a>The file system library necessary for this call has not been installed or has not been opened.</dd>

<dt><a name="998152"> </a><code><code>vfsErrNoFileSystem</code></code></dt>
<dd><a name="998153"> </a>VFS Manager can not find the file system specified in <code>fsLibRefNum</code>.</dd>

</dl>
<h4>
  <a name="998154"> </a>Comments 
</h4>

<p><a name="998155"> </a>This function is not normally called by applications. It unmounts any volumes that the specified file system may have mounted. It then closes the library and removes it from the library table with <a href="SystemManager.html#1076754"><code>SysLibRemove()</code></a>.</p>
<h4>
  <a name="998159"> </a>Compatibility 
</h4>

<p><a name="1028388"> </a>Implemented only if the <a href="CompatibilityApdx.html#996319">VFS Manager Feature Set</a> is present. This function is not implemented, however, if <a href="CompatibilityApdx.html#1029305">Palm OS Cobalt Feature Set</a> is present.</p>

<h3 class="hbH3">
  <a name="998166"> </a>VFSUnregisterDefaultDirectory Function <a href="#995797"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="998168"> </a>Purpose 
</h4>

<p><a name="998169"> </a>Sever the association between a particular file type and a default directory for a given type of card media.</p>
<h4>
  <a name="998170"> </a>Declared In 
</h4>
<code>VfsMgr.h<a name="998171"> </a></code><h4>
  <a name="998172"> </a>Prototype 
</h4>
<pre class="proto"><a name="998173"></a>Err VFSUnregisterDefaultDirectory (
   const Char *fileTypeStr,
   UInt32 mediaType
)
</pre>
<h4>
  <a name="998174"> </a>Parameters 
</h4>

<dl>
<dt><a name="998175"> </a><code>&rarr;  <i><code>fileTypeStr</code></i></code></dt>
<dd><a name="998176"> </a>Pointer to the file type with which the default directory is associated. This is a null-terminated string that can either be a MIME media type/subtype pair, such as "image/jpeg", "text/plain", or "audio/basic"; or a file extension, such as "<code>.jpeg</code>".</dd>

<dt><a name="998177"> </a><code>&rarr;  <i><code>mediaType</code></i></code></dt>
<dd><a name="998178"> </a>Type of card media for which the default directory is associated. See <a href="ExpansionManager.html#1033049">Defined Media Types</a> in the <a href="ExpansionManager.html#1032894">Expansion Manager</a> chapter for the list of accepted values.</dd>

</dl>
<h4>
  <a name="998185"> </a>Returns 
</h4>

<p><a name="998186"> </a>Returns one of the following error codes:</p>

<dl>
<dt><a name="998187"> </a><code><code>errNone</code> </code></dt>
<dd><a name="998188"> </a>No error.</dd>

<dt><a name="998189"> </a><code><code>sysErrParamErr</code></code></dt>
<dd><a name="998190"> </a>The <code>fileTypeStr</code> parameter is <code>NULL</code>.</dd>

<dt><a name="998191"> </a><code><code>vfsErrFileNotFound</code></code></dt>
<dd><a name="998192"> </a>A default directory could not be found in the registry for the specified file and media type.</dd>

</dl>
<h4>
  <a name="998193"> </a>Comments 
</h4>

<div><hr>
  <a name="998194"> </a> <b>NOTE: </b> Caution is advised when using this function, since you may remove another application's registration, causing data to mysteriously disappear from those applications.
<hr>
</div>
<h4>
  <a name="998195"> </a>Compatibility 
</h4>

<p><a name="998199"> </a>Implemented only if the <a href="CompatibilityApdx.html#996319">VFS Manager Feature Set</a> is present.</p>
<h4>
  <a name="998200"> </a>See Also 
</h4>

<p><a name="998206"> </a><a href="VFSMgr.html#997864"><code>VFSGetDefaultDirectory()</code></a>, <a href="VFSMgr.html#998087"><code>VFSRegisterDefaultDirectory()</code></a></p>

<h3 class="hbH3">
  <a name="998210"> </a>VFSVolumeEnumerate Function <a href="#995797"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="998212"> </a>Purpose 
</h4>

<p><a name="998213"> </a>Enumerate the mounted volumes.</p>
<h4>
  <a name="998214"> </a>Declared In 
</h4>
<code>VfsMgr.h<a name="998215"> </a></code><h4>
  <a name="998216"> </a>Prototype 
</h4>
<pre class="proto"><a name="998217"></a>Err VFSVolumeEnumerate (
   UInt16 *volRefNumP,
   UInt32 *volIteratorP
)
</pre>
<h4>
  <a name="998218"> </a>Parameters 
</h4>

<dl>
<dt><a name="998219"> </a><code>&larr;  <i><code>volRefNumP</code></i></code></dt>
<dd><a name="998220"> </a>Pointer to the reference number for the volume represented by the current enumeration, or <code>vfsInvalidVolRef</code> if there are no more volumes to be enumerated or an error occurred.</dd>

<dt><a name="998221"> </a><code>&harr;  <i><code>volIteratorP</code></i></code></dt>
<dd><a name="998222"> </a>Pointer to a variable that holds the index of the current enumeration. Set the variable to <code>vfsIteratorStart</code> prior to the first iteration. Each call to <code>VFSVolumeEnumerate</code> updates the variable to the index of the next volume. When the last volume is reached, the variable pointed to by <code>volIteratorP</code> is set to <code>vfsIteratorStop</code>.</dd>

</dl>
<h4>
  <a name="998223"> </a>Returns 
</h4>

<p><a name="998224"> </a>Returns one of the following error codes:</p>

<dl>
<dt><a name="998225"> </a><code><code>errNone</code> </code></dt>
<dd><a name="998226"> </a>No error</dd>

<dt><a name="998227"> </a><code><code>expErrEnumerationEmpty</code></code></dt>
<dd><a name="998228"> </a>There are no volumes to enumerate.</dd>

<dt><a name="998229"> </a><code><code>sysErrParamErr</code></code></dt>
<dd><a name="998230"> </a>The value pointed to by <code>volIteratorP</code> is not valid. This error is also returned when <code>volIteratorP</code> is <code>vfsIteratorStop</code>.</dd>

</dl>
<h4>
  <a name="998231"> </a>Comments 
</h4>

<p><a name="998232"> </a>This function returns a pointer to the volume reference number in the <code>volRefNumP</code> parameter. In order to traverse all volumes you must make repeated calls to <a href="VFSMgr.html#998210"><code>VFSVolumeEnumerate()</code></a> inside a loop. Before the first call to <code>VFSVolumeEnumerate</code>, the variable pointed to by <code>volIteratorP</code> should be initialized to <code>vfsIteratorStart</code>. Each iteration then increments <code>volIteratorP</code> to the next entry after updating <code>volRefNumP</code>. When the last volume is reached, <code>*volIteratorP</code> is set to <code>vfsIteratorStop</code>. If there are no volumes to enumerate, <code>VFSVolumeEnumerate</code> returns <code>expErrEnumerationEmpty</code> when first called.</p>
<h4>
  <a name="998236"> </a>Example 
</h4>

<p><a name="998237"> </a>Below is an example of how to use <code>VFSVolumeEnumerate</code>. </p>

<div class="CodeRule"><hr></div><pre class="CodeBlock">
UInt16 volRefNum;<a name="998238"> </a>
UInt32 volIterator = vfsIteratorStart;<a name="998239"> </a>
 <a name="998240"> </a>
while (volIterator != vfsIteratorStop) {<a name="998241"> </a>
   err = VFSVolumeEnumerate(&amp;volRefNum, &amp;volIterator); <a name="998242"> </a>
   if (err == errNone) {<a name="998243"> </a>
      // Do something with the volRefNum<a name="998244"> </a>
   } else {<a name="998245"> </a>
      // handle error... possibly by <a name="998246"> </a>
      // breaking out of the loop<a name="998247"> </a>
   }<a name="998248"> </a>
}<a name="998249"> </a>
</pre><div class="CodeRule"><hr></div>

<h4>
  <a name="998250"> </a>Compatibility 
</h4>

<p><a name="998254"> </a>Implemented only if the <a href="CompatibilityApdx.html#996319">VFS Manager Feature Set</a> is present.</p>

<h3 class="hbH3">
  <a name="998257"> </a>VFSVolumeFormat Function <a href="#995797"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="998259"> </a>Purpose 
</h4>

<p><a name="998260"> </a>Format and mount the volume installed in a given slot.</p>
<h4>
  <a name="998261"> </a>Declared In 
</h4>
<code>VfsMgr.h<a name="998262"> </a></code><h4>
  <a name="998263"> </a>Prototype 
</h4>
<pre class="proto"><a name="998264"></a>Err VFSVolumeFormat (
   UInt8 flags,
   UInt16 fsLibRefNum,
   VFSAnyMountParamPtr vfsMountParamP
)
</pre>
<h4>
  <a name="998265"> </a>Parameters 
</h4>

<dl>
<dt><a name="998266"> </a><code>&rarr;  <i><code>flags</code></i></code></dt>
<dd><a name="998267"> </a>Flags that control how the volume should be formatted. Currently, the only flag not reserved is <code>vfsMountFlagsUseThisFileSystem</code>. Pass this flag to cause the volume to be formatted using the file system specified by <code>fsLibRefNum</code>. Pass zero (0) to have the VFS Manager attempt to format the volume using a file system appropriate to the slot.</dd>

<dt><a name="998268"> </a><code>&rarr;  <i><code>fsLibRefNum</code></i></code></dt>
<dd><a name="998269"> </a>Reference number of the file system library for which the volume should be formatted. This number is obtained through a call to <a href="SystemManager.html#1076670"><code>SysLibFind()</code></a> with the name of the library you want to use. If the <code>flags</code> field is not set to <code>vfsMountFlagsUseThisFileSystem</code>, this parameter is ignored.</dd>

<dt><a name="998273"> </a><code>&harr;  <i><code>vfsMountParamP</code></i></code></dt>
<dd><a name="998274"> </a>Parameters to be used when formatting the volume and when mounting the volume after it has been formatted. Supply a pointer to either a <a href="VFSMgr.html#995918"><code>VFSSlotMountParamType</code></a> or a <a href="VFSMgr.html#995951"><code>VFSPOSEMountParamType</code></a> structure. Note that you'll need to cast your structure pointer to a <code>VFSAnyMountParamPtr</code>. Set the <code>mountClass</code> field to the appropriate value: if you are mounting to an Expansion Manager slot, set <code>mountClass</code> to <code>VFSMountClass_SlotDriver</code> and initialize <code>slotLibRefNum</code> and <code>slotRefNum</code> to the appropriate values. See the descriptions of <a href="VFSMgr.html#995874"><code>VFSAnyMountParamType</code></a>, <a href="VFSMgr.html#995918"><code>VFSSlotMountParamType</code></a>, and <a href="VFSMgr.html#995951"><code>VFSPOSEMountParamType</code></a> for information on the fields that make up these data structures.</dd>

</dl>
<h4>
  <a name="998290"> </a>Returns 
</h4>

<p><a name="998291"> </a>Returns one of the following error codes:</p>

<dl>
<dt><a name="998292"> </a><code><code>errNone </code></code></dt>
<dd><a name="998293"> </a>No error.</dd>

<dt><a name="998294"> </a><code><code>expErrNotEnoughPower</code></code></dt>
<dd><a name="998295"> </a>There is insufficient battery power to format and/or mount a volume.</dd>

<dt><a name="998296"> </a><code><code>expErrNotOpen</code></code></dt>
<dd><a name="998297"> </a>The file system library necessary for this call has not been installed or has not been opened.</dd>

<dt><a name="998298"> </a><code><code>vfsErrNoFileSystem</code></code></dt>
<dd><a name="998299"> </a>The VFS Manager cannot find an appropriate file system to handle the request.</dd>

</dl>
<h4>
  <a name="998300"> </a>Comments 
</h4>

<p><a name="998301"> </a>The slot driver currently only supports one volume per slot. If the volume is successfully formatted and mounted, the reference number of the mounted volume is returned in <code>vfsMountParamP-&gt;volRefNum</code>. If the format is unsuccessful or cancelled, <code>vfsMountParamP-&gt;volRefNum</code> is set to <code>vfsInvalidVolRef</code>.</p>

<p><a name="998302"> </a>If <code>vfsMountFlagsUseThisFileSystem</code> is passed as a flag, <code>VFSVolumeFormat</code> attempts to format the volume using the file system library specified by <code>fsLibRefNum</code>. Typically the flag parameter is not set. In this case <code>VFSVolumeFormat</code> tries to find a compatible library to format the volume, as follows:</p>
<ol type="1">
  <li value="1"><a name="998303"> </a>Check to see if the default file system library feature is set. If it is, and if that file system is installed, it is used to format the volume. You can set the default file system using <a href="FeatureManager.html#1037124"><code>FtrSet()</code></a>; supply <code>sysFileCVFSMgr</code> for the feature creator, and <code>vfsFtrIDDefaultFS</code> for the feature number.
  <li value="2"><a name="998307"> </a>Check to see if any of the installed file systems are natively supported for the slot on which the VFS Manager is trying to format. If one of them is, it is used to format the volume.
  <li value="3"><a name="998308"> </a>If none of the installed file systems can perform the format using the slot's native type, a dialog displays warning the user that their media may become incompatible with other devices if they continue with the format. The user may continue or cancel the format. If the user chooses to continue, <code>VFSVolumeFormat</code> formats the volume using the first file system library that was installed.
</ol>

<p><a name="998309"> </a>When calling <code>VFSVolumeFormat</code>, the volume can either be mounted or unmounted. The underlying file system library call requires the volume to be unmounted. <code>VFSVolumeFormat</code> checks to see if the volume is currently mounted and unmounts it, if necessary, using <a href="VFSMgr.html#998615"><code>VFSVolumeUnmount</code></a> before making the file system call. If the file system successfully formats the volume, <code>VFSVolumeFormat</code> mounts it and posts a <a href="Notifications.html#1048316"><code>sysNotifyVolumeMountedEvent</code></a> notification.</p>
<h4>
  <a name="998316"> </a>Example 
</h4>

<p><a name="998317"> </a>The following code excerpt formats a volume on an Expansion Manager slot using a compatible file system.</p>

<div class="CodeRule"><hr></div><pre class="CodeBlock">
VFSSlotMountParamType slotParam;<a name="998318"> </a>
UInt32 slotIterator = expIteratorStart;<a name="998319"> </a>
 <a name="998320"> </a>
slotParam.vfsMountParamP.mountClass = 
   VFSMountClass_SlotDriver;<a name="998321"> </a>
err = ExpSlotEnumerate(&amp;slotParam.slotRefNum, 
   &amp;slotIterator);<a name="998322"> </a>
err = ExpSlotLibFind(slotParam.slotRefNum,
   &amp;slotParam.slotLibRefNum);<a name="998323"> </a>
 <a name="998324"> </a>
err = VFSVolumeFormat(NULL, NULL, 
   (VFSAnyMountParamPtr) &amp; slotParam);<a name="998325"> </a>
</pre><div class="CodeRule"><hr></div>

<h4>
  <a name="998326"> </a>Compatibility 
</h4>

<p><a name="998330"> </a>Implemented only if the <a href="CompatibilityApdx.html#996319">VFS Manager Feature Set</a> is present.</p>
<h4>
  <a name="998331"> </a>See Also 
</h4>

<p><a name="998335"> </a><a href="VFSMgr.html#998428"><code>VFSVolumeMount()</code></a></p>

<h3 class="hbH3">
  <a name="998338"> </a>VFSVolumeGetLabel Function <a href="#995797"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="998340"> </a>Purpose 
</h4>

<p><a name="998341"> </a>Determine the volume label for a particular volume.</p>
<h4>
  <a name="998342"> </a>Declared In 
</h4>
<code>VfsMgr.h<a name="998343"> </a></code><h4>
  <a name="998344"> </a>Prototype 
</h4>
<pre class="proto"><a name="998345"></a>Err VFSVolumeGetLabel(
   UInt16 volRefNum,
   Char *labelP,
   UInt16 bufLen
)
</pre>
<h4>
  <a name="998346"> </a>Parameters 
</h4>

<dl>
<dt><a name="998347"> </a><code>&rarr;  <i><code>volRefNum</code></i></code></dt>
<dd><a name="998348"> </a>Volume reference number returned from <a href="VFSMgr.html#998210"><code>VFSVolumeEnumerate()</code></a>.</dd>

<dt><a name="998352"> </a><code>&larr;  <i><code>labelP</code></i></code></dt>
<dd><a name="998353"> </a>Pointer to a character buffer into which the volume name is placed.</dd>

<dt><a name="998354"> </a><code>&rarr;  <i><code>bufLen</code></i></code></dt>
<dd><a name="998355"> </a>Length, in bytes, of the <code>labelP</code> buffer.</dd>

</dl>
<h4>
  <a name="998356"> </a>Returns 
</h4>

<p><a name="998357"> </a>Returns one of the following error codes:</p>

<dl>
<dt><a name="998358"> </a><code><code>errNone</code> </code></dt>
<dd><a name="998359"> </a>No error.</dd>

<dt><a name="998360"> </a><code><code>expErrNotOpen</code></code></dt>
<dd><a name="998361"> </a>The file system library necessary for this call has not been installed or has not been opened.</dd>

<dt><a name="998362"> </a><code><code>vfsErrNoFileSystem</code></code></dt>
<dd><a name="998363"> </a>The VFS Manager cannot find an appropriate file system to handle the request.</dd>

<dt><a name="998364"> </a><code><code>vfsErrVolumeBadRef</code></code></dt>
<dd><a name="998365"> </a>The specified volume has not been mounted.</dd>

<dt><a name="998366"> </a><code><code>vfsErrBufferOverflow</code></code></dt>
<dd><a name="998367"> </a>The value specified in <code>bufLen</code> is not big enough to receive the full volume label.</dd>

<dt><a name="998368"> </a><code><code>vfsErrNameShortened</code></code></dt>
<dd><a name="998369"> </a>There was an error reading the full volume name. A shortened version is being returned.</dd>

</dl>
<h4>
  <a name="998370"> </a>Comments 
</h4>

<p><a name="998371"> </a>Volume reference numbers can change each time you mount a given volume. To keep track of a particular volume, save the volume's label rather than its reference number. Volume labels can be up to 255 characters long. They can contain any normal character, including spaces and lower case characters, in any character set as well as the following special characters: $ % ' - _ @ ~ ` ! ( ) ^ # &amp; + , ; = [ ].</p>
<h4>
  <a name="998372"> </a>Compatibility 
</h4>

<p><a name="998376"> </a>Implemented only if the <a href="CompatibilityApdx.html#996319">VFS Manager Feature Set</a> is present.</p>
<h4>
  <a name="998377"> </a>See Also 
</h4>

<p><a name="998381"> </a><a href="VFSMgr.html#998519"><code>VFSVolumeSetLabel()</code></a></p>

<h3 class="hbH3">
  <a name="998384"> </a>VFSVolumeInfo Function <a href="#995797"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="998386"> </a>Purpose 
</h4>

<p><a name="998387"> </a>Get information about the specified volume.</p>
<h4>
  <a name="998388"> </a>Declared In 
</h4>
<code>VfsMgr.h<a name="998389"> </a></code><h4>
  <a name="998390"> </a>Prototype 
</h4>
<pre class="proto"><a name="998391"></a>Err VFSVolumeInfo(
   UInt16 volRefNum,
   VolumeInfoType *volInfoP
)
</pre>
<h4>
  <a name="998392"> </a>Parameters 
</h4>

<dl>
<dt><a name="998393"> </a><code>&rarr;  <i><code>volRefNum</code></i></code></dt>
<dd><a name="998394"> </a>Volume reference number returned from <a href="VFSMgr.html#998210"><code>VFSVolumeEnumerate()</code></a>.</dd>

<dt><a name="998398"> </a><code>&larr;  <i><code>volInfoP</code></i></code></dt>
<dd><a name="998399"> </a>Pointer to the structure that receives the volume information for the specified volume. See <a href="VFSMgr.html#995976"><code>VolumeInfoType</code></a> for more information on the fields in this data structure.</dd>

</dl>
<h4>
  <a name="998403"> </a>Returns 
</h4>

<p><a name="998404"> </a>Returns one of the following error codes:</p>

<dl>
<dt><a name="998405"> </a><code><code>errNone</code> </code></dt>
<dd><a name="998406"> </a>No error.</dd>

<dt><a name="998407"> </a><code><code>expErrNotOpen</code></code></dt>
<dd><a name="998408"> </a>The file system library necessary for this call has not been installed or has not been opened.</dd>

<dt><a name="998409"> </a><code><code>vfsErrNoFileSystem</code></code></dt>
<dd><a name="998410"> </a>The VFS Manager cannot find an appropriate file system to handle the request.</dd>

<dt><a name="998411"> </a><code><code>vfsErrVolumeBadRef</code></code></dt>
<dd><a name="998412"> </a>The specified volume reference number is invalid.</dd>

</dl>
<h4>
  <a name="998413"> </a>Compatibility 
</h4>

<p><a name="998417"> </a>Implemented only if the <a href="CompatibilityApdx.html#996319">VFS Manager Feature Set</a> is present.</p>
<h4>
  <a name="998418"> </a>See Also 
</h4>

<p><a name="998425"> </a><a href="VFSMgr.html#998338"><code>VFSVolumeGetLabel()</code></a>, <a href="VFSMgr.html#998574"><code>VFSVolumeSize()</code></a></p>

<h3 class="hbH3">
  <a name="998428"> </a>VFSVolumeMount Function <a href="#995797"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="998430"> </a>Purpose 
</h4>

<p><a name="998431"> </a>Mount the card's volume on the specified slot.</p>
<h4>
  <a name="998432"> </a>Declared In 
</h4>
<code>VfsMgr.h<a name="998433"> </a></code><h4>
  <a name="998434"> </a>Prototype 
</h4>
<pre class="proto"><a name="998435"></a>Err VFSVolumeMount(
   UInt8 flags,
   UInt16 fsLibRefNum,
   VFSAnyMountParamPtr vfsMountParamP
)
</pre>
<h4>
  <a name="998436"> </a>Parameters 
</h4>

<dl>
<dt><a name="998437"> </a><code>&rarr;  <i><code>flags</code></i></code></dt>
<dd><a name="998438"> </a>Flags that control how the volume should be mounted. Currently, the only flag not reserved is <code>vfsMountFlagsUseThisFileSystem</code>. Pass this flag to cause the volume to be mounted using the file system specified by <code>fsLibRefNum</code>. Pass zero (0) to have the VFS Manager attempt to mount the volume using a file system appropriate for the slot.</dd>

<dt><a name="998439"> </a><code>&rarr;  <i><code>fsLibRefNum</code></i></code></dt>
<dd><a name="998440"> </a>Reference number of the file system library for which the volume should be mounted. This number is obtained through a call to <a href="SystemManager.html#1076670"><code>SysLibFind()</code></a> with the name of the library you want to use. If the <code>flags</code> field is not set to <code>vfsMountFlagsUseThisFileSystem</code>, this parameter is ignored.</dd>

<dt><a name="998444"> </a><code>&harr;  <i><code>vfsMountParamP</code></i></code></dt>
<dd><a name="998445"> </a>Parameters to be used when mounting the volume after it has been formatted. Supply a pointer to either a <a href="VFSMgr.html#995918"><code>VFSSlotMountParamType</code></a> or a <a href="VFSMgr.html#995951"><code>VFSPOSEMountParamType</code></a> structure. Note that you'll need to cast your structure pointer to a <code>VFSAnyMountParamPtr</code>. Set the <code>mountClass</code> field to the appropriate value: if you are mounting to an Expansion Manager slot, set <code>mountClass</code> to <code>VFSMountClass_SlotDriver</code> and initialize <code>slotLibRefNum</code> and <code>slotRefNum</code> to the appropriate values. See the descriptions of <a href="VFSMgr.html#995874"><code>VFSAnyMountParamType</code></a>, <a href="VFSMgr.html#995918"><code>VFSSlotMountParamType</code></a>, and <a href="VFSMgr.html#995951"><code>VFSPOSEMountParamType</code></a> for information on the fields that make up these data structures.</dd>

</dl>
<h4>
  <a name="998461"> </a>Returns 
</h4>

<p><a name="998462"> </a>Returns one of the following error codes:</p>

<dl>
<dt><a name="998463"> </a><code><code>errNone</code> </code></dt>
<dd><a name="998464"> </a>No error.</dd>

<dt><a name="998465"> </a><code><code>expErrNotEnoughPower</code></code></dt>
<dd><a name="998466"> </a>There is insufficient battery power to mount a volume.</dd>

<dt><a name="998467"> </a><code><code>expErrNotOpen</code></code></dt>
<dd><a name="998468"> </a>The file system library necessary for this call has not been installed or has not been opened.</dd>

<dt><a name="998469"> </a><code><code>sysErrParamErr</code></code></dt>
<dd><a name="998470"> </a><code>vfsMountParamP</code> was initialized to <code>NULL</code>.</dd>

<dt><a name="998471"> </a><code><code>vfsErrNoFileSystem</code></code></dt>
<dd><a name="998472"> </a>The VFS Manager cannot find an appropriate file system to handle the request.</dd>

<dt><a name="998473"> </a><code><code>vfsErrVolumeStillMounted</code></code></dt>
<dd><a name="998474"> </a>The volume is already mounted with a different file system than was specified in <code>fsLibRefNum</code>.</dd>

</dl>
<h4>
  <a name="998475"> </a>Comments 
</h4>

<p><a name="998476"> </a>The slot driver only supports one volume per slot. The reference number of the mounted volume is returned in <code>vfsMountParamP-&gt;volRefNum</code>. If <code>vfsMountFlagsUseThisFileSystem</code> is passed as a flag, <code>VFSVolumeMount</code> attempts to mount the volume using the file system library specified by <code>fsLibRefNum</code>. Otherwise <code>VFSVolumeMount</code> tries to find a file system library which is able to mount the volume. If none of the installed file system libraries is able to mount the volume, <code>VFSVolumeMount</code> attempts to re-format the volume (using <a href="VFSMgr.html#998257"><code>VFSVolumeFormat()</code></a>) and then mount it. If <code>VFSVolumeMount</code> manages to successfully mount the volume, it ends by posting a <a href="Notifications.html#1048316"><code>sysNotifyVolumeMountedEvent</code></a> notification.</p>

<p><a name="998483"> </a>After VFSVolumeMount successfully mounts a volume, it broadcasts <code>sysNotifyVolumeMountedEvent</code>. The VFS Manager, upon being notified of this event, searches the newly-mounted volume for <code>/PALM/start.prc</code>. If <code>start.prc</code> is found in the <code>/PALM</code> directory, the VFS Manager copies it to main memory and launches it. If start.prc is not found, the VFS Manager switches to the Launcher instead. This behavior can be overridden; see <a href="../PalmOSCompanion/ExpAndVFSConcepts.html#1031850">Card Insertion and Removal</a> in <a href="../PalmOSCompanion/ExpAndVFSConcepts.html#1031615">Chapter 7, "Expansion,"</a> <i>Palm OS Programmer's Companion</i>, vol. I.</p>

<p><a name="998493"> </a>When <code>VFSVolumeMount</code> is called, if the volume is already mounted with a different file system than was specified in <code>fsLibRefNum</code>, a <code>vfsErrVolumeStillMounted</code> error is returned. If the volume is already mounted with the same file system that is specified in <code>fsLibRefNum</code>, or if <code>vfsMountFlagsUseThisFileSystem</code> is not set, <code>VFSVolumeMount</code> returns <code>errNone</code> and sets <code>volRefNumP</code> to the reference number of the currently mounted volume.</p>
<h4>
  <a name="998494"> </a>Example 
</h4>

<p><a name="998495"> </a>The following code excerpt mounts a volume on an Expansion Manager slot using a compatible file system.</p>

<div class="CodeRule"><hr></div><pre class="CodeBlock">
VFSSlotMountParamType slotParam ;<a name="998496"> </a>
UInt32 slotIterator = expIteratorStart;<a name="998497"> </a>
 <a name="998498"> </a>
slotParam.vfsMountParamP.mountClass = 
   VFSMountClass_SlotDriver;<a name="998499"> </a>
err = ExpSlotEnumerate(&amp;slotParam.slotRefNum, 
   &amp;slotIterator);<a name="998500"> </a>
err = ExpSlotLibFind(slotParam.slotRefNum, 
   &amp;slotParam.slotLibRefNum);<a name="998501"> </a>
 <a name="998502"> </a>
err = VFSVolumeMount(NULL, NULL,
   (VFSAnyMountParamPtr) &amp; slotParam);<a name="998503"> </a>
</pre><div class="CodeRule"><hr></div>

<h4>
  <a name="998504"> </a>Compatibility 
</h4>

<p><a name="998508"> </a>Implemented only if the <a href="CompatibilityApdx.html#996319">VFS Manager Feature Set</a> is present.</p>
<h4>
  <a name="998509"> </a>See Also 
</h4>

<p><a name="998516"> </a><a href="VFSMgr.html#998257"><code>VFSVolumeFormat()</code></a>, <a href="VFSMgr.html#998615"><code>VFSVolumeUnmount()</code></a></p>

<h3 class="hbH3">
  <a name="998519"> </a>VFSVolumeSetLabel Function <a href="#995797"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="998521"> </a>Purpose 
</h4>

<p><a name="998522"> </a>Changes the volume label for a mounted volume.</p>
<h4>
  <a name="998523"> </a>Declared In 
</h4>
<code>VfsMgr.h<a name="998524"> </a></code><h4>
  <a name="998525"> </a>Prototype 
</h4>
<pre class="proto"><a name="998526"></a>Err VFSVolumeSetLabel(
   UInt16 volRefNum,
   const Char *labelP
)
</pre>
<h4>
  <a name="998527"> </a>Parameters 
</h4>

<dl>
<dt><a name="998528"> </a><code>&rarr;  <i><code>volRefNum</code></i></code></dt>
<dd><a name="998529"> </a>Volume reference number returned from <a href="VFSMgr.html#998210"><code>VFSVolumeEnumerate()</code></a>.</dd>

<dt><a name="998533"> </a><code>&rarr;  <i><code>labelP</code></i></code></dt>
<dd><a name="998534"> </a>Pointer to the label to be applied to the specified volume. This string must be null-terminated.</dd>

</dl>
<h4>
  <a name="998535"> </a>Returns 
</h4>

<p><a name="998536"> </a>Returns one of the following error codes:</p>

<dl>
<dt><a name="998537"> </a><code><code>errNone</code> </code></dt>
<dd><a name="998538"> </a>No error</dd>

<dt><a name="998539"> </a><code><code>expErrNotOpen</code></code></dt>
<dd><a name="998540"> </a>The file system library necessary for this call has not been installed or has not been opened.</dd>

<dt><a name="998541"> </a><code><code>vfsErrBadName</code></code></dt>
<dd><a name="998542"> </a>The supplied label is invalid.</dd>

<dt><a name="998543"> </a><code><code>vfsErrNameShortened</code></code></dt>
<dd><a name="998544"> </a>Indicates that the label name was too long. A shortened version of the label name was used instead.</dd>

<dt><a name="998545"> </a><code><code>vfsErrVolumeBadRef</code></code></dt>
<dd><a name="998546"> </a>The specified volume has not been mounted.</dd>

</dl>
<h4>
  <a name="998547"> </a>Comments 
</h4>

<p><a name="998548"> </a>Volume labels can be up to 255 characters long. They can contain any normal character, including spaces and lower case characters, in any character set as well as the following special characters: $ % ' - _ @ ~ ` ! ( ) ^ # &amp; + , ; = [ ]. See <a href="../PalmOSCompanion/ExpAndVFSConcepts.html#1032160">Naming Volumes</a> in <a href="../PalmOSCompanion/ExpAndVFSConcepts.html#1031615">Chapter 7, "Expansion,"</a><i>Palm OS Programmer's Companion</i>, vol. I for guidelines on naming.</p>

<div><hr>
  <a name="998558"> </a> <b>NOTE: </b> Most clients should not need to call this function. This function may create or delete a file in the root directory, which would invalidate any current calls to <a href="VFSMgr.html#996564"><code>VFSDirEntryEnumerate()</code></a>.
<hr>
</div>
<h4>
  <a name="998562"> </a>Compatibility 
</h4>

<p><a name="998566"> </a>Implemented only if the <a href="CompatibilityApdx.html#996319">VFS Manager Feature Set</a> is present.</p>
<h4>
  <a name="998567"> </a>See Also 
</h4>

<p><a name="998571"> </a><a href="VFSMgr.html#998338"><code>VFSVolumeGetLabel()</code></a></p>

<h3 class="hbH3">
  <a name="998574"> </a>VFSVolumeSize Function <a href="#995797"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="998576"> </a>Purpose 
</h4>

<p><a name="998577"> </a>Determine the total amount of space on a volume, as well as the amount that is currently being used.</p>
<h4>
  <a name="998578"> </a>Declared In 
</h4>
<code>VfsMgr.h<a name="998579"> </a></code><h4>
  <a name="998580"> </a>Prototype 
</h4>
<pre class="proto"><a name="998581"></a>Err VFSVolumeSize(
   UInt16 volRefNum,
   UInt32 *volumeUsedP,
   UInt32 *volumeTotalP
)
</pre>
<h4>
  <a name="998582"> </a>Parameters 
</h4>

<dl>
<dt><a name="998583"> </a><code>&rarr;  <i><code>volRefNum</code></i></code></dt>
<dd><a name="998584"> </a>Volume reference number returned from <a href="VFSMgr.html#998210"><code>VFSVolumeEnumerate()</code></a>.</dd>

<dt><a name="998588"> </a><code>&larr;  <i><code>volumeUsedP</code></i></code></dt>
<dd><a name="998589"> </a>Pointer to a variable that receives the amount of space, in bytes, in use on the volume.</dd>

<dt><a name="998590"> </a><code>&larr;  <i><code>volumeTotalP</code></i></code></dt>
<dd><a name="998591"> </a>Pointer to a variable that receives the total amount of space on the volume, in bytes.</dd>

</dl>
<h4>
  <a name="998592"> </a>Returns 
</h4>

<p><a name="998593"> </a>Returns one of the following error codes:</p>

<dl>
<dt><a name="998594"> </a><code><code>errNone</code> </code></dt>
<dd><a name="998595"> </a>No error.</dd>

<dt><a name="998596"> </a><code><code>expErrNotOpen</code></code></dt>
<dd><a name="998597"> </a>The file system library necessary for this call has not been installed or has not been opened.</dd>

<dt><a name="998598"> </a><code><code>vfsErrNoFileSystem</code></code></dt>
<dd><a name="998599"> </a>The VFS Manager cannot find an appropriate file system to handle the request.</dd>

<dt><a name="998600"> </a><code><code>vfsErrVolumeBadRef</code></code></dt>
<dd><a name="998601"> </a>The specified volume has not been mounted.</dd>

</dl>
<h4>
  <a name="998602"> </a>Compatibility 
</h4>

<p><a name="998606"> </a>Implemented only if the <a href="CompatibilityApdx.html#996319">VFS Manager Feature Set</a> is present.</p>
<h4>
  <a name="998607"> </a>See Also 
</h4>

<p><a name="998611"> </a><a href="VFSMgr.html#998384"><code>VFSVolumeInfo()</code></a></p>

<h3 class="hbH3">
  <a name="998615"> </a>VFSVolumeUnmount Function <a href="#995797"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="998617"> </a>Purpose 
</h4>

<p><a name="998618"> </a>Unmount the given volume.</p>
<h4>
  <a name="998619"> </a>Declared In 
</h4>
<code>VfsMgr.h<a name="998620"> </a></code><h4>
  <a name="998621"> </a>Prototype 
</h4>
<pre class="proto"><a name="998622"></a>Err VFSVolumeUnmount(
   UInt16 volRefNum
)
</pre>
<h4>
  <a name="998623"> </a>Parameters 
</h4>

<dl>
<dt><a name="998624"> </a><code>&rarr;  <i><code>volRefNum</code></i></code></dt>
<dd><a name="998625"> </a>Volume reference number returned from <a href="VFSMgr.html#998210"><code>VFSVolumeEnumerate()</code></a>.</dd>

</dl>
<h4>
  <a name="998629"> </a>Returns 
</h4>

<p><a name="998630"> </a>Returns one of the following error codes:</p>

<dl>
<dt><a name="998631"> </a><code><code>errNone</code> </code></dt>
<dd><a name="998632"> </a>No error.</dd>

<dt><a name="998633"> </a><code><code>expErrNotOpen</code></code></dt>
<dd><a name="998634"> </a>The file system library necessary for this call has not been installed or has not been opened.</dd>

<dt><a name="998635"> </a><code><code>vfsErrNoFileSystem</code></code></dt>
<dd><a name="998636"> </a>The VFS Manager cannot find an appropriate file system to handle the request.</dd>

<dt><a name="998637"> </a><code><code>vfsErrVolumeBadRef</code></code></dt>
<dd><a name="998638"> </a>The specified volume has not been mounted.</dd>

</dl>
<h4>
  <a name="998639"> </a>Comments 
</h4>

<p><a name="998640"> </a>This function closes any opened files and posts a <a href="Notifications.html#1048339"><code>sysNotifyVolumeUnmountedEvent</code></a> notification once the file system is successfully unmounted.</p>
<h4>
  <a name="998644"> </a>Compatibility 
</h4>

<p><a name="998648"> </a>Implemented only if the <a href="CompatibilityApdx.html#996319">VFS Manager Feature Set</a> is present.</p>
<h4>
  <a name="998649"> </a>See Also 
</h4>

<p><a name="998653"> </a><a href="VFSMgr.html#998428"><code>VFSVolumeMount()</code></a></p>

<h2 class="haH2">
  <a name="998655"> </a>Application-Defined Functions <a href="#995797"><span class="nav">^TOP^</span></a>
</h2>


<h3 class="hbH3">
  <a name="998658"> </a>VFSExportProcPtr Function <a href="#995797"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="998660"> </a>Purpose 
</h4>

<p><a name="998661"> </a>User-defined callback function supplied to <a href="VFSMgr.html#996699"><code>VFSExportDatabaseToFileCustom()</code></a> that tracks the progress of the export.</p>
<h4>
  <a name="998665"> </a>Declared In 
</h4>
<code>VfsMgr.h<a name="998666"> </a></code><h4>
  <a name="998667"> </a>Prototype 
</h4>
<pre class="proto"><a name="998668"></a>typedef Err (
   *VFSExportProcPtr
) (
   UInt32 totalBytes,
   UInt32 offset,
   void *userDataP
)
</pre>
<h4>
  <a name="998669"> </a>Parameters 
</h4>

<dl>
<dt><a name="998670"> </a><code><code>totalBytes</code></code></dt>
<dd><a name="998671"> </a>The total number of bytes being exported.</dd>

<dt><a name="998672"> </a><code><code>offset</code></code></dt>
<dd><a name="998673"> </a>Undefined.</dd>

<dt><a name="998674"> </a><code><code>userDataP</code></code></dt>
<dd><a name="998675"> </a>Pointer to any application-specific data passed to the callback function. This pointer may be <code>NULL</code> if your callback doesn't need any such data.</dd>

</dl>
<h4>
  <a name="998676"> </a>Returns 
</h4>

<p><a name="998677"> </a>Your progress tracker should allow the user to abort the export. Return <code>errNone</code> if the export should continue, or any other value to abort the export process. If you return a value other than <code>errNone</code>, that value will be returned by <a href="VFSMgr.html#996699"><code>VFSExportDatabaseToFileCustom()</code></a>.</p>
<h4>
  <a name="998681"> </a>Comments 
</h4>

<p><a name="998687"> </a>See the <a href="../PalmOSCompanion/UserInterface.html#1008406">Progress Dialogs</a> section in the <i>Palm OS Programmer's Companion</i>, vol. I for more information on writing a progress tracker.</p>
<h4>
  <a name="998689"> </a>Compatibility 
</h4>

<p><a name="998693"> </a>Implemented only if the <a href="CompatibilityApdx.html#996319">VFS Manager Feature Set</a> is present.</p>
<h4>
  <a name="998694"> </a>See Also 
</h4>

<p><a name="998698"> </a><a href="VFSMgr.html#998701"><code>VFSImportProcPtr()</code></a></p>

<h3 class="hbH3">
  <a name="998701"> </a>VFSImportProcPtr Function <a href="#995797"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="998703"> </a>Purpose 
</h4>

<p><a name="998704"> </a>User-defined callback function supplied to <a href="VFSMgr.html#997978"><code>VFSImportDatabaseFromFileCustom()</code></a> that tracks the progress of the import.</p>
<h4>
  <a name="998708"> </a>Declared In 
</h4>
<code>VfsMgr.h<a name="998709"> </a></code><h4>
  <a name="998710"> </a>Prototype 
</h4>
<pre class="proto"><a name="998711"></a>typedef Err (
   *VFSImportProcPtr
) (
   UInt32 totalBytes,
   UInt32 offset,
   void *userDataP
)
</pre>
<h4>
  <a name="998712"> </a>Parameters 
</h4>

<dl>
<dt><a name="998713"> </a><code><code>totalBytes</code></code></dt>
<dd><a name="998714"> </a>The total number of bytes being imported.</dd>

<dt><a name="998715"> </a><code><code>offset</code></code></dt>
<dd><a name="998716"> </a>The number of bytes that have already been imported. This value, along with the total number of bytes being imported, allows you to inform the user how far along the import is.</dd>

<dt><a name="998717"> </a><code><code>userDataP</code></code></dt>
<dd><a name="998718"> </a>Pointer to NY application-specific data passed to the callback function. This pointer may be <code>NULL</code> if your callback doesn't need any such data.</dd>

</dl>
<h4>
  <a name="998719"> </a>Returns 
</h4>

<p><a name="998720"> </a>Your progress tracker should allow the user to abort the import. Return <code>errNone</code> if the import should continue, or any other value to abort the import process. If you return a value other than <code>errNone</code>, that value will be returned by <a href="VFSMgr.html#997978"><code>VFSImportDatabaseFromFileCustom()</code></a>.</p>
<h4>
  <a name="998724"> </a>Comments 
</h4>

<p><a name="998730"> </a>See the <a href="../PalmOSCompanion/UserInterface.html#1008406">Progress Dialogs</a> section in the <i>Palm OS Programmer's Companion</i>, vol. I for more information on writing a progress tracker.</p>
<h4>
  <a name="998732"> </a>Compatibility 
</h4>

<p><a name="998736"> </a>Implemented only if the <a href="CompatibilityApdx.html#996319">VFS Manager Feature Set</a> is present.</p>
<h4>
  <a name="998737"> </a>See Also 
</h4>

<p><a name="998741"> </a><a href="VFSMgr.html#998658"><code>VFSExportProcPtr()</code></a></p>

<p><a name="998742"> </a></p>
&nbsp;<br>
</div>
<!--END CONTENT-->

</td>
<td width="5">&nbsp;&nbsp;</td>
</tr>

</table>

<!-- BEGIN FOOTER -->
<table width="100%" border="0" cellspacing="0" cellpadding="0">
<tr>
<td width="7" rowspan="2"><img name="index_x" src="images/shim.gif" width="7" height="33" border="0" alt=""></td>
<td align="left"><img name="dashes" src="images/dashes.gif" width="744" height="3" border="0" alt=""></td>
<td width="10" rowspan="2"><img name="index_x" src="images/shim.gif" width="10" height="33" border="0" alt=""></td>
</tr>
<tr>
<td align="center">
<p class="footer">
Copyright © 1996-2004, PalmSource, Inc. and its affiliates.  All rights reserved. <br>
<a href="http://www.palmsource.com/contact/">Write Us</a> | <a href="http://www.palmos.com/dev/training/">Training</a> | <a href="http://www.palmos.com/dev/support/kb/">Knowledge Base</a> | <a href="Reference_Front.html" target="_blank">Legal</a></p>
<br>
<!--BEGIN BOOK NAVIGATION-->
<p class="nav">
<A href="http://www.palmos.com/dev/support/docs/">Documentation</a>&nbsp;&nbsp;|&nbsp;&nbsp;
<a href="ReferenceTOC.html">Table of Contents</a>&nbsp;&nbsp;
             |&nbsp;&nbsp;<a href="DateAndTimeManager.html">&lt;&nbsp;Previous</a>&nbsp;&nbsp;
             |&nbsp;&nbsp;<a href="Window.html">Next&nbsp;&gt;</a>&nbsp;&nbsp;
             |&nbsp;&nbsp;<a href="ReferenceIX.html">Index</a>
</p>
</td>
</tr>
</table>
<!-- END FOOTER -->

</body>
</html>