<html>
<head>
<title>(68K) Serial Manager | Palm OS&#174; Programmer's  API Reference</title> 
<link href="psi_devpubs.css" rel="stylesheet" type="text/css">

<!-- BEGIN META DATA -->
<meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
<META NAME="PSITEMPLATE" CONTENT="1006-007 PalmSource_HTML_2003 20041101">
<META NAME="GENERATOR" CONTENT="Quadralay WebWorks AutoMap 2003 for FrameMaker 8.0.6.2138">
<META NAME="LASTUPDATED" CONTENT="11/22/04 10:47:07">
<!-- END META DATA -->
</head>

<body bgcolor="#ffffff" text="#000000" leftmargin="0" topmargin="0" marginwidth="0" marginheight="0">
<a name="1020300"></a>

<!-- BEGIN TOPNAV -->
<table width="100%" border="0" cellspacing="0" cellpadding="0">
<tr>
<td><img src="images/shim.gif" width="7" height="75" border="0" alt=""></td>
<td align="left"><table border="0" cellpadding="0" cellspacing="0" width="744">
<tr>
<td><img name="index_r2_c1" src="images/shim.gif" width="25" height="75" border="0" alt=""></td>
<td valign="top"><table border="0" cellpadding="0" cellspacing="0" width="96">
<tr>
<td><img name="index_r2_c4" src="images/shim.gif" width="96" height="15" border="0" alt=""></td>
</tr>
<tr>
<td><a href="http://www.palmsource.com/"><img name="ps_logo" src="images/ps_logo.gif" width="96" height="54" border="0" alt=""></a></td>
</tr>

</table>
</td>

<td><table border="0" cellpadding="0" cellspacing="0" width="30">
<td><img name="index_x" src="images/shim.gif" width="30" height="75" border="0" alt=""></td>
</table></td>

<!--BEGIN MASTHEAD-->
<td><table border="0" cellpadding="0" cellspacing="0" width="96">
<tr>
<td><img name="index_x" src="images/shim.gif" width="615" height="5" border="0" alt=""></td>
</tr>
<tr>
<td>
<!--BEGIN BOOK NAVIGATION-->
<span class="nav">
<A href="http://www.palmos.com/dev/support/docs/">Documentation</a>&nbsp;&nbsp;|&nbsp;&nbsp;
<a href="ReferenceTOC.html">Table of Contents</a>&nbsp;&nbsp;
             |&nbsp;&nbsp;<a href="SerialDriver.html">&lt;&nbsp;Previous</a>&nbsp;&nbsp;
             |&nbsp;&nbsp;<a href="OldSerialManager.html">Next&nbsp;&gt;</a>&nbsp;&nbsp;
             |&nbsp;&nbsp;<a href="ReferenceIX.html">Index</a>
</span>
<!--END BOOK NAVIGATION-->
</tr>
<tr>
<td>
<!--BEGIN PAGE TITLE-->
<h2 class="PageTitle">70 &nbsp;&nbsp;
Serial Manager</h2></td>
<!--END PAGE TITLE-->
</tr>
<tr>
<td>
<!--BEGIN BOOK TITLE-->
<p class="BookTitle">Palm OS&#174; Programmer's  API Reference</p>
<p class="SubTitle">Palm OS&#174; 68K SDK </p>
<!--END BOOK TITLE-->
</td>
</tr>
<tr>
<td><img name="index_x" src="images/shim.gif" width="615" height="5" border="0" alt=""></td>
</tr>
</table>
</td>
<!--END MASTHEAD-->
</tr>
</table>
<img name="dashes" src="images/dashes.gif" width="744" height="3" border="0" alt=""></td>
</tr>
</table>
<!-- END TOPNAV -->

<table width="100%" border="0" cellspacing="0" cellpadding="0">
<tr>
<td valign="top" width="5"><img name="index_x" src="images/shim.gif" width="5" height="33" border="0" alt=""></td>

<!--BEGIN SIDETOC-->
<td valign="top" width="175">
<div id="sidetoc" valign="bottom">
<h1 class="SideTOC1-PartTab"><a href="PartIII.html">Part III: Communications</a> </h1>
<h1 class="SideTOC1"><a href="SerialManager.html">70  Serial Manager</a></h1>

   <h2 class="SideTOC2"><a href="#1020330">
   Serial Manager Data Structures</a></h2>

      <h3 class="SideTOC3"><a href="#1020333">
      DeviceInfoType</a></h3>

      <h3 class="SideTOC3"><a href="#1020380">
      SrmCtlEnum</a></h3>

      <h3 class="SideTOC3"><a href="#1020533">
      SrmOpenConfigType</a></h3>

   <h2 class="SideTOC2"><a href="#1020611">
   Serial Manager Constants</a></h2>

      <h3 class="SideTOC3"><a href="#1020613">
      Port Constants</a></h3>

      <h3 class="SideTOC3"><a href="#1020769">
      Serial Capabilities Constants</a></h3>

      <h3 class="SideTOC3"><a href="#1020831">
      Serial Settings Constants</a></h3>

      <h3 class="SideTOC3"><a href="#1020943">
      Status Constants</a></h3>

      <h3 class="SideTOC3"><a href="#1020983">
      Line Error Constants</a></h3>

   <h2 class="SideTOC2"><a href="#1021040">
   Serial Manager Functions</a></h2>

      <h3 class="SideTOC3"><a href="#1021043">
      SrmClearErr</a></h3>

      <h3 class="SideTOC3"><a href="#1021073">
      SrmClose</a></h3>

      <h3 class="SideTOC3"><a href="#1021112">
      SrmControl</a></h3>

      <h3 class="SideTOC3"><a href="#1021290">
      SrmCustomControl</a></h3>

      <h3 class="SideTOC3"><a href="#1021346">
      SrmExtOpen</a></h3>

      <h3 class="SideTOC3"><a href="#1021416">
      SrmExtOpenBackground</a></h3>

      <h3 class="SideTOC3"><a href="#1021488">
      SrmGetDeviceCount</a></h3>

      <h3 class="SideTOC3"><a href="#1021514">
      SrmGetDeviceInfo</a></h3>

      <h3 class="SideTOC3"><a href="#1021560">
      SrmGetStatus</a></h3>

      <h3 class="SideTOC3"><a href="#1021606">
      SrmOpen</a></h3>

      <h3 class="SideTOC3"><a href="#1021657">
      SrmOpenBackground</a></h3>

      <h3 class="SideTOC3"><a href="#1021712">
      SrmPrimeWakeupHandler</a></h3>

      <h3 class="SideTOC3"><a href="#1021762">
      SrmReceive</a></h3>

      <h3 class="SideTOC3"><a href="#1021832">
      SrmReceiveCheck</a></h3>

      <h3 class="SideTOC3"><a href="#1021883">
      SrmReceiveFlush</a></h3>

      <h3 class="SideTOC3"><a href="#1021935">
      SrmReceiveWait</a></h3>

      <h3 class="SideTOC3"><a href="#1022011">
      SrmReceiveWindowClose</a></h3>

      <h3 class="SideTOC3"><a href="#1029031">
      SrmReceiveWindowOpen</a></h3>

      <h3 class="SideTOC3"><a href="#1022118">
      SrmSend</a></h3>

      <h3 class="SideTOC3"><a href="#1022183">
      SrmSendCheck</a></h3>

      <h3 class="SideTOC3"><a href="#1022235">
      SrmSendFlush</a></h3>

      <h3 class="SideTOC3"><a href="#1022284">
      SrmSendWait</a></h3>

      <h3 class="SideTOC3"><a href="#1022341">
      SrmSetReceiveBuffer</a></h3>

      <h3 class="SideTOC3"><a href="#1022385">
      SrmSetWakeupHandler</a></h3>

   <h2 class="SideTOC2"><a href="#1022441">
   Serial Manager Application-Defined Functions</a></h2>

      <h3 class="SideTOC3"><a href="#1022445">
      WakeupHandlerProcPtr</a></h3>

</div>
</td>

<td width="5">&nbsp;&nbsp;</td>
<td width="2" background="images/index_r8_c10.gif"><img src="images/shim.gif" width="2" height="75" border="0" alt=""></td>
<td width="5">&nbsp;&nbsp;</td>

<!--END SIDETOC-->

<td valign="top">

<!--BEGIN CONTENT-->
<div id="content" valign="bottom">
<p><a name="1020303"> </a>This chapter provides reference material for the Serial Manager API:</p>
<ul type="disc">
  <li><a name="1020307"> </a><a href="SerialManager.html#1020330">Serial Manager Data Structures</a>
  <li><a name="1020311"> </a><a href="SerialManager.html#1020611">Serial Manager Constants</a>
  <li><a name="1020315"> </a><a href="SerialManager.html#1021040">Serial Manager Functions</a>
  <li><a name="1020319"> </a><a href="SerialManager.html#1022441">Serial Manager Application-Defined Functions</a>
</ul>

<p><a name="1020321"> </a>The header file <code>SerialMgr.h</code> declares the Serial Manager API. The file <code>SystemResources.h</code> defines some serial port constants. For more information on the Serial Manager, see the chapter <a href="../PalmOSCompanion2/SerialCommunication.html#1018070">"Serial Communication"</a> of the <i>Palm OS Programmer's Companion</i>, vol. II, <i>Communications</i>. </p>

<h2 class="haH2">
  <a name="1020330"> </a>Serial Manager Data Structures <a href="#1020300"><span class="nav">^TOP^</span></a>
</h2>


<h3 class="hbH3">
  <a name="1020333"> </a>DeviceInfoType Struct <a href="#1020300"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="1020335"> </a>Purpose 
</h4>

<p><a name="1020337"> </a>The <code>DeviceInfoType</code> structure defines information about a serial device. This structure is returned by the <a href="SerialManager.html#1021514"><code>SrmGetDeviceInfo()</code></a> function.</p>
<h4>
  <a name="1020342"> </a>Prototype 
</h4>
<pre class="proto"><a name="1020343"></a>typedef struct DeviceInfoType {
  UInt32 serDevCreator; 
  UInt32 serDevFtrInfo; 
  UInt32 serDevMaxBaudRate; 
  UInt32 serDevHandshakeBaud; 
  Char *serDevPortInfoStr; 
  UInt8 reserved[8];
} DeviceInfoType;
</pre>
<pre class="proto"><a name="1020351"></a>typedef DeviceInfoType *DeviceInfoPtr;
</pre>
<h4>
  <a name="1024162"> </a>Fields 
</h4>

<dl>
<dt><a name="1020355"> </a><code><code>serDevCreator</code> </code></dt>
<dd><a name="1020357"> </a>Four-character creator ID for serial driver.</dd>

<dt><a name="1020359"> </a><code><code>serDevFtrInfo</code> </code></dt>
<dd><a name="1020361"> </a>Flags defining features of this serial hardware. See <a href="SerialManager.html#1020769">Serial Capabilities Constants</a> for a description of these flags.</dd>

<dt><a name="1020366"> </a><code><code>serDevMaxBaudRate</code> </code></dt>
<dd><a name="1020368"> </a>Maximum baud rate for this device.</dd>

<dt><a name="1020370"> </a><code><code>serDevHandshakeBaud</code> </code></dt>
<dd><a name="1020372"> </a>Hardware handshaking is recommended for baud rates over this rate.</dd>

<dt><a name="1020374"> </a><code><code>serDevPortInfoStr</code> </code></dt>
<dd><a name="1020376"> </a>Description of serial hardware device or virtual device.</dd>

</dl>

<h3 class="hbH3">
  <a name="1020380"> </a>SrmCtlEnum Enum <a href="#1020300"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="1020382"> </a>Purpose 
</h4>

<p><a name="1020384"> </a>The <code>SrmCtlEnum</code> enumerated type specifies a serial control operation. Specify one of these enumerated types for the <code>op</code> parameter to the <a href="SerialManager.html#1021112"><code>SrmControl()</code></a> call.</p>
<h4>
  <a name="1020389"> </a>Prototype 
</h4>
<pre class="proto"><a name="1020390"></a>typedef enum SrmCtlEnum {
  srmCtlFirstReserved = 0,
  srmCtlSetBaudRate, 
  srmCtlGetBaudRate, 
  srmCtlSetFlags, 
  srmCtlGetFlags, 
  srmCtlSetCtsTimeout, 
  srmCtlGetCtsTimeout, 
  srmCtlStartBreak, 
  srmCtlStopBreak, 
  srmCtlStartLocalLoopback, 
  srmCtlStopLocalLoopback, 
  srmCtlIrDAEnable, 
  srmCtlIrDADisable, 
  srmCtlRxEnable, 
  srmCtlRxDisable, 
  srmCtlEmuSetBlockingHook, 
  srmCtlUserDef, 
  srmCtlGetOptimalTransmitSize, 
  srmCtlSetDTRAsserted,
  srmCtlGetDTRAsserted,
  srmCtlSetYieldPortCallback,
  srmCtlSetYieldPortRefCon,
  srmCtlSystemReserved = 0x7000
  srmCtlCustom = 0x8000,
  srmCtlLAST
} SrmCtlEnum;
</pre>
<h4>
  <a name="1024235"> </a>Constants 
</h4>

<dl>
<dt><a name="1020420"> </a><code><code>srmCtlSetBaudRate </code></code></dt>
<dd><a name="1020422"> </a>Sets the current baud rate for the serial hardware.</dd>

<dt><a name="1020424"> </a><code><code>srmCtlGetBaudRate </code></code></dt>
<dd><a name="1020426"> </a>Gets the current baud rate for the serial hardware.</dd>

<dt><a name="1020428"> </a><code><code>srmCtlSetFlags </code></code></dt>
<dd><a name="1020430"> </a>Sets the current flag settings for the serial hardware. Specify flags from the set described in <a href="SerialManager.html#1020831">Serial Settings Constants</a>.</dd>

<dt><a name="1020435"> </a><code><code>srmCtlGetFlags </code></code></dt>
<dd><a name="1020437"> </a>Gets the current flag settings for the serial hardware. </dd>

<dt><a name="1020439"> </a><code><code>srmCtlSetCtsTimeout</code></code></dt>
<dd><a name="1020441"> </a>Sets the current CTS timeout value for hardware handshaking.</dd>

<dt><a name="1020443"> </a><code><code>srmCtlGetCtsTimeout</code></code></dt>
<dd><a name="1020445"> </a>Gets the current CTS timeout value for hardware handshaking.</dd>

<dt><a name="1020447"> </a><code><code>srmCtlStartBreak</code></code></dt>
<dd><a name="1020449"> </a>Turn RS-232 break signal on. Caller is responsible for turning this signal on and off and insuring it is on long enough to generate a viable break.</dd>

<dt><a name="1020451"> </a><code><code>srmCtlStopBreak</code></code></dt>
<dd><a name="1020453"> </a>Turn RS-232 break signal off.</dd>

<dt><a name="1020455"> </a><code><code>srmCtlStartLocalLoopback</code></code></dt>
<dd><a name="1020457"> </a>Start local loopback test.</dd>

<dt><a name="1020459"> </a><code><code>srmCtlStopLocalLoopback</code></code></dt>
<dd><a name="1020461"> </a>Stop local loopback test.</dd>

<dt><a name="1020463"> </a><code><code>srmCtlIrDAEnable</code></code></dt>
<dd><a name="1020465"> </a>Enable IrDA connection on this serial port.</dd>

</dl>

<div><hr>
  <a name="1020466"> </a> <b>NOTE: </b> You cannot enable an IrDA connection on a VZ processor. 
<hr>
</div>

<dl>
<dt><a name="1020468"> </a><code><code>srmCtlIrDADisable</code></code></dt>
<dd><a name="1020470"> </a>Disable IrDA connection on this serial port.</dd>

<dt><a name="1020472"> </a><code><code>srmCtlRxEnable</code></code></dt>
<dd><a name="1020474"> </a>Enable receiver (for IrDA).</dd>

<dt><a name="1020476"> </a><code><code>srmCtlRxDisable</code></code></dt>
<dd><a name="1020478"> </a>Disable receiver (for IrDA).</dd>

<dt><a name="1020480"> </a><code><code>srmCtlEmuSetBlockingHook</code></code></dt>
<dd><a name="1020482"> </a>Set a blocking hook routine for emulation mode only. Not supported on the actual device.</dd>

<dt><a name="1020484"> </a><code><code>srmCtlUserDef</code></code></dt>
<dd><a name="1020486"> </a>This is a user-defined function that third-party hardware developers can use to set or retrieve hardware-specific information from the serial driver. This op code invokes the driver's corresponding control function with its user-defined op code and the parameters are passed directly through to the serial driver. A serial driver that does not handle this function returns a <code>serErrBadParam</code> error.</dd>

<dd><a name="1020490"> </a>The <code>srmCtlUserDef</code> op code is superseded by defining a custom op code if <a href="CompatibilityApdx.html#994556">New Serial Manager Feature Set Version 2</a> is present. </dd>

<dt><a name="1020495"> </a><code><code>srmCtlGetOptimalTransmitSize</code></code></dt>
<dd><a name="1020497"> </a>Ask the port for the most efficient buffer size for transmitting data packets. This op code returns an error (buffering not necessary), 0 (buffering requested, but application can choose buffer size), or a number greater than 0 (recommended buffer size).</dd>

<dt><a name="1020499"> </a><code><code>srmCtlSetDTRAsserted</code></code></dt>
<dd><a name="1020501"> </a>Enabled or disable the DTR signal. This is not supported by all hardware. </dd>

<dt><a name="1020503"> </a><code><code>srmCtlGetDTRAsserted</code></code></dt>
<dd><a name="1020505"> </a>Ask the port whether the DTR signal is enabled or disabled. </dd>

<dt><a name="1020507"> </a><code><code>srmCtlSetYieldPortCallback</code></code></dt>
<dd><a name="1020509"> </a>Set the function to be called if the Serial Manager attempts to open another port when this one is open. This op code is for system use only. </dd>

<dt><a name="1020511"> </a><code><code>srmCtlSetYieldPortRefCon</code></code></dt>
<dd><a name="1020513"> </a>Data to pass to the yield port callback function. System use only. </dd>

<dt><a name="1020515"> </a><code><code>srmCtlSystemReserved</code></code></dt>
<dd><a name="1020517"> </a>Reserves op codes between 0x7000 and 0x8000 for system use. </dd>

<dt><a name="1020519"> </a><code><code>srmCtlCustom</code></code></dt>
<dd><a name="1020521"> </a>Reserves op codes greater than 0x8000 for driver-specific use. </dd>

</dl>
<h4>
  <a name="1020523"> </a>Compatibility 
</h4>

<p><a name="1020526"> </a>Custom control op codes are only supported if both <a href="CompatibilityApdx.html#994556">New Serial Manager Feature Set Version 2</a> and <a href="CompatibilityApdx.html#995256">4.0 New Feature Set</a> are present. </p>

<h3 class="hbH3">
  <a name="1020533"> </a>SrmOpenConfigType Struct <a href="#1020300"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="1020535"> </a>Purpose 
</h4>

<p><a name="1020537"> </a>The <code>SrmOpenConfigType</code> structure specifies parameters for opening a serial port. This structure is passed as a parameter to <a href="SerialManager.html#1021346"><code>SrmExtOpen()</code></a>. </p>
<h4>
  <a name="1020541"> </a>Prototype 
</h4>
<pre class="proto"><a name="1020542"></a>typedef struct SrmOpenConfigType {
  UInt32 baud;
  UInt32 function;
  MemPtr drvrDataP;
  UInt16 drvrDataSize;
  UInt32 sysReserved1;
  UInt32 sysReserved2; 
} SrmOpenConfigType;
</pre>
<h4>
  <a name="1024291"> </a>Fields 
</h4>

<dl>
<dt><a name="1020553"> </a><code><code>baud</code> </code></dt>
<dd><a name="1020555"> </a>Baud rate at which to open the connection. Serial drivers that do not require baud rates ignore this field. </dd>

<dt><a name="1020557"> </a><code><code>function</code> </code></dt>
<dd><a name="1020559"> </a>The reason why the port was opened. Specify the creator ID of the application that is opening the port or one of the following values: </dd>

<dl>
<dt><a name="1020561"> </a><code><code>serFncUndefined</code> </code></dt>
<dd><a name="1020562"> </a>Undefined function. This is the default value for this field.</dd>

<dt><a name="1020564"> </a><code><code>serFncPPPSession</code></code></dt>
<dd><a name="1020565"> </a>The connection is to be used for the PPP interface. </dd>

<dt><a name="1020567"> </a><code><code>serFncSLIPSession</code></code></dt>
<dd><a name="1020568"> </a>The connection is to be used for the SLIP session. </dd>

<dt><a name="1020570"> </a><code><code>serFncDebugger</code></code></dt>
<dd><a name="1020571"> </a>The connection is to be used for a debugging session. </dd>

<dt><a name="1020573"> </a><code><code>serFncHotSync</code></code></dt>
<dd><a name="1020574"> </a>The connection is to be used for a HotSync operation. </dd>

<dt><a name="1020576"> </a><code><code>serFncConsole</code> </code></dt>
<dd><a name="1020577"> </a>The connection is to the debugging console. </dd>

<dt><a name="1020579"> </a><code><code>serFncTelephony</code> </code></dt>
<dd><a name="1020580"> </a>The connection is to the telephony library. </dd>

</dl>
<dd><a name="1020584"> </a>The <code>function</code> field is used by protocols such as USB and Bluetooth that perform different setup tasks based on which type of application is using them. RS-232 drivers ignore this parameter. </dd>

<dt><a name="1020586"> </a><code><code>drvrDataP</code> </code></dt>
<dd><a name="1020588"> </a>Pointer to a driver-specific data block. </dd>

<dt><a name="1020590"> </a><code><code>drvrDataSize</code> </code></dt>
<dd><a name="1020592"> </a>The size of the data block pointed to by <code>drvrDataP</code>. </dd>

<dt><a name="1020594"> </a><code><code>sysReserved1</code> </code></dt>
<dd><a name="1020596"> </a>Reserved for future use. </dd>

<dt><a name="1020598"> </a><code><code>sysReserved2</code> </code></dt>
<dd><a name="1020600"> </a>Reserved for future use. </dd>

</dl>


<h4>
  <a name="1020602"> </a>Compatibility 
</h4>

<p><a name="1020605"> </a>This structure is only defined if both <a href="CompatibilityApdx.html#994556">New Serial Manager Feature Set Version 2</a> and <a href="CompatibilityApdx.html#995256">4.0 New Feature Set</a> are present. </p>

<h2 class="haH2">
  <a name="1020611"> </a>Serial Manager Constants <a href="#1020300"><span class="nav">^TOP^</span></a>
</h2>


<h3 class="hbH3">
  <a name="1020613"> </a>Port Constants <a href="#1020300"><span class="nav">^TOP^</span></a>
</h3>


<p><a name="1020618"> </a>When you specify the port to open in the <a href="SerialManager.html#1021606"><code>SrmOpen()</code></a>, <a href="SerialManager.html#1021657"><code>SrmOpenBackground()</code></a>, <a href="SerialManager.html#1021346"><code>SrmExtOpen()</code></a>, or <a href="SerialManager.html#1021416"><code>SrmExtOpenBackground()</code></a> call, you can use either a logical port constant, physical port constant, or a virtual port constant, but it is highly recommended that you use a logical port constant wherever possible. </p>

<h4 class="hcH4">
  <a name="1020632"> </a>Logical Serial Port Constants
</h4>

<p><a name="1020633"> </a>These constants specify the logical port names. </p>


<div class="tablediv"><table cellspacing="0" class="tTable">

  <tr valign="top">
    <th><p class="tt"><a name="1020636"> </a><b><span style="color: #000000;  font-style: normal; font-weight: bold; text-decoration: none; text-transform: none; vertical-align: baseline">Constant</span></b></p>
    </th>
    <th><p class="tt"><a name="1020638"> </a><b>Value</b></p>
    </th>
    <th><p class="tt"><a name="1020640"> </a><b>Description</b></p>
    </th>
  </tr>
  <tr valign="top">
    <td><p class="tt"><a name="1020643"> </a><code>serPortLocalHotSync</code> </p>
    </td>
    <td><p class="tt"><a name="1020645"> </a>0x8000 </p>
    </td>
    <td><p class="tt"><a name="1020647"> </a>The physical HotSync port. The Serial Manager automatically detects whether this port is USB or RS-232. </p>
    </td>
  </tr>
  <tr valign="top">
    <td><p class="tt"><a name="1020650"> </a><code>serPortCradlePort</code> </p>
    </td>
    <td><p class="tt"><a name="1020652"> </a>0x8000 </p>
    </td>
    <td><p class="tt"><a name="1020654"> </a>Cradle port. The Serial Manager automatically detects whether this port is USB or RS-232. Most applications should specify this as the port. </p>
    </td>
  </tr>
  <tr valign="top">
    <td><p class="tt"><a name="1020657"> </a><code>serPortIrPort</code> </p>
    </td>
    <td><p class="tt"><a name="1020659"> </a>0x8001 </p>
    </td>
    <td><p class="tt"><a name="1020661"> </a>The IR port. This is a raw IrDA port with no protocol support. </p>
    </td>
  </tr>
  <tr valign="top">
    <td><p class="tt"><a name="1020664"> </a><code>serPortConsolePort</code> </p>
    </td>
    <td><p class="tt"><a name="1020666"> </a>0x8002 </p>
    </td>
    <td><p class="tt"><a name="1020668"> </a>The debug console port, either USB or RS-232. USB is preferred where both are available. </p>
    </td>
  </tr>
  <tr valign="top">
    <td><p class="tt"><a name="1020671"> </a><code>serPortCradleRS232Port</code> </p>
    </td>
    <td><p class="tt"><a name="1020673"> </a>0x8003 </p>
    </td>
    <td><p class="tt"><a name="1020675"> </a>Port for the RS-232 cradle. Specify this port if you want to ensure that your application uses RS-232 communications only. </p>
    </td>
  </tr>
  <tr valign="top">
    <td><p class="tt"><a name="1020678"> </a><code>serPortCradleUSBPort</code> </p>
    </td>
    <td><p class="tt"><a name="1020680"> </a>0x8004 </p>
    </td>
    <td><p class="tt"><a name="1020682"> </a>Port for the USB cradle. Specify this port if you want to ensure that your application uses USB communications only. </p>
    </td>
  </tr>
</table>

</div>

<h4>
  <a name="1020684"> </a>Compatibility 
</h4>

<p><a name="1020687"> </a>USB ports are only supported if <a href="CompatibilityApdx.html#994556">New Serial Manager Feature Set Version 2</a> is present. </p>

<h4 class="hcH4">
  <a name="1020690"> </a>Physical Serial Port Constants
</h4>

<p><a name="1020691"> </a>The physical port constants specify 4-character constants that reference the physical hardware of the device. Doing so is <i>not</i> recommended because the hardware they reference may not exist on a particular device.</p>


<div class="tablediv"><table cellspacing="0" class="tTable">

  <tr valign="top">
    <th><p class="tt"><a name="1020694"> </a><b>Physical port</b></p>
    </th>
    <th><p class="tt"><a name="1020696"> </a><b>Value </b></p>
    </th>
    <th><p class="tt"><a name="1020698"> </a><b>Description </b></p>
    </th>
  </tr>
  <tr valign="top">
    <td><p class="tt"><a name="1020701"> </a><code>sysFileCUart328</code> </p>
    </td>
    <td><p class="tt"><a name="1020703"> </a>'u328'</p>
    </td>
    <td><p class="tt"><a name="1020705"> </a>Cradle port using the 68328 UART. This port can be switched between RS232 and IrDA mode using the <a href="SerialManager.html#1021112"><code>SrmControl()</code></a> call. </p>
    </td>
  </tr>
  <tr valign="top">
    <td><p class="tt"><a name="1020712"> </a><code>sysFileCUart328EZ</code></p>
    </td>
    <td><p class="tt"><a name="1020714"> </a>'u8EZ'</p>
    </td>
    <td><p class="tt"><a name="1020716"> </a>Cradle port using the 68328EZ UART. This port can also be switched between RS232 and IrDA mode. </p>
    </td>
  </tr>
  <tr valign="top">
    <td><p class="tt"><a name="1020719"> </a><code>sysFileCUart650</code> </p>
    </td>
    <td><p class="tt"><a name="1020721"> </a>'u650'</p>
    </td>
    <td>
<p><a name="1020723"> </a>Specifies the IR port on the upgrade card for Palm Personal or Palm Professional devices. This gives you a raw IR port like calling <code>SrmControl</code> does, but it only exists on devices that have the upgrade card. </p>
    </td>
  </tr>
</table>

</div>


<h4 class="hcH4">
  <a name="1020726"> </a>Virtual Serial Port Constants
</h4>

<p><a name="1020727"> </a>The virtual port constants specify 4-character constants that identify virtual ports, simulating a hardware interface. Virtual ports are not tied to specific hardware.</p>


<div class="tablediv"><table cellspacing="0" class="tTable">

  <tr valign="top">
    <th><p class="tt"><a name="1020730"> </a><b>Physical port</b></p>
    </th>
    <th><p class="tt"><a name="1020732"> </a><b>Value </b></p>
    </th>
    <th><p class="tt"><a name="1020734"> </a><b>Description </b></p>
    </th>
  </tr>
  <tr valign="top">
    <td><p class="tt"><a name="1020737"> </a><code>sysFileCVirtIrComm</code> </p>
    </td>
    <td><p class="tt"><a name="1020739"> </a>'ircm'</p>
    </td>
    <td><p class="tt"><a name="1020741"> </a>A virtual serial cable over an IrDA link using the IRComm protocol. It can only be used to talk to another IRComm device. </p>
    </td>
  </tr>
  <tr valign="top">
    <td><p class="tt"><a name="1020744"> </a><code>sysFileCVirtRfComm</code> </p>
    </td>
    <td><p class="tt"><a name="1020746"> </a>'rfcm'</p>
    </td>
    <td><p class="tt"><a name="1020748"> </a>RFCOMM (Bluetooth) virtual port plug-in.</p>
    </td>
  </tr>
  <tr valign="top">
    <td><p class="tt"><a name="1020751"> </a><code>sysFileCBtConnectPanelHelper</code> </p>
    </td>
    <td><p class="tt"><a name="1020753"> </a>'btcp'</p>
    </td>
    <td><p class="tt"><a name="1020755"> </a>Bluetooth Connection Panel helper application.</p>
    </td>
  </tr>
</table>

</div>

<h4>
  <a name="1020757"> </a>Compatibility 
</h4>

<p><a name="1020758"> </a>All virtual port constants other than <code>sysFileCVirtIrComm</code> are only defined if both <a href="CompatibilityApdx.html#994556">New Serial Manager Feature Set Version 2</a> and <a href="CompatibilityApdx.html#995256">4.0 New Feature Set</a> are present, and if the <a href="CompatibilityApdx.html#997336">5.0 New Feature Set</a> is <i>not</i> present.</p>

<h3 class="hbH3">
  <a name="1020769"> </a>Serial Capabilities Constants <a href="#1020300"><span class="nav">^TOP^</span></a>
</h3>


<p><a name="1020771"> </a>The serial capabilities constant flags describe serial hardware capabilities. These flags are set in the <code>serDevFtrInfo</code> field of the <a href="SerialManager.html#1020333"><code>DeviceInfoType</code></a> structure.</p>


<div class="tablediv"><table cellspacing="0" class="tTable">

  <tr valign="top">
    <th><p class="tt"><a name="1020777"> </a><b>Constant</b></p>
    </th>
    <th><p class="tt"><a name="1020779"> </a><b>Value</b></p>
    </th>
    <th><p class="tt"><a name="1020781"> </a><b>Description</b></p>
    </th>
  </tr>
  <tr valign="top">
    <td><p class="tt"><a name="1020783"> </a><code>serDevCradlePort</code></p>
    </td>
    <td><p class="tt"><a name="1020785"> </a>0x00000001</p>
    </td>
    <td><p class="tt"><a name="1020787"> </a>Serial hardware controls RS-232 serial from cradle connector of Palm device.</p>
    </td>
  </tr>
  <tr valign="top">
    <td><p class="tt"><a name="1020789"> </a><code>serDevRS232Serial</code></p>
    </td>
    <td><p class="tt"><a name="1020791"> </a>0x00000002</p>
    </td>
    <td><p class="tt"><a name="1020793"> </a>Serial hardware has RS-232 line drivers.</p>
    </td>
  </tr>
  <tr valign="top">
    <td><p class="tt"><a name="1020795"> </a><code>serDevIRDACapable</code></p>
    </td>
    <td><p class="tt"><a name="1020797"> </a>0x00000004</p>
    </td>
    <td><p class="tt"><a name="1020799"> </a>Serial hardware has IR line drivers and generates IrDA mode serial signals.</p>
    </td>
  </tr>
  <tr valign="top">
    <td><p class="tt"><a name="1020801"> </a><code>serDevModemPort</code></p>
    </td>
    <td><p class="tt"><a name="1020803"> </a>0x00000008</p>
    </td>
    <td><p class="tt"><a name="1020805"> </a>Serial hardware drives modem connection.</p>
    </td>
  </tr>
  <tr valign="top">
    <td><p class="tt"><a name="1020807"> </a><code>serDevCncMgrVisible</code></p>
    </td>
    <td><p class="tt"><a name="1020809"> </a>0x00000010</p>
    </td>
    <td><p class="tt"><a name="1020811"> </a>Serial device port name string is to be displayed in the Connection panel.</p>
    </td>
  </tr>
  <tr valign="top">
    <td><p class="tt"><a name="1020813"> </a><code>serDevConsolePort </code></p>
    </td>
    <td><p class="tt"><a name="1020815"> </a>0x00000020</p>
    </td>
    <td><p class="tt"><a name="1020817"> </a>Serial device is the default console port.</p>
    </td>
  </tr>
  <tr valign="top">
    <td><p class="tt"><a name="1020819"> </a><code>serDevUSBCapable</code></p>
    </td>
    <td><p class="tt"><a name="1020821"> </a>0x00000040</p>
    </td>
    <td><p class="tt"><a name="1020823"> </a>Serial hardware controls USB serial from cradle connector of Palm device.</p>
    </td>
  </tr>
</table>

</div>

<h4>
  <a name="1020825"> </a>Compatibility 
</h4>

<p><a name="1020828"> </a>USB ports are only supported if <a href="CompatibilityApdx.html#994556">New Serial Manager Feature Set Version 2</a> is present. </p>

<h3 class="hbH3">
  <a name="1020831"> </a>Serial Settings Constants <a href="#1020300"><span class="nav">^TOP^</span></a>
</h3>


<p><a name="1020833"> </a>The serial settings constants identify bit flags that correspond to various serial hardware settings. Use <a href="SerialManager.html#1021112"><code>SrmControl()</code></a> with the op code <code>srmCtlSetFlags</code> to control which settings are used. </p>


<div class="tablediv"><table cellspacing="0" class="tTable">

  <tr valign="top">
    <th><p class="tt"><a name="1020840"> </a><b>Constant</b></p>
    </th>
    <th><p class="tt"><a name="1020842"> </a><b>Value</b></p>
    </th>
    <th><p class="tt"><a name="1020844"> </a><b>Description</b></p>
    </th>
  </tr>
  <tr valign="top">
    <td><p class="tt"><a name="1020846"> </a><code>srmSettingsFlagStopBitsM</code> </p>
    </td>
    <td><p class="tt"><a name="1020848"> </a>0x00000001</p>
    </td>
    <td><p class="tt"><a name="1020850"> </a>Mask for stop bits field</p>
    </td>
  </tr>
  <tr valign="top">
    <td><p class="tt"><a name="1020852"> </a><code>srmSettingsFlagStopBits1</code> </p>
    </td>
    <td><p class="tt"><a name="1020854"> </a>0x00000000</p>
    </td>
    <td><p class="tt"><a name="1020856"> </a>1 stop bit (default) </p>
    </td>
  </tr>
  <tr valign="top">
    <td><p class="tt"><a name="1020858"> </a><code>srmSettingsFlagStopBits2</code> </p>
    </td>
    <td><p class="tt"><a name="1020860"> </a>0x00000001</p>
    </td>
    <td><p class="tt"><a name="1020862"> </a>2 stop bits</p>
    </td>
  </tr>
  <tr valign="top">
    <td><p class="tt"><a name="1020864"> </a><code>srmSettingsFlagParityOnM</code> </p>
    </td>
    <td><p class="tt"><a name="1020866"> </a>0x00000002</p>
    </td>
    <td><p class="tt"><a name="1020868"> </a>Mask for parity on</p>
    </td>
  </tr>
  <tr valign="top">
    <td><p class="tt"><a name="1020870"> </a><code>srmSettingsFlagParityEvenM</code> </p>
    </td>
    <td><p class="tt"><a name="1020872"> </a>0x00000004</p>
    </td>
    <td><p class="tt"><a name="1020874"> </a>Mask for parity even</p>
    </td>
  </tr>
  <tr valign="top">
    <td><p class="tt"><a name="1020876"> </a><code>srmSettingsFlagXonXoffM</code> </p>
    </td>
    <td><p class="tt"><a name="1020878"> </a>0x00000008</p>
    </td>
    <td><p class="tt"><a name="1020880"> </a>Mask for Xon/Xoff flow control (not implemented)</p>
    </td>
  </tr>
  <tr valign="top">
    <td><p class="tt"><a name="1020882"> </a><code>srmSettingsFlagRTSAutoM</code> </p>
    </td>
    <td><p class="tt"><a name="1020884"> </a>0x00000010</p>
    </td>
    <td><p class="tt"><a name="1020886"> </a>Mask for RTS receive flow control. This is the default. </p>
    </td>
  </tr>
  <tr valign="top">
    <td><p class="tt"><a name="1020888"> </a><code>srmSettingsFlagCTSAutoM</code> </p>
    </td>
    <td><p class="tt"><a name="1020890"> </a>0x00000020</p>
    </td>
    <td><p class="tt"><a name="1020892"> </a>Mask for CTS transmit flow control</p>
    </td>
  </tr>
  <tr valign="top">
    <td><p class="tt"><a name="1020894"> </a><code>srmSettingsFlagBitsPerCharM</code> </p>
    </td>
    <td><p class="tt"><a name="1020896"> </a>0x000000C0</p>
    </td>
    <td><p class="tt"><a name="1020898"> </a>Mask for bits per character</p>
    </td>
  </tr>
  <tr valign="top">
    <td><p class="tt"><a name="1020900"> </a><code>srmSettingsFlagBitsPerChar5</code> </p>
    </td>
    <td><p class="tt"><a name="1020902"> </a>0x00000000</p>
    </td>
    <td><p class="tt"><a name="1020904"> </a>5 bits per character</p>
    </td>
  </tr>
  <tr valign="top">
    <td><p class="tt"><a name="1020906"> </a><code>srmSettingsFlagBitsPerChar6</code> </p>
    </td>
    <td><p class="tt"><a name="1020908"> </a>0x00000040</p>
    </td>
    <td><p class="tt"><a name="1020910"> </a>6 bits per character</p>
    </td>
  </tr>
  <tr valign="top">
    <td><p class="tt"><a name="1020912"> </a><code>srmSettingsFlagBitsPerChar7</code> </p>
    </td>
    <td><p class="tt"><a name="1020914"> </a>0x00000080</p>
    </td>
    <td><p class="tt"><a name="1020916"> </a>7 bits per character</p>
    </td>
  </tr>
  <tr valign="top">
    <td><p class="tt"><a name="1020918"> </a><code>srmSettingsFlagBitsPerChar8</code> </p>
    </td>
    <td><p class="tt"><a name="1020920"> </a>0x000000C0</p>
    </td>
    <td><p class="tt"><a name="1020922"> </a>8 bits per character (default) </p>
    </td>
  </tr>
  <tr valign="top">
    <td><p class="tt"><a name="1020924"> </a><code>srmSettingsFlagFlowControlIn</code></p>
    </td>
    <td><p class="tt"><a name="1020926"> </a>0x00000100</p>
    </td>
    <td><p class="tt"><a name="1020928"> </a>Protect the receive buffer from software overruns. When this flag and <code>srmSettingsFlagRTSAutoM</code> are set, which is the default case, it causes the Serial Manager to assert RTS to prevent the transmitting device from continuing to send data when the receive buffer is full. Once the application receives data from the buffer, RTS is de-asserted to allow data reception to resume.</p>
    </td>
  </tr>
  <tr valign="top">
    <td><p class="tt"><a name="1020930"> </a></p>
    </td>
    <td><p class="tt"><a name="1020932"> </a></p>
    </td>
    <td><p class="tt"><a name="1020934"> </a>Note that this feature effectively prevents software overrun line errors but may also cause CTS timeouts on the transmitting device if the RTS line is asserted longer than the defined CTS timeout value.</p>
    </td>
  </tr>
  <tr valign="top">
    <td><p class="tt"><a name="1020936"> </a><code>srmSettingsFlagRTSInactive</code> </p>
    </td>
    <td><p class="tt"><a name="1020938"> </a>0x00000200</p>
    </td>
    <td><p class="tt"><a name="1020940"> </a>If this flag is set and <code>srmSettingsFlagRTSAutoM</code> is not set, RTS is held in the inactive (flow off) state forever.</p>
    </td>
  </tr>
</table>

</div>


<h3 class="hbH3">
  <a name="1020943"> </a>Status Constants <a href="#1020300"><span class="nav">^TOP^</span></a>
</h3>


<p><a name="1020945"> </a>The status constants identify bit flags that correspond to the status of serial signals. They can be returned by the <a href="SerialManager.html#1021560"><code>SrmGetStatus()</code></a> function.</p>


<div class="tablediv"><table cellspacing="0" class="tTable">

  <tr valign="top">
    <th><p class="tt"><a name="1020952"> </a><b>Constant</b></p>
    </th>
    <th><p class="tt"><a name="1020954"> </a><b>Value</b></p>
    </th>
    <th><p class="tt"><a name="1020956"> </a><b>Description</b></p>
    </th>
  </tr>
  <tr valign="top">
    <td><p class="tt"><a name="1020958"> </a><code>srmStatusCtsOn </code></p>
    </td>
    <td><p class="tt"><a name="1020960"> </a>0x00000001 </p>
    </td>
    <td><p class="tt"><a name="1020962"> </a>CTS line is active.</p>
    </td>
  </tr>
  <tr valign="top">
    <td><p class="tt"><a name="1020964"> </a><code>srmStatusRtsOn </code></p>
    </td>
    <td><p class="tt"><a name="1020966"> </a>0x00000002 </p>
    </td>
    <td><p class="tt"><a name="1020968"> </a>RTS line is active.</p>
    </td>
  </tr>
  <tr valign="top">
    <td><p class="tt"><a name="1020970"> </a><code>srmStatusDsrOn </code></p>
    </td>
    <td><p class="tt"><a name="1020972"> </a>0x00000004 </p>
    </td>
    <td><p class="tt"><a name="1020974"> </a>DSR line is active.</p>
    </td>
  </tr>
  <tr valign="top">
    <td><p class="tt"><a name="1020976"> </a><code>srmStatusBreakSigOn </code></p>
    </td>
    <td><p class="tt"><a name="1020978"> </a>0x00000008 </p>
    </td>
    <td><p class="tt"><a name="1020980"> </a>Break signal is active.</p>
    </td>
  </tr>
</table>

</div>


<h3 class="hbH3">
  <a name="1020983"> </a>Line Error Constants <a href="#1020300"><span class="nav">^TOP^</span></a>
</h3>


<p><a name="1020984"> </a>The line error constants identify bit flags that correspond to the line errors that may occur on the port. They can be returned by the <a href="SerialManager.html#1021560"><code>SrmGetStatus()</code></a> function. </p>


<div class="tablediv"><table cellspacing="0" class="tTable">

  <tr valign="top">
    <th><p class="tt"><a name="1020991"> </a><b>Constant</b></p>
    </th>
    <th><p class="tt"><a name="1020993"> </a><b>Value</b></p>
    </th>
    <th><p class="tt"><a name="1020995"> </a><b>Description</b></p>
    </th>
  </tr>
  <tr valign="top">
    <td><p class="tt"><a name="1020997"> </a><code>serLineErrorParity</code></p>
    </td>
    <td><p class="tt"><a name="1020999"> </a>0x0001</p>
    </td>
    <td><p class="tt"><a name="1021001"> </a>Parity error</p>
    </td>
  </tr>
  <tr valign="top">
    <td><p class="tt"><a name="1021003"> </a><code>serLineErrorHWOverrun</code></p>
    </td>
    <td><p class="tt"><a name="1021005"> </a>0x0002</p>
    </td>
    <td><p class="tt"><a name="1021007"> </a>Hardware overrun</p>
    </td>
  </tr>
  <tr valign="top">
    <td><p class="tt"><a name="1021009"> </a><code>serLineErrorFraming</code></p>
    </td>
    <td><p class="tt"><a name="1021011"> </a>0x0004</p>
    </td>
    <td><p class="tt"><a name="1021013"> </a>Framing error</p>
    </td>
  </tr>
  <tr valign="top">
    <td><p class="tt"><a name="1021015"> </a><code>serLineErrorBreak</code></p>
    </td>
    <td><p class="tt"><a name="1021017"> </a>0x0008</p>
    </td>
    <td><p class="tt"><a name="1021019"> </a>Break signal asserted</p>
    </td>
  </tr>
  <tr valign="top">
    <td><p class="tt"><a name="1021021"> </a><code>serLineErrorHShake</code></p>
    </td>
    <td><p class="tt"><a name="1021023"> </a>0x0010</p>
    </td>
    <td><p class="tt"><a name="1021025"> </a>Line handshake error</p>
    </td>
  </tr>
  <tr valign="top">
    <td><p class="tt"><a name="1021027"> </a><code>serLineErrorSWOverrun</code></p>
    </td>
    <td><p class="tt"><a name="1021029"> </a>0x0020</p>
    </td>
    <td><p class="tt"><a name="1021031"> </a>Software overrun</p>
    </td>
  </tr>
  <tr valign="top">
    <td><p class="tt"><a name="1021033"> </a><code>serLineErrorCarrierLost</code></p>
    </td>
    <td><p class="tt"><a name="1021035"> </a>0x0040</p>
    </td>
    <td><p class="tt"><a name="1021037"> </a>Carrier detect signal dropped</p>
    </td>
  </tr>
</table>

</div>


<h2 class="haH2">
  <a name="1021040"> </a>Serial Manager Functions <a href="#1020300"><span class="nav">^TOP^</span></a>
</h2>


<h3 class="hbH3">
  <a name="1021043"> </a>SrmClearErr Function <a href="#1020300"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="1021045"> </a>Purpose 
</h4>

<p><a name="1021046"> </a>Clears the port of any line errors.</p>
<h4>
  <a name="1021047"> </a>Declared In 
</h4>
<code>SerialMgr.h<a name="1021048"> </a></code><h4>
  <a name="1021049"> </a>Prototype 
</h4>
<pre class="proto"><a name="1021050"></a>Err SrmClearErr (
   UInt16 portId
)
</pre>
<h4>
  <a name="1021051"> </a>Parameters 
</h4>

<dl>
<dt><a name="1021052"> </a><code>&rarr;  <i><code>portID</code></i></code></dt>
<dd><a name="1021059"> </a>Port ID returned from <a href="SerialManager.html#1021606"><code>SrmOpen()</code></a> or <a href="SerialManager.html#1021346"><code>SrmExtOpen()</code></a>.</dd>

</dl>
<h4>
  <a name="1021060"> </a>Returns 
</h4>

<p><a name="1021061"> </a>This function returns the following error codes:</p>

<dl>
<dt><a name="1021062"> </a><code><code>errNone</code></code></dt>
<dd><a name="1021063"> </a>No error. </dd>

<dt><a name="1021064"> </a><code><code>serErrNotSupported</code></code></dt>
<dd><a name="1021065"> </a>The port is not the foreground port. </dd>

</dl>
<h4>
  <a name="1021066"> </a>Compatibility 
</h4>

<p><a name="1021070"> </a>Implemented only if <a href="CompatibilityApdx.html#994402">New Serial Manager Feature Set Version 1</a> is present.</p>

<h3 class="hbH3">
  <a name="1021073"> </a>SrmClose Function <a href="#1020300"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="1021075"> </a>Purpose 
</h4>

<p><a name="1021076"> </a>Closes a serial port and makes it available to other applications, regardless of whether the port is a foreground or background port. </p>
<h4>
  <a name="1021077"> </a>Declared In 
</h4>
<code>SerialMgr.h<a name="1021078"> </a></code><h4>
  <a name="1021079"> </a>Prototype 
</h4>
<pre class="proto"><a name="1021080"></a>Err SrmClose (
   UInt16 portId
)
</pre>
<h4>
  <a name="1021081"> </a>Parameters 
</h4>

<dl>
<dt><a name="1021082"> </a><code>&rarr;  <i><code>portId</code></i></code></dt>
<dd><a name="1021083"> </a>Port ID for port to be closed.</dd>

</dl>
<h4>
  <a name="1021084"> </a>Returns 
</h4>

<p><a name="1021085"> </a>This function returns the following error codes:</p>

<dl>
<dt><a name="1021086"> </a><code><code>errNone</code> </code></dt>
<dd><a name="1021087"> </a>No error.</dd>

<dt><a name="1021088"> </a><code><code>serErrBadPort</code></code></dt>
<dd><a name="1021089"> </a>This port doesn't exist.</dd>

<dt><a name="1021090"> </a><code><code>serErrNotOpen</code></code></dt>
<dd><a name="1021091"> </a>The serial port is not open. </dd>

<dt><a name="1021092"> </a><code><code>serErrNoDevicesAvail</code></code></dt>
<dd><a name="1021093"> </a>No serial devices could be found. </dd>

</dl>
<h4>
  <a name="1021094"> </a>Comments 
</h4>

<p><a name="1021095"> </a>If a foreground port is being closed and a background port exists, the background will have access to the port as long as another foreground port is not opened.</p>

<p><a name="1021096"> </a>If a foreground port is being closed and a yielded port exists, the yielded port will have access to the port as long as it does not yield to the opening of another foreground port. If there are both a yielded port and a background port for the foreground port being closed, the yielded port takes precedence over the background port. </p>
<h4>
  <a name="1021097"> </a>Compatibility 
</h4>

<p><a name="1021101"> </a>Implemented only if <a href="CompatibilityApdx.html#994402">New Serial Manager Feature Set Version 1</a> is present.</p>
<h4>
  <a name="1021102"> </a>See Also 
</h4>

<p><a name="1021109"> </a><a href="SerialManager.html#1021606"><code>SrmOpen()</code></a>, <a href="SerialManager.html#1021657"><code>SrmOpenBackground()</code></a></p>

<h3 class="hbH3">
  <a name="1021112"> </a>SrmControl Function <a href="#1020300"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="1021114"> </a>Purpose 
</h4>

<p><a name="1021115"> </a>Performs a serial control function.</p>
<h4>
  <a name="1021116"> </a>Declared In 
</h4>
<code>SerialMgr.h<a name="1021117"> </a></code><h4>
  <a name="1021118"> </a>Prototype 
</h4>
<pre class="proto"><a name="1021119"></a>Err SrmControl (
   UInt16 portId,
   UInt16 op,
   void *valueP,
   UInt16 *valueLenP
)
</pre>
<h4>
  <a name="1021120"> </a>Parameters 
</h4>

<dl>
<dt><a name="1021121"> </a><code>&rarr;  <i><code>portID</code></i></code></dt>
<dd><a name="1021128"> </a>Port ID returned from <a href="SerialManager.html#1021606"><code>SrmOpen()</code></a> or <a href="SerialManager.html#1021346"><code>SrmExtOpen()</code></a>.</dd>

<dt><a name="1021129"> </a><code>&rarr;  <i><code>op</code></i></code></dt>
<dd><a name="1021130"> </a>Control operation to perform. Specify one of the <a href="SerialManager.html#1020380"><code>SrmCtlEnum</code></a> enumerated types.</dd>

<dt><a name="1021135"> </a><code>&harr;  <i><code>valueP</code></i></code></dt>
<dd><a name="1021136"> </a>Pointer to a value to use for the operation. See Comments for details.</dd>

<dt><a name="1021137"> </a><code>&harr;  <i><code>valueLenP</code></i></code></dt>
<dd><a name="1021138"> </a>Pointer to the size of <code>*valueP</code>. See Comments for details.</dd>

</dl>
<h4>
  <a name="1021139"> </a>Returns 
</h4>

<p><a name="1021140"> </a>This function returns the following error codes:</p>

<dl>
<dt><a name="1021141"> </a><code><code>errNone</code> </code></dt>
<dd><a name="1021142"> </a>No error.</dd>

<dt><a name="1021143"> </a><code><code>serErrBadParam</code></code></dt>
<dd><a name="1021144"> </a>An invalid op code was specified. </dd>

<dt><a name="1021145"> </a><code><code>serErrBadPort</code></code></dt>
<dd><a name="1021146"> </a>This port doesn't exist.</dd>

<dt><a name="1021147"> </a><code><code>serErrNotOpen</code></code></dt>
<dd><a name="1021148"> </a>The serial port is not open. </dd>

<dt><a name="1021149"> </a><code><code>serErrNoDevicesAvail</code></code></dt>
<dd><a name="1021150"> </a>No serial devices could be found. </dd>

<dt><a name="1021151"> </a><code><code>serErrNotSupported</code></code></dt>
<dd><a name="1021152"> </a>The specified op code is not supported in the current configuration. </dd>

</dl>
<h4>
  <a name="1021153"> </a>Comments 
</h4>

<p><a name="1021157"> </a><a href="SerialManager.html#1021167">Table 70.1</a> shows what to pass for the <code>valueP</code> and <code>valueLenP</code> parameters for each of the operation codes. Control codes not listed do not use these parameters. See <a href="SerialManager.html#1020380"><code>SrmCtlEnum</code></a> for a complete list of control codes. </p>

<p class="caption"><a name="1021167"> </a><b>Table 70.1&nbsp;&nbsp;SrmControl Parameters </b></p>
<div class="tablediv"><table cellspacing="0" class="tTable">

  <tr valign="top">
    <th><p class="tt"><a name="1021171"> </a><b>Operation Code</b></p>
    </th>
    <th><p class="tt"><a name="1021173"> </a><b>Parameters</b></p>
    </th>
  </tr>
  <tr valign="top">
    <td colspan="1" rowspan="3"><p class="tt"><a name="1021175"> </a><code>srmCtlSetBaudRate</code> </p>
    </td>
    <td colspan="1" rowspan="3">
<dl>
<dt><a name="1021177"> </a><code>&rarr;  <i><code>valueP</code> = Pointer to <code>Int32</code> (baud rate)</i></code></dt>
<dt><a name="1021178"> </a><code>&rarr;  <i><code>valueLenP</code> = Pointer to <code>sizeof(Int32)</code></i></code></dt>
</dl>
    </td>
  </tr>
  <tr valign="top">
  </tr>
  <tr valign="top">
  </tr>
  <tr valign="top">
    <td colspan="1" rowspan="3"><p class="tt"><a name="1021188"> </a><code>srmCtlGetBaudRate</code> </p>
    </td>
    <td colspan="1" rowspan="3">
<dl>
<dt><a name="1021190"> </a><code>&larr;  <i><code>valueP</code> = Pointer to <code>Int32</code> (baud rate)</i></code></dt>
<dt><a name="1021191"> </a><code>&larr;  <i><code>valueLenP</code> = Pointer to <code>Int16</code></i></code></dt>
</dl>
    </td>
  </tr>
  <tr valign="top">
  </tr>
  <tr valign="top">
  </tr>
  <tr valign="top">
    <td colspan="1" rowspan="3"><p class="tt"><a name="1021201"> </a><code>srmCtlSetFlags</code> </p>
    </td>
    <td colspan="1" rowspan="3">
<dl>
<dt><a name="1021203"> </a><code>&rarr;  <i><code>valueP</code> = Pointer to <code>Uint32</code> (bitfield; see <a href="SerialManager.html#1020831">Serial Settings Constants</a>)</i></code></dt>
<dt><a name="1021207"> </a><code>&rarr;  <i><code>valueLenP</code> = Pointer to <code>sizeof(UInt32)</code></i></code></dt>
</dl>
    </td>
  </tr>
  <tr valign="top">
  </tr>
  <tr valign="top">
  </tr>
  <tr valign="top">
    <td colspan="1" rowspan="3"><p class="tt"><a name="1021217"> </a><code>srmCtlGetFlags</code> </p>
    </td>
    <td colspan="1" rowspan="3">
<dl>
<dt><a name="1021219"> </a><code>&larr;  <i><code>valueP</code> = Pointer to <code>UInt32</code> (bitfield)</i></code></dt>
<dt><a name="1021220"> </a><code>&larr;  <i><code>valueLenP</code> = Pointer to <code>Int16</code></i></code></dt>
</dl>
    </td>
  </tr>
  <tr valign="top">
  </tr>
  <tr valign="top">
  </tr>
  <tr valign="top">
    <td colspan="1" rowspan="3"><p class="tt"><a name="1021230"> </a><code>srmCtlSetCtsTimeout</code> </p>
    </td>
    <td colspan="1" rowspan="3">
<dl>
<dt><a name="1021232"> </a><code>&rarr;  <i><code>valueP</code> = Pointer to <code>Int32</code> (timeout value)</i></code></dt>
<dt><a name="1021233"> </a><code>&rarr;  <i><code>valueLenP</code> = Pointer to <code>sizeof(Int32)</code></i></code></dt>
</dl>
    </td>
  </tr>
  <tr valign="top">
  </tr>
  <tr valign="top">
  </tr>
  <tr valign="top">
    <td colspan="1" rowspan="3"><p class="tt"><a name="1021243"> </a><code>srmCtlGetCtsTimeout</code> </p>
    </td>
    <td colspan="1" rowspan="3">
<dl>
<dt><a name="1021245"> </a><code>&larr;  <i><code>valueP</code> = Pointer to <code>Int32</code> (timeout value)</i></code></dt>
<dt><a name="1021246"> </a><code>&larr;  <i><code>valueLenP</code> = Pointer to <code>Int16</code></i></code></dt>
</dl>
    </td>
  </tr>
  <tr valign="top">
  </tr>
  <tr valign="top">
  </tr>
  <tr valign="top">
    <td><p class="tt"><a name="1021256"> </a><code>srmCtlUserDef</code> </p>
    </td>
    <td>
<dl>
<dt><a name="1021258"> </a><code>&harr;  <i><code>valueP</code> = Pointer passed to the serial or virtual driver</i></code></dt>
<dt><a name="1021259"> </a><code>&harr;  <i><code>valueLenP</code> = Pointer to <code>sizeof(Int32)</code></i></code></dt>
</dl>
<p class="tt"><a name="1021260"> </a>For a serial driver, these pointers are passed to the driver's control function and they contain that functions return values (if any) upon return.</p>
    </td>
  </tr>
  <tr valign="top">
    <td><p class="tt"><a name="1021262"> </a><code>srmCtlGetOptimalTransmitSize</code> </p>
    </td>
    <td>
<dl>
<dt><a name="1021264"> </a><code>&larr;  <i><code>valueP</code> = Pointer to <code>Int32</code> </i></code></dt>
<dt><a name="1021265"> </a><code>&larr;  <i><code>valueLenP</code> = Pointer to <code>sizeof(Int32)</code></i></code></dt>
</dl>
<p class="tt"><a name="1021266"> </a>If an error is returned by <code>SrmControl</code>, no buffering should be done. If <code>valueP</code> points to zero, buffering is requested, but the transmitting application cannot determine the buffer size. If <code>valueP</code> points to a number &gt; 0, then try to send data in blocks of this number of bytes, as this is the most efficient block size for this particular device.</p>
    </td>
  </tr>
  <tr valign="top">
    <td><p class="tt"><a name="1021268"> </a><code>srmCtlSetDTRAsserted</code></p>
    </td>
    <td>
<dl>
<dt><a name="1021270"> </a><code>&rarr;  <i><code>valueP</code> = Pointer to Boolean indicating whether to enable or disable DTR. </i></code></dt>
<dt><a name="1021271"> </a><code>&rarr;  <i><code>valueLenP</code> = Pointer to <code>sizeof(Boolean)</code> </i></code></dt>
</dl>
    </td>
  </tr>
  <tr valign="top">
    <td><p class="tt"><a name="1021273"> </a><code>srmCtlGetDTRAsserted</code></p>
    </td>
    <td>
<dl>
<dt><a name="1021275"> </a><code>&larr;  <i><code>valueP</code> = Pointer to Boolean indicating whether DTR is enabled. </i></code></dt>
<dt><a name="1021276"> </a><code>&larr;  <i><code>valueLenP</code> = Pointer to <code>Int16 </code></i></code></dt>
</dl>
    </td>
  </tr>
</table>

</div>

<h4>
  <a name="1021278"> </a>Compatibility 
</h4>

<p><a name="1021282"> </a>Implemented only if <a href="CompatibilityApdx.html#994402">New Serial Manager Feature Set Version 1</a> is present.</p>
<h4>
  <a name="1021283"> </a>See Also 
</h4>

<p><a name="1021287"> </a><a href="SerialManager.html#1021290"><code>SrmCustomControl()</code></a></p>

<h3 class="hbH3">
  <a name="1021290"> </a>SrmCustomControl Function <a href="#1020300"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="1021292"> </a>Purpose 
</h4>

<p><a name="1021293"> </a>Performs a custom serial control function.</p>
<h4>
  <a name="1021294"> </a>Declared In 
</h4>
<code>SerialMgr.h<a name="1021295"> </a></code><h4>
  <a name="1021296"> </a>Prototype 
</h4>
<pre class="proto"><a name="1021297"></a>Err SrmCustomControl (
   UInt16 portId,
   UInt16 opCode,
   UInt32 creator,
   void *valueP,
   UInt16 *valueLenP
)
</pre>
<h4>
  <a name="1021298"> </a>Parameters 
</h4>

<dl>
<dt><a name="1021299"> </a><code>&rarr;  <i><code>portID</code></i></code></dt>
<dd><a name="1021306"> </a>Port ID returned from <a href="SerialManager.html#1021606"><code>SrmOpen()</code></a> or <a href="SerialManager.html#1021346"><code>SrmExtOpen()</code></a>.</dd>

<dt><a name="1021307"> </a><code>&rarr;  <i><code>opCode</code></i></code></dt>
<dd><a name="1021308"> </a>Control operation to perform. The op code must be greater than <code>srmCtlCustom</code>. </dd>

<dt><a name="1021310"> </a><code>&rarr;  <i><code>creator</code></i></code></dt>
<dd><a name="1021311"> </a>Creator ID of the driver that defines the op code. The combination of creator ID and op code uniquely identifies the operation to be performed. </dd>

<dt><a name="1021312"> </a><code>&harr;  <i><code>valueP</code></i></code></dt>
<dd><a name="1021313"> </a>Pointer to a value to use for the operation. </dd>

<dt><a name="1021314"> </a><code>&harr;  <i><code>valueLenP</code></i></code></dt>
<dd><a name="1021315"> </a>Pointer to the size of <code>*valueP</code>. </dd>

</dl>
<h4>
  <a name="1021316"> </a>Returns 
</h4>

<p><a name="1021317"> </a>This function returns the following error codes:</p>

<dl>
<dt><a name="1021318"> </a><code><code>errNone</code> </code></dt>
<dd><a name="1021319"> </a>No error.</dd>

<dt><a name="1021320"> </a><code><code>serErrNotSupported</code></code></dt>
<dd><a name="1021321"> </a>The port is not the foreground port. </dd>

<dt><a name="1021322"> </a><code><code>serErrBadPort</code></code></dt>
<dd><a name="1021323"> </a>This port doesn't exist.</dd>

<dt><a name="1021324"> </a><code><code>serErrNotOpen</code></code></dt>
<dd><a name="1021325"> </a>The serial port is not open. </dd>

<dt><a name="1021326"> </a><code><code>serErrNoDevicesAvail</code></code></dt>
<dd><a name="1021327"> </a>No serial devices could be found. </dd>

</dl>
<h4>
  <a name="1021328"> </a>Comments 
</h4>

<p><a name="1021329"> </a>This function is a mechanism for a virtual driver to create control codes specific to that driver, allowing for the support of new technologies that have interfaces through the Serial Manager. </p>

<p><a name="1021330"> </a>This function simply forwards the <code>opCode</code> and any <code>valueP</code> parameter to the virtual driver for the port. The virtual driver may return its own error code if the <code>opCode</code> or the input in <code>valueP</code> is invalid. </p>
<h4>
  <a name="1021331"> </a>Compatibility 
</h4>

<p><a name="1021335"> </a>Implemented only if both <a href="CompatibilityApdx.html#994556">New Serial Manager Feature Set Version 2</a> and <a href="CompatibilityApdx.html#995256">4.0 New Feature Set</a> are present. </p>
<h4>
  <a name="1021339"> </a>See Also 
</h4>

<p><a name="1021343"> </a><a href="SerialManager.html#1021112"><code>SrmControl()</code></a></p>

<h3 class="hbH3">
  <a name="1021346"> </a>SrmExtOpen Function <a href="#1020300"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="1021348"> </a>Purpose 
</h4>

<p><a name="1021349"> </a>Opens a foreground port connection with the specified configuration.</p>
<h4>
  <a name="1021350"> </a>Declared In 
</h4>
<code>SerialMgr.h<a name="1021351"> </a></code><h4>
  <a name="1021352"> </a>Prototype 
</h4>
<pre class="proto"><a name="1021353"></a>Err SrmExtOpen (
   UInt32 port,
   SrmOpenConfigType *configP,
   UInt16 configSize,
   UInt16 *newPortIdP
)
</pre>
<h4>
  <a name="1021354"> </a>Parameters 
</h4>

<dl>
<dt><a name="1021355"> </a><code>&rarr;  <i><code>port</code></i></code></dt>
<dd><a name="1021356"> </a>The four-character port name (such as 'ircm' or 'u328') or logical port number to be opened. (See <a href="SerialManager.html#1020613">Port Constants</a>.)</dd>

<dt><a name="1021360"> </a><code>&rarr;  <i><code>configP</code></i></code></dt>
<dd><a name="1021361"> </a>Pointer to the configuration structure specifying the serial port's properties. See <a href="SerialManager.html#1020533"><code>SrmOpenConfigType</code></a>.</dd>

<dt><a name="1021366"> </a><code>&rarr;  <i><code>configSize</code></i></code></dt>
<dd><a name="1021367"> </a>The size of the configuration structure pointed to by <code>configP</code>. </dd>

<dt><a name="1021368"> </a><code>&larr;  <i><code>newPortIdP</code></i></code></dt>
<dd><a name="1021369"> </a>Contains the port ID to be passed to other Serial Manager functions.</dd>

</dl>
<h4>
  <a name="1021370"> </a>Returns 
</h4>

<p><a name="1021371"> </a>This function returns the following error codes:</p>

<dl>
<dt><a name="1021372"> </a><code><code>errNone</code></code></dt>
<dd><a name="1021373"> </a>No error. </dd>

<dt><a name="1021374"> </a><code><code>serErrBadPort</code></code></dt>
<dd><a name="1021375"> </a>The <code>port</code> parameter does not specify a valid port. </dd>

<dt><a name="1021376"> </a><code><code>serErrBadParam</code></code></dt>
<dd><a name="1021377"> </a>The <code>configP</code> parameter is <code>NULL</code>. </dd>

<dt><a name="1021378"> </a><code><code>serErrAlreadyOpen</code></code></dt>
<dd><a name="1021379"> </a>The Serial Manager already has a port open. </dd>

<dt><a name="1021380"> </a><code><code>memErrNotEnoughSpace</code></code></dt>
<dd><a name="1021381"> </a>There was not enough memory available to open the port.</dd>

</dl>
<h4>
  <a name="1021382"> </a>Comments 
</h4>

<p><a name="1021383"> </a>Do not keep the port open any longer than necessary. An open serial port consumes more energy from the device's batteries. </p>

<p><a name="1021384"> </a>The values specified in the <code>configP</code> parameter depend on the type of connection being made. For RS-232 connections, you specify the baud rate but not a purpose. For USB connections, you specify a purpose but not a baud rate. </p>

<p><a name="1021385"> </a>A newly opened port has its line errors cleared, the default CTS timeout set (specified by the constant <code>srmDefaultCTSTimeout</code>), a 512-byte receive queue allocated, 1 stop bit, 8 bits per character, RTS enabled, and flow control enabled. To increase the receive queue size, use <a href="SerialManager.html#1022341"><code>SrmSetReceiveBuffer()</code></a>. To change the other serial port settings, use <a href="SerialManager.html#1021112"><code>SrmControl()</code></a>. </p>
<h4>
  <a name="1021395"> </a>Compatibility 
</h4>

<p><a name="1021399"> </a>Implemented only if both <a href="CompatibilityApdx.html#994556">New Serial Manager Feature Set Version 2</a> and <a href="CompatibilityApdx.html#995256">4.0 New Feature Set</a> are present. The <code>SrmExtOpen</code> function replaces the <a href="SerialManager.html#1021606"><code>SrmOpen()</code></a> function. </p>
<h4>
  <a name="1021406"> </a>See Also 
</h4>

<p><a name="1021413"> </a><a href="SerialManager.html#1021606"><code>SrmOpen()</code></a>, <a href="SerialManager.html#1021416"><code>SrmExtOpenBackground()</code></a></p>

<h3 class="hbH3">
  <a name="1021416"> </a>SrmExtOpenBackground Function <a href="#1020300"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="1021418"> </a>Purpose 
</h4>

<p><a name="1021419"> </a>Opens a port with the specified configuration in the background. Background ports relinquish control when another task opens the port with the <a href="SerialManager.html#1021606"><code>SrmOpen()</code></a> or <a href="SerialManager.html#1021346"><code>SrmExtOpen()</code></a> call. </p>
<h4>
  <a name="1021428"> </a>Declared In 
</h4>
<code>SerialMgr.h<a name="1021429"> </a></code><h4>
  <a name="1021430"> </a>Prototype 
</h4>
<pre class="proto"><a name="1021431"></a>Err SrmExtOpenBackground (
   UInt32 port,
   SrmOpenConfigType *configP,
   UInt16 configSize,
   UInt16 *newPortIdP
)
</pre>
<h4>
  <a name="1021432"> </a>Parameters 
</h4>

<dl>
<dt><a name="1021433"> </a><code>&rarr;  <i><code>port</code></i></code></dt>
<dd><a name="1021436"> </a>Physical or logical port number to be opened. See <a href="SerialManager.html#1020613">Port Constants</a> for more information. </dd>

<dt><a name="1021438"> </a><code>&rarr;  <i><code>configP</code></i></code></dt>
<dd><a name="1021439"> </a>Pointer to the configuration structure specifying the serial port's properties. See <a href="SerialManager.html#1020533"><code>SrmOpenConfigType</code></a>.</dd>

<dt><a name="1021444"> </a><code>&rarr;  <i><code>configSize</code></i></code></dt>
<dd><a name="1021445"> </a>The size of the configuration structure pointed to by <code>configP</code>. </dd>

<dt><a name="1021446"> </a><code>&larr;  <i><code>newPortIdP</code></i></code></dt>
<dd><a name="1021447"> </a>Contains the port ID to be passed to other Serial Manager functions.</dd>

</dl>
<h4>
  <a name="1021448"> </a>Returns 
</h4>

<p><a name="1021449"> </a>This function returns the following error codes:</p>

<dl>
<dt><a name="1021450"> </a><code><code>errNone</code> </code></dt>
<dd><a name="1021451"> </a>No error.</dd>

<dt><a name="1021452"> </a><code><code>serErrAlreadyOpen</code></code></dt>
<dd><a name="1021453"> </a>This port already has an installed background owner.</dd>

<dt><a name="1021454"> </a><code><code>serErrBadPort</code></code></dt>
<dd><a name="1021455"> </a>This port doesn't exist.</dd>

<dt><a name="1021456"> </a><code><code>serErrNotSupported</code></code></dt>
<dd><a name="1021457"> </a>This type of port cannot be opened in the background. </dd>

<dt><a name="1021458"> </a><code><code>serErrBadParam</code></code></dt>
<dd><a name="1021459"> </a>The <code>configP</code> parameter is <code>NULL</code>. </dd>

<dt><a name="1021460"> </a><code><code>memErrNotEnoughSpace</code></code></dt>
<dd><a name="1021461"> </a>There was not enough memory available to open the port.</dd>

</dl>
<h4>
  <a name="1021462"> </a>Comments 
</h4>

<p><a name="1021463"> </a>This function is provided to support tasks that want to use a serial device to receive data only when no other task is using the port.</p>

<p><a name="1021464"> </a>If a background port is forced to surrender control of the hardware as a result of another task opening a foreground connection, all buffers for the background port are flushed. After this active task closes the port, active control of the port is returned to the background task. Only one task can have background ownership of the port.</p>

<p><a name="1021465"> </a>Note that background ports have limited functionality: they can only receive data and notify owning clients of what data has been received.</p>

<p><a name="1021466"> </a>The values specified in the <code>configP</code> parameter depend on the type of connection being made. For RS-232 connections, you specify the baud rate but not a purpose. For USB connections, you specify a purpose but not a baud rate. </p>
<h4>
  <a name="1021467"> </a>Compatibility 
</h4>

<p><a name="1021471"> </a>Implemented only if both <a href="CompatibilityApdx.html#994556">New Serial Manager Feature Set Version 2</a> and <a href="CompatibilityApdx.html#995256">4.0 New Feature Set</a> are present. The <code>SrmExtOpenBackground</code> function replaces the <a href="SerialManager.html#1021657"><code>SrmOpenBackground()</code></a> function. </p>
<h4>
  <a name="1021478"> </a>See Also 
</h4>

<p><a name="1021485"> </a><a href="SerialManager.html#1021606"><code>SrmOpen()</code></a>, <a href="SerialManager.html#1021346"><code>SrmExtOpen()</code></a></p>

<h3 class="hbH3">
  <a name="1021488"> </a>SrmGetDeviceCount Function <a href="#1020300"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="1021490"> </a>Purpose 
</h4>

<p><a name="1021491"> </a>Returns the number of available serial devices.</p>
<h4>
  <a name="1021492"> </a>Declared In 
</h4>
<code>SerialMgr.h<a name="1021493"> </a></code><h4>
  <a name="1021494"> </a>Prototype 
</h4>
<pre class="proto"><a name="1021495"></a>Err SrmGetDeviceCount (
   UInt16 *numOfDevicesP
)
</pre>
<h4>
  <a name="1021496"> </a>Parameters 
</h4>

<dl>
<dt><a name="1021497"> </a><code>&larr;  <i><code>numOfDevicesP</code></i></code></dt>
<dd><a name="1021498"> </a>Pointer to address where the number of serial devices is returned.</dd>

</dl>
<h4>
  <a name="1021499"> </a>Returns 
</h4>

<dl>
<dt><a name="1021500"> </a><code><code>errNone</code></code></dt>
<dd><a name="1021501"> </a>No error. </dd>

</dl>
<h4>
  <a name="1021502"> </a>Compatibility 
</h4>

<p><a name="1021506"> </a>Implemented only if <a href="CompatibilityApdx.html#994402">New Serial Manager Feature Set Version 1</a> is present.</p>
<h4>
  <a name="1021507"> </a>See Also 
</h4>

<p><a name="1021511"> </a><a href="SerialManager.html#1021514"><code>SrmGetDeviceInfo()</code></a></p>

<h3 class="hbH3">
  <a name="1021514"> </a>SrmGetDeviceInfo Function <a href="#1020300"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="1021516"> </a>Purpose 
</h4>

<p><a name="1021517"> </a>Returns information about a serial device.</p>
<h4>
  <a name="1021518"> </a>Declared In 
</h4>
<code>SerialMgr.h<a name="1021519"> </a></code><h4>
  <a name="1021520"> </a>Prototype 
</h4>
<pre class="proto"><a name="1021521"></a>Err SrmGetDeviceInfo (
   UInt32 deviceID,
   DeviceInfoType *deviceInfoP
)
</pre>
<h4>
  <a name="1021522"> </a>Parameters 
</h4>

<dl>
<dt><a name="1021523"> </a><code>&rarr;  <i><code>deviceID</code></i></code></dt>
<dd><a name="1021524"> </a>ID of serial device to get information for. You can pass a zero-based index (0, 1, 2, ...), a valid port ID returned from <a href="SerialManager.html#1021606"><code>SrmOpen()</code></a> or <a href="SerialManager.html#1021346"><code>SrmExtOpen()</code></a>, or a 4-character port name (such as 'u328', 'u650', or 'ircm'). See <a href="SerialManager.html#1020613">Port Constants</a>.</dd>

<dt><a name="1021534"> </a><code>&larr;  <i><code>deviceInfoP</code></i></code></dt>
<dd><a name="1021539"> </a>Pointer to a <a href="SerialManager.html#1020333"><code>DeviceInfoType</code></a> structure where information about the device is returned.</dd>

</dl>
<h4>
  <a name="1021540"> </a>Returns 
</h4>

<p><a name="1021541"> </a>This function returns the following error codes:</p>

<dl>
<dt><a name="1021542"> </a><code><code>errNone</code></code></dt>
<dd><a name="1021543"> </a>No error. </dd>

<dt><a name="1021544"> </a><code><code>serErrBadPort</code></code></dt>
<dd><a name="1021545"> </a>This port doesn't exist.</dd>

<dt><a name="1021546"> </a><code><code>serErrNoDevicesAvail</code></code></dt>
<dd><a name="1021547"> </a>The Serial Manager cannot find any serial devices. </dd>

</dl>
<h4>
  <a name="1021548"> </a>Compatibility 
</h4>

<p><a name="1021552"> </a>Implemented only if <a href="CompatibilityApdx.html#994402">New Serial Manager Feature Set Version 1</a> is present.</p>
<h4>
  <a name="1021553"> </a>See Also 
</h4>

<p><a name="1021557"> </a><a href="SerialManager.html#1021488"><code>SrmGetDeviceCount()</code></a></p>

<h3 class="hbH3">
  <a name="1021560"> </a>SrmGetStatus Function <a href="#1020300"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="1021562"> </a>Purpose 
</h4>

<p><a name="1021563"> </a>Returns status information about the serial hardware.</p>
<h4>
  <a name="1021564"> </a>Declared In 
</h4>
<code>SerialMgr.h<a name="1021565"> </a></code><h4>
  <a name="1021566"> </a>Prototype 
</h4>
<pre class="proto"><a name="1021567"></a>Err SrmGetStatus (
   UInt16 portId,
   UInt32 *statusFieldP,
   UInt16 *lineErrsP
)
</pre>
<h4>
  <a name="1021568"> </a>Parameters 
</h4>

<dl>
<dt><a name="1021569"> </a><code>&rarr;  <i><code>portID</code></i></code></dt>
<dd><a name="1021576"> </a>Port ID returned from <a href="SerialManager.html#1021606"><code>SrmOpen()</code></a> or <a href="SerialManager.html#1021346"><code>SrmExtOpen()</code></a>.</dd>

<dt><a name="1021577"> </a><code>&larr;  <i><code>statusFieldP</code></i></code></dt>
<dd><a name="1021578"> </a>Pointer to address where hardware status information for the port is returned. This is a 32-bit field using the flags described in <a href="SerialManager.html#1020943">Status Constants</a>.</dd>

<dt><a name="1021582"> </a><code>&larr;  <i><code>lineErrsP</code></i></code></dt>
<dd><a name="1021583"> </a>Pointer to address where the number of line errors for the port is returned. The line error flags are described in <a href="SerialManager.html#1020983">Line Error Constants</a>.</dd>

</dl>
<h4>
  <a name="1021587"> </a>Returns 
</h4>

<p><a name="1021588"> </a>This function returns the following error codes:</p>

<dl>
<dt><a name="1021589"> </a><code><code>errNone</code> </code></dt>
<dd><a name="1021590"> </a>No error.</dd>

<dt><a name="1021591"> </a><code><code>serErrBadPort</code></code></dt>
<dd><a name="1021592"> </a>This port doesn't exist.</dd>

<dt><a name="1021593"> </a><code><code>serErrNotSupported</code></code></dt>
<dd><a name="1021594"> </a>The port is a yielded port. </dd>

<dt><a name="1021595"> </a><code><code>serErrNoDevicesAvail</code></code></dt>
<dd><a name="1021596"> </a>No serial devices could be found. </dd>

</dl>
<h4>
  <a name="1021597"> </a>Comments 
</h4>

<p><a name="1021598"> </a>Typically, <code>SrmGetStatus</code> is called to retrieve the line errors for the port if some of the send and receive functions return a <code>serErrLineErr</code> error code.</p>
<h4>
  <a name="1021599"> </a>Compatibility 
</h4>

<p><a name="1021603"> </a>Implemented only if <a href="CompatibilityApdx.html#994402">New Serial Manager Feature Set Version 1</a> is present.</p>

<h3 class="hbH3">
  <a name="1021606"> </a>SrmOpen Function <a href="#1020300"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="1021608"> </a>Purpose 
</h4>

<p><a name="1021609"> </a>Opens a foreground port connection with the specified port name or logical port number.</p>
<h4>
  <a name="1021610"> </a>Declared In 
</h4>
<code>SerialMgr.h<a name="1021611"> </a></code><h4>
  <a name="1021612"> </a>Prototype 
</h4>
<pre class="proto"><a name="1021613"></a>Err SrmOpen (
   UInt32 port,
   UInt32 baud,
   UInt16 *newPortIdP
)
</pre>
<h4>
  <a name="1021614"> </a>Parameters 
</h4>

<dl>
<dt><a name="1021615"> </a><code>&rarr;  <i><code>port</code></i></code></dt>
<dd><a name="1021616"> </a>The four-character port name or logical port number to be opened. See <a href="SerialManager.html#1020613">Port Constants</a> for more information. </dd>

<dt><a name="1021620"> </a><code>&rarr;  <i><code>baud</code></i></code></dt>
<dd><a name="1021621"> </a>Initial baud rate of port.</dd>

<dt><a name="1021622"> </a><code>&larr;  <i><code>newPortIdP</code></i></code></dt>
<dd><a name="1021623"> </a>Contains the port ID to be passed to other Serial Manager functions.</dd>

</dl>
<h4>
  <a name="1021624"> </a>Returns 
</h4>

<p><a name="1021625"> </a>This function returns the following error codes:</p>

<dl>
<dt><a name="1021626"> </a><code><code>errNone</code> </code></dt>
<dd><a name="1021627"> </a>No error.</dd>

<dt><a name="1021628"> </a><code><code>serErrAlreadyOpen</code></code></dt>
<dd><a name="1021629"> </a>This port already has an installed foreground owner.</dd>

<dt><a name="1021630"> </a><code><code>serErrBadPort</code></code></dt>
<dd><a name="1021631"> </a>This port doesn't exist.</dd>

<dt><a name="1021632"> </a><code><code>memErrNotEnoughSpace</code></code></dt>
<dd><a name="1021633"> </a>There was not enough memory available to open the port.</dd>

</dl>
<h4>
  <a name="1021634"> </a>Comments 
</h4>

<p><a name="1021635"> </a>Only one application or task may have access to a particular serial port at any time.</p>

<p><a name="1021636"> </a>Do not keep the port open any longer than necessary. An open serial port consumes more energy from the device's batteries. </p>
<h4>
  <a name="1021637"> </a>Compatibility 
</h4>

<p><a name="1021641"> </a>Implemented only if <a href="CompatibilityApdx.html#994402">New Serial Manager Feature Set Version 1</a> is present.</p>

<p><a name="1021645"> </a>If <a href="CompatibilityApdx.html#994556">New Serial Manager Feature Set Version 2</a> is present, the <code>SrmOpen</code> function is replaced by <a href="SerialManager.html#1021346"><code>SrmExtOpen()</code></a>. <code>SrmOpen</code> is supported for backward compatibility. </p>
<h4>
  <a name="1021650"> </a>See Also 
</h4>

<p><a name="1021654"> </a><a href="SerialManager.html#1021657"><code>SrmOpenBackground()</code></a></p>

<h3 class="hbH3">
  <a name="1021657"> </a>SrmOpenBackground Function <a href="#1020300"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="1021659"> </a>Purpose 
</h4>

<p><a name="1021660"> </a>Allows a task to open, initialize, and use the port, but always relinquishes control of the port when another task opens the port with the <a href="SerialManager.html#1021606"><code>SrmOpen()</code></a> call.</p>
<h4>
  <a name="1021664"> </a>Declared In 
</h4>
<code>SerialMgr.h<a name="1021665"> </a></code><h4>
  <a name="1021666"> </a>Prototype 
</h4>
<pre class="proto"><a name="1021667"></a>Err SrmOpenBackground (
   UInt32 port,
   UInt32 baud,
   UInt16 *newPortIdP
)
</pre>
<h4>
  <a name="1021668"> </a>Parameters 
</h4>

<dl>
<dt><a name="1021669"> </a><code>&rarr;  <i><code>port</code></i></code></dt>
<dd><a name="1021670"> </a>The four-character port name or logical port number to be opened. See <a href="SerialManager.html#1020613">Port Constants</a> for more information. </dd>

<dt><a name="1021674"> </a><code>&rarr;  <i><code>baud</code></i></code></dt>
<dd><a name="1021675"> </a>Initial baud rate of port.</dd>

<dt><a name="1021676"> </a><code>&larr;  <i><code>newPortIdP</code></i></code></dt>
<dd><a name="1021677"> </a>Contains the port ID to be passed to other Serial Manager functions.</dd>

</dl>
<h4>
  <a name="1021678"> </a>Returns 
</h4>

<p><a name="1021679"> </a>This function returns the following error codes:</p>

<dl>
<dt><a name="1021680"> </a><code><code>errNone</code></code></dt>
<dd><a name="1021681"> </a>No error.</dd>

<dt><a name="1021682"> </a><code><code>serErrAlreadyOpen</code></code></dt>
<dd><a name="1021683"> </a>This port already has an installed background owner.</dd>

<dt><a name="1021684"> </a><code><code>serErrBadPort</code></code></dt>
<dd><a name="1021685"> </a>This port doesn't exist.</dd>

<dt><a name="1021686"> </a><code><code>memErrNotEnoughSpace</code></code></dt>
<dd><a name="1021687"> </a>There was not enough memory available to open the port.</dd>

</dl>
<h4>
  <a name="1021688"> </a>Comments 
</h4>

<p><a name="1021689"> </a>This function is provided to support tasks that want to use a serial device to receive data only when no other task is using the port.</p>

<p><a name="1021690"> </a>If a background port is forced to surrender control of the hardware as a result of another task opening a foreground connection, all buffers for the background port are flushed. After this active task closes the port, active control of the port is returned to the background task. Only one task can have background ownership of the port.</p>

<p><a name="1021691"> </a>Note that background ports have limited functionality: they can only receive data and notify owning clients of what data has been received.</p>
<h4>
  <a name="1021692"> </a>Compatibility 
</h4>

<p><a name="1021696"> </a>Implemented only if <a href="CompatibilityApdx.html#994402">New Serial Manager Feature Set Version 1</a> is present.</p>

<p><a name="1023691"> </a>If <a href="CompatibilityApdx.html#994556">New Serial Manager Feature Set Version 2</a> is present, the <code>SrmOpenBackground()</code> function is replaced by <a href="SerialManager.html#1021416"><code>SrmExtOpenBackground()</code></a>. <code>SrmOpenBackground()</code> is supported for backward compatibility. If <a href="CompatibilityApdx.html#1029305">Palm OS Cobalt Feature Set</a> is present, this function is unimplemented.</p>
<h4>
  <a name="1021705"> </a>See Also 
</h4>

<p><a name="1021709"> </a><a href="SerialManager.html#1021606"><code>SrmOpen()</code></a></p>

<h3 class="hbH3">
  <a name="1021712"> </a>SrmPrimeWakeupHandler Function <a href="#1020300"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="1021714"> </a>Purpose 
</h4>

<p><a name="1021715"> </a>Sets the number of received bytes that triggers a call to the wakeup handler function.</p>
<h4>
  <a name="1021716"> </a>Declared In 
</h4>
<code>SerialMgr.h<a name="1021717"> </a></code><h4>
  <a name="1021718"> </a>Prototype 
</h4>
<pre class="proto"><a name="1021719"></a>Err SrmPrimeWakeupHandler (
   UInt16 portId,
   UInt16 minBytes
)
</pre>
<h4>
  <a name="1021720"> </a>Parameters 
</h4>

<dl>
<dt><a name="1021721"> </a><code>&rarr;  <i><code>portId</code></i></code></dt>
<dd><a name="1021728"> </a>Port ID returned from <a href="SerialManager.html#1021606"><code>SrmOpen()</code></a> or <a href="SerialManager.html#1021346"><code>SrmExtOpen()</code></a>.</dd>

<dt><a name="1021729"> </a><code>&rarr;  <i><code>minBytes</code></i></code></dt>
<dd><a name="1021730"> </a>Number of bytes that must be received before wakeup handler is called. Typically, this is set to 1.</dd>

</dl>
<h4>
  <a name="1021731"> </a>Returns 
</h4>

<p><a name="1021732"> </a>This function returns the following error codes:</p>

<dl>
<dt><a name="1021733"> </a><code><code>errNone</code></code></dt>
<dd><a name="1021734"> </a>No error.</dd>

<dt><a name="1021735"> </a><code><code>serErrBadPort</code></code></dt>
<dd><a name="1021736"> </a>This port doesn't exist.</dd>

<dt><a name="1021737"> </a><code><code>serErrNotOpen</code></code></dt>
<dd><a name="1021738"> </a>The port is not open. </dd>

<dt><a name="1021739"> </a><code><code>serErrNoDevicesAvail</code></code></dt>
<dd><a name="1021740"> </a>No serial devices could be found. </dd>

</dl>
<h4>
  <a name="1021741"> </a>Comments 
</h4>

<p><a name="1021742"> </a>This function primes a wakeup handler installed by <a href="SerialManager.html#1022385"><code>SrmSetWakeupHandler()</code></a>.</p>
<h4>
  <a name="1021747"> </a>Compatibility 
</h4>

<p><a name="1021751"> </a>Implemented only if <a href="CompatibilityApdx.html#994402">New Serial Manager Feature Set Version 1</a> is present.</p>
<h4>
  <a name="1021752"> </a>See Also 
</h4>

<p><a name="1021759"> </a><a href="SerialManager.html#1022385"><code>SrmSetWakeupHandler()</code></a>, <a href="SerialManager.html#1022445"><code>WakeupHandlerProcPtr()</code></a></p>

<h3 class="hbH3">
  <a name="1021762"> </a>SrmReceive Function <a href="#1020300"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="1021764"> </a>Purpose 
</h4>

<p><a name="1021765"> </a>Receives a specified number of bytes.</p>
<h4>
  <a name="1021766"> </a>Declared In 
</h4>
<code>SerialMgr.h<a name="1021767"> </a></code><h4>
  <a name="1021768"> </a>Prototype 
</h4>
<pre class="proto"><a name="1021769"></a>UInt32 SrmReceive (
   UInt16 portId,
   void *rcvBufP,
   UInt32 count,
   Int32 timeout,
   Err *errP
)
</pre>
<h4>
  <a name="1021770"> </a>Parameters 
</h4>

<dl>
<dt><a name="1021771"> </a><code>&rarr;  <i><code>portID</code></i></code></dt>
<dd><a name="1021778"> </a>Port ID returned from <a href="SerialManager.html#1021606"><code>SrmOpen()</code></a> or <a href="SerialManager.html#1021346"><code>SrmExtOpen()</code></a>.</dd>

<dt><a name="1021779"> </a><code>&larr;  <i><code>rcvBufP</code></i></code></dt>
<dd><a name="1021780"> </a>Pointer to buffer where received data is to be returned.</dd>

<dt><a name="1021781"> </a><code>&rarr;  <i><code>count</code></i></code></dt>
<dd><a name="1021782"> </a>Length of data buffer (in bytes). This specifies the number of bytes to receive.</dd>

<dt><a name="1021783"> </a><code>&rarr;  <i><code>timeout</code></i></code></dt>
<dd><a name="1021784"> </a>The amount of time (in ticks) that the Serial Manager waits to receive the requested block of data. At the end of the timeout, data received up to that time is returned.</dd>

<dt><a name="1021785"> </a><code>&larr;  <i><code>errP</code></i></code></dt>
<dd><a name="1021786"> </a>Error code.</dd>

</dl>
<h4>
  <a name="1021787"> </a>Returns 
</h4>

<p><a name="1021788"> </a>Number of bytes of data actually received.</p>
<h4>
  <a name="1021789"> </a>Comments 
</h4>

<p><a name="1021790"> </a>The following error codes can be returned in <code>errP</code>:</p>

<dl>
<dt><a name="1021791"> </a><code><code>errNone</code> </code></dt>
<dd><a name="1021792"> </a>No error.</dd>

<dt><a name="1021793"> </a><code><code>serErrBadPort</code></code></dt>
<dd><a name="1021794"> </a>This port doesn't exist.</dd>

<dt><a name="1021795"> </a><code><code>serErrNotOpen</code></code></dt>
<dd><a name="1021796"> </a>The port is not open. </dd>

<dt><a name="1021797"> </a><code><code>serErrTimeOut</code></code></dt>
<dd><a name="1021798"> </a>Unable to receive data within the specified timeout period.</dd>

<dt><a name="1021799"> </a><code><code>serErrConfigurationFailed</code></code></dt>
<dd><a name="1021800"> </a>The port needs time to configure, and the configuration has failed. </dd>

<dt><a name="1021801"> </a><code><code>serErrNotSupported</code></code></dt>
<dd><a name="1021802"> </a>The port is not the foreground port. </dd>

<dt><a name="1021804"> </a><code><code>serErrConfigurationFailed</code></code></dt>
<dd><a name="1021805"> </a>The port could not configure itself. </dd>

<dt><a name="1021806"> </a><code><code>serErrLineErr</code></code></dt>
<dd><a name="1021807"> </a>A line error occurred during the receipt of data. Use <a href="SerialManager.html#1021560"><code>SrmGetStatus()</code></a> to obtain the exact line error. </dd>

<dt><a name="1021812"> </a><code><code>serErrNoDevicesAvail</code></code></dt>
<dd><a name="1021813"> </a>No serial devices could be found. </dd>

</dl>
<h4>
  <a name="1021814"> </a>Compatibility 
</h4>

<p><a name="1021818"> </a>Implemented only if <a href="CompatibilityApdx.html#994402">New Serial Manager Feature Set Version 1</a> is present.</p>
<h4>
  <a name="1021819"> </a>See Also 
</h4>

<p><a name="1021826"> </a><a href="SerialManager.html#1021832"><code>SrmReceiveCheck()</code></a>, <a href="SerialManager.html#1021883"><code>SrmReceiveFlush()</code></a>, <a href="SerialManager.html#1021935"><code>SrmReceiveWait()</code></a></p>

<h3 class="hbH3">
  <a name="1021832"> </a>SrmReceiveCheck Function <a href="#1020300"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="1021834"> </a>Purpose 
</h4>

<p><a name="1021835"> </a>Checks the receive FIFO and returns the number of bytes in the serial receive queue.</p>
<h4>
  <a name="1021836"> </a>Declared In 
</h4>
<code>SerialMgr.h<a name="1021837"> </a></code><h4>
  <a name="1021838"> </a>Prototype 
</h4>
<pre class="proto"><a name="1021839"></a>Err SrmReceiveCheck (
   UInt16 portId,
   UInt32 *numBytesP
)
</pre>
<h4>
  <a name="1021840"> </a>Parameters 
</h4>

<dl>
<dt><a name="1021841"> </a><code>&rarr;  <i><code>portID</code></i></code></dt>
<dd><a name="1021848"> </a>Port ID returned from <a href="SerialManager.html#1021606"><code>SrmOpen()</code></a> or <a href="SerialManager.html#1021346"><code>SrmExtOpen()</code></a>.</dd>

<dt><a name="1021849"> </a><code>&larr;  <i><code>numBytesP</code></i></code></dt>
<dd><a name="1021850"> </a>Number of bytes in the receive queue.</dd>

</dl>
<h4>
  <a name="1021851"> </a>Returns 
</h4>

<p><a name="1021852"> </a>This function returns the following error codes:</p>

<dl>
<dt><a name="1021853"> </a><code><code>errNone</code></code></dt>
<dd><a name="1021854"> </a>No error.</dd>

<dt><a name="1021855"> </a><code><code>serErrBadPort</code></code></dt>
<dd><a name="1021856"> </a>This port doesn't exist.</dd>

<dt><a name="1021857"> </a><code><code>serErrNotOpen</code></code></dt>
<dd><a name="1021858"> </a>The port is not open. </dd>

<dt><a name="1021859"> </a><code><code>serErrLineErr</code></code></dt>
<dd><a name="1021864"> </a>A line error has occurred. Use <a href="SerialManager.html#1021560"><code>SrmGetStatus()</code></a> to obtain the exact line error. </dd>

</dl>
<h4>
  <a name="1021865"> </a>Compatibility 
</h4>

<p><a name="1021869"> </a>Implemented only if <a href="CompatibilityApdx.html#994402">New Serial Manager Feature Set Version 1</a> is present.</p>
<h4>
  <a name="1021870"> </a>See Also 
</h4>

<p><a name="1021880"> </a><a href="SerialManager.html#1021762"><code>SrmReceive()</code></a>, <a href="SerialManager.html#1021883"><code>SrmReceiveFlush()</code></a>, <a href="SerialManager.html#1021935"><code>SrmReceiveWait()</code></a></p>

<h3 class="hbH3">
  <a name="1021883"> </a>SrmReceiveFlush Function <a href="#1020300"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="1021885"> </a>Purpose 
</h4>

<p><a name="1021886"> </a>Flushes the receive FIFOs.</p>
<h4>
  <a name="1021887"> </a>Declared In 
</h4>
<code>SerialMgr.h<a name="1021888"> </a></code><h4>
  <a name="1021889"> </a>Prototype 
</h4>
<pre class="proto"><a name="1021890"></a>Err SrmReceiveFlush (
   UInt16 portId,
   Int32 timeout
)
</pre>
<h4>
  <a name="1021891"> </a>Parameters 
</h4>

<dl>
<dt><a name="1021892"> </a><code>&rarr;  <i><code>portId</code></i></code></dt>
<dd><a name="1021899"> </a>Port ID returned from <a href="SerialManager.html#1021606"><code>SrmOpen()</code></a> or <a href="SerialManager.html#1021346"><code>SrmExtOpen()</code></a>.</dd>

<dt><a name="1021900"> </a><code>&rarr;  <i><code>timeout</code></i></code></dt>
<dd><a name="1021901"> </a>Timeout value, in ticks.</dd>

</dl>
<h4>
  <a name="1021902"> </a>Returns 
</h4>

<p><a name="1021903"> </a>This function returns the following error codes:</p>

<dl>
<dt><a name="1021904"> </a><code><code>errNone</code> </code></dt>
<dd><a name="1021905"> </a>No error.</dd>

<dt><a name="1021906"> </a><code><code>serErrBadPort</code></code></dt>
<dd><a name="1021907"> </a>This port doesn't exist.</dd>

<dt><a name="1021908"> </a><code><code>serErrNotOpen</code></code></dt>
<dd><a name="1021909"> </a>The port is not open. </dd>

<dt><a name="1021910"> </a><code><code>serErrNotSupported</code></code></dt>
<dd><a name="1021911"> </a>The port is not the foreground port. </dd>

<dt><a name="1021912"> </a><code><code>serErrNoDevicesAvail</code></code></dt>
<dd><a name="1021913"> </a>No serial devices could be found. </dd>

</dl>
<h4>
  <a name="1021914"> </a>Comments 
</h4>

<p><a name="1021915"> </a>The <code>timeout</code> value forces this function to wait a period of ticks after flushing the port to see if more data shows up to be flushed. If more data arrives within the timeout period, the port is flushed again and the timeout counter is reset and waits again. The function only exits after no more bytes are received by the port for the full timeout period since the last flush of the port. To avoid this waiting behavior, specify 0 for the timeout period.</p>

<p><a name="1021916"> </a>Any errors on the line are cleared before this function returns. </p>
<h4>
  <a name="1021917"> </a>Compatibility 
</h4>

<p><a name="1021921"> </a>Implemented only if <a href="CompatibilityApdx.html#994402">New Serial Manager Feature Set Version 1</a> is present.</p>
<h4>
  <a name="1021922"> </a>See Also 
</h4>

<p><a name="1021932"> </a><a href="SerialManager.html#1021762"><code>SrmReceive()</code></a>, <a href="SerialManager.html#1021832"><code>SrmReceiveCheck()</code></a>, <a href="SerialManager.html#1021935"><code>SrmReceiveWait()</code></a></p>

<h3 class="hbH3">
  <a name="1021935"> </a>SrmReceiveWait Function <a href="#1020300"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="1021937"> </a>Purpose 
</h4>

<p><a name="1021938"> </a>Waits until some number of bytes of data have arrived into the serial receive queue, then returns.</p>
<h4>
  <a name="1021939"> </a>Declared In 
</h4>
<code>SerialMgr.h<a name="1021940"> </a></code><h4>
  <a name="1021941"> </a>Prototype 
</h4>
<pre class="proto"><a name="1021942"></a>Err SrmReceiveWait (
   UInt16 portId,
   UInt32 bytes,
   Int32 timeout
)
</pre>
<h4>
  <a name="1021943"> </a>Parameters 
</h4>

<dl>
<dt><a name="1021944"> </a><code>&rarr;  <i><code>portID</code></i></code></dt>
<dd><a name="1021951"> </a>Port ID returned from <a href="SerialManager.html#1021606"><code>SrmOpen()</code></a> or <a href="SerialManager.html#1021346"><code>SrmExtOpen()</code></a>.</dd>

<dt><a name="1021952"> </a><code>&rarr;  <i><code>bytes</code></i></code></dt>
<dd><a name="1021953"> </a>Number of bytes to wait for.</dd>

<dt><a name="1021954"> </a><code>&rarr;  <i><code>timeout</code></i></code></dt>
<dd><a name="1021955"> </a>Timeout value, in ticks.</dd>

</dl>
<h4>
  <a name="1021956"> </a>Returns 
</h4>

<p><a name="1021957"> </a>This function returns the following error codes:</p>

<dl>
<dt><a name="1021958"> </a><code><code>errNone</code></code></dt>
<dd><a name="1021959"> </a>No error.</dd>

<dt><a name="1021960"> </a><code><code>serErrBadPort</code></code></dt>
<dd><a name="1021961"> </a>This port doesn't exist.</dd>

<dt><a name="1021962"> </a><code><code>serErrNotOpen</code></code></dt>
<dd><a name="1021963"> </a>The port is not open.</dd>

<dt><a name="1021964"> </a><code><code>serErrTimeOut</code></code></dt>
<dd><a name="1021965"> </a>Unable to receive data within the specified timeout period.</dd>

<dt><a name="1021966"> </a><code><code>serErrNotSupported</code></code></dt>
<dd><a name="1021967"> </a>The port is not the foreground port. </dd>

<dt><a name="1021968"> </a><code><code>serErrBadParam</code></code></dt>
<dd><a name="1021969"> </a>The bytes parameter exceeds the size of the receive queue. Use <a href="SerialManager.html#1022341"><code>SrmSetReceiveBuffer()</code></a> to increase the size of the receive queue. </dd>

<dt><a name="1021974"> </a><code><code>serErrLineErr</code></code></dt>
<dd><a name="1021975"> </a>A line error occurred during the receipt of data. Use <a href="SerialManager.html#1021560"><code>SrmGetStatus()</code></a> to obtain the exact line error. </dd>

<dt><a name="1021980"> </a><code><code>serErrNoDevicesAvail</code></code></dt>
<dd><a name="1021981"> </a>No serial devices could be found. </dd>

</dl>
<h4>
  <a name="1021982"> </a>Comments 
</h4>

<p><a name="1021983"> </a>If this function returns no error, the application can either check the number of bytes currently in the receive queue (using <a href="SerialManager.html#1021832"><code>SrmReceiveCheck()</code></a>) or it can just specify a buffer and receive the data by calling <a href="SerialManager.html#1021762"><code>SrmReceive()</code></a>.</p>

<p><a name="1021992"> </a>Do not call <code>SerReceiveWait</code> from within a wakeup handler. If you do, the <code>serErrTimeOut</code> error is returned. </p>
<h4>
  <a name="1021993"> </a>Compatibility 
</h4>

<p><a name="1021997"> </a>Implemented only if <a href="CompatibilityApdx.html#994402">New Serial Manager Feature Set Version 1</a> is present.</p>
<h4>
  <a name="1021998"> </a>See Also 
</h4>

<p><a name="1022008"> </a><a href="SerialManager.html#1021762"><code>SrmReceive()</code></a>, <a href="SerialManager.html#1021832"><code>SrmReceiveCheck()</code></a>, <a href="SerialManager.html#1021883"><code>SrmReceiveFlush()</code></a></p>

<h3 class="hbH3">
  <a name="1022011"> </a>SrmReceiveWindowClose Function <a href="#1020300"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="1022013"> </a>Purpose 
</h4>

<p><a name="1022014"> </a>Closes direct access to the Serial Manager's receive queue.</p>
<h4>
  <a name="1022015"> </a>Declared In 
</h4>
<code>SerialMgr.h<a name="1022016"> </a></code><h4>
  <a name="1022017"> </a>Prototype 
</h4>
<pre class="proto"><a name="1022018"></a>Err SrmReceiveWindowClose (
   UInt16 portId,
   UInt32 bytesPulled
)
</pre>
<h4>
  <a name="1022019"> </a>Parameters 
</h4>

<dl>
<dt><a name="1022020"> </a><code>&rarr;  <i><code>portId</code></i></code></dt>
<dd><a name="1022027"> </a>Port ID returned from <a href="SerialManager.html#1021606"><code>SrmOpen()</code></a> or <a href="SerialManager.html#1021346"><code>SrmExtOpen()</code></a>.</dd>

<dt><a name="1022028"> </a><code>&rarr;  <i><code>bytesPulled</code></i></code></dt>
<dd><a name="1022029"> </a>Number of bytes the application read from the receive queue.</dd>

</dl>
<h4>
  <a name="1022030"> </a>Returns 
</h4>

<p><a name="1022031"> </a>This function returns the following error codes:</p>

<dl>
<dt><a name="1022032"> </a><code><code>errNone</code></code></dt>
<dd><a name="1022033"> </a>No error.</dd>

<dt><a name="1022034"> </a><code><code>serErrBadPort</code></code></dt>
<dd><a name="1022035"> </a>This port doesn't exist.</dd>

<dt><a name="1022036"> </a><code><code>serErrNotOpen</code></code></dt>
<dd><a name="1022037"> </a>The port is not open. </dd>

<dt><a name="1022038"> </a><code><code>serErrNotSupported</code></code></dt>
<dd><a name="1022039"> </a>The port is not the foreground port. </dd>

<dt><a name="1022040"> </a><code><code>serErrNoDevicesAvail</code></code></dt>
<dd><a name="1022041"> </a>No serial devices could be found. </dd>

</dl>
<h4>
  <a name="1022042"> </a>Comments 
</h4>

<p><a name="1022043"> </a>Call this function when the application has read as many bytes as it needs out of the receive queue or it has read all the available bytes.</p>
<h4>
  <a name="1022044"> </a>Compatibility 
</h4>

<p><a name="1022048"> </a>Implemented only if <a href="CompatibilityApdx.html#994402">New Serial Manager Feature Set Version 1</a> is present.</p>
<h4>
  <a name="1029024"> </a>See Also 
</h4>

<p><a name="1029028"> </a><a href="SerialManager.html#1029031"><code>SrmReceiveWindowOpen()</code></a></p>

<h3 class="hbH3">
  <a name="1029031"> </a>SrmReceiveWindowOpen Function <a href="#1020300"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="1022058"> </a>Purpose 
</h4>

<p><a name="1022059"> </a>Provides direct access to the Serial Manager's receive queue.</p>
<h4>
  <a name="1022060"> </a>Declared In 
</h4>
<code>SerialMgr.h<a name="1022061"> </a></code><h4>
  <a name="1022062"> </a>Prototype 
</h4>
<pre class="proto"><a name="1022063"></a>Err SrmReceiveWindowOpen (
   UInt16 portId,
   UInt8 **bufPP,
   UInt32 *sizeP
)
</pre>
<h4>
  <a name="1022064"> </a>Parameters 
</h4>

<dl>
<dt><a name="1022065"> </a><code>&rarr;  <i><code>portId</code></i></code></dt>
<dd><a name="1022072"> </a>Port ID returned from <a href="SerialManager.html#1021606"><code>SrmOpen()</code></a> or <a href="SerialManager.html#1021346"><code>SrmExtOpen()</code></a>.</dd>

<dt><a name="1022073"> </a><code>&larr;  <i><code>bufPP</code></i></code></dt>
<dd><a name="1022074"> </a>Pointer to a pointer to the receive buffer.</dd>

<dt><a name="1022075"> </a><code>&larr;  <i><code>sizeP</code></i></code></dt>
<dd><a name="1022076"> </a>Available bytes in buffer.</dd>

</dl>
<h4>
  <a name="1022077"> </a>Returns 
</h4>

<p><a name="1022078"> </a>This function returns the following error codes:</p>

<dl>
<dt><a name="1022079"> </a><code><code>errNone</code> </code></dt>
<dd><a name="1022080"> </a>No error.</dd>

<dt><a name="1022081"> </a><code><code>serErrBadPort</code></code></dt>
<dd><a name="1022082"> </a>This port doesn't exist.</dd>

<dt><a name="1022083"> </a><code><code>serErrNotOpen</code></code></dt>
<dd><a name="1022084"> </a>The port is not open. </dd>

<dt><a name="1022085"> </a><code><code>serErrNotSupported</code></code></dt>
<dd><a name="1022086"> </a>The port is not the foreground port. </dd>

<dt><a name="1022087"> </a><code><code>serErrLineErr</code></code></dt>
<dd><a name="1022088"> </a>The data in the queue contains line errors.</dd>

<dt><a name="1022089"> </a><code><code>serErrNoDevicesAvail</code></code></dt>
<dd><a name="1022090"> </a>No serial devices could be found. </dd>

</dl>
<h4>
  <a name="1022091"> </a>Comments 
</h4>

<p><a name="1022092"> </a>This function lets applications directly access the Serial Manager's receive queue to eliminate buffer copying by the Serial Manager. This access is a "back door" route to the received data. After retrieving data from the buffer, the application must call <a href="SerialManager.html#1022011"><code>SrmReceiveWindowClose()</code></a>.</p>

<p><a name="1022096"> </a>Applications that want to empty the receive buffer entirely should call the <code>SrmReceiveWindowOpen</code> and <code>SrmReceiveWindowClose</code> functions repeatedly until the buffer size returned is 0.</p>

<div><hr>
  <a name="1022097"> </a> <b>IMPORTANT: </b> Once an application calls <code>SrmReceiveWindowOpen</code>, it should not attempt to receive data via the normal method of calling <a href="SerialManager.html#1021762"><code>SrmReceive()</code></a> or <a href="SerialManager.html#1021935"><code>SrmReceiveWait()</code></a>, as these functions interfere with direct access to the receive queue.
<hr>
</div>
<h4>
  <a name="1022106"> </a>Compatibility 
</h4>

<p><a name="1022110"> </a>Implemented only if <a href="CompatibilityApdx.html#994402">New Serial Manager Feature Set Version 1</a> is present.</p>
<h4>
  <a name="1022111"> </a>See Also 
</h4>

<p><a name="1022115"> </a><a href="SerialManager.html#1022011"><code>SrmReceiveWindowClose()</code></a></p>

<h3 class="hbH3">
  <a name="1022118"> </a>SrmSend Function <a href="#1020300"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="1022120"> </a>Purpose 
</h4>

<p><a name="1022121"> </a>Sends a block of data out the specified port.</p>
<h4>
  <a name="1022122"> </a>Declared In 
</h4>
<code>SerialMgr.h<a name="1022123"> </a></code><h4>
  <a name="1022124"> </a>Prototype 
</h4>
<pre class="proto"><a name="1022125"></a>UInt32 SrmSend (
   UInt16 portId,
   const void *bufP,
   UInt32 count,
   Err *errP
)
</pre>
<h4>
  <a name="1022126"> </a>Parameters 
</h4>

<dl>
<dt><a name="1022127"> </a><code>&rarr;  <i><code>portID</code></i></code></dt>
<dd><a name="1022134"> </a>Port ID returned from <a href="SerialManager.html#1021606"><code>SrmOpen()</code></a> or <a href="SerialManager.html#1021346"><code>SrmExtOpen()</code></a>.</dd>

<dt><a name="1022135"> </a><code>&rarr;  <i><code>bufp</code></i></code></dt>
<dd><a name="1022136"> </a>Pointer to data to send.</dd>

<dt><a name="1022137"> </a><code>&rarr;  <i><code>count</code></i></code></dt>
<dd><a name="1022138"> </a>Length of data buffer, in bytes.</dd>

<dt><a name="1022139"> </a><code>&larr;  <i><code>errP</code></i></code></dt>
<dd><a name="1022140"> </a>Error code. See the Comments section for details.</dd>

</dl>
<h4>
  <a name="1022141"> </a>Returns 
</h4>

<p><a name="1022142"> </a>Number of bytes of data actually sent.</p>
<h4>
  <a name="1022143"> </a>Comments 
</h4>

<p><a name="1022144"> </a>When <code>SrmSend</code> returns, you should check the value returned in the <code>errP</code> parameter. If <code>errNone</code>, then the entire data buffer was sent. If not <code>errNone</code>, then the result equals the number of bytes sent before the error occurred. The possible error values are: </p>

<dl>
<dt><a name="1022146"> </a><code><code>errNone </code></code></dt>
<dd><a name="1022147"> </a>No error.</dd>

<dt><a name="1022149"> </a><code><code>serErrBadPort</code></code></dt>
<dd><a name="1022150"> </a>This port doesn't exist.</dd>

<dt><a name="1022152"> </a><code><code>serErrNotOpen</code></code></dt>
<dd><a name="1022153"> </a>The port is not open. </dd>

<dt><a name="1022155"> </a><code><code>serErrTimeOut</code></code></dt>
<dd><a name="1022156"> </a>Unable to send data within the specified CTS timeout period.</dd>

<dt><a name="1022157"> </a><code><code>serErrNoDevicesAvail</code></code></dt>
<dd><a name="1022158"> </a>No serial devices could be found. </dd>

<dt><a name="1022160"> </a><code><code>serErrConfigurationFailed</code> </code></dt>
<dd><a name="1022161"> </a>The port configuration has failed. </dd>

<dt><a name="1022163"> </a><code><code>serErrNotSupported</code> </code></dt>
<dd><a name="1022164"> </a>The specified port is not the foreground port. </dd>

</dl>
<h4>
  <a name="1022165"> </a>Compatibility 
</h4>

<p><a name="1022169"> </a>Implemented only if <a href="CompatibilityApdx.html#994402">New Serial Manager Feature Set Version 1</a> is present.</p>
<h4>
  <a name="1022170"> </a>See Also 
</h4>

<p><a name="1022180"> </a><a href="SerialManager.html#1022183"><code>SrmSendCheck()</code></a>, <a href="SerialManager.html#1022235"><code>SrmSendFlush()</code></a>, <a href="SerialManager.html#1022284"><code>SrmSendWait()</code></a></p>

<h3 class="hbH3">
  <a name="1022183"> </a>SrmSendCheck Function <a href="#1020300"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="1022185"> </a>Purpose 
</h4>

<p><a name="1022186"> </a>Checks the transmit FIFO and returns the number of bytes left to be sent. </p>
<h4>
  <a name="1022187"> </a>Declared In 
</h4>
<code>SerialMgr.h<a name="1022188"> </a></code><h4>
  <a name="1022189"> </a>Prototype 
</h4>
<pre class="proto"><a name="1022190"></a>Err SrmSendCheck (
   UInt16 portId,
   UInt32 *numBytesP
)
</pre>
<h4>
  <a name="1022191"> </a>Parameters 
</h4>

<dl>
<dt><a name="1022192"> </a><code>&rarr;  <i><code>portID</code></i></code></dt>
<dd><a name="1022199"> </a>Port ID returned from <a href="SerialManager.html#1021606"><code>SrmOpen()</code></a> or <a href="SerialManager.html#1021346"><code>SrmExtOpen()</code></a>.</dd>

<dt><a name="1022200"> </a><code>&larr;  <i><code>numBytesP</code></i></code></dt>
<dd><a name="1022201"> </a>Number of bytes left in the FIFO queue.</dd>

</dl>
<h4>
  <a name="1022202"> </a>Returns 
</h4>

<p><a name="1022203"> </a>This function returns the following error codes:</p>

<dl>
<dt><a name="1022204"> </a><code><code>errNone</code></code></dt>
<dd><a name="1022205"> </a>No error.</dd>

<dt><a name="1022206"> </a><code><code>serErrBadPort</code></code></dt>
<dd><a name="1022207"> </a>This port doesn't exist.</dd>

<dt><a name="1022209"> </a><code><code>serErrNotOpen</code></code></dt>
<dd><a name="1022210"> </a>The port is not open. </dd>

<dt><a name="1022211"> </a><code><code>serErrNotSupported</code></code></dt>
<dd><a name="1022212"> </a>This feature not supported by the hardware.</dd>

<dt><a name="1022213"> </a><code><code>serErrNoDevicesAvail</code></code></dt>
<dd><a name="1022214"> </a>No serial devices could be found. </dd>

</dl>
<h4>
  <a name="1022215"> </a>Comments 
</h4>

<p><a name="1022216"> </a>Not all serial devices support this feature.</p>
<h4>
  <a name="1022217"> </a>Compatibility 
</h4>

<p><a name="1022221"> </a>Implemented only if <a href="CompatibilityApdx.html#994402">New Serial Manager Feature Set Version 1</a> is present.</p>
<h4>
  <a name="1022222"> </a>See Also 
</h4>

<p><a name="1022232"> </a><a href="SerialManager.html#1022118"><code>SrmSend()</code></a>, <a href="SerialManager.html#1022235"><code>SrmSendFlush()</code></a>, <a href="SerialManager.html#1022284"><code>SrmSendWait()</code></a></p>

<h3 class="hbH3">
  <a name="1022235"> </a>SrmSendFlush Function <a href="#1020300"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="1022237"> </a>Purpose 
</h4>

<p><a name="1022238"> </a>Flushes the transmit FIFO.</p>
<h4>
  <a name="1022239"> </a>Declared In 
</h4>
<code>SerialMgr.h<a name="1022240"> </a></code><h4>
  <a name="1022241"> </a>Prototype 
</h4>
<pre class="proto"><a name="1022242"></a>Err SrmSendFlush (
   UInt16 portId
)
</pre>
<h4>
  <a name="1022243"> </a>Parameters 
</h4>

<dl>
<dt><a name="1022244"> </a><code>&rarr;  <i><code>portID</code></i></code></dt>
<dd><a name="1022251"> </a>Port ID returned from <a href="SerialManager.html#1021606"><code>SrmOpen()</code></a> or <a href="SerialManager.html#1021346"><code>SrmExtOpen()</code></a>.</dd>

</dl>
<h4>
  <a name="1022252"> </a>Returns 
</h4>

<p><a name="1022253"> </a>This function returns the following error codes:</p>

<dl>
<dt><a name="1022254"> </a><code><code>errNone</code></code></dt>
<dd><a name="1022255"> </a>No error.</dd>

<dt><a name="1022256"> </a><code><code>serErrBadPort</code></code></dt>
<dd><a name="1022257"> </a>This port doesn't exist.</dd>

<dt><a name="1022259"> </a><code><code>serErrNotOpen</code></code></dt>
<dd><a name="1022260"> </a>The port is not open. </dd>

<dt><a name="1022262"> </a><code><code>serErrNotSupported</code></code></dt>
<dd><a name="1022263"> </a>The port is not the foreground port. </dd>

<dt><a name="1022264"> </a><code><code>serErrNoDevicesAvail</code></code></dt>
<dd><a name="1022265"> </a>No serial devices could be found. </dd>

</dl>
<h4>
  <a name="1022266"> </a>Compatibility 
</h4>

<p><a name="1022270"> </a>Implemented only if <a href="CompatibilityApdx.html#994402">New Serial Manager Feature Set Version 1</a> is present.</p>
<h4>
  <a name="1022271"> </a>See Also 
</h4>

<p><a name="1022281"> </a><a href="SerialManager.html#1022118"><code>SrmSend()</code></a>, <a href="SerialManager.html#1022183"><code>SrmSendCheck()</code></a>, <a href="SerialManager.html#1022284"><code>SrmSendWait()</code></a></p>

<h3 class="hbH3">
  <a name="1022284"> </a>SrmSendWait Function <a href="#1020300"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="1022286"> </a>Purpose 
</h4>

<p><a name="1022287"> </a>Waits until all previous data has been sent from the transmit FIFO, then returns.</p>
<h4>
  <a name="1022288"> </a>Declared In 
</h4>
<code>SerialMgr.h<a name="1022289"> </a></code><h4>
  <a name="1022290"> </a>Prototype 
</h4>
<pre class="proto"><a name="1022291"></a>Err SrmSendWait (
   UInt16 portId
)
</pre>
<h4>
  <a name="1022292"> </a>Parameters 
</h4>

<dl>
<dt><a name="1022293"> </a><code>&rarr;  <i><code>portID</code></i></code></dt>
<dd><a name="1022300"> </a>Port ID returned from <a href="SerialManager.html#1021606"><code>SrmOpen()</code></a> or <a href="SerialManager.html#1021346"><code>SrmExtOpen()</code></a>.</dd>

</dl>
<h4>
  <a name="1022301"> </a>Returns 
</h4>

<p><a name="1022302"> </a>This function returns the following error codes:</p>

<dl>
<dt><a name="1022303"> </a><code><code>errNone</code> </code></dt>
<dd><a name="1022304"> </a>No error.</dd>

<dt><a name="1022305"> </a><code><code>serErrBadPort</code></code></dt>
<dd><a name="1022306"> </a>This port doesn't exist.</dd>

<dt><a name="1022308"> </a><code><code>serErrNotOpen</code></code></dt>
<dd><a name="1022309"> </a>The port is not open. </dd>

<dt><a name="1022310"> </a><code><code>serErrTimeOut</code></code></dt>
<dd><a name="1022311"> </a>Unable to send data within the CTS timeout period.</dd>

<dt><a name="1022313"> </a><code><code>serErrNotSupported</code></code></dt>
<dd><a name="1022314"> </a>The port is not the foreground port. </dd>

<dt><a name="1022315"> </a><code><code>serErrNoDevicesAvail</code></code></dt>
<dd><a name="1022316"> </a>No serial devices could be found. </dd>

</dl>
<h4>
  <a name="1022317"> </a>Comments 
</h4>

<p><a name="1022318"> </a>Consider calling this function if your software needs to detect when all data has been transmitted by <a href="SerialManager.html#1022118"><code>SrmSend()</code></a>. The <code>SrmSend</code> function blocks until all data has been transmitted or a timeout occurs. A subsequent call to <code>SrmSendWait</code> blocks until all data queued up for transmission has been transmitted or until another CTS timeout occurs (if CTS handshaking is enabled). </p>
<h4>
  <a name="1022323"> </a>Compatibility 
</h4>

<p><a name="1022327"> </a>Implemented only if <a href="CompatibilityApdx.html#994402">New Serial Manager Feature Set Version 1</a> is present.</p>
<h4>
  <a name="1022328"> </a>See Also 
</h4>

<p><a name="1022338"> </a><a href="SerialManager.html#1022118"><code>SrmSend()</code></a>, <a href="SerialManager.html#1022183"><code>SrmSendCheck()</code></a>, <a href="SerialManager.html#1022235"><code>SrmSendFlush()</code></a></p>

<h3 class="hbH3">
  <a name="1022341"> </a>SrmSetReceiveBuffer Function <a href="#1020300"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="1022343"> </a>Purpose 
</h4>

<p><a name="1022344"> </a>Installs a new buffer into the Serial Manager's receive queue.</p>
<h4>
  <a name="1022345"> </a>Declared In 
</h4>
<code>SerialMgr.h<a name="1022346"> </a></code><h4>
  <a name="1022347"> </a>Prototype 
</h4>
<pre class="proto"><a name="1022348"></a>Err SrmSetReceiveBuffer (
   UInt16 portId,
   void *bufP,
   UInt16 bufSize
)
</pre>
<h4>
  <a name="1022349"> </a>Parameters 
</h4>

<dl>
<dt><a name="1022350"> </a><code>&rarr;  <i><code>portID</code></i></code></dt>
<dd><a name="1022357"> </a>Port ID returned from <a href="SerialManager.html#1021606"><code>SrmOpen()</code></a> or <a href="SerialManager.html#1021346"><code>SrmExtOpen()</code></a>.</dd>

<dt><a name="1022358"> </a><code>&rarr;  <i><code>bufP</code></i></code></dt>
<dd><a name="1022359"> </a>Pointer to new receive buffer. Ignored if <code>bufSize</code> is <code>NULL</code>.</dd>

<dt><a name="1022360"> </a><code>&rarr;  <i><code>bufSize</code></i></code></dt>
<dd><a name="1022361"> </a>Size of new receive buffer in bytes. To remove this buffer and allocate a new default buffer (512 bytes), specify <code>NULL</code>.</dd>

</dl>
<h4>
  <a name="1022362"> </a>Returns 
</h4>

<p><a name="1022363"> </a>This function returns the following error codes:</p>

<dl>
<dt><a name="1022364"> </a><code><code>errNone</code> </code></dt>
<dd><a name="1022365"> </a>No error.</dd>

<dt><a name="1022366"> </a><code><code>serErrBadPort</code></code></dt>
<dd><a name="1022367"> </a>This port doesn't exist.</dd>

<dt><a name="1022368"> </a><code><code>serErrNotOpen</code></code></dt>
<dd><a name="1022369"> </a>This port is not open.</dd>

<dt><a name="1022370"> </a><code><code>memErrNotEnoughSpace</code></code></dt>
<dd><a name="1022371"> </a>Not enough memory to allocate default buffer.</dd>

<dt><a name="1022372"> </a><code><code>serErrNoDevicesAvail</code></code></dt>
<dd><a name="1022373"> </a>No serial devices could be found. </dd>

</dl>


<h4>
  <a name="1022375"> </a>Comments 
</h4>

<p><a name="1022376"> </a>The buffer that you pass to this function must remain allocated while you have the serial port open. Before you close the serial port, you must restore the default queue by calling <code>SrmSetReceiveBuffer</code> with <code>NULL</code> as the <code>bufP</code> and <code>bufSize</code> arguments. </p>

<div><hr>
  <a name="1022377"> </a> <b>IMPORTANT: </b> Applications must install the default buffer before closing the port (or disposing of the new receive queue).
<hr>
</div>
<h4>
  <a name="1022378"> </a>Compatibility 
</h4>

<p><a name="1022382"> </a>Implemented only if <a href="CompatibilityApdx.html#994402">New Serial Manager Feature Set Version 1</a> is present.</p>

<h3 class="hbH3">
  <a name="1022385"> </a>SrmSetWakeupHandler Function <a href="#1020300"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="1022387"> </a>Purpose 
</h4>

<p><a name="1022388"> </a>Installs a wakeup handler.</p>
<h4>
  <a name="1022389"> </a>Declared In 
</h4>
<code>SerialMgr.h<a name="1022390"> </a></code><h4>
  <a name="1022391"> </a>Prototype 
</h4>
<pre class="proto"><a name="1022392"></a>Err SrmSetWakeupHandler (
   UInt16 portId,
   WakeupHandlerProcPtr procP,
   UInt32 refCon
)
</pre>
<h4>
  <a name="1022393"> </a>Parameters 
</h4>

<dl>
<dt><a name="1022394"> </a><code>&rarr;  <i><code>portID</code></i></code></dt>
<dd><a name="1022401"> </a>Port ID returned from <a href="SerialManager.html#1021606"><code>SrmOpen()</code></a> or <a href="SerialManager.html#1021346"><code>SrmExtOpen()</code></a>.</dd>

<dt><a name="1022402"> </a><code>&rarr;  <i><code>procP</code></i></code></dt>
<dd><a name="1022407"> </a>Pointer to a <a href="SerialManager.html#1022445"><code>WakeupHandlerProcPtr()</code></a> function. Specify <code>NULL</code> to remove a handler.</dd>

<dt><a name="1022408"> </a><code>&rarr;  <i><code>refCon</code></i></code></dt>
<dd><a name="1022409"> </a>User-defined data that is passed to the wakeup handler function. This can be a pointer or not.</dd>

</dl>
<h4>
  <a name="1022410"> </a>Returns 
</h4>

<p><a name="1022411"> </a>This function returns the following error codes:</p>

<dl>
<dt><a name="1022412"> </a><code><code>errNone</code></code></dt>
<dd><a name="1022413"> </a>No error.</dd>

<dt><a name="1022414"> </a><code><code>serErrBadPort</code></code></dt>
<dd><a name="1022415"> </a>This port doesn't exist.</dd>

<dt><a name="1022416"> </a><code><code>serErrNotOpen</code></code></dt>
<dd><a name="1022417"> </a>The port is not open. </dd>

<dt><a name="1022418"> </a><code><code>serErrNoDevicesAvail</code></code></dt>
<dd><a name="1022419"> </a>No serial devices could be found. </dd>

</dl>
<h4>
  <a name="1022420"> </a>Comments 
</h4>

<p><a name="1022421"> </a>The wakeup handler is a function in your application that you want to be called whenever there is data ready to be received on the specified port. </p>

<p><a name="1022422"> </a>The wakeup handler function will not become active until it is primed with a number of bytes that is greater than 0, by the <a href="SerialManager.html#1021712"><code>SrmPrimeWakeupHandler()</code></a> function. Every time a wakeup handler is called, it must be re-primed (using <code>SrmPrimeWakeupHandler</code>) in order to be called again.</p>
<h4>
  <a name="1022427"> </a>Compatibility 
</h4>

<p><a name="1022431"> </a>Implemented only if <a href="CompatibilityApdx.html#994402">New Serial Manager Feature Set Version 1</a> is present.</p>
<h4>
  <a name="1022432"> </a>See Also 
</h4>

<p><a name="1022439"> </a><a href="SerialManager.html#1021712"><code>SrmPrimeWakeupHandler()</code></a>, <a href="SerialManager.html#1022445"><code>WakeupHandlerProcPtr()</code></a></p>

<h2 class="haH2">
  <a name="1022441"> </a>Serial Manager Application-Defined Functions <a href="#1020300"><span class="nav">^TOP^</span></a>
</h2>


<h3 class="hbH3">
  <a name="1022445"> </a>WakeupHandlerProcPtr Function <a href="#1020300"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="1022447"> </a>Purpose 
</h4>

<p><a name="1022448"> </a>Called after some number of bytes are received by the Serial Manager's interrupt function.</p>
<h4>
  <a name="1022449"> </a>Declared In 
</h4>
<code>SerialMgr.h<a name="1022450"> </a></code><h4>
  <a name="1022451"> </a>Prototype 
</h4>
<pre class="proto"><a name="1022452"></a>void (
   *WakeupHandlerProcPtr
)(
   UInt32 refCon
)
</pre>
<h4>
  <a name="1022453"> </a>Parameters 
</h4>

<dl>
<dt><a name="1022454"> </a><code>&rarr;  <i><code>refCon</code></i></code></dt>
<dd><a name="1022455"> </a>User-defined data passed from the <a href="SerialManager.html#1022385"><code>SrmSetWakeupHandler()</code></a> function.</dd>

</dl>
<h4>
  <a name="1022459"> </a>Returns 
</h4>

<p><a name="1022460"> </a>Returns nothing.</p>
<h4>
  <a name="1022461"> </a>Comments 
</h4>

<p><a name="1022462"> </a>This handler function is installed by calling <a href="SerialManager.html#1022385"><code>SrmSetWakeupHandler()</code></a>. The number of bytes after which it is called is specified by <a href="SerialManager.html#1021712"><code>SrmPrimeWakeupHandler()</code></a>.</p>

<div><hr>
  <a name="1022471"> </a> <b>IMPORTANT: </b> Because wakeup handlers are called during interrupt time, they cannot call <i>any</i> Palm OS<sup>&#174;</sup> system functions, including <a href="SerialManager.html#1021762"><code>SrmReceive()</code></a>, that may block the system in any way. Wakeup handlers should also be very short so as to reduce interrupt latency.
<hr>
</div>

<p><a name="1022476"> </a>Two common implementations of wakeup handlers include: </p>
<ul type="disc">
  <li><a name="1022481"> </a>Calling <a href="SystemEventManager.html#1071503"><code>EvtWakeup()</code></a>, which causes any pending <code>EvtGetEvent</code> call to return and then sends a <code>nilEvent</code> to the current application. 
  <li><a name="1022486"> </a>Using <a href="SerialManager.html#1029031"><code>SrmReceiveWindowOpen()</code></a> and <a href="SerialManager.html#1022011"><code>SrmReceiveWindowClose()</code></a> to gain direct access to the receive queue without blocking. 
</ul>
<h4>
  <a name="1022491"> </a>Compatibility 
</h4>

<p><a name="1022495"> </a>Implemented only if <a href="CompatibilityApdx.html#994402">New Serial Manager Feature Set Version 1</a> is present.</p>
<h4>
  <a name="1022496"> </a>See Also 
</h4>

<p><a name="1022503"> </a><a href="SerialManager.html#1021712"><code>SrmPrimeWakeupHandler()</code></a>, <a href="SerialManager.html#1022385"><code>SrmSetWakeupHandler()</code></a></p>

<p><a name="1004876"> </a></p>
&nbsp;<br>
</div>
<!--END CONTENT-->

</td>
<td width="5">&nbsp;&nbsp;</td>
</tr>

</table>

<!-- BEGIN FOOTER -->
<table width="100%" border="0" cellspacing="0" cellpadding="0">
<tr>
<td width="7" rowspan="2"><img name="index_x" src="images/shim.gif" width="7" height="33" border="0" alt=""></td>
<td align="left"><img name="dashes" src="images/dashes.gif" width="744" height="3" border="0" alt=""></td>
<td width="10" rowspan="2"><img name="index_x" src="images/shim.gif" width="10" height="33" border="0" alt=""></td>
</tr>
<tr>
<td align="center">
<p class="footer">
Copyright © 1996-2004, PalmSource, Inc. and its affiliates.  All rights reserved. <br>
<a href="http://www.palmsource.com/contact/">Write Us</a> | <a href="http://www.palmos.com/dev/training/">Training</a> | <a href="http://www.palmos.com/dev/support/kb/">Knowledge Base</a> | <a href="Reference_Front.html" target="_blank">Legal</a></p>
<br>
<!--BEGIN BOOK NAVIGATION-->
<p class="nav">
<A href="http://www.palmos.com/dev/support/docs/">Documentation</a>&nbsp;&nbsp;|&nbsp;&nbsp;
<a href="ReferenceTOC.html">Table of Contents</a>&nbsp;&nbsp;
             |&nbsp;&nbsp;<a href="SerialDriver.html">&lt;&nbsp;Previous</a>&nbsp;&nbsp;
             |&nbsp;&nbsp;<a href="OldSerialManager.html">Next&nbsp;&gt;</a>&nbsp;&nbsp;
             |&nbsp;&nbsp;<a href="ReferenceIX.html">Index</a>
</p>
</td>
</tr>
</table>
<!-- END FOOTER -->

</body>
</html>