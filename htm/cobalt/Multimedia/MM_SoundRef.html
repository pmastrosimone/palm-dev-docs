<html>
<head>
<title>(Protein) Sound Manager Reference | Multimedia</title> 
<link href="psi_devpubs.css" rel="stylesheet" type="text/css">

<!-- BEGIN META DATA -->
<meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
<META NAME="PSITEMPLATE" CONTENT="1006-007 PalmSource_HTML_2003 20041101">
<META NAME="GENERATOR" CONTENT="Quadralay WebWorks AutoMap 2003 for FrameMaker 8.0.6.2138">
<META NAME="LASTUPDATED" CONTENT="11/22/04 11:16:56">
<!-- END META DATA -->
</head>

<body bgcolor="#ffffff" text="#000000" leftmargin="0" topmargin="0" marginwidth="0" marginheight="0">
<a name="995984"></a>

<!-- BEGIN TOPNAV -->
<table width="100%" border="0" cellspacing="0" cellpadding="0">
<tr>
<td><img src="images/shim.gif" width="7" height="75" border="0" alt=""></td>
<td align="left"><table border="0" cellpadding="0" cellspacing="0" width="744">
<tr>
<td><img name="index_r2_c1" src="images/shim.gif" width="25" height="75" border="0" alt=""></td>
<td valign="top"><table border="0" cellpadding="0" cellspacing="0" width="96">
<tr>
<td><img name="index_r2_c4" src="images/shim.gif" width="96" height="15" border="0" alt=""></td>
</tr>
<tr>
<td><a href="http://www.palmsource.com/"><img name="ps_logo" src="images/ps_logo.gif" width="96" height="54" border="0" alt=""></a></td>
</tr>

</table>
</td>

<td><table border="0" cellpadding="0" cellspacing="0" width="30">
<td><img name="index_x" src="images/shim.gif" width="30" height="75" border="0" alt=""></td>
</table></td>

<!--BEGIN MASTHEAD-->
<td><table border="0" cellpadding="0" cellspacing="0" width="96">
<tr>
<td><img name="index_x" src="images/shim.gif" width="615" height="5" border="0" alt=""></td>
</tr>
<tr>
<td>
<!--BEGIN BOOK NAVIGATION-->
<span class="nav">
<A href="http://www.palmos.com/dev/support/docs/">Documentation</a>&nbsp;&nbsp;|&nbsp;&nbsp;
<a href="MM_TOC.html">Table of Contents</a>&nbsp;&nbsp;
             |&nbsp;&nbsp;<a href="MM_SoundConcept.html">&lt;&nbsp;Previous</a>&nbsp;&nbsp;
             |&nbsp;&nbsp;<a href="MM_MultimediaPart.html">Next&nbsp;&gt;</a>&nbsp;&nbsp;
             |&nbsp;&nbsp;<a href="MM_IX.html">Index</a>
</span>
<!--END BOOK NAVIGATION-->
</tr>
<tr>
<td>
<!--BEGIN PAGE TITLE-->
<h2 class="PageTitle">2 &nbsp;&nbsp;
Sound Manager Reference</h2></td>
<!--END PAGE TITLE-->
</tr>
<tr>
<td>
<!--BEGIN BOOK TITLE-->
<p class="BookTitle">Multimedia</p>
<p class="SubTitle">Exploring Palm OS&#174; </p>
<!--END BOOK TITLE-->
</td>
</tr>
<tr>
<td><img name="index_x" src="images/shim.gif" width="615" height="5" border="0" alt=""></td>
</tr>
</table>
</td>
<!--END MASTHEAD-->
</tr>
</table>
<img name="dashes" src="images/dashes.gif" width="744" height="3" border="0" alt=""></td>
</tr>
</table>
<!-- END TOPNAV -->

<table width="100%" border="0" cellspacing="0" cellpadding="0">
<tr>
<td valign="top" width="5"><img name="index_x" src="images/shim.gif" width="5" height="33" border="0" alt=""></td>

<!--BEGIN SIDETOC-->
<td valign="top" width="175">
<div id="sidetoc" valign="bottom">
<h1 class="SideTOC1-PartTab"><a href="MM_SoundPart.html">Part I: Sound Manager</a> </h1>
<h1 class="SideTOC1"><a href="MM_SoundRef.html">2  Sound Manager Reference</a></h1>

   <h2 class="SideTOC2"><a href="#995992">
   Sound Manager Structures and Types</a></h2>

      <h3 class="SideTOC3"><a href="#996061">
      SndCallbackInfoType</a></h3>

      <h3 class="SideTOC3"><a href="#996269">
      SndCommandType</a></h3>

      <h3 class="SideTOC3"><a href="#996507">
      SndMidiListItemType</a></h3>

      <h3 class="SideTOC3"><a href="#996617">
      SndMidiRecHdrType</a></h3>

      <h3 class="SideTOC3"><a href="#996718">
      SndPtr</a></h3>

      <h3 class="SideTOC3"><a href="#996773">
      SndSampleType</a></h3>

      <h3 class="SideTOC3"><a href="#996835">
      SndSmfCallbacksType</a></h3>

      <h3 class="SideTOC3"><a href="#996926">
      SndSmfChanRangeType</a></h3>

      <h3 class="SideTOC3"><a href="#997069">
      SndSmfOptionsType</a></h3>

      <h3 class="SideTOC3"><a href="#997269">
      SndStreamRef</a></h3>

   <h2 class="SideTOC2"><a href="#997434">
   Sound Manager Constants</a></h2>

      <h3 class="SideTOC3"><a href="#1039255">
      audio_type_t</a></h3>

      <h3 class="SideTOC3"><a href="#1013433">
      Simple Sound Amplitudes</a></h3>

      <h3 class="SideTOC3"><a href="#1022177">
      SndCmdIDType</a></h3>

      <h3 class="SideTOC3"><a href="#1046668">
      SndFormatType</a></h3>

      <h3 class="SideTOC3"><a href="#1013828">
      sndMidiNameLength</a></h3>

      <h3 class="SideTOC3"><a href="#1037339">
      sndMidiRecHdrSize</a></h3>

      <h3 class="SideTOC3"><a href="#1007485">
      sndMidiRecSignature</a></h3>

      <h3 class="SideTOC3"><a href="#1037226">
      sndSmfPlayAllMilliSec</a></h3>

      <h3 class="SideTOC3"><a href="#998045">
      SndSmfCmdEnum</a></h3>

      <h3 class="SideTOC3"><a href="#998115">
      SndStreamMode</a></h3>

      <h3 class="SideTOC3"><a href="#998185">
      SndStreamWidth</a></h3>

      <h3 class="SideTOC3"><a href="#998376">
      SndSysBeepType</a></h3>

      <h3 class="SideTOC3"><a href="#1020323">
      Sound Error Codes</a></h3>

      <h3 class="SideTOC3"><a href="#1016556">
      Sound Resource Playback Flags</a></h3>

      <h3 class="SideTOC3"><a href="#1015300">
      Sound Stream Feature Constants</a></h3>

      <h3 class="SideTOC3"><a href="#1016875">
      Stereo Pan Constants</a></h3>

      <h3 class="SideTOC3"><a href="#998633">
      Volume Constants</a></h3>

   <h2 class="SideTOC2"><a href="#998713">
   Sound Manager Functions and Macros</a></h2>

      <h3 class="SideTOC3"><a href="#998724">
      SndCreateMidiList</a></h3>

      <h3 class="SideTOC3"><a href="#999053">
      SndDoCmd</a></h3>

      <h3 class="SideTOC3"><a href="#999253">
      SndGetDefaultVolume</a></h3>

      <h3 class="SideTOC3"><a href="#999373">
      SndPlayResource</a></h3>

      <h3 class="SideTOC3"><a href="#999486">
      SndPlaySmf</a></h3>

      <h3 class="SideTOC3"><a href="#999905">
      SndPlaySmfResource</a></h3>

      <h3 class="SideTOC3"><a href="#1000052">
      SndPlaySystemSound</a></h3>

      <h3 class="SideTOC3"><a href="#1000145">
      SndSetDefaultVolume</a></h3>

      <h3 class="SideTOC3"><a href="#1000481">
      SndStreamCreate</a></h3>

      <h3 class="SideTOC3"><a href="#1000651">
      SndStreamCreateExtended</a></h3>

      <h3 class="SideTOC3"><a href="#1000831">
      SndStreamDelete</a></h3>

      <h3 class="SideTOC3"><a href="#1034397">
      SndStreamGetPan</a></h3>

      <h3 class="SideTOC3"><a href="#1001203">
      SndStreamGetVolume</a></h3>

      <h3 class="SideTOC3"><a href="#1001330">
      SndStreamPause</a></h3>

      <h3 class="SideTOC3"><a href="#1001442">
      SndStreamSetPan</a></h3>

      <h3 class="SideTOC3"><a href="#1001569">
      SndStreamSetVolume</a></h3>

      <h3 class="SideTOC3"><a href="#1001672">
      SndStreamStart</a></h3>

      <h3 class="SideTOC3"><a href="#1002040">
      SndStreamStop</a></h3>

   <h2 class="SideTOC2"><a href="#1002133">
   Application-Defined Functions</a></h2>

      <h3 class="SideTOC3"><a href="#1002200">
      SndBlockingFuncType</a></h3>

      <h3 class="SideTOC3"><a href="#1002563">
      SndComplFuncType</a></h3>

      <h3 class="SideTOC3"><a href="#1002708">
      SndStreamBufferCallback</a></h3>

      <h3 class="SideTOC3"><a href="#1002839">
      SndStreamVariableBufferCallback</a></h3>

</div>
</td>

<td width="5">&nbsp;&nbsp;</td>
<td width="2" background="images/index_r8_c10.gif"><img src="images/shim.gif" width="2" height="75" border="0" alt=""></td>
<td width="5">&nbsp;&nbsp;</td>

<!--END SIDETOC-->

<td valign="top">

<!--BEGIN CONTENT-->
<div id="content" valign="bottom">
<p><a name="1003167"> </a>This chapter describes the Sound Manager API. It covers: </p>
   <blockquote class = "bq"><a name="996001"> </a><a href="MM_SoundRef.html#995992">Sound Manager Structures and Types</a></blockquote>
   <blockquote class = "bq"><a name="997455"> </a><a href="MM_SoundRef.html#997434">Sound Manager Constants</a></blockquote>
   <blockquote class = "bq"><a name="998722"> </a><a href="MM_SoundRef.html#998713">Sound Manager Functions and Macros</a></blockquote>
   <blockquote class = "bq"><a name="1002142"> </a><a href="MM_SoundRef.html#1002133">Application-Defined Functions</a></blockquote>

<p><a name="995988"> </a>The header files <code>SoundMgr.h</code> and <span style="color: #000000;  font-family: Courier; font-style: normal; font-weight: normal; text-decoration: none; text-transform: none; vertical-align: baseline">AudioTypes.h</span> declare the API that this chapter describes.</p>

<p><a name="995990"> </a>For more information on the Sound Manager, see <a href="MM_SoundConcept.html#995948">Chapter 1, "Sound Manager."</a></p>

<h2 class="haH2">
  <a name="995992"> </a>Sound Manager Structures and Types <a href="#995984"><span class="nav">^TOP^</span></a>
</h2>


<h3 class="hbH3">
  <a name="996061"> </a>SndCallbackInfoType Struct <a href="#995984"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="996072"> </a>Purpose 
</h4>

<p><a name="1003589"> </a>Encapsulates a callback function and its argument data. <code>SndCallbackInfoType</code> is used by the <a href="MM_SoundRef.html#996835"><code>SndSmfCallbacksType</code></a> structure, which is used to list the callback functions that are called during SMF playback.</p>
<h4>
  <a name="996083"> </a>Declared In 
</h4>
<code>SoundMgr.h<a name="996089"> </a></code><h4>
  <a name="996094"> </a>Prototype 
</h4>
<pre class="proto"><a name="996100"></a>typedef struct SndCallbackInfoType {
   MemPtr funcP;
   uint32_t dwUserData;
} SndCallbackInfoType
</pre>
<h4>
  <a name="996105"> </a>Fields 
</h4>

<dl>
<dt><a name="996111"> </a><code>funcP</code></dt>
<dd><a name="996116"> </a>A pointer to the callback function.</dd>

<dt><a name="996121"> </a><code>dwUserData</code></dt>
<dd><a name="996126"> </a>Data that's passed as an argument to the callback function.</dd>

</dl>

<h3 class="hbH3">
  <a name="996269"> </a>SndCommandType Struct <a href="#995984"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="996280"> </a>Purpose 
</h4>

<p><a name="1003978"> </a>Encapsulates a sound synthesis operation and its associated parameters. It is used by the <a href="MM_SoundRef.html#999053"><code>SndDoCmd()</code></a> function.</p>
<h4>
  <a name="996291"> </a>Declared In 
</h4>
<code>SoundMgr.h<a name="996297"> </a></code><h4>
  <a name="996302"> </a>Prototype 
</h4>
<pre class="proto"><a name="996308"></a>typedef struct SndCommandType {
   SndCmdIDType cmd;
   uint8_t reserved;
   uint16_t padding;
   int32_t param1;
   uint16_t param2;
   uint16_t param3;
} SndCommandType
</pre>
<pre class="proto"><a name="1003658"></a>typedef SndCommandType *SndCommandPtr
</pre>
<h4>
  <a name="996313"> </a>Fields 
</h4>

<dl>
<dt><a name="1003992"> </a><code><code>cmd</code></code></dt>
<dd><a name="1003993"> </a>Constant that represents a sound operation. The operations are listed and described in <a href="MM_SoundRef.html#999053"><code>SndDoCmd()</code></a>.</dd>

<dt><a name="1003997"> </a><code><code>reserved</code></code></dt>
<dd><a name="1003998"> </a>Reserved for future use.</dd>

<dt><a name="1004130"> </a><code>padding</code></dt>
<dd><a name="1004131"> </a>Padding bytes.</dd>

<dt><a name="1003999"> </a><code><code>param1</code>, <code>param2</code>, <code>param3</code></code></dt>
<dd><a name="1004000"> </a>Operation-specific parameters. The parameters' meanings are described in <a href="MM_SoundRef.html#999053"><code>SndDoCmd()</code></a>.</dd>

</dl>

<h3 class="hbH3">
  <a name="996507"> </a>SndMidiListItemType Struct <a href="#995984"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="996518"> </a>Purpose 
</h4>

<p><a name="1006696"> </a>Locates a MIDI file. This structure is used by the <a href="MM_SoundRef.html#998724"><code>SndCreateMidiList()</code></a> function.</p>
<h4>
  <a name="996529"> </a>Declared In 
</h4>
<code>SoundMgr.h<a name="996535"> </a></code><h4>
  <a name="996540"> </a>Prototype 
</h4>
<pre class="proto"><a name="996546"></a>typedef struct SndMidiListItemType {
   char name[sndMidiNameLength];
   uint32_t uniqueRecID;
   DatabaseID dbH;
} SndMidiListItemType
</pre>
<h4>
  <a name="996551"> </a>Fields 
</h4>

<dl>
<dt><a name="996557"> </a><code>name</code></dt>
<dd><a name="996562"> </a>The null-terminated name of the MIDI file.</dd>

<dt><a name="996574"> </a><code>uniqueRecID</code></dt>
<dd><a name="996591"> </a>The ID of the record that holds the MIDI file.</dd>

<dt><a name="996596"> </a><code>dbH</code></dt>
<dd><a name="996601"> </a>Database ID of the database that holds the record.</dd>

</dl>

<h3 class="hbH3">
  <a name="996617"> </a>SndMidiRecHdrType Struct <a href="#995984"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="996628"> </a>Purpose 
</h4>

<p><a name="1007227"> </a>Encapsulates the header of a MIDI record.</p>
<h4>
  <a name="996639"> </a>Declared In 
</h4>
<code>SoundMgr.h<a name="996645"> </a></code><h4>
  <a name="996650"> </a>Prototype 
</h4>
<pre class="proto"><a name="996656"></a>typedef struct SndMidiRecHdrType {
   uint32_t signature;
   uint8_t bDataOffset;
   uint8_t reserved;
   uint16_t padding;
} SndMidiRecHdrType
</pre>
<h4>
  <a name="996661"> </a>Fields 
</h4>

<dl>
<dt><a name="996667"> </a><code>signature</code></dt>
<dd><a name="1007263"> </a>The MIDI record signature. Always set this field to <a href="MM_SoundRef.html#1007485"><code>sndMidiRecSignature</code></a>.</dd>

<dt><a name="996677"> </a><code>bDataOffset</code></dt>
<dd><a name="996682"> </a>Offset, in bytes, from the beginning of the record to the first byte of the MIDI data.</dd>

<dt><a name="996687"> </a><code>reserved</code></dt>
<dd><a name="996692"> </a>Reserved for future use. Always set this field to 0.</dd>

<dt><a name="996697"> </a><code>padding</code></dt>
<dd><a name="996702"> </a>Padding bytes (not counted toward the record size).</dd>

</dl>

<h3 class="hbH3">
  <a name="996718"> </a>SndPtr Typedef <a href="#995984"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="996729"> </a>Purpose 
</h4>

<p><a name="1008002"> </a>Used to cast a pointer to the sound data used by <a href="MM_SoundRef.html#999373"><code>SndPlayResource()</code></a>.</p>
<h4>
  <a name="996740"> </a>Declared In 
</h4>
<code>SoundMgr.h<a name="996746"> </a></code><h4>
  <a name="996751"> </a>Prototype 
</h4>
<pre class="proto"><a name="996757"></a>typedef void *SndPtr
</pre>

<h3 class="hbH3">
  <a name="996773"> </a>SndSampleType Typedef <a href="#995984"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="996791"> </a>Purpose 
</h4>

<p><a name="1008864"> </a>Used to specify the sample format (size, data type, endianness) of a sampled sound stream. Used by <a href="MM_SoundRef.html#1000481"><code>SndStreamCreate()</code></a>. See <a href="MM_SoundRef.html#1039255">"audio_type_t"</a> for the set of values that this type can contain.</p>
<h4>
  <a name="1008871"> </a>Declared In 
</h4>
<code>SoundMgr.h<a name="996808"> </a></code><h4>
  <a name="996813"> </a>Prototype 
</h4>
<pre class="proto"><a name="996819"></a>typedef audio_type_t SndSampleType
</pre>

<h3 class="hbH3">
  <a name="996835"> </a>SndSmfCallbacksType Struct <a href="#995984"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="996846"> </a>Purpose 
</h4>

<p><a name="1009043"> </a>Contains a set of application-defined functions that are called during MIDI playback. To register your callback functions, call <a href="MM_SoundRef.html#999486"><code>SndPlaySmf()</code></a>.</p>
<h4>
  <a name="996857"> </a>Declared In 
</h4>
<code>SoundMgr.h<a name="996863"> </a></code><h4>
  <a name="996868"> </a>Prototype 
</h4>
<pre class="proto"><a name="996874"></a>typedef struct SndSmfCallbacksType {
   SndCallbackInfoType completion;
   SndCallbackInfoType blocking;
   SndCallbackInfoType reserved;
} SndSmfCallbacksType
</pre>
<h4>
  <a name="996879"> </a>Fields 
</h4>

<dl>
<dt><a name="996885"> </a><code>completion</code></dt>
<dd><a name="996890"> </a>Completion function; see <a href="MM_SoundRef.html#1002563"><code>SndComplFuncType()</code></a>.</dd>

<dt><a name="996895"> </a><code>blocking</code></dt>
<dd><a name="996900"> </a>Blocking function; see <a href="MM_SoundRef.html#1002200"><code>SndBlockingFuncType()</code></a>.</dd>

<dt><a name="996905"> </a><code>reserved</code></dt>
<dd><a name="996910"> </a>Reserved. Set this field to 0.</dd>

</dl>

<h3 class="hbH3">
  <a name="996926"> </a>SndSmfChanRangeType Struct <a href="#995984"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="996937"> </a>Purpose 
</h4>

<p><a name="1009360"> </a>Defines the range of enabled MIDI channels. Events on MIDI channels outside the enabled range are ignored. By default, no channels are enabled. </p>
<h4>
  <a name="996948"> </a>Declared In 
</h4>
<code>SoundMgr.h<a name="996954"> </a></code><h4>
  <a name="996959"> </a>Prototype 
</h4>
<pre class="proto"><a name="996965"></a>typedef struct SndSmfChanRangeType {
   uint8_t bFirstChan;
   uint8_t bLastChan;
} SndSmfChanRangeType
</pre>
<h4>
  <a name="996970"> </a>Fields 
</h4>

<dl>
<dt><a name="996976"> </a><code>bFirstChan</code></dt>
<dd><a name="996981"> </a>The first enabled channel in the range [0, 15].</dd>

<dt><a name="996993"> </a><code>bLastChan</code></dt>
<dd><a name="996998"> </a>The last enabled channel in the range [0, 15].</dd>

</dl>

<div><hr>
  <a name="1009446"> </a> <b>IMPORTANT: </b> The <code>SndSmfChanRangeType</code><span style="color: #000000;  font-family: Courier; font-style: normal; font-weight: normal; text-decoration: none; text-transform: none; vertical-align: baseline"> </span>structure expects MIDI channels to be in the range [0, 15]; real MIDI channel values are in the range [1, 16]. Thus, PalmSource MIDI channel 0 is real MIDI channel 1, PalmSource MIDI channel 1 is real MIDI channel 2, and so on.
<hr>
</div>

<h3 class="hbH3">
  <a name="997069"> </a>SndSmfOptionsType Struct <a href="#995984"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="997080"> </a>Purpose 
</h4>

<p><a name="1009664"> </a>Defines MIDI performance parameters. </p>
<h4>
  <a name="997091"> </a>Declared In 
</h4>
<code>SoundMgr.h<a name="997097"> </a></code><h4>
  <a name="997102"> </a>Prototype 
</h4>
<pre class="proto"><a name="997108"></a>typedef struct SndSmfOptionsType {
   uint32_t dwStartMilliSec;
   uint32_t dwEndMilliSec;
   uint16_t amplitude;
   Boolean interruptible;
   uint8_t reserved1;
   uint32_t reserved;
} SndSmfOptionsType
</pre>
<h4>
  <a name="997113"> </a>Fields 
</h4>

<dl>
<dt><a name="997119"> </a><code>dwStartMilliSec</code></dt>
<dd><a name="997124"> </a>The "beginning of performance" marker, measured in milliseconds from the beginning of the track. A value of 0 plays the track from the beginning. The time difference between <code>dwStartMilliSec</code> and the performance time of the first subsequent MIDI event is respected. For example, if <code>dwStartMilliSec</code> is 2000 and the first (subsequent) note-on event is at 3000, there will be a 1000 millisecond "pause" before the note is played.</dd>

<dt><a name="997129"> </a><code>dwEndMilliSec</code></dt>
<dd><a name="997134"> </a>The "end of performance" marker, measured in milliseconds from the beginning of the track. To play to the end of the track, set this to <a href="MM_SoundRef.html#1037226"><code>sndSmfPlayAllMilliSec</code></a>.</dd>

<dt><a name="997139"> </a><code>amplitude</code></dt>
<dd><a name="997144"> </a>The volume of the track, in the range [0, <code>sndMaxAmp</code>].<code> </code>The default is <code>sndMaxAmp</code>. If set to 0, the MIDI file isn't played.</dd>

<dt><a name="997149"> </a><code>interruptible</code></dt>
<dd><a name="997154"> </a>If <code>true</code> (the default), MIDI playback is interrupted if the user interacts with the controls (digitizer, buttons, etc.), even if the interaction doesn't generate a sound command. If <code>false</code>, playback is not interrupted.</dd>

<dt><a name="997159"> </a><code>reserved1</code></dt>
<dd><a name="997164"> </a>Reserved.</dd>

<dt><a name="997169"> </a><code>reserved</code></dt>
<dd><a name="997181"> </a>Reserved. Set this field to 0.</dd>

</dl>
<h4>
  <a name="997186"> </a>Comments 
</h4>

<p><a name="997195"> </a>This structure is used with the <a href="MM_SoundRef.html#999486"><code>SndPlaySmf()</code></a> function to establish new parameter settings or to return the currently set values, depending on how the function is called. In the case where the structure returns values, only the "performance marker" fields (<code>dwStartMilliSec</code> and <code>dwEndMilliSec</code>) are valid.</p>

<h3 class="hbH3">
  <a name="997269"> </a>SndStreamRef Typedef <a href="#995984"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="997280"> </a>Purpose 
</h4>

<p><a name="1012261"> </a>Represents a sampled stream. You create an <code>SndStreamRef</code> with <a href="MM_SoundRef.html#1000481"><code>SndStreamCreate()</code></a>.</p>
<h4>
  <a name="997291"> </a>Declared In 
</h4>
<code>SoundMgr.h<a name="997297"> </a></code><h4>
  <a name="997302"> </a>Prototype 
</h4>
<pre class="proto"><a name="997308"></a>typedef uint32_t SndStreamRef
</pre>

<h2 class="haH2">
  <a name="997434"> </a>Sound Manager Constants <a href="#995984"><span class="nav">^TOP^</span></a>
</h2>


<h3 class="hbH3">
  <a name="1039255"> </a>audio_type_t Enum <a href="#995984"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="1039257"> </a>Purpose 
</h4>

<p><a name="1039258"> </a>Defines a set of constants that represent the sample format (size, data type, endianness) of a sampled sound stream. These constant values are used with <a href="MM_SoundRef.html#1000481"><code>SndStreamCreate()</code></a> and <a href="MM_SoundRef.html#1000651"><code>SndStreamCreateExtended()</code></a>, as the value of the type <a href="MM_SoundRef.html#996773"><code>SndSampleType</code></a>.</p>

<p><a name="1039262"> </a>The lower four bits of these constants gives the size (in bytes) of a single sample, as shown here:</p>

<div class="CodeRule"><hr></div><pre class="CodeBlock">
uint8_t byteSize = formatConstant &amp; 0x0f<a name="1039263"> </a>
</pre><div class="CodeRule"><hr></div>

<h4>
  <a name="1039264"> </a>Declared In 
</h4>
<code>AudioTypes.h<a name="1039265"> </a></code><h4>
  <a name="1040196"> </a>Constants 
</h4>

<dl>
<dt><a name="1040198"> </a><code>sndInt8 = 0x01</code></dt>
<dd><a name="1040609"> </a>Signed 8-bit data.</dd>

<dt><a name="1040201"> </a><code>sndUInt8 = 0x11</code></dt>
<dd><a name="1040629"> </a>Unsigned 8-bit data.</dd>

<dt><a name="1040204"> </a><code>sndInt16Big = 0x02</code></dt>
<dd><a name="1040633"> </a>Signed 16-bit integer data in big-endian format.</dd>

<dt><a name="1040207"> </a><code>sndInt16Little = 0x12</code></dt>
<dd><a name="1040637"> </a>Signed 16-bit integer data in little-endian format.</dd>

<dt><a name="1040210"> </a><code>sndInt32Big = 0x04</code></dt>
<dd><a name="1040645"> </a>Signed 32-bit integer data in big-endian format.</dd>

<dt><a name="1040213"> </a><code>sndInt32Little = 0x14</code></dt>
<dd><a name="1040649"> </a>Signed 32-bit integer data in little-endian format.</dd>

<dt><a name="1040216"> </a><code>sndFloatBig = 0x24</code></dt>
<dd><a name="1040653"> </a>Signed floating-point data in big-endian format.</dd>

<dt><a name="1040219"> </a><code>sndFloatLittle = 0x34</code></dt>
<dd><a name="1040657"> </a>Signed floating-point data in little-endian format.</dd>

<dt><a name="1040758"> </a><code>sndInt16 = sndInt16Little</code></dt>
<dd><a name="1040661"> </a>Signed 16-bit integer data in the device's native endianness.</dd>

<dt><a name="1040769"> </a><code>sndInt16Opposite = sndInt16Big</code></dt>
<dd><a name="1040665"> </a>Signed 16-bit integer data in the endianness opposite to that of the device.</dd>

<dt><a name="1040776"> </a><code>sndInt32 = sndInt32Little</code></dt>
<dd><a name="1040641"> </a>Signed 32-bit integer data in the device's native endianness.</dd>

<dt><a name="1040895"> </a><code>sndInt32Opposite = sndInt32Big</code></dt>
<dd><a name="1040669"> </a>Signed 32-bit integer data in the endianness opposite to that of the device.</dd>

<dt><a name="1040908"> </a><code>sndFloat = sndFloatLittle</code></dt>
<dd><a name="1040673"> </a>Signed floating-point data in the device's native endianness.</dd>

<dt><a name="1041055"> </a><code>sndFloatOpposite = sndFloatBig</code></dt>
<dd><a name="1040677"> </a>Signed floating-point data in the endianness opposite to that of the device.</dd>

</dl>
<h4>
  <a name="1039365"> </a>Comments 
</h4>

<p><a name="1039369"> </a>In the current implementation the 32-bit and floating point formats aren't supported.</p>

<h3 class="hbH3">
  <a name="1013433"> </a>Simple Sound Amplitudes <a href="#995984"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="1013652"> </a>Purpose 
</h4>

<p><a name="1013434"> </a>These constants can be supplied to the simple sound functions (such as <a href="MM_SoundRef.html#999053"><code>SndDoCmd()</code></a>) when an amplitude value is required. Note that these values are not compatible with the sampled sound amplitude range and thus shouldn't be used with the sampled sound functions.</p>
<h4>
  <a name="1013631"> </a>Declared In 
</h4>
<code>SoundMgr.h<a name="1013632"> </a></code><h4>
  <a name="1013633"> </a>Constants 
</h4>

<dl>
<dt><a name="1013635"> </a><code>#define sndDefaultAmp sndMaxAmp</code></dt>
<dd><a name="1013636"> </a>The maximum amplitude (full volume).</dd>

<dt><a name="1013778"> </a><code>#define sndMaxAmp 64</code></dt>
<dd><a name="1013779"> </a>The default amplitude.</dd>

</dl>

<h3 class="hbH3">
  <a name="1022177"> </a>SndCmdIDType Enum <a href="#995984"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="1022179"> </a>Purpose 
</h4>

<p><a name="1022180"> </a>Contains constants that represent specific sound operations used in simple sound playback with <a href="MM_SoundRef.html#999053"><code>SndDoCmd()</code></a>.</p>
<h4>
  <a name="1022184"> </a>Declared In 
</h4>
<code>SoundMgr.h<a name="1022185"> </a></code><h4>
  <a name="1022186"> </a>Constants 
</h4>

<dl>
<dt><a name="1022188"> </a><code>sndCmdFreqDurationAmp = 1</code></dt>
<dd><a name="1022189"> </a>Play a tone. <code>SndDoCmd()</code> blocks until the tone has finished.</dd>

<dt><a name="1022191"> </a><code>sndCmdNoteOn</code></dt>
<dd><a name="1022192"> </a>Initiate a MIDI-defined tone. <code>SndDoCmd()</code> returns immediately while the tone plays in the background. Subsequent sound playback requests interrupt the tone.</dd>

<dt><a name="1022194"> </a><code>sndCmdFrqOn</code></dt>
<dd><a name="1022195"> </a>Initiate a tone. <code>SndDoCmd()</code> returns immediately while the tone plays in the background. Subsequent sound playback requests interrupt the tone.</dd>

<dt><a name="1022197"> </a><code>sndCmdQuiet</code></dt>
<dd><a name="1022198"> </a>Stop the playback of the currently generated tone.</dd>

</dl>

<h3 class="hbH3">
  <a name="1046668"> </a>SndFormatType Enum <a href="#995984"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="1046670"> </a>Purpose 
</h4>

<p><a name="1046671"> </a>Defines a set of constants that represent various sound data encoding formats. Pass one of these constants as the <code class="par">format</code> argument to <a href="MM_SoundRef.html#1000651"><code>SndStreamCreateExtended()</code></a>.</p>
<h4>
  <a name="1046675"> </a>Declared In 
</h4>
<code>SoundMgr.h<a name="1046676"> </a></code><h4>
  <a name="1046677"> </a>Constants 
</h4>

<dl>
<dt><a name="1046679"> </a><code>sndFormatPCM = 0</code></dt>
<dd><a name="1046680"> </a>Pulse Code Modulation format. This is the "no encoding" format; the data is a series of samples that are linear with regard to amplitude quantization and regular with regard to sampling rate.</dd>

<dt><a name="1046682"> </a><code>sndFormatIMA_ADPCM = 'APCM'</code></dt>
<dd><a name="1046683"> </a>The Interactive Multimedia Association's implementation of "adaptive delta" encoding. The sampling rate is constant, but the quantization is non-linear.</dd>

<dt><a name="1046685"> </a><code>sndFormatDVI_ADPCM = 'DPCM'</code></dt>
<dd><a name="1046686"> </a>Microsoft's adaptive delta implementation. This is the same as IMA ADPCM.</dd>

<dt><a name="1046688"> </a><code>sndFormatMP3 = 'MPG3'</code></dt>
<dd><a name="1046689"> </a>Motion Picture Group Audio Layer III.</dd>

<dt><a name="1046691"> </a><code>sndFormatAAC = 'DAAC'</code></dt>
<dd><a name="1046692"> </a>Dolby Advanced Audio Coding.</dd>

<dt><a name="1046694"> </a><code>sndFormatOGG = 'OGGV'</code></dt>
<dd><a name="1046695"> </a>OGG Vorbis encoding.</dd>

</dl>
<h4>
  <a name="1046696"> </a>Comments 
</h4>

<p><a name="1046700"> </a>The implementation of <a href="MM_SoundRef.html#1000651"><code>SndStreamCreateExtended()</code></a> supports <code>sndFormatPCM</code> data only. To play ADPCM data, use <a href="MM_SoundRef.html#999373"><code>SndPlayResource()</code></a>.</p>

<h3 class="hbH3">
  <a name="1013828"> </a>sndMidiNameLength <a href="#995984"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="1013834"> </a>Purpose 
</h4>

<p><a name="1013829"> </a>Defines the maximum string length, including the null terminator, for the name of a MIDI file or MIDI track.</p>
<h4>
  <a name="1013843"> </a>Declared In 
</h4>
<code>SoundMgr.h<a name="1013844"> </a></code><h4>
  <a name="1013845"> </a>Constants 
</h4>

<dl>
<dt><a name="1015248"> </a><code>#define sndMidiNameLength 32</code></dt>
</dl>

<h3 class="hbH3">
  <a name="1037339"> </a>sndMidiRecHdrSize <a href="#995984"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="1037340"> </a>Purpose 
</h4>

<p><a name="1037341"> </a>Defines the header size of a MIDI record.</p>
<h4>
  <a name="1037342"> </a>Declared In 
</h4>
<code>SoundMgr.h<a name="1037343"> </a></code><h4>
  <a name="1037344"> </a>Constants 
</h4>

<dl>
<dt><a name="1037346"> </a><code>#define sndMidiRecHdrSize 6</code></dt>
</dl>

<h3 class="hbH3">
  <a name="1007485"> </a>sndMidiRecSignature <a href="#995984"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="1007486"> </a>Purpose 
</h4>

<p><a name="1011627"> </a>Tags a MIDI record. It is used as the value of the <code>signature</code> field of the <a href="MM_SoundRef.html#996617"><code>SndMidiRecHdrType</code></a> structure. </p>
<h4>
  <a name="1011839"> </a>Declared In 
</h4>
<code>SoundMgr.h<a name="1011840"> </a></code><h4>
  <a name="1016291"> </a>Constants 
</h4>

<dl>
<dt><a name="1007490"> </a><code>#define sndMidiRecSignature 'PMrc'</code></dt>
</dl>

<h3 class="hbH3">
  <a name="1037226"> </a>sndSmfPlayAllMilliSec <a href="#995984"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="1037227"> </a>Purpose 
</h4>

<p><a name="1011398"> </a>Represents the (temporal) far end of a MIDI file. You can use this constant as the value of the <code>dwEndMilliSec</code> field of the <a href="MM_SoundRef.html#997069"><code>SndSmfOptionsType</code></a> structure before passing the structure to <a href="MM_SoundRef.html#999486"><code>SndPlaySmf()</code></a>. This setting tells the function to play the entire file.</p>
<h4>
  <a name="1011943"> </a>Declared In 
</h4>
<code>SoundMgr.h<a name="1011944"> </a></code><h4>
  <a name="1016295"> </a>Constants 
</h4>

<dl>
<dt><a name="1011406"> </a><code>#define sndSmfPlayAllMilliSec 0xFFFFFFFFUL</code></dt>
</dl>

<h3 class="hbH3">
  <a name="998045"> </a>SndSmfCmdEnum Enum <a href="#995984"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="998056"> </a>Purpose 
</h4>

<p><a name="1009577"> </a>Defines a set of commands that tell <a href="MM_SoundRef.html#999486"><code>SndPlaySmf()</code></a> whether it should play the file or simply return the duration of the file in milliseconds.</p>
<h4>
  <a name="998067"> </a>Declared In 
</h4>
<code>SoundMgr.h<a name="998073"> </a></code><h4>
  <a name="998078"> </a>Constants 
</h4>

<dl>
<dt><a name="998084"> </a><code>sndSmfCmdPlay = 1</code></dt>
<dd><a name="998089"> </a>Play the specified Standard MIDI File.</dd>

<dt><a name="998094"> </a><code>sndSmfCmdDuration</code></dt>
<dd><a name="998099"> </a>Return the duration, in milliseconds, of the specified Standard MIDI File.</dd>

</dl>

<h3 class="hbH3">
  <a name="998115"> </a>SndStreamMode Enum <a href="#995984"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="998126"> </a>Purpose 
</h4>

<p><a name="1012654"> </a>Defines constants that represent the "direction" (input or output) of a sampled sound stream. Use these constants with the <a href="MM_SoundRef.html#1000481"><code>SndStreamCreate()</code></a> function.</p>
<h4>
  <a name="998137"> </a>Declared In 
</h4>
<code>SoundMgr.h<a name="998143"> </a></code><h4>
  <a name="998148"> </a>Constants 
</h4>

<dl>
<dt><a name="998154"> </a><code>sndInput</code></dt>
<dd><a name="998159"> </a>Input stream used for recording.</dd>

<dt><a name="998164"> </a><code>sndOutput</code></dt>
<dd><a name="998169"> </a>Output stream used for playback.</dd>

</dl>

<h3 class="hbH3">
  <a name="998185"> </a>SndStreamWidth Enum <a href="#995984"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="998196"> </a>Purpose 
</h4>

<p><a name="1012675"> </a>Defines constants that represent mono and stereo sampled data streams. Use these constants with the <a href="MM_SoundRef.html#1000481"><code>SndStreamCreate()</code></a> function.</p>
<h4>
  <a name="998207"> </a>Declared In 
</h4>
<code>SoundMgr.h<a name="998213"> </a></code><h4>
  <a name="998218"> </a>Constants 
</h4>

<dl>
<dt><a name="998253"> </a><code>sndMono</code></dt>
<dd><a name="998290"> </a>Mono (one channel) stream.</dd>

<dt><a name="998307"> </a><code>sndStereo</code></dt>
<dd><a name="998360"> </a>Stereo (two channel) stream.</dd>

</dl>

<h3 class="hbH3">
  <a name="998376"> </a>SndSysBeepType Enum <a href="#995984"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="998387"> </a>Purpose 
</h4>

<p><a name="1012923"> </a>Defines a set of constants that represent pre-defined system beeps. In order to play one of these sounds, pass the corresponding value to <a href="MM_SoundRef.html#1000052"><code>SndPlaySystemSound()</code></a>.</p>
<h4>
  <a name="998398"> </a>Declared In 
</h4>
<code>SoundMgr.h<a name="998404"> </a></code><h4>
  <a name="998409"> </a>Constants 
</h4>

<dl>
<dt><a name="998415"> </a><code>sndInfo = 1</code></dt>
<dd><a name="998420"> </a>Signals non-crucial information.</dd>

<dt><a name="998425"> </a><code>sndWarning</code></dt>
<dd><a name="998430"> </a>Grabs the user's attention.</dd>

<dt><a name="998435"> </a><code>sndError</code></dt>
<dd><a name="998440"> </a>Indicates an illegal operation.</dd>

<dt><a name="998445"> </a><code>sndStartUp</code></dt>
<dd><a name="998450"> </a>Played at device start up time.</dd>

<dt><a name="998455"> </a><code>sndAlarm</code></dt>
<dd><a name="998460"> </a>Generic alarm sound; note that this is <span style="color: #000000;  font-style: italic; font-weight: normal; text-decoration: none; text-transform: none; vertical-align: baseline">not</span> the Datebook's alarm sound.</dd>

<dt><a name="998465"> </a><code>sndConfirmation</code></dt>
<dd><a name="998470"> </a>Indicates approval or acceptance.</dd>

<dt><a name="998475"> </a><code>sndClick</code></dt>
<dd><a name="998480"> </a>The button click sound.</dd>

<dt><a name="998485"> </a><code>sndCardInserted</code></dt>
<dd><a name="998490"> </a>Played when a card is inserted.</dd>

<dt><a name="998495"> </a><code>sndCardRemoved</code></dt>
<dd><a name="1013208"> </a>Played when a card is removed.</dd>

</dl>

<h3 class="hbH3">
  <a name="1020323"> </a>Sound Error Codes <a href="#995984"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="1020324"> </a>Purpose 
</h4>

<p><a name="1020325"> </a>Error codes returned by various Sound Manager functions.</p>
<h4>
  <a name="1020326"> </a>Declared In 
</h4>
<code>SoundMgr.h<a name="1020327"> </a></code><h4>
  <a name="1020328"> </a>Constants 
</h4>

<dl>
<dt><a name="1020330"> </a><code>#define sndErrBadChannel (sndErrorClass | 2)</code></dt>
<dd><a name="1022292"> </a>Invalid sound channel.</dd>

<dt><a name="1020333"> </a><code>#define sndErrBadParam (sndErrorClass | 1)</code></dt>
<dd><a name="1022296"> </a>Invalid parameter passed to a function.</dd>

<dt><a name="1020336"> </a><code>#define sndErrBadStream (sndErrorClass | 8)</code></dt>
<dd><a name="1022302"> </a>Invalid data stream.</dd>

<dt><a name="1020339"> </a><code>#define sndErrFormat (sndErrorClass | 7)</code></dt>
<dd><a name="1022306"> </a>Unsupported data format.</dd>

<dt><a name="1020342"> </a><code>#define sndErrInterrupted (sndErrorClass | 9)</code></dt>
<dd><a name="1022310"> </a>Play was interrupted.</dd>

<dt><a name="1020345"> </a><code>#define sndErrInvalidStream (sndErrorClass | 11)</code></dt>
<dd><a name="1020346"> </a>Invalid stream identifier.</dd>

<dt><a name="1020348"> </a><code>#define sndErrMemory (sndErrorClass | 3)</code></dt>
<dd><a name="1022318"> </a>Insufficient memory. </dd>

<dt><a name="1020351"> </a><code>#define sndErrNotImpl (sndErrorClass | 10)</code></dt>
<dd><a name="1022325"> </a>Function not implemented</dd>

<dt><a name="1020354"> </a><code>#define sndErrOpen (sndErrorClass | 4)</code></dt>
<dd><a name="1022341"> </a>Tried to open a channel that's already open.</dd>

<dt><a name="1020357"> </a><code>#define sndErrQEmpty (sndErrorClass | 6)</code></dt>
<dd><a name="1020358"> </a>Internal error.</dd>

<dt><a name="1020360"> </a><code>#define sndErrQFull (sndErrorClass | 5)</code></dt>
<dd><a name="1022351"> </a>The sound queue is full.</dd>

</dl>

<h3 class="hbH3">
  <a name="1016556"> </a>Sound Resource Playback Flags <a href="#995984"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="1016595"> </a>Purpose 
</h4>

<p><a name="1016630"> </a>Use these flags when calling <a href="MM_SoundRef.html#999373"><code>SndPlayResource()</code></a> to specify various settings. Currently, the only setting is function synchronization.</p>
<h4>
  <a name="1016704"> </a>Declared In 
</h4>
<code>SoundMgr.h<a name="1016705"> </a></code><h4>
  <a name="1016706"> </a>Constants 
</h4>

<dl>
<dt><a name="1016804"> </a><code>#define sndFlagSync 0x00000000</code></dt>
<dd><a name="1016805"> </a>Tells <code>SndPlayResource()</code> to wait until all sound data has been fed to the DAC before returning (meaning that the function will return just a bit before the sound has finished playing).</dd>

<dt><a name="1016500"> </a><code>#define sndFlagAsync 0x00000001</code></dt>
<dd><a name="1016501"> </a>Tells <code>SndPlayResource()</code> to return immediately while playback continues in a separate thread.</dd>

<dt><a name="1016841"> </a><code>#define sndFlagNormal sndFlagSync</code></dt>
<dd><a name="1016842"> </a>A shorthand for the set of "normal" flag settings.</dd>

</dl>

<h3 class="hbH3">
  <a name="1015300"> </a>Sound Stream Feature Constants <a href="#995984"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="1015605"> </a>Purpose 
</h4>

<p><a name="1015304"> </a>Used to retrieve the Sound Manager version number from the Feature Manager.</p>
<h4>
  <a name="1015924"> </a>Declared In 
</h4>
<code>SoundMgr.h<a name="1015925"> </a></code><h4>
  <a name="1015926"> </a>Constants 
</h4>

<dl>
<dt><a name="1016093"> </a><code>#define sndFtrIDVersion 0</code></dt>
<dd><a name="1016094"> </a>The feature number to supply to <a href="../System_Management/FeatureMgr.html#992990"><code>FtrGet()</code></a>, along with a creator ID of <code>sysFileCSoundMgr</code>, when attempting to obtain the version of the Sound Manager.</dd>

<dt><a name="1016096"> </a><code>#define sndMgrVersionNum (100)</code></dt>
<dd><a name="1016097"> </a>The current version of the Sound Manager. Note that in Palm OS Cobalt version 6.0, this is set incorrectly to 100 (indicating version 1.00). The Sound Manager is actually version 1.01 in this release.</dd>

</dl>

<h3 class="hbH3">
  <a name="1016875"> </a>Stereo Pan Constants <a href="#995984"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="1017142"> </a>Purpose 
</h4>

<p><a name="1016876"> </a>Define the extremes and the midpoint when altering the stream's stereo balance with <a href="MM_SoundRef.html#1001442"><code>SndStreamSetPan()</code></a>. <code>SndStreamSetPan()</code> allows you to set the balance to one of these values, or any integral value between <code>sndPanFullLeft</code> and <code>sndPanFullRight</code>.</p>
<h4>
  <a name="1017341"> </a>Declared In 
</h4>
<code>SoundMgr.h<a name="1018003"> </a></code><h4>
  <a name="1017613"> </a>Constants 
</h4>

<dl>
<dt><a name="1017855"> </a><code>#define sndPanCenter (0)</code></dt>
<dd><a name="1017856"> </a>The stereo balance is centered.</dd>

<dt><a name="1017858"> </a><code>#define sndPanFullLeft (-1024)</code></dt>
<dd><a name="1017859"> </a>The stereo balance is panned completely to the left.</dd>

<dt><a name="1017861"> </a><code>#define sndPanFullRight (1024)</code></dt>
<dd><a name="1017862"> </a>The stereo balance is panned completely to the right.</dd>

</dl>

<h3 class="hbH3">
  <a name="998633"> </a>Volume Constants Enum <a href="#995984"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="998644"> </a>Purpose 
</h4>

<p><a name="1013256"> </a>Use the volume constants defined in this enum with <a href="MM_SoundRef.html#1001569"><code>SndStreamSetVolume()</code></a> and <a href="MM_SoundRef.html#999373"><code>SndPlayResource()</code></a>. The constants tell the functions to retrieve the named sound volume preference (as set by the user) and apply it as a volume setting.</p>
<h4>
  <a name="998655"> </a>Declared In 
</h4>
<code>SoundMgr.h<a name="998661"> </a></code><h4>
  <a name="998666"> </a>Constants 
</h4>

<dl>
<dt><a name="998672"> </a><code>sndSystemVolume = -1</code></dt>
<dd><a name="998677"> </a>The user's system sound preference.</dd>

<dt><a name="998682"> </a><code>sndGameVolume = -2</code></dt>
<dd><a name="998687"> </a>The user's game sound preference.</dd>

<dt><a name="998692"> </a><code>sndAlarmVolume = -3</code></dt>
<dd><a name="998697"> </a>The user's alarm sound preference.</dd>

</dl>

<h2 class="haH2">
  <a name="998713"> </a>Sound Manager Functions and Macros <a href="#995984"><span class="nav">^TOP^</span></a>
</h2>


<h3 class="hbH3">
  <a name="998724"> </a>SndCreateMidiList Function <a href="#995984"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="998773"> </a>Purpose 
</h4>

<p><a name="1022355"> </a>Generates a list of MIDI records.</p>
<h4>
  <a name="998816"> </a>Declared In 
</h4>
<code>SoundMgr.h<a name="998838"> </a></code><h4>
  <a name="998859"> </a>Prototype 
</h4>
<pre class="proto"><a name="998881"></a>Boolean SndCreateMidiList (
   uint32_t <code class="par">creator</code>,
   Boolean <code class="par">multipleDBs</code>,
   uint16_t <code class="par">*wCountP</code>,
   MemHandle <code class="par">*entHP</code>
)
</pre>
<h4>
  <a name="998910"> </a>Parameters 
</h4>

<dl>
<dt><a name="998932"> </a><code>&rarr;  <i>creator</i></code></dt>
<dd><a name="1022363"> </a>Creator ID of the database in which the function looks for MIDI records. Pass 0 to search all databases.</dd>

<dt><a name="998974"> </a><code>&rarr;  <i>multipleDBs</i></code></dt>
<dd><a name="1022404"> </a>Pass <code>true</code> to search multiple databases for MIDI records. Pass <code>false</code> to search only in the first database that meets the search criteria.</dd>

<dt><a name="999000"> </a><code>&larr;  <i>wCountP</i></code></dt>
<dd><a name="1022411"> </a>Returns the number of MIDI records that were found. </dd>

<dt><a name="999010"> </a><code>&larr;  <i>entHP</i></code></dt>
<dd><a name="1022450"> </a>Returns a pointer to an array of <a href="MM_SoundRef.html#996507"><code>SndMidiListItemType</code></a> structures, one structure for each record that was found.</dd>

</dl>
<h4>
  <a name="999020"> </a>Returns 
</h4>

<p><a name="1022660"> </a><code>true</code> if records were found, <code>false</code> otherwise.</p>

<h3 class="hbH3">
  <a name="999053"> </a>SndDoCmd Function <a href="#995984"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="999064"> </a>Purpose 
</h4>

<p><a name="1022700"> </a>Asks the Sound Manager to perform a simple sound synthesis operation.</p>
<h4>
  <a name="999075"> </a>Declared In 
</h4>
<code>SoundMgr.h<a name="999081"> </a></code><h4>
  <a name="999086"> </a>Prototype 
</h4>
<pre class="proto"><a name="999092"></a>status_t SndDoCmd (
   void <code class="par">*channelP</code>,
   SndCommandPtr <code class="par">cmdP</code>,
   Boolean <code class="par">noWait</code>
)
</pre>
<h4>
  <a name="999097"> </a>Parameters 
</h4>

<dl>
<dt><a name="999103"> </a><code>&rarr;  <i>channelP</i></code></dt>
<dd><a name="1022710"> </a>Pointer to the sound channel on which you want to perform the operation. Pass <code>NULL</code> for the "shared" sound channel.</dd>

</dl>

<div><hr>
  <a name="1022711"> </a> <b>IMPORTANT: </b> The Sound Manager only supports one channel of sound synthesis: You must pass <code>NULL</code> as the value of <code class="par">channelP</code>.
<hr>
</div>

<dl>
<dt><a name="999136"> </a><code>&rarr;  <i>cmdP</i></code></dt>
<dd><a name="1022754"> </a>Pointer to a <a href="MM_SoundRef.html#996269"><code>SndCommandType</code></a> structure that describes the operation and contains any associated parameters. See the Comments section below for the set of sound commands and their associated parameters.</dd>

<dt><a name="999210"> </a><code>&rarr;  <i>noWait</i></code></dt>
<dd><a name="1022794"> </a>Sets the function to be asynchronous (<code>true</code>) or synchronous (<code>false</code>) with respect to the caller.</dd>

</dl>

<div><hr>
  <a name="1022871"> </a> <b>IMPORTANT: </b> <code>SndDoCmd()</code> is always synchronous: The <code class="par">noWait</code> value is currently ignored.
<hr>
</div>
<h4>
  <a name="999220"> </a>Returns 
</h4>

<p><a name="1022897"> </a><code>errNone</code> if the operation completed successfully, or one of the following if an error occurs:</p>

<dl>
<dt><a name="1022898"> </a><code><code>sndErrBadParam</code></code></dt>
<dd><a name="1022899"> </a>Invalid parameter.</dd>

<dt><a name="1022900"> </a><code><code>sndErrBadChannel</code></code></dt>
<dd><a name="1022901"> </a>Invalid channel pointer.</dd>

<dt><a name="1022902"> </a><code><code>sndErrQFull</code></code></dt>
<dd><a name="1022903"> </a>The sound queue is full.</dd>

</dl>
<h4>
  <a name="999231"> </a>Comments 
</h4>

<p><a name="1022937"> </a>The sound operations that are performed by <code>SndDoCmd()</code> are encapsulated in the <a href="MM_SoundRef.html#996269"><code>SndCommandType</code></a> structure. The <code>cmd</code> field represents the operation, while the <code>param</code> fields are data that's passed to the operation. The operations and data that <code>SndDoCmd()</code> supports are described in the following table. </p>

<p class="caption"><a name="1026733"> </a><b>Table 2.1&nbsp;&nbsp;SndDoCmd() commands and parameters </b></p>
<div class="tablediv"><table cellspacing="0" class="tTable">

  <tr valign="top">
    <th><p class="tt"><a name="1026739"> </a><b>Command</b></p>
    </th>
    <th><p class="tt"><a name="1026741"> </a><b>Function</b></p>
    </th>
    <th><p class="tt"><a name="1026743"> </a><b>Parameters</b></p>
    </th>
  </tr>
  <tr valign="top">
    <td><p class="tt"><a name="1026746"> </a><code>sndCmdFreqDurationAmp</code></p>
    </td>
    <td><p class="tt"><a name="1026748"> </a>Plays a tone. <code>SndDoCmd()</code> blocks until the tone has finished.</p>
    </td>
    <td><p class="tt"><a name="1026750"> </a><code>param1</code> is the tone's frequency in Hertz.</p>
<p class="tt"><a name="1026751"> </a><code>param2</code> is its duration in milliseconds.</p>
<p class="tt"><a name="1026752"> </a><code>param3</code> is its amplitude in the range [0, <code>sndMaxAmp</code>]. If the amplitude is 0, the sound isn't played and the function returns immediately.</p>
    </td>
  </tr>
  <tr valign="top">
    <td><p class="tt"><a name="1026755"> </a><code>sndCmdFrqOn</code></p>
    </td>
    <td><p class="tt"><a name="1026757"> </a>Initiates a tone. <code>SndDoCmd()</code> returns immediately while the tone plays in the background. Subsequent sound playback requests interrupt the tone.</p>
    </td>
    <td><p class="tt"><a name="1026759"> </a><code>param1</code> is the tone's frequency in Hertz.</p>
<p class="tt"><a name="1026760"> </a><code>param2</code> is its duration in milliseconds.</p>
<p class="tt"><a name="1026761"> </a><code>param3</code> is its amplitude in the range [0, <code>sndMaxAmp</code>]. If the amplitude is 0, the sound isn't played and the function returns immediately.</p>
    </td>
  </tr>
  <tr valign="top">
    <td><p class="tt"><a name="1026764"> </a><code>sndCmdNoteOn</code></p>
    </td>
    <td><p class="tt"><a name="1026766"> </a>Initiates a MIDI-defined tone. <code>SndDoCmd()</code> returns immediately while the tone plays in the background. Subsequent sound playback requests interrupt the tone.</p>
    </td>
    <td><p class="tt"><a name="1026768"> </a><code>param1</code> is the tone's pitch given as a MIDI key number in the range [0, 127].</p>
<p class="tt"><a name="1026769"> </a><code>param2</code> is the tone's duration in milliseconds.</p>
<p class="tt"><a name="1026770"> </a><code>param3</code> is its amplitude given as MIDI velocity [0, 127]. </p>
    </td>
  </tr>
  <tr valign="top">
    <td><p class="tt"><a name="1026773"> </a><code>sndCmdQuiet</code></p>
    </td>
    <td><p class="tt"><a name="1026775"> </a>Stops the playback of the currently generated tone.</p>
    </td>
    <td><p class="tt"><a name="1026777"> </a>All parameter values are ignored.</p>
    </td>
  </tr>
</table>

</div>

<h4>
  <a name="999242"> </a>See Also 
</h4>

<p><a name="999248"> </a><a href="MM_SoundRef.html#999486"><code>SndPlaySmf()</code></a></p>

<h3 class="hbH3">
  <a name="999253"> </a>SndGetDefaultVolume Function <a href="#995984"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="999264"> </a>Purpose 
</h4>

<p><a name="1026787"> </a>Returns volume levels cached by the Sound Manager. This function is deprecated and should not be used.</p>
<h4>
  <a name="999275"> </a>Declared In 
</h4>
<code>SoundMgr.h<a name="999281"> </a></code><h4>
  <a name="999286"> </a>Prototype 
</h4>
<pre class="proto"><a name="999292"></a>void SndGetDefaultVolume (
   uint16_t <code class="par">*alarmAmpP</code>,
   uint16_t <code class="par">*sysAmpP</code>,
   uint16_t <code class="par">*masterAmpP</code>
)
</pre>
<h4>
  <a name="999297"> </a>Parameters 
</h4>

<dl>
<dt><a name="1026795"> </a><code>&larr;  <i>alarmAmpP</i></code></dt>
<dd><a name="1026796"> </a>Pointer to the alarm amplitude.</dd>

<dt><a name="1026797"> </a><code>&larr;  <i>sysAmpP</i></code></dt>
<dd><a name="1026798"> </a>Pointer to the system sound amplitude.</dd>

<dt><a name="1026799"> </a><code>&larr;  <i>masterAmpP</i></code></dt>
<dd><a name="1026800"> </a>Pointer to the master amplitude.</dd>

</dl>
<h4>
  <a name="999340"> </a>Returns 
</h4>

<p><a name="999346"> </a>Nothing.</p>
<h4>
  <a name="999351"> </a>Comments 
</h4>

<p><a name="1026944"> </a>Pass <code>NULL</code> for those settings that you don't care about.</p>

<p><a name="1026958"> </a>Never call this function. To retrieve default volume levels, you should ask for the user's preferences settings.</p>
<h4>
  <a name="999362"> </a>See Also 
</h4>

<p><a name="999368"> </a><a href="MM_SoundRef.html#1000145"><code>SndSetDefaultVolume()</code></a></p>

<h3 class="hbH3">
  <a name="999373"> </a>SndPlayResource Function <a href="#995984"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="999384"> </a>Purpose 
</h4>

<p><a name="1027113"> </a>Plays formatted sound data read from a resource or file.</p>
<h4>
  <a name="999395"> </a>Declared In 
</h4>
<code>SoundMgr.h<a name="999401"> </a></code><h4>
  <a name="999406"> </a>Prototype 
</h4>
<pre class="proto"><a name="999412"></a>status_t SndPlayResource (
   SndPtr <code class="par">sndP</code>,
   int32_t <code class="par">volume</code>,
   uint32_t <code class="par">flags</code>
)
</pre>
<h4>
  <a name="999417"> </a>Parameters 
</h4>

<dl>
<dt><a name="1027270"> </a><code>&rarr;  <i>sndP</i></code></dt>
<dd><a name="1027271"> </a>A pointer to the beginning of the formatted sound (including the header). Currently, only WAV data is recognized (see the Comments section, below); in this case, <code class="par">sndP</code> must point to the "RIFF" ID (byte 0 in a simple <code>.wav</code> file).</dd>

<dt><a name="1027272"> </a><code>&rarr;  <i><code>volume</code></i></code></dt>
<dd><a name="1027273"> </a>Amplitude scalar, in the range [0, 32k]. See <a href="MM_SoundRef.html#1001569"><code>SndStreamSetVolume()</code></a> for information on how amplitude scalar values are applied.</dd>

<dt><a name="1027277"> </a><code>&rarr;  <i><code>flags</code></i></code></dt>
<dd><a name="1027281"> </a>One of the <a href="MM_SoundRef.html#1016556">"Sound Resource Playback Flags."</a> Currently, the only setting is function synchronization: use <code>sndFlagSync</code> to have the function wait until all sound data has been fed to the DAC before returning, or <code>sndFlagAsync</code> flag to have the function return immediately while playback continues in a separate thread.</dd>

</dl>
<h4>
  <a name="999453"> </a>Returns 
</h4>

<p><a name="1027910"> </a><code>errNone</code> if the operation completed successfully, or one of the following if an error occurs:</p>

<dl>
<dt><a name="1027911"> </a><code><code>sndErrBadParam</code></code></dt>
<dd><a name="1027912"> </a>The specified resource or file contains no data.</dd>

<dt><a name="1027913"> </a><code><code>sndErrFormat</code></code></dt>
<dd><a name="1027914"> </a>The data is in an unsupported format.</dd>

<dt><a name="1027915"> </a><code><code>sndErrMemory</code></code></dt>
<dd><a name="1027916"> </a>The function couldn't allocate sufficient memory.</dd>

<dt><a name="1027917"> </a><code>other errors</code></dt>
<dd><a name="1027918"> </a>The device couldn't allocate system resources for the sound.</dd>

</dl>
<h4>
  <a name="999464"> </a>Comments 
</h4>

<p><a name="1028026"> </a>The supported WAVE parameters are: </p>
<ul type="disc">
  <li><a name="1028027"> </a>Uncompressed (PCM) or IMA 4-bit adaptive differential (IMA ADPCM). The ADPCM type is also known as DVI ADPCM; in a WAV file, it's known as format 0x11.
  <li><a name="1028028"> </a>One or two-channels
  <li><a name="1028029"> </a>Any sampling rate
</ul>

<p><a name="1028030"> </a>You can't interrupt or abort a resource playback once it's been initiated. The resource always plays to the end of the data.</p>
<h4>
  <a name="1028142"> </a>Example 
</h4>

<p><a name="1028143"> </a>The following code excerpt shows how to use this function to play a sound resource.</p>

<div class="CodeRule"><hr></div><pre class="CodeBlock">
SndPtr soundP;<a name="1028144"> </a>
MemHandle recordH;<a name="1028145"> </a>
recordH = DmGetResource(myOpenDb,sysResTSound,TestWaveSound);<a name="1028147"> </a>
soundP = (SndPtr) MemHandleLock(recordH);<a name="1028148"> </a>
SndPlayResource(soundP,1024,sndFlagSync); <a name="1032958"> </a>
                // 1024 is 0dB (unity) gain<a name="1032959"> </a>
MemHandleUnlock(recordH);<a name="1032960"> </a>
</pre><div class="CodeRule"><hr></div>


<p><a name="1028151"> </a>The above code first gets the resource from an open database. It then locks the memory associated with the resource and converts the result to a pointer to a sound resource.</p>

<p><a name="1028152"> </a>The call to the <code>SndPlayResource()</code> function plays the sound. The second parameter is the sound level, which varies from 0 to 32767. A value of 1024 specifies unity gain. Higher values indicate higher gain. The third parameter specifies whether the function returns immediately or waits until after the sound has finished playing. You should avoid using <code>sndFlagAsync</code>, which causes the function to return immediately without waiting for the sound to finish, if you use this code because you'll unlock the sound resource before the system finishes with it. In fact, you should always specify <code>sndFlagSync</code> unless you can guarantee two things:</p>
<ol type="1">
  <li value="1"><a name="1028153"> </a>Your resource memory remains locked for the duration of the sound.
  <li value="2"><a name="1028154"> </a>Your application does not exit for the duration of the sound.
</ol>

<p><a name="1028155"> </a>Remember that you cannot stop a sound played with <code>SndPlayResource()</code>.</p>

<h3 class="hbH3">
  <a name="999486"> </a>SndPlaySmf Function <a href="#995984"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="999497"> </a>Purpose 
</h4>

<p><a name="1028306"> </a>Performs a Standard MIDI File, or returns the duration of the file.</p>
<h4>
  <a name="999508"> </a>Declared In 
</h4>
<code>SoundMgr.h<a name="999514"> </a></code><h4>
  <a name="999519"> </a>Prototype 
</h4>
<pre class="proto"><a name="999525"></a>status_t SndPlaySmf (
   void <code class="par">*chanP</code>,
   SndSmfCmdEnum <code class="par">cmd</code>,
   uint8_t <code class="par">*smfP</code>,
   SndSmfOptionsType <code class="par">*selP</code>,
   SndSmfChanRangeType <code class="par">*chanRangeP</code>,
   SndSmfCallbacksType <code class="par">*callbacksP</code>,
   Boolean <code class="par">bNoWait</code>
)
</pre>
<h4>
  <a name="999549"> </a>Parameters 
</h4>

<dl>
<dt><a name="1028310"> </a><code>&rarr;  <i><code>chanP</code></i></code></dt>
<dd><a name="1028311"> </a>A pointer to the sound channel on which you want to perform the MIDI file. Pass <code>NULL</code> for the "shared" sound channel.</dd>

</dl>

<div><hr>
  <a name="1028312"> </a> <b>IMPORTANT: </b> The Sound Manager only supports one channel of sound synthesis: You must pass <code>NULL</code> as the value of <code class="par">channel</code>.
<hr>
</div>

<dl>
<dt><a name="1028313"> </a><code>&rarr;  <i><code>cmd</code></i></code></dt>
<dd><a name="1028317"> </a>One of the <a href="MM_SoundRef.html#998045">SndSmfCmdEnum</a> values: either <code>SndSmfCmdPlay</code> (play the file) or <code>SndSmfCmdDuration</code> (return the duration of the file in milliseconds).</dd>

<dt><a name="1028318"> </a><code>&rarr;  <i><code>smfP</code></i></code></dt>
<dd><a name="1028322"> </a>The MIDI data; this can point to a <a href="MM_SoundRef.html#996617"><code>SndMidiRecHdrType</code></a> structure, or it can point directly to the actual MIDI data bytes in memory. </dd>

<dt><a name="1028323"> </a><code>&rarr;  <i><code>selP</code></i></code></dt>
<dd><a name="1028327"> </a>A pointer to a <a href="MM_SoundRef.html#997069"><code>SndSmfOptionsType</code></a> structure that defines performance parameters, such as volume, starting offset, and interruption tolerance. For default behavior, pass <code>NULL</code>. For more information, including default settings, see <a href="MM_SoundRef.html#997069"><code>SndSmfOptionsType</code></a>.</dd>

<dt><a name="1028331"> </a><code>&rarr;  <i><code>chanRangeP</code></i></code></dt>
<dd><a name="1028335"> </a><code>A </code>pointer to a <a href="MM_SoundRef.html#996926"><code>SndSmfChanRangeType</code></a> structure that specifies the range of MIDI channels (in the SMF data) to use during playback. To play all channels, pass <code>NULL</code>.</dd>

<dt><a name="999821"> </a><code>&rarr;  <i>callbacksP</i></code></dt>
<dd><a name="1028982"> </a><code>A</code> pointer to a <a href="MM_SoundRef.html#996835"><code>SndSmfCallbacksType</code></a> structure that holds your callback functions. Pass <code>NULL</code> if you don't want any callbacks. </dd>

<dt><a name="999831"> </a><code>&rarr;  <i>bNoWait</i></code></dt>
<dd><a name="1029024"> </a>This value is ignored. This function always finishes playing the SMF selection before returning (but see the Comments section, below).</dd>

</dl>
<h4>
  <a name="999841"> </a>Returns 
</h4>

<p><a name="1029083"> </a><code>errNone</code> if the operation completed successfully, or one of the following if an error occurs:</p>

<dl>
<dt><a name="1029084"> </a><code><code>sndErrBadParam</code></code></dt>
<dd><a name="1029085"> </a>Invalid value passed to this function.</dd>

<dt><a name="1029086"> </a><code><code>sndErrBadChannel</code></code></dt>
<dd><a name="1029087"> </a>Invalid sound channel.</dd>

<dt><a name="1029088"> </a><code><code>sndErrMemory</code> </code></dt>
<dd><a name="1029089"> </a>Insufficient memory. </dd>

<dt><a name="1029090"> </a><code><code>sndErrOpen</code> </code></dt>
<dd><a name="1029091"> </a>Tried to open channel that's already open.</dd>

<dt><a name="1029092"> </a><code><code>sndErrQFull</code> </code></dt>
<dd><a name="1029093"> </a>Can't accept more notes.</dd>

<dt><a name="1029094"> </a><code><code>sndErrFormat</code> </code></dt>
<dd><a name="1029095"> </a>Unsupported data format.</dd>

<dt><a name="1029096"> </a><code><code>sndErrBadStream</code></code></dt>
<dd><a name="1029097"> </a>Invalid data stream.</dd>

<dt><a name="1029098"> </a><code><code>sndErrInterrupted</code></code></dt>
<dd><a name="1029099"> </a>Play was interrupted.</dd>

</dl>
<h4>
  <a name="999852"> </a>Comments 
</h4>

<p><a name="1029133"> </a>Although this call is always synchronous, you can register a "blocking" function that's called periodically as the MIDI file is playing. See <a href="MM_SoundRef.html#1002200"><code>SndBlockingFuncType()</code></a> for more information.</p>

<p><a name="1029137"> </a>Normally, playback is halted by events generated by user interaction with the screen, digitizer, or hardware-based buttons. You can override this behavior by setting the <code>interruptible </code>field of the <code class="par">selP</code> parameter to <code>false</code>.</p>

<p><a name="1029138"> </a>This function waits until any currently-playing simple sound has finished before starting playback of the requested MIDI data.</p>

<h3 class="hbH3">
  <a name="999905"> </a>SndPlaySmfResource Function <a href="#995984"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="999940"> </a>Purpose 
</h4>

<p><a name="1029398"> </a>Plays a MIDI track read out of an open resource database.</p>
<h4>
  <a name="999951"> </a>Declared In 
</h4>
<code>SoundMgr.h<a name="999957"> </a></code><h4>
  <a name="999962"> </a>Prototype 
</h4>
<pre class="proto"><a name="999968"></a>status_t SndPlaySmfResource (
   uint32_t <code class="par">resType</code>,
   DmOpenRef <code class="par">dbRef</code>,
   int16_t <code class="par">resID</code>,
   SystemPreferencesChoice <code class="par">volumeSelector</code>
)
</pre>
<h4>
  <a name="999973"> </a>Parameters 
</h4>

<dl>
<dt><a name="1029402"> </a><code>&rarr;  <i><code>resType</code></i></code></dt>
<dd><a name="1029512"> </a>SMF resource type.</dd>

<dt><a name="1030493"> </a><code>&rarr;  <i>dbRef</i></code></dt>
<dd><a name="1030494"> </a>Pointer to an open database. You can pass 0 to search all open resource databases for the specified resource type and ID.</dd>

<dt><a name="1030495"> </a><code>&rarr;  <i><code>resID</code></i></code></dt>
<dd><a name="1030496"> </a>SMF resource ID.</dd>

<dt><a name="1029406"> </a><code>&rarr;  <i>volumeSelector</i></code></dt>
<dd><a name="1029408"> </a>Volume setting; one of <code>prefSysSoundVolume</code>, <code>prefGameSoundVolume</code>, or <code>prefAlarmSoundVolume</code> (all defined in <code>Preferences.h</code>).</dd>

</dl>
<h4>
  <a name="1000019"> </a>Returns 
</h4>

<p><a name="1030156"> </a><code>errNone</code> if the track was played successfully, or one of the following if an error occurs:</p>

<dl>
<dt><a name="1030157"> </a><code><code>sndErrBadParam</code></code></dt>
<dd><a name="1030158"> </a>The <code class="par">volumeSelector</code> parameter is invalid or the SMF resource has invalid data.</dd>

<dt><a name="1030159"> </a><code><code>dmErrCantFind</code></code></dt>
<dd><a name="1030160"> </a>The specified resource doesn't exist.</dd>

<dt><a name="1030161"> </a><code>other values</code></dt>
<dd><a name="1030165"> </a>See <a href="MM_SoundRef.html#999486"><code>SndPlaySmf()</code></a>.</dd>

</dl>
<h4>
  <a name="1000030"> </a>Comments 
</h4>

<p><a name="1030255"> </a>This function plays the entire MIDI file using all MIDI channels. Playback is interrupted by a key down or digitizer event. No callbacks are specified. </p>

<p><a name="1030256"> </a>This function waits until any currently playing simple sound has finished before starting playback of the requested MIDI data.</p>

<h3 class="hbH3">
  <a name="1000052"> </a>SndPlaySystemSound Function <a href="#995984"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="1000063"> </a>Purpose 
</h4>

<p><a name="1030504"> </a>Plays a pre-defined (simple) system sound.</p>
<h4>
  <a name="1000074"> </a>Declared In 
</h4>
<code>SoundMgr.h<a name="1000080"> </a></code><h4>
  <a name="1000085"> </a>Prototype 
</h4>
<pre class="proto"><a name="1000091"></a>void SndPlaySystemSound (
   SndSysBeepType <code class="par">beepID</code>
)
</pre>
<h4>
  <a name="1000096"> </a>Parameters 
</h4>

<dl>
<dt><a name="1000102"> </a><code>&rarr;  <i>beepID</i></code></dt>
<dd><a name="1030512"> </a>One of the system beep sound constants defined in the <a href="MM_SoundRef.html#998376"><code>SndSysBeepType</code></a> enum.</dd>

</dl>
<h4>
  <a name="1000112"> </a>Returns 
</h4>

<p><a name="1000118"> </a>Nothing.</p>
<h4>
  <a name="1000123"> </a>Comments 
</h4>

<p><a name="1030525"> </a>If you're playing an alarm (<code>sndAlarm</code>), the user's alarm volume preference setting is used. For all other system sounds, the system volume preference is used.</p>

<p><a name="1030526"> </a>Alarm sounds (<code>sndAlarm</code>) are played synchronously: <code>SndPlaySystemSound()</code> blocks until the sound has been played. All other sounds are played asynchronously.</p>

<h3 class="hbH3">
  <a name="1000145"> </a>SndSetDefaultVolume Function <a href="#995984"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="1000156"> </a>Purpose 
</h4>

<p><a name="1030580"> </a>Sets the default sound volume levels cached by the Sound Manager.</p>
<h4>
  <a name="1000182"> </a>Declared In 
</h4>
<code>SoundMgr.h<a name="1000206"> </a></code><h4>
  <a name="1000233"> </a>Prototype 
</h4>
<pre class="proto"><a name="1000263"></a>void SndSetDefaultVolume (
   uint16_t <code class="par">*alarmAmpP</code>,
   uint16_t <code class="par">*sysAmpP</code>,
   uint16_t <code class="par">*defAmpP</code>
)
</pre>
<h4>
  <a name="1000304"> </a>Parameters 
</h4>

<dl>
<dt><a name="1030612"> </a><code>&rarr;  <i>alarmAmpP</i></code></dt>
<dd><a name="1030613"> </a>Pointer to the alarm amplitude.</dd>

<dt><a name="1030614"> </a><code>&rarr;  <i>sysAmpP</i></code></dt>
<dd><a name="1030615"> </a>Pointer to the system sound amplitude.</dd>

<dt><a name="1030616"> </a><code>&rarr;  <i>defAmpP</i></code></dt>
<dd><a name="1030617"> </a>Pointer to the default amplitude for other sounds.</dd>

</dl>
<h4>
  <a name="1000448"> </a>Returns 
</h4>

<p><a name="1030701"> </a>Nothing.</p>
<h4>
  <a name="1000459"> </a>Comments 
</h4>

<p><a name="1030705"> </a>Any of the parameters may be <code>NULL</code>. In that case, the corresponding setting is not altered.</p>

<div><hr>
  <a name="1030711"> </a> <b>NOTE: </b> It is usually not appropriate for an application to be setting the default sound volume levels. Accordingly, this function is rarely used by applications.
<hr>
</div>
<h4>
  <a name="1000470"> </a>See Also 
</h4>

<p><a name="1000476"> </a><a href="MM_SoundRef.html#999253"><code>SndGetDefaultVolume()</code></a></p>

<h3 class="hbH3">
  <a name="1000481"> </a>SndStreamCreate Function <a href="#995984"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="1000492"> </a>Purpose 
</h4>

<p><a name="1030794"> </a>Creates a new audio data stream that can be used to record or play back uncompressed, sampled audio data.</p>
<h4>
  <a name="1000503"> </a>Declared In 
</h4>
<code>SoundMgr.h<a name="1000509"> </a></code><h4>
  <a name="1000514"> </a>Prototype 
</h4>
<pre class="proto"><a name="1000520"></a>status_t SndStreamCreate (
   SndStreamRef <code class="par">*channel</code>,
   SndStreamMode <code class="par">mode</code>,
   uint32_t <code class="par">samplerate</code>,
   SndSampleType <code class="par">type</code>,
   SndStreamWidth <code class="par">width</code>,
   SndStreamBufferCallback <code class="par">func</code>,
   void <code class="par">*userdata</code>,
   uint32_t <code class="par">buffsize</code>
)
</pre>
<h4>
  <a name="1000525"> </a>Parameters 
</h4>

<dl>
<dt><a name="1030816"> </a><code>&larr;  <i><code>channel</code></i></code></dt>
<dd><a name="1030817"> </a>Token that represents the newly created stream.</dd>

<dt><a name="1030818"> </a><code>&rarr;  <i><code>mode</code></i></code></dt>
<dd><a name="1030822"> </a>One of the <a href="MM_SoundRef.html#998115"><code>SndStreamMode</code></a> constants that represents the "direction" of the data stream. Either <code>sndInput</code> (for recording), or <code>sndOutput</code> (for playback).</dd>

<dt><a name="1030823"> </a><code>&rarr;  <i><code>samplerate</code></i></code></dt>
<dd><a name="1030824"> </a>Sampling rate, in frames-per-second. Specify the native rate of the data, such as 22050, 44100, or 48000.</dd>

<dt><a name="1030825"> </a><code>&rarr;  <i><code>type</code></i></code></dt>
<dd><a name="1031047"> </a>Sample quantization and endianness (but see the section on "<a href="MM_SoundRef.html#1031597">Data Formats</a>," below). Supply one of the values documented under <a href="MM_SoundRef.html#1039255">"audio_type_t."</a></dd>

<dt><a name="1030833"> </a><code>&rarr;  <i><code>width</code></i></code></dt>
<dd><a name="1030834"> </a>One of the constants documented under <a href="MM_SoundRef.html#998185">"SndStreamWidth"</a> that represents the number of channels of data in the stream.</dd>

<dt><a name="1030838"> </a><code>&rarr;  <i>func</i></code></dt>
<dd><a name="1030839"> </a>A callback function that gets called when another buffer is needed. See <a href="MM_SoundRef.html#1002708"><code>SndStreamBufferCallback()</code></a> for a description of the callback function that you must implement.</dd>

<dt><a name="1030843"> </a><code>&rarr;  <i>userdata</i></code></dt>
<dd><a name="1030844"> </a>Caller-defined data that is passed to the callback function.</dd>

<dt><a name="1030845"> </a><code>&rarr;  <i><code>buffsize</code></i></code></dt>
<dd><a name="1030846"> </a>Preferred size (in frames) for the buffers that are passed to the callback function, <code class="par">func</code>. Note that the actual buffer size (as allocated by the Sound Manager) may be different from this request.</dd>

</dl>
<h4>
  <a name="1000618"> </a>Returns 
</h4>

<p><a name="1031586"> </a><code>errNone</code> if the operation completed successfully, or one of the following if an error occurs:</p>

<dl>
<dt><a name="1031587"> </a><code><code>sndErrBadParam</code></code></dt>
<dd><a name="1031588"> </a><code class="par">channel</code> is invalid, <code class="par">func</code> is <code>NULL</code>, the sampling rate is too high (greater than 96000), or the device doesn't support some other specified sound parameter value.</dd>

<dt><a name="1031589"> </a><code><code>sndErrMemory</code></code></dt>
<dd><a name="1031590"> </a>All streams are being used (there is a maximum of 16), or memory for this stream couldn't otherwise be allocated.</dd>

<dt><a name="1031591"> </a><code>other errors</code></dt>
<dd><a name="1031592"> </a>The device couldn't allocate system resources for the stream.</dd>

</dl>
<h4>
  <a name="1031593"> </a>Comments 
</h4>

<p><a name="1031594"> </a>This function creates a new audio stream into which you can write (playback) or from which you can read (record) buffers of uncompressed, sampled audio data. The stream's "direction"&#8212;whether it will be used for recording or playback&#8212;is described by the <code class="par">mode</code> argument. </p>

<p><a name="1031595"> </a>You can create one input stream and as many as 15 output streams. The "active" end of a stream is hardwired to read from or write to the device's sound driver. This means you can't "redirect" an input stream to read from a file (for example), nor can you connect one output stream to another output stream in an attempt to create a filter chain. You can, however, collect data from the input stream, manipulate it, and then write it to an output stream. </p>

<h4 class="hcH4">
  <a name="1031597"> </a>Data Formats
</h4>

<p><a name="1031598"> </a>The format of the data that flows through the stream is described by the <code class="par">sampleRate</code>, <code class="par">type</code>, and <code class="par">width</code> arguments. If you're using an "extended" stream (see <a href="MM_SoundRef.html#1000651"><code>SndStreamCreateExtended()</code></a>), you can also declare the data's encoding.</p>

<p><a name="1031605"> </a>If you look at the <a href="MM_SoundRef.html#1039255">audio_type_t</a> constants, you'll see four flavors for each quantization type: a big-endian version, a little-endian version, a native-endian version (defined as one of the other two), and an "opposite" version, which has endianness opposite that of the native version. In general, you should use the native-endian version when choosing a value for the <code class="par">type</code> parameter. </p>

<h4 class="hcH4">
  <a name="1031606"> </a>Running the Stream
</h4>

<p><a name="1031607"> </a>The new stream starts running when you pass the <code class="par">channel</code> token returned by this function to the <a href="MM_SoundRef.html#1001672"><code>SndStreamStart()</code></a> function. This initiates a series of calls to your callback function (the <code class="par">func</code> parameter), which is where the action is: Each callback invocation is passed a buffer into which you write or from which you read a chunk of audio data. The callback function is also passed the <code class="par">userdata</code> parameter that you supply here. See <a href="MM_SoundRef.html#1002708"><code>SndStreamBufferCallback()</code></a> for more information on the callback function.</p>

<h4 class="hcH4">
  <a name="1031614"> </a>Buffering and Latency
</h4>

<p><a name="1031615"> </a>Currently, audio streams are double-buffered. With regard to playback, this means that while one buffer (buffer A) is being played, your callback function is placing data in the other buffer (B). When A is "empty," the Sound Manager seamlessly starts playing buffer B, and passes buffer A back to your callback; when B is empty, it starts playing A, and passes back B, and so on. It's important that your callback function fills the data buffers as quickly as possible&#8212;certainly no longer than it takes to play a buffer of data. This same double-buffer scheme is also applied to sound recording although, of course, for recording you're emptying each buffer (and doing something with the data) in your callback function.</p>

<p><a name="1031616"> </a>Regarding latency, you can use the <code class="par">buffsize</code> argument to suggest a buffer size and thereby increase or decrease latency, but you can't change the number of buffers. Keep in mind that the actual buffer size that's used may not be the same as the size you suggest; hardware and memory limitations may enforce a maximum or minimum buffer size. Also keep in mind that the buffer size is measured in frames (not bytes).</p>
<h4>
  <a name="1031617"> </a>See Also 
</h4>

<p><a name="1031624"> </a><a href="MM_SoundRef.html#1001672"><code>SndStreamStart()</code></a>, <a href="MM_SoundRef.html#1000831"><code>SndStreamDelete()</code></a>, <a href="MM_SoundRef.html#1002708"><code>SndStreamBufferCallback()</code></a></p>

<h3 class="hbH3">
  <a name="1000651"> </a>SndStreamCreateExtended Function <a href="#995984"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="1000662"> </a>Purpose 
</h4>

<p><a name="1044480"> </a>Creates a new audio data stream that can be used to record or play back audio data. </p>
<h4>
  <a name="1044481"> </a>Declared In 
</h4>
<code>SoundMgr.h<a name="1000679"> </a></code><h4>
  <a name="1000684"> </a>Prototype 
</h4>
<pre class="proto"><a name="1000690"></a>status_t SndStreamCreateExtended (
   SndStreamRef <code class="par">*channel</code>,
   SndStreamMode <code class="par">mode</code>,
   SndFormatType <code class="par">format</code>,
   uint32_t <code class="par">samplerate</code>,
   SndSampleType <code class="par">type</code>,
   SndStreamWidth <code class="par">width</code>,
   SndStreamVariableBufferCallback <code class="par">func</code>,
   void <code class="par">*userdata</code>,
   uint32_t <code class="par">buffsize</code>
)
</pre>
<h4>
  <a name="1000695"> </a>Parameters 
</h4>

<dl>
<dt><a name="1032658"> </a><code>&larr;  <i><code>channel</code></i></code></dt>
<dd><a name="1032659"> </a>Token that represents the newly created stream.</dd>

<dt><a name="1032660"> </a><code>&rarr;  <i><code>mode</code></i></code></dt>
<dd><a name="1032664"> </a>One of the <a href="MM_SoundRef.html#998115"><code>SndStreamMode</code></a> constants that represents the "direction" of the data stream. Either <code>sndInput</code> (for recording), or <code>sndOutput</code> (for playback).</dd>

<dt><a name="1032665"> </a><code>&rarr;  <i><code>format</code></i></code></dt>
<dd><a name="1032666"> </a>Constant that represents the encoding format of the data that you propose to pour through the stream. See <a href="MM_SoundRef.html#1046668">"SndFormatType,"</a> for a list of eligible values. Currently, only <code>sndFormatPCM</code> is supported. </dd>

<dt><a name="1032670"> </a><code>&rarr;  <i><code>sampleRate</code></i></code></dt>
<dd><a name="1032671"> </a>Sampling rate, in frames-per-second. Specify the native rate of the data, such as 22050, 44100, or 48000. The maximum rate is 96000.</dd>

<dt><a name="1032672"> </a><code>&rarr;  <i><code>type</code></i></code></dt>
<dd><a name="1032675"> </a>Sample quantization and endianness (see <a href="MM_SoundRef.html#1031597">"Data Formats"</a> for advice on choosing this value). Supply one of the values documented under <a href="MM_SoundRef.html#1039255">"audio_type_t."</a></dd>

<dt><a name="1033012"> </a><code>&rarr;  <i><code>width</code></i></code></dt>
<dd><a name="1033013"> </a>One of the constants documented under <a href="MM_SoundRef.html#998185">"SndStreamWidth"</a> that represents the number of channels of data in the stream.</dd>

<dt><a name="1032685"> </a><code>&rarr;  <i><code>func</code></i></code></dt>
<dd><a name="1032686"> </a>A callback function that gets called when another buffer of data is needed. As implied by the name of the data type, the function accepts variable-sized buffers. See <a href="MM_SoundRef.html#1002839"><code>SndStreamVariableBufferCallback()</code></a> for a description of the callback function that you must implement.</dd>

<dt><a name="1032690"> </a><code>&rarr;  <i>userdata</i></code></dt>
<dd><a name="1032691"> </a>Caller-defined data that is passed to the callback function.</dd>

<dt><a name="1032692"> </a><code>&rarr;  <i><code>buffsize</code></i></code></dt>
<dd><a name="1032693"> </a>Preferred size (in frames) for the buffers that are passed to the callback function, <code class="par">func</code>. Note that the actual buffer size (as allocated by the Sound Manager) may be different from this request.</dd>

</dl>
<h4>
  <a name="1032696"> </a>Returns 
</h4>

<p><a name="1032697"> </a><code>errNone</code> if the operation completed successfully, or one of the following if there an error occurs:</p>

<dl>
<dt><a name="1032698"> </a><code><code>sndErrBadParam</code></code></dt>
<dd><a name="1032699"> </a><code class="par">channel</code> is invalid, <code class="par">func</code> is <code>NULL</code>, the sampling rate is too high (greater than 96000), or the device doesn't support some other specified sound parameter value.</dd>

<dt><a name="1032700"> </a><code><code>sndErrMemory</code></code></dt>
<dd><a name="1032701"> </a>All streams are being used (there is a maximum of 16), or memory for this stream couldn't otherwise be allocated.</dd>

<dt><a name="1032702"> </a><code>other errors</code></dt>
<dd><a name="1032703"> </a>The device couldn't allocate system resources for the stream.</dd>

</dl>
<h4>
  <a name="1032704"> </a>Comments 
</h4>

<p><a name="1032705"> </a>With a few minor exceptions, this function is equivalent to <a href="MM_SoundRef.html#1000481"><code>SndStreamCreate()</code></a>; see that function's Comments section for a description of how the stream creation functions generally work.</p>

<p><a name="1032709"> </a>One difference between standard and extended streams: If you're using an extended stream, you can also declare the data's encoding. When selecting that encoding, be aware of the following:</p>
<ul type="disc">
  <li><a name="1032710"> </a>The data format that you specify for an input stream must match the data that's produced by the audio hardware. 
  <li><a name="1032711"> </a>For an output stream, you can specify any of the formats that the Sound Manager supports; the data is automatically converted to the output hardware's native audio format. Whether your stream's format setting actually affects the hardware is undefined. For example, if you set an output stream to use a 48k sampling rate, that doesn't mean that the DAC will be set to 48k.
  <li><a name="1032712"> </a>Currently, only <code>sndFormatPCM</code> is supported.
</ul>

<p><a name="1032713"> </a>Extended streams also allow for variable-sized buffers, as opposed to the fixed-sized buffers used by <code>SndStreamCreate()</code>.This enables support for variable-length encoded data (such as MP3). To accommodate the variable-sized buffer, the callback function's prototype changes slightly for an extended stream: see <a href="MM_SoundRef.html#1002839"><code>SndStreamVariableBufferCallback()</code></a> for a full description of the callback function you use with <code>SndStreamCreateExtended()</code>.</p>

<h3 class="hbH3">
  <a name="1000831"> </a>SndStreamDelete Function <a href="#995984"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="1000842"> </a>Purpose 
</h4>

<p><a name="1034023"> </a>Stops the stream and deletes it. </p>
<h4>
  <a name="1000853"> </a>Declared In 
</h4>
<code>SoundMgr.h<a name="1000859"> </a></code><h4>
  <a name="1000864"> </a>Prototype 
</h4>
<pre class="proto"><a name="1000870"></a>status_t SndStreamDelete (
   SndStreamRef <code class="par">channel</code>
)
</pre>
<h4>
  <a name="1000875"> </a>Parameters 
</h4>

<dl>
<dt><a name="1000881"> </a><code>&rarr;  <i>channel</i></code></dt>
<dd><a name="1034062"> </a>Stream token, as returned from <a href="MM_SoundRef.html#1000481"><code>SndStreamCreate()</code></a> or <a href="MM_SoundRef.html#1000651"><code>SndStreamCreateExtended()</code></a>.</dd>

</dl>
<h4>
  <a name="1000891"> </a>Returns 
</h4>

<p><a name="1034179"> </a><code>errNone</code> if the operation completed successfully. Returns <code>sndErrBadParam</code> if the <code class="par">channel</code> argument is invalid.</p>
<h4>
  <a name="1000902"> </a>Comments 
</h4>

<p><a name="1034218"> </a><code>SndStreamDelete()</code> calls <a href="MM_SoundRef.html#1002040"><code>SndStreamStop()</code></a> before deleting the stream. You should never call <code>SndStreamDelete()</code> from within your callback function.</p>

<h3 class="hbH3">
  <a name="1034397"> </a>SndStreamGetPan Function <a href="#995984"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="1034399"> </a>Purpose 
</h4>

<p><a name="1034424"> </a>Retrieves a stream's stereo balance.</p>
<h4>
  <a name="1001076"> </a>Declared In 
</h4>
<code>SoundMgr.h<a name="1001082"> </a></code><h4>
  <a name="1001087"> </a>Prototype 
</h4>
<pre class="proto"><a name="1001093"></a>status_t SndStreamGetPan (
   SndStreamRef <code class="par">channel</code>,
   int32_t <code class="par">*panposition</code>
)
</pre>
<h4>
  <a name="1001098"> </a>Parameters 
</h4>

<dl>
<dt><a name="1001104"> </a><code>&rarr;  <i>channel</i></code></dt>
<dd><a name="1034443"> </a>Stream token, as returned from <a href="MM_SoundRef.html#1000481"><code>SndStreamCreate()</code></a> or <a href="MM_SoundRef.html#1000651"><code>SndStreamCreateExtended()</code></a>.</dd>

<dt><a name="1001114"> </a><code>&larr;  <i>panposition</i></code></dt>
<dd><a name="1034454"> </a>Pan value in the range [-1024 (extreme left), 1024 (extreme right)]. Center balance is 0.</dd>

</dl>
<h4>
  <a name="1001124"> </a>Returns 
</h4>

<p><a name="1034485"> </a><code>errNone</code> if the operation completed successfully. Returns <code>sndErrBadParam</code> if <code class="par">channel</code> is invalid or <code class="par">panposition</code> is <code>NULL</code>. </p>
<h4>
  <a name="1001163"> </a>See Also 
</h4>

<p><a name="1001176"> </a><a href="MM_SoundRef.html#1001442"><code>SndStreamSetPan()</code></a></p>

<h3 class="hbH3">
  <a name="1001203"> </a>SndStreamGetVolume Function <a href="#995984"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="1001238"> </a>Purpose 
</h4>

<p><a name="1034688"> </a>Retrieves the amplitude scalar for a sound stream.</p>
<h4>
  <a name="1001249"> </a>Declared In 
</h4>
<code>SoundMgr.h<a name="1001255"> </a></code><h4>
  <a name="1001260"> </a>Prototype 
</h4>
<pre class="proto"><a name="1001266"></a>status_t SndStreamGetVolume (
   SndStreamRef <code class="par">channel</code>,
   int32_t <code class="par">*volume</code>
)
</pre>
<h4>
  <a name="1001271"> </a>Parameters 
</h4>

<dl>
<dt><a name="1001277"> </a><code>&rarr;  <i>channel</i></code></dt>
<dd><a name="1034929"> </a>Stream token, as returned from <a href="MM_SoundRef.html#1000481"><code>SndStreamCreate()</code></a> or <a href="MM_SoundRef.html#1000651"><code>SndStreamCreateExtended()</code></a>.</dd>

<dt><a name="1034916"> </a><code>&larr;  <i><code>volume</code></i></code></dt>
<dd><a name="1034917"> </a>Amplitude scalar, in the range [0, 32k]. See <a href="MM_SoundRef.html#1001569"><code>SndStreamSetVolume()</code></a> for more information.</dd>

</dl>
<h4>
  <a name="1001297"> </a>Returns 
</h4>

<p><a name="1034936"> </a><code>errNone</code> if the operation completed successfully. Returns <code>sndErrBadParam</code> if <code class="par">channel</code> is invalid or <code class="par">volume</code> is <code>NULL</code>.</p>
<h4>
  <a name="1001319"> </a>See Also 
</h4>

<p><a name="1001325"> </a><a href="MM_SoundRef.html#1001569"><code>SndStreamSetVolume()</code></a></p>

<h3 class="hbH3">
  <a name="1001330"> </a>SndStreamPause Function <a href="#995984"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="1001341"> </a>Purpose 
</h4>

<p><a name="1035074"> </a>Pauses or resumes a sample stream.</p>
<h4>
  <a name="1001352"> </a>Declared In 
</h4>
<code>SoundMgr.h<a name="1001358"> </a></code><h4>
  <a name="1001363"> </a>Prototype 
</h4>
<pre class="proto"><a name="1001369"></a>status_t SndStreamPause (
   SndStreamRef <code class="par">channel</code>,
   Boolean <code class="par">pause</code>
)
</pre>
<h4>
  <a name="1001374"> </a>Parameters 
</h4>

<dl>
<dt><a name="1001380"> </a><code>&rarr;  <i>channel</i></code></dt>
<dd><a name="1035100"> </a>Stream token, as returned from <a href="MM_SoundRef.html#1000481"><code>SndStreamCreate()</code></a> or <a href="MM_SoundRef.html#1000651"><code>SndStreamCreateExtended()</code></a>.</dd>

<dt><a name="1001390"> </a><code>&rarr;  <i>pause</i></code></dt>
<dd><a name="1035119"> </a>If <code>true</code>, the function pauses the stream; if <code>false</code>, it resumes the stream</dd>

</dl>
<h4>
  <a name="1035120"> </a>Returns 
</h4>

<p><a name="1035121"> </a><code>errNone</code> if the operation completed successfully (which includes the situation where the stream is already in the requested state). Returns <code>sndErrBadParam</code> if <code class="par">channel</code> is invalid.</p>
<h4>
  <a name="1035122"> </a>Comments 
</h4>

<p><a name="1035126"> </a>Currently, <code>SndStreamPause()</code> simply calls <a href="MM_SoundRef.html#1002040"><code>SndStreamStop()</code></a> (if <code>pause</code> is <code>true</code>) or <a href="MM_SoundRef.html#1001672"><code>SndStreamStart()</code></a> (if <code>pause</code> is <code>false</code>). See those functions for details about "pausing" and "resuming" a sound stream.</p>

<p><a name="1035130"> </a>You can't nest pauses; a single resume request is effective, regardless of the number of times the stream has been told to pause.</p>

<h3 class="hbH3">
  <a name="1001442"> </a>SndStreamSetPan Function <a href="#995984"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="1001477"> </a>Purpose 
</h4>

<p><a name="1035264"> </a>Sets a stream's stereo balance.</p>
<h4>
  <a name="1001488"> </a>Declared In 
</h4>
<code>SoundMgr.h<a name="1001494"> </a></code><h4>
  <a name="1001499"> </a>Prototype 
</h4>
<pre class="proto"><a name="1001505"></a>status_t SndStreamSetPan (
   SndStreamRef <code class="par">channel</code>,
   int32_t <code class="par">panposition</code>
)
</pre>
<h4>
  <a name="1001510"> </a>Parameters 
</h4>

<dl>
<dt><a name="1001516"> </a><code>&rarr;  <i>channel</i></code></dt>
<dd><a name="1035295"> </a>Stream token, as returned from <a href="MM_SoundRef.html#1000481"><code>SndStreamCreate()</code></a> or <a href="MM_SoundRef.html#1000651"><code>SndStreamCreateExtended()</code></a>.</dd>

<dt><a name="1001526"> </a><code>&rarr;  <i>panposition</i></code></dt>
<dd><a name="1035313"> </a>Pan value in the range [-1024 (full left), 1024 (full right)]. Center balance is 0. As a convenience, you can use the values described in <a href="MM_SoundRef.html#1016875">"Stereo Pan Constants."</a>" Note that values outside of the valid range may yield unexpected results (but don't generate an error).</dd>

</dl>
<h4>
  <a name="1035317"> </a>Returns 
</h4>

<p><a name="1035318"> </a><code>errNone</code> if the operation completed successfully. Returns <code>sndErrBadParam</code> if <code class="par">channel</code> is invalid.</p>
<h4>
  <a name="1035319"> </a>Comments 
</h4>

<p><a name="1035320"> </a>The pan value is used as a scalar on a channel's volume such that a channel increases from 0 (inaudible) to full volume as the pan value moves from an extreme to 0. Graphically, it looks like this:</p>
<div align="left"><img src="images/MM_SoundRefd.jpg" height="233" width="480" border="0" hspace="0" vspace="0">
</div>
<h4>
  <a name="1001558"> </a>See Also 
</h4>

<p><a name="1001564"> </a><a href="MM_SoundRef.html#1034397"><code>SndStreamGetPan()</code></a></p>

<h3 class="hbH3">
  <a name="1001569"> </a>SndStreamSetVolume Function <a href="#995984"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="1001580"> </a>Purpose 
</h4>

<p><a name="1035561"> </a>Sets the amplitude scalar for a sound stream.</p>
<h4>
  <a name="1001591"> </a>Declared In 
</h4>
<code>SoundMgr.h<a name="1001597"> </a></code><h4>
  <a name="1001602"> </a>Prototype 
</h4>
<pre class="proto"><a name="1001608"></a>status_t SndStreamSetVolume (
   SndStreamRef <code class="par">channel</code>,
   int32_t <code class="par">volume</code>
)
</pre>
<h4>
  <a name="1001613"> </a>Parameters 
</h4>

<dl>
<dt><a name="1001619"> </a><code>&rarr;  <i>channel</i></code></dt>
<dd><a name="1035624"> </a>Stream token, as returned from <a href="MM_SoundRef.html#1000481"><code>SndStreamCreate()</code></a> or <a href="MM_SoundRef.html#1000651"><code>SndStreamCreateExtended()</code></a>.</dd>

<dt><a name="1001629"> </a><code>&rarr;  <i>volume</i></code></dt>
<dd><a name="1035683"> </a>Amplitude scalar in the range [0, 32k]. Values less than 0 are converted to 1024 (unity gain).</dd>

</dl>
<h4>
  <a name="1035684"> </a>Returns 
</h4>

<p><a name="1035685"> </a><code>errNone</code> if the operation completed successfully. Returns <code>sndErrBadParam</code> if <code class="par">channel</code> is invalid.</p>
<h4>
  <a name="1035686"> </a>Comments 
</h4>

<p><a name="1035687"> </a>The <code class="par">volume</code> value is applied as an amplitude scalar on the samples that this stream's callback function produces. The scalar is in the range [0, 32k], where 1024 is unity gain (that is, the samples are multiplied by 1.0). The mapping of <code class="par">volume</code> to a scalar is linear; thus a <code class="par">volume</code> of 512 scales the samples by ~0.5, and 2048 scales by ~2.0, and so on.</p>

<p><a name="1035688"> </a>To specify a user preference volume setting, supply one of the constants documented under <a href="MM_SoundRef.html#998633">"Volume Constants."</a> These values are guaranteed to be less than unity gain.</p>

<p><a name="1035692"> </a>If the stream is stereo, both channels are scaled by the same amplitude scalar. To adjust the balance between the channels, use <a href="MM_SoundRef.html#1001442"><code>SndStreamSetPan()</code></a>.</p>
<h4>
  <a name="1001661"> </a>See Also 
</h4>

<p><a name="1001667"> </a><a href="MM_SoundRef.html#1001203"><code>SndStreamGetVolume()</code></a></p>

<h3 class="hbH3">
  <a name="1001672"> </a>SndStreamStart Function <a href="#995984"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="1001683"> </a>Purpose 
</h4>

<p><a name="1035844"> </a>Starts a sample stream running.</p>
<h4>
  <a name="1001694"> </a>Declared In 
</h4>
<code>SoundMgr.h<a name="1001700"> </a></code><h4>
  <a name="1001705"> </a>Prototype 
</h4>
<pre class="proto"><a name="1001740"></a>status_t SndStreamStart (
   SndStreamRef <code class="par">channel</code>
)
</pre>
<h4>
  <a name="1001775"> </a>Parameters 
</h4>

<dl>
<dt><a name="1001831"> </a><code>&rarr;  <i>channel</i></code></dt>
<dd><a name="1035859"> </a>Stream token, as returned from <a href="MM_SoundRef.html#1000481"><code>SndStreamCreate()</code></a> or <a href="MM_SoundRef.html#1000651"><code>SndStreamCreateExtended()</code></a>.</dd>

</dl>
<h4>
  <a name="1001951"> </a>Returns 
</h4>

<p><a name="1035874"> </a><code>errNone</code> if the operation completed successfully (<code>errNone</code> is returned even if the stream is already running). Returns <code>sndErrBadParam</code> if <code class="par">channel</code> is invalid.</p>
<h4>
  <a name="1035875"> </a>Comments 
</h4>

<p><a name="1035876"> </a>If the stream is already running, <code>SndStreamStart()</code> returns immediately (with <code>errNone</code>). If it isn't running, the function starts the stream by initiating invocations of its callback function. If the stream is paused (through <a href="MM_SoundRef.html#1001330"><code>SndStreamPause()</code></a>), the stream is resumed.</p>

<p><a name="1035880"> </a>You can call this function from within another stream's callback function. This allows one stream to tell another stream to start playing.</p>
<h4>
  <a name="1002029"> </a>See Also 
</h4>

<p><a name="1002035"> </a><a href="MM_SoundRef.html#1002040"><code>SndStreamStop()</code></a></p>

<h3 class="hbH3">
  <a name="1002040"> </a>SndStreamStop Function <a href="#995984"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="1002051"> </a>Purpose 
</h4>

<p><a name="1036111"> </a>Stops a sample stream from running.</p>
<h4>
  <a name="1002062"> </a>Declared In 
</h4>
<code>SoundMgr.h<a name="1002068"> </a></code><h4>
  <a name="1002073"> </a>Prototype 
</h4>
<pre class="proto"><a name="1002079"></a>status_t SndStreamStop (
   SndStreamRef <code class="par">channel</code>
)
</pre>
<h4>
  <a name="1002084"> </a>Parameters 
</h4>

<dl>
<dt><a name="1002090"> </a><code>&rarr;  <i>channel</i></code></dt>
<dd><a name="1036076"> </a>Stream token, as returned from <a href="MM_SoundRef.html#1000481"><code>SndStreamCreate()</code></a> or <a href="MM_SoundRef.html#1000651"><code>SndStreamCreateExtended()</code></a>.</dd>

</dl>
<h4>
  <a name="1002100"> </a>Returns 
</h4>

<p><a name="1036137"> </a><code>errNone</code> if the operation completed successfully (<code>errNone</code> is returned even if the stream is already stopped). Returns <code>sndErrBadParam</code> if <code class="par">channel</code> is invalid.</p>
<h4>
  <a name="1036138"> </a>Comments 
</h4>

<p><a name="1036139"> </a>Stops a running sound stream by neglecting to call the stream's callback function. The stream remains in this suspended state until you call <a href="MM_SoundRef.html#1001672"><code>SndStreamStart()</code></a>.</p>

<p><a name="1036143"> </a>You can call this function from the stream's own callback function. In other words, a stream can stop itself.</p>

<h2 class="haH2">
  <a name="1002133"> </a>Application-Defined Functions <a href="#995984"><span class="nav">^TOP^</span></a>
</h2>


<h3 class="hbH3">
  <a name="1002200"> </a>SndBlockingFuncType Function <a href="#995984"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="1002211"> </a>Purpose 
</h4>

<p><a name="1036649"> </a>A callback function that is invoked periodically during SMF playback. </p>
<h4>
  <a name="1002222"> </a>Declared In 
</h4>
<code>SoundMgr.h<a name="1002228"> </a></code><h4>
  <a name="1002233"> </a>Prototype 
</h4>
<pre class="proto"><a name="1002239"></a>Boolean SndBlockingFuncType (
   void <code class="par">*chanP</code>,
   uint32_t <code class="par">dwUserData</code>,
   int32_t <code class="par">sysTicksAvailable</code>
)
</pre>
<pre class="proto"><a name="1003521"></a>typedef SndBlockingFuncType *SndBlockingFuncPtr
</pre>
<h4>
  <a name="1002244"> </a>Parameters 
</h4>

<dl>
<dt><a name="1036672"> </a><code>&rarr;  <i><code>chanP</code></i></code></dt>
<dd><a name="1036673"> </a>A pointer to the sound channel on which the file is being played. Currently always <code>NULL</code>.</dd>

<dt><a name="1036674"> </a><code>&rarr;  <i><code>dwUserData</code></i></code></dt>
<dd><a name="1036675"> </a>Application-defined data that's specified when the callback function is registered.</dd>

<dt><a name="1036676"> </a><code>&rarr;  <i>sysTicksAvailable</i></code></dt>
<dd><a name="1036677"> </a>The amount of time, in milliseconds, available for completion of this function. </dd>

</dl>
<h4>
  <a name="1002530"> </a>Returns 
</h4>

<p><a name="1036740"> </a>Return <code>true</code> from your callback function if playback is to continue. Return <code>false</code> if playback is to be aborted.</p>
<h4>
  <a name="1036741"> </a>Comments 
</h4>

<p><a name="1036742"> </a>Your application's blocking callback is called whenever the MIDI parser is "between notes." Your application can do whatever it wants during this period, as long as it doesn't take more than <code class="par">sysTicksAvailable</code> milliseconds.</p>

<p><a name="1036743"> </a>Specify your blocking callback function using the <code>blocking</code> field of the <a href="MM_SoundRef.html#996835"><code>SndSmfCallbacksType</code></a> structure that you pass to <a href="MM_SoundRef.html#999486"><code>SndPlaySmf()</code></a>. Note that the <code>blocking</code> field is a <a href="MM_SoundRef.html#996061"><code>SndCallbackInfoType</code></a> structure; it contains a pointer to your callback function and a 32-bit value that is passed, as-is, to your callback.</p>
<h4>
  <a name="1036753"> </a>See Also 
</h4>

<p><a name="1036757"> </a><a href="MM_SoundRef.html#1002563"><code>SndComplFuncType()</code></a></p>

<h3 class="hbH3">
  <a name="1002563"> </a>SndComplFuncType Function <a href="#995984"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="1002574"> </a>Purpose 
</h4>

<p><a name="1036834"> </a>A callback function that is invoked immediately after a MIDI file (SMF) finishes playing.</p>
<h4>
  <a name="1002585"> </a>Declared In 
</h4>
<code>SoundMgr.h<a name="1002591"> </a></code><h4>
  <a name="1002596"> </a>Prototype 
</h4>
<pre class="proto"><a name="1002602"></a>void SndComplFuncType (
   void <code class="par">*chanP</code>,
   uint32_t <code class="par">dwUserData</code>
)
</pre>
<pre class="proto"><a name="1004321"></a>typedef SndComplFuncType *SndComplFuncPtr
</pre>
<h4>
  <a name="1002607"> </a>Parameters 
</h4>

<dl>
<dt><a name="1036838"> </a><code>&rarr;  <i><code>chanP</code></i></code></dt>
<dd><a name="1036839"> </a>A pointer to the sound channel on which the file was playing. Currently always <code>NULL</code>.</dd>

<dt><a name="1036840"> </a><code>&rarr;  <i><code>dwUserData</code></i></code></dt>
<dd><a name="1036841"> </a>Application-defined data that's specified when the callback function is registered.</dd>

</dl>
<h4>
  <a name="1002640"> </a>Returns 
</h4>

<p><a name="1002648"> </a>Return nothing.</p>
<h4>
  <a name="1002661"> </a>Comments 
</h4>

<p><a name="1036916"> </a>Specify your blocking callback function using the <code>completion</code> field of the <a href="MM_SoundRef.html#996835"><code>SndSmfCallbacksType</code></a> structure that you pass to <a href="MM_SoundRef.html#999486"><code>SndPlaySmf()</code></a>. Note that the <code>completion</code> field is a <a href="MM_SoundRef.html#996061"><code>SndCallbackInfoType</code></a> structure; it contains a pointer to your callback function and a 32-bit value that is passed, as-is, to your callback.</p>
<h4>
  <a name="1002681"> </a>See Also 
</h4>

<p><a name="1002695"> </a><a href="MM_SoundRef.html#1002200"><code>SndBlockingFuncType()</code></a></p>

<h3 class="hbH3">
  <a name="1002708"> </a>SndStreamBufferCallback Function <a href="#995984"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="1002727"> </a>Purpose 
</h4>

<p><a name="1036219"> </a>In input mode, delivers a data buffer to your application. In output mode, allows your application to supply the next buffer's worth of data.</p>
<h4>
  <a name="1002738"> </a>Declared In 
</h4>
<code>SoundMgr.h<a name="1002744"> </a></code><h4>
  <a name="1002749"> </a>Prototype 
</h4>
<pre class="proto"><a name="1002755"></a>status_t (
   *SndStreamBufferCallback
) (
   void <code class="par">*userdata</code>,
   SndStreamRef <code class="par">channel</code>,
   void <code class="par">*buffer</code>,
   uint32_t <code class="par">numberofframes</code>
)
</pre>
<h4>
  <a name="1002760"> </a>Parameters 
</h4>

<dl>
<dt><a name="1036232"> </a><code>&rarr;  <i><code>userdata</code></i></code></dt>
<dd><a name="1036233"> </a>Caller-defined data, as provided in the <code class="par">userdata</code> parameter to <a href="MM_SoundRef.html#1000481"><code>SndStreamCreate()</code></a>.</dd>

<dt><a name="1036237"> </a><code>&rarr;  <i><code>channel</code></i></code></dt>
<dd><a name="1036238"> </a>Token that represents the stream to which this buffer belongs.</dd>

<dt><a name="1036239"> </a><code>&rarr;  <i><code>buffer</code></i></code></dt>
<dd><a name="1036240"> </a>The data buffer.</dd>

<dt><a name="1036241"> </a><code>&rarr;  <i><code>numberofframes</code></i></code></dt>
<dd><a name="1036242"> </a>Number of sample frames the buffer contains.</dd>

</dl>
<h4>
  <a name="1036243"> </a>Returns 
</h4>

<p><a name="1036244"> </a>Currently, the return value is ignored.</p>
<h4>
  <a name="1036245"> </a>Comments 
</h4>

<p><a name="1036246"> </a>The <code>SndStreamBufferCallback()</code> function that you create is invoked in input (recording) mode when the Sound Manager wants to deliver a new buffer of sound data to your application. In output (playback) mode, it is invoked when the Sound Manager needs another buffer of sound data. You associate your callback function with a given stream when you call <a href="MM_SoundRef.html#1000481"><code>SndStreamCreate()</code></a>.</p>

<p><a name="1036250"> </a>In input mode, your callback function should read the data from the data buffer. In output mode, your callback function should write data into the data buffer (and it must fill the entire buffer with data). In either case, you want to do this as quickly as possible to avoid data underflow.</p>

<p><a name="1036251"> </a>Note that the arguments passed to your callback function tell you nothing about the format of the data. You can use the <code class="par">userdata</code> argument to pass that information into the function.</p>
<h4>
  <a name="1002828"> </a>See Also 
</h4>

<p><a name="1002834"> </a><a href="MM_SoundRef.html#1002839"><code>SndStreamVariableBufferCallback()</code></a></p>

<h3 class="hbH3">
  <a name="1002839"> </a>SndStreamVariableBufferCallback Function <a href="#995984"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="1002850"> </a>Purpose 
</h4>

<p><a name="1036460"> </a>In input mode, delivers a variable-length data buffer to your application. In output mode, allows your application to supply the next buffer's worth of data.</p>
<h4>
  <a name="1002861"> </a>Declared In 
</h4>
<code>SoundMgr.h<a name="1002867"> </a></code><h4>
  <a name="1002872"> </a>Prototype 
</h4>
<pre class="proto"><a name="1002878"></a>status_t (
   *SndStreamVariableBufferCallback
) (
   void <code class="par">*userdata</code>,
   SndStreamRef <code class="par">channel</code>,
   void <code class="par">*buffer</code>,
   uint32_t <code class="par">*bufferSizeP</code>
)
</pre>
<h4>
  <a name="1002883"> </a>Parameters 
</h4>

<dl>
<dt><a name="1036478"> </a><code>&rarr;  <i><code>userdata</code></i></code></dt>
<dd><a name="1036543"> </a>Caller-defined data, as provided in the <code class="par">userdata</code> parameter to <a href="MM_SoundRef.html#1000651"><code>SndStreamCreateExtended()</code></a>.</dd>

<dt><a name="1036483"> </a><code>&rarr;  <i><code>channel</code></i></code></dt>
<dd><a name="1036484"> </a>Token that represents the stream that this buffer belongs to.</dd>

<dt><a name="1036485"> </a><code>&rarr;  <i><code>buffer</code></i></code></dt>
<dd><a name="1036486"> </a>The data buffer.</dd>

<dt><a name="1036487"> </a><code>&harr;  <i><code>bufferSizeP</code></i></code></dt>
<dd><a name="1036488"> </a>Size of the buffer, in bytes.</dd>

</dl>
<h4>
  <a name="1036489"> </a>Returns 
</h4>

<p><a name="1036490"> </a>Currently, the return value is ignored.</p>
<h4>
  <a name="1036491"> </a>Comments 
</h4>

<p><a name="1036492"> </a>The <code>SndStreamVariableBufferCallback()</code> function that you create is invoked in input (recording) mode when the Sound Manager wants to deliver a new buffer of sound data to your application. In output (playback) mode, it is invoked when the Sound Manager needs another buffer of sound data. You associate your callback function with a given stream when you call <a href="MM_SoundRef.html#1000651"><code>SndStreamCreateExtended()</code></a>.</p>

<p><a name="1036496"> </a>In input mode, your callback function should read the data from the data buffer. In output mode, your callback function should write data into the data buffer and then reset the value in <code class="par">bufferSizeP</code> to the amount of data that was actually written. Unlike <a href="MM_SoundRef.html#1002708"><code>SndStreamBufferCallback()</code></a>, your callback function is not required to fill the entire buffer with data. Moreover, the data that it writes to the buffer doesn't have to meet any other threshold or requirement&#8212;for example, the buffer doesn't have to represent a certain amount of playback time. This flexibility is provided in order to support variable-length encoded data (such as MP3).</p>

<p><a name="1036500"> </a>Whether your callback is reading from the buffer or writing to it, it should do this as quickly as possible to avoid data underflow.</p>

<p><a name="1036501"> </a>Note that the arguments passed to your callback function tell you nothing about the format of the data. You can use the <code class="par">userdata</code> argument to pass this information into the function.</p>

<p><a name="995980"> </a></p>
&nbsp;<br>
</div>
<!--END CONTENT-->

</td>
<td width="5">&nbsp;&nbsp;</td>
</tr>

</table>

<!-- BEGIN FOOTER -->
<table width="100%" border="0" cellspacing="0" cellpadding="0">
<tr>
<td width="7" rowspan="2"><img name="index_x" src="images/shim.gif" width="7" height="33" border="0" alt=""></td>
<td align="left"><img name="dashes" src="images/dashes.gif" width="744" height="3" border="0" alt=""></td>
<td width="10" rowspan="2"><img name="index_x" src="images/shim.gif" width="10" height="33" border="0" alt=""></td>
</tr>
<tr>
<td align="center">
<p class="footer">
Copyright © 1996&#8211;2004, PalmSource, Inc. and its affiliates. All rights reserved.<br>
<a href="http://www.palmsource.com/contact/">Write Us</a> | <a href="http://www.palmos.com/dev/training/">Training</a> | <a href="http://www.palmos.com/dev/support/kb/">Knowledge Base</a> | <a href="MM_Front.html" target="_blank">Legal</a></p>
<br>
<!--BEGIN BOOK NAVIGATION-->
<p class="nav">
<A href="http://www.palmos.com/dev/support/docs/">Documentation</a>&nbsp;&nbsp;|&nbsp;&nbsp;
<a href="MM_TOC.html">Table of Contents</a>&nbsp;&nbsp;
             |&nbsp;&nbsp;<a href="MM_SoundConcept.html">&lt;&nbsp;Previous</a>&nbsp;&nbsp;
             |&nbsp;&nbsp;<a href="MM_MultimediaPart.html">Next&nbsp;&gt;</a>&nbsp;&nbsp;
             |&nbsp;&nbsp;<a href="MM_IX.html">Index</a>
</p>
</td>
</tr>
</table>
<!-- END FOOTER -->

</body>
</html>