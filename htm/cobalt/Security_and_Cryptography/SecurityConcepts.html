<html>
<head>
<title>(Protein) Palm OS Cobalt Security | Security and Cryptography</title> 
<link href="psi_devpubs.css" rel="stylesheet" type="text/css">

<!-- BEGIN META DATA -->
<meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
<META NAME="PSITEMPLATE" CONTENT="1006-007 PalmSource_HTML_2003 20041101">
<META NAME="GENERATOR" CONTENT="Quadralay WebWorks AutoMap 2003 for FrameMaker 8.0.6.2138">
<META NAME="LASTUPDATED" CONTENT="11/22/04 11:23:15">
<!-- END META DATA -->
</head>

<body bgcolor="#ffffff" text="#000000" leftmargin="0" topmargin="0" marginwidth="0" marginheight="0">
<a name="992896"></a>

<!-- BEGIN TOPNAV -->
<table width="100%" border="0" cellspacing="0" cellpadding="0">
<tr>
<td><img src="images/shim.gif" width="7" height="75" border="0" alt=""></td>
<td align="left"><table border="0" cellpadding="0" cellspacing="0" width="744">
<tr>
<td><img name="index_r2_c1" src="images/shim.gif" width="25" height="75" border="0" alt=""></td>
<td valign="top"><table border="0" cellpadding="0" cellspacing="0" width="96">
<tr>
<td><img name="index_r2_c4" src="images/shim.gif" width="96" height="15" border="0" alt=""></td>
</tr>
<tr>
<td><a href="http://www.palmsource.com/"><img name="ps_logo" src="images/ps_logo.gif" width="96" height="54" border="0" alt=""></a></td>
</tr>

</table>
</td>

<td><table border="0" cellpadding="0" cellspacing="0" width="30">
<td><img name="index_x" src="images/shim.gif" width="30" height="75" border="0" alt=""></td>
</table></td>

<!--BEGIN MASTHEAD-->
<td><table border="0" cellpadding="0" cellspacing="0" width="96">
<tr>
<td><img name="index_x" src="images/shim.gif" width="615" height="5" border="0" alt=""></td>
</tr>
<tr>
<td>
<!--BEGIN BOOK NAVIGATION-->
<span class="nav">
<A href="http://www.palmos.com/dev/support/docs/">Documentation</a>&nbsp;&nbsp;|&nbsp;&nbsp;
<a href="SecurityAndCryptographyTOC.html">Table of Contents</a>&nbsp;&nbsp;
             |&nbsp;&nbsp;<a href="SecurityAndCrypto_Part1.html">&lt;&nbsp;Previous</a>&nbsp;&nbsp;
             |&nbsp;&nbsp;<a href="SslConcepts.html">Next&nbsp;&gt;</a>&nbsp;&nbsp;
             |&nbsp;&nbsp;<a href="SecurityAndCryptographyIX.html">Index</a>
</span>
<!--END BOOK NAVIGATION-->
</tr>
<tr>
<td>
<!--BEGIN PAGE TITLE-->
<h2 class="PageTitle">1 &nbsp;&nbsp;
Palm OS Cobalt Security</h2></td>
<!--END PAGE TITLE-->
</tr>
<tr>
<td>
<!--BEGIN BOOK TITLE-->
<p class="BookTitle">Security and Cryptography</p>
<p class="SubTitle">Exploring Palm OS </p>
<!--END BOOK TITLE-->
</td>
</tr>
<tr>
<td><img name="index_x" src="images/shim.gif" width="615" height="5" border="0" alt=""></td>
</tr>
</table>
</td>
<!--END MASTHEAD-->
</tr>
</table>
<img name="dashes" src="images/dashes.gif" width="744" height="3" border="0" alt=""></td>
</tr>
</table>
<!-- END TOPNAV -->

<table width="100%" border="0" cellspacing="0" cellpadding="0">
<tr>
<td valign="top" width="5"><img name="index_x" src="images/shim.gif" width="5" height="33" border="0" alt=""></td>

<!--BEGIN SIDETOC-->
<td valign="top" width="175">
<div id="sidetoc" valign="bottom">
<h1 class="SideTOC1-PartTab"><a href="SecurityAndCrypto_Part1.html">Part I: Concepts</a> </h1>
<h1 class="SideTOC1"><a href="SecurityConcepts.html">1  Palm OS Cobalt Security</a></h1>

   <h2 class="SideTOC2"><a href="#993076">
   Cryptographic Provider Manager (CPM)</a></h2>

      <h3 class="SideTOC3"><a href="#996976">
      Provider Information and Manipulation</a></h3>

      <h3 class="SideTOC3"><a href="#997065">
      Key Functions</a></h3>

      <h3 class="SideTOC3"><a href="#997182">
      Message Digest Functions</a></h3>

      <h3 class="SideTOC3"><a href="#997268">
      Encryption and Decryption Functions</a></h3>

   <h2 class="SideTOC2"><a href="#996775">
   Authentication Manager</a></h2>

      <h3 class="SideTOC3"><a href="#993270">
      Authentication Tokens</a></h3>

      <h3 class="SideTOC3"><a href="#993274">
      Token Management Functions</a></h3>

      <h3 class="SideTOC3"><a href="#999254">
      Using the Authentication Manager</a></h3>

      <h3 class="SideTOC3"><a href="#1009026">
      Creating an Authentication Manager Plug-In</a></h3>

      <h3 class="SideTOC3"><a href="#1009348">
      Manipulating Authentication Manager Plug-Ins</a></h3>

   <h2 class="SideTOC2"><a href="#993218">
   Authorization Manager</a></h2>

   <h2 class="SideTOC2"><a href="#993432">
   Certificate Manager</a></h2>

      <h3 class="SideTOC3"><a href="#1000611">
      Certificate Store Operations</a></h3>

      <h3 class="SideTOC3"><a href="#1000697">
      Certificate Verification and Parsing</a></h3>

      <h3 class="SideTOC3"><a href="#1002472">
      Certificate Backup and Restore</a></h3>

   <h2 class="SideTOC2"><a href="#994858">
   Security Services</a></h2>

      <h3 class="SideTOC3"><a href="#1003262">
      Current Security Setting</a></h3>

      <h3 class="SideTOC3"><a href="#994870">
      Lockout Settings</a></h3>

      <h3 class="SideTOC3"><a href="#1003510">
      Security Policies</a></h3>

   <h2 class="SideTOC2"><a href="#993477">
   Signature Verification Library</a></h2>

      <h3 class="SideTOC3"><a href="#1004001">
      Signature Verification</a></h3>

   <h2 class="SideTOC2"><a href="#1004872">
   Signing Code</a></h2>

      <h3 class="SideTOC3"><a href="#1004952">
      What can be Signed</a></h3>

      <h3 class="SideTOC3"><a href="#994593">
      Signing Algorithm</a></h3>

      <h3 class="SideTOC3"><a href="#1004819">
      Signing Tools</a></h3>

      <h3 class="SideTOC3"><a href="#1012966">
      Signed Code and Shared Libraries</a></h3>

      <h3 class="SideTOC3"><a href="#1012983">
      Signed Code and Overlays</a></h3>

   <h2 class="SideTOC2"><a href="#993550">
   Securing Databases</a></h2>

      <h3 class="SideTOC3"><a href="#993564">
      Synchronization and Backup of Secure Databases</a></h3>

</div>
</td>

<td width="5">&nbsp;&nbsp;</td>
<td width="2" background="images/index_r8_c10.gif"><img src="images/shim.gif" width="2" height="75" border="0" alt=""></td>
<td width="5">&nbsp;&nbsp;</td>

<!--END SIDETOC-->

<td valign="top">

<!--BEGIN CONTENT-->
<div id="content" valign="bottom">
<p><a name="994402"> </a>Palm OS Cobalt has a robust and comprehensive security architecture. Unlike other security solutions that are added in an ad-hoc manner to existing operating systems, the security for Palm OS Cobalt has been designed in from the beginning.</p>

<p><a name="994409"> </a>The basis of Palm OS Cobalt security is the secure kernel. The kernel relies on a capabilities model for security. The capabilities model, typically a model of least privilege, has been hybridized for Palm OS Cobalt in order to maintain the open nature of Palm OS. At boot time, keys are carefully distributed to various system managers that need to communicate with each other. Only managers that have keys enabling communication are able to communicate with other system components. This prevents unauthorized access to important system modules.</p>

<p><a name="995558"> </a>On top of the secure kernel are the components that make up the basis of a secure infrastructure. <a href="SecurityConcepts.html#995643">Figure 1.1</a> illustrates how these components interrelate.</p>

<p class="FFigureCaption">
  <a name="995643"> </a><b>Figure 1.1&nbsp;&nbsp;Palm OS Cobalt security components</b>
</p>
<div align="left"><img src="images/SecurityConceptse.jpg" height="604" width="480" border="0" hspace="0" vspace="0">
</div>

<p><a name="995367"> </a>The <b>Authorization Manager</b> (AM) provides system managers with the ability to protect managed resources. In the case of Data Manager, database resources are protected via the Authorization Manager. Other components, such as drivers, may protect other resources such as network access through the Authorization Manager. In conjunction with the Authorization Manager the <b>Authentication Manager</b> (AM) provides authentication for authorization rules and supports other authentication requirements. The Authentication Manager employs a plug-in architecture so that additional authentication mechanisms can be added. The Authentication Manager supports password/pass phrase authentication for users and both PKI and cryptographic fingerprint for code modules. Additional authentication mechanisms, such as biometric, can be added via the Authentication Manager plug-in framework.</p>

<p><a name="994417"> </a>Palm OS Cobalt also includes the <b>Cryptographic Provider Manager</b> (CPM). The Cryptographic Provider Manager exposes a simple yet robust API for performing cryptographic operations including key generation, hashing, encryption, decryption, signing, and verification. The Cryptographic Provider Manager includes a FIPS&#8211;approved pseudo random number generator and a provider architecture for cryptographic algorithms. The default provider, developed by RSA Security, includes RC4 (128 bit), SHA-1 hashing, and RSA public key operations (1024 bit). Additional providers can be added, either statically by the licensee or dynamically, to the Cryptographic Provider Manager to support other algorithms.</p>

<p><a name="994421"> </a>Palm OS Cobalt includes a <b>Certificate Manager</b>, developed by RSA Security. The Certificate Manager handles X.509 standard certificates. The Certificate Manager exposes a standard API for applications and system modules that need certificate services.</p>

<p><a name="994422"> </a>Making use of both the Cryptographic Provider Manager and the Certificate Manager, Palm OS Cobalt includes a <b>Signature Verification Library</b> that allows applications and system modules to easily verify signatures on code modules and resources.</p>

<p><a name="994429"> </a>Palm OS Cobalt also includes a robust and highly optimized version of SSL for end-to-end secure communications. The Palm OS Cobalt SSL implementation, by RSA Security, supports SSL v2, v3, and TLS 1.0.</p>

<p><a name="994436"> </a>The Palm OS Cobalt <b>Security Services module</b> that supports a variety of mechanisms for specifying and controlling the security policies of a particular device or class of devices. Security Services supports a policy API that applications and code modules can query to get policies for various operations or functionality. Examples include policies for what types of patches are allowed on the system and polices for what drivers are allowed on the system. The Security Services also supports a set of APIs so that the user can indicate a perceived level of security of the device (None, Medium, or High). Various modules and applications can read the user's security preference and react accordingly.</p>

<p><a name="994438"> </a>PalmSource signs all shared library code modules. Code modules easily support multiple signatures, enabling licensees and carriers to sign code modules.</p>

<p><a name="995799"> </a>The following sections provide details on each of the Palm OS Cobalt security components. Note that the details of SSL are covered in <a href="SslConcepts.html#992934">Chapter 2, "SSL Concepts."</a></p>

<h2 class="haH2">
  <a name="993076"> </a>Cryptographic Provider Manager (CPM) <a href="#992896"><span class="nav">^TOP^</span></a>
</h2>


<p><a name="993221"> </a>The Cryptographic Provider Manager (CPM) provides an interface for cryptographic related functions. At its heart it contains an X 9.31 FIPS&#8211;approved pseudo random number generator. The CPM allows you to do the following:</p>
<ul type="disc">
  <li><a name="993223"> </a>RC4 encrypt/decrypt
  <li><a name="993224"> </a>SHA1 digest
  <li><a name="993225"> </a>RSA verify
  <li><a name="993226"> </a>DES/MD5 encrypt/decrypt
</ul>

<p><a name="996050"> </a>The CPM also supports the SSL cryptographic package. See <a href="SslConcepts.html#992934">Chapter 2, "SSL Concepts,"</a> for more on SSL in Palm OS Cobalt.</p>

<p><a name="996774"> </a>Note that the CPM is export controlled. CPM providers must be signed.</p>

<p><a name="996955"> </a>The Cryptographic Provider Manager, or CPM, provides an easy to use, yet robust cryptographic API. Applications can use the CPM to perform cryptographic operations for data and protocols. Under the CPM there are one or more providers which supply the actual cryptographic functionality via the CPM API.</p>

<p><a name="996956"> </a>The CPM supports various classes of functions, some of which are described herein. For further information see the CPM documentation.</p>

<p><a name="996957"> </a>The classes of functions discussed herein can be grouped as follows:</p>
   <blockquote class = "bq"><a name="996961"> </a><a href="SecurityConcepts.html#996976">Provider Information and Manipulation</a></blockquote>
   <blockquote class = "bq"><a name="996965"> </a><a href="SecurityConcepts.html#997065">Key Functions</a></blockquote>
   <blockquote class = "bq"><a name="996969"> </a><a href="SecurityConcepts.html#997182">Message Digest Functions</a></blockquote>
   <blockquote class = "bq"><a name="996973"> </a><a href="SecurityConcepts.html#997268">Encryption and Decryption Functions</a></blockquote>
<h3 class="hbH3">
  <a name="996976"> </a>Provider Information and Manipulation <a href="#992896"><span class="nav">^TOP^</span></a>
</h3>


<p><a name="996977"> </a>The CPM itself provides the ability to query the number of providers present, modify the order the providers are called, and a pseudo random number generator based on ANSI X9.31</p>

<p><a name="996978"> </a>The CPM contains a default provider which includes SHA-1 hashing, RC4 encryption and decryption, and RSA verification (public key operations). Other providers may or may not be present.</p>

<p><a name="996979"> </a>The operation of the CPM is different from other cryptographic providers that perform the same types of operations. Applications that use the CPM can get default "reasonable" behavior without specifying a great deal of information related to the cryptographic operation requested. Examples will illustrate this.</p>

<p><a name="996983"> </a><a href="SecurityConcepts.html#996985">Listing 1.1</a> shows how to enumerate and identify the providers the CPM currently knows about.</p>
<p class="CCodeCaption">
  <a name="996985"> </a><b>Listing 1.1&nbsp;&nbsp;Enumerating CPM providers</b>
</p>

<div class="CodeRule"><hr></div><pre class="CodeBlock">
uint32_t *providers;<a name="996986"> </a>
APProviderInfoType providerInfo;<a name="996987"> </a>
uint16_t temp = 0;<a name="996988"> </a>
status_t err;<a name="996989"> </a>
<a name="996990"> </a>
err = CPMLibOpen(&amp;temp);<a name="996991"> </a>
<a name="996992"> </a>
if (err) {<a name="996993"> </a>
   DbgPrintf("SSFD: Error on CPMLibOpen 0x%x\n", err);<a name="996994"> </a>
} else {<a name="996995"> </a>
   DbgPrintf("SSFD: CPMLibOpen - 0x%x providers returned\n",
      temp providers = MemPtrNew(sizeof(uint32_t) * temp);<a name="996996"> </a>
  err = CPMLibEnumerateProviders(providers, &amp;temp);<a name="996997"> </a>
<a name="996998"> </a>
   providers = MemPtrNew(sizeof(uint32_t) * temp);<a name="996999"> </a>
   err = CPMLibEnumerateProviders(providers, &amp;temp);<a name="997000"> </a>
   if (err) {<a name="997001"> </a>
      DbgPrintf("SSFD: Error on CPMLibEnumerateProviders
         0x%x\n", err);<a name="997002"> </a>
   } else {<a name="997003"> </a>
      DbgPrintf("SSFD: CPMLibEnumerateProviders - 0x%x
         providers returned\n", temp);<a name="997004"> </a>
      for (i=0; i &lt; temp; i++) {<a name="997005"> </a>
         err = CPMLibGetProviderInfo(providers[i],
            &amp;providerInfo);<a name="997006"> </a>
         if (err) {<a name="997007"> </a>
            DbgPrintf("SSFD: Error on CPMLibGetProviderInfo
               0x%x\n", err);<a name="997008"> </a>
        } else {<a name="997009"> </a>
            uint32_t provider provider = providers[i];<a name="997010"> </a>
<a name="997011"> </a>
            provider = providers[i];<a name="997012"> </a>
            DbgPrintf("SSFD: CPMLibGetProviderInfo -
               provider['%c%c%c%c']\n",<a name="997013"> </a>
               (char)((provider &gt;&gt; 24) &amp; 0x000000FF),<a name="997014"> </a>
               (char)((provider &gt;&gt; 16) &amp; 0x000000FF),<a name="997015"> </a>
               (char)((provider &gt;&gt; 8) &amp; 0x000000FF),<a name="997016"> </a>
               (char)((provider &amp; 0x000000FF)));<a name="997017"> </a>
            DbgPrintf("\t%s\n", providerInfo.name);<a name="997018"> </a>
            DbgPrintf("\t%s\n", providerInfo.other);<a name="997019"> </a>
            DbgPrintf("\tAlgs: %d\n",
               providerInfo.numAlgorithms);<a name="997020"> </a>
            DbgPrintf("\tHardware?: %s\n",
               providerInfo.bHardware?"yes":"no");<a name="997021"> </a>
        }<a name="997022"> </a>
   }<a name="997023"> </a>
}<a name="997024"> </a>
</pre><div class="CodeRule"><hr></div>


<p><a name="997025"> </a>The order that the providers are called is arbitrary. The CPM orders the providers as they are found and calls each one in turn until one returns that it can handle the request. Subsequent calls on the same context of operations will go to the same provider that handled the first request. For example, say the first operation in an encryption context is generating a key to use for encryption. The provider that handles the key generation will also be used to do the encryption unless the application explicitly changes it.</p>

<p><a name="997026"> </a>For any given initial operation, or one for which a provider has not yet been selected, the CPM tries each provider in turn until one returns that the operation has been handled. Subsequent providers are not called. Due to this design, the CPM does not readily handle providers that include similar functionality.</p>

<p><a name="997027"> </a>The application is free to select a different provider for any operation for which the provider has already been set. The application is also free to set the first provider that the CPM will call, ensuring that all operations will go to a particular provider for the initial context. To set the default provider, do something like what is shown in <a href="SecurityConcepts.html#997032">Listing 1.2</a>.</p>
<p class="CCodeCaption">
  <a name="997032"> </a><b>Listing 1.2&nbsp;&nbsp;Setting the default CPM provider</b>
</p>

<div class="CodeRule"><hr></div><pre class="CodeBlock">
status_t err;<a name="997033"> </a>
<a name="997034"> </a>
/*<a name="997035"> </a>
* set the default provider to the provider with id 'foop'<a name="997036"> </a>
*/<a name="997037"> </a>
err = CPMLibSetDefaultProvider((uint32_t) 'foop'); <a name="997038"> </a>
if (err)<a name="997039"> </a>
   DbgPrintf("SSFD: Error on CPMLibSetDefaultProvider
      0x%x\n", err);<a name="997040"> </a>
</pre><div class="CodeRule"><hr></div>


<p><a name="997044"> </a>All <a href="CPMLibCommon.html#1010194"><code>CPMInfoType</code></a> structures have a common structure header which includes provider information about the provider that handled the structure. To change the provider for a given <code>CPMInfoType</code> structure, the application must copy the structure and reset the provider information. The application is then responsible for making sure that the original structure is passed to the original provider for cleanup. This operation is <i>not</i> recommended without specific knowledge of the operation and functionality of the various providers utilized. See <a href="SecurityConcepts.html#997049">Listing 1.3</a> for an illustration of how this might be done.</p>
<p class="CCodeCaption">
  <a name="997049"> </a><b>Listing 1.3&nbsp;&nbsp;Changing the provider</b>
</p>

<div class="CodeRule"><hr></div><pre class="CodeBlock">
status_t err;<a name="997050"> </a>
APKeyInfoType keyInfo, newkeyInfo;<a name="997051"> </a>
<a name="997052"> </a>
MemSet(&amp;keyInfo, sizeof(APKeyInfoType), 0);<a name="997053"> </a>
  <a name="997054"> </a>
err = CPMLibGenerateKey(NULL, 0, &amp;keyInfo);<a name="997055"> </a>
<a name="997056"> </a>
MemSet(&amp;newkeyInfo, sizeof(APKeyInfoType), 0);<a name="997057"> </a>
MemMove(&amp;newkeyInfo, &amp;keyInfo, sizeof(APKeyInfoType));<a name="997058"> </a>
newkeyInfo.providerContext.localContext = NULL;<a name="997059"> </a>
newkeyInfo.providerContext.providerID = 0;<a name="997060"> </a>
<a name="997061"> </a>
CPMLibReleaseKeyInfo(&amp;keyInfo);<a name="997062"> </a>
/* now go on to use newkeyInfo as you please */<a name="997063"> </a>
</pre><div class="CodeRule"><hr></div>

<h3 class="hbH3">
  <a name="997065"> </a>Key Functions <a href="#992896"><span class="nav">^TOP^</span></a>
</h3>


<p><a name="997066"> </a>The CPM provides several ways of introducing keys to the cryptographic functions. The CPM has concepts of either generating a brand new key, deriving a key from some initial data, or importing a previously generated key.</p>

<p><a name="997067"> </a>Generating a new key implies that every time a request for a new key to be generated is made, a brand new key is generated. If this brand new key is utilized for any cryptographic operations, it must be exported and saved in order to be used again. It is statistically improbable that a generated key could be regenerated.</p>

<p><a name="997068"> </a>Deriving a key means that given the same input data, the same key is derived from the data. This is useful for operations like Password Based Encryption (PBE) where the password is used to derive a key for a particular cryptographic operations (usually encryption or decryption).</p>

<p><a name="997069"> </a>Importing a key means that a previously generated key which was exported and saved by an application is now being imported for further cryptographic operations. Importing a key can also mean that key data from a derive key operation is now being used to create a <a href="CPMLibCommon.html#1007123"><code>APKeyInfoType</code></a> object. In general, an application would not export and save a derived key since it could be re-derived by using the same input data. A generated key, however, must be exported and saved if it is to be used for later cryptographic operations.</p>

<p><a name="997073"> </a>Note that the CPM is designed to work with very little information about the specific cryptographic operation requested. Especially for data that remains on the originating device, most of the input and output parameters for CPM APIs can be ignored.</p>

<p><a name="997074"> </a>To generate a new key (the application does not care about the type of key since it is to be used to encrypt data that remains on the device), do something along the lines of what is shown in <a href="SecurityConcepts.html#997079">Listing 1.4</a>.</p>
<p class="CCodeCaption">
  <a name="997079"> </a><b>Listing 1.4&nbsp;&nbsp;Generating a new key</b>
</p>

<div class="CodeRule"><hr></div><pre class="CodeBlock">
status_t err;<a name="997080"> </a>
APKeyInfoType keyInfo;<a name="997081"> </a>
<a name="997082"> </a>
MemSet(&amp;keyInfo, sizeof(APKeyInfoType), 0);<a name="997083"> </a>
  <a name="997084"> </a>
err = CPMLibGenerateKey(NULL, 0, &amp;keyInfo);<a name="997085"> </a>
if (err) {<a name="997086"> </a>
   DbgPrintf("SSFD: Error on CPMLibGenerateKey 0x%x\n", err);<a name="997087"> </a>
} else {<a name="997088"> </a>
   DbgPrintf("SSFD: CPMLibGenerateKey - key of length 0x%x
      returned\n", keyInfo.length);<a name="997089"> </a>
}<a name="997090"> </a>
</pre><div class="CodeRule"><hr></div>


<p><a name="997091"> </a>The call to generate a key allows the application to specify some data to use as seed data for the pseudo-random number generator before the pseudo-random number generator is used. <a href="SecurityConcepts.html#997096">Listing 1.5</a> illustrates how to generate a key of a specific type and length.</p>
<p class="CCodeCaption">
  <a name="997096"> </a><b>Listing 1.5&nbsp;&nbsp;Generating a key of a specific type and length</b>
</p>

<div class="CodeRule"><hr></div><pre class="CodeBlock">
status_t err;<a name="997097"> </a>
APKeyInfoType keyInfo;<a name="997098"> </a>
uint8_t *seedData;<a name="997099"> </a>
uint32_t seedDataLength;<a name="997100"> </a>
<a name="997101"> </a>
MemSet(&amp;keyInfo, sizeof(APKeyInfoType), 0);<a name="997102"> </a>
keyInfo.type = apSymmetricTypeRijndael;<a name="997103"> </a>
keyInfo.length = 256/8; /* 256 bit key or 32 byte key */<a name="997104"> </a>
<a name="997105"> </a>
/* provide some seed data to the random generator for 
   generating the key */<a name="997106"> </a>
GetSomeSeedData(seedData, seedDataLength); <a name="997107"> </a>
err = CPMLibGenerateKey(seedData, seedDataLength, &amp;keyInfo); 
if (err) {<a name="997108"> </a>
   DbgPrintf("SSFD: Error on CPMLibGenerateKey 0x%x\n", err);<a name="997109"> </a>
} else {<a name="997110"> </a>
   DbgPrintf("SSFD: CPMLibGenerateKey - key of length 0x%x
      returned\n", keyInfo.length);<a name="997111"> </a>
}<a name="997112"> </a>
</pre><div class="CodeRule"><hr></div>


<p><a name="997113"> </a>All of the CPM APIs that include an output buffer for results allow the application to specify a <code>NULL</code> output buffer and a valid output buffer size pointer to receive the required output buffer size. In this way an application can request the required output buffer size before making the actual call.</p>

<p><a name="997114"> </a>Derived keys can have some complicated parameters like iterations and salts which are better described elsewhere. In general, the CPM, and providers will provide "sane" functionality when parameters are left unspecified.</p>

<p><a name="997115"> </a>Deriving a key just returns exportable key data. To actually use a derived key, the application must import the key data to get an <a href="CPMLibCommon.html#1007123"><code>APKeyInfoType</code></a>. The <code>APKeyInfoType</code> is used in subsequent cryptographic operations. See <a href="SecurityConcepts.html#997123">Listing 1.6</a> for sample code that derives a key.</p>
<p class="CCodeCaption">
  <a name="997123"> </a><b>Listing 1.6&nbsp;&nbsp;Deriving a key</b>
</p>

<div class="CodeRule"><hr></div><pre class="CodeBlock">
status_t err;<a name="997124"> </a>
APDerivedKeyInfoType dki;<a name="997125"> </a>
APKeyInfoType keyInfo;<a name="997126"> </a>
uint32_t size;<a name="997127"> </a>
uint32_t *key_data;<a name="997128"> </a>
<a name="997129"> </a>
/*<a name="997130"> </a>
   * this is provider dependent<a name="997131"> </a>
   */<a name="997132"> </a>
struct {<a name="997133"> </a>
   unsigned long length;<a name="997134"> </a>
   unsigned char *data;<a name="997135"> </a>
} kdInfo;<a name="997136"> </a>
<a name="997137"> </a>
MemSet(&amp;dki, sizeof(APDerivedKeyInfoType), 0);<a name="997138"> </a>
MemSet(&amp;kdInfo, sizeof(kdInfo), 0);<a name="997139"> </a>
GetUserPassword(kdInfo.data, kdInfo.length)<a name="997140"> </a>
dki.kdInfo = &amp;kdInfo;<a name="997141"> </a>
size = 0;<a name="997142"> </a>
err = CPMLibDeriveKeyData(&amp;dki, NULL, &amp;size);<a name="997143"> </a>
if (err) {<a name="997144"> </a>
   DbgPrintf("SSFD: Error on CPMLibDeriveKeyData 0x%x\n",
      err);<a name="997145"> </a>
<a name="997146"> </a>
if (err == cpmErrBufTooSmall) {<a name="997147"> </a>
   DbgPrintf("SSFD: cpmErrBufTooSmall with
      CPMLibDeriveKeyData returning %d\n", size);<a name="997148"> </a>
   key_data = MemPtrNew(size);<a name="997149"> </a>
   if (key_data != NULL) {<a name="997150"> </a>
      err = CPMLibDeriveKeyData(&amp;dki, key_data, &amp;size);<a name="997151"> </a>
      if (err) {<a name="997152"> </a>
         DbgPrintf("SSFD: Error on CPMLibDeriveKeyData
            0x%x\n", err);<a name="997153"> </a>
      } else {<a name="997154"> </a>
         DbgPrintf("SSFD: CPMLibDeriveKeyData - 0x%x bytes
            returned\n", size<a name="997155"> </a>
/* now we can use key_data as import data to get a key */<a name="997156"> </a>
         MemSet(&amp;keyInfo, sizeof(APKeyInfoType), 0);<a name="997157"> </a>
         err = CPMLibImportKeyInfo(IMPORT_EXPORT_TYPE_RAW,
            key_data, size, &amp;keyInfo);<a name="997158"> </a>
         if (err) {<a name="997159"> </a>
            DbgPrintf("SSFD: Error on CPMLibImportKeyInfo
               0x%x\n", err);<a name="997160"> </a>
         } else {<a name="997161"> </a>
            DbgPrintf("SSFD: CPMLibImportKeyInfo - key of
               length 0x%x returned\n", keyInfo.length);<a name="997162"> </a>
         }<a name="997163"> </a>
      }<a name="997164"> </a>
   }<a name="997165"> </a>
}<a name="997166"> </a>
</pre><div class="CodeRule"><hr></div>


<p><a name="997167"> </a>Import is used with keys from various sources such as a saved database, a static application key or a key sourced from a protocol negotiation. Typically an application must specify the type of key that is being imported and the import format<a href="#1012955"><sup>1</sup></a>. Since import data is essentially raw byte streams, its important that the application specify something.</p>
<p class="CCodeCaption">
  <a name="997168"> </a><b>Listing 1.7&nbsp;&nbsp;Importing a key</b>
</p>

<div class="CodeRule"><hr></div><pre class="CodeBlock">
status_t err;<a name="997169"> </a>
APKeyInfoType keyInfo;<a name="997170"> </a>
uint8_t key[] = { 0x01, 0x23, 0x45, 0x67, 0x89, 0xAB, 0xCD,
   0xEF };<a name="997171"> </a>
  <a name="997172"> </a>
MemSet(&amp;keyInfo, sizeof(APKeyInfoType), 0);<a name="997173"> </a>
keyInfo.type = apSymmetricTypeDES;<a name="997174"> </a>
err = CPMLibImportKeyInfo(IMPORT_EXPORT_TYPE_RAW, key, 
   sizeof(key), &amp;keyInfo);<a name="997175"> </a>
if (err) {<a name="997176"> </a>
   DbgPrintf("SSFD: Error on CPMLibImportKeyInfo 0x%x\n",
      err);<a name="997177"> </a>
} else {<a name="997178"> </a>
   DbgPrintf("SSFD: CPMLibImportKeyInfo - key of length 0x%x 
      returned\n", keyInfo.length);<a name="997179"> </a>
}<a name="997180"> </a>
</pre><div class="CodeRule"><hr></div>

<h3 class="hbH3">
  <a name="997182"> </a>Message Digest Functions <a href="#992896"><span class="nav">^TOP^</span></a>
</h3>


<p><a name="997183"> </a>Message digests or hashes are cryptographically strong one way functions. A one way function yields a series of bits that represent the input message. Nothing about the input message can be gleaned from the message digest. The same input message always generates the same hash. Typically hashes are used slow operations are to be performed on long messages. Rather than performing the slow operation on the entire message, the long operation is performed on the hash of the message which is much shorter.</p>

<p><a name="997184"> </a>The CPM has two modes of operation for message digests. One mode takes the input message as whole and outputs a digest. The other mode takes the input message as parts and doesn't output the digest until the final part of the message is submitted.</p>

<p><a name="997185"> </a>In the all-in-one-shot mode of operation, no context is required for the hashing operation. The application can safely ignore the <a href="CPMLibCommon.html#1006140"><code>APHashInfoType</code></a> parameter for the AIO operations. <a href="SecurityConcepts.html#997193">Listing 1.8</a> shows how to do a hashing operation in a single pass.</p>
<p class="CCodeCaption">
  <a name="997193"> </a><b>Listing 1.8&nbsp;&nbsp;A single-pass hashing operation</b>
</p>

<div class="CodeRule"><hr></div><pre class="CodeBlock">
status_t err;<a name="997194"> </a>
uint32_t size;<a name="997195"> </a>
uint8_t data[] = ( 'f', 'o', 'o' );<a name="997196"> </a>
uint8_t *md;<a name="997197"> </a>
<a name="997198"> </a>
size = 0;<a name="997199"> </a>
err = CPMLibHash(apHashTypeSHA1, NULL, data, sizeof(data), 
   NULL, &amp;size);<a name="997200"> </a>
if (err) {<a name="997201"> </a>
   DbgPrintf("SSFD: Error on CPMLibHash 0x%x\n", err);<a name="997202"> </a>
<a name="997203"> </a>
   if (err == cpmErrBufTooSmall) {<a name="997204"> </a>
      DbgPrintf("SSFD: cpmErrBufTooSmall with CPMLibHash 
         returning %d\n", size);<a name="997205"> </a>
      md = MemPtrNew(size);<a name="997206"> </a>
      if (md != NULL) {<a name="997207"> </a>
         err = CPMLibHash(apHashTypeSHA1, NULL, data, 
            sizeof(data), md, &amp;size);<a name="997208"> </a>
      if (err) {<a name="997209"> </a>
         DbgPrintf("SSFD: Error on CPMLibHash 0x%x\n", err);<a name="997210"> </a>
      } else {<a name="997211"> </a>
         DbgPrintf("SSFD: CPMLibHash - 0x%x bytes 
            returned\n", size);<a name="997212"> </a>
      }<a name="997213"> </a>
   }<a name="997214"> </a>
}<a name="997215"> </a>
</pre><div class="CodeRule"><hr></div>


<p><a name="997216"> </a>For the multi-part mode of operation, a context is required to pass from initial operation to subsequent operations. Upon return from the final operation the context must be cleaned up. It is the application's responsibility to pass the context to the Release function for cleanup by the CPM and providers. See <a href="SecurityConcepts.html#997221">Listing 1.9</a> for a sample illustrating the multi-part hashing operation.</p>
<p class="CCodeCaption">
  <a name="997221"> </a><b>Listing 1.9&nbsp;&nbsp;A multi-part hashing operation</b>
</p>

<div class="CodeRule"><hr></div><pre class="CodeBlock">
status_t err;<a name="997222"> </a>
uint32_t size;<a name="997223"> </a>
uint8_t data[] = ( 'f', 'o', 'o' );<a name="997224"> </a>
uint8_t *md;<a name="997225"> </a>
APHashInfoType hashInfo;<a name="997226"> </a>
<a name="997227"> </a>
MemSet(&amp;hashInfo, sizeof(APHashInfoType), 0);<a name="997228"> </a>
hashInfo.type = apHashTypeSHA1;<a name="997229"> </a>
  <a name="997230"> </a>
err = CPMLibHashInit(&amp;hashInfo); /* initialize the context */<a name="997231"> </a>
if (err) {<a name="997232"> </a>
   DbgPrintf("SSFD: Error on CPMLibHashInit 0x%x\n", err);<a name="997233"> </a>
} else {<a name="997234"> </a>
   /*update the operation; can do this any number of times */<a name="997235"> </a>
   err = CPMLibHashUpdate(&amp;hashInfo, data, sizeof(data)); <a name="997236"> </a>
   if (err) {<a name="997237"> </a>
      DbgPrintf("SSFD: Error on CPMLibHashUpdate 0x%x\n", 
         err);<a name="997238"> </a>
   } else {<a name="997239"> </a>
      size = 0;<a name="997240"> </a>
      err = CPMLibHashFinal(&amp;hashInfo, NULL, 0, NULL, &amp;size);<a name="997241"> </a>
      if (err) {<a name="997242"> </a>
         DbgPrintf("SSFD: Error on CPMLibHashFinal 0x%x\n", 
            err);<a name="997243"> </a>
<a name="997244"> </a>
         if (err == cpmErrBufTooSmall) {<a name="997245"> </a>
            DbgPrintf("SSFD: cpmErrBufTooSmall with 
                CPMLibHash returning %d\n", size);<a name="997246"> </a>
            md = MemPtrNew(size);<a name="997247"> </a>
            if (md != NULL) {<a name="997248"> </a>
               /* finalize the operation */<a name="997249"> </a>
               err = CPMLibHashFinal(&amp;hashInfo, NULL, 0, md, 
                  &amp;size);<a name="997250"> </a>
               if (err) {<a name="997251"> </a>
                  DbgPrintf("SSFD: Error on CPMLibHash 
                     0x%x\n", err);<a name="997252"> </a>
               } else {<a name="997253"> </a>
                  DbgPrintf("SSFD: CPMLibHashFinal - 0x%x 
                     bytes returned\n", size);<a name="997254"> </a>
               }<a name="997255"> </a>
            }<a name="997256"> </a>
         }<a name="997257"> </a>
      }<a name="997258"> </a>
   }<a name="997259"> </a>
   /* release the context */<a name="997260"> </a>
   CPMLibReleaseHashInfo(&amp;hashInfo);<a name="997261"> </a>
} <a name="997262"> </a>
</pre><div class="CodeRule"><hr></div>


<p><a name="997263"> </a>Certain applications may require the hashing context to be saved off and returned to at a later time. The <a href="CPMLibCommon.html#1006140"><code>APHashInfoType</code></a> structures may be exported and imported in much the same way as keys are imported and exported.</p>
<h3 class="hbH3">
  <a name="997268"> </a>Encryption and Decryption Functions <a href="#992896"><span class="nav">^TOP^</span></a>
</h3>


<p><a name="997269"> </a>The CPM supports encryption and decryption in much the same was as hashing is supported. That is encryption and decryption have two modes of operation. An application can either encrypt or decrypt a message as a whole, or in parts. Providers are not required to support both modes.</p>

<p><a name="997270"> </a>Encryption algorithms either work on data a byte at a time or in blocks of bytes (usually blocks of 8 bytes) at a time. The former is called stream encryption while the latter is called, appropriately enough, block encryption. Typically with block encryption, some padding is added to the data to make the data an integral number of blocks. Providers are not required to support padding. If the provider does not support padding the application must pad data for a block encryption algorithm or an error occurs.</p>

<p><a name="997271"> </a>As with the hashing operation, no context is required for the operation if you perform the encryption in a single step. This is illustrated in <a href="SecurityConcepts.html#997276">Listing 1.10</a>.</p>
<p class="CCodeCaption">
  <a name="997276"> </a><b>Listing 1.10&nbsp;&nbsp;A single-pass encryption operation</b>
</p>

<div class="CodeRule"><hr></div><pre class="CodeBlock">
status_t err;<a name="997277"> </a>
uint8_t key[] = {0x7C, 0xA1, 0x10, 0x45, 0x4A, 0x1A, 0x6E, 
   0x57}; <a name="997278"> </a>
uint8_t plain[] = {0x01, 0xA1, 0xD6, 0xD0, 0x39, 0x77, 0x67, 
   0x42};<a name="997279"> </a>
uint8_t *output;<a name="997280"> </a>
uint32_t index, size;<a name="997281"> </a>
APKeyInfoType keyInfo;<a name="997282"> </a>
<a name="997283"> </a>
MemSet(&amp;keyInfo, sizeof(APKeyInfoType), 0);<a name="997284"> </a>
keyInfo.type = apSymmetricTypeDES;<a name="997285"> </a>
err = CPMLibImportKeyInfo(IMPORT_EXPORT_TYPE_RAW, key, 8, 
   &amp;keyInfo);<a name="997286"> </a>
if (err) {<a name="997287"> </a>
   DbgPrintf("SSFD: Error on CPMLibImportKeyInfo 0x%x\n", 
      err);<a name="997288"> </a>
} else {<a name="997289"> </a>
   DbgPrintf("SSFD: CPMLibImportKeyInfo - key of length 0x%x 
      returned\n", keyInfo.length);<a name="997290"> </a>
   size = 0;<a name="997291"> </a>
   err = CPMLibEncrypt(&amp;keyInfo, NULL, plain, 8, NULL, 
      &amp;size);<a name="997292"> </a>
   if (err) {<a name="997293"> </a>
      DbgPrintf("SSFD: Error on CPMLibEncrypt 0x%x with size 
         set to 0x%x\n", err, size);<a name="997294"> </a>
   } else {<a name="997295"> </a>
      DbgPrintf("SSFD: CPMLibEncrypt - cipher data of length 
         0x%x returned\n", size);<a name="997296"> </a>
   }<a name="997297"> </a>
<a name="997298"> </a>
   if (err = cpmErrBufTooSmall) {<a name="997299"> </a>
      output = MemPtrNew(size);<a name="997300"> </a>
      if (output != NULL) {<a name="997301"> </a>
         err = CPMLibEncrypt(&amp;keyInfo, NULL, plain, 8, 
            output, &amp;size);<a name="997302"> </a>
         if (err) {<a name="997303"> </a>
            DbgPrintf("SSFD: Error on CPMLibEncrypt 0x%x\n", 
               err);<a name="997304"> </a>
         } else {<a name="997305"> </a>
            DbgPrintf("SSFD: CPMLibEncrypt - cipher data of 
               length 0x%x returned\n", size);<a name="997306"> </a>
         }<a name="997307"> </a>
         MemPtrFree(output);<a name="997308"> </a>
      }<a name="997309"> </a>
   }<a name="997310"> </a>
   CPMLibReleaseKeyInfo(&amp;keyInfo);<a name="997311"> </a>
}<a name="997312"> </a>
</pre><div class="CodeRule"><hr></div>


<p><a name="997313"> </a>With the multi-part encryption, the application must pass the context from the initial operation through to the final operation. The multi-part encryption is much the same as the multi-part hashing. The difference is that the provider does not maintain the state of the encrypted data during an update. The application must supply an output buffer for each update. The final operation will handle the last input data and any padding that is required to make a full encryption block of data. This is illustrated in <a href="SecurityConcepts.html#997318">Listing 1.11</a>.</p>
<p class="CCodeCaption">
  <a name="997318"> </a><b>Listing 1.11&nbsp;&nbsp;A multi-part encryption operation</b>
</p>

<div class="CodeRule"><hr></div><pre class="CodeBlock">
status_t err;<a name="997319"> </a>
uint32_t size;<a name="997320"> </a>
uint8_t key[] = {0x7C, 0xA1, 0x10, 0x45, 0x4A, 0x1A, 0x6E, 
   0x57}; <a name="997321"> </a>
uint8_t plain1[] = {0x01, 0xA1, 0xD6, 0xD0, 0x39, 0x77, 0x67, 
   0x42};<a name="997322"> </a>
uint8_t plain2[] = {'f', 'o', 'o', 'b', 'a', 'z', 'a', 'r'};<a name="997323"> </a>
uint8_t *output;<a name="997324"> </a>
APKeyInfoType keyInfo;<a name="997325"> </a>
APCipherInfoType cipherInfo;<a name="997326"> </a>
<a name="997327"> </a>
MemSet(&amp;keyInfo, sizeof(APKeyInfoType), 0);<a name="997328"> </a>
keyInfo.type = apSymmetricTypeDES;<a name="997329"> </a>
err = CPMLibImportKeyInfo(IMPORT_EXPORT_TYPE_RAW, key, 8, 
   &amp;keyInfo);<a name="997330"> </a>
if (err) {<a name="997331"> </a>
   DbgPrintf("SSFD: Error on CPMLibImportKeyInfo 0x%x\n", 
      err);<a name="997332"> </a>
} else {<a name="997333"> </a>
   DbgPrintf("SSFD: CPMLibImportKeyInfo - key of length 0x%x 
      returned\n", keyInfo.length);<a name="997334"> </a>
   MemSet(&amp;cipherInfo, sizeof(APCipherInfoType), 0);<a name="997335"> </a>
   /* initialize the context */<a name="997336"> </a>
   err = CPMLibEncryptInit(&amp;keyInfo, &amp;cipherInfo); <a name="997337"> </a>
   if (err) {<a name="997338"> </a>
      DbgPrintf("SSFD: Error on CPMLibEncryptInit 0x%x\n", 
         err);<a name="997339"> </a>
   } else {<a name="997340"> </a>
      /* update the operation; can do this any number of
         times */<a name="997341"> </a>
      size = 0;<a name="997342"> </a>
      err = CPMLibEncryptUpdate(&amp;keyInfo, &amp;cipherInfo, 
         plain1, sizeof(plain1), NULL, size); <a name="997343"> </a>
      if (err) <a name="997344"> </a>
         DbgPrintf("SSFD: Error on CPMLibEncryptUpdate 
            0x%x\n", err);<a name="997345"> </a>
<a name="997346"> </a>
      if (err == cpmErrBufTooSmall) {<a name="997347"> </a>
         output = MemPtrNew(size);<a name="997348"> </a>
         if (output != NULL) {<a name="997349"> </a>
            err = CPMLibEncryptUpdate(&amp;keyInfo, &amp;cipherInfo, 
               plain1, sizeof(plain1), output, size); <a name="997350"> </a>
            if (err) {<a name="997351"> </a>
               DbgPrintf("SSFD: Error on CPMLibEncryptUpdate 
                  0x%x\n", err);<a name="997352"> </a>
            } else {<a name="997353"> </a>
               /* do something with output */<a name="997354"> </a>
               err = CPMLibEncryptFinal(&amp;keyInfo, 
                  &amp;cipherInfo, plain2, sizeof(plain2), 
                  output, &amp;size);<a name="997355"> </a>
               if (err) <a name="997356"> </a>
                  DbgPrintf("SSFD: Error on 
                     CPMLibEncryptFinal 0x%x\n", err);<a name="997357"> </a>
<a name="997358"> </a>
               if (err == cpmErrBufTooSmall) {<a name="997359"> </a>
                  DbgPrintf("SSFD: cpmErrBufTooSmall with 
                     CPMLibEncryptFinal returning %d\n", 
                        size);<a name="997360"> </a>
                  output = MemPtrRealloc(output, size);<a name="997361"> </a>
                  if (output != NULL) {<a name="997362"> </a>
                     err = CPMLibEncryptFinal(&amp;keyInfo, 
                        &amp;cipherInfo, plain2, sizeof(plain2), 
                        output, &amp;size);<a name="997363"> </a>
                     if (err) {<a name="997364"> </a>
                        DbgPrintf("SSFD: Error on 
                           CPMLibEncryptFinal 0x%x\n", err);<a name="997365"> </a>
                     } else {<a name="997366"> </a>
                           /* do something with output */<a name="997367"> </a>
                        DbgPrintf("SSFD: CPMLibEncryptFinal - 
                           0x%x bytes returned\n", size);<a name="997368"> </a>
                     }<a name="997369"> </a>
                  }<a name="997370"> </a>
               }<a name="997371"> </a>
            }<a name="997372"> </a>
            MemPtrFree(output);<a name="997373"> </a>
         }<a name="997374"> </a>
      }<a name="997375"> </a>
      CPMLibReleaseCipherInfo(&amp;cipherInfo);<a name="997376"> </a>
   }<a name="997377"> </a>
   CPMLibReleaseKeyInfo(&amp;keyInfo);<a name="997378"> </a>
} <a name="997379"> </a>
</pre><div class="CodeRule"><hr></div>


<p><a name="997380"> </a>Decryption is almost exactly the same as encryption. All in one and multi-part decryption is supported if the provider supports the two modes. Padding is required if the provider does not perform padding and the application must ensure that the contexts are released correctly.</p>

<p><a name="997381"> </a>As with encryption, the cipher context can be safely ignored if the operation is performed in a single step, as shown in <a href="SecurityConcepts.html#997386">Listing 1.12</a>.</p>
<p class="CCodeCaption">
  <a name="997386"> </a><b>Listing 1.12&nbsp;&nbsp;A single-pass decryption operation</b>
</p>

<div class="CodeRule"><hr></div><pre class="CodeBlock">
status_t err;<a name="997387"> </a>
uint8_t key[] = {0x7C, 0xA1, 0x10, 0x45, 0x4A, 0x1A, 0x6E, 
   0x57}; <a name="997388"> </a>
uint8_t cipher[] = (0x69, 0x0F, 0x5B, 0x0D, 0x9A, 0x26, 0x93, 
   0x9B};<a name="997389"> </a>
uint8_t *output;<a name="997390"> </a>
uint32_t index, size;<a name="997391"> </a>
APKeyInfoType keyInfo;<a name="997392"> </a>
<a name="997393"> </a>
MemSet(&amp;keyInfo, sizeof(APKeyInfoType), 0);<a name="997394"> </a>
keyInfo.type = apSymmetricTypeDES;<a name="997395"> </a>
err = CPMLibImportKeyInfo(IMPORT_EXPORT_TYPE_RAW, key, 8, 
   &amp;keyInfo);<a name="997396"> </a>
if (err) {<a name="997397"> </a>
   DbgPrintf("SSFD: Error on CPMLibImportKeyInfo 0x%x\n", 
      err);<a name="997398"> </a>
} else {<a name="997399"> </a>
   DbgPrintf("SSFD: CPMLibImportKeyInfo - key of length 0x%x 
      returned\n", keyInfo.length);<a name="997400"> </a>
   size = 0;<a name="997401"> </a>
   err = CPMLibDecrypt(&amp;keyInfo, NULL, cipher, 8, NULL, 
      &amp;size);<a name="997402"> </a>
   if (err) {<a name="997403"> </a>
      DbgPrintf("SSFD: Error on CPMLibDecrypt 0x%x with size 
         set to 0x%x\n", err, size);<a name="997404"> </a>
   } else {<a name="997405"> </a>
      DbgPrintf("SSFD: CPMLibDecrypt - deciphered data of 
         length 0x%x returned\n", size);<a name="997406"> </a>
   }<a name="997407"> </a>
<a name="997408"> </a>
   if (err == cpmErrBufTooSmall) {<a name="997409"> </a>
      output = MemPtrNew(size);<a name="997410"> </a>
      if (output != NULL) {<a name="997411"> </a>
         err = CPMLibDecrypt(&amp;keyInfo, NULL, cipher, 8, 
            output, &amp;size);<a name="997412"> </a>
         if (err) {<a name="997413"> </a>
            DbgPrintf("SSFD: Error on CPMLibDecrypt 0x%x\n", 
               err);<a name="997414"> </a>
         } else {<a name="997415"> </a>
            DbgPrintf("SSFD: CPMLibDecrypt - deciphered data 
               of length 0x%x returned\n", size);<a name="997416"> </a>
         }<a name="997417"> </a>
         MemPtrFree(output);<a name="997418"> </a>
      }<a name="997419"> </a>
   }<a name="997420"> </a>
   CPMLibReleaseKeyInfo(&amp;keyInfo);<a name="997421"> </a>
}<a name="997422"> </a>
</pre><div class="CodeRule"><hr></div>


<h2 class="haH2">
  <a name="996775"> </a>Authentication Manager <a href="#992896"><span class="nav">^TOP^</span></a>
</h2>


<p><a name="997541"> </a>The Authentication Manager (AM) is an abstraction layer between applications and authentication methods. The framework provided by the AM allows modules (plug-ins) to be written that implement specific authentication scenarios. Users of the AM deal with generic interfaces and opaque objects that define an authentication context.</p>

<p><a name="995094"> </a>The Authentication Manager is the authority that can answer the question "Are you X?" reliably, by utilizing some method of identity verification such as a password. The question "Are you X?" may be asked about a user or an application.</p>

<p><a name="995095"> </a>The services provided by the AM handle the following tasks: credential (Token) management (creation, deletion, modification, and storage), authentication against stored credentials (querying user for system password), and a framework for run-time extensibility via plug-ins.</p>

<p><a name="995099"> </a>The Palm OS Cobalt implementation of the AM includes three authentication models: </p>
<ul type="disc">
  <li><a name="997775"> </a>Password based authentication (as in OS5)
  <li><a name="997776"> </a>Signed code (PKI) based authentication
  <li><a name="997777"> </a>Code fingerprint (hashed code) based authentication
</ul>
<h3 class="hbH3">
  <a name="993270"> </a>Authentication Tokens <a href="#992896"><span class="nav">^TOP^</span></a>
</h3>


<p><a name="993271"> </a>A token is a reference to an authentication requirement. The structure that represents a token contains credentials. Tokens can either be system tokens or non-system tokens. The only difference is in how the AM behaves when it destroys a token. When a system token is destroyed the AM takes all of the same actions as when destroying a non-system token, except that the named entry for the token is not removed from the AM's list of tokens. This is due to the fact that system tokens should always exist: they are "well known" tokens, such as the user token (password), or the admin token (password). Tokens can be marked as system tokens at the time they are created.</p>

<p><a name="998131"> </a>Every token has a unique system ID.</p>

<h4 class="hcH4">
  <a name="995270"> </a>Token Types
</h4>

<p><a name="998358"> </a><code>AmTokenEnum</code> is an enumeration of the different types of tokens that can be requested from the system. These are the most common type of tokens that the device will deal with. The custom type (<code>AmTokenCustom</code>) allows the plug-in to announce a custom type of token that it will service. If an application requests a custom token, the Authentication Manager examines all plug-ins and finds all that match that custom type. Out of all the matches the best fit is picked to create the token.</p>

<div class="CodeRule"><hr></div><pre class="CodeBlock">
typedef enum  {<a name="998137"> </a>
   AmTokenUnknown = 0,<a name="998139"> </a>
   AmTokenCustom,<a name="998141"> </a>
   AmTokenPassword,<a name="998143"> </a>
   AmTokenSignedCode,<a name="998145"> </a>
   AmTokenCodeFingerprint<a name="998147"> </a>
} AmTokenEnum<a name="998149"> </a>
</pre><div class="CodeRule"><hr></div>


<p><a name="993272"> </a>To authenticate a token, the AM invokes a plug-in that implements a specific authentication method.</p>

<h4 class="hcH4">
  <a name="998069"> </a>Token Strength
</h4>

<p><a name="998070"> </a>Associated with each token is the concept of "strength." Tokens can be either strong or weak; weak tokens are authentication tokens that can be easily guessed or broken, such as dictionary words for passwords, or weak cryptography keys. Within the token structure is the minimum level of strength that the plug-in supports for token creation. The following levels are defined:</p>

<dl>
<dt><a name="998071"> </a>AmTokenStrengthLow</dt>
<dd><a name="998072"> </a>The lowest level. There are no requirements for token creation.</dd>

<dt><a name="998073"> </a>AmTokenStrengthMedium</dt>
<dd><a name="998074"> </a>Some measures are taken to reject weak tokens.</dd>

<dt><a name="998075"> </a>AmTokenStrengthHigh</dt>
<dd><a name="998076"> </a>The generated token should be guaranteed to not be a weak token. </dd>

</dl>
<h3 class="hbH3">
  <a name="993274"> </a>Token Management Functions <a href="#992896"><span class="nav">^TOP^</span></a>
</h3>


<p><a name="998725"> </a>The Authentication Manager APIs include functions to create, destroy, modify, and authenticate tokens:</p>
<ul type="disc">
  <li><a name="998755"> </a><a href="Am.html#994904"><code>AmCreateToken()</code></a>
  <li><a name="998756"> </a><a href="Am.html#995174"><code>AmDestroyToken()</code></a>
  <li><a name="998800"> </a><a href="Am.html#995600"><code>AmModifyToken()</code></a>
  <li><a name="998778"> </a><a href="Am.html#994850"><code>AmAuthenticateToken()</code></a>
</ul>

<p><a name="998734"> </a>To get information about a token, you use one of these functions:</p>
<ul type="disc">
  <li><a name="998861"> </a><a href="Am.html#995403"><code>AmGetTokenBySystemId()</code></a>
  <li><a name="998862"> </a><a href="Am.html#995457"><code>AmGetTokenExtendedInfo()</code></a>
  <li><a name="998863"> </a><a href="Am.html#995546"><code>AmGetTokenInfo()</code></a>
</ul>

<p><a name="998841"> </a>Finally, when manipulating the plug-ins themselves you work with these Authentication Manager functions:</p>
<ul type="disc">
  <li><a name="998431"> </a><a href="Am.html#995272"><code>AmGetPluginInfo()</code></a>
  <li><a name="998433"> </a><a href="Am.html#995318"><code>AmGetPluginReferences()</code></a>
  <li><a name="998443"> </a><a href="Am.html#995675"><code>AmRegisterPlugin()</code></a>
  <li><a name="998445"> </a><a href="Am.html#995721"><code>AmRemovePlugin()</code></a>
</ul>

<p><a name="998958"> </a>The Authentication Manager also supports the "legacy" APIs from earlier versions of Palm OS. These are the functions declared in <code>Password.h</code>. (<a href="Password.html#992982"><code>PwdExists()</code></a>, <a href="Password.html#993057"><code>PwdRemove()</code></a>, <a href="Password.html#993105"><code>PwdSet()</code></a>, and <a href="Password.html#993151"><code>PwdVerify()</code></a>). These functions all act on the user token. and only work if the user token is of type <code>AmTokenPassword</code>.</p>

<p><a name="993327"> </a>The Authorization Manager functions are easy to use. For instance, the code excerpt in <a href="SecurityConcepts.html#999117">Listing 1.13</a> shows how to authenticate the user token.</p>
<p class="CCodeCaption">
  <a name="999117"> </a><b>Listing 1.13&nbsp;&nbsp;Authenticating the user token</b>
</p>

<div class="CodeRule"><hr></div><pre class="CodeBlock">
AmTokenType token;<a name="993328"> </a>
status_t err;<a name="993329"> </a>
<a name="993330"> </a>
AmGetTokenBySystemId(&amp;token, SysUserToken);<a name="993331"> </a>
err = AmAuthenticateToken(token, NULL, AmAuthenticationOther,
   NULL, NULL);<a name="993332"> </a>
if (err == errNone){<a name="999042"> </a>
   // Authentication succeeded. Do something here.<a name="999051"> </a>
} else {<a name="999052"> </a>
   // Authentication failed.<a name="999061"> </a>
}<a name="999070"> </a>
</pre><div class="CodeRule"><hr></div>


<p><a name="993335"> </a><a href="Am.html#994850"><code>AmAuthenticateToken()</code></a> can take hints about what type of authentication is being performed (database access, device unlock, and so on). In the above example it is <code>AmAuthenticationOther</code>. This function can also take and optional title and description strings. These can be used by the AM plug-in to clarify to the user just why they are being prompted to enter a password (or provide a thumbprint, or whatever).</p>
<h3 class="hbH3">
  <a name="999254"> </a>Using the Authentication Manager <a href="#992896"><span class="nav">^TOP^</span></a>
</h3>


<p><a name="999259"> </a>The Authentication Manager can be used either to authenticate a user or to authenticate code.</p>

<h4 class="hcH4">
  <a name="995278"> </a>User Authentication
</h4>

<p><a name="995279"> </a>User authentication requires that the user knows or has on his possession a secret that identifies him to the system. This secret comes in the form of a PIN, a password, biometrics, and so forth. The Authentication Manager collects the credentials being presented by the user and compares them to the stored credentials, thereby authenticating the user.</p>

<h4 class="hcH4">
  <a name="995280"> </a>Code Authentication
</h4>

<p><a name="995281"> </a>There are two major scenarios when it comes to code authentication: signed code and unsigned code.</p>

<p><a name="995282"> </a>Signed code is usually a third-party application or a system patch. It was signed with a certificate, which was assigned by a certificate authority. The AM can verify the signature of the code and authenticate the identity of the certificate that was used when the code was signed. This is how the system protects patchable or replaceable objects: by requiring that the application patching or replacing an object be signed by a well-known certificate. </p>

<p><a name="995283"> </a>Code that is not signed is treated differently. It is expensive to acquire certificates from a certificate authority, and most shareware developers will not go through the trouble, yet the system is still able to protect data from access by any other application. In order to provide a non-interactive authentication method, the system creates a token that uniquely identifies an application when that application is installed on the device. An application may use this token to protect objects, and the AM can then verify the identity of the application by re-calculating the identity of the application and matching it against the identity that was calculated at install time.</p>

<h5 class="hdH5">
  <a name="999576"> </a>Signature Verification Library
</h5>

<p><a name="995284"> </a>The Signature Verification Library does the bulk of the work for the following code authentication tasks:</p>
<ul type="disc">
  <li><a name="995285"> </a>Interpreting the sign resource in an application's resource database.
  <li><a name="995286"> </a>Extracting the X.509 certificate block from the sign resource.
  <li><a name="995287"> </a>Verifying the validity of a digital signature in a PRC file.
</ul>

<p><a name="995288"> </a>This library enables any application on the device to verify a signed PRC file. The Authentication Manager also uses this shared library to authenticate signed code. The AM's task is to authenticate currently running applications. Any other type of authentication that needs to be done can be accomplished by using this shared library.</p>

<p><a name="1003830"> </a>The Signature Verification Library is covered in detail under <a href="SecurityConcepts.html#993477">"Signature Verification Library."</a></p>
<h3 class="hbH3">
  <a name="1009026"> </a>Creating an Authentication Manager Plug-In <a href="#992896"><span class="nav">^TOP^</span></a>
</h3>


<p><a name="1009027"> </a>An Authentication Manager plug-in is a shared library of type <code>'ampl'</code> that extends the authentication services provided by the AM. Each plug-in implements one authentication model, and is responsible for implementing any UI associated with that model. Authentication Manager plug-ins are loaded by the security process when the new plug-in is registered with the AM.</p>

<div><hr>
  <a name="1009028"> </a> <b>IMPORTANT: </b> Plug-ins execute in privileged space and have access to the whole system. Bugs in these modules can create security holes that can potentially expose all of the data on the device.
<hr>
</div>

<h4 class="hcH4">
  <a name="1009029"> </a>Working With Tokens
</h4>

<p><a name="1009030"> </a>Plug-ins publish information about the type of tokens they can create when registering with the AM. The AM then uses that information to find the most appropriate plug-in to use when an application creates a token.  An application that wishes to use specific features supported by a specific plug-in is able to request that plug-in when creating a new token.</p>

<p><a name="1009031"> </a>The plug-in that creates the token defines the structure of the token's data.  Since the data for the token must be tamper proof, it is stored in system space (owned by the Authentication Manager), and the application is only given a reference: an <a href="Am.html#994072"><code>AmTokenType</code></a>.  When the AM is asked to authenticate with a token, the plug-in that created the token is asked to collect a new token and compare it with the stored token. If the two tokens match, the authentication passes.</p>

<p><a name="1009035"> </a>Plug-ins may define their own internal data structures to use for storing information about the token.  The memory may be controlled by the AM or by the plug-in. If the memory allocation and deallocation is to be done by the AM, the plug-in must specify how much memory to allocate per token in the registration structure of the plug-in.</p>

<p><a name="1010297"> </a>The custom token type (<code>AmTokenCustom</code>) allows the plug-in to announce a custom type of token that it will service. If your plug-in creates custom tokens, be sure that it fills in the <code>identifier</code> field of the <a href="Am.html#993740"><code>AmTokenPropertiesType</code></a> structure with the identifier for the plug-in. Otherwise, the <code>identifier</code> field can be set to 0.</p>

<p><a name="1009037"> </a>Each token has a public info block that can be shared with applications through <a href="Am.html#995546"><code>AmGetTokenInfo()</code></a>.  This info, defined by the <a href="Am.html#993472"><code>AmTokenInfoType</code></a> structure, is set by the plug-in when the token is created.  Plug-ins may use their own discretion on how much information to divulge. Note that not all fields are applicable to all types of tokens.</p>

<p><a name="1009047"> </a>Token attributes (defined by the <a href="Am.html#993412"><code>AmTokenAttributesType</code></a> structure) are flags that specify information about the token.  The plug-in sets these flags and uses them later to allow or reject certain actions.</p>

<dl>
<dt><a name="1009048"> </a>destroy</dt>
<dd><a name="1009049"> </a>the token may be destroyed.</dd>

<dt><a name="1009050"> </a>modify</dt>
<dd><a name="1009051"> </a>the token may be modified.</dd>

<dt><a name="1009052"> </a>interactive</dt>
<dd><a name="1009053"> </a>the token is user interactive. That is, it is a password, PIN, or the like.</dd>

<dt><a name="1009054"> </a>empty</dt>
<dd><a name="1009055"> </a>the token is empty.</dd>

<dt><a name="1009056"> </a>system</dt>
<dd><a name="1009057"> </a>the token is a system token.</dd>

</dl>

<p><a name="1009058"> </a>The remaining fields of the <code>AmTokenInfoType</code> structure are set or filled in by the Authentication Manager, except for the "friendly name" which should be supplied by the plug-in.</p>

<p><a name="1011729"> </a>The function <a href="Am.html#994850"><code>AmAuthenticateToken()</code></a> can take hints about what type of authentication is being performed (database access, device unlock, and so on) in the form of an <a href="Am.html#994510"><code>AmAuthenticationEnum</code></a> value. This function can also take optional title and description strings. These can be used by the AM plug-in to clarify to the user just why they are being prompted to enter a password (or provide a thumbprint, or whatever).</p>

<h4 class="hcH4">
  <a name="1009059"> </a>Plug-In Entry Points
</h4>

<p><a name="1009062"> </a>A plug-in is a shared library that has a main entry point (see <a href="SecurityConcepts.html#1009209">"The Main Entry Point"</a>) which receives launch codes.  During the processing of the <a href="../Programming_Basics/CmnLaunchCodes.html#994023"><code>sysAppLaunchCmdNormalLaunch</code></a> launch code it fills in an initialization data structure which lets the AM know the address of its entry points. These entry points constitute a protocol for capturing, replacing, verifying, destroying, importing, and exporting tokens.  The AM invokes these entry points in a defined sequence when carrying out a task such as creating a token. Some of the entry points have a context argument (an <a href="Am.html#992950"><code>AmApplicationCtxType</code></a>) that lets the plug-in know the context in which it is executing. This allows the plug-in to implement the correct UI associated with a given action under different contexts.</p>

<p><a name="1009070"> </a>An AM plug-in implements entry points for the following actions:</p>

<dl>
<dt><a name="1009074"> </a><a href="SecurityConcepts.html#1009116">Open and Close</a></dt>
<dd><a name="1009075"> </a>Called at load and unload time, respectively.</dd>

<dt><a name="1009079"> </a><a href="SecurityConcepts.html#1009133">Capture</a></dt>
<dd><a name="1009080"> </a>Called by the AM during the capture of token information.</dd>

<dt><a name="1009084"> </a><a href="SecurityConcepts.html#1009147">Match</a></dt>
<dd><a name="1009085"> </a>Called by the AM to compare two tokens.</dd>

<dt><a name="1009089"> </a><a href="SecurityConcepts.html#1009157">Destroy Notify</a></dt>
<dd><a name="1009090"> </a>Called by the AM when a token is being destroyed.</dd>

<dt><a name="1009094"> </a><a href="SecurityConcepts.html#1009167">Get Extended Info</a></dt>
<dd><a name="1009095"> </a>Called to get extended information about a plug-in.</dd>

<dt><a name="1009099"> </a><a href="SecurityConcepts.html#1009177">Import and Export</a></dt>
<dd><a name="1009100"> </a>Called to import or export a plug-in.</dd>

<dt><a name="1009104"> </a><a href="SecurityConcepts.html#1009188">Get Derived Data</a></dt>
<dd><a name="1009105"> </a>Called to get derived data from a token.</dd>

<dt><a name="1009109"> </a><a href="SecurityConcepts.html#1009198">Admin</a></dt>
<dd><a name="1009110"> </a>Called by the AM to administer a plug-in.</dd>

</dl>

<p><a name="1009111"> </a>Except for the <code>PluginOpen</code> and <code>PluginClose</code> functions, the plug-in exports the above listed functions in an <a href="AmPlugin.html#992975"><code>AmPluginFunctionsType</code></a> structure.</p>

<h5 class="hdH5">
  <a name="1009116"> </a>Open and Close
</h5>

<p><a name="1009117"> </a><code>PluginOpen</code> is generally called upon receipt of a <a href="../Programming_Basics/CmnLaunchCodes.html#994023"><code>sysAppLaunchCmdNormalLaunch</code></a> launch code, while <code>PluginClose</code> is usually called upon receipt of a <a href="../Programming_Basics/CmnLaunchCodes.html#993881"><code>sysLaunchCmdFinalize</code></a> launch code.</p>

<p><a name="1009124"> </a><code>PluginOpen</code> and <code>PluginClose</code> are not directly invoked by the AM. Instead, the shared library support is used to let the plug-in know about these actions.  That is, the main entry point for the shared library receives the following launch codes:</p>

<dl>
<dt><a name="1009125"> </a><code>sysAppLaunchCmdNormalLaunch</code></dt>
<dd><a name="1009126"> </a>Instructs the plug-in to initialize itself. This is the "<code>PluginOpen</code>" functionality. Along with this launch code the plug-in is passed a pointer to an <a href="AmPlugin.html#993267"><code>AmPluginPrivType</code></a> structure (in the command block pointer argument). The plug-in should initialize the <code>ftn</code> field with pointers to those functions that the plug-in exports. It should also set up the <code>info</code> field with pertinent information about the plug-in (friendly name, vendor, version, and so on) and the token properties, and set the <code>tokenDataLength</code> and <code>tokenExtendedInfoLength</code> fields as appropriate. Finally, the plug-in should open any needed libraries (such as the CPM) and then return <code>errNone</code>.</dd>

<dt><a name="1009130"> </a><code>sysLaunchCmdFinalize</code></dt>
<dd><a name="1009131"> </a>Instructs the plug-in to close. It should perform any necessary cleanup and close any libraries opened by the <code>PluginOpen</code> function.</dd>

</dl>

<h5 class="hdH5">
  <a name="1009133"> </a>Capture
</h5>

<p><a name="1009134"> </a>The Capture function is called whenever the AM needs your plug-in to create a new token, or to verify or replace an existing token created by the plug-in. Capture is invoked with one of four defined modes (<a href="AmPlugin.html#993605"><code>AmCallMode</code></a>): <b>Enrollment</b>, <b>Verification</b>, <b>Replacement Start</b>, and <b>Replacement End</b>. Enrollment is used when a new token is being created. Verification is used when capturing tokens for authentication. Replacement is a two-phase protocol: first the AM may need to authenticate access to modify a token (start), and then it captures a new token to replace the old (end) with.</p>

<p><a name="1009138"> </a>During the processing of this function the plug-in may implement UI to gather tokens.  The mode passed in to this entry point can help determine the exact UI to present.</p>

<p><a name="1009139"> </a>Your Capture function should use the following prototype:</p>

<div class="CodeRule"><hr></div><pre class="CodeBlock">
status_t (*pluginCaptureFtn)(AmCallMode, AmApplicationCtxType *,
AmTokenPrivType *, AmAuthenticationEnum, char *, char *)<a name="1013765"> </a>
</pre><div class="CodeRule"><hr></div>


<p><a name="1013769"> </a>See the description of <a href="AmPlugin.html#992975"><code>AmPluginFunctionsType</code></a> for a description of this function's parameters.</p>

<p><a name="1009145"> </a>Your Capture function should return <code>errNone</code> if the operation completed successfully. Otherwise, return an appropriate Authentication Manager (or other) error code.</p>

<h5 class="hdH5">
  <a name="1009147"> </a>Match
</h5>

<p><a name="1009148"> </a>When the AM needs to verify a token it invokes the associated plug-in's match entry point, passing in two token structures for comparision. Any success or failure UI is implemented by the plug-in.</p>

<p><a name="1009149"> </a>Your Match function should use the following prototype:</p>

<div class="CodeRule"><hr></div><pre class="CodeBlock">
status_t (*pluginMatchFtn)(AmApplicationCtxType *, AmTokenPrivType *,
AmTokenPrivType *)<a name="1009150"> </a>
</pre><div class="CodeRule"><hr></div>


<p><a name="1009154"> </a>See the description of <a href="AmPlugin.html#992975"><code>AmPluginFunctionsType</code></a> for a description of this function's parameters.</p>

<p><a name="1009155"> </a>Your Match function should return <code>errNone</code> if the operation completed successfully. Otherwise, return an appropriate error code such as <code>amErrAuthenticationFailed</code>.</p>

<h5 class="hdH5">
  <a name="1009157"> </a>Destroy Notify
</h5>

<p><a name="1009158"> </a>The destroy notification is sent to the plug-in that created the token when the token is destroyed.  Destroying a token is an action that may be taken if the user has lost the ability to authenticate against that token (as in the case of a lost password). When creating a token the plug-in sets a flag that allows or disallows its destruction.</p>

<p><a name="1009159"> </a>Your Destroy Notify function, if your plug-in implements one, should use the following prototype:</p>

<div class="CodeRule"><hr></div><pre class="CodeBlock">
status_t (*pluginDestroyNotifyFtn)(AmTokenPrivType *)<a name="1009160"> </a>
</pre><div class="CodeRule"><hr></div>


<p><a name="1009164"> </a>See the description of <a href="AmPlugin.html#992975"><code>AmPluginFunctionsType</code></a> for a description of this function's parameters.</p>

<p><a name="1009165"> </a>Your Destroy Notify function should return <code>errNone</code> if the operation completed successfully. Otherwise, return an appropriate Authentication Manager (or other) error code.</p>

<h5 class="hdH5">
  <a name="1009167"> </a>Get Extended Info
</h5>

<p><a name="1009168"> </a>This function is used to answer the query for extended info by an application. A plug-in is not required to support this entry point, though it can be useful for certain types of tokens. The Palm OS PKI plug-in returns the certificate ID of the token (in an <a href="AmPluginSignedCode.html#992950"><code>AmPluginSignedCodeExtInfoType</code></a> structure). The Palm OS Code Fingerprint plug-in returns the type, creator, and name of the database that was fingerprinted (in an <a href="AmPluginCodePrint.html#992950"><code>AmPluginCodePrintExtInfoType</code></a> structure). The Palm OS password plug-in, however, doesn't implement this function. </p>

<p><a name="1012934"> </a>Your Get Extended Info function, if your plug-in implements one, should use the following prototype:</p>

<div class="CodeRule"><hr></div><pre class="CodeBlock">
status_t (*pluginGetTokenExtendedInfoFtn)(AmTokenPrivType *, uint8_t *,
uint32_t)<a name="1009170"> </a>
</pre><div class="CodeRule"><hr></div>


<p><a name="1009174"> </a>See the description of <a href="AmPlugin.html#992975"><code>AmPluginFunctionsType</code></a> for a description of this function's parameters.</p>

<p><a name="1009175"> </a>Your Get Extended Info function should return <code>errNone</code> if the operation completed successfully. Otherwise, return an appropriate Authentication Manager (or other) error code.</p>

<h5 class="hdH5">
  <a name="1009177"> </a>Import and Export
</h5>

<p><a name="1009178"> </a>If the Authentication Manager does all of the memory management for a particular plug-in, then the export and import of that plug-in's tokens is mostly taken care of by the AM.  The AM will make sure that the buffer it has allocated for internal data for each token is exported and imported correctly.  Plug-ins only need to worry about exporting or importing data that they have allocated themselves.</p>

<p><a name="1009179"> </a>The Import and Export entry points are for copying internal data about a token for import or export. In your export function, memory that is associated with a token <i>and is managed by the plug-in</i> should be copied to the provided buffer and returned to the AM.  The import function should do the opposite: copy the contents of a passed-in buffer into the token memory managed by the plug-in. Note that import and export functions are needed only for tokens that have associated data not managed by the AM itself. Because the Authentication Managert knows how to import and export the buffer that is allocated by the AM for the token data, simple plug-ins such as the password plug-in don't need to implement import and export functions.</p>

<p><a name="1009180"> </a>Your Import and Export functions, if your plug-in implements them, should use the following prototypes:</p>

<div class="CodeRule"><hr></div><pre class="CodeBlock">
status_t (*pluginImportTokenFtn)(AmTokenPrivType *, uint8_t *, uint32_t)
status_t (*pluginExportTokenFtn)(AmTokenPrivType *, uint8_t *, uint32_t *)<a name="1009181"> </a>
</pre><div class="CodeRule"><hr></div>


<p><a name="1009185"> </a>See the description of <a href="AmPlugin.html#992975"><code>AmPluginFunctionsType</code></a> for a description of the function parameters.</p>

<p><a name="1009186"> </a>Your Import and Export functions should return <code>errNone</code> if the operation completed successfully. Otherwise, return an appropriate Authentication Manager (or other) error code.</p>

<h5 class="hdH5">
  <a name="1009188"> </a>Get Derived Data
</h5>

<p><a name="1009189"> </a>This function is used solely by the operating system to get seed data for a cryptographic key derived from an authentication token (such as password derived keys). Currently the only user of this feature is the Data Manager; it uses this feature to generate password-derived keys for the backup  function.</p>

<p><a name="1009190"> </a>Your Get Derived Data function, if your plug-in implements one, should use the following prototype:</p>

<div class="CodeRule"><hr></div><pre class="CodeBlock">
status_t (*pluginGetDerivedData)(AmTokenPrivType *, uint8_t *, uint32_t *)<a name="1009191"> </a>
</pre><div class="CodeRule"><hr></div>


<p><a name="1009195"> </a>See the description of <a href="AmPlugin.html#992975"><code>AmPluginFunctionsType</code></a> for a description of the function parameters.</p>

<p><a name="1009196"> </a>Your Get Derived Data function should return <code>errNone</code> if the operation completed successfully. Otherwise, return an appropriate Authentication Manager (or other) error code.</p>

<h5 class="hdH5">
  <a name="1009198"> </a>Admin
</h5>

<p><a name="1010245"> </a>This function is the admin entry point for the plug-in. Some plug-ins may have settings that can be changed (a biometric plug-in, for instance, might allow the user to tweak the settings it uses to match tokens); accordingly, the plug-in can implement an admin UI in its implementation of this function. </p>

<p><a name="1009201"> </a>Your Admin function, if your plug-in implements one, should use the following prototype:</p>

<div class="CodeRule"><hr></div><pre class="CodeBlock">
status_t (*pluginAdminFtn)(AmPluginType *)<a name="1009202"> </a>
</pre><div class="CodeRule"><hr></div>


<p><a name="1009206"> </a>See the description of <a href="AmPlugin.html#992975"><code>AmPluginFunctionsType</code></a> for a description of the function parameters.</p>

<p><a name="1009207"> </a>Your Admin function should return <code>errNone</code> if the operation completed successfully. Otherwise, return an appropriate Authentication Manager (or other) error code.</p>

<h4 class="hcH4">
  <a name="1009209"> </a>The Main Entry Point
</h4>

<p><a name="1009210"> </a>The main entry point must have a definition as follows:</p>
<h4>
  <a name="1009211"> </a>Prototype 
</h4>
<pre class="proto"><a name="1009212"></a>uint32_t AmPluginMain (uint16_t cmd, 

MemPtr cmdPBP, uint16_t launchFlags)


</pre>
<h4>
  <a name="1009213"> </a>Parameters 
</h4>

<dl>
<dt><a name="1009214"> </a><code>cmd</code></dt>
<dd><a name="1009215"> </a>The launch code. Of particular interest are <code>sysAppLaunchCmdNormalLaunch</code> and <code>sysLaunchCmdFinalize</code>.</dd>

<dt><a name="1009216"> </a><code>cmdPBP</code></dt>
<dd><a name="1009217"> </a>When the launch code is <code>sysAppLaunchCmdNormalLaunch</code>, this parameter points to an <a href="AmPlugin.html#993267"><code>AmPluginPrivType</code></a> structure. The plug-in must fill in this structure before returning. </dd>

<dt><a name="1009221"> </a><code>launchFlags</code></dt>
<dd><a name="1009222"> </a>Not used.</dd>

</dl>
<h4>
  <a name="1009223"> </a>Returns 
</h4>

<p><a name="1009224"> </a>Return <code>errNone</code> to successfully register the plug-in. Otherwise, return one of the error codes declared in <code>Am.h</code>.</p>

<p><a name="1009225"> </a>The following is a sample implementation of a plug-in entry point and initialization function:</p>
<p class="CCodeCaption">
  <a name="1009226"> </a><b>Listing 1.14&nbsp;&nbsp;Sample plug-in entry point function</b>
</p>

<div class="CodeRule"><hr></div><pre class="CodeBlock">
uint32_t AmPkiPluginMain(uint16_t cmd, MemPtr cmdPBP,
   uint16_t launchFlags){<a name="1009227"> </a>
   switch(cmd) {<a name="1009228"> </a>
      case sysLaunchCmdInitialize:<a name="1009229"> </a>
      {<a name="1009230"> </a>
         // Do custom initialization here<a name="1009231"> </a>
         break;<a name="1009232"> </a>
      }<a name="1009233"> </a>
      <a name="1009234"> </a>
      case sysAppLaunchCmdNormalLaunch:<a name="1009235"> </a>
      {<a name="1009236"> </a>
         // For a PkiPlugin -- do the open<a name="1009237"> </a>
         AmPluginPrivType *pPlugin = 
            (AmPluginPrivType *)cmdPBP;<a name="1009238"> </a>
         <a name="1009239"> </a>
         return (AmPkiPluginOpen(pPlugin));<a name="1009240"> </a>
      }<a name="1009241"> </a>
      <a name="1009242"> </a>
      case sysLaunchCmdFinalize:<a name="1009243"> </a>
      {<a name="1009244"> </a>
         // Do custom de-initialization here<a name="1009245"> </a>
         break;<a name="1009246"> </a>
      }<a name="1009247"> </a>
      default:<a name="1009248"> </a>
         break;<a name="1009249"> </a>
   }<a name="1009250"> </a>
<a name="1009251"> </a>
   return 0;<a name="1009252"> </a>
}<a name="1009253"> </a>
<a name="1009254"> </a>
status_t AmPwPluginOpen(AmPluginPrivType *pPlugin){<a name="1009255"> </a>
    uint16_t  numProviders	= 0;<a name="1009256"> </a>
    status_t     err;<a name="1009257"> </a>
    <a name="1009258"> </a>
    // Setup the function array<a name="1009259"> </a>
    pPlugin-&gt;ftn.pluginCaptureFtn = AmPwPluginCapture;<a name="1009260"> </a>
    pPlugin-&gt;ftn.pluginMatchFtn = AmPwPluginMatch;<a name="1009261"> </a>
    pPlugin-&gt;ftn.pluginDestroyNotifyFtn =
      AmPwPluginDestroyNotify;<a name="1009262"> </a>
    pPlugin-&gt;ftn.pluginAdminFtn = AmPwPluginAdmin;<a name="1009263"> </a>
    pPlugin-&gt;ftn.pluginGetDerivedData =
      AmPwPluginGetDerivedData;<a name="1009264"> </a>
    <a name="1009265"> </a>
    // Setup the info piece<a name="1009266"> </a>
    strcpy(pPlugin-&gt;info.friendlyName, PwPluginFriendlyName);<a name="1009267"> </a>
    strcpy(pPlugin-&gt;info.vendor, PwPluginVendor);<a name="1009268"> </a>
    pPlugin-&gt;info.version = PwPluginVersion;<a name="1009269"> </a>
    <a name="1009270"> </a>
    pPlugin-&gt;info.tokenProperties.type = AmTokenPassword;<a name="1009271"> </a>
    pPlugin-&gt;info.tokenProperties.strength =
      AmTokenStrengthLow;<a name="1009272"> </a>
    pPlugin-&gt;info.tokenProperties.identifier =
      PwPluginCreator;<a name="1009273"> </a>
    <a name="1009274"> </a>
    // Setup the token length<a name="1009275"> </a>
    pPlugin-&gt;tokenDataLength = sizeof(PwPluginTokenType);<a name="1009276"> </a>
<a name="1009277"> </a>
    return (err);<a name="1009278"> </a>
}<a name="1009279"> </a>
</pre><div class="CodeRule"><hr></div>


<h4 class="hcH4">
  <a name="1009280"> </a>Sample Plug-In Implementations
</h4>

<p><a name="1009281"> </a>The following sections provide some details about how the sample implementations of the three standard plug-ins provided to Palm OS licencees are implemented.</p>

<h5 class="hdH5">
  <a name="1009282"> </a>Password Plug-In
</h5>

<p><a name="1009283"> </a>The password plug-in doesn't store plain-text passwords. Instead, it stores hashes of the passwords (SHA1 or MD5). Comparisons are done using the hashes.</p>

<p><a name="1009284"> </a>The Password plug-in implements the AM plug-in interface in the following manner:</p>

<dl>
<dt><a name="1009285"> </a>Open</dt>
<dd><a name="1009286"> </a>Initializes the entry point function array, sets the plug-in properties (<code>friendlyName</code> , <code>vendor</code>, and <code>version</code>), sets the token properties (<code>type</code> = <code>AmTokenPassword</code>, <code>strength</code> = <code>AmTokenStrengthLow</code>, <code>identifier</code>), sets the token data length to <code>sizeof(PwPluginTokenType)</code>, and opens the CPM.</dd>

<dt><a name="1009287"> </a>Close</dt>
<dd><a name="1009288"> </a>Closes the CPM.</dd>

<dt><a name="1009289"> </a>Capture</dt>
<dd><a name="1009292"> </a>Supports each mode as described under <a href="SecurityConcepts.html#1009133">"Capture."</a></dd>

<dt><a name="1009294"> </a>Match</dt>
<dd><a name="1009295"> </a>Compares the supplied password hashes.</dd>

<dt><a name="1009296"> </a>Destroy Notify</dt>
<dd><a name="1009297"> </a>Frees the memory allocated to the password hint.</dd>

<dt><a name="1009298"> </a>Get Token Extended Info</dt>
<dd><a name="1009299"> </a>Not implemented.</dd>

<dt><a name="1009300"> </a>Import/Export</dt>
<dd><a name="1009301"> </a>Not implemented.</dd>

<dt><a name="1009302"> </a>Get Derived Data</dt>
<dd><a name="1009303"> </a>Copies the password hash into the supplied buffer.</dd>

<dt><a name="1009304"> </a>Admin</dt>
<dd><a name="1009305"> </a>Does nothing.</dd>

</dl>

<h5 class="hdH5">
  <a name="1009306"> </a>Certificate Plug-in
</h5>

<p><a name="1009307"> </a>The certificate plug-in implements a code-signing authentication model.  This plug-in can verify whether a specific application has been signed by a specific certificate.  Tokens associated with this plug-in authenticate when the executing application has a signature from this certificate (the certificate ID is stored in the token).</p>

<p><a name="1009308"> </a>The Certificate plug-in implements the AM plug-in interface in the following manner:</p>

<dl>
<dt><a name="1009309"> </a>Open</dt>
<dd><a name="1009310"> </a>Initializes the entry point function array, sets the plug-in properties (<code>friendlyName</code> , <code>vendor</code>, and <code>version</code>), sets the token properties (<code>type</code> = <code>AmTokenSignedCode</code>, <code>strength</code> = <code>AmTokenStrengthHigh</code>, <code>identifier</code>), sets the token data length to <code>sizeof(PkiPluginTokenType)</code>, sets the <code>tokenExtendedInfoLength</code> to <code>sizeof(AmPluginSignedCodeExtInfoType)</code>, and opens the CPM.</dd>

<dt><a name="1009311"> </a>Close</dt>
<dd><a name="1009312"> </a>Closes the CPM.</dd>

<dt><a name="1009313"> </a>Capture</dt>
<dd><a name="1009314"> </a>Implements <code>AmEnrollment</code> and <code>AmVerification</code>. <code>AmReplacementStart</code> and <code>AmReplacementEnd</code> simply return <code>amErrActionnotSupported</code>.</dd>

<dt><a name="1009315"> </a>Match</dt>
<dd><a name="1009316"> </a>Compares the supplied tokens.</dd>

<dt><a name="1009317"> </a>Destroy Notify</dt>
<dd><a name="1009318"> </a>Not implemented. Tokens created by this plug-in cannot be destroyed.</dd>

<dt><a name="1009319"> </a>Get Token Extended Info</dt>
<dd><a name="1009320"> </a>Copies the certificate ID to the supplied buffer.</dd>

<dt><a name="1009321"> </a>Import/Export</dt>
<dd><a name="1009322"> </a>Not implemented.</dd>

<dt><a name="1009323"> </a>Get Derived Data</dt>
<dd><a name="1009324"> </a>Not implemented.</dd>

<dt><a name="1009325"> </a>Admin</dt>
<dd><a name="1009326"> </a>Not implemented.</dd>

</dl>

<h5 class="hdH5">
  <a name="1009327"> </a>Application Fingerprint Plug-in
</h5>

<p><a name="1009328"> </a>A application fingerprint is a cryptographic hash of an application's resources.  This plug-in implements an authentication model where current application must match a previously-stored cryptographic hash.  This allows the system to set up access control where a specific application is granted access.</p>

<p><a name="1009329"> </a>The Application Fingerprint plug-in implements the AM plug-in interface in the following manner:</p>

<dl>
<dt><a name="1009330"> </a>Open</dt>
<dd><a name="1009331"> </a>Initializes the entry point function array, sets the plug-in properties (<code>friendlyName</code> , <code>vendor</code>, and <code>version</code>), sets the token properties (<code>type</code> = <code>AmTokenCodeFingerprint</code>, <code>strength</code> = <code>AmTokenStrengthLow</code>, <code>identifier</code>), sets the token data length to <code>sizeof(CodePrintPluginTokenType)</code>, sets the <code>tokenExtendedInfoLength</code> to <code>sizeof(AmPluginCodePrintExtInfoType)</code>, and opens the CPM.</dd>

<dt><a name="1009332"> </a>Close</dt>
<dd><a name="1009333"> </a>Closes the CPM.</dd>

<dt><a name="1009334"> </a>Capture</dt>
<dd><a name="1009335"> </a>Implements <code>AmEnrollment</code> and <code>AmVerification</code>. <code>AmReplacementStart</code> and <code>AmReplacementEnd</code> simply return <code>amErrActionnotSupported</code>.</dd>

<dt><a name="1009336"> </a>Match</dt>
<dd><a name="1009337"> </a>Compares the supplied tokens.</dd>

<dt><a name="1009338"> </a>Destroy Notify</dt>
<dd><a name="1009339"> </a>Not implemented. Tokens created by this plug-in cannot be destroyed.</dd>

<dt><a name="1009340"> </a>Get Token Extended Info</dt>
<dd><a name="1009341"> </a>Copies the database name to the supplied buffer.</dd>

<dt><a name="1009342"> </a>Import/Export</dt>
<dd><a name="1009343"> </a>Not implemented.</dd>

<dt><a name="1009344"> </a>Get Derived Data</dt>
<dd><a name="1009345"> </a>Not implemented.</dd>

<dt><a name="1009346"> </a>Admin</dt>
<dd><a name="1009347"> </a>Not implemented.</dd>

</dl>
<h3 class="hbH3">
  <a name="1009348"> </a>Manipulating Authentication Manager Plug-Ins <a href="#992896"><span class="nav">^TOP^</span></a>
</h3>


<p><a name="1010775"> </a>The header file <code>Am.h</code> defines functions that allow you to install and remove Authentication Manager plug-ins, as well as get information about an installed plug-in and find all references to an installed plug-in.</p>

<h4 class="hcH4">
  <a name="1009612"> </a>Installing a Plug-in
</h4>

<p><a name="1011777"> </a>Call <a href="Am.html#995675"><code>AmRegisterPlugin()</code></a> to install, or <b>register</b>, a plug-in. This function loads and opens the plug-in shared library. If you attempt to register a plug-in that is already registered you will be notified of that fact unless you set the <code class="par">force</code> parameter to <code>true</code>, in which case the plug-in is closed and unloaded, then loaded and reopened. In this case the reference to the plug-in doesn't change; it is re-used. This means that all tokens still have a valid reference to their creator.</p>

<p><a name="1011819"> </a>As explained in <a href="SecurityConcepts.html#1009619">"Plug-in Security,"</a> the plug-in system space is protected by a token which must be authenticated against prior to installation; this keeps rogue plug-ins from being allowed onto the device that could circumvent all authentication security. </p>

<h4 class="hcH4">
  <a name="1009617"> </a>Removing a Plug-in
</h4>

<p><a name="1011081"> </a>You remove an installed Authentication Manager plug-in by calling <a href="Am.html#995721"><code>AmRemovePlugin()</code></a>. Note that you can only remove a plug-in if there are no tokens on the device that have been created by that plug-in.</p>

<h4 class="hcH4">
  <a name="1012047"> </a>Other Plug-in Manipulation Operations
</h4>

<p><a name="1012134"> </a>Call <a href="Am.html#995272"><code>AmGetPluginInfo()</code></a> to get the public info block for a registered plug-in. The returned <a href="Am.html#993343"><code>AmPluginInfoType</code></a> data structure contains information about the plug-in, such as vendor name, friendly name, and information about the type of tokens that the plug-in can create.</p>

<p><a name="1012165"> </a>To get a list of all currently registered Authentication Manager plug-ins, call <a href="Am.html#995318"><code>AmGetPluginReferences()</code></a>. You must allocate the array into which the list of references (each is an <a href="Am.html#993387"><code>AmPluginType</code></a>) is written; call <code>AmGetPluginReferences()</code> with a <code>NULL</code> pointer for the array to have returned to you the number of elements that would be written to the array.</p>

<h4 class="hcH4">
  <a name="1009619"> </a>Plug-in Security
</h4>

<p><a name="1009620"> </a>The storage area used to hold plug-in information is protected by a token. Authentication against this token is necessary before a plug-in can be installed or removed. So, for instance, if the plug-in storage space is protected by a password token, the user would need to enter a password before a plug-in could be installed or removed.</p>

<p><a name="1011375"> </a>The device manufacturer can create a policy that controls how Authentication Manager plug-ins are installed. If no policies are set, the device behaves as follows when installing a plug-in:</p>
<ul type="disc">
  <li><a name="1011376"> </a>If the user's current security level is set to None, the plug-in is installed.
  <li><a name="1011389"> </a>If the user's current security level is set to Medium, the user is prompted to choose whether or not the plug-in should be installed.
  <li><a name="1011413"> </a>If the user's current security level is set to High, the plug-in is not installed.
</ul>

<h2 class="haH2">
  <a name="993218"> </a>Authorization Manager <a href="#992896"><span class="nav">^TOP^</span></a>
</h2>


<p><a name="993344"> </a>The Authorization Manager (AZM) manages access control lists that are based on authentication tokens. These control lists are called rule sets. <a href="SecurityConcepts.html#993355">Figure 1.2</a> illustrates the basic rule-set syntax.</p>

<p class="FFigureCaption">
  <a name="993355"> </a><b>Figure 1.2&nbsp;&nbsp;Rule-set syntax</b>
</p>
<div align="left"><img src="images/SecurityConcepts2.jpg" height="316" width="480" border="0" hspace="0" vspace="0">
</div>

<p><a name="993410"> </a><a href="SecurityConcepts.html#993371">Figure 1.3</a> illustrates a simple rule set. When this rule set is evaluated, it will be satisfied if the currently running application's signature can be verified with either certificate "A" or certificate "B". </p>

<p class="FFigureCaption">
  <a name="993371"> </a><b>Figure 1.3&nbsp;&nbsp;A simple rule-set</b>
</p>
<div align="left"><img src="images/SecurityConcepts3.jpg" height="184" width="480" border="0" hspace="0" vspace="0">
</div>

<p><a name="993439"> </a>The set of APIs exposed by the Authorization Manager to third-party developers is quite small, consisting only of:</p>
<ul type="disc">
  <li><a name="999679"> </a><a href="azm.html#993577"><code>AzmAddRule()</code></a>, which lets you add an access rule to an existing rule-set container for a specific action.
  <li><a name="999709"> </a><a href="azm.html#996987"><code>AzmNonInteractiveAuthorize()</code></a>, which authorizes an action given a rule-set reference.
  <li><a name="999723"> </a><a href="azm.html#993631"><code>AzmGetSyncBypass()</code></a> and <a href="azm.html#997438"><code>AzmSetSyncBypass()</code></a>, which let you get and set the <b>sync bypass flag</b> in an existing rule-set container for a specific action. Sync-bypass must enabled for a specific action in order for an authenticated sync agent to be able to complete that action successfully. 
</ul>

<p><a name="999887"> </a>Note that as a third-party developer you cannot create or destroy rule sets.</p>

<p><a name="993464"> </a>Applications use <code>AzmAddRule()</code> to add rules to a rule set. <a href="SecurityConcepts.html#999911">Listing 1.15</a> presents one common operation: authenticating the user to perform a particular action.</p>
<p class="CCodeCaption">
  <a name="999911"> </a><b>Listing 1.15&nbsp;&nbsp;Adding a rule to a rule set</b>
</p>

<div class="CodeRule"><hr></div><pre class="CodeBlock">
AmTokenType usertoken;<a name="993465"> </a>
AzmRulesetType ruleSet;<a name="993466"> </a>
<a name="999942"> </a>
AmGetTokenBySystemId(&amp;usertoken, SysUserToken);<a name="993467"> </a>
<a name="993468"> </a>
ruleSet = CreateProtectedResource();<a name="993469"> </a>
err = AzmAddRule(ruleSet, action, "%t", usertoken);<a name="993470"> </a>
</pre><div class="CodeRule"><hr></div>


<p><a name="1014111"> </a>The contents of the action parameter depend upon what is being protected. Many applications will use access rules to control access to schema databases. See <a href="../Memory_Databases_Files/SchemaDatabases.html#1025368">"Schema Database Access Rule Action Types"</a> of <i>Exploring Palm OS: Memory, Databases, Files</i> for the access rules that can be applied to schema databases.</p>

<p><a name="993472"> </a>The above shows the addition of a very simple rule. More complex rules can be constructed using AND and OR logic operations. To construct a rule set that is valid if either of two tokens is authorized, use the logic operator OR when specifying the rule format string, as in "<code>%t OR %t</code>". An AND operation is even simpler, since you don't supply the word "AND." Simply specify the format like this: "<code>%t %t</code>".</p>

<h2 class="haH2">
  <a name="993432"> </a>Certificate Manager <a href="#992896"><span class="nav">^TOP^</span></a>
</h2>


<p><a name="993480"> </a>The Certificate Manager provides a secure server for the storing and parsing of DER-encoded X.509 digital certificates. It exposes functions that allow you to import, export, parse, and verify those certificates.</p>

<p><a name="1000447"> </a>You can use the Certificate Manager in either of two different ways: as a certificate verifier and parser, and as a certificate store. In the verifier/parser mode, the Certificate Manager takes data as input and parses it as a digital certificate. The user can then verify the certificate and access its internal fields. In certificate store mode, the Certificate Manager can securely store a tree of digital certificates (with multiple roots) and make the fields of those certificates available to users.</p>

<p><a name="1000448"> </a>The Certificate Manager is a system server with a client-side library. To securely store certificates, the Certificate Manager makes use of the Data Manager's vault facilities. This allows the Certificate Manager to guarantee the integrity of any certificate added to its certificate store.</p>

<p><a name="1001624"> </a>Note that very few applications use the Certificate Manager directly. As was shown in <a href="SecurityConcepts.html#995643">Figure 1.1</a>, both SSL and the Signature Verification Library make use of the Certificate Manager on the application's behalf. The Certificate Manager only exposes a fairly low-level set of APIs. </p>
<h3 class="hbH3">
  <a name="1000611"> </a>Certificate Store Operations <a href="#992896"><span class="nav">^TOP^</span></a>
</h3>


<p><a name="1001072"> </a>The Certificate Manager can securely store a tree of digital certificates (with multiple roots). <a href="SecurityConcepts.html#1002410">Figure 1.4</a> shows the basic certificate hierarchy.</p>

<p class="FFigureCaption">
  <a name="1002410"> </a><b>Figure 1.4&nbsp;&nbsp;Certificate Hierarchy</b>
</p>
<div align="left"><img src="images/SecurityConcepts4.jpg" height="292" width="480" border="0" hspace="0" vspace="0">
</div>

<p><a name="1002459"> </a>At boot time the certificate store is seeded with the list of root certificates that were stored in ROM by the device manufacturer. These ROM certificates are used to authenticate RAM certificates. </p>

<p><a name="1002665"> </a>To get a certificate from the store, call <a href="CertificateMgr.html#995620"><code>CertMgrFindCert()</code></a>. This function can be used in one of two modes: to find a particular certificate by ID or by subject RDN, or to iterate through all of the certificates in the certificate store. You control this function's operation through the use of the <code class="par">searchFlag</code> parameter. </p>

<p><a name="1002689"> </a>To add and remove certificates from the store, you use <a href="CertificateMgr.html#995203"><code>CertMgrAddCert()</code></a> and <a href="CertificateMgr.html#996250"><code>CertMgrRemoveCert()</code></a>, respectively. Note that you can only add a certificate if its authentication chain already resides in the certificate store, or if the certificate is self-signed. Also note that removing a certificate that is part of an authentication chain may prevent new certificates from being authenticated.</p>

<p><a name="1002804"> </a>The code excerpt shown in <a href="SecurityConcepts.html#1002793">Listing 1.16</a> shows how you can use <code>CertMgrAddCert()</code> to add a self-signed certificate to the certificate store.</p>
<p class="CCodeCaption">
  <a name="1002793"> </a><b>Listing 1.16&nbsp;&nbsp;Adding a self-signed certificate</b>
</p>

<div class="CodeRule"><hr></div><pre class="CodeBlock">
while (true) {<a name="1002734"> </a>
   err = CertMgrAddCert(&amp;certInfo, false, &amp;verifyResult);<a name="1002735"> </a>
   if (err) {<a name="1002736"> </a>
      CertMgrReleaseCertInfo(&amp;certInfo);<a name="1002737"> </a>
      goto exit;<a name="1002738"> </a>
   }<a name="1002739"> </a>
<a name="1002740"> </a>
   if (verifyResult.failureCode == 0) {<a name="1002741"> </a>
      break;<a name="1002742"> </a>
   } else {<a name="1002743"> </a>
      if (verifyResult.failureCode ==
         CertMgrVerifyFailSelfSigned) {<a name="1002744"> </a>
         verifyResult.failureCode = 0;<a name="1002745"> </a>
         continue;<a name="1002746"> </a>
      }<a name="1002747"> </a>
<a name="1002748"> </a>
      /* Another type of failure */<a name="1002749"> </a>
      break;<a name="1002750"> </a>
   }<a name="1002751"> </a>
}<a name="1002752"> </a>
</pre><div class="CodeRule"><hr></div>

<h3 class="hbH3">
  <a name="1000697"> </a>Certificate Verification and Parsing <a href="#992896"><span class="nav">^TOP^</span></a>
</h3>


<p><a name="1002877"> </a>Use <a href="CertificateMgr.html#996030"><code>CertMgrImportCert()</code></a> to import a DER-encoded x509 certificate and get back a <a href="CertificateMgr.html#993226"><code>CertMgrCertInfoType</code></a> structure. This structure represents a certificate object. You then verify this certificate's contents by calling <a href="CertificateMgr.html#996376"><code>CertMgrVerifyCert()</code></a>. Once you have a verified certificate, use <a href="CertificateMgr.html#995678"><code>CertMgrGetField()</code></a> to get fields out of the certificate. Most commonly, applications will want to get the key from the certificate. </p>

<p><a name="1002927"> </a>Once you are done with a certificate, be sure to call <a href="CertificateMgr.html#996208"><code>CertMgrReleaseCertInfo()</code></a> to release these resources that were allocated by the Certificate Manager during the call to <a href="CertificateMgr.html#995620"><code>CertMgrFindCert()</code></a> or <a href="CertificateMgr.html#996030"><code>CertMgrImportCert()</code></a>.</p>
<h3 class="hbH3">
  <a name="1002472"> </a>Certificate Backup and Restore <a href="#992896"><span class="nav">^TOP^</span></a>
</h3>


<p><a name="1007846"> </a>All certificates in the certificate store are backed up and restored.</p>

<h2 class="haH2">
  <a name="994858"> </a>Security Services <a href="#992896"><span class="nav">^TOP^</span></a>
</h2>


<p><a name="994859"> </a>In Palm OS Cobalt the security services allow the user of the Palm Powered device to specify a level of "paranoia." This maps directly to the paradigm of private records being visible, masked, or hidden but in Palm OS Cobalt this security setting extends to more than just private records. The security services also control the automatic locking and unlocking of the device. Finally, they also allow licensees to specify basic restrictive policies for various managers and services on the device, and provide APIs that let third-party developers examine those policies.</p>
<h3 class="hbH3">
  <a name="1003262"> </a>Current Security Setting <a href="#992896"><span class="nav">^TOP^</span></a>
</h3>


<p><a name="994863"> </a><a href="SecurityServices.html#993616"><code>SecSvcsGetDeviceSetting()</code></a> and <a href="SecurityServices.html#993933"><code>SecSvcsSetDeviceSetting()</code></a> allow you to get and set the device's current security setting. The security setting is an indication of how much the user wants to be bothered with security and how "paranoid" the user is. The manager or service reading this setting should follow these guidelines with regard to the security setting:</p>

<dl>
<dt><a name="994864"> </a>SecSvcsDeviceSecurityNone</dt>
<dd><a name="994865"> </a>The user does not want to be bothered at all and the device is totally open. Everything is "ok" by the user.</dd>

<dt><a name="994866"> </a>SecSvcsDeviceSecurityMedium</dt>
<dd><a name="994867"> </a>The user should be bothered with a Yes/No question about the pending operation with as much information about the operation as is reasonably possible (whether the code is signed or unsigned, which manager is performing the operation, details about the operation being performed, and so on). A "Yes" from the user indicates that the operation should proceed. "No" means that the operation should not be performed. </dd>

<dt><a name="994868"> </a>SecSvcsDeviceSecurityHigh</dt>
<dd><a name="994869"> </a>The user does not want to be bothered at all and the device is essentially closed. In general, no operations should be performed.</dd>

</dl>

<p><a name="1012441"> </a>The following table shows how certain aspects of Palm OS Cobalt react, by default, to the various security settings:</p>


<div class="tablediv"><table cellspacing="0" class="tTable">

  <tr valign="top">
    <th><p class="tt"><a name="1009660"> </a><b></b></p>
    </th>
    <th><p class="tt"><a name="1009662"> </a><b>None</b></p>
    </th>
    <th><p class="tt"><a name="1009664"> </a><b>Medium</b></p>
    </th>
    <th><p class="tt"><a name="1009666"> </a><b>High</b></p>
    </th>
  </tr>
  <tr valign="top">
    <td><p class="tt"><a name="1009668"> </a><b>Trusted Desktop</b></p>
    </td>
    <td><p class="tt"><a name="1009670"> </a>No UI</p>
    </td>
    <td><p class="tt"><a name="1009672"> </a>Ask user</p>
    </td>
    <td><p class="tt"><a name="1009674"> </a>Ask user</p>
    </td>
  </tr>
  <tr valign="top">
    <td><p class="tt"><a name="1009676"> </a><b>Sync Clients</b></p>
    </td>
    <td><p class="tt"><a name="1009678"> </a>No UI</p>
    </td>
    <td><p class="tt"><a name="1009680"> </a>Ask user</p>
    </td>
    <td><p class="tt"><a name="1009682"> </a>Ask user</p>
    </td>
  </tr>
  <tr valign="top">
    <td><p class="tt"><a name="1009684"> </a><b>Token Caching</b></p>
    </td>
    <td><p class="tt"><a name="1009686"> </a>Global</p>
    </td>
    <td><p class="tt"><a name="1009688"> </a>Application</p>
    </td>
    <td><p class="tt"><a name="1009690"> </a>Application</p>
    </td>
  </tr>
  <tr valign="top">
    <td><p class="tt"><a name="1009692"> </a><b>AM Plug-in</b></p>
    </td>
    <td><p class="tt"><a name="1009694"> </a>No UI; always allowed</p>
    </td>
    <td><p class="tt"><a name="1009696"> </a>Ask user</p>
    </td>
    <td><p class="tt"><a name="1009698"> </a>No UI; always denied</p>
    </td>
  </tr>
</table>

</div>

<h3 class="hbH3">
  <a name="994870"> </a>Lockout Settings <a href="#992896"><span class="nav">^TOP^</span></a>
</h3>


<p><a name="994871"> </a><a href="SecurityServices.html#993228"><code>SecSvcsGetDeviceLockout()</code></a> and <a href="SecurityServices.html#993867"><code>SecSvcsSetDeviceLockout()</code></a> get and set the device's current lockout scheme. These functions are intended to be used by security applications that control the locking and unlocking of the device. </p>

<p><a name="994872"> </a>Use <a href="SecurityServices.html#993174"><code>SecSvcsEncodeLockoutTime()</code></a> to encode the lockout parameters into a 32-bit value for use by <code>SecSvcsSetDeviceLockout()</code>. As you might expect, you use <a href="SecurityServices.html#993116"><code>SecSvcsDecodeLockoutTime()</code></a> to decode the lockout parameters from the 32-bit value returned from <code>SecSvcsGetDeviceLockout()</code>.</p>

<p><a name="994873"> </a>Low-level modules that control whether or not the device is locked can use <a href="SecurityServices.html#993742"><code>SecSvcsIsDeviceLocked()</code></a>. This function returns a boolean value: <code>true</code> if the device is locked, <code>false</code> if it is not.</p>
<h3 class="hbH3">
  <a name="1003510"> </a>Security Policies <a href="#992896"><span class="nav">^TOP^</span></a>
</h3>


<p><a name="1013140"> </a>Palm OS Cobalt licensees can set security policies for the various managers in their Palm OS system. Specifically, the following can be gated by separate security policies:</p>
<ul type="disc">
  <li><a name="1013141"> </a>Processes
  <li><a name="1013142"> </a>FEPs and locale modules
  <li><a name="1013143"> </a>The BSP key
  <li><a name="1013144"> </a>IOS drivers
  <li><a name="1013145"> </a>Sync clients
  <li><a name="1013146"> </a>Authentication Manager plug-ins
  <li><a name="1013147"> </a>CPM providers
</ul>

<p><a name="1003515"> </a><a href="SecurityServices.html#993566"><code>SecSvcsGetDevicePolicies()</code></a> obtains the security policies defined for the device. It checks, in order, the ROM token area of the device, any ROM-based PDB files, and then any RAM-based PDB files. The PDB files and ROM tokens that this function checks are of a specific format. The format used by the policies is a non-terminated list of 20 byte IDs of certificates against which code must be checked for signed status. These IDs can be directly used with the Signature Verification Library using the <a href="SignVfy.html#993960"><code>SignVerifySignatureByID()</code></a> function. The Signature Verification Library is responsible for checking that code is signed appropriately before it is used. </p>

<p><a name="1013039"> </a>Application developers can build a secure application by including a set of security policies in the PRC of the application (using PRCCert and PRCSign; see the book <i>Working with Resource Tools</i>) and then signing the PRC digitally. Before the Program Loader launches the application, it will make sure the application's integrity has not been compromised. When such an application is running, the Program Loader also makes sure that any shared library loaded into that application's process meets the requirement of the security policies carried by the application's PRC.</p>

<h2 class="haH2">
  <a name="993477"> </a>Signature Verification Library <a href="#992896"><span class="nav">^TOP^</span></a>
</h2>


<p><a name="993509"> </a>The Signature Verification Library provides an interface through which applications can access signature and certificate resources (<code>'sign'</code> and <code>'cert'</code>, respectively) in a PRC. With the exposed APIs you can:</p>
<ul type="disc">
  <li><a name="993510"> </a>Get the number of signatures or certificates
  <li><a name="993511"> </a>Get a certificate or signature by index or certificate ID
  <li><a name="993512"> </a>Get an overlay validation certificate list
  <li><a name="993513"> </a>Get a shared library validation certificate list
  <li><a name="993514"> </a>Validate a signature
</ul>

<p><a name="993515"> </a>Reference documentation for the APIs exposed by this library can be found in <a href="SignVfy.html#992934">Chapter 15, "Signature Verification Library."</a></p>
<h3 class="hbH3">
  <a name="1004001"> </a>Signature Verification <a href="#992896"><span class="nav">^TOP^</span></a>
</h3>


<p><a name="993506"> </a>Signature verification is perhaps the most common Signature Verification Library operation. <a href="SecurityConcepts.html#1003909">Listing 1.17</a> contains a code excerpt that shows how you can verify a signature.</p>
<p class="CCodeCaption">
  <a name="1003909"> </a><b>Listing 1.17&nbsp;&nbsp;Validating a signature</b>
</p>

<div class="CodeRule"><hr></div><pre class="CodeBlock">
DatabaseID dbID;<a name="993521"> </a>
DmOpenRef dbP;<a name="993522"> </a>
status_t err;<a name="993523"> </a>
<a name="993524"> </a>
dbID = DmFindDatabase("Test_SignedCode", 'scta');<a name="993525"> </a>
dbP = DmOpenDBNoOverlay(dbID, dmModeReadOnly);<a name="993526"> </a>
err = SignVerifySignatureByIndex(dbP, 0);<a name="993527"> </a>
if (err)<a name="993528"> </a>
   DbgPrintf("Error in Signature\n");<a name="993529"> </a>
else<a name="993530"> </a>
   DbgPrintf("Signature validation succeeded");<a name="993531"> </a>
DmCloseDatabase(dbP);<a name="993532"> </a>
</pre><div class="CodeRule"><hr></div>


<p><a name="994704"> </a>To verify a PRC's digital signature, its sign resource block must be interpreted. Each signature block in a sign resource contains a reference to its verifying certificate. This reference is the certificate's ID (the SHA1 digest of the public key).</p>

<p><a name="994705"> </a>The code verifying the signature can get the RSA verify key (the public key) from the Certificate Manager by referencing the certificate ID. If the certificate is not found in the certificate store, search for a matching certificate in the PRC file. If a certificate in the PRC file matches the ID, import it into the certificate store prior to using it for verification. The Certificate Manager verifies the integrity, validity, and suitability of the certificate during the process of importing it into the certificate store. </p>

<div><hr>
  <a name="994706"> </a> <b>NOTE: </b> It is possible to import expired certificates into the certificate store for purposes of verifying digital signatures. If a certificate has expired, the signature verification code is responsible for verifying that the PRC file was signed prior to the expiration date of the certificate.
<hr>
</div>

<p><a name="994712"> </a>The Authentication Manager, running in the System process, makes use of the signature verification shared library to provide signed code authentication.</p>

<h2 class="haH2">
  <a name="1004872"> </a>Signing Code <a href="#992896"><span class="nav">^TOP^</span></a>
</h2>


<p><a name="1004943"> </a>Applications are signed when code integrity is a concern. Depending on the device, some code&#8212;such as a patch&#8212;may need to be signed. Or, a secure database may be configured in such a way as to only allow access by a particular group of signed applications.</p>
<h3 class="hbH3">
  <a name="1004952"> </a>What can be Signed <a href="#992896"><span class="nav">^TOP^</span></a>
</h3>


<p><a name="1004956"> </a>Signed code in Palm OS Cobalt is used to validate the authenticity of a program resource. There are several types of resources that could be signed in Palm OS Cobalt. Applications, system patches, shared libraries, system components, system drivers, and the like. All of these resources are packaged as PRC files and then loaded onto the device. </p>

<p><a name="1004960"> </a>Unlike the desktop world where digital signatures are used to indicate the author of a piece of software, Palm OS uses digital signatures to represent endorsements. For example, an enterprise can use its own certificate to sign Palm OS applications that it has tested for usefulness and interoperability with other core enterprise applications. This makes it easy for employees to know they are getting good applications. </p>

<p><a name="1004961"> </a>An application can have multiple endorsements. For example, an application created by a major software vendor could be signed by the vendor as well as by the enterprise. It is also possible for user groups to endorse software that they have reviewed favorably. These endorsements help the user decided whether to install a piece of downloaded software.</p>

<h4 class="hcH4">
  <a name="1005353"> </a>Overlay and Shared Library Validation Certificate List
</h4>

<p><a name="1005354"> </a>A signed application can define two lists of certificate IDs: an overlay list, and a shared library list. These lists authenticate the integrity of overlays and shared libraries. They are defined at the time that the first signature is applied to the application, and cannot be changed without invalidating that signature.</p>
<h3 class="hbH3">
  <a name="994593"> </a>Signing Algorithm <a href="#992896"><span class="nav">^TOP^</span></a>
</h3>


<p><a name="994559"> </a>The algorithm for digital signatures in Palm OS Cobalt is the RSA/SHA1 signing algorithm. This means that Palm OS Cobalt uses RSA private keys to sign a SHA1 digest, and RSA public keys to verify the signature. To be compatible with the widest range of cryptographic hardware vendors, the padding format is PKCS #1 Block Type 1 from version 1.5 of the PKCS #1 specification.</p>

<p><a name="994580"> </a>The signing keys can be either self-issued or assigned by a Certificate Authority (CA). These are RSA keys with 1024 bits and can have either double-prime or triple-prime modulus. The exponent can be 3 or 216+1. Verifying a signature produced with exponent 3 is about three times faster than with the larger exponent.</p>
<h3 class="hbH3">
  <a name="1004819"> </a>Signing Tools <a href="#992896"><span class="nav">^TOP^</span></a>
</h3>


<p><a name="1004645"> </a>There are two tools that are required to do code-signing of PRC's: PRCCert and PRCSign. You use <b>PRCCert</b> to create your own RSA key pairs and digital certificates. You may create self-signed certificates for testing, or certificates that are signed by other private keys. PRCCert creates RSA public/private key pairs at 1024-bit length in PEM format. PRCCert also generates a public certificate file in DER format.</p>

<p><a name="1004270"> </a>The output files from PRCCert are used as input files to PRCSign.</p>

<p><a name="1004461"> </a><b>PRCSign</b> is a tool that you use to digitally sign your applications or to embed digital signature certificates in your applications. PRCSign creates a digital signature for a particular PRC using an asymmetric key cipher, storing the signature into the PRC as a resource of type <code>'sign'</code>. The signature can be verified as authentic by using your public key to decipher the signature resource. Each application has at most one <code>'sign'</code> resource with a resource ID of 1000.</p>

<p><a name="1004412"> </a>PRCSign takes your private key and signs a SHA1 hash of all of the static (unchanging) resources in the PRC along the signature attributes. PRCSign then adds the resulting output as the <code>'sign'</code> resource to your application PRC file. PRCSign also takes a digital signature and adds it to the PRC as a <code>'cert'</code> resource in such a way that the Security Manager can retrieve it for application certification.</p>

<p><a name="994756"> </a>PRCSign supports keys in regular files, and smart cards.</p>

<p><a name="994758"> </a>The tools can handle any kind of X.509 certificate as long as the certificate's key usage constraints include the ability to sign data. Certificates that can only sign certificates, and certificates that can only be used for encryption, are not acceptable. A certificate issued for signing e-mail, however, is acceptable even though it is not marked as being able to sign code. This allows for the widest possible range of certificate-issuing systems or infrastructures to be used to sign Palm OS software. It is up to the Certificate Manager acting on behalf of the user or the administrator to further restrict the suitability of certificates. The tools do not enforce this.</p>

<p><a name="1013455"> </a>For detailed instructions on using PRCCert and PRCSign, see <i>Palm OS Resource Tools Guide</i>. </p>
<h3 class="hbH3">
  <a name="1012966"> </a>Signed Code and Shared Libraries <a href="#992896"><span class="nav">^TOP^</span></a>
</h3>


<p><a name="1012970"> </a>Palm OS Cobalt can guarantee the integrity of the shared libraries that are loaded by an application while it runs. In order to do this the application has associated with it a list of certificates (the "shared library certificate ID list") that authenticate the shared libraries that are loaded at runtime. The operating system then uses this list of certificates to authenticate any shared library that is loaded by the system for the application. If a shared library has a valid signature (one that can be verified by one of the certificates in the list), then it is loaded. Otherwise the load is cancelled, and the application stops running.</p>

<p><a name="1012971"> </a>The feature in PRCSign that allows the setting of this list is the <code>&#8211;scert</code> parameter. Multiple <code>&#8211;scert</code> parameters can be supplied. Note that the list of shared library certificates must be set when the PRC is being signed; it cannot be modified after the first signature is applied. Previous signatures will be invalidated if the list is modified; the Application Manager requires that all signatures be valid when it checks the integrity of the certificate list. If any signature is determined to be invalid, the application is stopped.</p>

<h4 class="hcH4">
  <a name="1012975"> </a>Shared Library Scenarios
</h4>

<p><a name="1012976"> </a>Whether or not a given shared library is loaded depends on whether the application is signed, and whether the shared library's signature appears in the application's shared library certificate ID list.</p>

<h5 class="hdH5">
  <a name="1012977"> </a>Unsigned PRC 
</h5>

<p><a name="1012978"> </a>If the application isn't signed, the application is run and any needed shared libraries are loaded without any verification of signatures.</p>

<h5 class="hdH5">
  <a name="1012979"> </a>Signed PRC, Empty Shared Library Certificate ID List 
</h5>

<p><a name="1012980"> </a>If the application is signed but the shared library certificate ID list is empty, all signatures on the PRC must be valid, or the PRC execution is halted. Any needed shared libraries are loaded without signature verification.</p>

<h5 class="hdH5">
  <a name="1012981"> </a>Signed PRC, Shared Library Certificate ID List has Entries
</h5>

<p><a name="1012982"> </a>If the application is signed and there are entries in the shared library certificate ID list, all signatures on the PRC must be valid. Any needed shared libraries must have a signature that can be validated by one of the certificates in the shared library certificate ID list.</p>
<h3 class="hbH3">
  <a name="1012983"> </a>Signed Code and Overlays <a href="#992896"><span class="nav">^TOP^</span></a>
</h3>


<p><a name="1012984"> </a>Overlays for signed PRC's must be authenticated before they are applied. A signed PRC may contain a list of overlay certificate IDs. This list contains the IDs of certificates that may be used to authenticate overlays.</p>

<p><a name="1012985"> </a>The list of overlay certificate IDs is included in the signing hash for each signature, so if a user or application changes this list all previous signatures are invalidated.</p>

<p><a name="1012986"> </a>Prior to applying an overlay to a base PRC, the Locale Manager must verify that the overlay can be authenticated by one of the certificates in the "overlay certificate ID list" (from the <code>'sign'</code> resource).</p>

<h4 class="hcH4">
  <a name="1012987"> </a>Overlay Scenarios
</h4>

<p><a name="1012988"> </a>Whether or not a given overlay is applied depends on whether the application is signed, and whether the overlay's signature appears in the application's overlay certificate ID list.</p>

<h5 class="hdH5">
  <a name="1012989"> </a>Unsigned PRC 
</h5>

<p><a name="1012990"> </a>If the application isn't signed, the application is run and any overlays are applied without any verification of signatures.</p>

<p><a name="1012991"> </a>Note that signed overlays may be applied to unsigned PRC files because the operating system doesn't check the signature of the overlay.</p>

<h5 class="hdH5">
  <a name="1012992"> </a>Signed PRC, Empty Overlay Certificate ID List 
</h5>

<p><a name="1012993"> </a>If the application is signed, but its <code>'sign'</code> resource doesn't contain any overlay certificate IDs, any overlay is allowed.</p>

<h5 class="hdH5">
  <a name="1012994"> </a>Signed PRC, Overlay Certificate ID List has Entries
</h5>

<p><a name="1012995"> </a>If the application is signed and its 'sign' resource contains an overlay certificate ID list, an overlay must be verified with the certificate(s) in the list before it will be applied. </p>

<h2 class="haH2">
  <a name="993550"> </a>Securing Databases <a href="#992896"><span class="nav">^TOP^</span></a>
</h2>


<p><a name="993569"> </a>The Data Manager in Palm OS Cobalt supports secure schema databases. These databases have an Authorization Manager rule set associated with them that is evaluated when the database is opened or removed.</p>

<p><a name="993570"> </a>The Data Manager defines several different actions that the application can define access rules for:</p>
<ul type="disc">
  <li><a name="993571"> </a><code>dbActionRead</code> 
  <li><a name="993572"> </a><code>dbActionWrite</code> 
  <li><a name="993573"> </a><code>dbActionDelete</code> 
  <li><a name="993574"> </a><code>dbActionBackup</code> 
  <li><a name="993575"> </a><code>dbActionRestore</code> 
  <li><a name="993576"> </a><code>dbActionEditSchema</code> 
</ul>

<p><a name="993577"> </a>There are two functions for creating secure databases: <a href="../Memory_Databases_Files/SchemaDatabases.html#995225"><code>DbCreateSecureDatabase()</code></a>, and <a href="../Memory_Databases_Files/SchemaDatabases.html#995299"><code>DbCreateSecureDatabaseFromImage()</code></a>. </p>

<p><a name="993587"> </a>When you first create a secure database, access is only granted to the creator of that database, and the creator is only allowed to modify the database's access-control rule set. Accordingly, an application that creates a secure database must then set rules for those actions for which it wants to grant access.</p>

<p><a name="993589"> </a>A rule specifies a series of tokens that must be satisfied prior to access being granted. </p>

<p><a name="1006048"> </a>The following code shows how to create a secure database that requires a user password for any action performed on that database.</p>
<p class="CCodeCaption">
  <a name="1006145"> </a><b>Listing 1.18&nbsp;&nbsp;Creating a secure database</b>
</p>

<div class="CodeRule"><hr></div><pre class="CodeBlock">
AzmRuleSetType dbRuleSet;<a name="1006049"> </a>
AmTokenType usertoken;<a name="1006050"> </a>
UInt32 action = dbActionRead | dbActionWrite | dbActionDelete
   | dbActionBackup | dbActionRestore | dbActionEditSchema;<a name="1006051"> </a>
status_t err;<a name="1006153"> </a>
<a name="1006052"> </a>
// Create DB &#8211; get AZM ruleset reference<a name="1006053"> </a>
err = DbCreateSecureDatabase("My DB", 'crea', 'type',
   numSchemas, schemaList, &amp;dbRuleSet, &amp;dbID);<a name="1006054"> </a>
<a name="1006055"> </a>
// Set user password required for ALL actions<a name="1006056"> </a>
err = AmGetTokenBySystemId(&amp;usertoken, SysUserToken);<a name="1006057"> </a>
err = AzmAddRule(dbRuleSet, action , "%t", usertoken);<a name="1006058"> </a>
</pre><div class="CodeRule"><hr></div>

<h3 class="hbH3">
  <a name="993564"> </a>Synchronization and Backup of Secure Databases <a href="#992896"><span class="nav">^TOP^</span></a>
</h3>


<p><a name="1006169"> </a>"Sync bypass" must enabled for a specific action in order for an authenticated HotSync agent to be able to complete that action successfully. You use <a href="azm.html#993631"><code>AzmGetSyncBypass()</code></a> and <a href="azm.html#997438"><code>AzmSetSyncBypass()</code></a> to get and set the sync bypass flag in an existing rule-set container for a specific action. Sync bypass may be flagged for any action; it tells the sync server to grant access to registered sync clients. Sync bypass is used in both synchronization and backup operations.</p>

<h4 class="hcH4">
  <a name="993596"> </a>HotSync and Secure Databases
</h4>

<p><a name="1006249"> </a>If sync bypass has been granted for the appropriate actions, any HotSync client that has registered with the HotSync server may access a secure database on the device, and any HotSync conduit may access a secure database from the desktop. Any application can register with the HotSync Manager (although user confirmation may be required). </p>

<p><a name="1006291"> </a>Be aware that synchronizing a secure database exposes it on the desktop and on the device. The secure database is synchronized "in the clear," meaning that the security of the link between the desktop and the device is up to the HotSync client/server setup. For truly secure data synchronization is not recommended.</p>

<h4 class="hcH4">
  <a name="993600"> </a>Backing up Secure Databases
</h4>

<p><a name="993602"> </a>The database itself is always backed up encrypted, and the encryption key is backed up as well. In order to allow the database to be backed up, the backup action must be set in the bypass vector of the rule set. As well, all actions must be protected by the user token: only data that is protected solely by the user password can be backed up. This is enforced by the Data Manager.</p>

<p><a name="993660"> </a>On the desktop the backup image is protected by the user password. That means that the security of the backup depends on strength of the password. However, because it is protected by a user password on both the device and the desktop, the data is no more at risk on the desktop than it is on the device.</p>

<p><a name="993626"> </a></p>
 

<hr> 
<p class="FNFootnote">
<a name="1012955"> </a><a href="#997167">1</a>. A given CPM import/export format, such as XML, is only supported if the provider supports it. IMPORT_EXPORT_TYPE_RAW is always supported.</p>
&nbsp;<br>
</div>
<!--END CONTENT-->

</td>
<td width="5">&nbsp;&nbsp;</td>
</tr>

</table>

<!-- BEGIN FOOTER -->
<table width="100%" border="0" cellspacing="0" cellpadding="0">
<tr>
<td width="7" rowspan="2"><img name="index_x" src="images/shim.gif" width="7" height="33" border="0" alt=""></td>
<td align="left"><img name="dashes" src="images/dashes.gif" width="744" height="3" border="0" alt=""></td>
<td width="10" rowspan="2"><img name="index_x" src="images/shim.gif" width="10" height="33" border="0" alt=""></td>
</tr>
<tr>
<td align="center">
<p class="footer">
Copyright © 1996&#8211;2004, PalmSource, Inc. and its affiliates. All rights reserved.<br>
<a href="http://www.palmsource.com/contact/">Write Us</a> | <a href="http://www.palmos.com/dev/training/">Training</a> | <a href="http://www.palmos.com/dev/support/kb/">Knowledge Base</a> | <a href="SecurityAndCrypto_Front.html" target="_blank">Legal</a></p>
<br>
<!--BEGIN BOOK NAVIGATION-->
<p class="nav">
<A href="http://www.palmos.com/dev/support/docs/">Documentation</a>&nbsp;&nbsp;|&nbsp;&nbsp;
<a href="SecurityAndCryptographyTOC.html">Table of Contents</a>&nbsp;&nbsp;
             |&nbsp;&nbsp;<a href="SecurityAndCrypto_Part1.html">&lt;&nbsp;Previous</a>&nbsp;&nbsp;
             |&nbsp;&nbsp;<a href="SslConcepts.html">Next&nbsp;&gt;</a>&nbsp;&nbsp;
             |&nbsp;&nbsp;<a href="SecurityAndCryptographyIX.html">Index</a>
</p>
</td>
</tr>
</table>
<!-- END FOOTER -->

</body>
</html>