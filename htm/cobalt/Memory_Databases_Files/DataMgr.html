<html>
<head>
<title>(Protein) Data Manager | Memory, Databases, and Files</title> 
<link href="psi_devpubs.css" rel="stylesheet" type="text/css">

<!-- BEGIN META DATA -->
<meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
<META NAME="PSITEMPLATE" CONTENT="1006-007 PalmSource_HTML_2003 20041101">
<META NAME="GENERATOR" CONTENT="Quadralay WebWorks AutoMap 2003 for FrameMaker 8.0.6.2138">
<META NAME="LASTUPDATED" CONTENT="11/22/04 11:15:47">
<!-- END META DATA -->
</head>

<body bgcolor="#ffffff" text="#000000" leftmargin="0" topmargin="0" marginwidth="0" marginheight="0">
<a name="992934"></a>

<!-- BEGIN TOPNAV -->
<table width="100%" border="0" cellspacing="0" cellpadding="0">
<tr>
<td><img src="images/shim.gif" width="7" height="75" border="0" alt=""></td>
<td align="left"><table border="0" cellpadding="0" cellspacing="0" width="744">
<tr>
<td><img name="index_r2_c1" src="images/shim.gif" width="25" height="75" border="0" alt=""></td>
<td valign="top"><table border="0" cellpadding="0" cellspacing="0" width="96">
<tr>
<td><img name="index_r2_c4" src="images/shim.gif" width="96" height="15" border="0" alt=""></td>
</tr>
<tr>
<td><a href="http://www.palmsource.com/"><img name="ps_logo" src="images/ps_logo.gif" width="96" height="54" border="0" alt=""></a></td>
</tr>

</table>
</td>

<td><table border="0" cellpadding="0" cellspacing="0" width="30">
<td><img name="index_x" src="images/shim.gif" width="30" height="75" border="0" alt=""></td>
</table></td>

<!--BEGIN MASTHEAD-->
<td><table border="0" cellpadding="0" cellspacing="0" width="96">
<tr>
<td><img name="index_x" src="images/shim.gif" width="615" height="5" border="0" alt=""></td>
</tr>
<tr>
<td>
<!--BEGIN BOOK NAVIGATION-->
<span class="nav">
<A href="http://www.palmos.com/dev/support/docs/">Documentation</a>&nbsp;&nbsp;|&nbsp;&nbsp;
<a href="MDF_TOC.html">Table of Contents</a>&nbsp;&nbsp;
             |&nbsp;&nbsp;<a href="MDF_Part2.html">&lt;&nbsp;Previous</a>&nbsp;&nbsp;
             |&nbsp;&nbsp;<a href="FileStream.html">Next&nbsp;&gt;</a>&nbsp;&nbsp;
             |&nbsp;&nbsp;<a href="MDF_IX.html">Index</a>
</span>
<!--END BOOK NAVIGATION-->
</tr>
<tr>
<td>
<!--BEGIN PAGE TITLE-->
<h2 class="PageTitle">4 &nbsp;&nbsp;
Data Manager</h2></td>
<!--END PAGE TITLE-->
</tr>
<tr>
<td>
<!--BEGIN BOOK TITLE-->
<p class="BookTitle">Memory, Databases, and Files</p>
<p class="SubTitle">Exploring Palm OS&#174; </p>
<!--END BOOK TITLE-->
</td>
</tr>
<tr>
<td><img name="index_x" src="images/shim.gif" width="615" height="5" border="0" alt=""></td>
</tr>
</table>
</td>
<!--END MASTHEAD-->
</tr>
</table>
<img name="dashes" src="images/dashes.gif" width="744" height="3" border="0" alt=""></td>
</tr>
</table>
<!-- END TOPNAV -->

<table width="100%" border="0" cellspacing="0" cellpadding="0">
<tr>
<td valign="top" width="5"><img name="index_x" src="images/shim.gif" width="5" height="33" border="0" alt=""></td>

<!--BEGIN SIDETOC-->
<td valign="top" width="175">
<div id="sidetoc" valign="bottom">
<h1 class="SideTOC1-PartTab"><a href="MDF_Part2.html">Part II: Reference</a> </h1>
<h1 class="SideTOC1"><a href="DataMgr.html">4  Data Manager</a></h1>

   <h2 class="SideTOC2"><a href="#992942">
   Data Manager Structures and Types</a></h2>

      <h3 class="SideTOC3"><a href="#992950">
      CategoryID</a></h3>

      <h3 class="SideTOC3"><a href="#992975">
      DatabaseID</a></h3>

      <h3 class="SideTOC3"><a href="#993225">
      DmBackupRestoreStateType</a></h3>

      <h3 class="SideTOC3"><a href="#993322">
      DmDatabaseInfoType</a></h3>

      <h3 class="SideTOC3"><a href="#993618">
      DmFindType</a></h3>

      <h3 class="SideTOC3"><a href="#1146522">
      DmOpenModeType</a></h3>

      <h3 class="SideTOC3"><a href="#993643">
      DmOpenRef</a></h3>

      <h3 class="SideTOC3"><a href="#993673">
      DmResourceID</a></h3>

      <h3 class="SideTOC3"><a href="#993858">
      DmResourceType</a></h3>

      <h3 class="SideTOC3"><a href="#993964">
      DmSearchStateType</a></h3>

      <h3 class="SideTOC3"><a href="#994025">
      DmSortRecordInfoType</a></h3>

      <h3 class="SideTOC3"><a href="#994086">
      DmStorageInfoType</a></h3>

   <h2 class="SideTOC2"><a href="#994414">
   Data Manager Constants</a></h2>

      <h3 class="SideTOC3"><a href="#1041655">
      Non-Schema Database Record Attributes</a></h3>

      <h3 class="SideTOC3"><a href="#1049292">
      Database Attributes</a></h3>

      <h3 class="SideTOC3"><a href="#1050193">
      Miscellaneous Data Manager Constants</a></h3>

      <h3 class="SideTOC3"><a href="#1064838">
      Data Manager Error Codes</a></h3>

   <h2 class="SideTOC2"><a href="#995305">
   Data Manager Functions and Macros</a></h2>

      <h3 class="SideTOC3"><a href="#995341">
      DmArchiveRecord</a></h3>

      <h3 class="SideTOC3"><a href="#1208108">
      DmAttachRecord</a></h3>

      <h3 class="SideTOC3"><a href="#995445">
      DmAttachResource</a></h3>

      <h3 class="SideTOC3"><a href="#995503">
      DmBackupFinalize</a></h3>

      <h3 class="SideTOC3"><a href="#995549">
      DmBackupInitialize</a></h3>

      <h3 class="SideTOC3"><a href="#995634">
      DmBackupUpdate</a></h3>

      <h3 class="SideTOC3"><a href="#995692">
      DmCloseDatabase</a></h3>

      <h3 class="SideTOC3"><a href="#995734">
      DmCloseIteratorByTypeCreator</a></h3>

      <h3 class="SideTOC3"><a href="#995780">
      DmCreateDatabase</a></h3>

      <h3 class="SideTOC3"><a href="#995834">
      DmCreateDatabaseFromImage</a></h3>

      <h3 class="SideTOC3"><a href="#995884">
      DmCreateDatabaseFromImageV50</a></h3>

      <h3 class="SideTOC3"><a href="#995926">
      DmCreateDatabaseV50</a></h3>

      <h3 class="SideTOC3"><a href="#996192">
      DmDatabaseInfo</a></h3>

      <h3 class="SideTOC3"><a href="#996281">
      DmDatabaseInfoV50</a></h3>

      <h3 class="SideTOC3"><a href="#996399">
      DmDatabaseProtectV50</a></h3>

      <h3 class="SideTOC3"><a href="#996477">
      DmDatabaseSize</a></h3>

      <h3 class="SideTOC3"><a href="#996555">
      DmDatabaseSizeV50</a></h3>

      <h3 class="SideTOC3"><a href="#996617">
      DmDeleteCategory</a></h3>

      <h3 class="SideTOC3"><a href="#996663">
      DmDeleteDatabase</a></h3>

      <h3 class="SideTOC3"><a href="#996867">
      DmDeleteDatabaseV50</a></h3>

      <h3 class="SideTOC3"><a href="#996913">
      DmDeleteRecord</a></h3>

      <h3 class="SideTOC3"><a href="#997011">
      DmDetachRecord</a></h3>

      <h3 class="SideTOC3"><a href="#997061">
      DmDetachResource</a></h3>

      <h3 class="SideTOC3"><a href="#1077521">
      DmFindDatabase</a></h3>

      <h3 class="SideTOC3"><a href="#997169">
      DmFindDatabaseByTypeCreator</a></h3>

      <h3 class="SideTOC3"><a href="#997495">
      DmFindDatabaseV50</a></h3>

      <h3 class="SideTOC3"><a href="#997584">
      DmFindRecordByID</a></h3>

      <h3 class="SideTOC3"><a href="#997658">
      DmFindRecordByOffsetInCategory</a></h3>

      <h3 class="SideTOC3"><a href="#997720">
      DmFindResource</a></h3>

      <h3 class="SideTOC3"><a href="#997774">
      DmFindResourceType</a></h3>

      <h3 class="SideTOC3"><a href="#998108">
      DmGet1ResourceV50</a></h3>

      <h3 class="SideTOC3"><a href="#998154">
      DmGetAppInfo</a></h3>

      <h3 class="SideTOC3"><a href="#998408">
      DmGetAppInfoIDV50</a></h3>

      <h3 class="SideTOC3"><a href="#998557">
      DmGetDatabaseLockState</a></h3>

      <h3 class="SideTOC3"><a href="#1157229">
      DmGetDatabaseV50</a></h3>

      <h3 class="SideTOC3"><a href="#998819">
      DmGetFallbackOverlayLocale</a></h3>

      <h3 class="SideTOC3"><a href="#998861">
      DmGetLastErr</a></h3>

      <h3 class="SideTOC3"><a href="#999000">
      DmGetNextDatabaseByTypeCreator</a></h3>

      <h3 class="SideTOC3"><a href="#999050">
      DmGetNextDatabaseByTypeCreatorV50</a></h3>

      <h3 class="SideTOC3"><a href="#999324">
      DmGetOpenInfo</a></h3>

      <h3 class="SideTOC3"><a href="#999666">
      DmGetOverlayDatabaseLocale</a></h3>

      <h3 class="SideTOC3"><a href="#999764">
      DmGetOverlayDatabaseName</a></h3>

      <h3 class="SideTOC3"><a href="#999814">
      DmGetOverlayLocale</a></h3>

      <h3 class="SideTOC3"><a href="#1000116">
      DmGetPositionInCategory</a></h3>

      <h3 class="SideTOC3"><a href="#1000166">
      DmGetRecord</a></h3>

      <h3 class="SideTOC3"><a href="#1000420">
      DmGetRecordAttr</a></h3>

      <h3 class="SideTOC3"><a href="#1000470">
      DmGetRecordCategory</a></h3>

      <h3 class="SideTOC3"><a href="#1000600">
      DmGetRecordID</a></h3>

      <h3 class="SideTOC3"><a href="#1000656">
      DmGetRecordSortPosition</a></h3>

      <h3 class="SideTOC3"><a href="#1000738">
      DmGetResource</a></h3>

      <h3 class="SideTOC3"><a href="#1000792">
      DmGetResourceByIndex</a></h3>

      <h3 class="SideTOC3"><a href="#1000838">
      DmGetResourceV50</a></h3>

      <h3 class="SideTOC3"><a href="#1000927">
      DmGetStorageInfo</a></h3>

      <h3 class="SideTOC3"><a href="#1000993">
      DmHandleFree</a></h3>

      <h3 class="SideTOC3"><a href="#1001035">
      DmHandleLock</a></h3>

      <h3 class="SideTOC3"><a href="#1001327">
      DmHandleResize</a></h3>

      <h3 class="SideTOC3"><a href="#1001373">
      DmHandleSize</a></h3>

      <h3 class="SideTOC3"><a href="#1001480">
      DmHandleUnlock</a></h3>

      <h3 class="SideTOC3"><a href="#1191454">
      DmInitiateAutoBackupOfOpenDatabase</a></h3>

      <h3 class="SideTOC3"><a href="#1001522">
      DmInsertionSort</a></h3>

      <h3 class="SideTOC3"><a href="#1001572">
      DmMoveCategory</a></h3>

      <h3 class="SideTOC3"><a href="#1133286">
      DmMoveRecord</a></h3>

      <h3 class="SideTOC3"><a href="#1001715">
      DmNewHandle</a></h3>

      <h3 class="SideTOC3"><a href="#1001785">
      DmNewRecord</a></h3>

      <h3 class="SideTOC3"><a href="#1001870">
      DmNewResource</a></h3>

      <h3 class="SideTOC3"><a href="#1001948">
      DmNextOpenDatabase</a></h3>

      <h3 class="SideTOC3"><a href="#1086376">
      DmNextOpenDatabaseV50</a></h3>

      <h3 class="SideTOC3"><a href="#1002084">
      DmNextOpenResDatabase</a></h3>

      <h3 class="SideTOC3"><a href="#1002126">
      DmNextOpenResDatabaseV50</a></h3>

      <h3 class="SideTOC3"><a href="#1002211">
      DmNumDatabases</a></h3>

      <h3 class="SideTOC3"><a href="#1002275">
      DmNumDatabasesV50</a></h3>

      <h3 class="SideTOC3"><a href="#1002317">
      DmNumRecords</a></h3>

      <h3 class="SideTOC3"><a href="#1002424">
      DmNumRecordsInCategory</a></h3>

      <h3 class="SideTOC3"><a href="#1002470">
      DmNumResources</a></h3>

      <h3 class="SideTOC3"><a href="#1002512">
      DmOpenDatabase</a></h3>

      <h3 class="SideTOC3"><a href="#1002766">
      DmOpenDatabaseByTypeCreator</a></h3>

      <h3 class="SideTOC3"><a href="#1002816">
      DmOpenDatabaseByTypeCreatorV50</a></h3>

      <h3 class="SideTOC3"><a href="#1002946">
      DmOpenDatabaseInfoV50</a></h3>

      <h3 class="SideTOC3"><a href="#1003012">
      DmOpenDatabaseV50</a></h3>

      <h3 class="SideTOC3"><a href="#1003062">
      DmOpenDBNoOverlay</a></h3>

      <h3 class="SideTOC3"><a href="#1003392">
      DmOpenDBNoOverlayV50</a></h3>

      <h3 class="SideTOC3"><a href="#1003442">
      DmOpenIteratorByTypeCreator</a></h3>

      <h3 class="SideTOC3"><a href="#1003720">
      DmPtrResize</a></h3>

      <h3 class="SideTOC3"><a href="#1003809">
      DmPtrSize</a></h3>

      <h3 class="SideTOC3"><a href="#1003875">
      DmPtrUnlock</a></h3>

      <h3 class="SideTOC3"><a href="#1003917">
      DmQueryNextInCategory</a></h3>

      <h3 class="SideTOC3"><a href="#1004199">
      DmQueryRecord</a></h3>

      <h3 class="SideTOC3"><a href="#1004245">
      DmQuickSort</a></h3>

      <h3 class="SideTOC3"><a href="#1004375">
      DmRecordInfoV50</a></h3>

      <h3 class="SideTOC3"><a href="#1004437">
      DmRecoverHandle</a></h3>

      <h3 class="SideTOC3"><a href="#1004479">
      DmReleaseRecord</a></h3>

      <h3 class="SideTOC3"><a href="#1004572">
      DmReleaseResource</a></h3>

      <h3 class="SideTOC3"><a href="#1004638">
      DmRemoveRecord</a></h3>

      <h3 class="SideTOC3"><a href="#1004684">
      DmRemoveResource</a></h3>

      <h3 class="SideTOC3"><a href="#1090390">
      DmRemoveSecretRecords</a></h3>

      <h3 class="SideTOC3"><a href="#1005056">
      DmResetRecordStates</a></h3>

      <h3 class="SideTOC3"><a href="#1005163">
      DmResizeRecord</a></h3>

      <h3 class="SideTOC3"><a href="#1005213">
      DmResizeResource</a></h3>

      <h3 class="SideTOC3"><a href="#1005302">
      DmResourceInfo</a></h3>

      <h3 class="SideTOC3"><a href="#1005384">
      DmResourceInfoV50</a></h3>

      <h3 class="SideTOC3"><a href="#1005674">
      DmRestoreFinalize</a></h3>

      <h3 class="SideTOC3"><a href="#1005732">
      DmRestoreInitialize</a></h3>

      <h3 class="SideTOC3"><a href="#1005778">
      DmRestoreUpdate</a></h3>

      <h3 class="SideTOC3"><a href="#1006040">
      DmSearchRecordOpenDatabases</a></h3>

      <h3 class="SideTOC3"><a href="#1006129">
      DmSearchResourceOpenDatabases</a></h3>

      <h3 class="SideTOC3"><a href="#1006207">
      DmSet</a></h3>

      <h3 class="SideTOC3"><a href="#1006265">
      DmSetDatabaseInfo</a></h3>

      <h3 class="SideTOC3"><a href="#1006311">
      DmSetDatabaseInfoV50</a></h3>

      <h3 class="SideTOC3"><a href="#1006613">
      DmSetDatabaseProtection</a></h3>

      <h3 class="SideTOC3"><a href="#1006659">
      DmSetFallbackOverlayLocale</a></h3>

      <h3 class="SideTOC3"><a href="#1006917">
      DmSetOverlayLocale</a></h3>

      <h3 class="SideTOC3"><a href="#1006959">
      DmSetRecordAttr</a></h3>

      <h3 class="SideTOC3"><a href="#1007171">
      DmSetRecordCategory</a></h3>

      <h3 class="SideTOC3"><a href="#1007227">
      DmSetRecordID</a></h3>

      <h3 class="SideTOC3"><a href="#1007301">
      DmSetRecordInfoV50</a></h3>

      <h3 class="SideTOC3"><a href="#1007394">
      DmSetResourceInfo</a></h3>

      <h3 class="SideTOC3"><a href="#1007456">
      DmStrCopy</a></h3>

      <h3 class="SideTOC3"><a href="#1007510">
      DmWrite</a></h3>

      <h3 class="SideTOC3"><a href="#1007564">
      DmWriteCheckV50</a></h3>

   <h2 class="SideTOC2"><a href="#1007918">
   Application-Defined Functions</a></h2>

      <h3 class="SideTOC3"><a href="#1007926">
      DmCompareFunctionType</a></h3>

</div>
</td>

<td width="5">&nbsp;&nbsp;</td>
<td width="2" background="images/index_r8_c10.gif"><img src="images/shim.gif" width="2" height="75" border="0" alt=""></td>
<td width="5">&nbsp;&nbsp;</td>

<!--END SIDETOC-->

<td valign="top">

<!--BEGIN CONTENT-->
<div id="content" valign="bottom">
<p><a name="1008004"> </a>This chapter describes the Data Manager APIs. These APIs are those structures, constants, and functions that operate on extended and classic databases (collectively, the "non-schema" databases). This chapter is organized as follows:</p>
   <blockquote class = "bq"><a name="992948"> </a><a href="DataMgr.html#992942">Data Manager Structures and Types</a></blockquote>
   <blockquote class = "bq"><a name="1095923"> </a><a href="DataMgr.html#994414">Data Manager Constants</a></blockquote>
   <blockquote class = "bq"><a name="1095927"> </a><a href="DataMgr.html#995305">Data Manager Functions and Macros</a></blockquote>
   <blockquote class = "bq"><a name="1095931"> </a><a href="DataMgr.html#1007918">Application-Defined Functions</a></blockquote>

<p><a name="992938"> </a>The header file <code>DataMgr.h</code> declares the API that this chapter describes.</p>

<p><a name="1007999"> </a>For more information on Palm OS<sup>&#174;</sup> databases, see <a href="FilesAndDatabases.html#608590">Chapter 2, "Palm OS Databases."</a></p>

<h2 class="haH2">
  <a name="992942"> </a>Data Manager Structures and Types <a href="#992934"><span class="nav">^TOP^</span></a>
</h2>


<h3 class="hbH3">
  <a name="992950"> </a>CategoryID Typedef <a href="#992934"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="992955"> </a>Purpose 
</h4>

<p><a name="1008140"> </a>Container for a category's unique identifier.</p>
<h4>
  <a name="992960"> </a>Declared In 
</h4>
<code>DataMgr.h<a name="992963"> </a></code><h4>
  <a name="992965"> </a>Prototype 
</h4>
<pre class="proto"><a name="992968"></a>typedef int32_t CategoryID
</pre>

<h3 class="hbH3">
  <a name="992975"> </a>DatabaseID Typedef <a href="#992934"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="992980"> </a>Purpose 
</h4>

<p><a name="1008252"> </a>Container for a database's unique identifier.</p>
<h4>
  <a name="992985"> </a>Declared In 
</h4>
<code>DataMgr.h<a name="992988"> </a></code><h4>
  <a name="992990"> </a>Prototype 
</h4>
<pre class="proto"><a name="992993"></a>typedef uint32_t DatabaseID
</pre>

<h3 class="hbH3">
  <a name="993225"> </a>DmBackupRestoreStateType Struct <a href="#992934"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="993270"> </a>Purpose 
</h4>

<p><a name="1009450"> </a>Opaque container for the backup state, used to maintain state across multiple calls to <a href="DataMgr.html#995634"><code>DmBackupUpdate()</code></a> or <a href="DataMgr.html#1005778"><code>DmRestoreUpdate()</code></a>.</p>
<h4>
  <a name="993275"> </a>Declared In 
</h4>
<code>DataMgr.h<a name="993278"> </a></code><h4>
  <a name="993280"> </a>Prototype 
</h4>
<pre class="proto"><a name="993283"></a>typedef struct DmBackupRestoreStateTag {
   uint32_t info[12];
} DmBackupRestoreStateType
</pre>
<pre class="proto"><a name="1009686"></a>typedef DmBackupRestoreStateType 
*DmBackupRestoreStatePtr
</pre>
<h4>
  <a name="993285"> </a>Fields 
</h4>

<dl>
<dt><a name="993288"> </a><code>info</code></dt>
<dd><a name="1009489"> </a>The backup state.</dd>

</dl>
<h4>
  <a name="993292"> </a>Comments 
</h4>

<p><a name="1008624"> </a>Your application allocates a structure of this type and passes it to <a href="DataMgr.html#995549"><code>DmBackupInitialize()</code></a> (or <a href="DataMgr.html#1005732"><code>DmRestoreInitialize()</code></a>) for initialization prior to serializing a database (or restoring a database that has been serialized). After passing it to <a href="DataMgr.html#995634"><code>DmBackupUpdate()</code></a> (<a href="DataMgr.html#1005778"><code>DmRestoreUpdate()</code></a>), calling that function as many times as necessary, your application must pass it to <a href="DataMgr.html#995503"><code>DmBackupFinalize()</code></a> (<a href="DataMgr.html#1005674"><code>DmRestoreFinalize()</code></a>) before releasing the storage occupied by the structure. </p>

<div><hr>
  <a name="1008643"> </a> <b>NOTE: </b> The contents of this structure are opaque; your application should not attempt to directly manipulate the contents of this structure in any way.
<hr>
</div>

<h3 class="hbH3">
  <a name="993322"> </a>DmDatabaseInfoType Struct <a href="#992934"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="993327"> </a>Purpose 
</h4>

<p><a name="1016975"> </a>Data structure used to return information about a database through a call to <a href="DataMgr.html#996192"><code>DmDatabaseInfo()</code></a>.</p>
<h4>
  <a name="993332"> </a>Declared In 
</h4>
<code>DataMgr.h<a name="993335"> </a></code><h4>
  <a name="993337"> </a>Prototype 
</h4>
<pre class="proto"><a name="993340"></a>typedef struct DmDatabaseInfoTag {
   uint32_t size;
   char *pName;
   char *pDispName;
   uint16_t *pAttributes;
   uint16_t *pVersion;
   uint32_t *pType;
   uint32_t *pCreator;
   uint32_t *pCrDate;
   uint32_t *pModDate;
   uint32_t *pBckpDate;
   uint32_t *pModNum;
   MemHandle *pAppInfoHandle;
   MemHandle *pSortInfoHandle;
   uint16_t *pEncoding;
} DmDatabaseInfoType
</pre>
<pre class="proto"><a name="1016818"></a>typedef DmDatabaseInfoType *DmDatabaseInfoPtr
</pre>
<h4>
  <a name="993358"> </a>Fields 
</h4>

<dl>
<dt><a name="993409"> </a><code>size</code></dt>
<dd><a name="1016982"> </a>Size of this structure.</dd>

<dt><a name="993509"> </a><code>pName</code></dt>
<dd><a name="1016986"> </a>The database's name. This should be a pointer to 32-byte character array for this parameter, or <code>NULL</code> if you don't care about the name.</dd>

<dt><a name="993561"> </a><code>pDispName</code></dt>
<dd><a name="1017024"> </a><i>(Schema databases only)</i> The database's display name.</dd>

<dt><a name="993565"> </a><code>pAttributes</code></dt>
<dd><a name="1017030"> </a>The database's attribute flags. The section <a href="DataMgr.html#1049292">"Database Attributes"</a> lists constants you can use to query the values returned in this parameter.</dd>

<dt><a name="993569"> </a><code>pVersion</code></dt>
<dd><a name="1017035"> </a>The application-specific version number. The default version number is 0.</dd>

<dt><a name="993573"> </a><code>pType</code></dt>
<dd><a name="1017039"> </a>The database's type, specified when it is created.</dd>

<dt><a name="993577"> </a><code>pCreator</code></dt>
<dd><a name="1017043"> </a>The database's creator, specified when it is created.</dd>

<dt><a name="993581"> </a><code>pCrDate</code></dt>
<dd><a name="1017047"> </a>The date the database was created, expressed as the number of seconds since the start of the Unix epoch.</dd>

<dt><a name="993585"> </a><code>pModDate</code></dt>
<dd><a name="1017051"> </a>The date the database was last modified, expressed as the number of seconds since the start of the Unix epoch.</dd>

<dt><a name="993593"> </a><code>pBckpDate</code></dt>
<dd><a name="1017055"> </a>The date the database was backed up, expressed as the number of seconds since the start of the Unix epoch.</dd>

<dt><a name="993597"> </a><code>pModNum</code></dt>
<dd><a name="1017218"> </a>The modification number, which is incremented every time a record in the database is added, modified, or deleted.</dd>

<dt><a name="993601"> </a><code>pAppInfoHandle</code></dt>
<dd><a name="1017282"> </a><i>(Non-schema databases only)</i> Handle of the application info block, or <code>NULL</code>. The application info block is an optional field that the database may use to store application-specific information about the database.</dd>

<dt><a name="993605"> </a><code>pSortInfoHandle</code></dt>
<dd><a name="1017330"> </a><i>(Non-schema databases only)</i> Handle of the database's sort table. This is an optional field in the database header.</dd>

<dt><a name="993609"> </a><code>pEncoding</code></dt>
<dd><a name="1017334"> </a><i>(Schema databases only)</i> The database's encoding.</dd>

</dl>
<h4>
  <a name="993613"> </a>Comments 
</h4>

<p><a name="1017341"> </a>Prior to calling <a href="DataMgr.html#996192"><code>DmDatabaseInfo()</code></a>, initialize the fields of this structure to point to variables where <code>DmDatabaseInfo()</code> will write the information. If you don't want to retrieve data corresponding to a given field, set that field to <code>NULL</code>. See the comments section for <a href="DataMgr.html#999000"><code>DmGetNextDatabaseByTypeCreator()</code></a> for an example of how this structure is initialized and used.</p>

<p><a name="1206282"> </a>The fields representing dates (<code>pCrDate</code>, <code>pModDate</code>, <span style="color: #000000;  font-family: Courier; font-style: normal; font-weight: normal; text-decoration: none; text-transform: none; vertical-align: baseline">pBckpDate</span>) contain the number of non-leap seconds since the start of the Unix epoch: 00:00:00 UTC on Jan 1, 1970. Note that this is different from the way dates are returned by PACE, and is different from the way they are returned by <a href="DataMgr.html#996281"><code>DmDatabaseInfoV50()</code></a>; PACE and <code>DmDatabaseInfoV50()</code> return dates based upon the "Palm OS epoch": the number of seconds since the beginning of Jan 1, 1904, local time.</p>

<h3 class="hbH3">
  <a name="993618"> </a>DmFindType Typedef <a href="#992934"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="993623"> </a>Purpose 
</h4>

<p><a name="1098365"> </a>Flags that indicate the type of database to be searched for when using <a href="DataMgr.html#1077521"><code>DmFindDatabase()</code></a>, <a href="DataMgr.html#997169"><code>DmFindDatabaseByTypeCreator()</code></a>, or <a href="DataMgr.html#1003442"><code>DmOpenIteratorByTypeCreator()</code></a>. These flags can be OR'd together to search for a combination of database types.</p>
<h4>
  <a name="993628"> </a>Declared In 
</h4>
<code>DataMgr.h<a name="993631"> </a></code><h4>
  <a name="993633"> </a>Prototype 
</h4>
<pre class="proto"><a name="993636"></a>typedef uint32_t DmFindType
</pre>
<h4>
  <a name="1096713"> </a>Constants 
</h4>

<dl>
<dt><a name="1096716"> </a><code>#define dmFindClassicDB ((DmFindType)0x00000004)</code></dt>
<dd><a name="1096717"> </a>Classic databases.</dd>

<dt><a name="1096719"> </a><code>#define dmFindExtendedDB ((DmFindType)0x00000002)</code></dt>
<dd><a name="1096720"> </a>Extended databases.</dd>

<dt><a name="1096722"> </a><code>#define dmFindSchemaDB ((DmFindType)0x00000001)</code></dt>
<dd><a name="1096723"> </a>Schema databases.</dd>

<dt><a name="1096725"> </a><code>#define dmFindAllDB (dmFindSchemaDB | dmFindExtendedDB | dmFindClassicDB)</code></dt>
<dd><a name="1096726"> </a>A convenience value that can be used when searching for databases of any type.</dd>

</dl>
<h4>
  <a name="1098410"> </a>See Also 
</h4>

<p><a name="1098501"> </a><a href="FilesAndDatabases.html#608590">Chapter 2, "Palm OS Databases,"</a></p>

<h3 class="hbH3">
  <a name="1146522"> </a>DmOpenModeType Typedef <a href="#992934"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="1146583"> </a>Purpose 
</h4>

<p><a name="1146590"> </a>Type that holds the mode in which a database can be opened. You pass one or more of the associated constants as a parameter to <a href="DataMgr.html#1002512"><code>DmOpenDatabase()</code></a>, <a href="DataMgr.html#1002766"><code>DmOpenDatabaseByTypeCreator()</code></a>, or <a href="DataMgr.html#1003062"><code>DmOpenDBNoOverlay()</code></a>. These constants are also used when working with schema databases using either <a href="SchemaDatabases.html#1000351"><code>DbOpenDatabase()</code></a> or <a href="SchemaDatabases.html#1000405"><code>DbOpenDatabaseByName()</code></a>.</p>
<h4>
  <a name="1146591"> </a>Declared In 
</h4>
<code>DataMgr.h<a name="1146594"> </a></code><h4>
  <a name="1146632"> </a>Prototype 
</h4>
<pre class="proto"><a name="1146686"></a>typedef uint16_t DmOpenModeType;
</pre>
<h4>
  <a name="1153441"> </a>Constants 
</h4>

<dl>
<dt><a name="1153443"> </a><code>#define dmModeExclusive ((DmOpenModeType)0x0008)</code></dt>
<dd><a name="1153444"> </a>While the database is open don't let anyone else open it. This value cannot be passed to <a href="SchemaDatabases.html#1000351"><code>DbOpenDatabase()</code></a> and <a href="SchemaDatabases.html#1000405"><code>DbOpenDatabaseByName()</code></a>.</dd>

<dt><a name="1153461"> </a><code>#define dmModeReadOnly ((DmOpenModeType)0x0001)</code></dt>
<dd><a name="1153462"> </a>Open the database with read-only access. This value can be passed to <a href="SchemaDatabases.html#1000351"><code>DbOpenDatabase()</code></a> and <a href="SchemaDatabases.html#1000405"><code>DbOpenDatabaseByName()</code></a>.</dd>

<dt><a name="1153470"> </a><code>#define dmModeReadWrite ((DmOpenModeType)0x0003)</code></dt>
<dd><a name="1153471"> </a>Open the database with read-write access. This value can be passed to <a href="SchemaDatabases.html#1000351"><code>DbOpenDatabase()</code></a> and <a href="SchemaDatabases.html#1000405"><code>DbOpenDatabaseByName()</code></a>. Use <code>dmModeWrite</code> when calling any of the <code>DmOpen...</code> functions.</dd>

<dt><a name="1153479"> </a><code>#define dmModeShowSecret ((DmOpenModeType)0x0010)</code></dt>
<dd><a name="1153480"> </a>Show records marked private. This value can be passed to <a href="SchemaDatabases.html#1000351"><code>DbOpenDatabase()</code></a> and <a href="SchemaDatabases.html#1000405"><code>DbOpenDatabaseByName()</code></a>.</dd>

<dt><a name="1153488"> </a><code>#define dmModeWrite ((DmOpenModeType)0x0002)</code></dt>
<dd><a name="1153489"> </a>Open the database with write-only access. This value cannot be passed to <a href="SchemaDatabases.html#1000351"><code>DbOpenDatabase()</code></a> and <a href="SchemaDatabases.html#1000405"><code>DbOpenDatabaseByName()</code></a>; use <code>dmModeReadWrite</code> when calling one of these functions.</dd>

</dl>

<h3 class="hbH3">
  <a name="993643"> </a>DmOpenRef Struct <a href="#992934"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="993648"> </a>Purpose 
</h4>

<p><a name="1017442"> </a>Defines a pointer to an open database.</p>
<h4>
  <a name="993653"> </a>Declared In 
</h4>
<code>DataMgr.h<a name="993656"> </a></code><h4>
  <a name="993658"> </a>Prototype 
</h4>
<pre class="proto"><a name="993661"></a>typedef struct _opaque *DmOpenRef
</pre>
<h4>
  <a name="993663"> </a>Fields 
</h4>

<p><a name="993666"> </a>None.</p>
<h4>
  <a name="993668"> </a>Comments 
</h4>

<p><a name="1017474"> </a>The database pointer is created and returned by <a href="DataMgr.html#1002512"><code>DmOpenDatabase()</code></a>. It is used in any function that requires access to an open database. </p>

<h3 class="hbH3">
  <a name="993673"> </a>DmResourceID Typedef <a href="#992934"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="993678"> </a>Purpose 
</h4>

<p><a name="1017493"> </a>Defines a resource identifier. You assign each resource an ID at creation time. </p>
<h4>
  <a name="993683"> </a>Declared In 
</h4>
<code>DataMgr.h<a name="993686"> </a></code><h4>
  <a name="993688"> </a>Prototype 
</h4>
<pre class="proto"><a name="993717"></a>typedef uint16_t DmResourceID
</pre>
<h4>
  <a name="993749"> </a>Comments 
</h4>

<p><a name="1017509"> </a>Resource IDs greater than or equal to 10000 are reserved for system use.</p>

<h3 class="hbH3">
  <a name="993858"> </a>DmResourceType Typedef <a href="#992934"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="993919"> </a>Purpose 
</h4>

<p><a name="1017519"> </a>Defines the type of a resource.</p>
<h4>
  <a name="993924"> </a>Declared In 
</h4>
<code>DataMgr.h<a name="993927"> </a></code><h4>
  <a name="993929"> </a>Prototype 
</h4>
<pre class="proto"><a name="993932"></a>typedef uint32_t DmResourceType
</pre>
<h4>
  <a name="993934"> </a>Comments 
</h4>

<p><a name="1017527"> </a>The resource type is a four-character code such as <code>'Tbmp'</code> for bitmap resources. </p>

<h3 class="hbH3">
  <a name="993964"> </a>DmSearchStateType Struct <a href="#992934"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="993969"> </a>Purpose 
</h4>

<p><a name="1017542"> </a>Opaque container for the search state, used to maintain state when iterating through databases that match a specified type and creator.</p>
<h4>
  <a name="993974"> </a>Declared In 
</h4>
<code>DataMgr.h<a name="993977"> </a></code><h4>
  <a name="993979"> </a>Prototype 
</h4>
<pre class="proto"><a name="993982"></a>typedef struct {
   uint32_t info[8];
} DmSearchStateType
</pre>
<pre class="proto"><a name="1017537"></a>typedef DmSearchStateType *DmSearchStatePtr
</pre>
<h4>
  <a name="993984"> </a>Fields 
</h4>

<dl>
<dt><a name="993987"> </a><code>info</code></dt>
<dd><a name="1024206"> </a>The search state.</dd>

</dl>
<h4>
  <a name="993991"> </a>Comments 
</h4>

<p><a name="1024234"> </a>Your application should allocate a <code>DmSearchStateType</code> structure and pass it as the <code class="par">stateInfoP</code> parameter when iterating through databases with <a href="DataMgr.html#1003442"><code>DmOpenIteratorByTypeCreator()</code></a>, <a href="DataMgr.html#999000"><code>DmGetNextDatabaseByTypeCreator()</code></a>, and <a href="DataMgr.html#995734"><code>DmCloseIteratorByTypeCreator()</code></a>; or when calling <a href="DataMgr.html#999050"><code>DmGetNextDatabaseByTypeCreatorV50()</code></a>. These functions store private information in this structure and use that information if the search is continued.</p>

<div><hr>
  <a name="1024235"> </a> <b>NOTE: </b> The contents of this structure are opaque; your application should not attempt to directly manipulate the contents of this structure in any way.
<hr>
</div>

<h3 class="hbH3">
  <a name="994025"> </a>DmSortRecordInfoType Struct <a href="#992934"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="994030"> </a>Purpose 
</h4>

<p><a name="1024993"> </a>Specifies information that can be used to sort a record. </p>
<h4>
  <a name="994035"> </a>Declared In 
</h4>
<code>DataMgr.h<a name="994038"> </a></code><h4>
  <a name="994040"> </a>Prototype 
</h4>
<pre class="proto"><a name="994043"></a>typedef struct {
   uint8_t attributes;
   uint8_t uniqueID[3];
} DmSortRecordInfoType
</pre>
<pre class="proto"><a name="1024940"></a>typedef DmSortRecordInfoType *DmSortRecordInfoPtr
</pre>
<h4>
  <a name="994045"> </a>Fields 
</h4>

<dl>
<dt><a name="994048"> </a><code>attributes</code></dt>
<dd><a name="1025047"> </a>The record's attributes. See <a href="DataMgr.html#1041655">"Non-Schema Database Record Attributes."</a></dd>

<dt><a name="994052"> </a><code>uniqueID</code></dt>
<dd><a name="1025100"> </a>The unique identifier for the record.</dd>

</dl>
<h4>
  <a name="994056"> </a>Comments 
</h4>

<p><a name="1025155"> </a>The database sorting functions (<a href="DataMgr.html#1001522"><code>DmInsertionSort()</code></a> and <a href="DataMgr.html#1004245"><code>DmQuickSort()</code></a>) pass this structure to your comparison callback function (of type <a href="DataMgr.html#1007926"><code>DmCompareFunctionType()</code></a>), where you can use the information therein to help when comparing two records. To create this structure, you can call <a href="DataMgr.html#1004375"><code>DmRecordInfoV50()</code></a>, which returns these values for a given record.</p>

<h3 class="hbH3">
  <a name="994086"> </a>DmStorageInfoType Struct <a href="#992934"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="994091"> </a>Purpose 
</h4>

<p><a name="1025277"> </a>Returns storage heap memory usage information through a call to <a href="DataMgr.html#1000927"><code>DmGetStorageInfo()</code></a>.</p>
<h4>
  <a name="994096"> </a>Declared In 
</h4>
<code>DataMgr.h<a name="994099"> </a></code><h4>
  <a name="994101"> </a>Prototype 
</h4>
<pre class="proto"><a name="994130"></a>typedef struct DmStorageInfoTag {
   uint32_t size;
   uint32_t bytesTotal;
   uint32_t bytesNonSecureUsed;
   uint32_t bytesNonSecureFree;
   uint32_t bytesSecureUsed;
   uint32_t bytesSecureFree;
   uint32_t bytesFreePool;
} DmStorageInfoType
</pre>
<pre class="proto"><a name="1025202"></a>typedef DmStorageInfoType *DmStorageInfoPtr
</pre>
<h4>
  <a name="994186"> </a>Fields 
</h4>

<dl>
<dt><a name="994237"> </a><code>size</code></dt>
<dd><a name="1025314"> </a>Size of this structure.</dd>

<dt><a name="994337"> </a><code>bytesTotal</code></dt>
<dd><a name="1025354"> </a>Total amount of memory available for persistent storage.</dd>

<dt><a name="994389"> </a><code>bytesNonSecureUsed</code></dt>
<dd><a name="1025370"> </a>Amount of memory used in non-secure storage.</dd>

<dt><a name="994393"> </a><code>bytesNonSecureFree</code></dt>
<dd><a name="1025386"> </a>Amount of free memory in non-secure storage.</dd>

<dt><a name="994397"> </a><code>bytesSecureUsed</code></dt>
<dd><a name="1025402"> </a>Amount of memory used in secure storage.</dd>

<dt><a name="994401"> </a><code>bytesSecureFree</code></dt>
<dd><a name="1025418"> </a>Amount of free memory in secure storage.</dd>

<dt><a name="994405"> </a><code>bytesFreePool</code></dt>
<dd><a name="1025434"> </a>Amount of memory in the free pool, available for both secure and non-secure storage.</dd>

</dl>

<h2 class="haH2">
  <a name="994414"> </a>Data Manager Constants <a href="#992934"><span class="nav">^TOP^</span></a>
</h2>


<h3 class="hbH3">
  <a name="1041655"> </a>Non-Schema Database Record Attributes <a href="#992934"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="1041656"> </a>Purpose 
</h4>

<p><a name="1041657"> </a>These constants define the set of attributes that a non-schema database record can have. Use <a href="DataMgr.html#1000420"><code>DmGetRecordAttr()</code></a> to obtain a database record's attributes.</p>
<h4>
  <a name="1041661"> </a>Declared In 
</h4>
<code>DataMgr.h<a name="1041662"> </a></code><h4>
  <a name="1041663"> </a>Constants 
</h4>

<dl>
<dt><a name="1041665"> </a><code>#define dmAllRecAttrs ( dmRecAttrDelete | dmRecAttrDirty | dmRecAttrBusy | dmRecAttrSecret )</code></dt>
<dd><a name="1041666"> </a>The complete set of record attributes.</dd>

<dt><a name="1041668"> </a><code>#define dmRecAttrBusy 0x20</code></dt>
<dd><a name="1041669"> </a>The application has locked access to the record. A call to <a href="DataMgr.html#1000166"><code>DmGetRecord()</code></a> fails on a record that has this bit set.</dd>

<dt><a name="1041674"> </a><code>#define dmRecAttrDelete 0x80</code></dt>
<dd><a name="1041675"> </a>The record has been deleted.</dd>

<dt><a name="1041677"> </a><code>#define dmRecAttrDirty 0x40</code></dt>
<dd><a name="1041678"> </a>The record has been modified since the last sync.</dd>

<dt><a name="1041680"> </a><code>#define dmRecAttrSecret 0x10</code></dt>
<dd><a name="1041681"> </a>The record is private.</dd>

<dt><a name="1041683"> </a><code>#define dmSysOnlyRecAttrs ( dmRecAttrBusy )</code></dt>
<dd><a name="1041684"> </a>Mask that identifies those attributes that only the system can change.</dd>

<dt><a name="1041686"> </a><code>#define dmRecAttrCategoryMask ( (uint8_t) 0x0F )</code></dt>
<dd><a name="1041687"> </a>Mask that isolates the record's category.</dd>

</dl>

<h3 class="hbH3">
  <a name="1049292"> </a>Database Attributes <a href="#992934"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="1049293"> </a>Purpose 
</h4>

<p><a name="1049294"> </a>Define the set of attributes that a database can have. These attributes apply to schema, extended, and classic databases.</p>
<h4>
  <a name="1049295"> </a>Declared In 
</h4>
<code>DataMgr.h<a name="1049296"> </a></code><h4>
  <a name="1049297"> </a>Constants 
</h4>

<dl>
<dt><a name="1157522"> </a><code>#define dmAllHdrAttrs (dmHdrAttrResDB | dmHdrAttrReadOnly | dmHdrAttrAppInfoDirty | dmHdrAttrBackup | dmHdrAttrOKToInstallNewer | dmHdrAttrResetAfterInstall | dmHdrAttrCopyPrevention | dmHdrAttrStream | dmHdrAttrHidden | dmHdrAttrLaunchableData | dmHdrAttrRecyclable | dmHdrAttrBundle | dmHdrAttrSchema | dmHdrAttrSecure | dmHdrAttrOpen)</code></dt>
<dd><a name="1049287"> </a>A mask used to specify all header attributes.</dd>

<dt><a name="1048543"> </a><code>#define dmHdrAttrAppInfoDirty 0x0004</code></dt>
<dd><a name="1049436"> </a>The application info block is dirty (it has been modified since the last sync). This bit only applies to non-schema databases; schema databases don't have application info blocks.</dd>

<dt><a name="1048545"> </a><code>#define dmHdrAttrBackup 0x0008</code></dt>
<dd><a name="1049440"> </a>The database should be backed up to the desktop computer if no application-specific conduit is available. </dd>

<dt><a name="1048547"> </a><code>#define dmHdrAttrBundle 0x0800</code></dt>
<dd><a name="1049469"> </a>The database is bundled with its application during a beam, send, or copy operation. That is, if the user chooses to beam the application from the Launcher, the Launcher beams this database along with the application's resource database and overlay database. (Note that overlay databases are automatically beamed with the application database. You do not need to set this bit in overlay databases.)</dd>

<dt><a name="1048549"> </a><code>#define dmHdrAttrCopyPrevention 0x0040</code></dt>
<dd><a name="1049489"> </a>Prevents the database from being copied by methods such as IR beaming.</dd>

<dt><a name="1048553"> </a><code>#define dmHdrAttrHidden 0x0100</code></dt>
<dd><a name="1049505"> </a>This database should be hidden from view. For example, this attribute is set to hide some applications in the Launcher's main view. You can set it on record databases to have the Launcher disregard the database's records when showing a count of records.</dd>

<dt><a name="1048555"> </a><code>#define dmHdrAttrLaunchableData 0x0200</code></dt>
<dd><a name="1050106"> </a>This database contains data but it can be "launched" from the Launcher. </dd>

<dt><a name="1048557"> </a><code>#define dmHdrAttrExtendedDB dmHdrAttrSecure</code></dt>
<dd><a name="1048558"> </a>If <code>dmHdrAttrSchema</code> is not set, the database is an extended database. Note that this bit serves a dual-purpose, depending upon the <code>dmHdrAttrSchema</code> bit; if the database is a schema database (<code>dmHdrAttrSchema</code> is set), this bit indicates whether or not the schema database is a secure database. See <a href="FilesAndDatabases.html#608590">Chapter 2, "Palm OS Databases,"</a> for an explanation of the differences between the various database types.</dd>

<dt><a name="1048559"> </a><code>#define dmHdrAttrOKToInstallNewer 0x0010</code></dt>
<dd><a name="1050122"> </a>The backup conduit can install a newer version of this database with a different name if the current database is open. This mechanism is used to update the Graffiti 2 Shortcuts databases, for example.</dd>

<dt><a name="1048561"> </a><code>#define dmHdrAttrOpen 0x8000</code></dt>
<dd><a name="1050134"> </a>The database is open.</dd>

<dt><a name="1048563"> </a><code>#define dmHdrAttrReadOnly 0x0002</code></dt>
<dd><a name="1050138"> </a>The database is a read-only database.</dd>

<dt><a name="1048565"> </a><code>#define dmHdrAttrRecyclable 0x0400</code></dt>
<dd><a name="1050142"> </a>The database is recyclable. Recyclable databases are deleted when they are closed or upon a system reset. </dd>

<dt><a name="1048567"> </a><code>#define dmHdrAttrResDB 0x0001</code></dt>
<dd><a name="1050146"> </a>The database is a resource database.</dd>

<dt><a name="1048569"> </a><code>#define dmHdrAttrResetAfterInstall 0x0020</code></dt>
<dd><a name="1050150"> </a>The device must be reset after this database is installed. That is, the HotSync<sup>&#174;</sup> application forces a reset after installing this database.</dd>

<dt><a name="1048571"> </a><code>#define dmHdrAttrSchema 0x1000</code></dt>
<dd><a name="1050177"> </a>The database is a schema database. See <a href="FilesAndDatabases.html#608590">Chapter 2, "Palm OS Databases,"</a> for an explanation of the differences between the various database types.</dd>

<dt><a name="1048573"> </a><code>#define dmHdrAttrSecure 0x2000</code></dt>
<dd><a name="1050181"> </a>The database is a secure database.</dd>

<dt><a name="1048575"> </a><code>#define dmHdrAttrStream 0x0080</code></dt>
<dd><a name="1050185"> </a>The database is a file stream.</dd>

<dt><a name="1049266"> </a><code>#define dmSysOnlyHdrAttrs ( dmHdrAttrResDB | dmHdrAttrSchema | dmHdrAttrSecure | dmHdrAttrOpen )</code></dt>
<dd><a name="1050189"> </a>A mask specifying the attributes that only the system can change (open and resource database).</dd>

</dl>

<h3 class="hbH3">
  <a name="1050193"> </a>Miscellaneous Data Manager Constants <a href="#992934"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="1050194"> </a>Purpose 
</h4>

<p><a name="1050195"> </a>Miscellaneous constants defined by the Data Manager.</p>
<h4>
  <a name="1050196"> </a>Declared In 
</h4>
<code>DataMgr.h<a name="1050197"> </a></code><h4>
  <a name="1050198"> </a>Constants 
</h4>

<dl>
<dt><a name="1050461"> </a><code>#define appInfoStringsRsc 'tAIS'</code></dt>
<dd><a name="1064653"> </a>Application Info strings resource type.</dd>

<dt><a name="1051449"> </a><code>#define dmMaxRecordIndex ( (uint16_t) 0xFFFE )</code></dt>
<dd><a name="1051450"> </a>The highest record index that can be used with a classic database.</dd>

<dt><a name="1051511"> </a><code>#define dmAllCategories ( (uint8_t) 0xFF )</code></dt>
<dd><a name="1064657"> </a>Category value that can be supplied to <a href="DataMgr.html#1002424"><code>DmNumRecordsInCategory()</code></a> and <a href="DataMgr.html#1003917"><code>DmQueryNextInCategory()</code></a> to indicate all categories.</dd>

<dt><a name="1051628"> </a><code>#define dmCategoryLength 16</code></dt>
<dd><a name="1183416"> </a>The maximum length of a classic or extended database category name, in bytes, including the <code>NULL</code> terminator.</dd>

<dt><a name="1183418"> </a><code>#define dmDBNameLength 32</code></dt>
<dd><a name="1064792"> </a>The maximum length of a database name, in bytes, including the <code>NULL</code> terminator.</dd>

<dt><a name="1051632"> </a><code>#define dmDefaultRecordsID 0</code></dt>
<dd><a name="1109332"> </a>Records in a default database are copied with their unique ID seeds set to this value.</dd>

<dt><a name="1057545"> </a><code>#define dmInvalidRecIndex ( (uint16_t) -1 )</code></dt>
<dd><a name="1064799"> </a>Resource index value returned by <a href="DataMgr.html#997720"><code>DmFindResource()</code></a> when that function fails to find the specified resource.</dd>

<dt><a name="1057547"> </a><code>#define dmRecNumCategories 16</code></dt>
<dd><a name="1057548"> </a>The maximum number of categories that can be used with a classic or extended database.</dd>

<dt><a name="1057549"> </a><code>#define dmRecordIDReservedRange 1</code></dt>
<dd><a name="1057550"> </a>Upper limit of the range of unique ID seed values reserved for use by the operating system in conjunction with classic and extended databases.</dd>

<dt><a name="1057551"> </a><code>#define dmSearchWildcardID ((uint32_t)0)</code></dt>
<dd><a name="1057552"> </a>A "wild card" that matches databases of any type and/or creator when iterating through databases with <a href="DataMgr.html#1003442"><code>DmOpenIteratorByTypeCreator()</code></a> or searching for databases with either <a href="DataMgr.html#999000"><code>DmGetNextDatabaseByTypeCreator()</code></a> or <a href="DataMgr.html#999050"><code>DmGetNextDatabaseByTypeCreatorV50()</code></a>.</dd>

<dt><a name="1057553"> </a><code>#define dmSeekBackward -1</code></dt>
<dd><a name="1064803"> </a>Direction value supplied to <a href="DataMgr.html#997658"><code>DmFindRecordByOffsetInCategory()</code></a> to indicate that the search should be performed from the specified position towards the beginning of the database.</dd>

<dt><a name="1057555"> </a><code>#define dmSeekForward 1</code></dt>
<dd><a name="1064830"> </a>Direction value supplied to <a href="DataMgr.html#997658"><code>DmFindRecordByOffsetInCategory()</code></a> to indicate that the search should be performed from the specified position towards the end of the database.</dd>

<dt><a name="1057557"> </a><code>#define dmUnfiledCategory 0</code></dt>
<dd><a name="1057558"> </a>Category identifier for the Unfiled category.</dd>

<dt><a name="1057559"> </a><code>#define dmUnusedRecordID 0</code></dt>
<dd><a name="1057560"> </a>A record ID value representing an illegal or unused record. A "real" record cannot use this value as its record identifier.</dd>

</dl>

<h3 class="hbH3">
  <a name="1064838"> </a>Data Manager Error Codes <a href="#992934"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="1064839"> </a>Purpose 
</h4>

<p><a name="1064840"> </a>Error codes returned by the various Data Manager functions. These codes are returned by schema database functions as well as classic database functions.</p>
<h4>
  <a name="1025477"> </a>Declared In 
</h4>
<code>DataMgr.h<a name="1025478"> </a></code><h4>
  <a name="1025479"> </a>Constants 
</h4>

<dl>
<dt><a name="1032301"> </a><code>#define dmErrAccessDenied (dmErrorClass | 37)</code></dt>
<dd><a name="1109487"> </a>The database is a secure database and you don't have permission to edit it.</dd>

<dt><a name="1032303"> </a><code>#define dmErrAlreadyExists (dmErrorClass | 25)</code></dt>
<dd><a name="1064869"> </a>Another database with the same name already exists.</dd>

<dt><a name="1032305"> </a><code>#define dmErrAlreadyOpenForWrites (dmErrorClass | 22)</code></dt>
<dd><a name="1064873"> </a>The database is already open with write access.</dd>

<dt><a name="1032309"> </a><code>#define dmErrBadOverlayDBName (dmErrorClass | 32)</code></dt>
<dd><a name="1032310"> </a>The length of the locale description or overlay database name is incorrect, or the locale description begins with an underscore ('_') character.</dd>

<dt><a name="1032311"> </a><code>#define dmErrBaseRequiresOverlay (dmErrorClass | 33)</code></dt>
<dd><a name="1032312"> </a>The base probably requires an overlay, but the corresponding overlay cannot be located.</dd>

<dt><a name="1032313"> </a><code>#define dmErrBufferNotLargeEnough (dmErrorClass | 42)</code></dt>
<dd><a name="1111827"> </a>While copying a table column value from a schema database, it was determined that the supplied buffer wasn't large enough to contain the column value.</dd>

<dt><a name="1032315"> </a><code>#define dmErrBuiltInProperty (dmErrorClass | 58)</code></dt>
<dd><a name="1109497"> </a>The schema database column property you are trying to alter is a built-in property; it cannot be changed or removed.</dd>

<dt><a name="1032317"> </a><code>#define dmErrCantFind (dmErrorClass | 7)</code></dt>
<dd><a name="1064877"> </a>The specified database can't be found.</dd>

<dt><a name="1032319"> </a><code>#define dmErrCantOpen (dmErrorClass | 6)</code></dt>
<dd><a name="1064881"> </a>The database cannot be opened.</dd>

<dt><a name="1032321"> </a><code>#define dmErrCategoryLimitReached (dmErrorClass | 74)</code></dt>
<dd><a name="1032322"> </a>The schema database row cannot be made a member of the specified category because it is already a member of the maximum number of allowable categories.</dd>

<dt><a name="1032323"> </a><code>#define dmErrColumnDefinitionsLocked (dmErrorClass | 76)</code></dt>
<dd><a name="1109509"> </a>The schema database table's column definitions are locked.</dd>

<dt><a name="1032325"> </a><code>#define dmErrColumnIDAlreadyExists (dmErrorClass | 46)</code></dt>
<dd><a name="1109513"> </a>The specified schema database table already contains a column with the specified ID.</dd>

<dt><a name="1032327"> </a><code>#define dmErrColumnIndexOutOfRange (dmErrorClass | 43)</code></dt>
<dd><a name="1109521"> </a>The supplied column index exceeds the number of columns in the schema database table.</dd>

<dt><a name="1032329"> </a><code>#define dmErrColumnNameAlreadyExists (dmErrorClass | 70)</code></dt>
<dd><a name="1109525"> </a>The specified schema database table already contains a column with the specified name.</dd>

<dt><a name="1032331"> </a><code>#define dmErrColumnPropertiesLocked (dmErrorClass | 75)</code></dt>
<dd><a name="1109529"> </a>The specified column property is locked.</dd>

<dt><a name="1032333"> </a><code>#define dmErrCorruptDatabase (dmErrorClass | 9)</code></dt>
<dd><a name="1064885"> </a>The database is corrupted.</dd>

<dt><a name="1032335"> </a><code>#define dmErrDatabaseNotProtected (dmErrorClass | 28)</code></dt>
<dd><a name="1064892"> </a><a href="DataMgr.html#996399"><code>DmDatabaseProtectV50()</code></a> failed to protect the specified database. </dd>

<dt><a name="1032337"> </a><code>#define dmErrDatabaseOpen (dmErrorClass | 5)</code></dt>
<dd><a name="1064896"> </a>The function cannot be performed on an open database, and the database is open. </dd>

<dt><a name="1032339"> </a><code>#define dmErrDatabaseProtected (dmErrorClass | 27)</code></dt>
<dd><a name="1064900"> </a>The database is marked as protected.</dd>

<dt><a name="1032341"> </a><code>#define dmErrDeviceLocked (dmErrorClass | 59)</code></dt>
<dd><a name="1032342"> </a></dd>

<dt><a name="1032343"> </a><code>#define dmErrEncryptionFailure (dmErrorClass | 54)</code></dt>
<dd><a name="1032344"> </a></dd>

<dt><a name="1032345"> </a><code>#define dmErrIndexOutOfRange (dmErrorClass | 2)</code></dt>
<dd><a name="1064904"> </a>The specified index is out of range.</dd>

<dt><a name="1032347"> </a><code>#define dmErrInvalidCategory (dmErrorClass | 18)</code></dt>
<dd><a name="1032348"> </a>At least one of the supplied category IDs is not a valid schema database category.</dd>

<dt><a name="1032349"> </a><code>#define dmErrInvalidColSpec (dmErrorClass | 40)</code></dt>
<dd><a name="1109533"> </a>At least one of the specified schema database table column attributes is not a valid column attribute.</dd>

<dt><a name="1032351"> </a><code>#define dmErrInvalidColType (dmErrorClass | 41)</code></dt>
<dd><a name="1109537"> </a>The specified schema database table column type is not a valid column type.</dd>

<dt><a name="1032353"> </a><code>#define dmErrInvalidColumnID (dmErrorClass | 44)</code></dt>
<dd><a name="1109552"> </a>One or more of the specified column IDs doesn't correspond to a column in the specified schema database table.</dd>

<dt><a name="1157421"> </a><code>#define dmErrInvalidColumnName (dmErrorClass | 79)</code></dt>
<dd><a name="1157422"> </a>The supplied column name doesn't correspond to a column within the schema database table.</dd>

<dt><a name="1032355"> </a><code>#define dmErrInvalidDatabaseName (dmErrorClass | 26)</code></dt>
<dd><a name="1064908"> </a>The name you've specified for the database is invalid.</dd>

<dt><a name="1032357"> </a><code>#define dmErrInvalidID (dmErrorClass | 30)</code></dt>
<dd><a name="1032358"> </a>The schema database row ID is invalid.</dd>

<dt><a name="1032359"> </a><code>#define dmErrInvalidIndex (dmErrorClass | 29)</code></dt>
<dd><a name="1032360"> </a>The row or sort index value exceeds the number of rows or sort indices defined for the schema database table.</dd>

<dt><a name="1032361"> </a><code>#define dmErrInvalidTableName (dmErrorClass | 78)</code></dt>
<dd><a name="1032362"> </a>The supplied table name doesn't correspond to a table in the schema database.</dd>

<dt><a name="1032363"> </a><code>#define dmErrInvalidOperation (dmErrorClass | 60)</code></dt>
<dd><a name="1032364"> </a>The requested schema database operation is not valid.</dd>

<dt><a name="1032365"> </a><code>#define dmErrInvalidParam (dmErrorClass | 3)</code></dt>
<dd><a name="1064912"> </a>The function received an invalid parameter.</dd>

<dt><a name="1032367"> </a><code>#define dmErrInvalidPrimaryKey (dmErrorClass | 66)</code></dt>
<dd><a name="1032368"> </a>Not currently used.</dd>

<dt><a name="1032369"> </a><code>#define dmErrInvalidPropID (dmErrorClass | 56)</code></dt>
<dd><a name="1109563"> </a>The specified schema database table column doesn't have a property with the specified property ID.</dd>

<dt><a name="1032371"> </a><code>#define dmErrInvalidSchemaDefn (dmErrorClass | 38)</code></dt>
<dd><a name="1109570"> </a>You are creating a schema database or adding a table to an existing schema database and the supplied <a href="SchemaDatabases.html#993597"><code>DbTableDefinitionType</code></a> structure defining the new table is invalid.</dd>

<dt><a name="1032375"> </a><code>#define dmErrInvalidSizeSpec (dmErrorClass | 51)</code></dt>
<dd><a name="1032376"> </a>You are creating a schema database or adding a table to an existing schema database and one of the table's vector column sizes is zero.</dd>

<dt><a name="1032377"> </a><code>#define dmErrInvalidSortDefn (dmErrorClass | 71)</code></dt>
<dd><a name="1032378"> </a>You are adding a sort index to a schema database that is incorrectly specified or you are attempting to remove a sort index that isn't defined for the database.</dd>

<dt><a name="1032379"> </a><code>#define dmErrInvalidSortIndex (dmErrorClass | 65)</code></dt>
<dd><a name="1110398"> </a>You are opening a schema database cursor and one of the specified sort IDs isn't defined for the specified database table.</dd>

<dt><a name="1110415"> </a><code>#define dmErrInvalidVectorType (dmErrorClass | 50)</code></dt>
<dd><a name="1110416"> </a>You adding a vector column to an existing schema database&#8212;either explicitly or during the creation of a new schema database&#8212;but the specified column type isn't appropriate for a vector column.</dd>

<dt><a name="1110418"> </a><code>#define dmErrMemError (dmErrorClass | 1)</code></dt>
<dd><a name="1110419"> </a>A memory error occurred.</dd>

<dt><a name="1032385"> </a><code>#define dmErrNoColumnData (dmErrorClass | 48)</code></dt>
<dd><a name="1032386"> </a>Your request for the value of one or more schema database table columns cannot be fulfilled because the column contains no data.</dd>

<dt><a name="1032387"> </a><code>#define dmErrNoCustomProperties (dmErrorClass | 57)</code></dt>
<dd><a name="1032388"> </a>The schema database contains no custom properties.</dd>

<dt><a name="1032389"> </a><code>#define dmErrNoData (dmErrorClass | 53)</code></dt>
<dd><a name="1111893"> </a>The specified schema database table has no columns defined. </dd>

<dt><a name="1032391"> </a><code>#define dmErrNoMoreData (dmErrorClass | 72)</code></dt>
<dd><a name="1032392"> </a>The backup operation is complete. See <a href="DataMgr.html#995634"><code>DmBackupUpdate()</code></a> for a detailed explanation and example of how this error code is used.</dd>

<dt><a name="1032393"> </a><code>#define dmErrNoOpenDatabase (dmErrorClass | 17)</code></dt>
<dd><a name="1064920"> </a>The function is to search all open databases, but there are none. </dd>

<dt><a name="1032395"> </a><code>#define dmErrNotRecordDB (dmErrorClass | 12)</code></dt>
<dd><a name="1064924"> </a>You've attempted to perform a record function on a resource database. </dd>

<dt><a name="1032397"> </a><code>#define dmErrNotResourceDB (dmErrorClass | 13)</code></dt>
<dd><a name="1064928"> </a>You've attempted to perform a Resource Manager operation on a record database. </dd>

<dt><a name="1032399"> </a><code>#define dmErrNotSchemaDatabase (dmErrorClass | 35)</code></dt>
<dd><a name="1032400"> </a>The specified database is not a schema database.</dd>

<dt><a name="1032401"> </a><code>#define dmErrNotSecureDatabase (dmErrorClass | 36)</code></dt>
<dd><a name="1110451"> </a>The specified database is not a secure schema database.</dd>

<dt><a name="1032403"> </a><code>#define dmErrNotValidRecord (dmErrorClass | 19)</code></dt>
<dd><a name="1064948"> </a>The record handle is invalid.</dd>

<dt><a name="1032405"> </a><code>#define dmErrNoUserPassword (dmErrorClass | 68)</code></dt>
<dd><a name="1032406"> </a>The Authorization Manager doesn't have a user password on file.</dd>

<dt><a name="1032407"> </a><code>#define dmErrOneOrMoreFailed (dmErrorClass | 62)</code></dt>
<dd><a name="1110455"> </a>At least one of the schema database table's column definitions could not be retrieved.</dd>

<dt><a name="1032409"> </a><code>#define dmErrOpenedByAnotherTask (dmErrorClass | 23)</code></dt>
<dd><a name="1064952"> </a>You've attempted to open a database that another task already has open. </dd>

<dt><a name="1032411"> </a><code>#define dmErrOperationAborted (dmErrorClass | 73)</code></dt>
<dd><a name="1032412"> </a>The variables bound to a schema database cursor couldn't be written to the database, or a database backup or restore operation was aborted.</dd>

<dt><a name="1032413"> </a><code>#define dmErrReadOnly (dmErrorClass | 4)</code></dt>
<dd><a name="1064956"> </a>You've attempted to write to or modify a database that is open in read-only mode.</dd>

<dt><a name="1032415"> </a><code>#define dmErrReadOutOfBounds (dmErrorClass | 49)</code></dt>
<dd><a name="1032416"> </a>A schema database table vector column is being read in which the specified offset exceeds the bounds of the column.</dd>

<dt><a name="1032417"> </a><code>#define dmErrRecordArchived (dmErrorClass | 11)</code></dt>
<dd><a name="1064960"> </a>The function requires that the record not be archived, but it is.</dd>

<dt><a name="1032419"> </a><code>#define dmErrRecordBusy (dmErrorClass | 15)</code></dt>
<dd><a name="1064976"> </a>The function requires that the record not be busy, but it is.</dd>

<dt><a name="1032421"> </a><code>#define dmErrRecordDeleted (dmErrorClass | 10)</code></dt>
<dd><a name="1064980"> </a>The record has been deleted.</dd>

<dt><a name="1032423"> </a><code>#define dmErrRecordInWrongCard (dmErrorClass | 8)</code></dt>
<dd><a name="1064984"> </a>You've attempted to attach a record to a database when the record and database reside on different memory cards. </dd>

<dt><a name="1032425"> </a><code>#define dmErrTableNotEmpty (dmErrorClass | 61)</code></dt>
<dd><a name="1032426"> </a>An attempt to remove a schema database table failed because the table isn't empty.</dd>

<dt><a name="1032427"> </a><code>#define dmErrResourceNotFound (dmErrorClass | 16)</code></dt>
<dd><a name="1064988"> </a>The resource can't be found.</dd>

<dt><a name="1032429"> </a><code>#define dmErrROMBased (dmErrorClass | 14)</code></dt>
<dd><a name="1065004"> </a>You've attempted to delete or modify a ROM-based database.</dd>

<dt><a name="1032431"> </a><code>#define dmErrSchemaBase (dmErrorClass | 34)</code></dt>
<dd><a name="1032432"> </a>Not an actual error code: this value serves to mark the beginning of the set of error codes created specifically for schema databases.</dd>

<dt><a name="1032435"> </a><code>#define dmErrSchemaIndexOutOfRange (dmErrorClass | 47)</code></dt>
<dd><a name="1032436"> </a>The supplied table index exceeds the number of tables in the schema database.</dd>

<dt><a name="1032437"> </a><code>#define dmErrTableNameAlreadyExists (dmErrorClass | 69)</code></dt>
<dd><a name="1111165"> </a>The schema database to which you are attempting to add a new table already contains a table with the supplied name, or, during the creation of a new schema database, you specified the same table name more than once.</dd>

<dt><a name="1032439"> </a><code>#define dmErrSchemaNotFound (dmErrorClass | 55)</code></dt>
<dd><a name="1111313"> </a>Not currently used.</dd>

<dt><a name="1032441"> </a><code>#define dmErrSeekFailed (dmErrorClass | 21)</code></dt>
<dd><a name="1065020"> </a>The operation of seeking the next record in the category failed. </dd>

<dt><a name="1111401"> </a><code>#define dmErrSortDisabled (dmErrorClass | 67)</code></dt>
<dd><a name="1111449"> </a>Not currently used.</dd>

<dt><a name="1111404"> </a><code>#define dmErrSQLParseError (dmErrorClass | 78)</code></dt>
<dd><a name="1111405"> </a>The SQL used to specify the schema database sort index is incorrectly formatted.</dd>

<dt><a name="1032447"> </a><code>#define dmErrUniqueIDNotFound (dmErrorClass | 24)</code></dt>
<dd><a name="1065032"> </a>A record with the specified unique ID can't be found.</dd>

<dt><a name="1032449"> </a><code>#define dmErrUnknownLocale (dmErrorClass | 31)</code></dt>
<dd><a name="1032450"> </a>The specified locale is unknown to the operating system.</dd>

<dt><a name="1032451"> </a><code>#define dmErrCursorBOF (dmErrorClass | 63)</code></dt>
<dd><a name="1032452"> </a>The schema database cursor position&#8212;either the current position or the one specified&#8212;is located before the first row in the cursor.</dd>

<dt><a name="1032453"> </a><code>#define dmErrCursorEOF (dmErrorClass | 64)</code></dt>
<dd><a name="1111789"> </a>The schema database cursor position&#8212;either the current position or the one specified&#8212;is located after the last row in the cursor.</dd>

<dt><a name="1032455"> </a><code>#define dmErrWriteOutOfBounds (dmErrorClass | 20)</code></dt>
<dd><a name="1065044"> </a>A write operation exceeded the bounds of the record. </dd>

</dl>

<h2 class="haH2">
  <a name="995305"> </a>Data Manager Functions and Macros <a href="#992934"><span class="nav">^TOP^</span></a>
</h2>


<h3 class="hbH3">
  <a name="995341"> </a>DmArchiveRecord Function <a href="#992934"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="1065056"> </a>Purpose 
</h4>

<p><a name="1065057"> </a>Mark a record as archived by leaving the record's chunk intact and setting the delete bit for the next HotSync operation.</p>
<h4>
  <a name="1065059"> </a>Declared In 
</h4>
<code>DataMgr.h<a name="1065060"> </a></code><h4>
  <a name="1065061"> </a>Prototype 
</h4>
<pre class="proto"><a name="1065062"></a>status_t DmArchiveRecord (
   DmOpenRef <code class="par">dbRef</code>,
   uint16_t <code class="par">index</code>
)
</pre>
<h4>
  <a name="1065063"> </a>Parameters 
</h4>

<dl>
<dt><a name="1065064"> </a><code>&rarr;  <i>dbRef</i></code></dt>
<dd><a name="1065065"> </a><code>DmOpenRef</code> to an open database.</dd>

<dt><a name="1065066"> </a><code>&rarr;  <i>index</i></code></dt>
<dd><a name="1065067"> </a>Which record to archive.</dd>

</dl>
<h4>
  <a name="1065068"> </a>Returns 
</h4>

<p><a name="1065069"> </a>Returns <code>errNone</code> if no error, or one of the following if an error occurs: </p>

<dl>
<dt><a name="1065070"> </a><code>dmErrReadOnly</code></dt>
<dd><a name="1065071"> </a>You've attempted to write to or modify a database that is open in read-only mode.</dd>

<dt><a name="1065072"> </a><code>dmErrIndexOutOfRange</code></dt>
<dd><a name="1065073"> </a>The specified index is out of range.</dd>

<dt><a name="1065074"> </a><code>dmErrRecordArchived</code></dt>
<dd><a name="1065075"> </a>The function requires that the record not be archived, but it is.</dd>

<dt><a name="1065076"> </a><code>dmErrRecordDeleted</code></dt>
<dd><a name="1065077"> </a>The record has been deleted.</dd>

<dt><a name="1065078"> </a><code>memErrInvalidParam</code></dt>
<dd><a name="1065079"> </a>A memory error occurred.</dd>

</dl>

<p><a name="1065080"> </a>Some releases may display a fatal error message instead of returning the error code. </p>
<h4>
  <a name="1065081"> </a>Comments 
</h4>

<p><a name="1065082"> </a>When a record is archived, the deleted bit is set but the chunk is not freed and the record ID is preserved. This way, the next time the user synchronizes with the desktop system, the conduit can save the record data on the desktop before it permanently removes the record entry and data from the Palm Powered<sup>&#8482;</sup> device. </p>

<p><a name="1065083"> </a>Based on the assumption that a call to <code>DmArchiveRecord()</code> indicates that you are finished with the record and aren't going to refer to it again, this function sets the chunk's lock count to zero.</p>
<h4>
  <a name="1208092"> </a>See Also 
</h4>

<p><a name="1208102"> </a><a href="DataMgr.html#1004638"><code>DmRemoveRecord()</code></a>, <a href="DataMgr.html#997011"><code>DmDetachRecord()</code></a>, <a href="DataMgr.html#1001785"><code>DmNewRecord()</code></a>, <a href="DataMgr.html#996913"><code>DmDeleteRecord()</code></a></p>

<h3 class="hbH3">
  <a name="1208108"> </a>DmAttachRecord Function <a href="#992934"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="1065718"> </a>Purpose 
</h4>

<p><a name="1065719"> </a>Attach an existing chunk ID handle to a database as a record. </p>
<h4>
  <a name="1065720"> </a>Declared In 
</h4>
<code>DataMgr.h<a name="1065721"> </a></code><h4>
  <a name="1065722"> </a>Prototype 
</h4>
<pre class="proto"><a name="1065723"></a>status_t DmAttachRecord (
   DmOpenRef <code class="par">dbRef</code>,
   uint16_t <code class="par">*pIndex</code>,
   MemHandle <code class="par">hNewRecord</code>,
   MemHandle <code class="par">*hReplacedRecord</code>
)
</pre>
<h4>
  <a name="1065724"> </a>Parameters 
</h4>

<dl>
<dt><a name="1065725"> </a><code>&rarr;  <i>dbRef</i></code></dt>
<dd><a name="1065726"> </a><code>DmOpenRef</code> to an open database.</dd>

<dt><a name="1065727"> </a><code>&harr;  <i>pIndex</i></code></dt>
<dd><a name="1065728"> </a>Pointer to the index where the new record should be placed. Specify the value <code>dmMaxRecordIndex</code> to add the record to the end of the database. </dd>

<dt><a name="1065730"> </a><code>&rarr;  <i>hNewRecord</i></code></dt>
<dd><a name="1065731"> </a>Handle of the new record.</dd>

<dt><a name="1065732"> </a><code>&harr;  <i>hReplacedRecord</i></code></dt>
<dd><a name="1065733"> </a>If non-<code>NULL</code> upon entry, indicates that the record at <code>*</code><code class="par">pIndex</code> should be replaced. Upon return, contains the handle to the replaced record.</dd>

</dl>
<h4>
  <a name="1065734"> </a>Returns 
</h4>

<p><a name="1065735"> </a>Returns <code>errNone</code> if no error, or one of the following if an error occurs: </p>

<dl>
<dt><a name="1065736"> </a><code>dmErrMemError</code></dt>
<dd><a name="1065737"> </a>A memory error occurred.</dd>

<dt><a name="1065738"> </a><code>memErrChunkLocked</code></dt>
<dd><a name="1065739"> </a>The associated memory chunk is locked. </dd>

<dt><a name="1065740"> </a><code>memErrInvalidParam</code></dt>
<dd><a name="1065741"> </a>A memory error occurred.</dd>

<dt><a name="1065742"> </a><code>memErrNotEnoughSpace</code></dt>
<dd><a name="1065743"> </a>A memory error occurred.</dd>

<dt><a name="1065744"> </a><code>dmErrReadOnly</code></dt>
<dd><a name="1065745"> </a>You've attempted to write to or modify a database that is open in read-only mode.</dd>

<dt><a name="1065746"> </a><code>dmErrNotRecordDB</code></dt>
<dd><a name="1065747"> </a>You've attempted to perform a record function on a resource database. </dd>

<dt><a name="1065748"> </a><code>dmErrRecordInWrongCard</code></dt>
<dd><a name="1065749"> </a>You've attempted to attach a record to a database when the record and database reside on different memory cards. </dd>

<dt><a name="1065750"> </a><code>dmErrIndexOutOfRange</code></dt>
<dd><a name="1065751"> </a>The specified index is out of range.</dd>

</dl>

<p><a name="1065752"> </a>Some releases may display a fatal error message instead of returning some of these error codes. </p>
<h4>
  <a name="1065753"> </a>Comments 
</h4>

<p><a name="1065754"> </a>Given the handle of an existing chunk, this function makes that chunk a new record in a database and sets the dirty bit. The parameter <code class="par">pIndex</code> points to an index variable. If <code class="par">hReplacedRecord</code> is <code>NULL</code>, the new record is inserted at index *<code class="par">pIndex</code> and all record indices that follow are shifted down. If *<code class="par">pIndex</code> is greater than the number of records currently in the database, the new record <code class="par">hNewRecord</code> is appended to the end and its index is returned in *<code class="par">pIndex</code>. If <code class="par">hReplacedRecord</code> is not <code>NULL</code>, the new record replaces an existing record at index *<code class="par">pIndex</code> and the handle of the old record is returned in *<code class="par">hReplacedRecord</code> so that the application can free it or attach it to another database.</p>

<p><a name="1065756"> </a>This function is useful for cutting and pasting between databases.</p>
<h4>
  <a name="1065757"> </a>See Also 
</h4>

<p><a name="1065767"> </a><a href="DataMgr.html#1004638"><code>DmRemoveRecord()</code></a>, <a href="DataMgr.html#997011"><code>DmDetachRecord()</code></a>, <a href="DataMgr.html#1001785"><code>DmNewRecord()</code></a>, <a href="DataMgr.html#996913"><code>DmDeleteRecord()</code></a></p>

<h3 class="hbH3">
  <a name="995445"> </a>DmAttachResource Function <a href="#992934"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="1066388"> </a>Purpose 
</h4>

<p><a name="1066389"> </a>Attach an existing chunk ID to a resource database as a new resource.</p>
<h4>
  <a name="1066390"> </a>Declared In 
</h4>
<code>DataMgr.h<a name="1066391"> </a></code><h4>
  <a name="1066392"> </a>Prototype 
</h4>
<pre class="proto"><a name="1066393"></a>status_t DmAttachResource (
   DmOpenRef <code class="par">dbRef</code>,
   MemHandle <code class="par">hNewRes</code>,
   DmResourceType <code class="par">resType</code>,
   DmResourceID <code class="par">resID</code>
)
</pre>
<h4>
  <a name="1066394"> </a>Parameters 
</h4>

<dl>
<dt><a name="1066395"> </a><code>&rarr;  <i>dbRef</i></code></dt>
<dd><a name="1066396"> </a><code>DmOpenRef</code> to an open database.</dd>

<dt><a name="1066397"> </a><code>&rarr;  <i>hNewRes</i></code></dt>
<dd><a name="1066398"> </a>Handle of new resource's data.</dd>

<dt><a name="1066399"> </a><code>&rarr;  <i>resType</i></code></dt>
<dd><a name="1066400"> </a>Type of the new resource.</dd>

<dt><a name="1066401"> </a><code>&rarr;  <i>resID</i></code></dt>
<dd><a name="1066402"> </a>ID of the new resource.</dd>

</dl>
<h4>
  <a name="1066403"> </a>Returns 
</h4>

<p><a name="1066404"> </a>Returns <code>errNone</code> if no error, or one of the following if an error occurs: </p>

<dl>
<dt><a name="1066405"> </a><code>dmErrMemError</code></dt>
<dd><a name="1066406"> </a>A memory error occurred.</dd>

<dt><a name="1066407"> </a><code>memErrChunkLocked</code></dt>
<dd><a name="1066408"> </a>The associated memory chunk is locked. </dd>

<dt><a name="1066409"> </a><code>memErrInvalidParam</code></dt>
<dd><a name="1066410"> </a>A memory error occurred.</dd>

<dt><a name="1066411"> </a><code>memErrNotEnoughSpace</code></dt>
<dd><a name="1066412"> </a>A memory error occurred.</dd>

<dt><a name="1066413"> </a><code>dmErrReadOnly</code></dt>
<dd><a name="1066414"> </a>You've attempted to write to or modify a database that is open in read-only mode.</dd>

<dt><a name="1066415"> </a><code>dmErrRecordInWrongCard</code></dt>
<dd><a name="1066416"> </a>You've attempted to attach a record to a database when the record and database reside on different memory cards. </dd>

</dl>

<p><a name="1066417"> </a>Some releases may display a fatal error message instead of returning some of these error codes. All releases may display a fatal error message if the database is not a resource database. </p>
<h4>
  <a name="1066418"> </a>Comments 
</h4>

<p><a name="1066419"> </a>Given the handle of an existing chunk with resource data in it, this function makes that chunk a new resource in a resource database. The new resource will have the given type and ID. </p>
<h4>
  <a name="1066420"> </a>See Also 
</h4>

<p><a name="1066427"> </a><a href="DataMgr.html#997061"><code>DmDetachResource()</code></a>, <a href="DataMgr.html#1004684"><code>DmRemoveResource()</code></a>, <a href="DataMgr.html#1001715"><code>DmNewHandle()</code></a>, <a href="DataMgr.html#1001870"><code>DmNewResource()</code></a></p>

<h3 class="hbH3">
  <a name="995503"> </a>DmBackupFinalize Function <a href="#992934"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="1067026"> </a>Purpose 
</h4>

<p><a name="1067027"> </a>Complete or abort an on-going database backup operation.</p>
<h4>
  <a name="1067028"> </a>Declared In 
</h4>
<code>DataMgr.h<a name="1067029"> </a></code><h4>
  <a name="1067030"> </a>Prototype 
</h4>
<pre class="proto"><a name="1067031"></a>status_t DmBackupFinalize (
   DmBackupRestoreStatePtr <code class="par">pState</code>,
   Boolean <code class="par">fAbort</code>
)
</pre>
<h4>
  <a name="1067032"> </a>Parameters 
</h4>

<dl>
<dt><a name="1067033"> </a><code>&rarr;  <i>pState</i></code></dt>
<dd><a name="1067037"> </a>Pointer to a <a href="DataMgr.html#993225"><code>DmBackupRestoreStateType</code></a> structure allocated by the caller and initialized with <a href="DataMgr.html#995549"><code>DmBackupInitialize()</code></a>.</dd>

<dt><a name="1067041"> </a><code>&rarr;  <i>fAbort</i></code></dt>
<dd><a name="1067042"> </a>Set to <code>true</code> to abort an on-going backup operation, or <code>false</code> to clean up after a successful backup.</dd>

</dl>
<h4>
  <a name="1067043"> </a>Returns 
</h4>

<p><a name="1067044"> </a>Returns <code>errNone</code> if the database image was successfully created, <code>dmErrOperationAborted</code> if the backup operation was cancelled, or one of the following errors otherwise:</p>

<dl>
<dt><a name="1067045"> </a><code>dmErrInvalidParam</code></dt>
<dd><a name="1067046"> </a>One of the parameters is invalid or corrupt.</dd>

<dt><a name="1067047"> </a><code>dmErrMemError</code></dt>
<dd><a name="1067048"> </a>A memory error occurred which prevented the backup operation from completing.</dd>

</dl>
<h4>
  <a name="1067049"> </a>Comments 
</h4>

<p><a name="1067050"> </a>This function allows the Data Manager to perform a final clean up of the internal structures it allocated for the operation. Applications should always call this function after having started a backup operation, whether or not the backup completed successfully. See <a href="DataMgr.html#995634"><code>DmBackupUpdate()</code></a> for sample code illustrating this function's use.</p>

<p><a name="1138193"> </a>The backup operation can be used with schema, extended, or classic databases.</p>
<h4>
  <a name="1067054"> </a>See Also 
</h4>

<p><a name="1067061"> </a><a href="DataMgr.html#995549"><code>DmBackupInitialize()</code></a>, <a href="DataMgr.html#1005674"><code>DmRestoreFinalize()</code></a></p>

<h3 class="hbH3">
  <a name="995549"> </a>DmBackupInitialize Function <a href="#992934"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="1067181"> </a>Purpose 
</h4>

<p><a name="1067182"> </a>Initialize the Data Manager prior to starting a backup operation on the specified database.</p>
<h4>
  <a name="1067183"> </a>Declared In 
</h4>
<code>DataMgr.h<a name="1067184"> </a></code><h4>
  <a name="1067185"> </a>Prototype 
</h4>
<pre class="proto"><a name="1067186"></a>status_t DmBackupInitialize (
   DmBackupRestoreStatePtr <code class="par">pState</code>,
   DatabaseID <code class="par">dbID</code>
)
</pre>
<h4>
  <a name="1067187"> </a>Parameters 
</h4>

<dl>
<dt><a name="1067188"> </a><code>&harr;  <i>pState</i></code></dt>
<dd><a name="1067192"> </a>Pointer to a <a href="DataMgr.html#993225"><code>DmBackupRestoreStateType</code></a> structure allocated by the caller.</dd>

<dt><a name="1067193"> </a><code>&rarr;  <i>dbID</i></code></dt>
<dd><a name="1067194"> </a>Database ID of the database to be backed up.</dd>

</dl>
<h4>
  <a name="1067195"> </a>Returns 
</h4>

<p><a name="1067196"> </a>Returns <code>errNone</code> if the structure was successfully initialized, or one of the following if an error occurred:</p>

<dl>
<dt><a name="1067197"> </a><code>dmErrCantFind</code></dt>
<dd><a name="1067198"> </a>The specified database doesn't exist.</dd>

<dt><a name="1067199"> </a><code>dmErrDatabaseOpen</code></dt>
<dd><a name="1067200"> </a>The function cannot be performed on an open database, and the database is open. </dd>

<dt><a name="1067201"> </a><code>dmErrAccessDenied</code></dt>
<dd><a name="1067202"> </a>The caller was not authorized to perform a backup operation for the specified database. This can be returned if the specified database is a secure schema database.</dd>

<dt><a name="1067203"> </a><code>dmErrInvalidParam</code></dt>
<dd><a name="1067204"> </a>One of the parameters is invalid.</dd>

<dt><a name="1067205"> </a><code>dmErrMemError</code></dt>
<dd><a name="1067206"> </a>A memory error occurred.</dd>

</dl>
<h4>
  <a name="1067207"> </a>Comments 
</h4>

<p><a name="1067208"> </a>Use <code>DmBackupInitialize()</code> to start a database backup operation. See <a href="DataMgr.html#995634"><code>DmBackupUpdate()</code></a> for sample code illustrating this function's use.</p>

<p><a name="1138171"> </a>The backup operation can be used with schema, extended, or classic databases.</p>

<div><hr>
  <a name="1185740"> </a> <b>IMPORTANT: </b> When called from the main application thread, this function may block. While blocked, the application will not receive events and won't redraw its windows. As well, deferred sublaunches and notifications won't execute while the main application thread is blocked.
<hr>
</div>
<h4>
  <a name="1067212"> </a>See Also 
</h4>

<p><a name="1067219"> </a><a href="DataMgr.html#995503"><code>DmBackupFinalize()</code></a>, <a href="DataMgr.html#1005732"><code>DmRestoreInitialize()</code></a></p>

<h3 class="hbH3">
  <a name="995634"> </a>DmBackupUpdate Function <a href="#992934"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="1067810"> </a>Purpose 
</h4>

<p><a name="1067811"> </a>Stream a database into its corresponding image within the specified buffer.</p>
<h4>
  <a name="1067812"> </a>Declared In 
</h4>
<code>DataMgr.h<a name="1067813"> </a></code><h4>
  <a name="1067814"> </a>Prototype 
</h4>
<pre class="proto"><a name="1067815"></a>status_t DmBackupUpdate (
   DmBackupRestoreStatePtr <code class="par">pState</code>,
   MemPtr <code class="par">pBuffer</code>,
   uint32_t <code class="par">*pSize</code>
)
</pre>
<h4>
  <a name="1067816"> </a>Parameters 
</h4>

<dl>
<dt><a name="1067817"> </a><code>&rarr;  <i>pState</i></code></dt>
<dd><a name="1067821"> </a>Pointer to a <a href="DataMgr.html#993225"><code>DmBackupRestoreStateType</code></a> structure allocated by the caller and initialized with <a href="DataMgr.html#995549"><code>DmBackupInitialize()</code></a>.</dd>

<dt><a name="1067825"> </a><code>&rarr;  <i>pBuffer</i></code></dt>
<dd><a name="1067826"> </a>Pointer to a buffer to hold the backed-up database image.</dd>

<dt><a name="1067827"> </a><code>&harr;  <i>pSize</i></code></dt>
<dd><a name="1067828"> </a>Before calling, set this variable to the size of the <code class="par">pBuffer</code> data buffer. Upon return, it contains the actual number of bytes written to <code class="par">pBuffer</code>.</dd>

</dl>
<h4>
  <a name="1067829"> </a>Returns 
</h4>

<p><a name="1067830"> </a>Returns <code>errNone</code> if the operation was successful, <code>dmErrNoMoreData</code> if the backup operation is complete, or one of the following if an error occurred:</p>

<dl>
<dt><a name="1067831"> </a><code>dmErrInvalidParam</code></dt>
<dd><a name="1067832"> </a>One of the parameters is invalid or corrupt.</dd>

<dt><a name="1067833"> </a><code>dmErrMemError</code></dt>
<dd><a name="1067834"> </a>A memory error occurred which prevented the backup operation from completing.</dd>

</dl>
<h4>
  <a name="1067835"> </a>Comments 
</h4>

<p><a name="1067839"> </a>Use <code>DmBackupUpdate()</code>, along with <a href="DataMgr.html#995549"><code>DmBackupInitialize()</code></a> and <a href="DataMgr.html#995503"><code>DmBackupFinalize()</code></a>, to get the serial image of a database.</p>

<p><a name="1067843"> </a>You may need to call <code>DmBackupUpdate()</code> several times in order to get the complete image of the specified database. Call <code>DmBackupUpdate()</code> as many times as required and as long as it returns <code>errNone</code>, until it finally returns <code>dmErrNoMoreData</code>.</p>

<p><a name="1067844"> </a>When <code>DmBackupUpdate()</code> returns an error code other than <code>errNone</code> or <code>dmErrNoMoreData</code>, the operation has been aborted due to a fatal error. You must still call <code>DmBackupFinalize()</code> in order to let the Data Manager perform its final clean up of the internal structures it allocated for the operation.</p>

<p><a name="1138181"> </a>The backup operation can be used with schema, extended, or classic databases.</p>
<h4>
  <a name="1067845"> </a>Example 
</h4>

<p><a name="1067846"> </a>The following code shows how to use the <code>DmBackup...()</code> functions to send an image of a database to a fictitious serial channel.</p>

<div class="CodeRule"><hr></div><pre class="CodeBlock">
status_t error;<a name="1067847"> </a>
DmBackupRestoreStateType backupState;<a name="1067848"> </a>
char buffer[BUFFER_SIZE];<a name="1067849"> </a>
uint32_t size;<a name="1067850"> </a>
Boolean fAbort;<a name="1067851"> </a>
Boolean fDone;<a name="1067852"> </a>
<a name="1067853"> </a>
error = DmBackupInitialize(&amp;backupState, dbID);<a name="1067854"> </a>
<a name="1067855"> </a>
if (error == errNone){<a name="1067856"> </a>
   do {<a name="1067857"> </a>
      // Reset the size value with the buffer size for each<a name="1067858"> </a>
      // loop as this variable gets updated with the actual<a name="1067859"> </a>
      // number of bytes written to the buffer after each<a name="1067860"> </a>
      // call to DmBackupDatabase.<a name="1067861"> </a>
      size = sizeof(buffer);<a name="1067862"> </a>
<a name="1067863"> </a>
      error = DmBackupUpdate(&amp;backupState, &amp;buffer, &amp;size);<a name="1067864"> </a>
<a name="1067865"> </a>
      fDone = (error == dmErrNoMoreData);<a name="1067866"> </a>
<a name="1067867"> </a>
      if ((error == errNone) || fDone){<a name="1067868"> </a>
         // Stream the database image data chunk we got back<a name="1067869"> </a>
         // out to some I/O channel...<a name="1067870"> </a>
         error = SendDatabaseImageData(&amp;buffer, size);<a name="1067871"> </a>
      }<a name="1067872"> </a>
<a name="1067873"> </a>
      // Abort the operation if we got back an error or if<a name="1067874"> </a>
      // the user decided to cancel the operation...<a name="1067875"> </a>
      fAbort = (error != errNone) || DidUserCancel();<a name="1067876"> </a>
<a name="1067877"> </a>
   } while(!fDone &amp;&amp; !fAbort);<a name="1067878"> </a>
<a name="1067879"> </a>
<a name="1067880"> </a>
   // Always call DmBackupFinalize to complete the backup<a name="1067881"> </a>
   // operation, whether or not it completed successfully<a name="1067882"> </a>
   error = DmBackupFinalize(&amp;backupState, fAbort);<a name="1067883"> </a>
}<a name="1067884"> </a>
<a name="1067885"> </a>
if (error == errNone){<a name="1067886"> </a>
   // The backup operation completed successfully...<a name="1067887"> </a>
} else {<a name="1067888"> </a>
   if (error == dmErrOperationAborted){<a name="1067889"> </a>
      // The user aborted the operation<a name="1067890"> </a>
   } else {<a name="1067891"> </a>
      // Some other fatal error occurred...<a name="1067892"> </a>
   }<a name="1067893"> </a>
}<a name="1067894"> </a>
</pre><div class="CodeRule"><hr></div>

<h4>
  <a name="1067895"> </a>See Also 
</h4>

<p><a name="1067899"> </a><a href="DataMgr.html#1005778"><code>DmRestoreUpdate()</code></a></p>

<h3 class="hbH3">
  <a name="995692"> </a>DmCloseDatabase Function <a href="#992934"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="1068537"> </a>Purpose 
</h4>

<p><a name="1068539"> </a>Close a database.</p>
<h4>
  <a name="1068540"> </a>Declared In 
</h4>
<code>DataMgr.h<a name="1068541"> </a></code><h4>
  <a name="1068542"> </a>Prototype 
</h4>
<pre class="proto"><a name="1068543"></a>status_t DmCloseDatabase (
   DmOpenRef <code class="par">dbRef</code>
)
</pre>
<h4>
  <a name="1068544"> </a>Parameters 
</h4>

<dl>
<dt><a name="1068545"> </a><code>&rarr;  <i>dbRef</i></code></dt>
<dd><a name="1068546"> </a><code>DmOpenRef</code> to an open database.</dd>

</dl>
<h4>
  <a name="1068547"> </a>Returns 
</h4>

<p><a name="1068548"> </a>Returns <code>errNone</code> if no error, or <code>dmErrInvalidParam</code> if an error occurs. Some releases may display a fatal error message instead of returning the error code. </p>
<h4>
  <a name="1068549"> </a>Comments 
</h4>

<p><a name="1068550"> </a>This function doesn't unlock any records that were left locked. Records and resources should not be left locked. If a record or resource is left locked, you should not use its reference because the record can disappear during a HotSync operation or if the database is deleted by the user. To prevent the database from being deleted, you can use <a href="DataMgr.html#1006613"><code>DmSetDatabaseProtection()</code></a> before closing. </p>

<p><a name="1068555"> </a>If there is an overlay associated with the database passed in, <code>DmCloseDatabase()</code> closes the overlay as well. </p>

<p><a name="1068557"> </a>If the database has the recyclable bit set (<code>dmHdrAttrRecyclable</code>), <code>DmCloseDatabase()</code> calls <a href="DataMgr.html#996663"><code>DmDeleteDatabase()</code></a> to delete it. </p>

<p><a name="1068562"> </a><code>DmCloseDatabase()</code> updates the database's modification date. </p>
<h4>
  <a name="1068563"> </a>See Also 
</h4>

<p><a name="1068570"> </a><a href="DataMgr.html#1002512"><code>DmOpenDatabase()</code></a>, <a href="DataMgr.html#996663"><code>DmDeleteDatabase()</code></a><!-PS02-><span style="color: #0000ff;  font-style: normal; font-weight: normal; text-decoration: underline; text-transform: none; vertical-align: baseline">, </span><a href="DataMgr.html#1002766"><code>DmOpenDatabaseByTypeCreator()</code></a> </p>

<h3 class="hbH3">
  <a name="995734"> </a>DmCloseIteratorByTypeCreator Function <a href="#992934"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="995743"> </a>Purpose 
</h4>

<p><a name="995746"> </a>Indicate that a particular iteration loop is complete.</p>
<h4>
  <a name="995748"> </a>Declared In 
</h4>
<code>DataMgr.h<a name="995751"> </a></code><h4>
  <a name="995753"> </a>Prototype 
</h4>
<pre class="proto"><a name="995756"></a>status_t DmCloseIteratorByTypeCreator (
   DmSearchStatePtr <code class="par">stateInfoP</code>
)
</pre>
<h4>
  <a name="995758"> </a>Parameters 
</h4>

<dl>
<dt><a name="995761"> </a><code>&rarr;  <i>stateInfoP</i></code></dt>
<dd><a name="995763"> </a>Pointer to the <a href="DataMgr.html#993964"><code>DmSearchStateType</code></a> structure supplied to <a href="DataMgr.html#1003442"><code>DmOpenIteratorByTypeCreator()</code></a> and <a href="DataMgr.html#999000"><code>DmGetNextDatabaseByTypeCreator()</code></a>.</dd>

</dl>
<h4>
  <a name="995765"> </a>Returns 
</h4>

<p><a name="995768"> </a>Returns <code>errNone</code>.</p>
<h4>
  <a name="995770"> </a>Comments 
</h4>

<p><a name="995773"> </a>See the comments under <a href="DataMgr.html#999000"><code>DmGetNextDatabaseByTypeCreator()</code></a> for an example of how this function is used.</p>
<h4>
  <a name="995775"> </a>See Also 
</h4>

<p><a name="995778"> </a><a href="DataMgr.html#999000"><code>DmGetNextDatabaseByTypeCreator()</code></a>, <a href="DataMgr.html#1003442"><code>DmOpenIteratorByTypeCreator()</code></a></p>

<h3 class="hbH3">
  <a name="995780"> </a>DmCreateDatabase Function <a href="#992934"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="1069154"> </a>Purpose 
</h4>

<p><a name="1069156"> </a>Create a new extended database with the given name, creator, and type.</p>
<h4>
  <a name="1069157"> </a>Declared In 
</h4>
<code>DataMgr.h<a name="1069158"> </a></code><h4>
  <a name="1069159"> </a>Prototype 
</h4>
<pre class="proto"><a name="1069160"></a>status_t DmCreateDatabase (
   const char <code class="par">*nameP</code>,
   uint32_t <code class="par">creator</code>,
   uint32_t <code class="par">type</code>,
   Boolean <code class="par">resDB</code>
)
</pre>
<h4>
  <a name="1069161"> </a>Parameters 
</h4>

<dl>
<dt><a name="1069162"> </a><code>&rarr;  <i>nameP</i></code></dt>
<dd><a name="1069163"> </a>Name of new database, up to 32 ASCII bytes long, including the null terminator (as specified by <code>dmDBNameLength</code>). Database names must use only 7-bit ASCII characters (0x20 through 0x7E). </dd>

<dt><a name="1069165"> </a><code>&rarr;  <i>creator</i></code></dt>
<dd><a name="1069166"> </a>Creator of the database. </dd>

<dt><a name="1069167"> </a><code>&rarr;  <i>type</i></code></dt>
<dd><a name="1069168"> </a>Type of the database.</dd>

<dt><a name="1069169"> </a><code>&rarr;  <i>resDB</i></code></dt>
<dd><a name="1069170"> </a>If <code>true</code>, create a resource database. If <code>false</code>, create a record database.</dd>

</dl>
<h4>
  <a name="1069171"> </a>Returns 
</h4>

<p><a name="1069172"> </a>Returns <code>errNone</code> if no error, or one of the following if an error occurs: </p>

<dl>
<dt><a name="1069173"> </a><code>dmErrInvalidDatabaseName</code></dt>
<dd><a name="1069174"> </a>The name you've specified for the database is invalid.</dd>

<dt><a name="1069175"> </a><code>dmErrAlreadyExists</code></dt>
<dd><a name="1069176"> </a>Another database with the same name already exists.</dd>

<dt><a name="1069177"> </a><code>memErrCardNotPresent</code></dt>
<dd><a name="1069178"> </a>The specified card can't be found.</dd>

<dt><a name="1069179"> </a><code>dmErrMemError</code></dt>
<dd><a name="1069180"> </a>A memory error occurred.</dd>

<dt><a name="1069181"> </a><code>memErrChunkLocked</code></dt>
<dd><a name="1069182"> </a>The associated memory chunk is locked. </dd>

<dt><a name="1069183"> </a><code>memErrInvalidParam</code></dt>
<dd><a name="1069184"> </a>A memory error occurred.</dd>

<dt><a name="1069185"> </a><code>memErrInvalidStoreHeader</code></dt>
<dd><a name="1069186"> </a>The specified card has no storage RAM.</dd>

<dt><a name="1069187"> </a><code>memErrNotEnoughSpace</code></dt>
<dd><a name="1069188"> </a>A memory error occurred.</dd>

<dt><a name="1069189"> </a><code>memErrRAMOnlyCard</code></dt>
<dd><a name="1069190"> </a>The specified card has no storage RAM.</dd>

</dl>

<p><a name="1069191"> </a>May display a fatal error message if the master database list cannot be found. </p>
<h4>
  <a name="1069192"> </a>Comments 
</h4>

<p><a name="1069193"> </a>If another database with the same name and creator already exists in RAM store, this function returns a <code>dmErrAlreadyExists</code> error. </p>

<p><a name="1069194"> </a>Once created, the database ID can be retrieved by calling <a href="DataMgr.html#1077521"><code>DmFindDatabase()</code></a>. The database can be opened using the database ID.</p>

<p><a name="1069199"> </a>After you create a database, you should call <a href="DataMgr.html#1006265"><code>DmSetDatabaseInfo()</code></a> to set the version number. Databases default to version 0 if the version isn't explicitly set.</p>

<div><hr>
  <a name="1128852"> </a> <b>IMPORTANT: </b> This function creates extended databases only. To create a classic database, use <a href="DataMgr.html#995926"><code>DmCreateDatabaseV50()</code></a>. To create a schema database, use <a href="SchemaDatabases.html#994949"><code>DbCreateDatabase()</code></a>.
<hr>
</div>
<h4>
  <a name="1069203"> </a>See Also 
</h4>

<p><a name="1069210"> </a><a href="DataMgr.html#995834"><code>DmCreateDatabaseFromImage()</code></a>, <a href="DataMgr.html#1002512"><code>DmOpenDatabase()</code></a>, <a href="DataMgr.html#996663"><code>DmDeleteDatabase()</code></a></p>

<h3 class="hbH3">
  <a name="995834"> </a>DmCreateDatabaseFromImage Function <a href="#992934"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="1069839"> </a>Purpose 
</h4>

<p><a name="1069840"> </a>Create an entire database from a single resource that contains an image of the database.</p>
<h4>
  <a name="1069841"> </a>Declared In 
</h4>
<code>DataMgr.h<a name="1069842"> </a></code><h4>
  <a name="995853"> </a>Prototype 
</h4>
<pre class="proto"><a name="995856"></a>status_t DmCreateDatabaseFromImage (
   MemPtr <code class="par">pImage</code>,
   DatabaseID <code class="par">*pDbID</code>
)
</pre>
<h4>
  <a name="995858"> </a>Parameters 
</h4>

<dl>
<dt><a name="995861"> </a><code>&rarr;  <i>pImage</i></code></dt>
<dd><a name="1069888"> </a>Pointer to locked resource containing database image.</dd>

<dt><a name="995865"> </a><code>&larr;  <i>pDbID</i></code></dt>
<dd><a name="1124013"> </a>Pointer to a variable that will hold the ID of the newly-created database, or <code>NULL</code> if the ID isn't needed.</dd>

</dl>
<h4>
  <a name="1069936"> </a>Returns 
</h4>

<p><a name="1123985"> </a>Returns <code>errNone</code> if the operation completed successfully, or one of the following otherwise:</p>

<dl>
<dt><a name="1123986"> </a><code>dmErrInvalidParam</code></dt>
<dd><a name="1123994"> </a><code class="par">pImage</code> is <code>NULL</code>.</dd>

<dt><a name="1124003"> </a><code>dmErrMemError</code></dt>
<dd><a name="1124044"> </a>A memory error occurred. Most likely there wasn't enough memory available to create the database.</dd>

<dt><a name="1124802"> </a><code>dmErrCorruptDatabase</code></dt>
<dd><a name="1124863"> </a>The format of the database image is unrecognized.</dd>

<dt><a name="1124948"> </a><code>dmErrAlreadyExists</code></dt>
<dd><a name="1124969"> </a>The database being created already exists on the device.</dd>

</dl>
<h4>
  <a name="1123987"> </a>Comments 
</h4>

<p><a name="1069939"> </a>An image is the same as a desktop file representation of a PRC or PDB file. This function creates either an extended or a classic database, or a non-secure schema database, depending upon the image stored in the resource. To perform a similar operation for a secure schema database, see <a href="SchemaDatabases.html#995299"><code>DbCreateSecureDatabaseFromImage()</code></a>.</p>

<p><a name="1069940"> </a>This function is intended for applications in the ROM to install default databases after a hard reset. RAM-based applications that want to install a default database should install a PDB file separately to save storage heap space.</p>
<h4>
  <a name="1069941"> </a>See Also 
</h4>

<p><a name="1069948"> </a><a href="DataMgr.html#995780"><code>DmCreateDatabase()</code></a>, <a href="DataMgr.html#1002512"><code>DmOpenDatabase()</code></a></p>

<h3 class="hbH3">
  <a name="995884"> </a>DmCreateDatabaseFromImageV50 Function <a href="#992934"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="995889"> </a>Purpose 
</h4>

<p><a name="1069952"> </a>Create an entire classic database from a single resource that contains an image of the database.</p>
<h4>
  <a name="995894"> </a>Declared In 
</h4>
<code>DataMgr.h<a name="995897"> </a></code><h4>
  <a name="995899"> </a>Prototype 
</h4>
<pre class="proto"><a name="995902"></a>status_t DmCreateDatabaseFromImageV50 (
   MemPtr <code class="par">pImage</code>
)
</pre>
<h4>
  <a name="995904"> </a>Parameters 
</h4>

<dl>
<dt><a name="995907"> </a><code>&rarr;  <i>pImage</i></code></dt>
<dd><a name="1069997"> </a>Pointer to locked resource containing database image.</dd>

</dl>
<h4>
  <a name="1070013"> </a>Returns 
</h4>

<p><a name="1125005"> </a>Returns <code>errNone</code> if the operation completed successfully, or one of the following otherwise:</p>

<dl>
<dt><a name="1125006"> </a><code>dmErrInvalidParam</code></dt>
<dd><a name="1125007"> </a><code class="par">pImage</code> is <code>NULL</code>.</dd>

<dt><a name="1125008"> </a><code>dmErrMemError</code></dt>
<dd><a name="1125009"> </a>A memory error occurred. Most likely there wasn't enough memory available to create the database.</dd>

<dt><a name="1125010"> </a><code>dmErrCorruptDatabase</code></dt>
<dd><a name="1125011"> </a>The format of the database image is unrecognized.</dd>

<dt><a name="1125012"> </a><code>dmErrAlreadyExists</code></dt>
<dd><a name="1125013"> </a>The database being created already exists on the device.</dd>

</dl>
<h4>
  <a name="1070015"> </a>Comments 
</h4>

<p><a name="1070016"> </a>An image is the same as a desktop file representation of a PRC or PDB file.</p>

<p><a name="1070017"> </a>This function is intended for applications in the ROM to install default databases after a hard reset. RAM-based applications that want to install a default database should install a PDB file separately to save storage heap space.</p>
<h4>
  <a name="1127135"> </a>Compatibility 
</h4>

<p><a name="1128381"> </a>This function is provided for compatibility purposes. Note that it works only with classic databases&#8212;the only type of database supported in PACE and by previous versions of Palm OS. Native Palm OS Cobalt applications will likely want to use <a href="DataMgr.html#995834"><code>DmCreateDatabaseFromImage()</code></a> instead.</p>
<h4>
  <a name="1070018"> </a>See Also 
</h4>

<p><a name="1070025"> </a><a href="DataMgr.html#995834"><code>DmCreateDatabaseFromImage()</code></a></p>

<h3 class="hbH3">
  <a name="995926"> </a>DmCreateDatabaseV50 Function <a href="#992934"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="1070138"> </a>Purpose 
</h4>

<p><a name="1070139"> </a>Create a new classic database on the specified card with the given name, creator, and type.</p>
<h4>
  <a name="1070141"> </a>Declared In 
</h4>
<code>DataMgr.h<a name="1070142"> </a></code><h4>
  <a name="1070143"> </a>Prototype 
</h4>
<pre class="proto"><a name="1070144"></a>status_t DmCreateDatabaseV50 (
   uint16_t <code class="par">cardNo</code>,
   const char <code class="par">*nameP</code>,
   uint32_t <code class="par">creator</code>,
   uint32_t <code class="par">type</code>,
   Boolean <code class="par">resDB</code>
)
</pre>
<h4>
  <a name="1070145"> </a>Parameters 
</h4>

<dl>
<dt><a name="1070146"> </a><code>&rarr;  <i>cardNo</i></code></dt>
<dd><a name="1070147"> </a>The number of the card on which to create the database. This value should always be zero.</dd>

<dt><a name="1070148"> </a><code>&rarr;  <i>nameP</i></code></dt>
<dd><a name="1070149"> </a>Name of new database, up to 32 ASCII bytes long, including the null terminator (as specified by <code>dmDBNameLength</code>). Database names must use only 7-bit ASCII characters (0x20 through 0x7E). </dd>

<dt><a name="1070151"> </a><code>&rarr;  <i>creator</i></code></dt>
<dd><a name="1070152"> </a>Creator of the database. </dd>

<dt><a name="1070153"> </a><code>&rarr;  <i>type</i></code></dt>
<dd><a name="1070154"> </a>Type of the database.</dd>

<dt><a name="1070155"> </a><code>&rarr;  <i>resDB</i></code></dt>
<dd><a name="1070156"> </a>If <code>true</code>, create a resource database.</dd>

</dl>
<h4>
  <a name="1070157"> </a>Returns 
</h4>

<p><a name="1070158"> </a>Returns <code>errNone</code> if no error, or one of the following if an error occurs: </p>

<dl>
<dt><a name="1070159"> </a><code>dmErrInvalidDatabaseName</code></dt>
<dd><a name="1070160"> </a>The name you've specified for the database is invalid.</dd>

<dt><a name="1070161"> </a><code>dmErrAlreadyExists</code></dt>
<dd><a name="1070162"> </a>Another database with the same name already exists.</dd>

<dt><a name="1070163"> </a><code>memErrCardNotPresent</code></dt>
<dd><a name="1070164"> </a>The specified card can't be found.</dd>

<dt><a name="1070165"> </a><code>dmErrMemError</code></dt>
<dd><a name="1070166"> </a>A memory error occurred.</dd>

<dt><a name="1070167"> </a><code>memErrChunkLocked</code></dt>
<dd><a name="1070168"> </a>The associated memory chunk is locked. </dd>

<dt><a name="1070169"> </a><code>memErrInvalidParam</code></dt>
<dd><a name="1070170"> </a>A memory error occurred.</dd>

<dt><a name="1070171"> </a><code>memErrInvalidStoreHeader</code></dt>
<dd><a name="1070172"> </a>The specified card has no storage RAM.</dd>

<dt><a name="1070173"> </a><code>memErrNotEnoughSpace</code></dt>
<dd><a name="1070174"> </a>A memory error occurred.</dd>

<dt><a name="1070175"> </a><code>memErrRAMOnlyCard</code></dt>
<dd><a name="1070176"> </a>The specified card has no storage RAM.</dd>

</dl>

<p><a name="1070177"> </a>May display a fatal error message if the master database list cannot be found. </p>
<h4>
  <a name="1070178"> </a>Comments 
</h4>

<p><a name="1070179"> </a>Call this function to create a new database on a specific card. If another classic database with the same name already exists in RAM store, this function returns a <code>dmErrAlreadyExists</code> error code. Once created, the database ID can be retrieved by calling <a href="DataMgr.html#1077521"><code>DmFindDatabase()</code></a>. The database can be opened using the database ID. To create a resource database instead of a record-based database, set the <code class="par">resDB</code> parameter to <code>true</code>.</p>

<p><a name="1070184"> </a>After you create a database, it's recommended that you call <a href="DataMgr.html#1006265"><code>DmSetDatabaseInfo()</code></a> to set the version number. Databases default to version 0 if the version isn't explicitly set.</p>
<h4>
  <a name="1128199"> </a>Compatibility 
</h4>

<p><a name="1128216"> </a>This function is provided for compatibility purposes. Note that it only works with classic databases&#8212;the only type of database supported in PACE and by previous versions of Palm OS. Native Palm OS Cobalt applications may want to use <a href="DataMgr.html#995780"><code>DmCreateDatabase()</code></a> instead.</p>
<h4>
  <a name="1070188"> </a>See Also 
</h4>

<p><a name="1070195"> </a><a href="DataMgr.html#995834"><code>DmCreateDatabaseFromImage()</code></a>, <a href="DataMgr.html#1002512"><code>DmOpenDatabase()</code></a>, <a href="DataMgr.html#996663"><code>DmDeleteDatabase()</code></a></p>

<h3 class="hbH3">
  <a name="996192"> </a>DmDatabaseInfo Function <a href="#992934"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="1070784"> </a>Purpose 
</h4>

<p><a name="1070785"> </a>Retrieve information about a non-schema database.</p>
<h4>
  <a name="1070786"> </a>Declared In 
</h4>
<code>DataMgr.h<a name="1070787"> </a></code><h4>
  <a name="1070788"> </a>Prototype 
</h4>
<pre class="proto"><a name="1070789"></a>status_t DmDatabaseInfo (
   DatabaseID <code class="par">dbID</code>,
   DmDatabaseInfoPtr <code class="par">pDatabaseInfo</code>
)
</pre>
<h4>
  <a name="1070790"> </a>Parameters 
</h4>

<dl>
<dt><a name="1070791"> </a><code>&rarr;  <i>dbID</i></code></dt>
<dd><a name="1070792"> </a>Database ID of the database.</dd>

<dt><a name="1070793"> </a><code>&rarr;  <i>pDatabaseInfo</i></code></dt>
<dd><a name="1070797"> </a>Pointer to a <a href="DataMgr.html#993322"><code>DmDatabaseInfoType</code></a> structure that indicates where, or if, the database information is to be written.</dd>

</dl>
<h4>
  <a name="1070798"> </a>Returns 
</h4>

<p><a name="1070799"> </a>Returns <code>errNone</code> if the database information was successfully retrieved, or <code>dmErrInvalidParam</code> if an error occurred.</p>
<h4>
  <a name="1070800"> </a>Comments 
</h4>

<p><a name="1070801"> </a>Initialize the fields of the <code class="par">pDatabaseInfo</code> structure to point to variables where this function will write the information. If you don't want to retrieve data corresponding to a given field, set that field to <code>NULL</code>.</p>
<h4>
  <a name="1070802"> </a>See Also 
</h4>

<p><a name="1070809"> </a><a href="DataMgr.html#996281"><code>DmDatabaseInfoV50()</code></a>, <a href="DataMgr.html#1006265"><code>DmSetDatabaseInfo()</code></a>, <a href="DataMgr.html#996477"><code>DmDatabaseSize()</code></a>, <a href="DataMgr.html#1002946"><code>DmOpenDatabaseInfoV50()</code></a>, <a href="DataMgr.html#1077521"><code>DmFindDatabase()</code></a>, <a href="DataMgr.html#999000"><code>DmGetNextDatabaseByTypeCreator()</code></a>, <a href="../System_Management/DateTime.html#997368"><code>TimSecondsToDateTime()</code></a> </p>

<h3 class="hbH3">
  <a name="996281"> </a>DmDatabaseInfoV50 Function <a href="#992934"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="1070854"> </a>Purpose 
</h4>

<p><a name="1070855"> </a>Retrieve information about a database.</p>
<h4>
  <a name="1070856"> </a>Declared In 
</h4>
<code>DataMgr.h<a name="1070857"> </a></code><h4>
  <a name="1070858"> </a>Prototype 
</h4>
<pre class="proto"><a name="1070859"></a>status_t DmDatabaseInfoV50 (
   uint16_t <code class="par">cardNo</code>,
   LocalID <code class="par">dbID</code>,
   char <code class="par">*nameP</code>,
   uint16_t <code class="par">*attributesP</code>,
   uint16_t <code class="par">*versionP</code>,
   uint32_t <code class="par">*crDateP</code>,
   uint32_t <code class="par">*modDateP</code>,
   uint32_t <code class="par">*bckUpDateP</code>,
   uint32_t <code class="par">*modNumP</code>,
   LocalID <code class="par">*appInfoIDP</code>,
   LocalID <code class="par">*sortInfoIDP</code>,
   uint32_t <code class="par">*typeP</code>,
   uint32_t <code class="par">*creatorP</code>
)
</pre>
<h4>
  <a name="1070860"> </a>Parameters 
</h4>

<dl>
<dt><a name="1070861"> </a><code>&rarr;  <i>cardNo</i></code></dt>
<dd><a name="1070862"> </a>Number of the card the database resides on.</dd>

<dt><a name="1070863"> </a><code>&rarr;  <i>dbID</i></code></dt>
<dd><a name="1070864"> </a>Database ID of the database.</dd>

<dt><a name="1070865"> </a><code>&larr;  <i>nameP</i></code></dt>
<dd><a name="1070866"> </a>The database's name. Pass a pointer to 32-byte character array for this parameter, or <code>NULL</code> if you don't care about the name.</dd>

<dt><a name="1070867"> </a><code>&larr;  <i>attributesP</i></code></dt>
<dd><a name="1070870"> </a>The database's attribute flags. The section <a href="DataMgr.html#1049292">"Database Attributes"</a> lists constants you can use to query the values returned in this parameter. Pass <code>NULL</code> for this parameter if you don't want to retrieve it. </dd>

<dt><a name="1070872"> </a><code>&larr;  <i>versionP</i></code></dt>
<dd><a name="1070873"> </a>The application-specific version number. The default version number is 0. Pass <code>NULL</code> for this parameter if you don't want to retrieve it. </dd>

<dt><a name="1070874"> </a><code>&larr;  <i>crDateP</i></code></dt>
<dd><a name="1070875"> </a>The date the database was created, expressed as the number of seconds since the first instant of Jan. 1, 1904. Pass <code>NULL</code> for this parameter if you don't want to retrieve it. </dd>

<dt><a name="1070876"> </a><code>&larr;  <i>modDateP</i></code></dt>
<dd><a name="1070877"> </a>The date the database was last modified, expressed as the number of seconds since the first instant of Jan. 1, 1904. Pass <code>NULL</code> for this parameter if you don't want to retrieve it. </dd>

<dt><a name="1070878"> </a><code>&larr;  <i>bckUpDateP</i></code></dt>
<dd><a name="1070879"> </a>The date the database was backed up, expressed as the number of seconds since the first instant of Jan. 1, 1904. Pass <code>NULL</code> for this parameter if you don't want to retrieve it. </dd>

<dt><a name="1070880"> </a><code>&larr;  <i>modNumP</i></code></dt>
<dd><a name="1070881"> </a>The modification number, which is incremented every time a record in the database is added, modified, or deleted. Pass <code>NULL</code> for this parameter if you don't want to retrieve it. </dd>

<dt><a name="1070882"> </a><code>&larr;  <i>appInfoIDP</i></code></dt>
<dd><a name="1070883"> </a>The local ID of the application info block, or <code>NULL</code>. The application info block is an optional field that the database may use to store application-specific information about the database. Pass <code>NULL</code> for this parameter if you don't want to retrieve it. </dd>

<dt><a name="1070884"> </a><code>&larr;  <i>sortInfoIDP</i></code></dt>
<dd><a name="1070885"> </a>The local ID of the database's sort table. This is an optional field in the database header. Pass <code>NULL</code> for this parameter if you don't want to retrieve it. </dd>

<dt><a name="1070886"> </a><code>&larr;  <i>typeP</i></code></dt>
<dd><a name="1070887"> </a>The database's type, specified when it is created. Pass <code>NULL</code> for this parameter if you don't want to retrieve it.</dd>

<dt><a name="1070888"> </a><code>&larr;  <i>creatorP</i></code></dt>
<dd><a name="1070889"> </a>The database's creator, specified when it is created. Pass <code>NULL</code> for this parameter if you don't want to retrieve it. </dd>

</dl>
<h4>
  <a name="1070890"> </a>Returns 
</h4>

<p><a name="1070891"> </a>Returns <code>errNone</code> if no error, or <code>dmErrInvalidParam</code> if an error occurs.</p>
<h4>
  <a name="1070892"> </a>Comments 
</h4>

<p><a name="1070893"> </a>The modification date is updated only if a change has been made to the database opened with write access. (The update still occurs upon closing the database.) Changes that trigger an update include adding, deleting, archiving, rearranging, or resizing records, setting a record's dirty bit in <a href="DataMgr.html#1004479"><code>DmReleaseRecord()</code></a>, rearranging or deleting categories, or updating the database header fields using <a href="DataMgr.html#1006265"><code>DmSetDatabaseInfo()</code></a>. </p>
<h4>
  <a name="1128936"> </a>Compatibility 
</h4>

<p><a name="1128937"> </a>This function is provided for compatibility purposes only; Palm OS Cobalt applications will likely want to use <a href="DataMgr.html#996192"><code>DmDatabaseInfo()</code></a> instead.</p>
<h4>
  <a name="1070900"> </a>See Also 
</h4>

<p><a name="1070907"> </a><a href="DataMgr.html#996192"><code>DmDatabaseInfo()</code></a>, <a href="DataMgr.html#1006265"><code>DmSetDatabaseInfo()</code></a>, <a href="DataMgr.html#996477"><code>DmDatabaseSize()</code></a>, <a href="DataMgr.html#1002946"><code>DmOpenDatabaseInfoV50()</code></a>, <a href="DataMgr.html#1077521"><code>DmFindDatabase()</code></a>, <a href="DataMgr.html#999000"><code>DmGetNextDatabaseByTypeCreator()</code></a>, <a href="../System_Management/DateTime.html#997368"><code>TimSecondsToDateTime()</code></a> </p>

<h3 class="hbH3">
  <a name="996399"> </a>DmDatabaseProtectV50 Function <a href="#992934"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="1071473"> </a>Purpose 
</h4>

<p><a name="1071475"> </a>Increment or decrement a non-schema database's protection count. </p>
<h4>
  <a name="1071476"> </a>Declared In 
</h4>
<code>DataMgr.h<a name="1071477"> </a></code><h4>
  <a name="1071478"> </a>Prototype 
</h4>
<pre class="proto"><a name="1071479"></a>status_t DmDatabaseProtectV50 (
   uint16_t <code class="par">cardNo</code>,
   LocalID <code class="par">dbID</code>,
   Boolean <code class="par">protect</code>
)
</pre>
<h4>
  <a name="1071480"> </a>Parameters 
</h4>

<dl>
<dt><a name="1071481"> </a><code>&rarr;  <i>cardNo</i></code></dt>
<dd><a name="1071482"> </a>Card number of database to protect/unprotect.</dd>

<dt><a name="1071483"> </a><code>&rarr;  <i>dbID</i></code></dt>
<dd><a name="1071484"> </a>Local ID of database to protect/unprotect.</dd>

<dt><a name="1071485"> </a><code>&rarr;  <i>protect</i></code></dt>
<dd><a name="1071486"> </a>If <code>true</code>, the database's protection count is incremented. If <code>false</code>, it is decremented.</dd>

</dl>
<h4>
  <a name="1071487"> </a>Returns 
</h4>

<p><a name="1071488"> </a>Returns <code>errNone</code> if no error, or one of the following if an error occurs: </p>

<dl>
<dt><a name="1071489"> </a><code>memErrCardNotPresent</code></dt>
<dd><a name="1071490"> </a>The specified card can't be found.</dd>

<dt><a name="1071491"> </a><code>dmErrROMBased</code></dt>
<dd><a name="1071492"> </a>You've attempted to delete or modify a ROM-based database.</dd>

<dt><a name="1071493"> </a><code>dmErrCantFind</code></dt>
<dd><a name="1071494"> </a>The specified database can't be found.</dd>

<dt><a name="1071495"> </a><code>memErrNotEnoughSpace</code></dt>
<dd><a name="1071496"> </a>A memory error occurred.</dd>

<dt><a name="1071497"> </a><code>dmErrDatabaseNotProtected</code></dt>
</dl>
<h4>
  <a name="1071498"> </a>Comments 
</h4>

<p><a name="1071499"> </a>This function can be used to prevent a database from being deleted (by passing <code>true</code> for the <code class="par">protect</code> parameter). It increments the protect count if <code class="par">protect</code> is <code>true</code> and decrements it if <code class="par">protect</code> is <code>false</code>. All <code>true</code> calls should be balanced by <code>false</code> calls before the application terminates. </p>

<p><a name="1071501"> </a>Use this function if you want to keep a particular record or resource in a database locked down but don't want to keep the database open. This information is kept in the dynamic heap, so all databases are "unprotected" at system reset. </p>

<p><a name="1071502"> </a>If the database is a resource database that has an overlay associated with it for the current locale, the overlay is also protected or unprotected by this call.</p>
<h4>
  <a name="1128948"> </a>Compatibility 
</h4>

<p><a name="1129181"> </a>This function is provided for compatibility purposes only. Palm OS Cobalt functions should use <a href="DataMgr.html#1006613"><code>DmSetDatabaseProtection()</code></a> instead.</p>

<h3 class="hbH3">
  <a name="996477"> </a>DmDatabaseSize Function <a href="#992934"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="1072047"> </a>Purpose 
</h4>

<p><a name="1072048"> </a>Retrieve size information for a database.</p>
<h4>
  <a name="1072049"> </a>Declared In 
</h4>
<code>DataMgr.h<a name="1072050"> </a></code><h4>
  <a name="1072051"> </a>Prototype 
</h4>
<pre class="proto"><a name="1072052"></a>status_t DmDatabaseSize (
   DatabaseID <code class="par">dbID</code>,
   uint32_t <code class="par">*numRecordsP</code>,
   uint32_t <code class="par">*totalBytesP</code>,
   uint32_t <code class="par">*dataBytesP</code>
)
</pre>
<h4>
  <a name="1072053"> </a>Parameters 
</h4>

<dl>
<dt><a name="1072054"> </a><code>&rarr;  <i>dbID</i></code></dt>
<dd><a name="1072055"> </a>Database ID of the database.</dd>

<dt><a name="1072056"> </a><code>&larr;  <i>numRecordsP</i></code></dt>
<dd><a name="1072057"> </a>The total number of records in the database. Pass <code>NULL</code> for this parameter if you don't want to retrieve it.</dd>

<dt><a name="1072058"> </a><code>&larr;  <i>totalBytesP</i></code></dt>
<dd><a name="1072059"> </a>The total number of bytes used by the database including the overhead. Pass <code>NULL</code> for this parameter if you don't want to retrieve it.</dd>

<dt><a name="1072060"> </a><code>&larr;  <i>dataBytesP</i></code></dt>
<dd><a name="1072061"> </a>The total number of bytes used to store just each record's data, not including overhead. Pass <code>NULL</code> for this parameter if you don't want to retrieve it.</dd>

</dl>
<h4>
  <a name="1072062"> </a>Returns 
</h4>

<p><a name="1072063"> </a>Returns <code>errNone</code> if no error, or <code>dmErrMemError</code> if an error occurs. </p>
<h4>
  <a name="1129290"> </a>Comments 
</h4>

<p><a name="1129291"> </a>This function operates on extended, classic, or schema databases.</p>
<h4>
  <a name="1072064"> </a>See Also 
</h4>

<p><a name="1072071"> </a><a href="DataMgr.html#996192"><code>DmDatabaseInfo()</code></a>, <a href="DataMgr.html#1002946"><code>DmOpenDatabaseInfoV50()</code></a>, <a href="DataMgr.html#1077521"><code>DmFindDatabase()</code></a>, <a href="DataMgr.html#999000"><code>DmGetNextDatabaseByTypeCreator()</code></a></p>

<h3 class="hbH3">
  <a name="996555"> </a>DmDatabaseSizeV50 Function <a href="#992934"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="1072131"> </a>Purpose 
</h4>

<p><a name="1072132"> </a>Retrieve size information for a database.</p>
<h4>
  <a name="1072133"> </a>Declared In 
</h4>
<code>DataMgr.h<a name="1072134"> </a></code><h4>
  <a name="1072135"> </a>Prototype 
</h4>
<pre class="proto"><a name="1072136"></a>status_t DmDatabaseSizeV50 (
   uint16_t <code class="par">cardNo</code>,
   LocalID <code class="par">dbID</code>,
   uint32_t <code class="par">*numRecordsP</code>,
   uint32_t <code class="par">*totalBytesP</code>,
   uint32_t <code class="par">*dataBytesP</code>
)
</pre>
<h4>
  <a name="1072137"> </a>Parameters 
</h4>

<dl>
<dt><a name="1072138"> </a><code>&rarr;  <i>cardNo</i></code></dt>
<dd><a name="1072139"> </a>Card number the database resides on.</dd>

<dt><a name="1072140"> </a><code>&rarr;  <i>dbID</i></code></dt>
<dd><a name="1072141"> </a>Database ID of the database.</dd>

<dt><a name="1072142"> </a><code>&larr;  <i>numRecordsP</i></code></dt>
<dd><a name="1072143"> </a>The total number of records in the database. Pass <code>NULL</code> for this parameter if you don't want to retrieve it.</dd>

<dt><a name="1072144"> </a><code>&larr;  <i>totalBytesP</i></code></dt>
<dd><a name="1072145"> </a>The total number of bytes used by the database including the overhead. Pass <code>NULL</code> for this parameter if you don't want to retrieve it.</dd>

<dt><a name="1072146"> </a><code>&larr;  <i>dataBytesP</i></code></dt>
<dd><a name="1072147"> </a>The total number of bytes used to store just each record's data, not including overhead. Pass <code>NULL</code> for this parameter if you don't want to retrieve it.</dd>

</dl>
<h4>
  <a name="1072148"> </a>Returns 
</h4>

<p><a name="1072149"> </a>Returns <code>errNone</code> if no error, or <code>dmErrMemError</code> if an error occurs. </p>
<h4>
  <a name="1129323"> </a>Compatibility 
</h4>

<p><a name="1129336"> </a>This function is provided for compatibility purposes only. Palm OS Cobalt applications should use <a href="DataMgr.html#996477"><code>DmDatabaseSize()</code></a> instead.</p>
<h4>
  <a name="1072150"> </a>See Also 
</h4>

<p><a name="1072157"> </a><a href="DataMgr.html#996192"><code>DmDatabaseInfo()</code></a>, <a href="DataMgr.html#1002946"><code>DmOpenDatabaseInfoV50()</code></a>, <a href="DataMgr.html#1077521"><code>DmFindDatabase()</code></a>, <a href="DataMgr.html#999000"><code>DmGetNextDatabaseByTypeCreator()</code></a></p>

<h3 class="hbH3">
  <a name="996617"> </a>DmDeleteCategory Function <a href="#992934"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="1072195"> </a>Purpose 
</h4>

<p><a name="1072196"> </a>Delete all records in a category. The category name is not changed.</p>
<h4>
  <a name="1072197"> </a>Declared In 
</h4>
<code>DataMgr.h<a name="1072198"> </a></code><h4>
  <a name="1072199"> </a>Prototype 
</h4>
<pre class="proto"><a name="1072200"></a>status_t DmDeleteCategory (
   DmOpenRef <code class="par">dbRef</code>,
   uint16_t <code class="par">categoryNum</code>
)
</pre>
<h4>
  <a name="1072201"> </a>Parameters 
</h4>

<dl>
<dt><a name="1072202"> </a><code>&rarr;  <i>dbRef</i></code></dt>
<dd><a name="1072203"> </a><code>DmOpenRef</code> to an open database.</dd>

<dt><a name="1072204"> </a><code>&rarr;  <i>categoryNum</i></code></dt>
<dd><a name="1072205"> </a>Category of records to delete. Category masks such as <code>dmAllCategories</code> are invalid. </dd>

</dl>
<h4>
  <a name="1072206"> </a>Returns 
</h4>

<p><a name="1072207"> </a>Returns <code>errNone</code> if no error, or one of the following if an error occurs: </p>

<dl>
<dt><a name="1072208"> </a><code>dmErrReadOnly</code></dt>
<dd><a name="1072209"> </a>You've attempted to write to or modify a database that is open in read-only mode.</dd>

<dt><a name="1072210"> </a><code>memErrInvalidParam</code></dt>
<dd><a name="1072211"> </a>A memory error occurred.</dd>

</dl>

<p><a name="1072212"> </a>Some releases may display a fatal error message instead of returning the error code. </p>
<h4>
  <a name="1072213"> </a>Comments 
</h4>

<p><a name="1072214"> </a>This function deletes all records in a category, but does not delete the category itself (note that it deletes the record data and header info, and doesn't just set the deleted bit). For each record in the category, <code>DmDeleteCategory()</code> marks the <code>delete</code> bit in the database header for the record and disposes of the record's data chunk. The record entry in the database header remains, but its <code>localChunkID</code> is set to <code>NULL</code>. </p>

<p><a name="1072216"> </a>If the category contains no records, this function does nothing and returns <code>errNone</code> to indicate success. The <code class="par">categoryNum</code> parameter is assumed to represent a single category. If you pass a category mask to specify more than one category, this function interprets that value as a single category, finds no records to delete in that category, and returns <code>errNone</code>. </p>
<h4>
  <a name="1109363"> </a>Example 
</h4>

<p><a name="1072220"> </a>You can use the <a href="DataMgr.html#1000470"><code>DmGetRecordCategory()</code></a> call to obtain a category index from a given record, as shown in the following code excerpt:</p>

<div class="CodeRule"><hr></div><pre class="CodeBlock">
DmOpenRef myDB;   //assume that this is set<a name="1133979"> </a>
uint16_t myRecIndex;   //assume that this is set<a name="1134283"> </a>
uint8_t category;<a name="1134273"> </a>
status_t err;<a name="1133434"> </a>
 <a name="1072223"> </a>
err = DmGetRecordCategory(myDB, myRecIndex, &amp;category);<a name="1072224"> </a>
err = DmDeleteCategory(myDB, category);<a name="1072226"> </a>
</pre><div class="CodeRule"><hr></div>


<h3 class="hbH3">
  <a name="996663"> </a>DmDeleteDatabase Function <a href="#992934"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="1072597"> </a>Purpose 
</h4>

<p><a name="1072598"> </a>Delete a database and all of its records.</p>
<h4>
  <a name="1072599"> </a>Declared In 
</h4>
<code>DataMgr.h<a name="1072600"> </a></code><h4>
  <a name="1072601"> </a>Prototype 
</h4>
<pre class="proto"><a name="1072602"></a>status_t DmDeleteDatabase (
   DatabaseID <code class="par">dbID</code>
)
</pre>
<h4>
  <a name="1072603"> </a>Parameters 
</h4>

<dl>
<dt><a name="1072604"> </a><code>&rarr;  <i>dbID</i></code></dt>
<dd><a name="1072605"> </a>Database ID of the database being deleted.</dd>

</dl>
<h4>
  <a name="1072606"> </a>Returns 
</h4>

<p><a name="1072607"> </a>Returns <code>errNone</code> if no error, or one of the following if an error occurred: </p>

<dl>
<dt><a name="1072608"> </a><code>dmErrCantFind</code></dt>
<dd><a name="1072609"> </a>The specified database can't be found.</dd>

<dt><a name="1072610"> </a><code>dmErrCantOpen</code></dt>
<dd><a name="1072611"> </a>The database cannot be opened.</dd>

<dt><a name="1072612"> </a><code>memErrChunkLocked</code></dt>
<dd><a name="1072613"> </a>The associated memory chunk is locked. </dd>

<dt><a name="1072614"> </a><code>dmErrDatabaseOpen</code></dt>
<dd><a name="1072615"> </a>The function cannot be performed on an open database, and the database is open. </dd>

<dt><a name="1072616"> </a><code>dmErrROMBased</code></dt>
<dd><a name="1072617"> </a>You've attempted to delete or modify a ROM-based database.</dd>

<dt><a name="1072618"> </a><code>memErrInvalidParam</code></dt>
<dd><a name="1072619"> </a>A memory error occurred.</dd>

<dt><a name="1072620"> </a><code>memErrNotEnoughSpace</code></dt>
<dd><a name="1072621"> </a>A memory error occurred.</dd>

</dl>
<h4>
  <a name="1072622"> </a>Comments 
</h4>

<p><a name="1072623"> </a>Call this function to delete a database. This function deletes the database, the application info block, the sort info block, and any other overhead information that is associated with this database. After deleting the database, this function enqueues a deferred <a href="../Programming_Basics/NotifyMgr.html#996752"><code>sysNotifyDBDeletedEvent</code></a> notification, which will be broadcast at the top of the event loop. </p>

<p><a name="1072628"> </a>If the database has an overlay associated with it, this function does <i>not </i>delete the overlay. You can delete the overlay with a separate call to <code>DmDeleteDatabase()</code>. </p>

<p><a name="1072629"> </a>This function accepts a database ID as a parameter. To determine the database ID, call <a href="DataMgr.html#1077521"><code>DmFindDatabase()</code></a>.</p>

<div><hr>
  <a name="1185320"> </a> <b>IMPORTANT: </b> When called from the main application thread, this function may block. While blocked, the application will not receive events and won't redraw its windows. As well, deferred sublaunches and notifications won't execute while the main application thread is blocked.
<hr>
</div>
<h4>
  <a name="1072639"> </a>See Also 
</h4>

<p><a name="1072646"> </a><a href="DataMgr.html#996913"><code>DmDeleteRecord()</code></a>, <a href="DataMgr.html#1004638"><code>DmRemoveRecord()</code></a>, <a href="DataMgr.html#1004684"><code>DmRemoveResource()</code></a>, <a href="DataMgr.html#995780"><code>DmCreateDatabase()</code></a>, <a href="DataMgr.html#999000"><code>DmGetNextDatabaseByTypeCreator()</code></a>, <a href="DataMgr.html#1077521"><code>DmFindDatabase()</code></a></p>

<h3 class="hbH3">
  <a name="996867"> </a>DmDeleteDatabaseV50 Function <a href="#992934"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="1073182"> </a>Purpose 
</h4>

<p><a name="1073183"> </a>Delete a database and all its records.</p>
<h4>
  <a name="1073184"> </a>Declared In 
</h4>
<code>DataMgr.h<a name="1073185"> </a></code><h4>
  <a name="1073186"> </a>Prototype 
</h4>
<pre class="proto"><a name="1073187"></a>status_t DmDeleteDatabaseV50 (
   uint16_t <code class="par">cardNo</code>,
   LocalID <code class="par">dbID</code>
)
</pre>
<h4>
  <a name="1073188"> </a>Parameters 
</h4>

<dl>
<dt><a name="1073189"> </a><code>&rarr;  <i>cardNo</i></code></dt>
<dd><a name="1073190"> </a>Card number the database resides on.</dd>

<dt><a name="1073191"> </a><code>&rarr;  <i>dbID</i></code></dt>
<dd><a name="1073192"> </a>Database ID.</dd>

</dl>
<h4>
  <a name="1073193"> </a>Returns 
</h4>

<p><a name="1073194"> </a>Returns <code>errNone</code> if no error, or one of the following if an error occurs: </p>

<dl>
<dt><a name="1073195"> </a><code>dmErrCantFind</code></dt>
<dd><a name="1073196"> </a>The specified database can't be found.</dd>

<dt><a name="1073197"> </a><code>dmErrCantOpen</code></dt>
<dd><a name="1073198"> </a>The database cannot be opened.</dd>

<dt><a name="1073199"> </a><code>memErrChunkLocked</code></dt>
<dd><a name="1073200"> </a>The associated memory chunk is locked. </dd>

<dt><a name="1073201"> </a><code>dmErrDatabaseOpen</code></dt>
<dd><a name="1073202"> </a>The function cannot be performed on an open database, and the database is open. </dd>

<dt><a name="1073203"> </a><code>dmErrDatabaseProtected</code></dt>
<dd><a name="1073204"> </a>The database is marked as protected.</dd>

<dt><a name="1073205"> </a><code>dmErrROMBased</code></dt>
<dd><a name="1073206"> </a>You've attempted to delete or modify a ROM-based database.</dd>

<dt><a name="1073207"> </a><code>memErrInvalidParam</code></dt>
<dd><a name="1073208"> </a>A memory error occurred.</dd>

<dt><a name="1073209"> </a><code>memErrNotEnoughSpace</code></dt>
<dd><a name="1073210"> </a>A memory error occurred.</dd>

</dl>
<h4>
  <a name="1073211"> </a>Comments 
</h4>

<p><a name="1073212"> </a>Call this function to delete a database. This function deletes the database, the application info block, the sort info block, and any other overhead information that is associated with this database. After deleting the database, this function enqueues a deferred <a href="../Programming_Basics/NotifyMgr.html#996752"><code>sysNotifyDBDeletedEvent</code></a> notification, which will be broadcast at the top of the event loop. </p>

<p><a name="1073217"> </a>If the database has an overlay associated with it, this function does <i>not</i> delete the overlay. You can delete the overlay with a separate call to <code>DmDeleteDatabase()</code>. </p>

<p><a name="1073218"> </a>This function accepts a database ID as a parameter. To determine the database ID, call either <a href="DataMgr.html#1077521"><code>DmFindDatabase()</code></a> or <a href="DataMgr.html#1157229"><code>DmGetDatabaseV50()</code></a> with a database index.</p>

<div><hr>
  <a name="1185332"> </a> <b>IMPORTANT: </b> When called from the main application thread, this function may block. While blocked, the application will not receive events and won't redraw its windows. As well, deferred sublaunches and notifications won't execute while the main application thread is blocked.
<hr>
</div>
<h4>
  <a name="1129351"> </a>Compatibility 
</h4>

<p><a name="1129356"> </a>This function is provided for compatibility purposes. Palm OS Cobalt applications will likely want to use <a href="DataMgr.html#996663"><code>DmDeleteDatabase()</code></a> instead.</p>
<h4>
  <a name="1073228"> </a>See Also 
</h4>

<p><a name="1073235"> </a><a href="DataMgr.html#996913"><code>DmDeleteRecord()</code></a>, <a href="DataMgr.html#1004638"><code>DmRemoveRecord()</code></a>, <a href="DataMgr.html#1004684"><code>DmRemoveResource()</code></a>, <a href="DataMgr.html#995780"><code>DmCreateDatabase()</code></a>, <a href="DataMgr.html#999000"><code>DmGetNextDatabaseByTypeCreator()</code></a>, <a href="DataMgr.html#1077521"><code>DmFindDatabase()</code></a></p>

<h3 class="hbH3">
  <a name="996913"> </a>DmDeleteRecord Function <a href="#992934"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="1073775"> </a>Purpose 
</h4>

<p><a name="1073776"> </a>Delete a record's chunk from a database but leave the record entry in the header and set the <code>delete</code> bit for the next HotSync operation.</p>
<h4>
  <a name="1073778"> </a>Declared In 
</h4>
<code>DataMgr.h<a name="1073779"> </a></code><h4>
  <a name="1073780"> </a>Prototype 
</h4>
<pre class="proto"><a name="1073781"></a>status_t DmDeleteRecord (
   DmOpenRef <code class="par">dbRef</code>,
   uint16_t <code class="par">index</code>
)
</pre>
<h4>
  <a name="1073782"> </a>Parameters 
</h4>

<dl>
<dt><a name="1073783"> </a><code>&rarr;  <i>dbRef</i></code></dt>
<dd><a name="1073784"> </a><code>DmOpenRef</code> to an open database.</dd>

<dt><a name="1073785"> </a><code>&rarr;  <i>index</i></code></dt>
<dd><a name="1073786"> </a>Which record to delete.</dd>

</dl>
<h4>
  <a name="1073787"> </a>Returns 
</h4>

<p><a name="1073788"> </a>Returns <code>errNone</code> if no error, or one of the following if an error occurs: </p>

<dl>
<dt><a name="1073789"> </a><code>dmErrReadOnly</code></dt>
<dd><a name="1073790"> </a>You've attempted to write to or modify a database that is open in read-only mode.</dd>

<dt><a name="1073791"> </a><code>dmErrIndexOutOfRange</code></dt>
<dd><a name="1073792"> </a>The specified index is out of range.</dd>

<dt><a name="1073793"> </a><code>dmErrRecordArchived</code></dt>
<dd><a name="1073794"> </a>The function requires that the record not be archived, but it is.</dd>

<dt><a name="1073795"> </a><code>dmErrRecordDeleted</code></dt>
<dd><a name="1073796"> </a>The record has been deleted.</dd>

<dt><a name="1073797"> </a><code>memErrInvalidParam</code></dt>
<dd><a name="1073798"> </a>A memory error occurred.</dd>

</dl>

<p><a name="1073799"> </a>Some releases may display a fatal error message instead of returning the error code. </p>
<h4>
  <a name="1073800"> </a>Comments 
</h4>

<p><a name="1073802"> </a>Marks the <code>delete</code> bit in the database header for the record and disposes of the record's data chunk. Does not remove the record entry from the database header, but simply sets the <code>localChunkID</code> of the record entry to <code>NULL</code>.</p>
<h4>
  <a name="1073803"> </a>See Also 
</h4>

<p><a name="1073810"> </a><a href="DataMgr.html#997011"><code>DmDetachRecord()</code></a>, <a href="DataMgr.html#1004638"><code>DmRemoveRecord()</code></a>, <a href="DataMgr.html#995341"><code>DmArchiveRecord()</code></a>, <a href="DataMgr.html#1001785"><code>DmNewRecord()</code></a></p>

<h3 class="hbH3">
  <a name="997011"> </a>DmDetachRecord Function <a href="#992934"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="1074280"> </a>Purpose 
</h4>

<p><a name="1074281"> </a>Detach and orphan a record from a database but don't delete the record's chunk.</p>
<h4>
  <a name="1074282"> </a>Declared In 
</h4>
<code>DataMgr.h<a name="1074283"> </a></code><h4>
  <a name="1074284"> </a>Prototype 
</h4>
<pre class="proto"><a name="1074285"></a>status_t DmDetachRecord (
   DmOpenRef <code class="par">dbRef</code>,
   uint16_t <code class="par">index</code>,
   MemHandle <code class="par">*hDetached</code>
)
</pre>
<h4>
  <a name="1074286"> </a>Parameters 
</h4>

<dl>
<dt><a name="1074287"> </a><code>&rarr;  <i>dbRef</i></code></dt>
<dd><a name="1074288"> </a><code>DmOpenRef</code> to an open database.</dd>

<dt><a name="1074289"> </a><code>&rarr;  <i>index</i></code></dt>
<dd><a name="1074290"> </a>Index of the record to detach.</dd>

<dt><a name="1074291"> </a><code>&harr;  <i>hDetached</i></code></dt>
<dd><a name="1074292"> </a>Pointer to return handle of the detached record.</dd>

</dl>
<h4>
  <a name="1074293"> </a>Returns 
</h4>

<p><a name="1074294"> </a>Returns <code>errNone</code> if no error, or one of the following if an error occurs: </p>

<dl>
<dt><a name="1074295"> </a><code>dmErrReadOnly</code></dt>
<dd><a name="1074296"> </a>You've attempted to write to or modify a database that is open in read-only mode.</dd>

<dt><a name="1074297"> </a><code>dmErrIndexOutOfRange</code></dt>
<dd><a name="1074298"> </a>The specified index is out of range.</dd>

<dt><a name="1074299"> </a><code>dmErrNotRecordDB</code></dt>
<dd><a name="1074300"> </a>You've attempted to perform a record function on a resource database. </dd>

<dt><a name="1074301"> </a><code>memErrChunkLocked</code></dt>
<dd><a name="1074302"> </a>The associated memory chunk is locked. </dd>

<dt><a name="1074303"> </a><code>memErrInvalidParam</code></dt>
<dd><a name="1074304"> </a>A memory error occurred.</dd>

</dl>

<p><a name="1074305"> </a>Some releases may display a fatal error message instead of returning the error code. </p>
<h4>
  <a name="1074306"> </a>Comments 
</h4>

<p><a name="1074308"> </a>This function detaches a record from a database by removing its entry from the database header and returns the handle of the record's data chunk in <code class="par">*hDetached</code>. Unlike <a href="DataMgr.html#996913"><code>DmDeleteRecord()</code></a>, this function removes its entry in the database header but it does not delete the actual record.</p>
<h4>
  <a name="1074312"> </a>See Also 
</h4>

<p><a name="1074319"> </a><a href="DataMgr.html#1208108"><code>DmAttachRecord()</code></a>, <a href="DataMgr.html#1004638"><code>DmRemoveRecord()</code></a>, <a href="DataMgr.html#995341"><code>DmArchiveRecord()</code></a>, <a href="DataMgr.html#996913"><code>DmDeleteRecord()</code></a></p>

<h3 class="hbH3">
  <a name="997061"> </a>DmDetachResource Function <a href="#992934"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="1077909"> </a>Purpose 
</h4>

<p><a name="1077910"> </a>Detach a resource from a database and return the handle of the resource's data.</p>
<h4>
  <a name="1077911"> </a>Declared In 
</h4>
<code>DataMgr.h<a name="1077912"> </a></code><h4>
  <a name="1077913"> </a>Prototype 
</h4>
<pre class="proto"><a name="1077914"></a>status_t DmDetachResource (
   DmOpenRef <code class="par">dbRef</code>,
   uint16_t <code class="par">index</code>,
   MemHandle <code class="par">*hDetached</code>
)
</pre>
<h4>
  <a name="1077915"> </a>Parameters 
</h4>

<dl>
<dt><a name="1077916"> </a><code>&rarr;  <i>dbRef</i></code></dt>
<dd><a name="1077917"> </a><code>DmOpenRef</code> to an open database.</dd>

<dt><a name="1077918"> </a><code>&rarr;  <i>index</i></code></dt>
<dd><a name="1077919"> </a>Index of resource to detach.</dd>

<dt><a name="1077920"> </a><code>&harr;  <i>hDetached</i></code></dt>
<dd><a name="1077921"> </a>Pointer to return handle of the detached record.</dd>

</dl>
<h4>
  <a name="1077922"> </a>Returns 
</h4>

<p><a name="1077923"> </a>Returns <code>errNone</code> if no error, or one of the following if an error occurs: </p>

<dl>
<dt><a name="1077924"> </a><code>dmErrReadOnly</code></dt>
<dd><a name="1077925"> </a>You've attempted to write to or modify a database that is open in read-only mode.</dd>

<dt><a name="1077926"> </a><code>dmErrIndexOutOfRange</code></dt>
<dd><a name="1077927"> </a>The specified index is out of range.</dd>

<dt><a name="1077928"> </a><code>dmErrCorruptDatabase</code></dt>
<dd><a name="1077929"> </a>The database is corrupted.</dd>

<dt><a name="1077930"> </a><code>memErrChunkLocked</code></dt>
<dd><a name="1077931"> </a>The associated memory chunk is locked. </dd>

<dt><a name="1077932"> </a><code>memErrInvalidParam</code></dt>
<dd><a name="1077933"> </a>A memory error occurred.</dd>

</dl>

<p><a name="1077934"> </a>Some releases may display a fatal error message instead of returning the error code. All releases may display a fatal error message if the database is not a resource database. </p>
<h4>
  <a name="1077935"> </a>Comments 
</h4>

<p><a name="1077936"> </a>This function detaches a resource from a database by removing its entry from the database header and returns the handle of the resource's data chunk in *<code class="par">hDetached</code>. </p>
<h4>
  <a name="1077937"> </a>See Also 
</h4>

<p><a name="1077944"> </a><a href="DataMgr.html#995445"><code>DmAttachResource()</code></a>, <a href="DataMgr.html#1004684"><code>DmRemoveResource()</code></a></p>

<h3 class="hbH3">
  <a name="1077521"> </a>DmFindDatabase Function <a href="#992934"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="997120"> </a>Purpose 
</h4>

<p><a name="1078426"> </a>Return the database ID of a database given its name and creator ID.</p>
<h4>
  <a name="997125"> </a>Declared In 
</h4>
<code>DataMgr.h<a name="997128"> </a></code><h4>
  <a name="997130"> </a>Prototype 
</h4>
<pre class="proto"><a name="997133"></a>DatabaseID DmFindDatabase (
   const char <code class="par">*nameP</code>,
   uint32_t <code class="par">creator</code>,
   DmFindType <code class="par">find</code>,
   DmDatabaseInfoPtr <code class="par">databaseInfoP</code>
)
</pre>
<h4>
  <a name="997135"> </a>Parameters 
</h4>

<dl>
<dt><a name="1078432"> </a><code>&rarr;  <i>nameP</i></code></dt>
<dd><a name="1078433"> </a>Name of the database to look for.</dd>

<dt><a name="1078434"> </a><code>&rarr;  <i>creator</i></code></dt>
<dd><a name="1078435"> </a>Creator ID of the database to look for.</dd>

<dt><a name="997146"> </a><code>&rarr;  <i>find</i></code></dt>
<dd><a name="1102229"> </a>Flags indicating the type of database to be searched for: schema, extended, classic, or a combination of the three. See <a href="DataMgr.html#993618"><code>DmFindType</code></a> for more information.</dd>

<dt><a name="997150"> </a><code>&larr;  <i>databaseInfoP</i></code></dt>
<dd><a name="1101599"> </a>Pointer to a <a href="DataMgr.html#993322"><code>DmDatabaseInfoType</code></a> structure which is filled out appropriately for the found database, or <code>NULL</code> if this information isn't needed.</dd>

</dl>
<h4>
  <a name="997154"> </a>Returns 
</h4>

<p><a name="1101257"> </a>Returns the database ID. If the database can't be found, this function returns 0, and <a href="DataMgr.html#998861"><code>DmGetLastErr()</code></a> returns an error code indicating the reason for failure.</p>
<h4>
  <a name="1101425"> </a>Comments 
</h4>

<p><a name="1101488"> </a>This function first searches in RAM; if a database matching the specified criteria is not found, it then searches the device's ROM.</p>
<h4>
  <a name="1078459"> </a>See Also 
</h4>

<p><a name="1078465"> </a><a href="DataMgr.html#996192"><code>DmDatabaseInfo()</code></a>, <a href="DataMgr.html#997169"><code>DmFindDatabaseByTypeCreator()</code></a>, <a href="DataMgr.html#997495"><code>DmFindDatabaseV50()</code></a>, <a href="DataMgr.html#999000"><code>DmGetNextDatabaseByTypeCreator()</code></a></p>

<h3 class="hbH3">
  <a name="997169"> </a>DmFindDatabaseByTypeCreator Function <a href="#992934"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="997174"> </a>Purpose 
</h4>

<p><a name="1101962"> </a>Return the database ID of a database given its type and creator ID.</p>
<h4>
  <a name="997179"> </a>Declared In 
</h4>
<code>DataMgr.h<a name="997182"> </a></code><h4>
  <a name="997184"> </a>Prototype 
</h4>
<pre class="proto"><a name="997213"></a>DatabaseID DmFindDatabaseByTypeCreator (
   uint32_t <code class="par">type</code>,
   uint32_t <code class="par">creator</code>,
   DmFindType <code class="par">find</code>,
   DmDatabaseInfoPtr <code class="par">databaseInfoP</code>
)
</pre>
<h4>
  <a name="997269"> </a>Parameters 
</h4>

<dl>
<dt><a name="997320"> </a><code>&rarr;  <i>type</i></code></dt>
<dd><a name="997370"> </a>Database type of the database to look for.</dd>

<dt><a name="997420"> </a><code>&rarr;  <i>creator</i></code></dt>
<dd><a name="1101992"> </a>Creator ID of the database to look for.</dd>

<dt><a name="997472"> </a><code>&rarr;  <i>find</i></code></dt>
<dd><a name="1102264"> </a>Flags indicating the type of database to be searched for: schema, extended, classic, or a combination of the three. See <a href="DataMgr.html#993618"><code>DmFindType</code></a> for more information.</dd>

<dt><a name="997476"> </a><code>&larr;  <i>databaseInfoP</i></code></dt>
<dd><a name="1101650"> </a>Pointer to a <a href="DataMgr.html#993322"><code>DmDatabaseInfoType</code></a> structure which is filled out appropriately for the found database, or <code>NULL</code> if this information isn't needed.</dd>

</dl>
<h4>
  <a name="997480"> </a>Returns 
</h4>

<p><a name="1102279"> </a>Returns the database ID. If the database can't be found, this function returns 0, and <a href="DataMgr.html#998861"><code>DmGetLastErr()</code></a> returns an error code indicating the reason for failure.</p>
<h4>
  <a name="997485"> </a>Comments 
</h4>

<p><a name="1102205"> </a>This function first searches in RAM; if a database matching the specified criteria is not found, it then searches the device's ROM.</p>

<p><a name="1129519"> </a>This function can be used to find extended, classic, or even schema databases.</p>
<h4>
  <a name="997490"> </a>See Also 
</h4>

<p><a name="997493"> </a><a href="DataMgr.html#996192"><code>DmDatabaseInfo()</code></a>, <a href="DataMgr.html#1077521"><code>DmFindDatabase()</code></a>, <a href="DataMgr.html#999000"><code>DmGetNextDatabaseByTypeCreator()</code></a></p>

<h3 class="hbH3">
  <a name="997495"> </a>DmFindDatabaseV50 Function <a href="#992934"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="1078494"> </a>Purpose 
</h4>

<p><a name="1078496"> </a>Return the database ID of a classic database given its card number and name.</p>
<h4>
  <a name="1078497"> </a>Declared In 
</h4>
<code>DataMgr.h<a name="1078498"> </a></code><h4>
  <a name="1078499"> </a>Prototype 
</h4>
<pre class="proto"><a name="1078500"></a>LocalID DmFindDatabaseV50 (
   uint16_t <code class="par">cardNo</code>,
   const char <code class="par">*nameP</code>
)
</pre>
<h4>
  <a name="1078501"> </a>Parameters 
</h4>

<dl>
<dt><a name="1078502"> </a><code>&rarr;  <i>cardNo</i></code></dt>
<dd><a name="1078503"> </a>Number of card to search.</dd>

<dt><a name="1078504"> </a><code>&rarr;  <i>nameP</i></code></dt>
<dd><a name="1078505"> </a>Name of the database to look for.</dd>

</dl>
<h4>
  <a name="1078506"> </a>Returns 
</h4>

<p><a name="1078507"> </a>Returns the database ID. If the database can't be found, this function returns 0, and <a href="DataMgr.html#998861"><code>DmGetLastErr()</code></a> returns an error code indicating the reason for failure.</p>
<h4>
  <a name="1129372"> </a>Comments 
</h4>

<p><a name="1129373"> </a>This function searches only within the classic namespace. This eliminates the possibility of finding multiple databases with the same name.</p>

<p><a name="1164988"> </a>Palm OS Cobalt applications should usually use <a href="DataMgr.html#1077521"><code>DmFindDatabase()</code></a> instead of this function. In order to ensure compatibility, this function only searches for classic database. Note that this function isn't as flexible as <code>DmFindDatabase()</code> since it finds databases without regard to their creator ID. This is consistent with earlier versions of Palm OS, in which databases had to be uniquely identified by name.</p>
<h4>
  <a name="1129474"> </a>Compatibility 
</h4>

<p><a name="1129510"> </a>This function is provided for compatibility purposes only. Palm OS Cobalt applications should use <a href="DataMgr.html#1077521"><code>DmFindDatabase()</code></a> instead.</p>
<h4>
  <a name="1078511"> </a>See Also 
</h4>

<p><a name="1078518"> </a><a href="DataMgr.html#1077521"><code>DmFindDatabase()</code></a>, <a href="DataMgr.html#999000"><code>DmGetNextDatabaseByTypeCreator()</code></a>, <a href="DataMgr.html#996192"><code>DmDatabaseInfo()</code></a>, <a href="DataMgr.html#1002512"><code>DmOpenDatabase()</code></a></p>

<h3 class="hbH3">
  <a name="997584"> </a>DmFindRecordByID Function <a href="#992934"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="1078546"> </a>Purpose 
</h4>

<p><a name="1078548"> </a>Return the index of the record with the given unique ID.</p>
<h4>
  <a name="1078549"> </a>Declared In 
</h4>
<code>DataMgr.h<a name="1078550"> </a></code><h4>
  <a name="1078551"> </a>Prototype 
</h4>
<pre class="proto"><a name="1078552"></a>status_t DmFindRecordByID (
   DmOpenRef <code class="par">dbRef</code>,
   uint32_t <code class="par">uniqueID</code>,
   uint16_t <code class="par">*pIndex</code>
)
</pre>
<h4>
  <a name="1078553"> </a>Parameters 
</h4>

<dl>
<dt><a name="1078554"> </a><code>&rarr;  <i>dbRef</i></code></dt>
<dd><a name="1078555"> </a><code>DmOpenRef</code> to an open database.</dd>

<dt><a name="1078556"> </a><code>&rarr;  <i>uniqueID</i></code></dt>
<dd><a name="1078557"> </a>Unique ID to search for.</dd>

<dt><a name="1078558"> </a><code>&larr;  <i>pIndex</i></code></dt>
<dd><a name="1078559"> </a>Return index.</dd>

</dl>
<h4>
  <a name="1078560"> </a>Returns 
</h4>

<p><a name="1078561"> </a>Returns 0 if found, otherwise <code>dmErrUniqueIDNotFound</code>. May display a fatal error message if the unique ID is invalid. </p>
<h4>
  <a name="1078562"> </a>See Also 
</h4>

<p><a name="1078572"> </a><a href="DataMgr.html#1004199"><code>DmQueryRecord()</code></a>, <a href="DataMgr.html#1000166"><code>DmGetRecord()</code></a>, <a href="DataMgr.html#1004375"><code>DmRecordInfoV50()</code></a></p>

<h3 class="hbH3">
  <a name="997658"> </a>DmFindRecordByOffsetInCategory Function <a href="#992934"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="1078580"> </a>Purpose 
</h4>

<p><a name="1078581"> </a>Return the index of the record nearest the offset from the passed record index whose category matches the passed category. (The <code class="par">offset</code> parameter indicates the number of records to move forward or backward.)</p>
<h4>
  <a name="1078583"> </a>Declared In 
</h4>
<code>DataMgr.h<a name="1078584"> </a></code><h4>
  <a name="1078585"> </a>Prototype 
</h4>
<pre class="proto"><a name="1078586"></a>status_t DmFindRecordByOffsetInCategory (
   DmOpenRef <code class="par">dbRef</code>,
   uint16_t <code class="par">*pIndex</code>,
   uint16_t <code class="par">offset</code>,
   int16_t <code class="par">direction</code>,
   uint16_t <code class="par">category</code>
)
</pre>
<h4>
  <a name="1078587"> </a>Parameters 
</h4>

<dl>
<dt><a name="1078588"> </a><code>&rarr;  <i>dbRef</i></code></dt>
<dd><a name="1078589"> </a><code>DmOpenRef</code> to an open database.</dd>

<dt><a name="1078590"> </a><code>&harr;  <i>pIndex</i></code></dt>
<dd><a name="1078591"> </a>The index to start the search at. Upon return, contains the index of the record at <code class="par">offset</code> from the index that you passed in. </dd>

<dt><a name="1078592"> </a><code>&rarr;  <i>offset</i></code></dt>
<dd><a name="1078593"> </a>Offset of the passed record index. This must be a positive number; use <code>dmSeekBackward</code> for the <code class="par">direction</code> parameter to search backwards.</dd>

<dt><a name="1078595"> </a><code>&rarr;  <i>direction</i></code></dt>
<dd><a name="1078596"> </a>Must be either <code>dmSeekForward</code> or <code>dmSeekBackward</code>.</dd>

<dt><a name="1078597"> </a><code>&rarr;  <i>category</i></code></dt>
<dd><a name="1078598"> </a>Category index.</dd>

</dl>
<h4>
  <a name="1078599"> </a>Returns 
</h4>

<p><a name="1078600"> </a>Returns <code>errNone</code> if no error; returns <code>dmErrIndexOutOfRange</code> or <code>dmErrSeekFailed</code> if an error occurred.</p>
<h4>
  <a name="1078601"> </a>Comments 
</h4>

<p><a name="1078602"> </a><code>DmFindRecordByOffsetInCategory()</code> searches for a record in the specified category. The search begins with the record at <code class="par">pIndex</code>. When it finds a record in the specified category, it decrements the <code class="par">offset</code> parameter and continues searching until a match is found and <code class="par">offset</code> is 0. </p>

<p><a name="1078603"> </a>Because of this, if you use <code>DmFindRecordByOffsetInCategory()</code> to find the nearest matching record in a particular category, you must pass different <code class="par">offset</code> parameters if the starting record is in the category than if it isn't. If the record at <code class="par">pIndex</code> is in the category, then you must pass an <code class="par">offset</code> of 1 to find the next record in the category because the comparison is performed before the <code class="par">pIndex</code> value changes. If the record at <code class="par">pIndex</code> isn't in the category, you must pass an <code class="par">offset</code> of 0 to find the next record in the category. In this case, an <code class="par">offset</code> of 1 skips the first matching record. </p>

<p><a name="1078604"> </a>Records that have the <code>deleted</code> bit set are ignored, and if the user has specified that private records should be hidden or masked, private records are ignored as well. </p>
<h4>
  <a name="1078605"> </a>See Also 
</h4>

<p><a name="1078612"> </a><a href="DataMgr.html#1002424"><code>DmNumRecordsInCategory()</code></a>, <a href="DataMgr.html#1003917"><code>DmQueryNextInCategory()</code></a>, <a href="DataMgr.html#1001572"><code>DmMoveCategory()</code></a></p>

<h3 class="hbH3">
  <a name="997720"> </a>DmFindResource Function <a href="#992934"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="1078942"> </a>Purpose 
</h4>

<p><a name="1078943"> </a>Search the given database for a resource by type and ID, or by pointer if it is non-<code>NULL</code>.</p>
<h4>
  <a name="1078944"> </a>Declared In 
</h4>
<code>DataMgr.h<a name="1078945"> </a></code><h4>
  <a name="1078946"> </a>Prototype 
</h4>
<pre class="proto"><a name="1078947"></a>uint16_t DmFindResource (
   DmOpenRef <code class="par">dbRef</code>,
   DmResourceType <code class="par">resType</code>,
   DmResourceID <code class="par">resID</code>,
   MemHandle <code class="par">hResource</code>
)
</pre>
<h4>
  <a name="1078948"> </a>Parameters 
</h4>

<dl>
<dt><a name="1078949"> </a><code>&rarr;  <i>dbRef</i></code></dt>
<dd><a name="1078950"> </a><code>DmOpenRef</code> to an open database.</dd>

<dt><a name="1078951"> </a><code>&rarr;  <i>resType</i></code></dt>
<dd><a name="1078952"> </a>Type of resource to search for.</dd>

<dt><a name="1078953"> </a><code>&rarr;  <i>resID</i></code></dt>
<dd><a name="1078954"> </a>ID of resource to search for.</dd>

<dt><a name="1078955"> </a><code>&rarr;  <i>hResource</i></code></dt>
<dd><a name="1078956"> </a>Pointer to locked resource, or <code>NULL</code>.</dd>

</dl>
<h4>
  <a name="1078957"> </a>Returns 
</h4>

<p><a name="1078958"> </a>Returns index of resource in resource database, or <code>dmInvalidRecIndex</code> if not found.</p>

<p><a name="1078959"> </a>May display a fatal error message if the database is not a resource database. </p>
<h4>
  <a name="1078960"> </a>Comments 
</h4>

<p><a name="1078961"> </a>Use this function to find a resource in a particular resource database by type and ID or by pointer. It is particularly useful when you want to search only one database for a resource and that database is not the topmost one. </p>

<div><hr>
  <a name="1078962"> </a> <b>IMPORTANT: </b> This function searches for the resource only in the database you specify. If you pass a pointer to a base resource database, its overlay is <i>not</i> searched. To search both a base database and its overlay for a localized resource, use <a href="DataMgr.html#998108"><code>DmGet1ResourceV50()</code></a> instead of this function.
<hr>
</div>

<p><a name="1078966"> </a>If <code class="par">hResource</code> is <code>NULL</code>, the resource is searched for by type and ID.</p>

<p><a name="1078967"> </a>If <code class="par">hResource</code> is not <code>NULL</code>, <code class="par">resType</code> and <code class="par">resID</code> are ignored and the index of the given locked resource is returned. </p>

<p><a name="1078968"> </a>Once the index of a resource is determined, it can be locked down and accessed by calling <a href="DataMgr.html#1000792"><code>DmGetResourceByIndex()</code></a>. </p>
<h4>
  <a name="1078972"> </a>See Also 
</h4>

<p><a name="1078979"> </a><a href="DataMgr.html#1000738"><code>DmGetResource()</code></a>, <a href="DataMgr.html#1006129"><code>DmSearchResourceOpenDatabases()</code></a>, <a href="DataMgr.html#1005302"><code>DmResourceInfo()</code></a>, <a href="DataMgr.html#1000792"><code>DmGetResourceByIndex()</code></a>, <a href="DataMgr.html#997774"><code>DmFindResourceType()</code></a></p>

<h3 class="hbH3">
  <a name="997774"> </a>DmFindResourceType Function <a href="#992934"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="1079421"> </a>Purpose 
</h4>

<p><a name="1079423"> </a>Search the given database for a resource by type and type index.</p>
<h4>
  <a name="1079424"> </a>Declared In 
</h4>
<code>DataMgr.h<a name="1079425"> </a></code><h4>
  <a name="1079426"> </a>Prototype 
</h4>
<pre class="proto"><a name="1079427"></a>uint16_t DmFindResourceType (
   DmOpenRef <code class="par">dbRef</code>,
   DmResourceType <code class="par">resType</code>,
   uint16_t <code class="par">typeIndex</code>
)
</pre>
<h4>
  <a name="1079428"> </a>Parameters 
</h4>

<dl>
<dt><a name="1079429"> </a><code>&rarr;  <i>dbRef</i></code></dt>
<dd><a name="1079430"> </a><code>DmOpenRef</code> to an open database.</dd>

<dt><a name="1079431"> </a><code>&rarr;  <i>resType</i></code></dt>
<dd><a name="1079432"> </a>Type of resource to search for.</dd>

<dt><a name="1079433"> </a><code>&rarr;  <i>typeIndex</i></code></dt>
<dd><a name="1079434"> </a>Index of given resource type.</dd>

</dl>
<h4>
  <a name="1079435"> </a>Returns 
</h4>

<p><a name="1079436"> </a>Index of resource in resource database, or <code>0xFFFF</code> if not found.</p>

<p><a name="1079437"> </a>May display a fatal error message if the database is not a resource database. </p>
<h4>
  <a name="1079438"> </a>Comments 
</h4>

<p><a name="1079439"> </a>Use this function to retrieve all the resources of a given type in a resource database. By starting at <code class="par">typeIndex</code> 0 and incrementing until an error is returned, the total number of resources of a given type and the index of each of these resources can be determined. Once the index of a resource is determined, it can be locked down and accessed by calling <a href="DataMgr.html#1000792"><code>DmGetResourceByIndex()</code></a>.</p>

<div><hr>
  <a name="1079443"> </a> <b>IMPORTANT: </b> This function searches for resources only in the database you specify. If you pass a pointer to a base resource database, its overlay is <i>not</i> searched. To search both a base database and its overlay for a localized resource, use <a href="DataMgr.html#998108"><code>DmGet1ResourceV50()</code></a> instead of this function.
<hr>
</div>
<h4>
  <a name="1079447"> </a>See Also 
</h4>

<p><a name="1079454"> </a><a href="DataMgr.html#1000738"><code>DmGetResource()</code></a>, <a href="DataMgr.html#1006129"><code>DmSearchResourceOpenDatabases()</code></a>, <a href="DataMgr.html#1005302"><code>DmResourceInfo()</code></a>, <a href="DataMgr.html#1000792"><code>DmGetResourceByIndex()</code></a>, <a href="DataMgr.html#997720"><code>DmFindResource()</code></a></p>

<h3 class="hbH3">
  <a name="998108"> </a>DmGet1ResourceV50 Function <a href="#992934"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="1079772"> </a>Purpose 
</h4>

<p><a name="1079773"> </a>Search the most recently opened resource database and return a handle to a resource given the resource type and ID.</p>
<h4>
  <a name="1079774"> </a>Declared In 
</h4>
<code>DataMgr.h<a name="1079775"> </a></code><h4>
  <a name="1079776"> </a>Prototype 
</h4>
<pre class="proto"><a name="1079777"></a>MemHandle DmGet1ResourceV50 (
   DmResourceType <code class="par">resType</code>,
   DmResourceID <code class="par">resID</code>
)
</pre>
<h4>
  <a name="1079778"> </a>Parameters 
</h4>

<dl>
<dt><a name="1079779"> </a><code>&rarr;  <i>resType</i></code></dt>
<dd><a name="1079780"> </a>The resource type.</dd>

<dt><a name="1079781"> </a><code>&rarr;  <i>resID</i></code></dt>
<dd><a name="1079782"> </a>The resource ID.</dd>

</dl>
<h4>
  <a name="1079783"> </a>Returns 
</h4>

<p><a name="1079784"> </a>Handle to resource data. If unsuccessful, this function returns <code>NULL</code> and <a href="DataMgr.html#998861"><code>DmGetLastErr()</code></a> returns an error code indicating the reason for failure.</p>
<h4>
  <a name="1079788"> </a>Comments 
</h4>

<p><a name="1079789"> </a>Searches the most recently opened resource database for a resource of the given type and ID. If the database has an overlay associated with it, the overlay is searched first, and then the base database is searched if the overlay does not contain the resource. If found, the resource handle is returned. The application should call <a href="DataMgr.html#1004572"><code>DmReleaseResource()</code></a> as soon as it finishes accessing the resource data. The resource handle is not locked by this function.</p>
<h4>
  <a name="1131791"> </a>Compatibility 
</h4>

<p><a name="1131792"> </a>This function is provided for compatibility purposes only. Palm OS Cobalt applications should use <a href="DataMgr.html#1000738"><code>DmGetResource()</code></a> or <a href="DataMgr.html#1000792"><code>DmGetResourceByIndex()</code></a> instead.</p>
<h4>
  <a name="1079793"> </a>See Also 
</h4>

<p><a name="1079800"> </a><a href="DataMgr.html#1000738"><code>DmGetResource()</code></a>, <a href="DataMgr.html#1004572"><code>DmReleaseResource()</code></a>, <a href="../User_Interface/UI_ResLoad.html#998513"><code>ResLoadConstant()</code></a></p>

<h3 class="hbH3">
  <a name="998154"> </a>DmGetAppInfo Function <a href="#992934"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="1080228"> </a>Purpose 
</h4>

<p><a name="1080229"> </a>Return the handle of the specified database's application info block.</p>
<h4>
  <a name="1080230"> </a>Declared In 
</h4>
<code>DataMgr.h<a name="1080231"> </a></code><h4>
  <a name="1080232"> </a>Prototype 
</h4>
<pre class="proto"><a name="1080233"></a>status_t DmGetAppInfo (
   DmOpenRef <code class="par">dbRef</code>,
   MemHandle <code class="par">*pAppInfoHandle</code>
)
</pre>
<h4>
  <a name="1080234"> </a>Parameters 
</h4>

<dl>
<dt><a name="1080235"> </a><code>&rarr;  <i>dbRef</i></code></dt>
<dd><a name="1080236"> </a><code>DmOpenRef</code> to an open database.</dd>

<dt><a name="1080237"> </a><code>&larr;  <i>pAppInfoHandle</i></code></dt>
<dd><a name="1080238"> </a>Memory handle of the application info block.</dd>

</dl>
<h4>
  <a name="1080239"> </a>Returns 
</h4>

<p><a name="1080240"> </a>Returns <code>errNone</code> if the handle was returned successfully, or one of the following if an error occurred: </p>

<dl>
<dt><a name="1080241"> </a><code>dmErrMemError</code></dt>
<dd><a name="1080242"> </a>A memory error occurred.</dd>

<dt><a name="1080243"> </a><code>memErrInvalidParam</code></dt>
<dd><a name="1080244"> </a>A memory error occurred.</dd>

</dl>
<h4>
  <a name="1130255"> </a>Compatibility 
</h4>

<p><a name="1130256"> </a>This function can be used with extended or classic databases. Note that schema databases don't have an explicit application info block.</p>

<h3 class="hbH3">
  <a name="998408"> </a>DmGetAppInfoIDV50 Function <a href="#992934"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="1080269"> </a>Purpose 
</h4>

<p><a name="1080270"> </a>Return the local ID of the specified database's application info block.</p>
<h4>
  <a name="1080271"> </a>Declared In 
</h4>
<code>DataMgr.h<a name="1080272"> </a></code><h4>
  <a name="1080273"> </a>Prototype 
</h4>
<pre class="proto"><a name="1080274"></a>LocalID DmGetAppInfoIDV50 (
   DmOpenRef <code class="par">dbRef</code>
)
</pre>
<h4>
  <a name="1080275"> </a>Parameters 
</h4>

<dl>
<dt><a name="1080276"> </a><code>&rarr;  <i>dbRef</i></code></dt>
<dd><a name="1080277"> </a><code>DmOpenRef</code> to an open database.</dd>

</dl>
<h4>
  <a name="1080278"> </a>Returns 
</h4>

<p><a name="1080279"> </a>Returns local ID of the application info block. The application info block is an optional field that the database may use to store application-specific information about the database; if the database doesn't have an application info block, <code>DmGetAppInfoIDV50()</code> returns zero.</p>
<h4>
  <a name="1130259"> </a>Compatibility 
</h4>

<p><a name="1130332"> </a>This function is provided for compatibility purposes only. Palm OS Cobalt applications will likely want to use <a href="DataMgr.html#998154"><code>DmGetAppInfo()</code></a> instead.</p>
<h4>
  <a name="1080280"> </a>See Also 
</h4>

<p><a name="1080287"> </a><a href="DataMgr.html#996192"><code>DmDatabaseInfo()</code></a>, <a href="DataMgr.html#1002512"><code>DmOpenDatabase()</code></a></p>

<h3 class="hbH3">
  <a name="998557"> </a>DmGetDatabaseLockState Function <a href="#992934"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="998562"> </a>Purpose 
</h4>

<p><a name="1080375"> </a>Return information about the number of locked and busy records in a RAM-based non-schema database.</p>
<h4>
  <a name="998567"> </a>Declared In 
</h4>
<code>DataMgr.h<a name="998570"> </a></code><h4>
  <a name="998572"> </a>Prototype 
</h4>
<pre class="proto"><a name="998575"></a>status_t DmGetDatabaseLockState (
   DmOpenRef <code class="par">dbRef</code>,
   uint8_t <code class="par">*pHighest</code>,
   uint32_t <code class="par">*pCount</code>,
   uint32_t <code class="par">*pBusy</code>
)
</pre>
<h4>
  <a name="998577"> </a>Parameters 
</h4>

<dl>
<dt><a name="1080389"> </a><code>&rarr;  <i>dbRef</i></code></dt>
<dd><a name="1080390"> </a><code>DmOpenRef</code> to an open database.</dd>

<dt><a name="1080391"> </a><code>&larr;  <i>pHighest</i></code></dt>
<dd><a name="1080392"> </a>The highest lock count found for all of the records in the database. If a database has two records, one has a lock count of 2 and one has a lock count of 1, the highest lock count is 2. Pass <code>NULL</code> for this parameter if you don't want to retrieve it. </dd>

<dt><a name="1080393"> </a><code>&larr;  <i>pCount</i></code></dt>
<dd><a name="1080394"> </a>The number of records that have the lock count that is returned in the <code class="par">pHighest</code> parameter. Pass <code>NULL</code> for this parameter if you don't want to retrieve it. </dd>

<dt><a name="1080395"> </a><code>&larr;  <i>pBusy</i></code></dt>
<dd><a name="1080396"> </a>The number of records that have the busy bit set. Pass <code>NULL</code> for this parameter if you don't want to retrieve it. </dd>

</dl>
<h4>
  <a name="998596"> </a>Returns 
</h4>

<p><a name="998599"> </a>Returns <code>errNone</code> if the operation completed successfully, or one of the following otherwise:</p>

<dl>
<dt><a name="1102680"> </a><code>dmErrInvalidParam</code></dt>
<dd><a name="1102697"> </a><code class="par">dbRef</code> doesn't reference an open database, or <code class="par">dbRef</code> references a schema database.</dd>

<dt><a name="1102748"> </a><code>memErrInvalidParam</code></dt>
<dd><a name="1102849"> </a>A memory error occurred.</dd>

</dl>
<h4>
  <a name="998601"> </a>Comments 
</h4>

<p><a name="1080412"> </a>This function is intended to be used for debugging purposes. You can use it to obtain information about how many records are busy and how much locking occurs.</p>

<p><a name="1157226"> </a>Because databases stored in ROM cannot be locked, if this function is used with a ROM-based database it returns <code>errNone</code> but <code>*</code><code class="par">pHighest</code>, <code>*</code><code class="par">pCount</code>, and <code>*</code><code class="par">pBusy</code> (if supplied) are all set to zero.</p>

<h3 class="hbH3">
  <a name="1157229"> </a>DmGetDatabaseV50 Function <a href="#992934"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="1080428"> </a>Purpose 
</h4>

<p><a name="1080429"> </a>Get the database header ID of a database, given its index and card number.</p>
<h4>
  <a name="1080430"> </a>Declared In 
</h4>
<code>DataMgr.h<a name="1080431"> </a></code><h4>
  <a name="1080432"> </a>Prototype 
</h4>
<pre class="proto"><a name="1080433"></a>LocalID DmGetDatabaseV50 (
   uint16_t <code class="par">cardNo</code>,
   uint16_t <code class="par">index</code>
)
</pre>
<h4>
  <a name="1080434"> </a>Parameters 
</h4>

<dl>
<dt><a name="1080435"> </a><code>&rarr;  <i>cardNo</i></code></dt>
<dd><a name="1080436"> </a>Card number of database. </dd>

<dt><a name="1080437"> </a><code>&rarr;  <i>index</i></code></dt>
<dd><a name="1080438"> </a>Index of database.</dd>

</dl>
<h4>
  <a name="1080439"> </a>Returns 
</h4>

<p><a name="1080440"> </a>Returns the database ID, or 0 if an invalid parameter is passed.</p>
<h4>
  <a name="1080441"> </a>Comments 
</h4>

<p><a name="1080442"> </a>Call this function to retrieve the database ID of a database by index. The index should range from 0 to <a href="DataMgr.html#1002211"><code>DmNumDatabases()</code></a>-1. </p>

<p><a name="1080446"> </a>This function is useful for getting a directory of all databases on a card. The databases returned may reside in either the ROM or the RAM. The order in which databases are returned is not fixed; therefore, you should not rely on receiving a list of databases in a particular order. </p>
<h4>
  <a name="1130439"> </a>Compatibility 
</h4>

<p><a name="1130480"> </a>This function is provided for compatibility purposes. Palm OS Cobalt applications that want to iterate through all of a handheld's databases should use <a href="DataMgr.html#999000"><code>DmGetNextDatabaseByTypeCreator()</code></a> instead.</p>
<h4>
  <a name="1080447"> </a>See Also 
</h4>

<p><a name="1080454"> </a><a href="DataMgr.html#1002512"><code>DmOpenDatabase()</code></a>, <a href="DataMgr.html#1002211"><code>DmNumDatabases()</code></a>, <a href="DataMgr.html#996192"><code>DmDatabaseInfo()</code></a>, <a href="DataMgr.html#996477"><code>DmDatabaseSize()</code></a></p>

<h3 class="hbH3">
  <a name="998819"> </a>DmGetFallbackOverlayLocale Function <a href="#992934"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="1080727"> </a>Purpose 
</h4>

<p><a name="1080728"> </a>Get the fallback overlay locale: the locale used when the Data Manager attempts to open an overlay locale for which no valid overlay exists.</p>
<h4>
  <a name="1080729"> </a>Declared In 
</h4>
<code>DataMgr.h<a name="1080730"> </a></code><h4>
  <a name="1080731"> </a>Prototype 
</h4>
<pre class="proto"><a name="1080732"></a>status_t DmGetFallbackOverlayLocale (
   LmLocaleType <code class="par">*fallbackLocale</code>
)
</pre>
<h4>
  <a name="1080733"> </a>Parameters 
</h4>

<dl>
<dt><a name="1080734"> </a><code>&larr;  <i>fallbackLocale</i></code></dt>
<dd><a name="1080735"> </a>Pointer to a structure into which the fallback overlay locale is written.</dd>

</dl>
<h4>
  <a name="1080736"> </a>Returns 
</h4>

<p><a name="1080737"> </a>Returns <code>errNone</code> if the fallback locale was obtained successfully, or <code>dmErrInvalidParam</code> if the <code class="par">fallbackLocale</code> parameter is invalid.</p>
<h4>
  <a name="1080738"> </a>Comments 
</h4>

<p><a name="1080739"> </a>The fallback overlay locale is used by the Data Manager when it attempts to automatically open an overlay using the overlay locale, but no valid overlay exists, and the base probably has been stripped.</p>
<h4>
  <a name="1080740"> </a>See Also 
</h4>

<p><a name="1080744"> </a><a href="DataMgr.html#999666"><code>DmGetOverlayDatabaseLocale()</code></a>, <a href="DataMgr.html#999814"><code>DmGetOverlayLocale()</code></a>, <a href="DataMgr.html#1006659"><code>DmSetFallbackOverlayLocale()</code></a></p>

<h3 class="hbH3">
  <a name="998861"> </a>DmGetLastErr Function <a href="#992934"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="1080774"> </a>Purpose 
</h4>

<p><a name="1080776"> </a>Return error code from last Data Manager call.</p>
<h4>
  <a name="1080777"> </a>Declared In 
</h4>
<code>DataMgr.h<a name="1080778"> </a></code><h4>
  <a name="1080779"> </a>Prototype 
</h4>
<pre class="proto"><a name="1080780"></a>status_t DmGetLastErr (
   void
)
</pre>
<h4>
  <a name="1080781"> </a>Parameters 
</h4>

<p><a name="1080782"> </a>None.</p>
<h4>
  <a name="1080783"> </a>Returns 
</h4>

<p><a name="1080784"> </a>Error code from last unsuccessful Data Manager call.</p>
<h4>
  <a name="1080785"> </a>Comments 
</h4>

<p><a name="1080786"> </a>Use this function to determine why a Data Manager call failed. In particular, calls like <a href="DataMgr.html#1000166"><code>DmGetRecord()</code></a> return 0 if unsuccessful, so calling <code>DmGetLastErr()</code> is the only way to determine why they failed.</p>

<p><a name="1080794"> </a>Note that <code>DmGetLastErr()</code> does not always reflect the error status of the last Data Manager call. Rather, it reflects the error status of Data Manager calls that don't return an error code. For some of those calls, the saved error code value is not set to 0 when the call is successful. </p>

<p><a name="1080798"> </a>For example, if a call to <a href="DataMgr.html#1002766"><code>DmOpenDatabaseByTypeCreator()</code></a> returns <code>NULL</code> for database reference (that is, it fails), <code>DmGetLastErr()</code> returns something meaningful; otherwise, it returns the error value of some previous Data Manager call. </p>

<p><a name="1080799"> </a>Only the Data Manager functions listed in <a href="DataMgr.html#1167956">Table 4.1</a> currently affect the value returned by <code>DmGetLastErr()</code>.</p>

<p class="caption"><a name="1167956"> </a><b>Table 4.1&nbsp;&nbsp;Functions that affect the value returned by DmGetLastErr() </b></p>
<div class="tablediv"><table cellspacing="0" class="tTable">

  <tr valign="top">
    <td><p class="tt"><a name="1167960"> </a><a href="SchemaDatabases.html#995782"><code>DbCursorGetRowCount()</code></a></p>
    </td>
    <td><p class="tt"><a name="1167962"> </a><a href="SchemaDatabases.html#995913"><code>DbCursorIsBOF()</code></a></p>
    </td>
  </tr>
  <tr valign="top">
    <td><p class="tt"><a name="1167964"> </a><a href="SchemaDatabases.html#995963"><code>DbCursorIsDeleted()</code></a></p>
    </td>
    <td><p class="tt"><a name="1167966"> </a><a href="SchemaDatabases.html#996005"><code>DbCursorIsEOF()</code></a></p>
    </td>
  </tr>
  <tr valign="top">
    <td><p class="tt"><a name="1167968"> </a><a href="SchemaDatabases.html#999489"><code>DbHasTable()</code></a></p>
    </td>
    <td><p class="tt"><a name="1167970"> </a><a href="SchemaDatabases.html#1000351"><code>DbOpenDatabase()</code></a></p>
    </td>
  </tr>
  <tr valign="top">
    <td><p class="tt"><a name="1167972"> </a><a href="SchemaDatabases.html#1000405"><code>DbOpenDatabaseByName()</code></a></p>
    </td>
    <td><p class="tt"><a name="1167974"> </a><a href="DataMgr.html#1077521"><code>DmFindDatabase()</code></a></p>
    </td>
  </tr>
  <tr valign="top">
    <td><p class="tt"><a name="1167976"> </a><a href="DataMgr.html#997169"><code>DmFindDatabaseByTypeCreator()</code></a></p>
    </td>
    <td><p class="tt"><a name="1167978"> </a><a href="DataMgr.html#997495"><code>DmFindDatabaseV50()</code></a></p>
    </td>
  </tr>
  <tr valign="top">
    <td><p class="tt"><a name="1167980"> </a><a href="DataMgr.html#997658"><code>DmFindRecordByOffsetInCategory()</code></a></p>
    </td>
    <td><p class="tt"><a name="1167982"> </a><a href="DataMgr.html#997720"><code>DmFindResource()</code></a></p>
    </td>
  </tr>
  <tr valign="top">
    <td><p class="tt"><a name="1167984"> </a><a href="DataMgr.html#997774"><code>DmFindResourceType()</code></a></p>
    </td>
    <td><p class="tt"><a name="1167986"> </a><a href="DataMgr.html#998408"><code>DmGetAppInfoIDV50()</code></a></p>
    </td>
  </tr>
  <tr valign="top">
    <td><p class="tt"><a name="1167988"> </a><a href="DataMgr.html#1157229"><code>DmGetDatabaseV50()</code></a></p>
    </td>
    <td><p class="tt"><a name="1167990"> </a><a href="DataMgr.html#1000116"><code>DmGetPositionInCategory()</code></a></p>
    </td>
  </tr>
  <tr valign="top">
    <td><p class="tt"><a name="1167992"> </a><a href="DataMgr.html#1000166"><code>DmGetRecord()</code></a></p>
    </td>
    <td><p class="tt"><a name="1167994"> </a><a href="DataMgr.html#1000738"><code>DmGetResource()</code></a></p>
    </td>
  </tr>
  <tr valign="top">
    <td><p class="tt"><a name="1167996"> </a><a href="DataMgr.html#1000792"><code>DmGetResourceByIndex()</code></a></p>
    </td>
    <td><p class="tt"><a name="1167998"> </a><a href="DataMgr.html#1000838"><code>DmGetResourceV50()</code></a></p>
    </td>
  </tr>
  <tr valign="top">
    <td><p class="tt"><a name="1168000"> </a><a href="DataMgr.html#998108"><code>DmGet1ResourceV50()</code></a></p>
    </td>
    <td><p class="tt"><a name="1168002"> </a><a href="DataMgr.html#1001715"><code>DmNewHandle()</code></a></p>
    </td>
  </tr>
  <tr valign="top">
    <td><p class="tt"><a name="1168004"> </a><a href="DataMgr.html#1001785"><code>DmNewRecord()</code></a></p>
    </td>
    <td><p class="tt"><a name="1168006"> </a><a href="DataMgr.html#1001870"><code>DmNewResource()</code></a></p>
    </td>
  </tr>
  <tr valign="top">
    <td><p class="tt"><a name="1168008"> </a><a href="DataMgr.html#1001948"><code>DmNextOpenDatabase()</code></a></p>
    </td>
    <td><p class="tt"><a name="1168010"> </a><a href="DataMgr.html#1086376"><code>DmNextOpenDatabaseV50()</code></a></p>
    </td>
  </tr>
  <tr valign="top">
    <td><p class="tt"><a name="1168012"> </a><a href="DataMgr.html#1002084"><code>DmNextOpenResDatabase()</code></a></p>
    </td>
    <td><p class="tt"><a name="1168014"> </a><a href="DataMgr.html#1002126"><code>DmNextOpenResDatabaseV50()</code></a></p>
    </td>
  </tr>
  <tr valign="top">
    <td><p class="tt"><a name="1168016"> </a><a href="DataMgr.html#1002211"><code>DmNumDatabases()</code></a></p>
    </td>
    <td><p class="tt"><a name="1168018"> </a><a href="DataMgr.html#1002275"><code>DmNumDatabasesV50()</code></a></p>
    </td>
  </tr>
  <tr valign="top">
    <td><p class="tt"><a name="1168020"> </a><a href="DataMgr.html#1002317"><code>DmNumRecords()</code></a></p>
    </td>
    <td><p class="tt"><a name="1168022"> </a><a href="DataMgr.html#1002424"><code>DmNumRecordsInCategory()</code></a></p>
    </td>
  </tr>
  <tr valign="top">
    <td><p class="tt"><a name="1168024"> </a><a href="DataMgr.html#1002470"><code>DmNumResources()</code></a></p>
    </td>
    <td><p class="tt"><a name="1168026"> </a><a href="DataMgr.html#1002512"><code>DmOpenDatabase()</code></a></p>
    </td>
  </tr>
  <tr valign="top">
    <td><p class="tt"><a name="1168028"> </a><a href="DataMgr.html#1002766"><code>DmOpenDatabaseByTypeCreator()</code></a></p>
    </td>
    <td><p class="tt"><a name="1168030"> </a><a href="DataMgr.html#1003062"><code>DmOpenDBNoOverlay()</code></a></p>
    </td>
  </tr>
  <tr valign="top">
    <td><p class="tt"><a name="1168032"> </a><a href="DataMgr.html#1003917"><code>DmQueryNextInCategory()</code></a></p>
    </td>
    <td><p class="tt"><a name="1168034"> </a><a href="DataMgr.html#1004199"><code>DmQueryRecord()</code></a></p>
    </td>
  </tr>
  <tr valign="top">
    <td><p class="tt"><a name="1168036"> </a><a href="DataMgr.html#1005163"><code>DmResizeRecord()</code></a></p>
    </td>
    <td><p class="tt"><a name="1168038"> </a><a href="DataMgr.html#1005213"><code>DmResizeResource()</code></a></p>
    </td>
  </tr>
  <tr valign="top">
    <td><p class="tt"><a name="1168040"> </a><a href="DataMgr.html#1006040"><code>DmSearchRecordOpenDatabases()</code></a></p>
    </td>
    <td><p class="tt"><a name="1168042"> </a><a href="DataMgr.html#1006129"><code>DmSearchResourceOpenDatabases()</code></a></p>
    </td>
  </tr>
</table>

</div>


<h3 class="hbH3">
  <a name="999000"> </a>DmGetNextDatabaseByTypeCreator Function <a href="#992934"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="999005"> </a>Purpose 
</h4>

<p><a name="999008"> </a>Iterate to the next database that meets the criteria set forth in a previous call to <a href="DataMgr.html#1003442"><code>DmOpenIteratorByTypeCreator()</code></a>.</p>
<h4>
  <a name="999010"> </a>Declared In 
</h4>
<code>DataMgr.h<a name="999013"> </a></code><h4>
  <a name="999015"> </a>Prototype 
</h4>
<pre class="proto"><a name="999018"></a>status_t DmGetNextDatabaseByTypeCreator (
   DmSearchStatePtr <code class="par">stateInfoP</code>,
   DatabaseID <code class="par">*dbIDP</code>,
   DmDatabaseInfoPtr <code class="par">databaseInfoP</code>
)
</pre>
<h4>
  <a name="999020"> </a>Parameters 
</h4>

<dl>
<dt><a name="999023"> </a><code>&rarr;  <i>stateInfoP</i></code></dt>
<dd><a name="1098556"> </a>Pointer to the <a href="DataMgr.html#993964"><code>DmSearchStateType</code></a> structure originally supplied to <a href="DataMgr.html#1003442"><code>DmOpenIteratorByTypeCreator()</code></a>.</dd>

<dt><a name="999027"> </a><code>&larr;  <i>dbIDP</i></code></dt>
<dd><a name="1131270"> </a>Pointer to a location into which the ID of the found database is written (a value of zero is written if a database meeting the specified criteria isn't found). Pass <code>NULL</code> if the ID of the database isn't needed.</dd>

<dt><a name="1131271"> </a><code>&larr;  <i>databaseInfoP</i></code></dt>
<dd><a name="1098948"> </a>Pointer to a <a href="DataMgr.html#993322"><code>DmDatabaseInfoType</code></a> structure which is filled out appropriately for the found database. Pass <code>NULL</code> if this information isn't needed.</dd>

</dl>
<h4>
  <a name="999035"> </a>Returns 
</h4>

<p><a name="999038"> </a>Returns <code>errNone</code> if a database meeting the specified criteria is found, <code>dmErrCantFind</code> if there are no additional databases meeting the specified criteria, or one of the following if an error occurred:</p>

<dl>
<dt><a name="1098569"> </a><code>dmErrInvalidParam</code></dt>
<dd><a name="1098574"> </a>The <code class="par">find</code> parameter passed to <a href="DataMgr.html#1003442"><code>DmOpenIteratorByTypeCreator()</code></a> did not contain at least one of the defined database type flags.</dd>

</dl>
<h4>
  <a name="999040"> </a>Comments 
</h4>

<p><a name="999043"> </a>Both <code class="par">dbIDP</code> and <code class="par">databaseInfoP</code> are optional; pass <code>NULL</code> for both if you only need to know if there exists a database that meets your particular criteria. Otherwise, pass pointers as appropriate for one or both.</p>

<p><a name="1099859"> </a>This function searches all heaps for a match.</p>

<p><a name="1100640"> </a>To start the search, allocate a <code>DmSearchStateType</code> structure and pass it as the <code class="par">stateInfoP</code> parameter in a call to <a href="DataMgr.html#1003442"><code>DmOpenIteratorByTypeCreator()</code></a>. Then, call <code>DmGetNextDatabaseByTypeCreator()</code>. Note that you need to call this function repeatedly to discover all databases having a specified type/creator pair. Finally, be sure to call <a href="DataMgr.html#995734"><code>DmCloseIteratorByTypeCreator()</code></a> to finalize the iteration.</p>

<p><a name="1099962"> </a>You can pass <code>dmSearchWildcardID</code> for the <code class="par">type</code> or <code class="par">creator</code> parameter to conduct searches of wider scope. If the <code class="par">type</code> parameter is <code>dmSearchWildcardID</code>, this function can be called successively to return all databases of the given creator. If the <code class="par">creator</code> parameter is <code>dmSearchWildcardID</code>, this function can be called successively to return all databases of the given type. You can also pass <code>dmSearchWildcardID</code> as the value for both of these parameters to return all available databases without regard to type or creator.</p>

<p><a name="1099963"> </a>Because databases are scattered freely throughout memory space, they are not returned in any particular order&#8212;any database matching the specified type/creator criteria can be returned. Thus, if the value of the <code class="par">onlyLatestVers</code> parameter is <code>false</code>, this function may return a database which is not the most recent version matching the specified type/creator pair. To obtain only the latest version of a database matching the search criteria, set the value of the <code class="par">onlyLatestVers</code> parameter to <code>true</code>. </p>

<p><a name="1099964"> </a>When determining which is the latest version of the database, RAM databases are considered newer than ROM databases that have the same version number. Because of this, you can replace any ROM-based application with your own version of it.</p>

<p><a name="1101038"> </a>If <code class="par">onlyLatestVers</code> is <code>true</code>, you only receive one matching database for each type/creator pair. Note that the behavior is different only when you have specified a value for both <code class="par">type</code> and <code class="par">creator</code> and <code class="par">onlyLatestVers</code> is <code>true</code>.</p>
<h4>
  <a name="1100794"> </a>Example 
</h4>

<p><a name="1100795"> </a>The following code excerpt illustrates how to iterate through the latest versions of all schema databases on the device that have a given type and creator.</p>

<div class="CodeRule"><hr></div><pre class="CodeBlock">
status_t err; <a name="1190666"> </a>
DmSearchStateType state; <a name="1190667"> </a>
DatabaseID dbID = NULL;<a name="1190668"> </a>
uint32_t creator;<a name="1190669"> </a>
char name[dmDBNameLength];<a name="1190670"> </a>
DmDatabaseInfoType databaseInfo;<a name="1190671"> </a>
<a name="1190672"> </a>
// Initialize the DmDatabaseInfoType structure<a name="1190673"> </a>
memset(&amp;databaseInfo, 0x0, sizeof(DmDatabaseInfoType));<a name="1190674"> </a>
databaseInfo.name = name;<a name="1190675"> </a>
databaseInfo.creator = &amp;creator;<a name="1190676"> </a>
<a name="1190677"> </a>
err = DmOpenIteratorByTypeCreator(&amp;state, myType, myCreator,
   true, dmHdrAttrSchema);<a name="1097892"> </a>
while (err == errNone) {<a name="1097893"> </a>
   err = DmGetNextDatabaseByTypeCreator(&amp;state, &amp;dbID,
      &amp;databaseInfo);<a name="1097894"> </a>
   if (err == errNone) {<a name="1099098"> </a>
      // a database was found; the ID is in dbID, and info<a name="1099111"> </a>
      // about the database is in databaseInfo. Do something<a name="1099120"> </a>
      // with this information here.<a name="1099145"> </a>
   }<a name="1099129"> </a>
}<a name="1099022"> </a>
DmCloseIteratorByTypeCreator(&amp;state);<a name="1097895"> </a>
</pre><div class="CodeRule"><hr></div>

<h4>
  <a name="999045"> </a>See Also 
</h4>

<p><a name="999048"> </a><a href="DataMgr.html#1077521"><code>DmFindDatabase()</code></a>, <a href="DataMgr.html#997169"><code>DmFindDatabaseByTypeCreator()</code></a>, <a href="DataMgr.html#1003442"><code>DmOpenIteratorByTypeCreator()</code></a>, <a href="DataMgr.html#995734"><code>DmCloseIteratorByTypeCreator()</code></a></p>

<h3 class="hbH3">
  <a name="999050"> </a>DmGetNextDatabaseByTypeCreatorV50 Function <a href="#992934"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="1081269"> </a>Purpose 
</h4>

<p><a name="1081270"> </a>Return the header ID and card number for a classic database or an extended resource database given the type, the creator, or both. This function searches all heaps for a match. </p>
<h4>
  <a name="1081271"> </a>Declared In 
</h4>
<code>DataMgr.h<a name="1081272"> </a></code><h4>
  <a name="1081273"> </a>Prototype 
</h4>
<pre class="proto"><a name="1081274"></a>status_t DmGetNextDatabaseByTypeCreatorV50 (
   Boolean <code class="par">newSearch</code>,
   DmSearchStatePtr <code class="par">stateInfoP</code>,
   uint32_t <code class="par">type</code>,
   uint32_t <code class="par">creator</code>,
   Boolean <code class="par">onlyLatestVers</code>,
   uint16_t <code class="par">*cardNoP</code>,
   LocalID <code class="par">*dbIDP</code>
)
</pre>
<h4>
  <a name="1081275"> </a>Parameters 
</h4>

<dl>
<dt><a name="1081276"> </a><code>&rarr;  <i>newSearch</i></code></dt>
<dd><a name="1081277"> </a><code>true</code> if starting a new search.</dd>

<dt><a name="1081278"> </a><code>&harr;  <i>stateInfoP</i></code></dt>
<dd><a name="1081279"> </a>If <code class="par">newSearch</code> is <code>false</code>, this must point to the same data used for the previous invocation. </dd>

<dt><a name="1081280"> </a><code>&rarr;  <i>type</i></code></dt>
<dd><a name="1081281"> </a>Type of database to search for. Pass <code>dmSearchWildcardID</code> to find databases with any type.</dd>

<dt><a name="1081282"> </a><code>&rarr;  <i>creator</i></code></dt>
<dd><a name="1081283"> </a>Creator of database to search for. Pass <code>dmSearchWildcardID</code> to find databases with any creator.</dd>

<dt><a name="1081284"> </a><code>&rarr;  <i>onlyLatestVers</i></code></dt>
<dd><a name="1081285"> </a>If <code>true</code>, only the latest version of a database with a given type and creator is returned.</dd>

<dt><a name="1081286"> </a><code>&larr;  <i>cardNoP</i></code></dt>
<dd><a name="1081287"> </a>On exit, the card number of the found database. Pass <code>NULL</code> if you don't need the card number (note that as in Palm OS Cobalt the card number is always zero).</dd>

<dt><a name="1081288"> </a><code>&larr;  <i>dbIDP</i></code></dt>
<dd><a name="1081289"> </a>Local ID of the found database. Pass <code>NULL</code> if you don't need the database's local ID.</dd>

</dl>
<h4>
  <a name="1081290"> </a>Returns 
</h4>

<p><a name="1081291"> </a>Returns <code>errNone</code> if no error, or <code>dmErrCantFind</code> if no matches were found.</p>
<h4>
  <a name="1081292"> </a>Comments 
</h4>

<p><a name="1081293"> </a>You may need to call this function successively to discover all databases having a specified type/creator pair. </p>

<p><a name="1081294"> </a>To start the search, pass <code>true</code> for <code class="par">newSearch</code>. Allocate a <code>DmSearchStateType</code> structure and pass it as the <code class="par">stateInfoP</code> parameter. <code>DmGetNextDatabaseByTypeCreator()</code> stores private information in <code class="par">stateInfoP</code> and uses it if the search is continued. </p>

<p><a name="1081296"> </a>To continue a search where the previous one left off, pass <code>false</code> for <code class="par">newSearch</code> and pass the same <code class="par">stateInfoP</code> that you used during the previous call to this function. </p>

<p><a name="1081297"> </a>You can pass <code>dmSearchWildcardID</code> for the <code class="par">type</code> or <code class="par">creator</code> parameter to conduct searches of wider scope. If the <code class="par">type</code> parameter is <code>dmSearchWildcardID</code>, this function can be called successively to return all databases of the given creator. If the <code class="par">creator</code> parameter is <code>dmSearchWildcardID</code>, this function can be called successively to return all databases of the given type. You can also pass <code>dmSearchWildcardID</code> as the value for both of these parameters to return all available databases without regard to type or creator.</p>

<p><a name="1081298"> </a>Because databases are scattered freely throughout memory space, they are not returned in any particular order&#8212;any database matching the specified type/creator criteria can be returned.Thus, if the value of the <code class="par">onlyLatestVers</code> parameter is <code>false</code>, this function may return a database which is not the most recent version matching the specified type/creator pair. To obtain only the latest version of a database matching the search criteria, set the value of the <code class="par">onlyLatestVers</code> parameter to <code>true</code>. </p>

<p><a name="1081299"> </a>When determining which is the latest version of the database, RAM databases are considered newer than ROM databases that have the same version number. Because of this, you can replace any ROM-based application with your own version of it. Also, a RAM database on card 1 is considered newer than a RAM database on card 0 if the version numbers are identical. </p>

<div><hr>
  <a name="1081300"> </a> <span class="warning">WARNING! </span> Don't create or delete a database while using <code>DmGetNextDatabaseByTypeCreatorV50()</code> to iterate through the existing databases. This could cause databases to be skipped, or it could result in a given database being returned more than once.
<hr>
</div>

<p><a name="1081301"> </a>If <code class="par">onlyLatestVers</code> is <code>true</code>, you only receive one matching database for each type/creator pair. Note that the behavior is different only when you have specified a value for both <code class="par">type</code> and <code class="par">creator</code> and <code class="par">onlyLatestVers</code> is <code>true</code>.</p>

<p><a name="1081302"> </a>If you expect multiple databases to match your search criteria, make sure you call <code>DmGetNextDatabaseByTypeCreator()</code> in one of the following ways to ensure that your code operates the same on all Palm OS versions:</p>
<ul type="disc">
  <li><a name="1081303"> </a>Set <code class="par">onlyLatestVers</code> to <code>false</code> if you specify both a <code class="par">type</code> and <code class="par">creator</code>. 
  <li><a name="1081304"> </a>Specify <code>0</code> for either the <code class="par">type</code> or <code class="par">creator</code> parameter (or both). 
</ul>
<h4>
  <a name="1131244"> </a>Compatibility 
</h4>

<p><a name="1131245"> </a>This function is provided for compatibility purposes only. Most Palm OS Cobalt applications will want to use <a href="DataMgr.html#999000"><code>DmGetNextDatabaseByTypeCreator()</code></a> instead; that function (in conjunction with <a href="DataMgr.html#1003442"><code>DmOpenIteratorByTypeCreator()</code></a> and <a href="DataMgr.html#995734"><code>DmCloseIteratorByTypeCreator()</code></a>) can be used to locate classic, extended, or schema databases.</p>
<h4>
  <a name="1081305"> </a>See Also 
</h4>

<p><a name="1081315"> </a><a href="DataMgr.html#1077521"><code>DmFindDatabase()</code></a>, <a href="DataMgr.html#996192"><code>DmDatabaseInfo()</code></a>, <a href="DataMgr.html#1002766"><code>DmOpenDatabaseByTypeCreator()</code></a>, <a href="DataMgr.html#996477"><code>DmDatabaseSize()</code></a></p>

<h3 class="hbH3">
  <a name="999324"> </a>DmGetOpenInfo Function <a href="#992934"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="1081756"> </a>Purpose 
</h4>

<p><a name="1081757"> </a>Retrieve information about an open database.</p>
<h4>
  <a name="1081758"> </a>Declared In 
</h4>
<code>DataMgr.h<a name="1081759"> </a></code><h4>
  <a name="1081760"> </a>Prototype 
</h4>
<pre class="proto"><a name="1081761"></a>status_t DmGetOpenInfo (
   DmOpenRef <code class="par">dbRef</code>,
   DatabaseID <code class="par">*pDbID</code>,
   uint16_t <code class="par">*pOpenCount</code>,
   DmOpenModeType <code class="par">*pOpenMode</code>,
   Boolean <code class="par">*pResDB</code>
)
</pre>
<h4>
  <a name="1081762"> </a>Parameters 
</h4>

<dl>
<dt><a name="1081763"> </a><code>&rarr;  <i>dbRef</i></code></dt>
<dd><a name="1081764"> </a><code>DmOpenRef</code> to an open database.</dd>

<dt><a name="1081765"> </a><code>&larr;  <i>pDbID</i></code></dt>
<dd><a name="1081766"> </a>ID of the database. Pass <code>NULL</code> for this parameter if you don't want to retrieve this information.</dd>

<dt><a name="1081767"> </a><code>&larr;  <i>pOpenCount</i></code></dt>
<dd><a name="1081768"> </a>Number of applications that have this database open. Pass <code>NULL</code> for this parameter if you don't want to retrieve this information.</dd>

<dt><a name="1081769"> </a><code>&larr;  <i>pOpenMode</i></code></dt>
<dd><a name="1081773"> </a>Mode used to open the database (see <a href="DataMgr.html#1146522"><code>DmOpenModeType</code></a>). Pass <code>NULL</code> for this parameter if you don't want to retrieve this information.</dd>

<dt><a name="1081774"> </a><code>&larr;  <i>pResDB</i></code></dt>
<dd><a name="1081775"> </a>If <code>true</code> upon return, the database is a resource database. Otherwise, the database is a record database. Pass <code>NULL</code> for this parameter if you don't want to retrieve this information.</dd>

</dl>
<h4>
  <a name="1081776"> </a>Returns 
</h4>

<p><a name="1081777"> </a>Returns <code>errNone</code> if no error. </p>
<h4>
  <a name="1081778"> </a>See Also 
</h4>

<p><a name="1081782"> </a><a href="DataMgr.html#996192"><code>DmDatabaseInfo()</code></a> </p>

<h3 class="hbH3">
  <a name="999666"> </a>DmGetOverlayDatabaseLocale Function <a href="#992934"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="1081798"> </a>Purpose 
</h4>

<p><a name="1081799"> </a>Return an overlay database's locale given its name. </p>
<h4>
  <a name="1081800"> </a>Declared In 
</h4>
<code>DataMgr.h<a name="1081801"> </a></code><h4>
  <a name="1081802"> </a>Prototype 
</h4>
<pre class="proto"><a name="1081803"></a>status_t DmGetOverlayDatabaseLocale (
   const char <code class="par">*overlayDBName</code>,
   LmLocaleType <code class="par">*overlayLocale</code>
)
</pre>
<h4>
  <a name="1081804"> </a>Parameters 
</h4>

<dl>
<dt><a name="1081805"> </a><code>&rarr;  <i>overlayDBName</i></code></dt>
<dd><a name="1081806"> </a>The name of the overlay database. </dd>

<dt><a name="1081807"> </a><code>&larr;  <i>overlayLocale</i></code></dt>
<dd><a name="1081811"> </a>Points to an <code>LmLocaleType</code> structure into which the overlay's locale is written. Your application must allocate and pass a pointer to this structure.</dd>

</dl>
<h4>
  <a name="1081812"> </a>Returns 
</h4>

<p><a name="1081813"> </a>Returns <code>errNone</code> upon success, or one of the following if an error occurred:</p>

<dl>
<dt><a name="1081814"> </a><code>dmErrInvalidParam</code></dt>
<dd><a name="1081815"> </a>The function received an invalid parameter.</dd>

<dt><a name="1081816"> </a><code>dmErrBadOverlayDBName</code></dt>
<dd><a name="1081817"> </a>The <code class="par">overlayDBName</code> parameter doesn't point to the name of an overlay database.</dd>

</dl>

<h3 class="hbH3">
  <a name="999764"> </a>DmGetOverlayDatabaseName Function <a href="#992934"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="1081825"> </a>Purpose 
</h4>

<p><a name="1081826"> </a>Return the overlay database's name given the base database name and the locale. </p>
<h4>
  <a name="1081827"> </a>Declared In 
</h4>
<code>DataMgr.h<a name="1081828"> </a></code><h4>
  <a name="1081829"> </a>Prototype 
</h4>
<pre class="proto"><a name="1081830"></a>status_t DmGetOverlayDatabaseName (
   const char <code class="par">*baseDBName</code>,
   const LmLocaleType <code class="par">*targetLocale</code>,
   char <code class="par">*overlayDBName</code>
)
</pre>
<h4>
  <a name="1081831"> </a>Parameters 
</h4>

<dl>
<dt><a name="1081832"> </a><code>&rarr;  <i>baseDBName</i></code></dt>
<dd><a name="1081833"> </a>The name of the base database with which the overlay is associated. </dd>

<dt><a name="1081834"> </a><code>&rarr;  <i>targetLocale</i></code></dt>
<dd><a name="1081838"> </a>The locale to which this overlay applies. See <code>LmLocaleType</code>. Pass <code>NULL</code> to use the current locale. </dd>

<dt><a name="1081839"> </a><code>&larr;  <i>overlayDBName</i></code></dt>
<dd><a name="1081840"> </a>Pointer to a buffer into which the overlay database name is written. This buffer must be at least <code>dmDBNameLength</code> bytes. </dd>

</dl>
<h4>
  <a name="1081841"> </a>Returns 
</h4>

<p><a name="1081842"> </a>Returns <code>errNone</code> upon success, or <code>dmErrInvalidParam</code> if one of the parameters is invalid. </p>

<h3 class="hbH3">
  <a name="999814"> </a>DmGetOverlayLocale Function <a href="#992934"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="1081856"> </a>Purpose 
</h4>

<p><a name="1081857"> </a>Get the Data Manager's overlay locale: the locale used by the Data Manager when it attempts to automatically open overlays.</p>
<h4>
  <a name="1081858"> </a>Declared In 
</h4>
<code>DataMgr.h<a name="1081859"> </a></code><h4>
  <a name="1081860"> </a>Prototype 
</h4>
<pre class="proto"><a name="1081861"></a>status_t DmGetOverlayLocale (
   LmLocaleType <code class="par">*overlayLocale</code>
)
</pre>
<h4>
  <a name="1081862"> </a>Parameters 
</h4>

<dl>
<dt><a name="1081863"> </a><code>&larr;  <i>overlayLocale</i></code></dt>
<dd><a name="1081867"> </a>Pointer to an <code>LmLocaleType</code> structure into which the overlay's locale is written. Your application must allocate and pass a pointer to this structure.</dd>

</dl>
<h4>
  <a name="1081868"> </a>Returns 
</h4>

<p><a name="1081869"> </a>Returns <code>errNone</code> upon success, or <code>dmErrInvalidParam</code> if one of the parameters is invalid. </p>
<h4>
  <a name="1081870"> </a>See Also 
</h4>

<p><a name="1081874"> </a><a href="DataMgr.html#999666"><code>DmGetOverlayDatabaseLocale()</code></a>, <a href="DataMgr.html#1006917"><code>DmSetOverlayLocale()</code></a></p>

<h3 class="hbH3">
  <a name="1000116"> </a>DmGetPositionInCategory Function <a href="#992934"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="1082246"> </a>Purpose 
</h4>

<p><a name="1082247"> </a>Return a position of a record within the specified category. </p>
<h4>
  <a name="1082248"> </a>Declared In 
</h4>
<code>DataMgr.h<a name="1082249"> </a></code><h4>
  <a name="1082250"> </a>Prototype 
</h4>
<pre class="proto"><a name="1082251"></a>uint16_t DmGetPositionInCategory (
   DmOpenRef <code class="par">dbRef</code>,
   uint16_t <code class="par">index</code>,
   uint16_t <code class="par">category</code>
)
</pre>
<h4>
  <a name="1082252"> </a>Parameters 
</h4>

<dl>
<dt><a name="1082253"> </a><code>&rarr;  <i>dbRef</i></code></dt>
<dd><a name="1082254"> </a><code>DmOpenRef</code> to an open database.</dd>

<dt><a name="1082255"> </a><code>&rarr;  <i>index</i></code></dt>
<dd><a name="1082256"> </a>Index of the record.</dd>

<dt><a name="1082257"> </a><code>&rarr;  <i>category</i></code></dt>
<dd><a name="1082258"> </a>Index of category to search.</dd>

</dl>
<h4>
  <a name="1082259"> </a>Returns 
</h4>

<p><a name="1082260"> </a>Returns the position (zero-based). If the specified index is out of range, this function returns 0 and <a href="DataMgr.html#998861"><code>DmGetLastErr()</code></a> returns an error code indicating the reason for failure. Note that this means a 0 return value might indicate either success or failure. If this function returns 0 and <code>DmGetLastErr()</code> returns <code>errNone</code>, the return value indicates that this is the first record in the category. </p>
<h4>
  <a name="1082264"> </a>Comments 
</h4>

<p><a name="1082265"> </a>Because this function must examine all records up to the current record, it can be slow to return, especially when called on a large database.</p>

<p><a name="1082266"> </a>Records that have the <code>deleted</code> bit set are ignored, and if the user has specified that private records should be hidden or masked, private records are ignored as well. </p>

<p><a name="1082268"> </a>If the record is ROM-based (pointer accessed) this function makes a fake handle to it and stores this handle in the <code>DmAccessType</code> structure.</p>

<p><a name="1082272"> </a>To learn which category a record is in, use <a href="DataMgr.html#1000470"><code>DmGetRecordCategory()</code></a>. </p>
<h4>
  <a name="1082273"> </a>See Also 
</h4>

<p><a name="1082277"> </a><a href="DataMgr.html#1003917"><code>DmQueryNextInCategory()</code></a>, <a href="DataMgr.html#997658"><code>DmFindRecordByOffsetInCategory()</code></a>, <a href="DataMgr.html#1001572"><code>DmMoveCategory()</code></a></p>

<h3 class="hbH3">
  <a name="1000166"> </a>DmGetRecord Function <a href="#992934"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="1082446"> </a>Purpose 
</h4>

<p><a name="1082447"> </a>Return a handle to a record by index and mark the record busy.</p>
<h4>
  <a name="1082448"> </a>Declared In 
</h4>
<code>DataMgr.h<a name="1082449"> </a></code><h4>
  <a name="1082450"> </a>Prototype 
</h4>
<pre class="proto"><a name="1082451"></a>MemHandle DmGetRecord (
   DmOpenRef <code class="par">dbRef</code>,
   uint16_t <code class="par">index</code>
)
</pre>
<h4>
  <a name="1082452"> </a>Parameters 
</h4>

<dl>
<dt><a name="1082453"> </a><code>&rarr;  <i>dbRef</i></code></dt>
<dd><a name="1082454"> </a><code>DmOpenRef</code> to an open database.</dd>

<dt><a name="1082455"> </a><code>&rarr;  <i>index</i></code></dt>
<dd><a name="1082456"> </a>Which record to retrieve.</dd>

</dl>
<h4>
  <a name="1082457"> </a>Returns 
</h4>

<p><a name="1082458"> </a>Returns a handle to record data. If another call to <code>DmGetRecord()</code> for the same record is attempted before the record is released, <code>NULL</code> is returned and <a href="DataMgr.html#998861"><code>DmGetLastErr()</code></a> returns an error code indicating the reason for failure.</p>
<h4>
  <a name="1082462"> </a>Comments 
</h4>

<p><a name="1082463"> </a>Returns a handle to given record and sets the <code>busy</code> bit for the record. </p>

<p><a name="1082464"> </a>If the record is ROM-based (pointer accessed), this function makes a fake handle to it and stores this handle in the <code>DmAccessType</code> structure.</p>

<p><a name="1082469"> </a><a href="DataMgr.html#1004479"><code>DmReleaseRecord()</code></a> should be called as soon as the caller finishes viewing or editing the record.</p>
<h4>
  <a name="1082470"> </a>See Also 
</h4>

<p><a name="1082477"> </a><a href="DataMgr.html#1006040"><code>DmSearchRecordOpenDatabases()</code></a>, <a href="DataMgr.html#997584"><code>DmFindRecordByID()</code></a>, <a href="DataMgr.html#1004375"><code>DmRecordInfoV50()</code></a>, <a href="DataMgr.html#1004479"><code>DmReleaseRecord()</code></a>, <a href="DataMgr.html#1004199"><code>DmQueryRecord()</code></a></p>

<h3 class="hbH3">
  <a name="1000420"> </a>DmGetRecordAttr Function <a href="#992934"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="1082698"> </a>Purpose 
</h4>

<p><a name="1082699"> </a>Get the attributes of a database record.</p>
<h4>
  <a name="1082700"> </a>Declared In 
</h4>
<code>DataMgr.h<a name="1082701"> </a></code><h4>
  <a name="1082702"> </a>Prototype 
</h4>
<pre class="proto"><a name="1082703"></a>status_t DmGetRecordAttr (
   DmOpenRef <code class="par">dbRef</code>,
   uint16_t <code class="par">index</code>,
   uint8_t <code class="par">*pAttr</code>
)
</pre>
<h4>
  <a name="1082704"> </a>Parameters 
</h4>

<dl>
<dt><a name="1082705"> </a><code>&rarr;  <i>dbRef</i></code></dt>
<dd><a name="1082706"> </a><code>DmOpenRef</code> to an open database.</dd>

<dt><a name="1082707"> </a><code>&rarr;  <i>index</i></code></dt>
<dd><a name="1082708"> </a>Index of the record for which attributes are being retrieved.</dd>

<dt><a name="1082709"> </a><code>&larr;  <i>pAttr</i></code></dt>
<dd><a name="1082710"> </a>Pointer to a variable into which the record's attributes are written. See <a href="DataMgr.html#1041655">"Non-Schema Database Record Attributes"</a> for a description of the attributes.</dd>

</dl>
<h4>
  <a name="1082714"> </a>Returns 
</h4>

<p><a name="1082715"> </a>Returns <code>errNone</code> if the attributes were successfully obtained, or one of the following if an error occurred:</p>

<dl>
<dt><a name="1082716"> </a><code>dmErrNotRecordDB</code></dt>
<dd><a name="1082717"> </a>You've attempted to perform a record function on a resource database. </dd>

<dt><a name="1082718"> </a><code>dmErrIndexOutOfRange</code></dt>
<dd><a name="1082719"> </a>The specified index is out of range.</dd>

</dl>
<h4>
  <a name="1082720"> </a>See Also 
</h4>

<p><a name="1082727"> </a><a href="DataMgr.html#1004375"><code>DmRecordInfoV50()</code></a>, <a href="DataMgr.html#1006959"><code>DmSetRecordAttr()</code></a></p>

<h3 class="hbH3">
  <a name="1000470"> </a>DmGetRecordCategory Function <a href="#992934"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="1083107"> </a>Purpose 
</h4>

<p><a name="1083108"> </a>Get the category information for a record.</p>
<h4>
  <a name="1083109"> </a>Declared In 
</h4>
<code>DataMgr.h<a name="1083110"> </a></code><h4>
  <a name="1083111"> </a>Prototype 
</h4>
<pre class="proto"><a name="1083112"></a>status_t DmGetRecordCategory (
   DmOpenRef <code class="par">dbRef</code>,
   uint16_t <code class="par">index</code>,
   uint8_t <code class="par">*pCategory</code>
)
</pre>
<h4>
  <a name="1083113"> </a>Parameters 
</h4>

<dl>
<dt><a name="1083114"> </a><code>&rarr;  <i>dbRef</i></code></dt>
<dd><a name="1083115"> </a><code>DmOpenRef</code> to an open database.</dd>

<dt><a name="1083116"> </a><code>&rarr;  <i>index</i></code></dt>
<dd><a name="1083117"> </a>Index of the record for which the category information is being obtained.</dd>

<dt><a name="1083118"> </a><code>&larr;  <i>pCategory</i></code></dt>
<dd><a name="1083119"> </a>Pointer to a variable into which the record's category information is written.</dd>

</dl>
<h4>
  <a name="1083120"> </a>Returns 
</h4>

<p><a name="1083121"> </a>Returns <code>errNone</code> if the category information was successfully obtained, or one of the following if an error occurred:</p>

<dl>
<dt><a name="1083122"> </a><code>dmErrNotRecordDB</code></dt>
<dd><a name="1083123"> </a>You've attempted to perform a record function on a resource database. </dd>

<dt><a name="1083124"> </a><code>dmErrIndexOutOfRange</code></dt>
<dd><a name="1083125"> </a>The specified index is out of range.</dd>

</dl>
<h4>
  <a name="1083126"> </a>See Also 
</h4>

<p><a name="1083133"> </a><a href="DataMgr.html#1004375"><code>DmRecordInfoV50()</code></a>, <a href="DataMgr.html#1007171"><code>DmSetRecordCategory()</code></a></p>

<h3 class="hbH3">
  <a name="1000600"> </a>DmGetRecordID Function <a href="#992934"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="1083157"> </a>Purpose 
</h4>

<p><a name="1083158"> </a>Get the record ID for the record at the given index position.</p>
<h4>
  <a name="1083159"> </a>Declared In 
</h4>
<code>DataMgr.h<a name="1083160"> </a></code><h4>
  <a name="1083161"> </a>Prototype 
</h4>
<pre class="proto"><a name="1083162"></a>status_t DmGetRecordID (
   DmOpenRef <code class="par">dbRef</code>,
   uint16_t <code class="par">index</code>,
   uint32_t <code class="par">*pUID</code>
)
</pre>
<h4>
  <a name="1083163"> </a>Parameters 
</h4>

<dl>
<dt><a name="1083164"> </a><code>&rarr;  <i>dbRef</i></code></dt>
<dd><a name="1083165"> </a><code>DmOpenRef</code> to an open database.</dd>

<dt><a name="1083166"> </a><code>&rarr;  <i>index</i></code></dt>
<dd><a name="1083167"> </a>Index of the record for which to retrieve the ID.</dd>

<dt><a name="1083168"> </a><code>&larr;  <i>pUID</i></code></dt>
<dd><a name="1083169"> </a>Pointer to a variable into which the record ID is written.</dd>

</dl>
<h4>
  <a name="1083170"> </a>Returns 
</h4>

<p><a name="1083171"> </a>Returns <code>errNone</code> if the category information was successfully obtained, or one of the following if an error occurred:</p>

<dl>
<dt><a name="1083172"> </a><code>dmErrNotRecordDB</code></dt>
<dd><a name="1083173"> </a>You've attempted to perform a record function on a resource database. </dd>

<dt><a name="1083174"> </a><code>dmErrIndexOutOfRange</code></dt>
<dd><a name="1083175"> </a>The specified index is out of range.</dd>

<dt><a name="1083176"> </a><code>dmErrInvalidParam</code></dt>
<dd><a name="1083177"> </a>The function received an invalid parameter.</dd>

</dl>
<h4>
  <a name="1083178"> </a>See Also 
</h4>

<p><a name="1083185"> </a><a href="DataMgr.html#1004375"><code>DmRecordInfoV50()</code></a>, <a href="DataMgr.html#1007227"><code>DmSetRecordID()</code></a></p>

<h3 class="hbH3">
  <a name="1000656"> </a>DmGetRecordSortPosition Function <a href="#992934"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="1083191"> </a>Purpose 
</h4>

<p><a name="1083192"> </a>Returns where in a sorted list of records a given record would be located. Useful to find where to insert a record with <a href="DataMgr.html#1208108"><code>DmAttachRecord()</code></a>. Uses a binary search.</p>
<h4>
  <a name="1083196"> </a>Declared In 
</h4>
<code>DataMgr.h<a name="1083197"> </a></code><h4>
  <a name="1083198"> </a>Prototype 
</h4>
<pre class="proto"><a name="1083199"></a>uint16_t DmGetRecordSortPosition (
   DmOpenRef <code class="par">dbRef</code>,
   void <code class="par">*pNewRecord</code>,
   DmSortRecordInfoType <code class="par">*pNewRecordInfo</code>,
   DmCompareFunctionType <code class="par">*pFuncCompar</code>,
   int16_t <code class="par">other</code>
)
</pre>
<h4>
  <a name="1083200"> </a>Parameters 
</h4>

<dl>
<dt><a name="1083201"> </a><code>&rarr;  <i>dbRef</i></code></dt>
<dd><a name="1083202"> </a><code>DmOpenRef</code> to an open database.</dd>

<dt><a name="1083203"> </a><code>&rarr;  <i>pNewRecord</i></code></dt>
<dd><a name="1083204"> </a>Pointer to the new record. </dd>

<dt><a name="1083205"> </a><code>&rarr;  <i>pNewRecordInfo</i></code></dt>
<dd><a name="1083206"> </a>Sort information about the new record. See <a href="DataMgr.html#994025"><code>DmSortRecordInfoType</code></a>.</dd>

<dt><a name="1083210"> </a><code>&rarr;  <i>pFuncCompar</i></code></dt>
<dd><a name="1083211"> </a>Pointer to comparison function. See <a href="DataMgr.html#1007926"><code>DmCompareFunctionType()</code></a>.</dd>

<dt><a name="1083215"> </a><code>&rarr;  <i>other</i></code></dt>
<dd><a name="1083216"> </a>Any value the application wants to pass to the comparison function. This parameter is often used to indicate a sort direction (ascending or descending).</dd>

</dl>
<h4>
  <a name="1083217"> </a>Returns 
</h4>

<p><a name="1083218"> </a>The position where the record should be inserted.</p>

<p><a name="1083219"> </a>The position should be viewed as between the record returned and the record before it. Note that the return value may be one greater than the number of records.</p>
<h4>
  <a name="1083220"> </a>Comments 
</h4>

<p><a name="1083221"> </a>If <code class="par">pNewRecord</code> has the same key as another record in the database, <code>DmGetRecordSortPosition()</code> assumes that <code class="par">pNewRecord</code> should be inserted after that record. If there are several records with the same key, <code class="par">pNewRecord</code> is inserted after all of them. For this reason, if you use <code>DmGetRecordSortPosition()</code> to search for the location of a record that you know is already in the database, you must subtract 1 from the result. (Be sure to check that the value is not 0.)</p>

<p><a name="1083222"> </a>If there are deleted records in the database, <code>DmGetRecordSortPosition()</code> only works if those records are at the end of the database. <code>DmGetRecordSortPosition()</code> always assumes that a deleted record is greater than or equal to any other record.</p>

<h3 class="hbH3">
  <a name="1000738"> </a>DmGetResource Function <a href="#992934"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="1083445"> </a>Purpose 
</h4>

<p><a name="1083447"> </a>Search a specified open database and return a handle to a resource, given the resource type and ID.</p>
<h4>
  <a name="1083448"> </a>Declared In 
</h4>
<code>DataMgr.h<a name="1083449"> </a></code><h4>
  <a name="1083450"> </a>Prototype 
</h4>
<pre class="proto"><a name="1083451"></a>MemHandle DmGetResource (
   DmOpenRef <code class="par">dbRef</code>,
   DmResourceType <code class="par">resType</code>,
   DmResourceID <code class="par">resID</code>
)
</pre>
<h4>
  <a name="1083452"> </a>Parameters 
</h4>

<dl>
<dt><a name="1083453"> </a><code>&rarr;  <i>dbRef</i></code></dt>
<dd><a name="1083454"> </a>Reference to an open database to be searched.</dd>

<dt><a name="1083455"> </a><code>&rarr;  <i>resType</i></code></dt>
<dd><a name="1083456"> </a>The resource type.</dd>

<dt><a name="1083457"> </a><code>&rarr;  <i>resID</i></code></dt>
<dd><a name="1083458"> </a>The resource ID.</dd>

</dl>
<h4>
  <a name="1083459"> </a>Returns 
</h4>

<p><a name="1083460"> </a>Handle to resource data. If the specified resource cannot be found, this function returns <code>NULL</code> and <a href="DataMgr.html#998861"><code>DmGetLastErr()</code></a> returns an error code indicating the reason for failure.</p>
<h4>
  <a name="1083464"> </a>Comments 
</h4>

<p><a name="1083465"> </a>Searches the specified database for a resource of the given type and ID. If found, the resource handle is returned. The application should call <a href="DataMgr.html#1004572"><code>DmReleaseResource()</code></a> as soon as it finishes accessing the resource data. The resource handle is not locked by this function. </p>

<p><a name="1083469"> </a>This function always returns the resource located in the overlay if the overlay has a resource matching that type and ID. If there is no overlay version of the resource, this function returns the resource from the base database. </p>
<h4>
  <a name="1083470"> </a>See Also 
</h4>

<p><a name="1083477"> </a><a href="DataMgr.html#998108"><code>DmGet1ResourceV50()</code></a>, <a href="DataMgr.html#1004572"><code>DmReleaseResource()</code></a>, <a href="../User_Interface/UI_ResLoad.html#998513"><code>ResLoadConstant()</code></a></p>

<h3 class="hbH3">
  <a name="1000792"> </a>DmGetResourceByIndex Function <a href="#992934"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="1083840"> </a>Purpose 
</h4>

<p><a name="1083841"> </a>Return a handle to a resource, given the index of that resource.</p>
<h4>
  <a name="1083842"> </a>Declared In 
</h4>
<code>DataMgr.h<a name="1083843"> </a></code><h4>
  <a name="1083844"> </a>Prototype 
</h4>
<pre class="proto"><a name="1083845"></a>MemHandle DmGetResourceByIndex (
   DmOpenRef <code class="par">dbRef</code>,
   uint16_t <code class="par">index</code>
)
</pre>
<h4>
  <a name="1083846"> </a>Parameters 
</h4>

<dl>
<dt><a name="1083847"> </a><code>&rarr;  <i>dbRef</i></code></dt>
<dd><a name="1083848"> </a><code>DmOpenRef</code> to an open database.</dd>

<dt><a name="1083849"> </a><code>&rarr;  <i>index</i></code></dt>
<dd><a name="1083850"> </a>Index of the resource whose handle you want.</dd>

</dl>
<h4>
  <a name="1083851"> </a>Returns 
</h4>

<p><a name="1083852"> </a>Handle to resource data. If the specified index is out of range, this function returns <code>NULL</code> and <a href="DataMgr.html#998861"><code>DmGetLastErr()</code></a> returns an error code indicating the reason for failure.</p>

<p><a name="1083856"> </a>May display a fatal error message if the database is not a resource database. </p>

<div><hr>
  <a name="1083857"> </a> <b>IMPORTANT: </b> This function accesses the resource only in the database you specify. If you pass a pointer to a base resource database, its overlay is <i>not</i> accessed. Therefore, you should use care when using this function to access a potentially localized resource. You can use <a href="DataMgr.html#1006129"><code>DmSearchResourceOpenDatabases()</code></a> to obtain a pointer to the overlay database if the resource is localized; however, it's more convenient to use <a href="DataMgr.html#1000738"><code>DmGetResource()</code></a> or <a href="DataMgr.html#998108"><code>DmGet1ResourceV50()</code></a>. 
<hr>
</div>
<h4>
  <a name="1083870"> </a>See Also 
</h4>

<p><a name="1083877"> </a><a href="DataMgr.html#997720"><code>DmFindResource()</code></a>, <a href="DataMgr.html#997774"><code>DmFindResourceType()</code></a>, <a href="DataMgr.html#1006129"><code>DmSearchResourceOpenDatabases()</code></a></p>

<h3 class="hbH3">
  <a name="1000838"> </a>DmGetResourceV50 Function <a href="#992934"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="1084025"> </a>Purpose 
</h4>

<p><a name="1084026"> </a>Search all open resource databases and return a handle to a resource, given the resource type and ID.</p>
<h4>
  <a name="1084028"> </a>Declared In 
</h4>
<code>DataMgr.h<a name="1084029"> </a></code><h4>
  <a name="1084030"> </a>Prototype 
</h4>
<pre class="proto"><a name="1084031"></a>MemHandle DmGetResourceV50 (
   DmResourceType <code class="par">resType</code>,
   DmResourceID <code class="par">resID</code>
)
</pre>
<h4>
  <a name="1084032"> </a>Parameters 
</h4>

<dl>
<dt><a name="1084033"> </a><code>&rarr;  <i>resType</i></code></dt>
<dd><a name="1084034"> </a>The resource type.</dd>

<dt><a name="1084035"> </a><code>&rarr;  <i>resID</i></code></dt>
<dd><a name="1084036"> </a>The resource ID.</dd>

</dl>
<h4>
  <a name="1084037"> </a>Returns 
</h4>

<p><a name="1084038"> </a>Handle to resource data. If the specified resource cannot be found, this function returns <code>NULL</code> and <a href="DataMgr.html#998861"><code>DmGetLastErr()</code></a> returns an error code indicating the reason for failure.</p>
<h4>
  <a name="1084042"> </a>Comments 
</h4>

<p><a name="1084043"> </a>Searches all open resource databases starting with the most recently opened one for a resource of the given type and ID. If found, the resource handle is returned. The application should call <a href="DataMgr.html#1004572"><code>DmReleaseResource()</code></a> as soon as it finishes accessing the resource data. The resource handle is not locked by this function. </p>

<p><a name="1084047"> </a>This function always returns the resource located in the overlay if any open overlay has a resource matching that type and ID. If there is no overlay version of the resource, this function returns the resource from the base database.</p>
<h4>
  <a name="1131336"> </a>Compatibility 
</h4>

<p><a name="1131421"> </a>This function is provided for compatibility purposes. Because most Palm OS Cobalt applications know which resource file should contain the resource being searched for, for efficiency purposes such applications should use <a href="DataMgr.html#1000738"><code>DmGetResource()</code></a> or <a href="DataMgr.html#1000792"><code>DmGetResourceByIndex()</code></a> instead.</p>
<h4>
  <a name="1084048"> </a>See Also 
</h4>

<p><a name="1084055"> </a><a href="DataMgr.html#998108"><code>DmGet1ResourceV50()</code></a>, <a href="DataMgr.html#1004572"><code>DmReleaseResource()</code></a>, <a href="../User_Interface/UI_ResLoad.html#998513"><code>ResLoadConstant()</code></a></p>

<h3 class="hbH3">
  <a name="1000927"> </a>DmGetStorageInfo Function <a href="#992934"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="1084247"> </a>Purpose 
</h4>

<p><a name="1084248"> </a>Determine how much memory is used, and how much is free, in both secure and non-secure storage.</p>
<h4>
  <a name="1084249"> </a>Declared In 
</h4>
<code>DataMgr.h<a name="1084250"> </a></code><h4>
  <a name="1084251"> </a>Prototype 
</h4>
<pre class="proto"><a name="1084252"></a>status_t DmGetStorageInfo (
   DmStorageInfoPtr <code class="par">pStorageInfo</code>
)
</pre>
<h4>
  <a name="1084253"> </a>Parameters 
</h4>

<dl>
<dt><a name="1084254"> </a><code>&rarr;  <i>pStorageInfo</i></code></dt>
<dd><a name="1084258"> </a>Pointer to a <a href="DataMgr.html#994086"><code>DmStorageInfoType</code></a> structure, which upon return contains the memory usage information.</dd>

</dl>
<h4>
  <a name="1084259"> </a>Returns 
</h4>

<p><a name="1084260"> </a>Returns <code>errNone</code> if the memory information is obtained successfully, or one of the following otherwise:</p>

<dl>
<dt><a name="1084261"> </a><code>dmErrInvalidParam</code></dt>
<dd><a name="1084262"> </a>The function received an invalid parameter.</dd>

<dt><a name="1084263"> </a><code>dmErrMemError</code></dt>
<dd><a name="1084264"> </a>A memory error occurred.</dd>

</dl>
<h4>
  <a name="1084265"> </a>Comments 
</h4>

<p><a name="1084266"> </a>Your application must allocate the <code>DmStorageInfoType</code> structure prior to calling this function. </p>

<h3 class="hbH3">
  <a name="1000993"> </a>DmHandleFree Function <a href="#992934"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="1084280"> </a>Purpose 
</h4>

<p><a name="1084282"> </a>Dispose of a movable chunk on the storage heap.</p>
<h4>
  <a name="1084283"> </a>Declared In 
</h4>
<code>DataMgr.h<a name="1084284"> </a></code><h4>
  <a name="1084285"> </a>Prototype 
</h4>
<pre class="proto"><a name="1084286"></a>status_t DmHandleFree (
   MemHandle <code class="par">handle</code>
)
</pre>
<h4>
  <a name="1084287"> </a>Parameters 
</h4>

<dl>
<dt><a name="1084288"> </a><code>&rarr;  <i>handle</i></code></dt>
<dd><a name="1084289"> </a>Chunk handle.</dd>

</dl>
<h4>
  <a name="1084290"> </a>Returns 
</h4>

<p><a name="1084291"> </a>Returns 0 if no error, or <code>dmErrInvalidParam</code> if an error occurred.</p>
<h4>
  <a name="1084292"> </a>Comments 
</h4>

<p><a name="1084293"> </a>Call this function to dispose of a movable chunk.</p>
<h4>
  <a name="1084294"> </a>See Also 
</h4>

<p><a name="1084298"> </a><a href="MemoryMgr.html#994503"><code>MemHandleNew()</code></a> </p>

<h3 class="hbH3">
  <a name="1001035"> </a>DmHandleLock Function <a href="#992934"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="1084302"> </a>Purpose 
</h4>

<p><a name="1084303"> </a>Lock a storage heap chunk and obtain a pointer to the chunk's data.</p>
<h4>
  <a name="1084304"> </a>Declared In 
</h4>
<code>DataMgr.h<a name="1084305"> </a></code><h4>
  <a name="1084306"> </a>Prototype 
</h4>
<pre class="proto"><a name="1084307"></a>MemPtr DmHandleLock (
   MemHandle <code class="par">handle</code>
)
</pre>
<h4>
  <a name="1084308"> </a>Parameters 
</h4>

<dl>
<dt><a name="1084309"> </a><code>&rarr;  <i>handle</i></code></dt>
<dd><a name="1084310"> </a>Chunk handle.</dd>

</dl>
<h4>
  <a name="1084311"> </a>Returns 
</h4>

<p><a name="1084312"> </a>Returns a pointer to the chunk.</p>
<h4>
  <a name="1084313"> </a>Comments 
</h4>

<p><a name="1084315"> </a>Call this function to lock a chunk and obtain a pointer to it. Call <a href="MemoryMgr.html#994367"><code>MemHandleLock()</code></a> to lock a chunk allocated on the dynamic heap.</p>

<p><a name="1084322"> </a><code>DmHandleLock()</code> and <a href="DataMgr.html#1001480"><code>DmHandleUnlock()</code></a> should be used in pairs.</p>
<h4>
  <a name="1084323"> </a>See Also 
</h4>

<p><a name="1084327"> </a><a href="MemoryMgr.html#994503"><code>MemHandleNew()</code></a></p>

<h3 class="hbH3">
  <a name="1001327"> </a>DmHandleResize Function <a href="#992934"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="1084649"> </a>Purpose 
</h4>

<p><a name="1084650"> </a>Resize a storage heap chunk.</p>
<h4>
  <a name="1084651"> </a>Declared In 
</h4>
<code>DataMgr.h<a name="1084652"> </a></code><h4>
  <a name="1084653"> </a>Prototype 
</h4>
<pre class="proto"><a name="1084654"></a>status_t DmHandleResize (
   MemHandle <code class="par">handle</code>,
   uint32_t <code class="par">newSize</code>
)
</pre>
<h4>
  <a name="1084655"> </a>Parameters 
</h4>

<dl>
<dt><a name="1084656"> </a><code>&rarr;  <i>handle</i></code></dt>
<dd><a name="1084657"> </a>Chunk handle.</dd>

<dt><a name="1084658"> </a><code>&rarr;  <i>newSize</i></code></dt>
<dd><a name="1084659"> </a>The new desired size.</dd>

</dl>
<h4>
  <a name="1084660"> </a>Returns 
</h4>

<p><a name="1084661"> </a>Returns <code>errNone</code> if the chunk was successfully resized, or one of the following if an error occurred:</p>

<dl>
<dt><a name="1084662"> </a><code>dmErrInvalidParam</code></dt>
<dd><a name="1084663"> </a>Invalid parameter passed.</dd>

<dt><a name="1084664"> </a><code>memErrNotEnoughSpace</code></dt>
<dd><a name="1084665"> </a>A memory error occurred.</dd>

<dt><a name="1084666"> </a><code>memErrChunkLocked</code></dt>
<dd><a name="1084667"> </a>The associated memory chunk is locked. </dd>

</dl>
<h4>
  <a name="1084668"> </a>Comments 
</h4>

<p><a name="1084669"> </a>Call this function to resize a chunk. This function is always successful when shrinking the size of a chunk, even if the chunk is locked. When growing a chunk, it first attempts to grab free space immediately following the chunk so that the chunk does not have to move. If the chunk has to move to another free area of the heap to grow, it must be movable and have a lock count of 0. </p>
<h4>
  <a name="1084670"> </a>See Also 
</h4>

<p><a name="1084677"> </a><a href="MemoryMgr.html#994503"><code>MemHandleNew()</code></a>, <a href="DataMgr.html#1001373"><code>DmHandleSize()</code></a></p>

<h3 class="hbH3">
  <a name="1001373"> </a>DmHandleSize Function <a href="#992934"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="1084804"> </a>Purpose 
</h4>

<p><a name="1084806"> </a>Return the requested size of a storage heap chunk.</p>
<h4>
  <a name="1084807"> </a>Declared In 
</h4>
<code>DataMgr.h<a name="1084808"> </a></code><h4>
  <a name="1084809"> </a>Prototype 
</h4>
<pre class="proto"><a name="1084810"></a>uint32_t DmHandleSize (
   MemHandle <code class="par">handle</code>
)
</pre>
<h4>
  <a name="1084811"> </a>Parameters 
</h4>

<dl>
<dt><a name="1084812"> </a><code>&rarr;  <i>handle</i></code></dt>
<dd><a name="1084813"> </a>Chunk handle.</dd>

</dl>
<h4>
  <a name="1084814"> </a>Returns 
</h4>

<p><a name="1084815"> </a>Returns the requested size of the chunk.</p>
<h4>
  <a name="1084816"> </a>Comments 
</h4>

<p><a name="1084817"> </a>Call this function to get the size originally requested for a chunk.</p>
<h4>
  <a name="1084818"> </a>See Also 
</h4>

<p><a name="1084822"> </a><a href="DataMgr.html#1001327"><code>DmHandleResize()</code></a></p>

<h3 class="hbH3">
  <a name="1001480"> </a>DmHandleUnlock Function <a href="#992934"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="1084840"> </a>Purpose 
</h4>

<p><a name="1084842"> </a>Unlock a storage heap chunk given a chunk handle.</p>
<h4>
  <a name="1084843"> </a>Declared In 
</h4>
<code>DataMgr.h<a name="1084844"> </a></code><h4>
  <a name="1084845"> </a>Prototype 
</h4>
<pre class="proto"><a name="1084846"></a>status_t DmHandleUnlock (
   MemHandle <code class="par">handle</code>
)
</pre>
<h4>
  <a name="1084847"> </a>Parameters 
</h4>

<dl>
<dt><a name="1084848"> </a><code>&rarr;  <i>handle</i></code></dt>
<dd><a name="1084849"> </a>The chunk handle.</dd>

</dl>
<h4>
  <a name="1084850"> </a>Returns 
</h4>

<p><a name="1084851"> </a>Returns <code>errNone</code> if the handle was successfully unlocked, or <code>dmErrInvalidParam</code> if the passed handle was invalid.</p>
<h4>
  <a name="1084852"> </a>Comments 
</h4>

<p><a name="1084853"> </a>Call this function to decrement the lock count for a chunk. </p>

<p><a name="1084857"> </a><a href="DataMgr.html#1001035"><code>DmHandleLock()</code></a> and <code>DmHandleUnlock()</code> should be used in pairs.</p>

<h3 class="hbH3">
  <a name="1191454"> </a>DmInitiateAutoBackupOfOpenDatabase Function <a href="#992934"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="1191502"> </a>Purpose 
</h4>

<p><a name="1191719"> </a>Update the automatic backup file for a given open database. </p>
<h4>
  <a name="1191764"> </a>Declared In 
</h4>
<code>DataMgr.h<a name="1191775"> </a></code><h4>
  <a name="1191780"> </a>Prototype 
</h4>
<pre class="proto"><a name="1191787"></a>status_t DmInitiateAutoBackupOfOpenDatabase (
   DmOpenRef <code class="par">dbRef</code>
)
</pre>
<h4>
  <a name="1191883"> </a>Parameters 
</h4>

<dl>
<dt><a name="1191943"> </a><code>&rarr;  <i>dbRef</i></code></dt>
<dd><a name="1192066"> </a>Database access pointer.</dd>

</dl>
<h4>
  <a name="1192091"> </a>Returns 
</h4>

<p><a name="1192926"> </a>Returns <code>errNone</code> if no error, or one of the following if an error occurs: </p>

<dl>
<dt><a name="1192345"> </a><code>dmErrInvalidParam</code></dt>
<dd><a name="1192423"> </a><code class="par">dbRef</code> doesn't reference a valid open database.</dd>

<dt><a name="1192355"> </a><code>dmErrReadOnly</code></dt>
<dd><a name="1192444"> </a><code class="par">dbRef</code> references a non-schema database that is open in read-only mode. Non-schema databases must be open for writing</dd>

<dt><a name="1192360"> </a><code>dmErrOperationAborted</code></dt>
<dd><a name="1192422"> </a>The Palm OS device doesn't support the automatic database backup feature.</dd>

</dl>
<h4>
  <a name="1192167"> </a>Comments 
</h4>

<p><a name="1192203"> </a>The database is left open.</p>

<p><a name="1201094"> </a>Use this function to cause an open database to be backed up.</p>

<p><a name="1192933"> </a>Many devices running Palm OS Cobalt version 6.1 will back up the contents of the RAM storage heaps to some sort of non-volatile NAND flash.  In the event that the RAM storage heaps are corrupted or are lost for some reason, the storage heaps can then be restored to their saved state. Backup is automatically triggered on a limited set of events: database close, database create, a call to <a href="DataMgr.html#1006265"><code>DmSetDatabaseInfo()</code></a>, or upon device sleep (open databases only). Developers can explicitly cause a database to be backed up by calling <code>DmInitiateAutoBackupOfOpenDatabase()</code>. </p>

<p><a name="1201889"> </a>For additional information on this feature, see <a href="FilesAndDatabases.html#1029499">"Automatic Database Backup and Restore."</a></p>

<h3 class="hbH3">
  <a name="1001522"> </a>DmInsertionSort Function <a href="#992934"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="1085036"> </a>Purpose 
</h4>

<p><a name="1085037"> </a>Sort records in a database. </p>
<h4>
  <a name="1085038"> </a>Declared In 
</h4>
<code>DataMgr.h<a name="1085039"> </a></code><h4>
  <a name="1085040"> </a>Prototype 
</h4>
<pre class="proto"><a name="1085041"></a>status_t DmInsertionSort (
   const DmOpenRef <code class="par">dbR</code>,
   DmCompareFunctionType <code class="par">*compar</code>,
   int16_t <code class="par">other</code>
)
</pre>
<h4>
  <a name="1085042"> </a>Parameters 
</h4>

<dl>
<dt><a name="1085043"> </a><code>&rarr;  <i>dbR</i></code></dt>
<dd><a name="1085044"> </a>Database access pointer.</dd>

<dt><a name="1085045"> </a><code>&rarr;  <i>compar</i></code></dt>
<dd><a name="1085049"> </a>Comparison function. See <a href="DataMgr.html#1007926"><code>DmCompareFunctionType()</code></a>.</dd>

<dt><a name="1085050"> </a><code>&rarr;  <i>other</i></code></dt>
<dd><a name="1085051"> </a>Any value the application wants to pass to the comparison function. This parameter is often used to indicate a sort direction (ascending or descending).</dd>

</dl>
<h4>
  <a name="1085052"> </a>Returns 
</h4>

<p><a name="1085053"> </a>Returns <code>errNone</code> if no error, or one of the following if an error occurs: </p>

<dl>
<dt><a name="1085054"> </a><code>dmErrReadOnly</code></dt>
<dd><a name="1085055"> </a>You've attempted to write to or modify a database that is open in read-only mode.</dd>

<dt><a name="1085056"> </a><code>dmErrNotRecordDB</code></dt>
<dd><a name="1085057"> </a>You've attempted to perform a record function on a resource database. </dd>

</dl>

<p><a name="1085058"> </a>Some releases may display a fatal error message instead of returning the error code. </p>
<h4>
  <a name="1085059"> </a>Comments 
</h4>

<p><a name="1085060"> </a>Deleted records are placed last in any order. All others are sorted according to the passed comparison function. Only records which are out of order move. Moved records are moved to the end of the range of equal records. If a large number of records are being sorted, try to use the quick sort.</p>

<p><a name="1085061"> </a>The following insertion-sort algorithm is used: Starting with the second record, each record is compared to the preceding record. Each record not greater than the last is inserted into sorted position within those already sorted. A binary insertion is performed. A moved record is inserted after any other equal records.</p>
<h4>
  <a name="1085062"> </a>See Also 
</h4>

<p><a name="1085066"> </a><a href="DataMgr.html#1004245"><code>DmQuickSort()</code></a> </p>

<h3 class="hbH3">
  <a name="1001572"> </a>DmMoveCategory Function <a href="#992934"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="1085380"> </a>Purpose 
</h4>

<p><a name="1085382"> </a>Move all records in a category to another category. </p>
<h4>
  <a name="1085383"> </a>Declared In 
</h4>
<code>DataMgr.h<a name="1085384"> </a></code><h4>
  <a name="1085385"> </a>Prototype 
</h4>
<pre class="proto"><a name="1085386"></a>status_t DmMoveCategory (
   DmOpenRef <code class="par">dbRef</code>,
   uint16_t <code class="par">toCategory</code>,
   uint16_t <code class="par">fromCategory</code>,
   Boolean <code class="par">fDirty</code>
)
</pre>
<h4>
  <a name="1085387"> </a>Parameters 
</h4>

<dl>
<dt><a name="1085388"> </a><code>&rarr;  <i>dbRef</i></code></dt>
<dd><a name="1085389"> </a><code>DmOpenRef</code> to an open database.</dd>

<dt><a name="1085390"> </a><code>&rarr;  <i>toCategory</i></code></dt>
<dd><a name="1085391"> </a>Category to which the records should be added.</dd>

<dt><a name="1085392"> </a><code>&rarr;  <i>fromCategory</i></code></dt>
<dd><a name="1085393"> </a>Category from which to remove records.</dd>

<dt><a name="1085394"> </a><code>&rarr;  <i>fDirty</i></code></dt>
<dd><a name="1085395"> </a>If <code>true</code>, set the dirty bit.</dd>

</dl>
<h4>
  <a name="1085396"> </a>Returns 
</h4>

<p><a name="1085397"> </a>Returns <code>errNone</code> if successful, or <code>dmErrReadOnly</code> if the database is in read-only mode. Some releases may display a fatal error message instead of returning the error code. </p>
<h4>
  <a name="1085398"> </a>Comments 
</h4>

<p><a name="1085399"> </a>If <code class="par">fDirty</code> is <code>true</code>, the moved records are marked as dirty.</p>

<p><a name="1085400"> </a>The <code class="par">toCategory</code> and <code class="par">fromCategory</code> parameters hold category index values. You can learn which category a record is in with the <a href="DataMgr.html#1000470"><code>DmGetRecordCategory()</code></a> call and use that value in this function. For example, the following code, ensures that the records <span style="color: #000000;  font-family: Courier; font-style: normal; font-weight: normal; text-decoration: none; text-transform: none; vertical-align: baseline">rec1</span> and <span style="color: #000000;  font-family: Courier; font-style: normal; font-weight: normal; text-decoration: none; text-transform: none; vertical-align: baseline">rec2</span> are in the same category: </p>

<div class="CodeRule"><hr></div><pre class="CodeBlock">
DmOpenRef myDB;   //assume that this is set<a name="1085404"> </a>
uint16_t rec1Index, rec2Index;   //assume that these are set<a name="1085405"> </a>
status_t err;<a name="1134249"> </a>
uint8_t category1, category2;<a name="1085407"> </a>
<a name="1085408"> </a>
err = DmGetRecordCategory(myDb, rec1Index, &amp;category1);<a name="1134011"> </a>
err = DmGetRecordCategory(myDb, rec2Index, &amp;category2);<a name="1134018"> </a>
if (category1 != category2) <a name="1133281"> </a>
   DmMoveCategory(myDB, category1, category2, true);<a name="1133282"> </a>
</pre><div class="CodeRule"><hr></div>


<h3 class="hbH3">
  <a name="1133286"> </a>DmMoveRecord Function <a href="#992934"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="1085614"> </a>Purpose 
</h4>

<p><a name="1085615"> </a>Move a record from one index to another. </p>
<h4>
  <a name="1085616"> </a>Declared In 
</h4>
<code>DataMgr.h<a name="1085617"> </a></code><h4>
  <a name="1085618"> </a>Prototype 
</h4>
<pre class="proto"><a name="1085619"></a>status_t DmMoveRecord (
   DmOpenRef <code class="par">dbRef</code>,
   uint16_t <code class="par">from</code>,
   uint16_t <code class="par">to</code>
)
</pre>
<h4>
  <a name="1085620"> </a>Parameters 
</h4>

<dl>
<dt><a name="1085621"> </a><code>&rarr;  <i>dbRef</i></code></dt>
<dd><a name="1085622"> </a><code>DmOpenRef</code> to an open database.</dd>

<dt><a name="1085623"> </a><code>&rarr;  <i>from</i></code></dt>
<dd><a name="1085624"> </a>Index of record to move.</dd>

<dt><a name="1085625"> </a><code>&rarr;  <i>to</i></code></dt>
<dd><a name="1085626"> </a>Where to move the record.</dd>

</dl>
<h4>
  <a name="1085627"> </a>Returns 
</h4>

<p><a name="1085628"> </a>Returns <code>errNone</code> if no error, or one of the following if an error occurs: </p>

<dl>
<dt><a name="1085629"> </a><code>dmErrReadOnly</code></dt>
<dd><a name="1085630"> </a>You've attempted to write to or modify a database that is open in read-only mode.</dd>

<dt><a name="1085631"> </a><code>dmErrIndexOutOfRange</code></dt>
<dd><a name="1085632"> </a>The specified index is out of range.</dd>

<dt><a name="1085633"> </a><code>dmErrNotRecordDB</code></dt>
<dd><a name="1085634"> </a>You've attempted to perform a record function on a resource database. </dd>

<dt><a name="1085635"> </a><code>dmErrMemError</code></dt>
<dd><a name="1085636"> </a>A memory error occurred.</dd>

<dt><a name="1085637"> </a><code>memErrInvalidParam</code></dt>
<dd><a name="1085638"> </a>A memory error occurred.</dd>

<dt><a name="1085639"> </a><code>memErrChunkLocked</code></dt>
<dd><a name="1085640"> </a>The associated memory chunk is locked. </dd>

</dl>

<p><a name="1085641"> </a>Some releases may display a fatal error message instead of returning the error code. </p>
<h4>
  <a name="1085642"> </a>Comments 
</h4>

<p><a name="1085643"> </a>Insert the record at the <code class="par">to</code> index and move other records down. The <code class="par">to</code> position should be viewed as an insertion position. This value may be one greater than the index of the last record in the database. In cases where <code class="par">to</code> is greater than <code class="par">from</code>, the new index of the record becomes <code class="par">to </code>&#8211; 1 after the move is complete. </p>

<h3 class="hbH3">
  <a name="1001715"> </a>DmNewHandle Function <a href="#992934"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="1085973"> </a>Purpose 
</h4>

<p><a name="1085974"> </a>Attempt to allocate a new chunk in the storage heap.</p>
<h4>
  <a name="1085975"> </a>Declared In 
</h4>
<code>DataMgr.h<a name="1085976"> </a></code><h4>
  <a name="1085977"> </a>Prototype 
</h4>
<pre class="proto"><a name="1085978"></a>MemHandle DmNewHandle (
   DmOpenRef <code class="par">dbRef</code>,
   uint32_t <code class="par">size</code>
)
</pre>
<h4>
  <a name="1085979"> </a>Parameters 
</h4>

<dl>
<dt><a name="1085980"> </a><code>&rarr;  <i>dbRef</i></code></dt>
<dd><a name="1085981"> </a><code>DmOpenRef</code> to an open database.</dd>

<dt><a name="1085982"> </a><code>&rarr;  <i>size</i></code></dt>
<dd><a name="1085983"> </a>Size of new handle.</dd>

</dl>
<h4>
  <a name="1085984"> </a>Returns 
</h4>

<p><a name="1085985"> </a>Returns a handle to the new chunk. If an error occurs, returns 0, and <a href="DataMgr.html#998861"><code>DmGetLastErr()</code></a> returns an error code indicating the reason for failure. </p>
<h4>
  <a name="1085989"> </a>Comments 
</h4>

<p><a name="1085990"> </a>Allocates a new handle of the given size. You can attach the handle to the database as a record to obtain and save its record ID in the <code>appInfoID</code> or <code>sortInfoID</code> fields of the header.</p>

<p><a name="1085991"> </a>The handle should be attached to a database as soon as possible. If it is not attached to a database and the application crashes, the memory used by the new handle is unavailable until the next soft reset. </p>

<h3 class="hbH3">
  <a name="1001785"> </a>DmNewRecord Function <a href="#992934"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="1086006"> </a>Purpose 
</h4>

<p><a name="1086007"> </a>Return a handle to a new record in the database and mark the record busy.</p>
<h4>
  <a name="1086008"> </a>Declared In 
</h4>
<code>DataMgr.h<a name="1086009"> </a></code><h4>
  <a name="1086010"> </a>Prototype 
</h4>
<pre class="proto"><a name="1086011"></a>MemHandle DmNewRecord (
   DmOpenRef <code class="par">dbRef</code>,
   uint16_t <code class="par">*atP</code>,
   uint32_t <code class="par">size</code>
)
</pre>
<h4>
  <a name="1086012"> </a>Parameters 
</h4>

<dl>
<dt><a name="1086013"> </a><code>&rarr;  <i>dbRef</i></code></dt>
<dd><a name="1086014"> </a><code>DmOpenRef</code> to an open database.</dd>

<dt><a name="1086015"> </a><code>&harr;  <i>atP</i></code></dt>
<dd><a name="1086016"> </a>Pointer to index where new record should be placed. Specify the value <code>dmMaxRecordIndex</code> to add the record to the end of the database. </dd>

<dt><a name="1086018"> </a><code>&rarr;  <i>size</i></code></dt>
<dd><a name="1086019"> </a>Size of new record.</dd>

</dl>
<h4>
  <a name="1086020"> </a>Returns 
</h4>

<p><a name="1086021"> </a>Handle to record data. If an error occurs, this function returns 0 and <a href="DataMgr.html#998861"><code>DmGetLastErr()</code></a> returns an error code indicating the reason for failure. </p>

<p><a name="1086025"> </a>Some releases may display a fatal error message if the database is opened in read-only mode or it is a resource database. </p>
<h4>
  <a name="1086026"> </a>Comments 
</h4>

<p><a name="1086027"> </a>Allocates a new record of the given size, and returns a handle to the record data. The parameter <code class="par">atP</code> points to an index variable. The new record is inserted at index <code>*</code><code class="par">atP</code> and all record indices that follow are shifted down. If <code>*</code><code class="par">atP</code> is greater than the number of records currently in the database, the new record is appended to the end and its index is returned in <code>*</code><code class="par">atP</code>. </p>

<p><a name="1086028"> </a>Both the <code>busy</code> and <code>dirty</code> bits are set for the new record and a unique ID is automatically created. </p>

<p><a name="1086033"> </a><a href="DataMgr.html#1004479"><code>DmReleaseRecord()</code></a> should be called as soon as the caller finishes viewing or editing the record.</p>
<h4>
  <a name="1086034"> </a>See Also 
</h4>

<p><a name="1086044"> </a><a href="DataMgr.html#1208108"><code>DmAttachRecord()</code></a>, <a href="DataMgr.html#1004638"><code>DmRemoveRecord()</code></a>, <a href="DataMgr.html#996913"><code>DmDeleteRecord()</code></a></p>

<h3 class="hbH3">
  <a name="1001870"> </a>DmNewResource Function <a href="#992934"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="1086233"> </a>Purpose 
</h4>

<p><a name="1086234"> </a>Allocate and add a new resource to a resource database.</p>
<h4>
  <a name="1086235"> </a>Declared In 
</h4>
<code>DataMgr.h<a name="1086236"> </a></code><h4>
  <a name="1086237"> </a>Prototype 
</h4>
<pre class="proto"><a name="1086238"></a>MemHandle DmNewResource (
   DmOpenRef <code class="par">dbRef</code>,
   DmResourceType <code class="par">resType</code>,
   DmResourceID <code class="par">resID</code>,
   uint32_t <code class="par">size</code>
)
</pre>
<h4>
  <a name="1086239"> </a>Parameters 
</h4>

<dl>
<dt><a name="1086240"> </a><code>&rarr;  <i>dbRef</i></code></dt>
<dd><a name="1086241"> </a><code>DmOpenRef</code> to an open database.</dd>

<dt><a name="1086242"> </a><code>&rarr;  <i>resType</i></code></dt>
<dd><a name="1086243"> </a>Type of the new resource.</dd>

<dt><a name="1086244"> </a><code>&rarr;  <i>resID</i></code></dt>
<dd><a name="1086245"> </a>ID of the new resource.</dd>

<dt><a name="1086246"> </a><code>&rarr;  <i>size</i></code></dt>
<dd><a name="1086247"> </a>Desired size of the new resource.</dd>

</dl>
<h4>
  <a name="1086248"> </a>Returns 
</h4>

<p><a name="1086249"> </a>Returns a handle to the new resource. If an error occurs, this function returns <code>NULL</code> and <a href="DataMgr.html#998861"><code>DmGetLastErr()</code></a> returns an error code indicating the reason for failure.</p>

<p><a name="1086253"> </a>May display a fatal error message if the database is not a resource database. </p>
<h4>
  <a name="1086254"> </a>Comments 
</h4>

<p><a name="1086255"> </a>Allocates a memory chunk for a new resource and adds it to the given resource database. The new resource has the given type and ID. If successful, the application should call <a href="DataMgr.html#1004572"><code>DmReleaseResource()</code></a> as soon as it finishes initializing the resource.</p>
<h4>
  <a name="1086260"> </a>See Also 
</h4>

<p><a name="1086267"> </a><a href="DataMgr.html#995445"><code>DmAttachResource()</code></a>, <a href="DataMgr.html#1004684"><code>DmRemoveResource()</code></a></p>

<h3 class="hbH3">
  <a name="1001948"> </a>DmNextOpenDatabase Function <a href="#992934"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="1102920"> </a>Purpose 
</h4>

<p><a name="1102921"> </a>Return a <code>DmOpenRef</code> to the next open database for the current task.</p>
<h4>
  <a name="1086470"> </a>Declared In 
</h4>
<code>DataMgr.h<a name="1086471"> </a></code><h4>
  <a name="1086472"> </a>Prototype 
</h4>
<pre class="proto"><a name="1086473"></a>DmOpenRef DmNextOpenDatabase (
   DmOpenRef <code class="par">dbRef</code>
)
</pre>
<h4>
  <a name="1086474"> </a>Parameters 
</h4>

<dl>
<dt><a name="1086475"> </a><code>&rarr;  <i>dbRef</i></code></dt>
<dd><a name="1086476"> </a>Current database access pointer or <code>NULL</code> to start the search from the top.</dd>

</dl>
<h4>
  <a name="1086477"> </a>Returns 
</h4>

<p><a name="1086478"> </a><code>DmOpenRef</code> to the next open database, or <code>NULL</code> if there are no more.</p>
<h4>
  <a name="1086479"> </a>Comments 
</h4>

<p><a name="1086480"> </a>Call this function successively to get the <code>DmOpenRefs</code> of all open databases. Pass <code>NULL</code> for <code class="par">dbRef</code> to get the first one. Applications don't usually call this function, but is useful for system information.</p>

<p><a name="1102909"> </a>Note that unlike <a href="DataMgr.html#1086376"><code>DmNextOpenDatabaseV50()</code></a>, this function doesn't find databases that have been added to the resource search chain using functions such as <a href="DataMgr.html#1003012"><code>DmOpenDatabaseV50()</code></a>.</p>

<div><hr>
  <a name="1185363"> </a> <b>IMPORTANT: </b> When called from the main application thread, this function may block. While blocked, the application will not receive events and won't redraw its windows. As well, deferred sublaunches and notifications won't execute while the main application thread is blocked.
<hr>
</div>
<h4>
  <a name="1086481"> </a>See Also 
</h4>

<p><a name="1086488"> </a><a href="DataMgr.html#996192"><code>DmDatabaseInfo()</code></a>, <a href="DataMgr.html#1002946"><code>DmOpenDatabaseInfoV50()</code></a></p>

<h3 class="hbH3">
  <a name="1086376"> </a>DmNextOpenDatabaseV50 Function <a href="#992934"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="1086427"> </a>Purpose 
</h4>

<p><a name="1086428"> </a>Return <code>DmOpenRef</code> to the next open database in the current task's search chain.</p>
<h4>
  <a name="1086429"> </a>Declared In 
</h4>
<code>DataMgr.h<a name="1086430"> </a></code><h4>
  <a name="1086431"> </a>Prototype 
</h4>
<pre class="proto"><a name="1086432"></a>DmOpenRef DmNextOpenDatabaseV50 (
   DmOpenRef <code class="par">dbRef</code>
)
</pre>
<h4>
  <a name="1086433"> </a>Parameters 
</h4>

<dl>
<dt><a name="1086434"> </a><code>&rarr;  <i>dbRef</i></code></dt>
<dd><a name="1086435"> </a>Current database access pointer or <code>NULL</code> to start the search from the top.</dd>

</dl>
<h4>
  <a name="1086436"> </a>Returns 
</h4>

<p><a name="1086437"> </a><code>DmOpenRef</code> to next open database, or <code>NULL</code> if there are no more.</p>
<h4>
  <a name="1086438"> </a>Comments 
</h4>

<p><a name="1086439"> </a>Call this function successively to get the <code>DmOpenRefs</code> of all open databases. Pass <code>NULL</code> for <code class="par">dbRef</code> to get the first one. Applications don't usually call this function, but is useful for system information.</p>

<p><a name="1102935"> </a>This function is provided for backwards compatibility with 68K-based applications. Unlike <a href="DataMgr.html#1001948"><code>DmNextOpenDatabase()</code></a>, this function does find databases that have been added to the resource search chain using functions such as <a href="DataMgr.html#1003012"><code>DmOpenDatabaseV50()</code></a>.</p>

<div><hr>
  <a name="1184865"> </a> <b>IMPORTANT: </b> When called from the main application thread, this function may block. While blocked, the application will not receive events and won't redraw its windows. As well, deferred sublaunches and notifications won't execute while the main application thread is blocked.
<hr>
</div>
<h4>
  <a name="1131864"> </a>Compatibility 
</h4>

<p><a name="1131917"> </a>This function&#8212;and the concept of a resource search chain&#8212;are provided to ease the porting of applications from an earlier version of Palm OS. Palm OS Cobalt applications should use <a href="DataMgr.html#1001948"><code>DmNextOpenDatabase()</code></a> instead.</p>
<h4>
  <a name="1086440"> </a>See Also 
</h4>

<p><a name="1086447"> </a><a href="DataMgr.html#996192"><code>DmDatabaseInfo()</code></a>, <a href="DataMgr.html#1002946"><code>DmOpenDatabaseInfoV50()</code></a></p>

<h3 class="hbH3">
  <a name="1002084"> </a>DmNextOpenResDatabase Function <a href="#992934"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="1002089"> </a>Purpose 
</h4>

<p><a name="1086796"> </a>Return an access pointer to next open resource database in the current task.</p>
<h4>
  <a name="1086797"> </a>Declared In 
</h4>
<code>DataMgr.h<a name="1086798"> </a></code><h4>
  <a name="1086799"> </a>Prototype 
</h4>
<pre class="proto"><a name="1086800"></a>DmOpenRef DmNextOpenResDatabase (
   DmOpenRef <code class="par">dbRef</code>
)
</pre>
<h4>
  <a name="1086801"> </a>Parameters 
</h4>

<dl>
<dt><a name="1086802"> </a><code>&rarr;  <i>dbRef</i></code></dt>
<dd><a name="1086803"> </a>Database reference, or <code>NULL</code> to start the search from the top.</dd>

</dl>
<h4>
  <a name="1086804"> </a>Returns 
</h4>

<p><a name="1086805"> </a>Pointer to next open resource database.</p>
<h4>
  <a name="1086806"> </a>Comments 
</h4>

<p><a name="1086807"> </a>Returns a pointer to next open resource database. To get a pointer to the first one in the list, pass <code>NULL</code> for <code class="par">dbRef</code>.</p>

<p><a name="1086812"> </a>If you use this function to access a resource database that might have an overlay associated with it, be careful how you use the result. The <code>DmOpenRef</code> returned by this function is a pointer to the overlay database, not the base database. If you subsequently pass this pointer to <a href="DataMgr.html#997720"><code>DmFindResource()</code></a>, you'll receive a handle to the overlay resource. If you're searching for a resource that is found only in the base, you won't find it. Instead, always use <a href="DataMgr.html#1000738"><code>DmGetResource()</code></a> or <a href="DataMgr.html#998108"><code>DmGet1ResourceV50()</code></a> to obtain a resource. Both of those functions search both the overlay databases and their associated base databases. </p>

<div><hr>
  <a name="1184789"> </a> <b>IMPORTANT: </b> When called from the main application thread, this function may block. While blocked, the application will not receive events and won't redraw its windows. As well, deferred sublaunches and notifications won't execute while the main application thread is blocked.
<hr>
</div>

<h3 class="hbH3">
  <a name="1002126"> </a>DmNextOpenResDatabaseV50 Function <a href="#992934"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="1086988"> </a>Purpose 
</h4>

<p><a name="1086989"> </a>Return access pointer to next open resource database in the current task's search chain.</p>
<h4>
  <a name="1086990"> </a>Declared In 
</h4>
<code>DataMgr.h<a name="1086991"> </a></code><h4>
  <a name="1086992"> </a>Prototype 
</h4>
<pre class="proto"><a name="1086993"></a>DmOpenRef DmNextOpenResDatabaseV50 (
   DmOpenRef <code class="par">dbRef</code>
)
</pre>
<h4>
  <a name="1086994"> </a>Parameters 
</h4>

<dl>
<dt><a name="1086995"> </a><code>&rarr;  <i>dbRef</i></code></dt>
<dd><a name="1086996"> </a>Database reference, or 0 to start search from the top.</dd>

</dl>
<h4>
  <a name="1086997"> </a>Returns 
</h4>

<p><a name="1086998"> </a>Pointer to next open resource database.</p>
<h4>
  <a name="1086999"> </a>Comments 
</h4>

<p><a name="1087000"> </a>Returns pointer to next open resource database. To get a pointer to the first one in the search chain, pass <code>NULL</code> for <code class="par">dbRef</code>. This is the database that is searched when <a href="DataMgr.html#998108"><code>DmGet1ResourceV50()</code></a> is called. </p>

<p><a name="1087005"> </a>If you use this function to access a resource database that might have an overlay associated with it, be careful how you use the result. The <code>DmOpenRef</code> returned by this function is a pointer to the overlay database, not the base database. If you subsequently pass this pointer to <a href="DataMgr.html#997720"><code>DmFindResource()</code></a>, you'll receive a handle to the overlaid resource. If you're searching for a resource that is found only in the base, you won't find it. Instead, always use <a href="DataMgr.html#1000738"><code>DmGetResource()</code></a> or <a href="DataMgr.html#998108"><code>DmGet1ResourceV50()</code></a> to obtain a resource. Both of those functions search both the overlay databases and their associated base databases. </p>

<div><hr>
  <a name="1184805"> </a> <b>IMPORTANT: </b> When called from the main application thread, this function may block. While blocked, the application will not receive events and won't redraw its windows. As well, deferred sublaunches and notifications won't execute while the main application thread is blocked.
<hr>
</div>
<h4>
  <a name="1131971"> </a>Compatibility 
</h4>

<p><a name="1132062"> </a>This function&#8212;and the concept of a resource search chain&#8212;are provided to ease the porting of applications from an earlier version of Palm OS. Palm OS Cobalt applications should use <a href="DataMgr.html#1002084"><code>DmNextOpenResDatabase()</code></a> instead.</p>

<h3 class="hbH3">
  <a name="1002211"> </a>DmNumDatabases Function <a href="#992934"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="1087065"> </a>Purpose 
</h4>

<p><a name="1087066"> </a>Determine how many databases reside in memory.</p>
<h4>
  <a name="1087067"> </a>Declared In 
</h4>
<code>DataMgr.h<a name="1087068"> </a></code><h4>
  <a name="1087069"> </a>Prototype 
</h4>
<pre class="proto"><a name="1087070"></a>uint16_t DmNumDatabases (
   void
)
</pre>
<h4>
  <a name="1087071"> </a>Parameters 
</h4>

<p><a name="1087072"> </a>None.</p>
<h4>
  <a name="1087073"> </a>Returns 
</h4>

<p><a name="1087074"> </a>The number of databases found.</p>
<h4>
  <a name="1087075"> </a>Comments 
</h4>

<p><a name="1087076"> </a>The returned value doesn't include databases on expansion media (such as an SD card).</p>
<h4>
  <a name="1087083"> </a>See Also 
</h4>

<p><a name="1087087"> </a><a href="DataMgr.html#999000"><code>DmGetNextDatabaseByTypeCreator()</code></a> </p>

<h3 class="hbH3">
  <a name="1002275"> </a>DmNumDatabasesV50 Function <a href="#992934"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="1087105"> </a>Purpose 
</h4>

<p><a name="1087106"> </a>Determine how many classic databases or extended resource database reside in either RAM or ROM.</p>
<h4>
  <a name="1087107"> </a>Declared In 
</h4>
<code>DataMgr.h<a name="1087108"> </a></code><h4>
  <a name="1087109"> </a>Prototype 
</h4>
<pre class="proto"><a name="1087110"></a>uint16_t DmNumDatabasesV50 (
   uint16_t <code class="par">cardNo</code>
)
</pre>
<h4>
  <a name="1087111"> </a>Parameters 
</h4>

<dl>
<dt><a name="1087112"> </a><code>&rarr;  <i>cardNo</i></code></dt>
<dd><a name="1087113"> </a>Number of the card to check. </dd>

</dl>
<h4>
  <a name="1087114"> </a>Returns 
</h4>

<p><a name="1087115"> </a>The number of databases found.</p>
<h4>
  <a name="1087116"> </a>Comments 
</h4>

<p><a name="1087117"> </a>This function is helpful for getting a directory of all databases on a card. <a href="DataMgr.html#1157229"><code>DmGetDatabaseV50()</code></a> accepts an index from 0 to <a href="DataMgr.html#1002211"><code>DmNumDatabases()</code></a> -1 and returns a database ID by index.</p>
<h4>
  <a name="1132101"> </a>Compatibility 
</h4>

<p><a name="1132110"> </a>This function only returns the number of classic databases residing in RAM. Palm OS Cobalt applications should use <a href="DataMgr.html#1002211"><code>DmNumDatabases()</code></a> instead.</p>
<h4>
  <a name="1087124"> </a>See Also 
</h4>

<p><a name="1087128"> </a><a href="DataMgr.html#1157229"><code>DmGetDatabaseV50()</code></a> </p>

<h3 class="hbH3">
  <a name="1002317"> </a>DmNumRecords Function <a href="#992934"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="1087136"> </a>Purpose 
</h4>

<p><a name="1087137"> </a>Return the number of records in a database.</p>
<h4>
  <a name="1087138"> </a>Declared In 
</h4>
<code>DataMgr.h<a name="1087139"> </a></code><h4>
  <a name="1087140"> </a>Prototype 
</h4>
<pre class="proto"><a name="1087141"></a>uint16_t DmNumRecords (
   DmOpenRef <code class="par">dbRef</code>
)
</pre>
<h4>
  <a name="1087142"> </a>Parameters 
</h4>

<dl>
<dt><a name="1087143"> </a><code>&rarr;  <i>dbRef</i></code></dt>
<dd><a name="1087144"> </a><code>DmOpenRef</code> to an open database.</dd>

</dl>
<h4>
  <a name="1087145"> </a>Returns 
</h4>

<p><a name="1087146"> </a>The number of records in a database.</p>
<h4>
  <a name="1087147"> </a>Comments 
</h4>

<p><a name="1087148"> </a>Records that have that have the <code>deleted</code> bit set (that is, records that will be deleted during the next HotSync operation because the user has marked them deleted) are included in the count. If you want to exclude these records from your count, use <a href="DataMgr.html#1002424"><code>DmNumRecordsInCategory()</code></a> and pass <code>dmAllCategories</code> as the category.</p>
<h4>
  <a name="1087153"> </a>See Also 
</h4>

<p><a name="1087160"> </a><a href="DataMgr.html#1002424"><code>DmNumRecordsInCategory()</code></a>, <a href="DataMgr.html#1004375"><code>DmRecordInfoV50()</code></a>, <a href="DataMgr.html#1007301"><code>DmSetRecordInfoV50()</code></a></p>

<h3 class="hbH3">
  <a name="1002424"> </a>DmNumRecordsInCategory Function <a href="#992934"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="1087444"> </a>Purpose 
</h4>

<p><a name="1087445"> </a>Return the number of records of a specified category in a database. </p>
<h4>
  <a name="1087446"> </a>Declared In 
</h4>
<code>DataMgr.h<a name="1087447"> </a></code><h4>
  <a name="1087448"> </a>Prototype 
</h4>
<pre class="proto"><a name="1087449"></a>uint16_t DmNumRecordsInCategory (
   DmOpenRef <code class="par">dbRef</code>,
   uint16_t <code class="par">category</code>
)
</pre>
<h4>
  <a name="1087450"> </a>Parameters 
</h4>

<dl>
<dt><a name="1087451"> </a><code>&rarr;  <i>dbRef</i></code></dt>
<dd><a name="1087452"> </a><code>DmOpenRef</code> to an open database.</dd>

<dt><a name="1087453"> </a><code>&rarr;  <i>category</i></code></dt>
<dd><a name="1087454"> </a>Category index.</dd>

</dl>
<h4>
  <a name="1087455"> </a>Returns 
</h4>

<p><a name="1087456"> </a>The number of records in the category.</p>
<h4>
  <a name="1087457"> </a>Comments 
</h4>

<p><a name="1087458"> </a>Because this function must examine all records in the database, it can be slow to return, especially when called on a large database.</p>

<p><a name="1087459"> </a>Records that have the <code>deleted</code> bit set are not counted, and if the user has specified to hide or mask private records, private records are not counted either. </p>

<p><a name="1087463"> </a>You can use the <a href="DataMgr.html#1000470"><code>DmGetRecordCategory()</code></a> call to obtain a category index from a given record. For example: </p>

<div class="CodeRule"><hr></div><pre class="CodeBlock">
DmOpenRef myDB;   //assume that this is set<a name="1087464"> </a>
uint16_t recIndex;   //assume that this is set<a name="1134083"> </a>
status_t err;<a name="1134257"> </a>
uint8_t category;<a name="1134106"> </a>
uint16_t total;<a name="1087465"> </a>
<a name="1087466"> </a>
err = DmGetRecordCategory(myDb, recIndex, &amp;category);<a name="1134034"> </a>
total = DmNumRecordsInCategory(myDB, category);<a name="1087469"> </a>
</pre><div class="CodeRule"><hr></div>

<h4>
  <a name="1087470"> </a>See Also 
</h4>

<p><a name="1087477"> </a><a href="DataMgr.html#1002317"><code>DmNumRecords()</code></a>, <a href="DataMgr.html#1003917"><code>DmQueryNextInCategory()</code></a>, <a href="DataMgr.html#1000116"><code>DmGetPositionInCategory()</code></a>, <a href="DataMgr.html#997658"><code>DmFindRecordByOffsetInCategory()</code></a>, <a href="DataMgr.html#1001572"><code>DmMoveCategory()</code></a></p>

<h3 class="hbH3">
  <a name="1002470"> </a>DmNumResources Function <a href="#992934"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="1087650"> </a>Purpose 
</h4>

<p><a name="1087651"> </a>Return the total number of resources in a given resource database.</p>
<h4>
  <a name="1087652"> </a>Declared In 
</h4>
<code>DataMgr.h<a name="1087653"> </a></code><h4>
  <a name="1087654"> </a>Prototype 
</h4>
<pre class="proto"><a name="1087655"></a>uint16_t DmNumResources (
   DmOpenRef <code class="par">dbRef</code>
)
</pre>
<h4>
  <a name="1087656"> </a>Parameters 
</h4>

<dl>
<dt><a name="1087657"> </a><code>&rarr;  <i>dbRef</i></code></dt>
<dd><a name="1087658"> </a><code>DmOpenRef</code> to an open database.</dd>

</dl>
<h4>
  <a name="1087659"> </a>Returns 
</h4>

<p><a name="1087660"> </a>The total number of resources in the given database.</p>

<p><a name="1087661"> </a>May display a fatal error message if the database is not a resource database. </p>
<h4>
  <a name="1087662"> </a>Comments 
</h4>

<p><a name="1087663"> </a><code>DmNumResources()</code> counts only the resources in the database indicated by the <code>DmOpenRef</code> parameter. If the database is a resource database that has an overlay associated with it, this function returns only the number of resources in the base database, not in the overlay. </p>

<h3 class="hbH3">
  <a name="1002512"> </a>DmOpenDatabase Function <a href="#992934"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="1087679"> </a>Purpose 
</h4>

<p><a name="1087680"> </a>Open a non-schema database and return a reference to it. If the database is a resource database, also open its overlay for the current locale. </p>
<h4>
  <a name="1087681"> </a>Declared In 
</h4>
<code>DataMgr.h<a name="1087682"> </a></code><h4>
  <a name="1087683"> </a>Prototype 
</h4>
<pre class="proto"><a name="1087684"></a>DmOpenRef DmOpenDatabase (
   DatabaseID <code class="par">dbID</code>,
   DmOpenModeType <code class="par">mode</code>
)
</pre>
<h4>
  <a name="1087685"> </a>Parameters 
</h4>

<dl>
<dt><a name="1087686"> </a><code>&rarr;  <i>dbID</i></code></dt>
<dd><a name="1087687"> </a>Database ID of the database.</dd>

<dt><a name="1087688"> </a><code>&rarr;  <i>mode</i></code></dt>
<dd><a name="1087692"> </a>Which mode to open the database in (see <a href="DataMgr.html#1146522"><code>DmOpenModeType</code></a>).</dd>

</dl>
<h4>
  <a name="1087693"> </a>Returns 
</h4>

<p><a name="1087694"> </a>Returns a <code>DmOpenRef</code> to the open database. On error, unlike <a href="DataMgr.html#1003012"><code>DmOpenDatabaseV50()</code></a>, no fatal error is displayed; this function simply returns 0 and <a href="DataMgr.html#998861"><code>DmGetLastErr()</code></a> returns an error code indicating the reason for failure.</p>
<h4>
  <a name="1087701"> </a>Comments 
</h4>

<p><a name="1087702"> </a>Call this function to open a database for reading or writing. </p>

<p><a name="1087703"> </a>This function returns a <code>DmOpenRef</code> which must be used to access particular records in a database. If unsuccessful, 0 is returned and the cause of the error can be determined by calling <a href="DataMgr.html#998861"><code>DmGetLastErr()</code></a>.</p>

<p><a name="1087708"> </a>When you use this function to open a resource database in read-only mode, it also opens the overlay associated with this database for the current locale, if it exists. (The function <a href="DataMgr.html#999814"><code>DmGetOverlayLocale()</code></a> returns the current locale.) Overlays are resource databases typically used to localize applications, shared libraries, and panels. They have the same creator as the base database, a type of <code>'ovly'</code> (symbolically named <code>omOverlayDBType</code>), and contain resources with the same IDs and types as the resources in the base database. When you request a resource from the database using <a href="DataMgr.html#1000738"><code>DmGetResource()</code></a> or <a href="DataMgr.html#998108"><code>DmGet1ResourceV50()</code></a>, the overlay is searched first. If the overlay contains a resource for the given ID, it is returned. If not, the resource from the base database is returned. </p>

<p><a name="1087719"> </a>The <code>DmOpenRef</code> returned by this function is the pointer to the base database, not to the overlay database, so care should be taken when passing this pointer to functions such as <a href="DataMgr.html#997720"><code>DmFindResource()</code></a> because this circumvents the overlay. </p>

<p><a name="1087723"> </a>It's possible to create a "stripped" base resource database, one that does not contain any user interface resources. <code>DmOpenDatabase()</code> only opens a stripped database if its corresponding overlay exists. If the overlay does not exist or if the overlay doesn't match the resource database, <code>DmOpenDatabase()</code> returns <code>NULL</code> and <a href="DataMgr.html#998861"><code>DmGetLastErr()</code></a> returns the error code <code>omErrBaseRequiresOverlay</code>.</p>

<p><a name="1087728"> </a>If you open a resource database in a writable mode, the associated overlay is not opened. If you make changes to the resource database, the overlay database is invalidated if those changes affect any resources that are also in the overlay. This means that on future occasions where you open the resource database in read-only mode, the overlay will not be opened because Palm OS considers it to be invalid. </p>

<div><hr>
  <a name="1183987"> </a> <b>IMPORTANT: </b> When called from the main application thread, this function may block. While blocked, the application will not receive events and won't redraw its windows. As well, deferred sublaunches and notifications won't execute while the main application thread is blocked.
<hr>
</div>
<h4>
  <a name="1087729"> </a>See Also 
</h4>

<p><a name="1087736"> </a><a href="SchemaDatabases.html#1000351"><code>DbOpenDatabase()</code></a>, <a href="DataMgr.html#995692"><code>DmCloseDatabase()</code></a>, <a href="DataMgr.html#995780"><code>DmCreateDatabase()</code></a>, <a href="DataMgr.html#1077521"><code>DmFindDatabase()</code></a>, <a href="DataMgr.html#1002766"><code>DmOpenDatabaseByTypeCreator()</code></a>, <a href="DataMgr.html#996663"><code>DmDeleteDatabase()</code></a>, <a href="DataMgr.html#1003062"><code>DmOpenDBNoOverlay()</code></a> </p>

<h3 class="hbH3">
  <a name="1002766"> </a>DmOpenDatabaseByTypeCreator Function <a href="#992934"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="1088048"> </a>Purpose 
</h4>

<p><a name="1088049"> </a>Open the most recent revision of a database with the given type and creator. If the database is a resource database, also open its overlay for the current locale. </p>
<h4>
  <a name="1088050"> </a>Declared In 
</h4>
<code>DataMgr.h<a name="1088051"> </a></code><h4>
  <a name="1088052"> </a>Prototype 
</h4>
<pre class="proto"><a name="1088053"></a>DmOpenRef DmOpenDatabaseByTypeCreator (
   uint32_t <code class="par">type</code>,
   uint32_t <code class="par">creator</code>,
   DmOpenModeType <code class="par">mode</code>
)
</pre>
<h4>
  <a name="1088054"> </a>Parameters 
</h4>

<dl>
<dt><a name="1088055"> </a><code>&rarr;  <i>type</i></code></dt>
<dd><a name="1088056"> </a>Type of database.</dd>

<dt><a name="1088057"> </a><code>&rarr;  <i>creator</i></code></dt>
<dd><a name="1088058"> </a>Creator of database.</dd>

<dt><a name="1088059"> </a><code>&rarr;  <i>mode</i></code></dt>
<dd><a name="1088063"> </a>Which mode to open database in (see <a href="DataMgr.html#1146522"><code>DmOpenModeType</code></a>).</dd>

</dl>
<h4>
  <a name="1088064"> </a>Returns 
</h4>

<p><a name="1088065"> </a><code>DmOpenRef</code> to open database. Unlike <a href="DataMgr.html#1002816"><code>DmOpenDatabaseByTypeCreatorV50()</code></a>, no fatal error message is displayed; if the database couldn't be found this function simply returns 0 and <a href="DataMgr.html#998861"><code>DmGetLastErr()</code></a> returns an error code indicating the reason for failure.</p>
<h4>
  <a name="1088072"> </a>Comments 
</h4>

<p><a name="1088073"> </a>If you use this function to open a resource database in read-only mode, it also opens the overlay associated with this database for the current locale. See <a href="DataMgr.html#1002512"><code>DmOpenDatabase()</code></a> for more information on overlays and resource databases. </p>

<div><hr>
  <a name="1184751"> </a> <b>IMPORTANT: </b> When called from the main application thread, this function may block. While blocked, the application will not receive events and won't redraw its windows. As well, deferred sublaunches and notifications won't execute while the main application thread is blocked.
<hr>
</div>
<h4>
  <a name="1002811"> </a>See Also 
</h4>

<p><a name="1002814"> </a><a href="DataMgr.html#997169"><code>DmFindDatabaseByTypeCreator()</code></a>, <a href="DataMgr.html#1002512"><code>DmOpenDatabase()</code></a><a href="DataMgr.html#1003062"><code>DmOpenDBNoOverlay()</code></a><a href="DataMgr.html#1003442"><code>DmOpenIteratorByTypeCreator()</code></a></p>

<h3 class="hbH3">
  <a name="1002816"> </a>DmOpenDatabaseByTypeCreatorV50 Function <a href="#992934"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="1088099"> </a>Purpose 
</h4>

<p><a name="1088100"> </a>Opens the most recent revision of a classic database or extended resource database with the given type and creator. If the database is a resource database, either classic or extended, this function also opens its overlay for the current locale. </p>
<h4>
  <a name="1088101"> </a>Declared In 
</h4>
<code>DataMgr.h<a name="1088102"> </a></code><h4>
  <a name="1088103"> </a>Prototype 
</h4>
<pre class="proto"><a name="1088104"></a>DmOpenRef DmOpenDatabaseByTypeCreatorV50 (
   uint32_t <code class="par">type</code>,
   uint32_t <code class="par">creator</code>,
   DmOpenModeType <code class="par">mode</code>
)
</pre>
<h4>
  <a name="1088105"> </a>Parameters 
</h4>

<dl>
<dt><a name="1088106"> </a><code>&rarr;  <i>type</i></code></dt>
<dd><a name="1088107"> </a>Type of database.</dd>

<dt><a name="1088108"> </a><code>&rarr;  <i>creator</i></code></dt>
<dd><a name="1088109"> </a>Creator of database.</dd>

<dt><a name="1088110"> </a><code>&rarr;  <i>mode</i></code></dt>
<dd><a name="1088114"> </a>Which mode to open database in (see <a href="DataMgr.html#1146522"><code>DmOpenModeType</code></a>).</dd>

</dl>
<h4>
  <a name="1088115"> </a>Returns 
</h4>

<p><a name="1088116"> </a><code>DmOpenRef</code> to open database. If the database couldn't be found this function returns 0 and <a href="DataMgr.html#998861"><code>DmGetLastErr()</code></a> returns an error code indicating the reason for failure.</p>
<h4>
  <a name="1088120"> </a>Comments 
</h4>

<p><a name="1088121"> </a>If you use this function to open a resource database in read-only mode, it also opens the overlay associated with this database for the current locale. See <a href="DataMgr.html#1002512"><code>DmOpenDatabase()</code></a> for more information on overlays and resource databases.</p>

<div><hr>
  <a name="1185732"> </a> <b>IMPORTANT: </b> When called from the main application thread, this function may block. While blocked, the application will not receive events and won't redraw its windows. As well, deferred sublaunches and notifications won't execute while the main application thread is blocked.
<hr>
</div>
<h4>
  <a name="1132131"> </a>Compatibility 
</h4>

<p><a name="1132138"> </a>This function operates only on classic databases, and exists for compatibility purposes only. Palm OS Cobalt applications should use <a href="DataMgr.html#1002766"><code>DmOpenDatabaseByTypeCreator()</code></a> instead.</p>
<h4>
  <a name="1132133"> </a>See Also 
</h4>

<p><a name="1088132"> </a><a href="DataMgr.html#1002766"><code>DmOpenDatabaseByTypeCreator()</code></a>, <a href="DataMgr.html#995780"><code>DmCreateDatabase()</code></a>, <a href="DataMgr.html#1002512"><code>DmOpenDatabase()</code></a>, <a href="DataMgr.html#1002946"><code>DmOpenDatabaseInfoV50()</code></a>, <a href="DataMgr.html#995692"><code>DmCloseDatabase()</code></a>, <a href="DataMgr.html#1003062"><code>DmOpenDBNoOverlay()</code></a> </p>

<h3 class="hbH3">
  <a name="1002946"> </a>DmOpenDatabaseInfoV50 Function <a href="#992934"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="1088419"> </a>Purpose 
</h4>

<p><a name="1088420"> </a>Retrieve information about an open database.</p>
<h4>
  <a name="1088421"> </a>Declared In 
</h4>
<code>DataMgr.h<a name="1088422"> </a></code><h4>
  <a name="1088423"> </a>Prototype 
</h4>
<pre class="proto"><a name="1088424"></a>status_t DmOpenDatabaseInfoV50 (
   DmOpenRef <code class="par">dbRef</code>,
   LocalID <code class="par">*pDbID</code>,
   uint16_t <code class="par">*pOpenCount</code>,
   DmOpenModeType <code class="par">*pMode</code>,
   uint16_t <code class="par">*pCardNo</code>,
   Boolean <code class="par">*pResDB</code>
)
</pre>
<h4>
  <a name="1088425"> </a>Parameters 
</h4>

<dl>
<dt><a name="1088426"> </a><code>&rarr;  <i>dbRef</i></code></dt>
<dd><a name="1088427"> </a><code>DmOpenRef</code> to an open database.</dd>

<dt><a name="1088428"> </a><code>&larr;  <i>pDbID</i></code></dt>
<dd><a name="1088429"> </a>The ID of the database. Pass <code>NULL</code> for this parameter if you don't want to retrieve this information.</dd>

<dt><a name="1088430"> </a><code>&larr;  <i>pOpenCount</i></code></dt>
<dd><a name="1088431"> </a>The number of applications that have this database open. Pass <code>NULL</code> for this parameter if you don't want to retrieve this information.</dd>

<dt><a name="1088432"> </a><code>&larr;  <i>pMode</i></code></dt>
<dd><a name="1088436"> </a>The mode used to open the database (see <a href="DataMgr.html#1146522"><code>DmOpenModeType</code></a>). Pass <code>NULL</code> for this parameter if you don't want to retrieve this information.</dd>

<dt><a name="1088437"> </a><code>&larr;  <i>pCardNo</i></code></dt>
<dd><a name="1088438"> </a>The number of the card on which this database resides. Pass <code>NULL</code> for this parameter if you don't want to retrieve this information.</dd>

<dt><a name="1088439"> </a><code>&larr;  <i>pResDB</i></code></dt>
<dd><a name="1088440"> </a>If <code>true</code> upon return, the database is a resource database, <code>false</code> otherwise. Pass <code>NULL</code> for this parameter if you don't want to retrieve this information.</dd>

</dl>
<h4>
  <a name="1088441"> </a>Returns 
</h4>

<p><a name="1088442"> </a>Returns <code>errNone</code> if no error. </p>
<h4>
  <a name="1132162"> </a>Compatibility 
</h4>

<p><a name="1132171"> </a>This function is provided only to ease the porting of applications from previous versions of Palm OS. Palm OS Cobalt applications will want to use <a href="DataMgr.html#999324"><code>DmGetOpenInfo()</code></a> instead.</p>
<h4>
  <a name="1088443"> </a>See Also 
</h4>

<p><a name="1088447"> </a><a href="DataMgr.html#996192"><code>DmDatabaseInfo()</code></a> </p>

<h3 class="hbH3">
  <a name="1003012"> </a>DmOpenDatabaseV50 Function <a href="#992934"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="1088462"> </a>Purpose 
</h4>

<p><a name="1088463"> </a>Open a non-schema database and return a reference to it. If the database is a resource database, also open its overlay for the current locale. </p>
<h4>
  <a name="1088464"> </a>Declared In 
</h4>
<code>DataMgr.h<a name="1088465"> </a></code><h4>
  <a name="1088466"> </a>Prototype 
</h4>
<pre class="proto"><a name="1088467"></a>DmOpenRef DmOpenDatabaseV50 (
   uint16_t <code class="par">cardNo</code>,
   LocalID <code class="par">dbID</code>,
   DmOpenModeType <code class="par">mode</code>
)
</pre>
<h4>
  <a name="1088468"> </a>Parameters 
</h4>

<dl>
<dt><a name="1088469"> </a><code>&rarr;  <i>cardNo</i></code></dt>
<dd><a name="1088470"> </a>Card number database resides on.</dd>

<dt><a name="1088471"> </a><code>&rarr;  <i>dbID</i></code></dt>
<dd><a name="1088472"> </a>The database ID of the database.</dd>

<dt><a name="1088473"> </a><code>&rarr;  <i>mode</i></code></dt>
<dd><a name="1088477"> </a>Which mode to open database in (see <a href="DataMgr.html#1146522"><code>DmOpenModeType</code></a>).</dd>

</dl>
<h4>
  <a name="1088478"> </a>Returns 
</h4>

<p><a name="1088479"> </a>Returns <code>DmOpenRef</code> to open database. May display a fatal error message if the database parameter is <code>NULL</code>. On all other errors, this function returns 0 and <a href="DataMgr.html#998861"><code>DmGetLastErr()</code></a> returns an error code indicating the reason for failure.</p>
<h4>
  <a name="1088483"> </a>Comments 
</h4>

<p><a name="1088484"> </a>Call this function to open a database for reading or writing. </p>

<p><a name="1088485"> </a>This function returns a <code>DmOpenRef</code> which must be used to access particular records in a database. If unsuccessful, 0 is returned and the cause of the error can be determined by calling <a href="DataMgr.html#998861"><code>DmGetLastErr()</code></a>.</p>

<p><a name="1088490"> </a>When you use this function to open a resource database in read-only mode, it also opens the overlay associated with this database for the current locale, if it exists. (The function <a href="DataMgr.html#999814"><code>DmGetOverlayLocale()</code></a> returns the current locale.) Overlays are resource databases typically used to localize applications, shared libraries, and panels. They have the same creator as the base database, a type of <code>'ovly'</code> (symbolically named <code>omOverlayDBType</code>), and contain resources with the same IDs and types as the resources in the base database. When you request a resource from the database using <a href="DataMgr.html#1000738"><code>DmGetResource()</code></a> or <a href="DataMgr.html#998108"><code>DmGet1ResourceV50()</code></a>, the overlay is searched first. If the overlay contains a resource for the given ID, it is returned. If not, the resource from the base database is returned. </p>

<p><a name="1088501"> </a>The <code>DmOpenRef</code> returned by this function is the pointer to the base database, not to the overlay database, so care should be taken when passing this pointer to functions such as <a href="DataMgr.html#997720"><code>DmFindResource()</code></a> because this circumvents the overlay. </p>

<p><a name="1088505"> </a>It's possible to create a "stripped" base resource database, one that does not contain any user interface resources. <code>DmOpenDatabaseV50()</code> only opens a stripped database if its corresponding overlay exists. If the overlay does not exist or if the overlay doesn't match the resource database, <code>DmOpenDatabaseV50()</code> returns <code>NULL</code> and <a href="DataMgr.html#998861"><code>DmGetLastErr()</code></a> returns the error code <code>omErrBaseRequiresOverlay</code>.</p>

<p><a name="1088510"> </a>If you open a resource database in a writable mode, the associated overlay is not opened. If you make changes to the resource database, the overlay database is invalidated if those changes affect any resources that are also in the overlay. This means that on future occasions where you open the resource database in read-only mode, the overlay will not be opened because Palm OS considers it to be invalid. </p>

<div><hr>
  <a name="1088511"> </a> <b>TIP: </b> If you want to prevent your resource database from being overlaid, include an <code>'xprf'</code> resource (symbolically named <code>sysResTExtPrefs</code>) in the database with the ID 0 (<code>sysResIDExtPrefs</code>) and set its <code>disableOverlays</code> flag. This resource is defined in <code>UIResources.r</code>. 
<hr>
</div>

<p><a name="1088515"> </a>When <code>DmOpenDatabaseV50()</code> attempts to open a stripped resource database and cannot find an overlay for it, it searches for an overlay matching the default locale if the system locale is different from the default locale. </p>

<div><hr>
  <a name="1185371"> </a> <b>IMPORTANT: </b> When called from the main application thread, this function may block. While blocked, the application will not receive events and won't redraw its windows. As well, deferred sublaunches and notifications won't execute while the main application thread is blocked.
<hr>
</div>
<h4>
  <a name="1132400"> </a>Compatibility 
</h4>

<p><a name="1132401"> </a>This function is provided only to ease the porting of applications from previous versions of Palm OS. Palm OS Cobalt applications will want to use <a href="DataMgr.html#1002512"><code>DmOpenDatabase()</code></a> instead.</p>
<h4>
  <a name="1088516"> </a>See Also 
</h4>

<p><a name="1088523"> </a><a href="DataMgr.html#1002512"><code>DmOpenDatabase()</code></a>, <a href="DataMgr.html#995692"><code>DmCloseDatabase()</code></a>, <a href="DataMgr.html#995780"><code>DmCreateDatabase()</code></a>, <a href="DataMgr.html#1077521"><code>DmFindDatabase()</code></a>, <a href="DataMgr.html#1002766"><code>DmOpenDatabaseByTypeCreator()</code></a>, <a href="DataMgr.html#996663"><code>DmDeleteDatabase()</code></a>, <a href="DataMgr.html#1003062"><code>DmOpenDBNoOverlay()</code></a> </p>

<h3 class="hbH3">
  <a name="1003062"> </a>DmOpenDBNoOverlay Function <a href="#992934"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="1088820"> </a>Purpose 
</h4>

<p><a name="1088821"> </a>Open a non-schema database and return a reference to it.</p>
<h4>
  <a name="1088822"> </a>Declared In 
</h4>
<code>DataMgr.h<a name="1088823"> </a></code><h4>
  <a name="1088824"> </a>Prototype 
</h4>
<pre class="proto"><a name="1088825"></a>DmOpenRef DmOpenDBNoOverlay (
   DatabaseID <code class="par">dbID</code>,
   DmOpenModeType <code class="par">mode</code>
)
</pre>
<h4>
  <a name="1088826"> </a>Parameters 
</h4>

<dl>
<dt><a name="1088827"> </a><code>&rarr;  <i>dbID</i></code></dt>
<dd><a name="1088828"> </a>Database ID of the database.</dd>

<dt><a name="1088829"> </a><code>&rarr;  <i>mode</i></code></dt>
<dd><a name="1088833"> </a>Which mode to open database in (see <a href="DataMgr.html#1146522"><code>DmOpenModeType</code></a>). </dd>

</dl>
<h4>
  <a name="1088834"> </a>Returns 
</h4>

<p><a name="1088835"> </a>Returns a <code>DmOpenRef</code> to the open database. Unlike <a href="DataMgr.html#1003392"><code>DmOpenDBNoOverlayV50()</code></a>, no fatal error message is displayed; on error, this function simply returns 0 and <a href="DataMgr.html#998861"><code>DmGetLastErr()</code></a> returns an error code indicating the reason for failure.</p>
<h4>
  <a name="1088842"> </a>Comments 
</h4>

<p><a name="1088843"> </a>Call this function to open a database for reading or writing, while ignoring any overlay databases that might be associated with it. </p>

<p><a name="1088844"> </a>This function returns a <code>DmOpenRef</code> which must be used to access particular records in a database. If unsuccessful, 0 is returned and the cause of the error can be determined by calling <a href="DataMgr.html#998861"><code>DmGetLastErr()</code></a>.</p>

<div><hr>
  <a name="1184634"> </a> <b>IMPORTANT: </b> When called from the main application thread, this function may block. While blocked, the application will not receive events and won't redraw its windows. As well, deferred sublaunches and notifications won't execute while the main application thread is blocked.
<hr>
</div>
<h4>
  <a name="1088848"> </a>See Also 
</h4>

<p><a name="1088855"> </a><a href="DataMgr.html#995692"><code>DmCloseDatabase()</code></a>, <a href="DataMgr.html#995780"><code>DmCreateDatabase()</code></a>, <a href="DataMgr.html#1077521"><code>DmFindDatabase()</code></a>, <a href="DataMgr.html#1002766"><code>DmOpenDatabaseByTypeCreator()</code></a>, <a href="DataMgr.html#996663"><code>DmDeleteDatabase()</code></a>, <a href="DataMgr.html#1002512"><code>DmOpenDatabase()</code></a> </p>

<h3 class="hbH3">
  <a name="1003392"> </a>DmOpenDBNoOverlayV50 Function <a href="#992934"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="1089121"> </a>Purpose 
</h4>

<p><a name="1089122"> </a>Open a non-schema database and return a reference to it.</p>
<h4>
  <a name="1089123"> </a>Declared In 
</h4>
<code>DataMgr.h<a name="1089124"> </a></code><h4>
  <a name="1089125"> </a>Prototype 
</h4>
<pre class="proto"><a name="1089126"></a>DmOpenRef DmOpenDBNoOverlayV50 (
   uint16_t <code class="par">cardNo</code>,
   LocalID <code class="par">dbID</code>,
   DmOpenModeType <code class="par">mode</code>
)
</pre>
<h4>
  <a name="1089127"> </a>Parameters 
</h4>

<dl>
<dt><a name="1089128"> </a><code>&rarr;  <i>cardNo</i></code></dt>
<dd><a name="1089129"> </a>Card number database resides on.</dd>

<dt><a name="1089130"> </a><code>&rarr;  <i>dbID</i></code></dt>
<dd><a name="1089131"> </a>The database ID of the database.</dd>

<dt><a name="1089132"> </a><code>&rarr;  <i>mode</i></code></dt>
<dd><a name="1089136"> </a>Which mode to open database in (see <a href="DataMgr.html#1146522"><code>DmOpenModeType</code></a>). </dd>

</dl>
<h4>
  <a name="1089137"> </a>Returns 
</h4>

<p><a name="1089138"> </a><code>DmOpenRef</code> to open database. May display a fatal error message if the database parameter is <code>NULL</code>. On all other errors, this function returns 0 and <a href="DataMgr.html#998861"><code>DmGetLastErr()</code></a> returns an error code indicating the reason for failure.</p>
<h4>
  <a name="1089142"> </a>Comments 
</h4>

<p><a name="1089143"> </a>Call this function to open a database for reading or writing, while ignoring any overlay databases that might be associated with it. </p>

<p><a name="1089144"> </a>This function returns a <code>DmOpenRef</code> which must be used to access particular records in a database. If unsuccessful, 0 is returned and the cause of the error can be determined by calling <a href="DataMgr.html#998861"><code>DmGetLastErr()</code></a>.</p>

<div><hr>
  <a name="1185696"> </a> <b>IMPORTANT: </b> When called from the main application thread, this function may block. While blocked, the application will not receive events and won't redraw its windows. As well, deferred sublaunches and notifications won't execute while the main application thread is blocked.
<hr>
</div>
<h4>
  <a name="1132663"> </a>Compatibility 
</h4>

<p><a name="1132664"> </a>This function is provided only to ease the porting of applications from previous versions of Palm OS. Palm OS Cobalt applications will want to use <a href="DataMgr.html#1003062"><code>DmOpenDBNoOverlay()</code></a> instead.</p>
<h4>
  <a name="1089148"> </a>See Also 
</h4>

<p><a name="1089155"> </a><a href="DataMgr.html#1003062"><code>DmOpenDBNoOverlay()</code></a>, <a href="DataMgr.html#995692"><code>DmCloseDatabase()</code></a>, <a href="DataMgr.html#995780"><code>DmCreateDatabase()</code></a>, <a href="DataMgr.html#1077521"><code>DmFindDatabase()</code></a>, <a href="DataMgr.html#1002766"><code>DmOpenDatabaseByTypeCreator()</code></a>, <a href="DataMgr.html#996663"><code>DmDeleteDatabase()</code></a>, <a href="DataMgr.html#1002512"><code>DmOpenDatabase()</code></a> </p>

<h3 class="hbH3">
  <a name="1003442"> </a>DmOpenIteratorByTypeCreator Function <a href="#992934"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="1003447"> </a>Purpose 
</h4>

<p><a name="1003454"> </a>Mark the start of an iteration through those databases that match a specified set of criteria.</p>
<h4>
  <a name="1003464"> </a>Declared In 
</h4>
<code>DataMgr.h<a name="1003485"> </a></code><h4>
  <a name="1003509"> </a>Prototype 
</h4>
<pre class="proto"><a name="1003536"></a>status_t DmOpenIteratorByTypeCreator (
   DmSearchStatePtr <code class="par">stateInfoP</code>,
   uint32_t <code class="par">type</code>,
   uint32_t <code class="par">creator</code>,
   Boolean <code class="par">onlyLatestVers</code>,
   DmFindType <code class="par">find</code>
)
</pre>
<h4>
  <a name="1003574"> </a>Parameters 
</h4>

<dl>
<dt><a name="1003601"> </a><code>&rarr;  <i>stateInfoP</i></code></dt>
<dd><a name="1097660"> </a>Pointer to a <a href="DataMgr.html#993964"><code>DmSearchStateType</code></a> structure that you have allocated. The iteration process uses this opaque structure to maintain its state.</dd>

<dt><a name="1003665"> </a><code>&rarr;  <i>type</i></code></dt>
<dd><a name="1097722"> </a>Type of database to search for, pass <code>dmSearchWildcardID</code> to iterate through databases of all types.</dd>

<dt><a name="1097723"> </a><code>&rarr;  <i>creator</i></code></dt>
<dd><a name="1097724"> </a>Creator of database to search for, pass <code>dmSearchWildcardID</code> to iterate through databases with all creator IDs.</dd>

<dt><a name="1097725"> </a><code>&rarr;  <i>onlyLatestVers</i></code></dt>
<dd><a name="1097726"> </a>If <code>true</code>, only the latest version of a database with a given type and creator is returned.</dd>

<dt><a name="1003701"> </a><code>&rarr;  <i>find</i></code></dt>
<dd><a name="1003703"> </a>Flags indicating the type of database to be searched for: schema, extended, classic, or a combination of the three. See <a href="DataMgr.html#993618"><code>DmFindType</code></a> for more information.</dd>

</dl>
<h4>
  <a name="1003705"> </a>Returns 
</h4>

<p><a name="1003708"> </a>Returns <code>errNone</code>.</p>
<h4>
  <a name="1003710"> </a>Comments 
</h4>

<p><a name="1097588"> </a>See the comments under <a href="DataMgr.html#999000"><code>DmGetNextDatabaseByTypeCreator()</code></a> for an example of how this function is used.</p>
<h4>
  <a name="1003715"> </a>See Also 
</h4>

<p><a name="1003718"> </a><a href="DataMgr.html#999000"><code>DmGetNextDatabaseByTypeCreator()</code></a>, <a href="DataMgr.html#995734"><code>DmCloseIteratorByTypeCreator()</code></a></p>

<h3 class="hbH3">
  <a name="1003720"> </a>DmPtrResize Function <a href="#992934"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="1089218"> </a>Purpose 
</h4>

<p><a name="1089219"> </a>Resize a storage heap chunk given a pointer to its data.</p>
<h4>
  <a name="1089220"> </a>Declared In 
</h4>
<code>DataMgr.h<a name="1089221"> </a></code><h4>
  <a name="1089222"> </a>Prototype 
</h4>
<pre class="proto"><a name="1089223"></a>status_t DmPtrResize (
   MemPtr <code class="par">p</code>,
   uint32_t <code class="par">newSize</code>
)
</pre>
<h4>
  <a name="1089224"> </a>Parameters 
</h4>

<dl>
<dt><a name="1089225"> </a><code>&rarr;  <i>p</i></code></dt>
<dd><a name="1089226"> </a>Pointer to the chunk.</dd>

<dt><a name="1089227"> </a><code>&rarr;  <i>newSize</i></code></dt>
<dd><a name="1089228"> </a>The new desired size.</dd>

</dl>
<h4>
  <a name="1089229"> </a>Returns 
</h4>

<p><a name="1089230"> </a>Returns <code>errNone</code> if the chunk was successfully resized, or one of the following if an error occurred:</p>

<dl>
<dt><a name="1089231"> </a><code>dmErrInvalidParam</code></dt>
<dd><a name="1089232"> </a>The function received an invalid parameter.</dd>

<dt><a name="1089233"> </a><code>memErrNotEnoughSpace</code></dt>
<dd><a name="1089234"> </a>A memory error occurred.</dd>

<dt><a name="1089235"> </a><code>memErrChunkLocked</code></dt>
<dd><a name="1089236"> </a>The associated memory chunk is locked. </dd>

</dl>
<h4>
  <a name="1089237"> </a>Comments 
</h4>

<p><a name="1089238"> </a>Call this function to resize a locked chunk. This function is always successful when shrinking the size of a chunk. When growing a chunk, it attempts to use free space immediately following the chunk.</p>
<h4>
  <a name="1089239"> </a>See Also 
</h4>

<p><a name="1089246"> </a><a href="DataMgr.html#1003809"><code>DmPtrSize()</code></a>, <a href="DataMgr.html#1001327"><code>DmHandleResize()</code></a> </p>

<h3 class="hbH3">
  <a name="1003809"> </a>DmPtrSize Function <a href="#992934"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="1089274"> </a>Purpose 
</h4>

<p><a name="1089275"> </a>Return the size of a storage heap chunk given a pointer to its data.</p>
<h4>
  <a name="1089276"> </a>Declared In 
</h4>
<code>DataMgr.h<a name="1089277"> </a></code><h4>
  <a name="1089278"> </a>Prototype 
</h4>
<pre class="proto"><a name="1089279"></a>uint32_t DmPtrSize (
   MemPtr <code class="par">p</code>
)
</pre>
<h4>
  <a name="1089280"> </a>Parameters 
</h4>

<dl>
<dt><a name="1089281"> </a><code>&rarr;  <i>p</i></code></dt>
<dd><a name="1089282"> </a>Pointer to the chunk.</dd>

</dl>
<h4>
  <a name="1089283"> </a>Returns 
</h4>

<p><a name="1089284"> </a>The requested size of the chunk.</p>
<h4>
  <a name="1089285"> </a>Comments 
</h4>

<p><a name="1089286"> </a>Call this function to get the original requested size of a chunk.</p>

<h3 class="hbH3">
  <a name="1003875"> </a>DmPtrUnlock Function <a href="#992934"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="1089407"> </a>Purpose 
</h4>

<p><a name="1089408"> </a>Unlock a storage heap chunk, given a pointer to its data.</p>
<h4>
  <a name="1089409"> </a>Declared In 
</h4>
<code>DataMgr.h<a name="1089410"> </a></code><h4>
  <a name="1089411"> </a>Prototype 
</h4>
<pre class="proto"><a name="1089412"></a>status_t DmPtrUnlock (
   MemPtr <code class="par">p</code>
)
</pre>
<h4>
  <a name="1089413"> </a>Parameters 
</h4>

<dl>
<dt><a name="1089414"> </a><code>&rarr;  <i>p</i></code></dt>
<dd><a name="1089415"> </a>Pointer to a chunk.</dd>

</dl>
<h4>
  <a name="1089416"> </a>Returns 
</h4>

<p><a name="1089417"> </a>Returns <code>errNone</code> if the chunk was successfully unlocked, or <code>dmErrInvalidParam</code> if there was a problem with the chunk pointer.</p>
<h4>
  <a name="1089418"> </a>Comments 
</h4>

<p><a name="1089420"> </a>A chunk must <i>not</i> be unlocked more times than it was locked. </p>
<h4>
  <a name="1089421"> </a>See Also 
</h4>

<p><a name="1089425"> </a><a href="DataMgr.html#1001035"><code>DmHandleLock()</code></a> </p>

<h3 class="hbH3">
  <a name="1003917"> </a>DmQueryNextInCategory Function <a href="#992934"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="1089452"> </a>Purpose 
</h4>

<p><a name="1089453"> </a>Return a handle to the next record in the specified category for reading only (does not set the <code>busy</code> bit).</p>
<h4>
  <a name="1089455"> </a>Declared In 
</h4>
<code>DataMgr.h<a name="1089456"> </a></code><h4>
  <a name="1089457"> </a>Prototype 
</h4>
<pre class="proto"><a name="1089458"></a>MemHandle DmQueryNextInCategory (
   DmOpenRef <code class="par">dbRef</code>,
   uint16_t <code class="par">*pIndex</code>,
   uint16_t <code class="par">category</code>
)
</pre>
<h4>
  <a name="1089459"> </a>Parameters 
</h4>

<dl>
<dt><a name="1089460"> </a><code>&rarr;  <i>dbRef</i></code></dt>
<dd><a name="1089461"> </a><code>DmOpenRef</code> to an open database.</dd>

<dt><a name="1089462"> </a><code>&harr;  <i>pIndex</i></code></dt>
<dd><a name="1089463"> </a>Index of a known record (often retrieved with <a href="DataMgr.html#1000116"><code>DmGetPositionInCategory()</code></a>). If a "next" record is found, this index is updated to indicate that record.</dd>

<dt><a name="1089467"> </a><code>&rarr;  <i>category</i></code></dt>
<dd><a name="1089468"> </a>Index of category to query, or <code>dmAllCategories</code> to find the next record in any category. </dd>

</dl>
<h4>
  <a name="1089469"> </a>Returns 
</h4>

<p><a name="1089470"> </a>Returns a handle to the record, along with the index of that record. If a record couldn't be found, this function returns <code>NULL</code>, and <a href="DataMgr.html#998861"><code>DmGetLastErr()</code></a> returns an error code indicating the reason for failure. </p>
<h4>
  <a name="1089474"> </a>Comments 
</h4>

<p><a name="1089475"> </a>This function begins searching the database from the record at <code>*</code><code class="par">pIndex</code> for a record that is in the specified category. If the record at <code>*</code><code class="par">pIndex</code> belongs to that category, then a handle to it is returned. If not, the function continues searching until it finds a record in the category. </p>

<p><a name="1089476"> </a>Records that have the <code>deleted</code> bit set are skipped, and if the user has specified that private records should be hidden or masked, private records are skipped as well. </p>

<p><a name="1089477"> </a>Because this function begins searching the database at the record with the supplied index, if you want to find the next record in the category after the one you have an index for, increment the index value before calling this function. For example: </p>

<div class="CodeRule"><hr></div><pre class="CodeBlock">
DmOpenRef myDB;   //assume that this is set<a name="1089478"> </a>
uint16_t recIndex;   //assume that this is set<a name="1134148"> </a>
uint8_t category;<a name="1134161"> </a>
status_t err;<a name="1134229"> </a>
uint16_t pos;<a name="1089479"> </a>
MemHandle newRecH;<a name="1089480"> </a>
<a name="1089481"> </a>
err = DmGetRecordCategory(myDb, recIndex, &amp;category);<a name="1134174"> </a>
pos = DmGetPositionInCategory(myDB, recIndex, category);<a name="1089484"> </a>
pos++;   //advance to next record<a name="1089486"> </a>
newRecH = DmQueryNextInCategory(myDB, &amp;pos, category);<a name="1089487"> </a>
</pre><div class="CodeRule"><hr></div>

<h4>
  <a name="1089488"> </a>See Also 
</h4>

<p><a name="1089492"> </a><a href="DataMgr.html#1002424"><code>DmNumRecordsInCategory()</code></a>, <a href="DataMgr.html#1000116"><code>DmGetPositionInCategory()</code></a>, <a href="DataMgr.html#997658"><code>DmFindRecordByOffsetInCategory()</code></a> </p>

<h3 class="hbH3">
  <a name="1004199"> </a>DmQueryRecord Function <a href="#992934"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="1089732"> </a>Purpose 
</h4>

<p><a name="1089733"> </a>Return a handle to a record for reading only (does not set the <code>busy</code> bit).</p>
<h4>
  <a name="1089734"> </a>Declared In 
</h4>
<code>DataMgr.h<a name="1089735"> </a></code><h4>
  <a name="1089736"> </a>Prototype 
</h4>
<pre class="proto"><a name="1089737"></a>MemHandle DmQueryRecord (
   DmOpenRef <code class="par">dbRef</code>,
   uint16_t <code class="par">index</code>
)
</pre>
<h4>
  <a name="1089738"> </a>Parameters 
</h4>

<dl>
<dt><a name="1089739"> </a><code>&rarr;  <i>dbRef</i></code></dt>
<dd><a name="1089740"> </a><code>DmOpenRef</code> to an open database.</dd>

<dt><a name="1089741"> </a><code>&rarr;  <i>index</i></code></dt>
<dd><a name="1089742"> </a>Which record to retrieve.</dd>

</dl>
<h4>
  <a name="1089743"> </a>Returns 
</h4>

<p><a name="1089744"> </a>Returns a record handle. If an error occurs, this function returns <code>NULL</code>, and <a href="DataMgr.html#998861"><code>DmGetLastErr()</code></a> returns an error code indicating the reason for failure. </p>

<p><a name="1089748"> </a>Some releases may display a fatal error message if the specified index is out of range. </p>
<h4>
  <a name="1089749"> </a>Comments 
</h4>

<p><a name="1089750"> </a>Returns a handle to the given record. Use this function only when viewing the record. This function successfully returns a handle to the record even if the record is busy.</p>

<p><a name="1089752"> </a>If the record is ROM-based (pointer accessed) this function returns the fake handle to it.</p>

<h3 class="hbH3">
  <a name="1004245"> </a>DmQuickSort Function <a href="#992934"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="1089758"> </a>Purpose 
</h4>

<p><a name="1089759"> </a>Sort records in a database. </p>
<h4>
  <a name="1089760"> </a>Declared In 
</h4>
<code>DataMgr.h<a name="1089761"> </a></code><h4>
  <a name="1089762"> </a>Prototype 
</h4>
<pre class="proto"><a name="1089763"></a>status_t DmQuickSort (
   const DmOpenRef <code class="par">dbR</code>,
   DmCompareFunctionType <code class="par">*compar</code>,
   int16_t <code class="par">other</code>
)
</pre>
<h4>
  <a name="1089764"> </a>Parameters 
</h4>

<dl>
<dt><a name="1089765"> </a><code>&rarr;  <i>dbR</i></code></dt>
<dd><a name="1089766"> </a>Database access pointer.</dd>

<dt><a name="1089767"> </a><code>&rarr;  <i>compar</i></code></dt>
<dd><a name="1089771"> </a>Comparison function. See <a href="DataMgr.html#1007926"><code>DmCompareFunctionType()</code></a>.</dd>

<dt><a name="1089772"> </a><code>&rarr;  <i>other</i></code></dt>
<dd><a name="1089773"> </a>Any value the application wants to pass to the comparison function. This parameter is often used to indicate a sort direction (ascending or descending).</dd>

</dl>
<h4>
  <a name="1089774"> </a>Returns 
</h4>

<p><a name="1089775"> </a>Returns <code>errNone</code> if no error, or one of the following if an error occurs:</p>

<dl>
<dt><a name="1089776"> </a><code>dmErrReadOnly</code></dt>
<dd><a name="1089777"> </a>You've attempted to write to or modify a database that is open in read-only mode.</dd>

<dt><a name="1089778"> </a><code>dmErrNotRecordDB</code></dt>
<dd><a name="1089779"> </a>You've attempted to perform a record function on a resource database. </dd>

</dl>

<p><a name="1089780"> </a>Some releases may display a fatal error message instead of returning the error code. </p>
<h4>
  <a name="1089781"> </a>Comments 
</h4>

<p><a name="1089782"> </a>Deleted records are placed last in any order. All others are sorted according to the passed comparison function.</p>

<p><a name="1089783"> </a>After <code>DmQuickSort()</code> returns, equal database records do not have a consistent order. That is, if <code>DmQuickSort()</code> is passed two equal records, their resulting order is unpredictable. To prevent records that contain the same data from being rearranged in an unpredictable order, pass the record's unique ID to the comparison function (using the <a href="DataMgr.html#994025"><code>DmSortRecordInfoType</code></a> structure). </p>

<p><a name="1089787"> </a><code>DmQuickSort()</code> contains its own stack to limit uncontrolled recursion. When the stack is full <code>DmQuickSort()</code> instead performs an insertion sort. An insertion sort is also performed when the number of records is low, avoiding the noticeable overhead of a quick sort with a small number of records. Finally, if the records seem mostly sorted an insertion sort is performed to move only those records that need moving.</p>
<h4>
  <a name="1089788"> </a>See Also 
</h4>

<p><a name="1089792"> </a><a href="DataMgr.html#1001522"><code>DmInsertionSort()</code></a></p>

<h3 class="hbH3">
  <a name="1004375"> </a>DmRecordInfoV50 Function <a href="#992934"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="1089999"> </a>Purpose 
</h4>

<p><a name="1090001"> </a>Retrieve the record information stored in the database header.</p>
<h4>
  <a name="1090002"> </a>Declared In 
</h4>
<code>DataMgr.h<a name="1090003"> </a></code><h4>
  <a name="1090004"> </a>Prototype 
</h4>
<pre class="proto"><a name="1090005"></a>status_t DmRecordInfoV50 (
   DmOpenRef <code class="par">dbRef</code>,
   uint16_t <code class="par">index</code>,
   uint16_t <code class="par">*pAttr</code>,
   uint32_t <code class="par">*pUID</code>,
   LocalID <code class="par">*pChunkID</code>
)
</pre>
<h4>
  <a name="1090006"> </a>Parameters 
</h4>

<dl>
<dt><a name="1090007"> </a><code>&rarr;  <i>dbRef</i></code></dt>
<dd><a name="1090008"> </a><code>DmOpenRef</code> to an open database.</dd>

<dt><a name="1090009"> </a><code>&rarr;  <i>index</i></code></dt>
<dd><a name="1090010"> </a>Index of the record.</dd>

<dt><a name="1090011"> </a><code>&larr;  <i>pAttr</i></code></dt>
<dd><a name="1090014"> </a>The record's attributes. See <a href="DataMgr.html#1041655">"Non-Schema Database Record Attributes."</a> Pass <code>NULL</code> for this parameter if you don't want to retrieve this value.</dd>

<dt><a name="1090016"> </a><code>&larr;  <i>pUID</i></code></dt>
<dd><a name="1090017"> </a>The record's unique ID. Pass <code>NULL</code> for this parameter if you don't want to retrieve this value.</dd>

<dt><a name="1090018"> </a><code>&larr;  <i>pChunkID</i></code></dt>
<dd><a name="1090019"> </a>The record's local ID. Pass <code>NULL</code> for this parameter if you don't want to retrieve this value.</dd>

</dl>
<h4>
  <a name="1090020"> </a>Returns 
</h4>

<p><a name="1090021"> </a>Returns <code>errNone</code> if no error or <code>dmErrIndexOutOfRange</code> if the specified record can't be found. Some releases may display a fatal error message instead of returning the error code. </p>
<h4>
  <a name="1132752"> </a>Compatibility 
</h4>

<p><a name="1132761"> </a>This function is provided for compatibility purposes only. Palm OS Cobalt applications should use one or more of the functions listed in the See Also section, below, instead.</p>
<h4>
  <a name="1090022"> </a>See Also 
</h4>

<p><a name="1090029"> </a><a href="DataMgr.html#1000420"><code>DmGetRecordAttr()</code></a>, <a href="DataMgr.html#1000470"><code>DmGetRecordCategory()</code></a>, <a href="DataMgr.html#1000600"><code>DmGetRecordID()</code></a>, <a href="DataMgr.html#1003917"><code>DmQueryNextInCategory()</code></a></p>

<h3 class="hbH3">
  <a name="1004437"> </a>DmRecoverHandle Function <a href="#992934"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="1090079"> </a>Purpose 
</h4>

<p><a name="1090080"> </a>Recover the handle of a storage heap chunk, given a pointer to its data.</p>
<h4>
  <a name="1090081"> </a>Declared In 
</h4>
<code>DataMgr.h<a name="1090082"> </a></code><h4>
  <a name="1090083"> </a>Prototype 
</h4>
<pre class="proto"><a name="1090084"></a>MemHandle DmRecoverHandle (
   MemPtr <code class="par">pChunk</code>
)
</pre>
<h4>
  <a name="1090085"> </a>Parameters 
</h4>

<dl>
<dt><a name="1090086"> </a><code>&rarr;  <i>pChunk</i></code></dt>
<dd><a name="1090087"> </a>Pointer to the chunk.</dd>

</dl>
<h4>
  <a name="1090088"> </a>Returns 
</h4>

<p><a name="1090089"> </a>Returns the handle of the chunk, or 0 if unsuccessful.</p>
<h4>
  <a name="1090090"> </a>Comments 
</h4>

<p><a name="1090091"> </a>Don't call this function for pointers in ROM.</p>

<h3 class="hbH3">
  <a name="1004479"> </a>DmReleaseRecord Function <a href="#992934"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="1090131"> </a>Purpose 
</h4>

<p><a name="1090132"> </a>Clear the <code>busy</code> bit for the given record and set the <code>dirty</code> bit if <code class="par">fDirty</code> is <code>true</code>.</p>
<h4>
  <a name="1090133"> </a>Declared In 
</h4>
<code>DataMgr.h<a name="1090134"> </a></code><h4>
  <a name="1090135"> </a>Prototype 
</h4>
<pre class="proto"><a name="1090136"></a>status_t DmReleaseRecord (
   DmOpenRef <code class="par">dbRef</code>,
   uint16_t <code class="par">index</code>,
   Boolean <code class="par">fDirty</code>
)
</pre>
<h4>
  <a name="1090137"> </a>Parameters 
</h4>

<dl>
<dt><a name="1090138"> </a><code>&rarr;  <i>dbRef</i></code></dt>
<dd><a name="1090139"> </a><code>DmOpenRef</code> to an open database.</dd>

<dt><a name="1090140"> </a><code>&rarr;  <i>index</i></code></dt>
<dd><a name="1090141"> </a>The record to unlock.</dd>

<dt><a name="1090142"> </a><code>&rarr;  <i>fDirty</i></code></dt>
<dd><a name="1090143"> </a>If <code>true</code>, set the <code>dirty</code> bit.</dd>

</dl>
<h4>
  <a name="1090144"> </a>Returns 
</h4>

<p><a name="1090145"> </a>Returns <code>errNone</code> if no error, or <code>dmErrIndexOutOfRange</code> if the specified index is out of range. Some releases may display a fatal error message instead of returning the error code. </p>
<h4>
  <a name="1090146"> </a>Comments 
</h4>

<p><a name="1090147"> </a>Call this function when you finish modifying or reading a record that you've called <a href="DataMgr.html#1000166"><code>DmGetRecord()</code></a> on or created using <a href="DataMgr.html#1001785"><code>DmNewRecord()</code></a>.</p>
<h4>
  <a name="1090154"> </a>See Also 
</h4>

<p><a name="1090158"> </a><a href="DataMgr.html#1000166"><code>DmGetRecord()</code></a> </p>

<h3 class="hbH3">
  <a name="1004572"> </a>DmReleaseResource Function <a href="#992934"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="1090166"> </a>Purpose 
</h4>

<p><a name="1090170"> </a>Release a resource acquired with <a href="DataMgr.html#1000738"><code>DmGetResource()</code></a>.</p>
<h4>
  <a name="1090171"> </a>Declared In 
</h4>
<code>DataMgr.h<a name="1090172"> </a></code><h4>
  <a name="1090173"> </a>Prototype 
</h4>
<pre class="proto"><a name="1090174"></a>status_t DmReleaseResource (
   MemHandle <code class="par">hResource</code>
)
</pre>
<h4>
  <a name="1090175"> </a>Parameters 
</h4>

<dl>
<dt><a name="1090176"> </a><code>&rarr;  <i>hResource</i></code></dt>
<dd><a name="1090177"> </a>Handle to resource.</dd>

</dl>
<h4>
  <a name="1090178"> </a>Returns 
</h4>

<p><a name="1090179"> </a>Returns <code>errNone</code> if no error.</p>
<h4>
  <a name="1090180"> </a>Comments 
</h4>

<p><a name="1090181"> </a>Marks a resource as being no longer needed by the application.</p>
<h4>
  <a name="1090182"> </a>See Also 
</h4>

<p><a name="1090189"> </a><a href="DataMgr.html#998108"><code>DmGet1ResourceV50()</code></a>, <a href="DataMgr.html#1000738"><code>DmGetResource()</code></a></p>

<h3 class="hbH3">
  <a name="1004638"> </a>DmRemoveRecord Function <a href="#992934"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="1091295"> </a>Purpose 
</h4>

<p><a name="1091296"> </a>Remove a record from a database and dispose of its data chunk.</p>
<h4>
  <a name="1091297"> </a>Declared In 
</h4>
<code>DataMgr.h<a name="1091298"> </a></code><h4>
  <a name="1091299"> </a>Prototype 
</h4>
<pre class="proto"><a name="1091300"></a>status_t DmRemoveRecord (
   DmOpenRef <code class="par">dbRef</code>,
   uint16_t <code class="par">index</code>
)
</pre>
<h4>
  <a name="1091301"> </a>Parameters 
</h4>

<dl>
<dt><a name="1091302"> </a><code>&rarr;  <i>dbRef</i></code></dt>
<dd><a name="1091303"> </a><code>DmOpenRef</code> to an open database.</dd>

<dt><a name="1091304"> </a><code>&rarr;  <i>index</i></code></dt>
<dd><a name="1091305"> </a>Index of the record to remove.</dd>

</dl>
<h4>
  <a name="1091306"> </a>Returns 
</h4>

<p><a name="1091307"> </a>Returns <code>errNone</code> if no error, or one of the following if an error occurs: </p>

<dl>
<dt><a name="1091308"> </a><code>dmErrReadOnly</code></dt>
<dd><a name="1091309"> </a>You've attempted to write to or modify a database that is open in read-only mode.</dd>

<dt><a name="1091310"> </a><code>dmErrIndexOutOfRange</code></dt>
<dd><a name="1091311"> </a>The specified index is out of range.</dd>

<dt><a name="1091312"> </a><code>dmErrNotRecordDB</code></dt>
<dd><a name="1091313"> </a>You've attempted to perform a record function on a resource database. </dd>

<dt><a name="1091314"> </a><code>memErrChunkLocked</code></dt>
<dd><a name="1091315"> </a>The associated memory chunk is locked. </dd>

<dt><a name="1091316"> </a><code>memErrInvalidParam</code></dt>
<dd><a name="1091317"> </a>A memory error occurred.</dd>

</dl>

<p><a name="1091318"> </a>Some releases may display a fatal error message instead of returning the error code. </p>
<h4>
  <a name="1091319"> </a>Comments 
</h4>

<p><a name="1091320"> </a>Disposes of the record's data chunk and removes the record's entry from the database header. <code>DmRemoveRecord()</code> should only be used for newly-created records that have just been deleted or records that have never been synchronized.</p>
<h4>
  <a name="1091321"> </a>See Also 
</h4>

<p><a name="1091328"> </a><a href="DataMgr.html#997011"><code>DmDetachRecord()</code></a>, <a href="DataMgr.html#996913"><code>DmDeleteRecord()</code></a>, <a href="DataMgr.html#995341"><code>DmArchiveRecord()</code></a>, <a href="DataMgr.html#1001785"><code>DmNewRecord()</code></a></p>

<h3 class="hbH3">
  <a name="1004684"> </a>DmRemoveResource Function <a href="#992934"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="1091472"> </a>Purpose 
</h4>

<p><a name="1091473"> </a>Delete a resource from a resource database.</p>
<h4>
  <a name="1091474"> </a>Declared In 
</h4>
<code>DataMgr.h<a name="1091475"> </a></code><h4>
  <a name="1091476"> </a>Prototype 
</h4>
<pre class="proto"><a name="1091477"></a>status_t DmRemoveResource (
   DmOpenRef <code class="par">dbRef</code>,
   uint16_t <code class="par">index</code>
)
</pre>
<h4>
  <a name="1091478"> </a>Parameters 
</h4>

<dl>
<dt><a name="1091479"> </a><code>&rarr;  <i>dbRef</i></code></dt>
<dd><a name="1091480"> </a><code>DmOpenRef</code> to an open database.</dd>

<dt><a name="1091481"> </a><code>&rarr;  <i>index</i></code></dt>
<dd><a name="1091482"> </a>Index of resource to delete.</dd>

</dl>
<h4>
  <a name="1091483"> </a>Returns 
</h4>

<p><a name="1091484"> </a>Returns <code>errNone</code> if no error, or one of the following if an error occurs: </p>

<dl>
<dt><a name="1091485"> </a><code>dmErrCorruptDatabase</code></dt>
<dd><a name="1091486"> </a>The database is corrupted.</dd>

<dt><a name="1091487"> </a><code>dmErrIndexOutOfRange</code></dt>
<dd><a name="1091488"> </a>The specified index is out of range.</dd>

<dt><a name="1091489"> </a><code>dmErrReadOnly</code></dt>
<dd><a name="1091490"> </a>You've attempted to write to or modify a database that is open in read-only mode.</dd>

<dt><a name="1091491"> </a><code>memErrChunkLocked</code></dt>
<dd><a name="1091492"> </a>The associated memory chunk is locked. </dd>

<dt><a name="1091493"> </a><code>memErrInvalidParam</code></dt>
<dd><a name="1091494"> </a>A memory error occurred.</dd>

<dt><a name="1091495"> </a><code>memErrNotEnoughSpace</code></dt>
<dd><a name="1091496"> </a>A memory error occurred.</dd>

</dl>

<p><a name="1091497"> </a>May display a fatal error message if the database is not a resource database.</p>
<h4>
  <a name="1091498"> </a>Comments 
</h4>

<p><a name="1091499"> </a>This function disposes of the Memory Manager chunk that holds the given resource and removes its entry from the database header.</p>
<h4>
  <a name="1091500"> </a>See Also 
</h4>

<p><a name="1091507"> </a><a href="DataMgr.html#997061"><code>DmDetachResource()</code></a>, <a href="DataMgr.html#1004684"><code>DmRemoveResource()</code></a>, <a href="DataMgr.html#995445"><code>DmAttachResource()</code></a></p>

<h3 class="hbH3">
  <a name="1090390"> </a>DmRemoveSecretRecords Function <a href="#992934"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="1091682"> </a>Purpose 
</h4>

<p><a name="1091684"> </a>Remove all secret records.</p>
<h4>
  <a name="1091685"> </a>Declared In 
</h4>
<code>DataMgr.h<a name="1091686"> </a></code><h4>
  <a name="1091687"> </a>Prototype 
</h4>
<pre class="proto"><a name="1091688"></a>status_t DmRemoveSecretRecords (
   DmOpenRef <code class="par">dbRef</code>
)
</pre>
<h4>
  <a name="1091689"> </a>Parameters 
</h4>

<dl>
<dt><a name="1091690"> </a><code>&rarr;  <i>dbRef</i></code></dt>
<dd><a name="1091691"> </a><code>DmOpenRef</code> to an open database.</dd>

</dl>
<h4>
  <a name="1091692"> </a>Returns 
</h4>

<p><a name="1091693"> </a>Returns <code>errNone</code> if no error, or one of the following if an error occurs: </p>

<dl>
<dt><a name="1091694"> </a><code>dmErrReadOnly</code></dt>
<dd><a name="1091695"> </a>You've attempted to write to or modify a database that is open in read-only mode.</dd>

<dt><a name="1091696"> </a><code>dmErrNotRecordDB</code></dt>
<dd><a name="1091697"> </a>You've attempted to perform a record function on a resource database. </dd>

</dl>

<p><a name="1091698"> </a>Some releases may display a fatal error message instead of returning the error code. </p>
<h4>
  <a name="1091699"> </a>See Also 
</h4>

<p><a name="1091706"> </a><a href="DataMgr.html#1004638"><code>DmRemoveRecord()</code></a>, <a href="DataMgr.html#1004375"><code>DmRecordInfoV50()</code></a>, <a href="DataMgr.html#1007301"><code>DmSetRecordInfoV50()</code></a></p>

<h3 class="hbH3">
  <a name="1005056"> </a>DmResetRecordStates Function <a href="#992934"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="1005061"> </a>Purpose 
</h4>

<p><a name="1005064"> </a>For each record in a non-schema database, unlocks the record and clears the busy bit.</p>
<h4>
  <a name="1005066"> </a>Declared In 
</h4>
<code>DataMgr.h<a name="1005069"> </a></code><h4>
  <a name="1005071"> </a>Prototype 
</h4>
<pre class="proto"><a name="1005074"></a>status_t DmResetRecordStates (
   DmOpenRef <code class="par">dbRef</code>
)
</pre>
<h4>
  <a name="1005076"> </a>Parameters 
</h4>

<dl>
<dt><a name="1005079"> </a><code>&rarr;  <i>dbRef</i></code></dt>
<dd><a name="1108556"> </a><code>DmOpenRef</code> to an open non-schema database.</dd>

</dl>
<h4>
  <a name="1005087"> </a>Returns 
</h4>

<p><a name="1005137"> </a>Returns <code>errNone</code> if the operation completed successfully, or one of the following otherwise:</p>

<dl>
<dt><a name="1108621"> </a><code>dmErrInvalidParam</code></dt>
<dd><a name="1108638"> </a><code class="par">dbRef</code> doesn't reference an open database, or <code class="par">dbRef</code> references a schema database.</dd>

<dt><a name="1108643"> </a><code>dmErrReadOnly</code></dt>
<dd><a name="1108648"> </a>The specified database isn't open for writing.</dd>

<dt><a name="1108737"> </a><code>dmErrROMBased</code></dt>
<dd><a name="1108750"> </a>The specified database is located in ROM.</dd>

<dt><a name="1108763"> </a><code>memErrInvalidParam</code></dt>
<dd><a name="1108768"> </a>A memory error occurred.</dd>

</dl>
<h4>
  <a name="1005158"> </a>See Also 
</h4>

<p><a name="1005161"> </a><a href="DataMgr.html#1006959"><code>DmSetRecordAttr()</code></a></p>

<h3 class="hbH3">
  <a name="1005163"> </a>DmResizeRecord Function <a href="#992934"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="1091860"> </a>Purpose 
</h4>

<p><a name="1091861"> </a>Resize a record by index.</p>
<h4>
  <a name="1091862"> </a>Declared In 
</h4>
<code>DataMgr.h<a name="1091863"> </a></code><h4>
  <a name="1091864"> </a>Prototype 
</h4>
<pre class="proto"><a name="1091865"></a>MemHandle DmResizeRecord (
   DmOpenRef <code class="par">dbRef</code>,
   uint16_t <code class="par">index</code>,
   uint32_t <code class="par">newSize</code>
)
</pre>
<h4>
  <a name="1091866"> </a>Parameters 
</h4>

<dl>
<dt><a name="1091867"> </a><code>&rarr;  <i>dbRef</i></code></dt>
<dd><a name="1091868"> </a><code>DmOpenRef</code> to an open database.</dd>

<dt><a name="1091869"> </a><code>&rarr;  <i>index</i></code></dt>
<dd><a name="1091870"> </a>Which record to retrieve.</dd>

<dt><a name="1091871"> </a><code>&rarr;  <i>newSize</i></code></dt>
<dd><a name="1091872"> </a>New size of record.</dd>

</dl>
<h4>
  <a name="1091873"> </a>Returns 
</h4>

<p><a name="1091874"> </a>Handle to resized record. Returns <code>NULL</code> if there is not enough space to resize the record, and <a href="DataMgr.html#998861"><code>DmGetLastErr()</code></a> returns an error code indicating the reason for failure. Some releases may display a fatal error message instead of returning the error code. </p>
<h4>
  <a name="1091878"> </a>Comments 
</h4>

<p><a name="1091879"> </a>As this function reallocates the record, the handle may change, so be sure to use the returned handle to access the resized record.</p>

<h3 class="hbH3">
  <a name="1005213"> </a>DmResizeResource Function <a href="#992934"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="1091943"> </a>Purpose 
</h4>

<p><a name="1091944"> </a>Resize a resource and return the new handle. </p>
<h4>
  <a name="1091945"> </a>Declared In 
</h4>
<code>DataMgr.h<a name="1091946"> </a></code><h4>
  <a name="1091947"> </a>Prototype 
</h4>
<pre class="proto"><a name="1091948"></a>MemHandle DmResizeResource (
   MemHandle <code class="par">hResource</code>,
   uint32_t <code class="par">size</code>
)
</pre>
<h4>
  <a name="1091949"> </a>Parameters 
</h4>

<dl>
<dt><a name="1091950"> </a><code>&rarr;  <i>hResource</i></code></dt>
<dd><a name="1091951"> </a>Handle to resource.</dd>

<dt><a name="1091952"> </a><code>&rarr;  <i>size</i></code></dt>
<dd><a name="1091953"> </a>Desired new size of resource.</dd>

</dl>
<h4>
  <a name="1091954"> </a>Returns 
</h4>

<p><a name="1091955"> </a>Returns a handle to newly sized resource. Returns <code>NULL</code> if there is not enough space to resize the resource, and <a href="DataMgr.html#998861"><code>DmGetLastErr()</code></a> returns an error code indicating the reason for failure. Some releases may display a fatal error message instead of returning the error code. </p>
<h4>
  <a name="1091959"> </a>Comments 
</h4>

<p><a name="1091960"> </a>Resizes the resource and returns a new handle.</p>

<p><a name="1091961"> </a>The handle may change if the resource had to be reallocated in a different data heap because there was not enough space in its present data heap.</p>

<h3 class="hbH3">
  <a name="1005302"> </a>DmResourceInfo Function <a href="#992934"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="1091984"> </a>Purpose 
</h4>

<p><a name="1091986"> </a>Retrieve information on a given resource.</p>
<h4>
  <a name="1091987"> </a>Declared In 
</h4>
<code>DataMgr.h<a name="1091988"> </a></code><h4>
  <a name="1091989"> </a>Prototype 
</h4>
<pre class="proto"><a name="1091990"></a>status_t DmResourceInfo (
   DmOpenRef <code class="par">dbRef</code>,
   uint16_t <code class="par">index</code>,
   DmResourceType <code class="par">*pResType</code>,
   DmResourceID <code class="par">*pResID</code>,
   MemHandle <code class="par">*pChunkHandle</code>
)
</pre>
<h4>
  <a name="1091991"> </a>Parameters 
</h4>

<dl>
<dt><a name="1091992"> </a><code>&rarr;  <i>dbRef</i></code></dt>
<dd><a name="1091993"> </a><code>DmOpenRef</code> to an open database.</dd>

<dt><a name="1091994"> </a><code>&rarr;  <i>index</i></code></dt>
<dd><a name="1091995"> </a>Index of resource to get info on.</dd>

<dt><a name="1091996"> </a><code>&larr;  <i>pResType</i></code></dt>
<dd><a name="1091997"> </a>The resource type. Pass <code>NULL</code> if you don't want to retrieve this information.</dd>

<dt><a name="1091998"> </a><code>&larr;  <i>pResID</i></code></dt>
<dd><a name="1091999"> </a>The resource ID. Pass <code>NULL</code> if you don't want to retrieve this information.</dd>

<dt><a name="1092000"> </a><code>&larr;  <i>pChunkHandle</i></code></dt>
<dd><a name="1092001"> </a>Handle for the resource data. Pass <code>NULL</code> if you don't want to retrieve this information.</dd>

</dl>
<h4>
  <a name="1092002"> </a>Returns 
</h4>

<p><a name="1092003"> </a>Returns <code>errNone</code> if no error or <code>dmErrIndexOutOfRange</code> if an error occurred. Unlike <a href="DataMgr.html#1005384"><code>DmResourceInfoV50()</code></a>, no fatal error message is displayed if the database is not a resource database. </p>
<h4>
  <a name="1092007"> </a>Comments 
</h4>

<p><a name="1092008"> </a>If <code class="par">dbRef</code> is a pointer to a base resource database, the information returned is about the resource from that database alone; this function ignores any associated overlay. </p>
<h4>
  <a name="1092009"> </a>See Also 
</h4>

<p><a name="1092016"> </a><a href="DataMgr.html#1000738"><code>DmGetResource()</code></a>, <a href="DataMgr.html#998108"><code>DmGet1ResourceV50()</code></a>, <a href="DataMgr.html#1007394"><code>DmSetResourceInfo()</code></a>, <a href="DataMgr.html#997720"><code>DmFindResource()</code></a>, <a href="DataMgr.html#997774"><code>DmFindResourceType()</code></a></p>

<h3 class="hbH3">
  <a name="1005384"> </a>DmResourceInfoV50 Function <a href="#992934"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="1092178"> </a>Purpose 
</h4>

<p><a name="1092180"> </a>Retrieve information on a given resource.</p>
<h4>
  <a name="1092181"> </a>Declared In 
</h4>
<code>DataMgr.h<a name="1092182"> </a></code><h4>
  <a name="1092183"> </a>Prototype 
</h4>
<pre class="proto"><a name="1092184"></a>status_t DmResourceInfoV50 (
   DmOpenRef <code class="par">dbRef</code>,
   uint16_t <code class="par">index</code>,
   DmResourceType <code class="par">*pResType</code>,
   DmResourceID <code class="par">*pResID</code>,
   LocalID <code class="par">*pChunkLocalID</code>
)
</pre>
<h4>
  <a name="1092185"> </a>Parameters 
</h4>

<dl>
<dt><a name="1092186"> </a><code>&rarr;  <i>dbRef</i></code></dt>
<dd><a name="1092187"> </a><code>DmOpenRef</code> to an open database.</dd>

<dt><a name="1092188"> </a><code>&rarr;  <i>index</i></code></dt>
<dd><a name="1092189"> </a>Index of resource to get info on.</dd>

<dt><a name="1092190"> </a><code>&larr;  <i>pResType</i></code></dt>
<dd><a name="1092191"> </a>The resource type. Pass <code>NULL</code> if you don't want to retrieve this information.</dd>

<dt><a name="1092192"> </a><code>&larr;  <i>pResID</i></code></dt>
<dd><a name="1092193"> </a>The resource ID. Pass <code>NULL</code> if you don't want to retrieve this information.</dd>

<dt><a name="1092194"> </a><code>&larr;  <i>pChunkLocalID</i></code></dt>
<dd><a name="1092195"> </a>The Memory Manager local ID of the resource data. Pass <code>NULL</code> if you don't want to retrieve this information.</dd>

</dl>
<h4>
  <a name="1092196"> </a>Returns 
</h4>

<p><a name="1092197"> </a>Returns <code>errNone</code> if no error or <code>dmErrIndexOutOfRange</code> if an error occurred. May display a fatal error message if the database is not a resource database. </p>
<h4>
  <a name="1092198"> </a>Comments 
</h4>

<p><a name="1092199"> </a>If <code class="par">dbRef</code> is a pointer to a base resource database, the information returned is about the resource from that database alone; this function ignores any associated overlay. </p>
<h4>
  <a name="1132775"> </a>Compatibility 
</h4>

<p><a name="1132816"> </a>This function is provided for compatibility purposes only. Palm OS Cobalt applications should use <a href="DataMgr.html#1005302"><code>DmResourceInfo()</code></a> instead.</p>
<h4>
  <a name="1092200"> </a>See Also 
</h4>

<p><a name="1092207"> </a><a href="DataMgr.html#1005302"><code>DmResourceInfo()</code></a>, <a href="DataMgr.html#1000738"><code>DmGetResource()</code></a>, <a href="DataMgr.html#998108"><code>DmGet1ResourceV50()</code></a>, <a href="DataMgr.html#1007394"><code>DmSetResourceInfo()</code></a>, <a href="DataMgr.html#997720"><code>DmFindResource()</code></a>, <a href="DataMgr.html#997774"><code>DmFindResourceType()</code></a></p>

<h3 class="hbH3">
  <a name="1005674"> </a>DmRestoreFinalize Function <a href="#992934"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="1092249"> </a>Purpose 
</h4>

<p><a name="1092250"> </a>Complete or abort an on-going database restore operation.</p>
<h4>
  <a name="1092251"> </a>Declared In 
</h4>
<code>DataMgr.h<a name="1092252"> </a></code><h4>
  <a name="1092253"> </a>Prototype 
</h4>
<pre class="proto"><a name="1092254"></a>status_t DmRestoreFinalize (
   DmBackupRestoreStatePtr <code class="par">pState</code>,
   Boolean <code class="par">fAbort</code>,
   Boolean <code class="par">fOverwrite</code>,
   DatabaseID <code class="par">*pDbID</code>
)
</pre>
<h4>
  <a name="1092255"> </a>Parameters 
</h4>

<dl>
<dt><a name="1092256"> </a><code>&rarr;  <i>pState</i></code></dt>
<dd><a name="1092260"> </a>Pointer to a <a href="DataMgr.html#993225"><code>DmBackupRestoreStateType</code></a> structure allocated by the caller and initialized with <a href="DataMgr.html#995549"><code>DmBackupInitialize()</code></a>.</dd>

<dt><a name="1092264"> </a><code>&rarr;  <i>fAbort</i></code></dt>
<dd><a name="1092265"> </a>Set to <code>true</code> to abort an on-going backup operation, or <code>false</code> to clean up after a successful backup.</dd>

<dt><a name="1092266"> </a><code>&rarr;  <i>fOverwrite</i></code></dt>
<dd><a name="1092267"> </a>Set to <code>true</code> to overwrite an existing matching database (if there is one), or <code>false</code> to leave the existing matching database intact.</dd>

<dt><a name="1092268"> </a><code>&larr;  <i>pDbID</i></code></dt>
<dd><a name="1092269"> </a>Pointer to a variable that receives the identifier for the restored database, or <code>NULL</code> if the database identifier isn't needed.</dd>

</dl>
<h4>
  <a name="1092270"> </a>Returns 
</h4>

<p><a name="1092271"> </a>Returns <code>errNone</code> if the database image was successfully restored, <code>dmErrOperationAborted</code> if the restore operation was cancelled, or one of the following errors otherwise:</p>

<dl>
<dt><a name="1092272"> </a><code>dmErrInvalidParam</code></dt>
<dd><a name="1092273"> </a>One of the parameters is invalid or corrupt.</dd>

<dt><a name="1092274"> </a><code>dmErrMemError</code></dt>
<dd><a name="1092275"> </a>A memory error occurred.</dd>

<dt><a name="1092276"> </a><code>dmErrAlreadyExists</code></dt>
<dd><a name="1092277"> </a>The database being restored already exists, and the <code class="par">fOverwrite</code> parameter was set to <code>false</code>.</dd>

</dl>
<h4>
  <a name="1092278"> </a>Comments 
</h4>

<p><a name="1092279"> </a>This function allows the Data Manager to perform a final clean up of the internal structures it allocated for the operation. Applications should always call this function after having started a restore operation, whether or not the restore completed successfully. See <a href="DataMgr.html#1005778"><code>DmRestoreUpdate()</code></a> for sample code illustrating this function's use.</p>

<p><a name="1138350"> </a>The restore operation can be used with schema, extended, or classic databases.</p>
<h4>
  <a name="1092283"> </a>See Also 
</h4>

<p><a name="1092290"> </a><a href="DataMgr.html#995503"><code>DmBackupFinalize()</code></a>, <a href="DataMgr.html#1005732"><code>DmRestoreInitialize()</code></a></p>

<h3 class="hbH3">
  <a name="1005732"> </a>DmRestoreInitialize Function <a href="#992934"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="1092396"> </a>Purpose 
</h4>

<p><a name="1092397"> </a>Initialize the Data Manager prior to starting a restore operation on the specified database.</p>
<h4>
  <a name="1092398"> </a>Declared In 
</h4>
<code>DataMgr.h<a name="1092399"> </a></code><h4>
  <a name="1092400"> </a>Prototype 
</h4>
<pre class="proto"><a name="1092401"></a>status_t DmRestoreInitialize (
   DmBackupRestoreStatePtr <code class="par">pState</code>,
   DmDatabaseInfoPtr <code class="par">pDbInfo</code>
)
</pre>
<h4>
  <a name="1092402"> </a>Parameters 
</h4>

<dl>
<dt><a name="1092403"> </a><code>&rarr;  <i>pState</i></code></dt>
<dd><a name="1092407"> </a>Pointer to a <a href="DataMgr.html#993225"><code>DmBackupRestoreStateType</code></a> structure allocated by the caller.</dd>

<dt><a name="1092408"> </a><code>&rarr;  <i>pDbInfo</i></code></dt>
<dd><a name="1092412"> </a>Pointer to a <a href="DataMgr.html#993322"><code>DmDatabaseInfoType</code></a> structure that will receive information about the database being restored. This structure will receive its information after you call <a href="DataMgr.html#1005778"><code>DmRestoreUpdate()</code></a>. Set to <code>NULL</code> if you don't want to receive this information.</dd>

</dl>
<h4>
  <a name="1092416"> </a>Returns 
</h4>

<p><a name="1092417"> </a>Returns <code>errNone</code> if the initialization was successful, or one of the following if an error occurred:</p>

<dl>
<dt><a name="1092418"> </a><code>dmErrAccessDenied</code></dt>
<dd><a name="1092419"> </a>The caller was not authorized to perform a restore operation for the specified database.</dd>

<dt><a name="1092420"> </a><code>dmErrInvalidParam</code></dt>
<dd><a name="1092421"> </a>One of the parameters is invalid or corrupt.</dd>

<dt><a name="1092422"> </a><code>dmErrMemError</code></dt>
<dd><a name="1092423"> </a>A memory error occurred.</dd>

</dl>
<h4>
  <a name="1092424"> </a>Comments 
</h4>

<p><a name="1092425"> </a>Use <code>DmRestoreInitialize()</code> to start a database backup operation. See <a href="DataMgr.html#1005778"><code>DmRestoreUpdate()</code></a> for sample code illustrating this function's use.</p>

<p><a name="1138485"> </a>The restore operation can be used with schema, extended, or classic databases.</p>

<div><hr>
  <a name="1185833"> </a> <b>IMPORTANT: </b> When called from the main application thread, this function may block. While blocked, the application will not receive events and won't redraw its windows. As well, deferred sublaunches and notifications won't execute while the main application thread is blocked.
<hr>
</div>
<h4>
  <a name="1092429"> </a>See Also 
</h4>

<p><a name="1092436"> </a><a href="DataMgr.html#995549"><code>DmBackupInitialize()</code></a>, <a href="DataMgr.html#1005674"><code>DmRestoreFinalize()</code></a></p>

<h3 class="hbH3">
  <a name="1005778"> </a>DmRestoreUpdate Function <a href="#992934"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="1092463"> </a>Purpose 
</h4>

<p><a name="1092464"> </a>Reassemble a database within the storage heap from a database image stream held within the specified buffer.</p>
<h4>
  <a name="1092465"> </a>Declared In 
</h4>
<code>DataMgr.h<a name="1092466"> </a></code><h4>
  <a name="1092467"> </a>Prototype 
</h4>
<pre class="proto"><a name="1092468"></a>status_t DmRestoreUpdate (
   DmBackupRestoreStatePtr <code class="par">pState</code>,
   MemPtr <code class="par">pBuffer</code>,
   uint32_t <code class="par">size</code>,
   Boolean <code class="par">endOfData</code>,
   Boolean <code class="par">*pfDbInfoAvailable</code>
)
</pre>
<h4>
  <a name="1092469"> </a>Parameters 
</h4>

<dl>
<dt><a name="1092470"> </a><code>&rarr;  <i>pState</i></code></dt>
<dd><a name="1092474"> </a>Pointer to a <a href="DataMgr.html#993225"><code>DmBackupRestoreStateType</code></a> structure allocated by the caller and initialized with <a href="DataMgr.html#1005732"><code>DmRestoreInitialize()</code></a>.</dd>

<dt><a name="1092478"> </a><code>&rarr;  <i>pBuffer</i></code></dt>
<dd><a name="1092479"> </a>Pointer to a buffer to hold the backed-up database image that is being restored.</dd>

<dt><a name="1092480"> </a><code>&rarr;  <i>size</i></code></dt>
<dd><a name="1092481"> </a>Size, in bytes, of the database image data held within <code class="par">pBuffer</code>.</dd>

<dt><a name="1185846"> </a><code>&rarr;  <i>endOfData</i></code></dt>
<dd><a name="1185850"> </a>Set this parameter to <code>true</code> to indicate that there is no additional data (beyond what is in <code class="par">pBuffer</code>). Set it to <code>false</code> if you will be making additional calls to <code>DmRestoreUpdate()</code>.</dd>

<dt><a name="1092482"> </a><code>&larr;  <i>pfDbInfoAvailable</i></code></dt>
<dd><a name="1092483"> </a>Pointer to a Boolean variable that is to indicate whether the information about the database being restored is available, or <code>NULL</code> if you don't need the database information. If true, the information was written to the <a href="DataMgr.html#993322"><code>DmDatabaseInfoType</code></a> structure you specified when calling <a href="DataMgr.html#1005732"><code>DmRestoreInitialize()</code></a>.</dd>

</dl>
<h4>
  <a name="1092490"> </a>Returns 
</h4>

<p><a name="1092491"> </a>Returns <code>errNone</code> if the operation was successful, or one of the following if an error occurred:</p>

<dl>
<dt><a name="1092492"> </a><code>dmErrInvalidParam</code></dt>
<dd><a name="1092493"> </a>One of the parameters is invalid or corrupt.</dd>

<dt><a name="1092494"> </a><code>dmErrMemError</code></dt>
<dd><a name="1092495"> </a>A memory error occurred which prevented the restore operation from continuing.</dd>

</dl>
<h4>
  <a name="1092496"> </a>Comments 
</h4>

<p><a name="1138498"> </a>Use this function, along with <a href="DataMgr.html#1005732"><code>DmRestoreInitialize()</code></a> and <a href="DataMgr.html#1005674"><code>DmRestoreFinalize()</code></a>, to restore a schema, extended, or classic database from its serial image.</p>

<p><a name="1092504"> </a>If the serial image doesn't reside in a single buffer, you'll need to call this function several times before you've completely restored the complete database. Call <code>DmRestoreUpdate()</code> as many times as required until all of the database image data has been successfully processed by this function. For all but the last call to this function, <code class="par">endOfData</code> must be set to <code>false</code>. The last time you call it, set <code class="par">endOfData</code> to <code>true</code> (note that the last call needn't contain any data in <code class="par">pBuffer</code>; see the example, below, for code that does this). Finally, call <code>DmRestoreFinalize()</code> to complete the operation and have the database once again accessible from the Data Manager's database directory list.</p>

<p><a name="1092505"> </a>If <code class="par">pfDbInfoAvailable</code> is not <code>NULL</code>, <code>DmRestoreUpdate()</code> sets the pointed-to Boolean variable to <code>true</code> when it has received enough of the database image to be able to return information about it. The actual database information is returned through the <code>DmDatabaseInfoType</code> structure that you specified when calling <code>DmRestoreInitialize()</code>.</p>

<p><a name="1092506"> </a>If <code>DmRestoreUpdate()</code> returns an error code other than <code>errNone</code>, the operation has been aborted due to a fatal error. You must still perform a call to <code>DmRestoreFinalize()</code> to let the Data Manager perform a final cleanup of the internal structures it allocated for the operation.</p>
<h4>
  <a name="1092507"> </a>Example 
</h4>

<p><a name="1092511"> </a>This sample code shows how to use <a href="DataMgr.html#1005732"><code>DmRestoreInitialize()</code></a>, <a href="DataMgr.html#1005778"><code>DmRestoreUpdate()</code></a>, and <a href="DataMgr.html#1005674"><code>DmRestoreFinalize()</code></a> to restore database from a serial image. This code employs a fictitious <code>DoesUserWantToOverwrite()</code> function to let the user decide whether to overwrite a matching database (if any).</p>

<div class="CodeRule"><hr></div><pre class="CodeBlock">
status_t error;<a name="1092518"> </a>
DatabaseID dbID;<a name="1092519"> </a>
DmBackupRestoreStateType restoreState;<a name="1092520"> </a>
char buffer[BUFFER_SIZE];<a name="1092521"> </a>
uint32_t size;<a name="1092522"> </a>
Boolean fAbort;<a name="1092523"> </a>
Boolean fGotDbInfo;<a name="1092524"> </a>
Boolean fDone = false;<a name="1092525"> </a>
Boolean fOverwrite = false;<a name="1092526"> </a>
Boolean fAlreadyAsked = false;<a name="1092527"> </a>
DmDatabaseInfoType databaseInfo;<a name="1092528"> </a>
char dbName[dmDBNameLength];<a name="1092529"> </a>
uint32_t type;<a name="1092530"> </a>
uint32_t creator;<a name="1092531"> </a>
uint16_t attributes;<a name="1092532"> </a>
<a name="1092533"> </a>
// Set up the DmDatabaseInfoType structure so that we will<a name="1092534"> </a>
// get the information we want about the database being<a name="1092535"> </a>
// restored...<a name="1092536"> </a>
MemSet(&amp;databaseInfo, sizeof(databaseInfo), 0);<a name="1092537"> </a>
databaseInfo.pName = dbName;<a name="1092538"> </a>
databaseInfo.pType = &amp;type;<a name="1092539"> </a>
databaseInfo.pCreator = &amp;creator;<a name="1092540"> </a>
databaseInfo.pAttributes = &amp;attributes;<a name="1092541"> </a>
<a name="1092542"> </a>
error = DmRestoreInitialize(&amp;restoreState, &amp;databaseInfo);<a name="1092543"> </a>
if (error == errNone) {<a name="1092545"> </a>
   do {<a name="1092546"> </a>
      size = sizeof(buffer);<a name="1092547"> </a>
<a name="1092548"> </a>
      // Get a chunk from the database image data out of some<a name="1092549"> </a>
      // I/O channel. We assume this function returns false<a name="1092550"> </a>
      // when there is no more data to receive for the<a name="1092551"> </a>
      // database image.<a name="1092552"> </a>
      if (GetDatabaseImageData(buffer, &amp;size)) {<a name="1092553"> </a>
         error = DmRestoreUpdate(&amp;restoreState, buffer,<a name="1092554"> </a>
            size, false, &amp;fGotDbInfo);<a name="1092555"> </a>
<a name="1092556"> </a>
         // Set the abort flag if we got back an error or if<a name="1092557"> </a>
         // the user decided to cancel the operation...<a name="1092558"> </a>
         fAbort = (error != errNone) | DidUserCancel();<a name="1092559"> </a>
<a name="1092560"> </a>
         if (!fAbort &amp;&amp; fGotDbInfo &amp;&amp; !fAlreadyAsked) {<a name="1092561"> </a>
            // We just got the database info we asked so now<a name="1092562"> </a>
            // we ask the user whether they want to<a name="1092563"> </a>
            // overwrite the existing database with this<a name="1092564"> </a>
            // one...<a name="1092565"> </a>
            fOverwrite = DoesUserWantToOverwrite(&amp;pDbInfo,<a name="1092566"> </a>
               &amp;fFoundDb);<a name="1092567"> </a>
<a name="1092568"> </a>
            // If the user doesn't want to overwrite and we<a name="1092569"> </a>
            // found an existing database in the storage<a name="1092570"> </a>
            // heap, then set the abort flag to break out of<a name="1092571"> </a>
            // the loop.<a name="1092572"> </a>
            fAbort = !fOverwrite &amp;&amp; fFoundDb;<a name="1092573"> </a>
<a name="1092574"> </a>
            // Use this flag to make sure we don't ask the<a name="1092575"> </a>
            // user twice (or more) the same question in case<a name="1092576"> </a>
            // where we didn't find a matching database or <a name="1092577"> </a>
            // they wanted to overwrite anyway...<a name="1092578"> </a>
            fAlreadyAsked = true;<a name="1092579"> </a>
         }<a name="1092580"> </a>
      } else<a name="1092581"> </a>
         fDone = true;<a name="1092582"> </a>
<a name="1092583"> </a>
   } while(!fDone &amp;&amp; !fAbort);<a name="1092584"> </a>
<a name="1186054"> </a>
   // call DmRestoreUpdate one last time with no data and<a name="1186071"> </a>
   // with the endOfData flag set to mark the end of data<a name="1186072"> </a>
   error = DmRestoreUpdate(&amp;restoreState, buffer,<a name="1186061"> </a>
      size, true, &amp;fGotDbInfo);<a name="1186062"> </a>
<a name="1092585"> </a>
   // Always call DmRestoreFinalize to complete the restore<a name="1092586"> </a>
   // operation ...<a name="1092587"> </a>
   error = DmRestoreFinalize(&amp;restoreState, fAbort,<a name="1092588"> </a>
      fOverwrite, &amp;dbID);<a name="1092589"> </a>
}<a name="1092590"> </a>
<a name="1092591"> </a>
if (error == errNone) {<a name="1092592"> </a>
   // Restore operation completed successfully...<a name="1092593"> </a>
<a name="1092594"> </a>
   // Now we can use the dbID we got back to operate on the<a name="1092595"> </a>
   // newly-restored database. Note also that we can also use<a name="1092596"> </a>
   // the database information we got back during the restore<a name="1092597"> </a>
   // operation.<a name="1092598"> </a>
} else {<a name="1092599"> </a>
   // A fatal error occurred...<a name="1092600"> </a>
     <a name="1092601"> </a>
   if (error == dmErrOperationAborted) {<a name="1092602"> </a>
      // The user aborted. Handle it.<a name="1092603"> </a>
   } else<a name="1092604"> </a>
      if (error == dmErrAlreadyExists) {<a name="1092605"> </a>
         // The database already exists! Handle this.<a name="1092606"> </a>
      } else {<a name="1092607"> </a>
         // Some other error occurred.<a name="1092608"> </a>
   }<a name="1092609"> </a>
}<a name="1092610"> </a>
</pre><div class="CodeRule"><hr></div>

<h4>
  <a name="1092611"> </a>See Also 
</h4>

<p><a name="1092615"> </a><a href="DataMgr.html#995634"><code>DmBackupUpdate()</code></a>, <a href="DataMgr.html#995834"><code>DmCreateDatabaseFromImage()</code></a></p>

<h3 class="hbH3">
  <a name="1006040"> </a>DmSearchRecordOpenDatabases Function <a href="#992934"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="1092857"> </a>Purpose 
</h4>

<p><a name="1092858"> </a>Search all open record databases for a record with the handle passed.</p>
<h4>
  <a name="1092859"> </a>Declared In 
</h4>
<code>DataMgr.h<a name="1092860"> </a></code><h4>
  <a name="1092861"> </a>Prototype 
</h4>
<pre class="proto"><a name="1092862"></a>uint16_t DmSearchRecordOpenDatabases (
   MemHandle <code class="par">hRecord</code>,
   DmOpenRef <code class="par">*pDbRef</code>
)
</pre>
<h4>
  <a name="1092863"> </a>Parameters 
</h4>

<dl>
<dt><a name="1092864"> </a><code>&rarr;  <i>hRecord</i></code></dt>
<dd><a name="1092865"> </a>Record handle.</dd>

<dt><a name="1092866"> </a><code>&larr;  <i>pDbRef</i></code></dt>
<dd><a name="1092867"> </a>The database that contains the record <code class="par">hRecord</code>.</dd>

</dl>
<h4>
  <a name="1092868"> </a>Returns 
</h4>

<p><a name="1092869"> </a>Returns the index of the record and database access pointer; if not found, returns -1 and <code>*</code><code class="par">pDbRef</code> is 0.</p>
<h4>
  <a name="1092870"> </a>See Also 
</h4>

<p><a name="1092880"> </a><a href="DataMgr.html#1000166"><code>DmGetRecord()</code></a>, <a href="DataMgr.html#997584"><code>DmFindRecordByID()</code></a>, <a href="DataMgr.html#1004375"><code>DmRecordInfoV50()</code></a></p>

<h3 class="hbH3">
  <a name="1006129"> </a>DmSearchResourceOpenDatabases Function <a href="#992934"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="1092888"> </a>Purpose 
</h4>

<p><a name="1092889"> </a>Search all open resource databases for a resource by type and ID, or by pointer if it is non-<code>NULL</code>.</p>
<h4>
  <a name="1092890"> </a>Declared In 
</h4>
<code>DataMgr.h<a name="1092891"> </a></code><h4>
  <a name="1092892"> </a>Prototype 
</h4>
<pre class="proto"><a name="1092893"></a>uint16_t DmSearchResourceOpenDatabases (
   DmResourceType <code class="par">resType</code>,
   DmResourceID <code class="par">resID</code>,
   MemHandle <code class="par">hResource</code>,
   DmOpenRef <code class="par">*pDbRef</code>
)
</pre>
<h4>
  <a name="1092894"> </a>Parameters 
</h4>

<dl>
<dt><a name="1092895"> </a><code>&rarr;  <i>resType</i></code></dt>
<dd><a name="1092896"> </a>Type of resource to search for.</dd>

<dt><a name="1092897"> </a><code>&rarr;  <i>resID</i></code></dt>
<dd><a name="1092898"> </a>ID of resource to search for.</dd>

<dt><a name="1092899"> </a><code>&rarr;  <i>hResource</i></code></dt>
<dd><a name="1092900"> </a>Handle of locked resource, or <code>NULL</code>.</dd>

<dt><a name="1092901"> </a><code>&larr;  <i>pDbRef</i></code></dt>
<dd><a name="1092902"> </a>The resource database that contains the specified resource.</dd>

</dl>
<h4>
  <a name="1092903"> </a>Returns 
</h4>

<p><a name="1092904"> </a>Returns the index of the resource, stores <code>DmOpenRef</code> in <code>*</code><code class="par">pDbRef</code>. </p>
<h4>
  <a name="1092905"> </a>Comments 
</h4>

<p><a name="1092906"> </a>This function can be used to find a resource in all open resource databases by type and ID or by pointer. If <code class="par">hResource</code> is <code>NULL</code>, the resource is searched for by type and ID. If <code class="par">hResource</code> is not <code>NULL</code>, <code class="par">resType</code> and <code class="par">resID</code> is ignored and the index of the resource handle is returned. On return, <code>*</code><code class="par">pDbRef</code> contains the access pointer of the resource database that the resource was eventually found in. Once the index of a resource is determined, it can be locked down and accessed by calling <a href="DataMgr.html#1000792"><code>DmGetResourceByIndex()</code></a>.</p>

<p><a name="1092910"> </a>If any of the open databases are overlaid, this function finds and returns the localized version of the resource when searching by type and creator. In this case, the <code class="par">pDbRef</code> return value is a pointer to the overlay database, not the base resource database. </p>
<h4>
  <a name="1092911"> </a>See Also 
</h4>

<p><a name="1092918"> </a><a href="DataMgr.html#1000738"><code>DmGetResource()</code></a>, <a href="DataMgr.html#997774"><code>DmFindResourceType()</code></a>, <a href="DataMgr.html#1005302"><code>DmResourceInfo()</code></a>, <a href="DataMgr.html#997720"><code>DmFindResource()</code></a></p>

<h3 class="hbH3">
  <a name="1006207"> </a>DmSet Function <a href="#992934"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="1093054"> </a>Purpose 
</h4>

<p><a name="1093055"> </a>Write a specified value into a section of a record. This function also checks the validity of the pointer for the record and makes sure the writing of the record information doesn't exceed the bounds of the record.</p>
<h4>
  <a name="1093056"> </a>Declared In 
</h4>
<code>DataMgr.h<a name="1093057"> </a></code><h4>
  <a name="1093058"> </a>Prototype 
</h4>
<pre class="proto"><a name="1093059"></a>status_t DmSet (
   void <code class="par">*pRecord</code>,
   uint32_t <code class="par">offset</code>,
   uint32_t <code class="par">bytes</code>,
   uint8_t <code class="par">value</code>
)
</pre>
<h4>
  <a name="1093060"> </a>Parameters 
</h4>

<dl>
<dt><a name="1093061"> </a><code>&rarr;  <i>pRecord</i></code></dt>
<dd><a name="1093062"> </a>Pointer to locked data record (chunk pointer).</dd>

<dt><a name="1093063"> </a><code>&rarr;  <i>offset</i></code></dt>
<dd><a name="1093064"> </a>Offset within record to start writing.</dd>

<dt><a name="1093065"> </a><code>&rarr;  <i>bytes</i></code></dt>
<dd><a name="1093066"> </a>Number of bytes to write.</dd>

<dt><a name="1093067"> </a><code>&rarr;  <i>value</i></code></dt>
<dd><a name="1093068"> </a>Byte value to write.</dd>

</dl>
<h4>
  <a name="1093069"> </a>Returns 
</h4>

<p><a name="1093070"> </a>Returns <code>errNone</code> if no error. May display a fatal error message if the record pointer is invalid or the function overwrites the record. </p>
<h4>
  <a name="1093071"> </a>Comments 
</h4>

<p><a name="1093072"> </a>Must be used to write to Data Manager records because the data storage area is write-protected. </p>
<h4>
  <a name="1093073"> </a>See Also 
</h4>

<p><a name="1093077"> </a><a href="DataMgr.html#1007510"><code>DmWrite()</code></a> </p>

<h3 class="hbH3">
  <a name="1006265"> </a>DmSetDatabaseInfo Function <a href="#992934"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="1093081"> </a>Purpose 
</h4>

<p><a name="1093082"> </a>Set information about a database.</p>
<h4>
  <a name="1093083"> </a>Declared In 
</h4>
<code>DataMgr.h<a name="1093084"> </a></code><h4>
  <a name="1093085"> </a>Prototype 
</h4>
<pre class="proto"><a name="1093086"></a>status_t DmSetDatabaseInfo (
   DatabaseID <code class="par">dbID</code>,
   DmDatabaseInfoPtr <code class="par">pDatabaseInfo</code>
)
</pre>
<h4>
  <a name="1093087"> </a>Parameters 
</h4>

<dl>
<dt><a name="1093088"> </a><code>&rarr;  <i>dbID</i></code></dt>
<dd><a name="1093089"> </a>Database ID of the database.</dd>

<dt><a name="1093090"> </a><code>&rarr;  <i>pDatabaseInfo</i></code></dt>
<dd><a name="1093091"> </a>Pointer to a structure that contains references to the new database information. See <a href="DataMgr.html#993322"><code>DmDatabaseInfoType</code></a> for a description of the data structure.</dd>

</dl>
<h4>
  <a name="1093095"> </a>Returns 
</h4>

<p><a name="1093096"> </a>Returns <code>errNone</code> if no error or one of the following if an error occurred: </p>

<dl>
<dt><a name="1093097"> </a><code>dmErrInvalidDatabaseName</code></dt>
<dd><a name="1093098"> </a>The name you've specified for the database is invalid.</dd>

<dt><a name="1093099"> </a><code>dmErrAlreadyExists</code></dt>
<dd><a name="1093100"> </a>Another database with the same name already exists.</dd>

<dt><a name="1093101"> </a><code>dmErrInvalidParam</code></dt>
<dd><a name="1093102"> </a>The function received an invalid parameter.</dd>

</dl>
<h4>
  <a name="1093103"> </a>Comments 
</h4>

<p><a name="1093104"> </a>When this call changes <code>appInfoID</code> or <code>sortInfoID</code>, the old chunk ID (if any) is marked as an orphaned chunk<a href="#1093107"><sup>1</sup></a> and the new chunk ID is un-orphaned. Consequently, you shouldn't replace an existing <code>appInfoID</code> or <code>sortInfoID</code> if that chunk has already been attached to another database.</p>

<p><a name="1093110"> </a>Call this function to set any or all information about a database except for the database ID. This function sets the new value for any non-<code>NULL</code> field in the <code class="par">pDatabaseInfo</code> structure.</p>
<h4>
  <a name="1093111"> </a>See Also 
</h4>

<p><a name="1093118"> </a><a href="DataMgr.html#996192"><code>DmDatabaseInfo()</code></a>, <a href="DataMgr.html#1002946"><code>DmOpenDatabaseInfoV50()</code></a>, <a href="DataMgr.html#1077521"><code>DmFindDatabase()</code></a>, <a href="DataMgr.html#999000"><code>DmGetNextDatabaseByTypeCreator()</code></a>, <a href="../System_Management/DateTime.html#996102"><code>TimDateTimeToSeconds()</code></a></p>

<h3 class="hbH3">
  <a name="1006311"> </a>DmSetDatabaseInfoV50 Function <a href="#992934"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="1093210"> </a>Purpose 
</h4>

<p><a name="1093211"> </a>Set information about a database.</p>
<h4>
  <a name="1093212"> </a>Declared In 
</h4>
<code>DataMgr.h<a name="1093213"> </a></code><h4>
  <a name="1093214"> </a>Prototype 
</h4>
<pre class="proto"><a name="1093215"></a>status_t DmSetDatabaseInfoV50 (
   uint16_t <code class="par">cardNo</code>,
   LocalID <code class="par">dbID</code>,
   const char <code class="par">*nameP</code>,
   uint16_t <code class="par">*attributesP</code>,
   uint16_t <code class="par">*versionP</code>,
   uint32_t <code class="par">*crDateP</code>,
   uint32_t <code class="par">*modDateP</code>,
   uint32_t <code class="par">*bckUpDateP</code>,
   uint32_t <code class="par">*modNumP</code>,
   LocalID <code class="par">*appInfoIDP</code>,
   LocalID <code class="par">*sortInfoIDP</code>,
   uint32_t <code class="par">*typeP</code>,
   uint32_t <code class="par">*creatorP</code>
)
</pre>
<h4>
  <a name="1093216"> </a>Parameters 
</h4>

<dl>
<dt><a name="1093217"> </a><code>&rarr;  <i>cardNo</i></code></dt>
<dd><a name="1093218"> </a>Card number the database resides on.</dd>

<dt><a name="1093219"> </a><code>&rarr;  <i>dbID</i></code></dt>
<dd><a name="1093220"> </a>Database ID of the database.</dd>

<dt><a name="1093221"> </a><code>&rarr;  <i>nameP</i></code></dt>
<dd><a name="1093222"> </a>Pointer to the new name of the database, or <code>NULL</code>. A database name can be up to 32 ASCII bytes long, including the null terminator (as specified by <code>dmDBNameLength</code>). Database names must use only 7-bit ASCII characters (0x20 through 0x7E). </dd>

<dt><a name="1093224"> </a><code>&rarr;  <i>attributesP</i></code></dt>
<dd><a name="1093227"> </a>Pointer to new attributes variable, or <code>NULL</code>. See <a href="DataMgr.html#1049292">"Database Attributes"</a> for a list of possible values.</dd>

<dt><a name="1093229"> </a><code>&rarr;  <i>versionP</i></code></dt>
<dd><a name="1093230"> </a>Pointer to new version, or <code>NULL</code>. </dd>

<dt><a name="1093231"> </a><code>&rarr;  <i>crDateP</i></code></dt>
<dd><a name="1093232"> </a>Pointer to new creation date variable, or <code>NULL</code>. Specify the value as a number of seconds since Jan. 1, 1904.</dd>

<dt><a name="1093233"> </a><code>&rarr;  <i>modDateP</i></code></dt>
<dd><a name="1093234"> </a>Pointer to new modification date variable, or <code>NULL</code>. Specify the value as a number of seconds since Jan. 1, 1904.</dd>

<dt><a name="1093235"> </a><code>&rarr;  <i>bckUpDateP</i></code></dt>
<dd><a name="1093236"> </a>Pointer to new backup date variable, or <code>NULL</code>. Specify the value as a number of seconds since Jan. 1, 1904.</dd>

<dt><a name="1093237"> </a><code>&rarr;  <i>modNumP</i></code></dt>
<dd><a name="1093238"> </a>Pointer to new modification number variable, or <code>NULL</code>.</dd>

<dt><a name="1093239"> </a><code>&rarr;  <i>appInfoIDP</i></code></dt>
<dd><a name="1093240"> </a>Pointer to new <code>appInfoID</code>, or <code>NULL</code>.</dd>

<dt><a name="1093241"> </a><code>&rarr;  <i>sortInfoIDP</i></code></dt>
<dd><a name="1093242"> </a>Pointer to new <code>sortInfoID</code>, or <code>NULL</code>.</dd>

<dt><a name="1093243"> </a><code>&rarr;  <i>typeP</i></code></dt>
<dd><a name="1093244"> </a>Pointer to new <code>type</code>, or <code>NULL</code>.</dd>

<dt><a name="1093245"> </a><code>&rarr;  <i>creatorP</i></code></dt>
<dd><a name="1093246"> </a>Pointer to new <code>creator</code>, or <code>NULL</code>.</dd>

</dl>
<h4>
  <a name="1093247"> </a>Returns 
</h4>

<p><a name="1093248"> </a>Returns <code>errNone</code> if no error or one of the following if an error occurred: </p>

<dl>
<dt><a name="1093249"> </a><code>dmErrInvalidDatabaseName</code></dt>
<dd><a name="1093250"> </a>The name you've specified for the database is invalid.</dd>

<dt><a name="1093251"> </a><code>dmErrAlreadyExists</code></dt>
<dd><a name="1093252"> </a>Another database with the same name already exists.</dd>

<dt><a name="1093253"> </a><code>dmErrInvalidParam</code></dt>
<dd><a name="1093254"> </a>The function received an invalid parameter.</dd>

</dl>
<h4>
  <a name="1093255"> </a>Comments 
</h4>

<p><a name="1093256"> </a>When this call changes <code>appInfoID</code> or <code>sortInfoID</code>, the old chunk ID (if any) is marked as an orphaned chunk<a href="#1093259"><sup>2</sup></a> and the new chunk ID is un-orphaned. Consequently, you shouldn't replace an existing <code>appInfoID</code> or <code>sortInfoID</code> if that chunk has already been attached to another database.</p>

<p><a name="1093262"> </a>Call this function to set any or all information about a database except for the card number and database ID. This function sets the new value for any non-<code>NULL</code> parameter.</p>

<p><a name="1093263"> </a>When setting database attributes, note that the following are system attributes that cannot be set&#8212;they are read-only:</p>

<dl>
<dt><a name="1093264"> </a><code>dmHdrAttrResDB </code></dt>
<dt><a name="1093265"> </a><code>dmHdrAttrSchema </code></dt>
<dt><a name="1093266"> </a><code>dmHdrAttrSecure </code></dt>
<dt><a name="1093268"> </a><code>dmHdrAttrOpen</code></dt>
</dl>
<h4>
  <a name="1132870"> </a>Compatibility 
</h4>

<p><a name="1132935"> </a>This function is provided for compatibility purposes only. Although it could be used to set information in an extended database, it operates as on previous versions of Palm OS in that the given database name must be unique. Palm OS Cobalt applications&#8212;particularly those that are operating on extended databases&#8212;will most likely want to use <a href="DataMgr.html#1006265"><code>DmSetDatabaseInfo()</code></a> instead.</p>
<h4>
  <a name="1093269"> </a>See Also 
</h4>

<p><a name="1093276"> </a><a href="DataMgr.html#1006265"><code>DmSetDatabaseInfo()</code></a>, <a href="DataMgr.html#996192"><code>DmDatabaseInfo()</code></a>, <a href="DataMgr.html#1003012"><code>DmOpenDatabaseV50()</code></a>, <a href="DataMgr.html#1077521"><code>DmFindDatabase()</code></a>, <a href="DataMgr.html#999000"><code>DmGetNextDatabaseByTypeCreator()</code></a>, <a href="../System_Management/DateTime.html#996102"><code>TimDateTimeToSeconds()</code></a></p>

<h3 class="hbH3">
  <a name="1006613"> </a>DmSetDatabaseProtection Function <a href="#992934"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="1093406"> </a>Purpose 
</h4>

<p><a name="1093407"> </a>Increment or decrement the database's protection count.</p>
<h4>
  <a name="1093408"> </a>Declared In 
</h4>
<code>DataMgr.h<a name="1093409"> </a></code><h4>
  <a name="1093410"> </a>Prototype 
</h4>
<pre class="proto"><a name="1093411"></a>status_t DmSetDatabaseProtection (
   DatabaseID <code class="par">dbID</code>,
   Boolean <code class="par">protect</code>
)
</pre>
<h4>
  <a name="1093412"> </a>Parameters 
</h4>

<dl>
<dt><a name="1093413"> </a><code>&rarr;  <i>dbID</i></code></dt>
<dd><a name="1093414"> </a>Database ID of the database.</dd>

<dt><a name="1093415"> </a><code>&rarr;  <i>protect</i></code></dt>
<dd><a name="1093416"> </a>If <code>true</code>, the protection count is incremented. If <code>false</code>, the protection count is decremented.</dd>

</dl>
<h4>
  <a name="1093417"> </a>Returns 
</h4>

<p><a name="1093418"> </a>Returns <code>errNone</code> if the protection count was updated, or one of the following if an error occurred: </p>

<dl>
<dt><a name="1093419"> </a><code>memErrCardNotPresent</code></dt>
<dd><a name="1093420"> </a>The specified card can't be found.</dd>

<dt><a name="1093421"> </a><code>dmErrROMBased</code></dt>
<dd><a name="1093422"> </a>You've attempted to delete or modify a ROM-based database.</dd>

<dt><a name="1093423"> </a><code>dmErrCantFind</code></dt>
<dd><a name="1093424"> </a>The specified database can't be found.</dd>

<dt><a name="1093425"> </a><code>memErrNotEnoughSpace</code></dt>
<dd><a name="1093426"> </a>A memory error occurred.</dd>

<dt><a name="1093427"> </a><code>dmErrDatabaseNotProtected</code></dt>
</dl>
<h4>
  <a name="1093428"> </a>Comments 
</h4>

<p><a name="1093429"> </a>This function can be used to prevent a database from being deleted (pass <code>true</code> for the <code class="par">protect</code> parameter). All "true" calls should be balanced by "false" calls before the application terminates. </p>

<p><a name="1093430"> </a>Use this function to keep a particular record or resource in a database locked down without having to keep the database open. Note that because protection counts are kept in the dynamic heap, all databases are "unprotected" at system reset. </p>

<p><a name="1093431"> </a>If the database is a resource database that has an overlay associated with it for the current locale, the overlay is also protected or unprotected by this function. </p>

<h3 class="hbH3">
  <a name="1006659"> </a>DmSetFallbackOverlayLocale Function <a href="#992934"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="1093515"> </a>Purpose 
</h4>

<p><a name="1093516"> </a>Set the fallback overlay locale: the locale used when the Data Manager attempts to open an overlay locale for which no valid overlay exists.</p>
<h4>
  <a name="1093517"> </a>Declared In 
</h4>
<code>DataMgr.h<a name="1093518"> </a></code><h4>
  <a name="1093519"> </a>Prototype 
</h4>
<pre class="proto"><a name="1093520"></a>status_t DmSetFallbackOverlayLocale (
   const LmLocaleType <code class="par">*fallbackLocale</code>
)
</pre>
<h4>
  <a name="1093521"> </a>Parameters 
</h4>

<dl>
<dt><a name="1093522"> </a><code>&rarr;  <i>fallbackLocale</i></code></dt>
<dd><a name="1093523"> </a>Pointer to a structure identifying the fallback overlay locale.</dd>

</dl>
<h4>
  <a name="1093524"> </a>Returns 
</h4>

<p><a name="1093525"> </a>Returns <code>errNone</code> if the fallback overlay locale was successfully set, or one of the following if an error occurred:</p>

<dl>
<dt><a name="1093526"> </a><code>dmErrInvalidParam</code></dt>
<dd><a name="1093527"> </a>The function received an invalid parameter.</dd>

<dt><a name="1093528"> </a><code>dmErrUnknownLocale</code></dt>
<dd><a name="1111930"> </a>The specified locale is unknown to the operating system.</dd>

</dl>
<h4>
  <a name="1093529"> </a>Comments 
</h4>

<p><a name="1093530"> </a>The fallback overlay locale is used by the Data Manager when it attempts to automatically open an overlay using the overlay locale, but no valid overlay exists, and the base probably has been stripped.</p>
<h4>
  <a name="1093531"> </a>See Also 
</h4>

<p><a name="1093538"> </a><a href="DataMgr.html#998819"><code>DmGetFallbackOverlayLocale()</code></a>, <a href="DataMgr.html#1006917"><code>DmSetOverlayLocale()</code></a></p>

<h3 class="hbH3">
  <a name="1006917"> </a>DmSetOverlayLocale Function <a href="#992934"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="1093615"> </a>Purpose 
</h4>

<p><a name="1093616"> </a>Set the Data Manager's overlay locale: the locale used by the Data Manager when it attempts to automatically open overlays.</p>
<h4>
  <a name="1093617"> </a>Declared In 
</h4>
<code>DataMgr.h<a name="1093618"> </a></code><h4>
  <a name="1093619"> </a>Prototype 
</h4>
<pre class="proto"><a name="1093620"></a>status_t DmSetOverlayLocale (
   const LmLocaleType <code class="par">*overlayLocale</code>
)
</pre>
<h4>
  <a name="1093621"> </a>Parameters 
</h4>

<dl>
<dt><a name="1093622"> </a><code>&rarr;  <i>overlayLocale</i></code></dt>
<dd><a name="1093626"> </a>Pointer to an <code>LmLocaleType</code> structure containing the overlay locale.</dd>

</dl>
<h4>
  <a name="1093627"> </a>Returns 
</h4>

<p><a name="1093628"> </a>Returns <code>errNone</code> if the overlay locale was successfully set, or one of the following if an error occurred:</p>

<dl>
<dt><a name="1093629"> </a><code>dmErrInvalidParam</code></dt>
<dd><a name="1093630"> </a>The function received an invalid parameter.</dd>

<dt><a name="1093631"> </a><code>dmErrUnknownLocale</code></dt>
<dd><a name="1112135"> </a>The specified locale is unknown to the operating system.</dd>

</dl>
<h4>
  <a name="1093632"> </a>See Also 
</h4>

<p><a name="1093639"> </a><a href="DataMgr.html#999814"><code>DmGetOverlayLocale()</code></a>, <a href="DataMgr.html#1006659"><code>DmSetFallbackOverlayLocale()</code></a></p>

<h3 class="hbH3">
  <a name="1006959"> </a>DmSetRecordAttr Function <a href="#992934"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="1093682"> </a>Purpose 
</h4>

<p><a name="1093683"> </a>Set the attributes of a record.</p>
<h4>
  <a name="1093684"> </a>Declared In 
</h4>
<code>DataMgr.h<a name="1093685"> </a></code><h4>
  <a name="1093686"> </a>Prototype 
</h4>
<pre class="proto"><a name="1093687"></a>status_t DmSetRecordAttr (
   DmOpenRef <code class="par">dbRef</code>,
   uint16_t <code class="par">index</code>,
   uint8_t <code class="par">*pAttr</code>
)
</pre>
<h4>
  <a name="1093688"> </a>Parameters 
</h4>

<dl>
<dt><a name="1093689"> </a><code>&rarr;  <i>dbRef</i></code></dt>
<dd><a name="1093690"> </a><code>DmOpenRef</code> to an open database.</dd>

<dt><a name="1093691"> </a><code>&rarr;  <i>index</i></code></dt>
<dd><a name="1093692"> </a>Index of the record for which attributes are being set.</dd>

<dt><a name="1093693"> </a><code>&rarr;  <i>pAttr</i></code></dt>
<dd><a name="1093696"> </a>Pointer to the new attributes for the record. See <a href="DataMgr.html#1041655">"Non-Schema Database Record Attributes"</a> for a description of the attributes. Note that you can only set those attributes not included in the definition of <code>dmSysOnlyRecAttrs</code>.</dd>

</dl>
<h4>
  <a name="1093698"> </a>Returns 
</h4>

<p><a name="1093699"> </a>Returns <code>errNone</code> if the attributes were successfully set, or one of the following if an error occurred:</p>

<dl>
<dt><a name="1093700"> </a><code>dmErrReadOnly</code></dt>
<dd><a name="1093701"> </a>You've attempted to write to or modify a database that is open in read-only mode.</dd>

<dt><a name="1093702"> </a><code>dmErrNotRecordDB</code></dt>
<dd><a name="1093703"> </a>You've attempted to perform a record function on a resource database. </dd>

<dt><a name="1093704"> </a><code>dmErrIndexOutOfRange</code></dt>
<dd><a name="1093705"> </a>The specified index is out of range.</dd>

</dl>
<h4>
  <a name="1093706"> </a>See Also 
</h4>

<p><a name="1093710"> </a><a href="DataMgr.html#1000420"><code>DmGetRecordAttr()</code></a></p>

<h3 class="hbH3">
  <a name="1007171"> </a>DmSetRecordCategory Function <a href="#992934"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="1093804"> </a>Purpose 
</h4>

<p><a name="1093805"> </a>Set the category information for a record.</p>
<h4>
  <a name="1093806"> </a>Declared In 
</h4>
<code>DataMgr.h<a name="1093807"> </a></code><h4>
  <a name="1093808"> </a>Prototype 
</h4>
<pre class="proto"><a name="1093809"></a>status_t DmSetRecordCategory (
   DmOpenRef <code class="par">dbRef</code>,
   uint16_t <code class="par">index</code>,
   uint8_t <code class="par">*pCategory</code>
)
</pre>
<h4>
  <a name="1093810"> </a>Parameters 
</h4>

<dl>
<dt><a name="1093811"> </a><code>&rarr;  <i>dbRef</i></code></dt>
<dd><a name="1093812"> </a><code>DmOpenRef</code> to an open database.</dd>

<dt><a name="1093813"> </a><code>&rarr;  <i>index</i></code></dt>
<dd><a name="1093814"> </a>Index of the record for which the category information is being set.</dd>

<dt><a name="1093815"> </a><code>&rarr;  <i>pCategory</i></code></dt>
<dd><a name="1093816"> </a>Pointer to the new category information for the record.</dd>

</dl>
<h4>
  <a name="1093817"> </a>Returns 
</h4>

<p><a name="1093818"> </a>Returns <code>errNone</code> if the category information was successfully set, or one of the following if an error occurred:</p>

<dl>
<dt><a name="1093820"> </a><code>dmErrReadOnly</code></dt>
<dd><a name="1093821"> </a>You've attempted to write to or modify a database that is open in read-only mode.</dd>

<dt><a name="1093822"> </a><code>dmErrNotRecordDB</code></dt>
<dd><a name="1093823"> </a>You've attempted to perform a record function on a resource database. </dd>

<dt><a name="1093824"> </a><code>dmErrIndexOutOfRange</code></dt>
<dd><a name="1093825"> </a>The specified index is out of range.</dd>

</dl>
<h4>
  <a name="1093826"> </a>See Also 
</h4>

<p><a name="1093830"> </a><a href="DataMgr.html#1000470"><code>DmGetRecordCategory()</code></a></p>

<h3 class="hbH3">
  <a name="1007227"> </a>DmSetRecordID Function <a href="#992934"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="1093838"> </a>Purpose 
</h4>

<p><a name="1093839"> </a>Set the unique ID of a record.</p>
<h4>
  <a name="1093840"> </a>Declared In 
</h4>
<code>DataMgr.h<a name="1093841"> </a></code><h4>
  <a name="1093842"> </a>Prototype 
</h4>
<pre class="proto"><a name="1093843"></a>status_t DmSetRecordID (
   DmOpenRef <code class="par">dbRef</code>,
   uint16_t <code class="par">index</code>,
   uint32_t <code class="par">*pUID</code>
)
</pre>
<h4>
  <a name="1093844"> </a>Parameters 
</h4>

<dl>
<dt><a name="1093845"> </a><code>&rarr;  <i>dbRef</i></code></dt>
<dd><a name="1093846"> </a><code>DmOpenRef</code> to an open database.</dd>

<dt><a name="1093847"> </a><code>&rarr;  <i>index</i></code></dt>
<dd><a name="1093848"> </a>Record index for which to set the unique ID.</dd>

<dt><a name="1093849"> </a><code>&rarr;  <i>pUID</i></code></dt>
<dd><a name="1093850"> </a>Pointer to the new unique ID.</dd>

</dl>
<h4>
  <a name="1093851"> </a>Returns 
</h4>

<p><a name="1093852"> </a>Returns <code>errNone</code> if the record ID was set successfully, or one of the following if an error occurred:</p>

<dl>
<dt><a name="1093853"> </a><code>dmErrInvalidParam</code></dt>
<dd><a name="1093854"> </a>The function received an invalid parameter.</dd>

<dt><a name="1093855"> </a><code>dmErrNotRecordDB</code></dt>
<dd><a name="1093856"> </a>You've attempted to perform a record function on a resource database. </dd>

<dt><a name="1093857"> </a><code>dmErrIndexOutOfRange</code></dt>
<dd><a name="1093858"> </a>The specified index is out of range.</dd>

<dt><a name="1093859"> </a><code>dmErrInvalidID</code></dt>
<dd><a name="1093860"> </a>The supplied record ID is already in use.</dd>

</dl>
<h4>
  <a name="1093861"> </a>Comments 
</h4>

<p><a name="1093862"> </a>The Data Manager guarantees that a record ID's uniqueness is maintained after such a call. If the supplied record ID is already in use by another record, this function returns <code>dmErrInvalidID</code>.</p>
<h4>
  <a name="1093863"> </a>See Also 
</h4>

<p><a name="1093870"> </a><a href="DataMgr.html#1000600"><code>DmGetRecordID()</code></a>, <a href="DataMgr.html#1007301"><code>DmSetRecordInfoV50()</code></a></p>

<h3 class="hbH3">
  <a name="1007301"> </a>DmSetRecordInfoV50 Function <a href="#992934"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="1093916"> </a>Purpose 
</h4>

<p><a name="1093917"> </a>Set record information stored in the database header.</p>
<h4>
  <a name="1093918"> </a>Declared In 
</h4>
<code>DataMgr.h<a name="1093919"> </a></code><h4>
  <a name="1093920"> </a>Prototype 
</h4>
<pre class="proto"><a name="1093921"></a>status_t DmSetRecordInfoV50 (
   DmOpenRef <code class="par">dbRef</code>,
   uint16_t <code class="par">index</code>,
   uint16_t <code class="par">*pAttr</code>,
   uint32_t <code class="par">*pUID</code>
)
</pre>
<h4>
  <a name="1093922"> </a>Parameters 
</h4>

<dl>
<dt><a name="1093923"> </a><code>&rarr;  <i>dbRef</i></code></dt>
<dd><a name="1093924"> </a><code>DmOpenRef</code> to an open database.</dd>

<dt><a name="1093925"> </a><code>&rarr;  <i>index</i></code></dt>
<dd><a name="1093926"> </a>Index of record.</dd>

<dt><a name="1093927"> </a><code>&rarr;  <i>pAttr</i></code></dt>
<dd><a name="1093930"> </a>Pointer to new attribute variable, or <code>NULL</code> if you don't want to change any of the record's attributes. See <a href="DataMgr.html#1041655">"Non-Schema Database Record Attributes"</a> for a list of possible values.</dd>

<dt><a name="1093932"> </a><code>&rarr;  <i>pUID</i></code></dt>
<dd><a name="1093933"> </a>Pointer to new unique ID, or <code>NULL</code> if you don't want to change the record's unique ID.</dd>

</dl>
<h4>
  <a name="1093934"> </a>Returns 
</h4>

<p><a name="1093935"> </a>Returns <code>errNone</code> if no error, or one of the following if an error occurred:</p>

<dl>
<dt><a name="1093936"> </a><code>dmErrReadOnly</code></dt>
<dd><a name="1093937"> </a>You've attempted to write to or modify a database that is open in read-only mode.</dd>

<dt><a name="1093938"> </a><code>dmErrNotRecordDB</code></dt>
<dd><a name="1093939"> </a>You've attempted to perform a record function on a resource database. </dd>

<dt><a name="1093940"> </a><code>dmErrIndexOutOfRange</code></dt>
<dd><a name="1093941"> </a>The specified index is out of range.</dd>

</dl>

<p><a name="1093942"> </a>Some releases may display a fatal error message instead of returning the error code. </p>
<h4>
  <a name="1093943"> </a>Comments 
</h4>

<p><a name="1093944"> </a>Sets information about a record. This function cannot be used to set the <code>dmRecAttrBusy</code> bit; instead, use <a href="DataMgr.html#1000166"><code>DmGetRecord()</code></a> to set the bit and <a href="DataMgr.html#1004479"><code>DmReleaseRecord()</code></a> to clear it.</p>

<p><a name="1093951"> </a>Normally, the unique ID for a record is automatically created by the Data Manager when a record is created using <a href="DataMgr.html#1001785"><code>DmNewRecord()</code></a>, so an application would not typically change the unique ID. </p>
<h4>
  <a name="1133020"> </a>Compatibility 
</h4>

<p><a name="1133150"> </a>Provided for compatibility purposes only. Palm OS Cobalt applications should use <a href="DataMgr.html#1006959"><code>DmSetRecordAttr()</code></a> and/or <a href="DataMgr.html#1007227"><code>DmSetRecordID()</code></a> instead.</p>
<h4>
  <a name="1133154"> </a>See Also 
</h4>

<p><a name="1093962"> </a><a href="DataMgr.html#1006959"><code>DmSetRecordAttr()</code></a>, <a href="DataMgr.html#1007227"><code>DmSetRecordID()</code></a>, <a href="DataMgr.html#1000420"><code>DmGetRecordAttr()</code></a>, <a href="DataMgr.html#1000600"><code>DmGetRecordID()</code></a>, <a href="DataMgr.html#1004375"><code>DmRecordInfoV50()</code></a></p>

<h3 class="hbH3">
  <a name="1007394"> </a>DmSetResourceInfo Function <a href="#992934"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="1094024"> </a>Purpose 
</h4>

<p><a name="1094025"> </a>Set information on a given resource.</p>
<h4>
  <a name="1094026"> </a>Declared In 
</h4>
<code>DataMgr.h<a name="1094027"> </a></code><h4>
  <a name="1094028"> </a>Prototype 
</h4>
<pre class="proto"><a name="1094029"></a>status_t DmSetResourceInfo (
   DmOpenRef <code class="par">dbRef</code>,
   uint16_t <code class="par">index</code>,
   DmResourceType <code class="par">*pResType</code>,
   DmResourceID <code class="par">*pResID</code>
)
</pre>
<h4>
  <a name="1094030"> </a>Parameters 
</h4>

<dl>
<dt><a name="1094031"> </a><code>&rarr;  <i>dbRef</i></code></dt>
<dd><a name="1094032"> </a><code>DmOpenRef</code> to an open database.</dd>

<dt><a name="1094033"> </a><code>&rarr;  <i>index</i></code></dt>
<dd><a name="1094034"> </a>Index of resource to set info for.</dd>

<dt><a name="1094035"> </a><code>&rarr;  <i>pResType</i></code></dt>
<dd><a name="1094036"> </a>Pointer to new <code>resType</code> (resource type), or <code>NULL</code>.</dd>

<dt><a name="1094037"> </a><code>&rarr;  <i>pResID</i></code></dt>
<dd><a name="1094038"> </a>Pointer to new resource ID, or <code>NULL</code>.</dd>

</dl>
<h4>
  <a name="1094039"> </a>Returns 
</h4>

<p><a name="1094040"> </a>Returns <code>errNone</code> if no error, or one of the following if an error occurred: </p>

<dl>
<dt><a name="1094041"> </a><code>dmErrIndexOutOfRange</code></dt>
<dd><a name="1094042"> </a>The specified index is out of range.</dd>

<dt><a name="1094043"> </a><code>dmErrReadOnly</code></dt>
<dd><a name="1094044"> </a>You've attempted to write to or modify a database that is open in read-only mode.</dd>

</dl>

<p><a name="1094045"> </a>May display a fatal error message if the database is not a resource database. </p>
<h4>
  <a name="1094046"> </a>Comments 
</h4>

<p><a name="1094047"> </a>Use this function to set all or a portion of the information on a particular resource. Any or all of the new info pointers can be <code>NULL</code>. If not <code>NULL</code>, the type and ID of the resource are changed to <code>*</code><code class="par">pResType</code> and <code>*</code><code class="par">pResID</code>.</p>

<h3 class="hbH3">
  <a name="1007456"> </a>DmStrCopy Function <a href="#992934"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="1094073"> </a>Purpose 
</h4>

<p><a name="1094074"> </a>Copies a string to a record within a database that is open for writing.</p>
<h4>
  <a name="1094075"> </a>Declared In 
</h4>
<code>DataMgr.h<a name="1094076"> </a></code><h4>
  <a name="1094077"> </a>Prototype 
</h4>
<pre class="proto"><a name="1094078"></a>status_t DmStrCopy (
   void <code class="par">*pRecord</code>,
   uint32_t <code class="par">offset</code>,
   const void <code class="par">*pSrc</code>
)
</pre>
<h4>
  <a name="1094079"> </a>Parameters 
</h4>

<dl>
<dt><a name="1094080"> </a><code>&harr;  <i>pRecord</i></code></dt>
<dd><a name="1094081"> </a>Pointer to data record (chunk pointer).</dd>

<dt><a name="1094082"> </a><code>&rarr;  <i>offset</i></code></dt>
<dd><a name="1094083"> </a>Offset within record to start writing.</dd>

<dt><a name="1094084"> </a><code>&rarr;  <i>pSrc</i></code></dt>
<dd><a name="1094085"> </a>Pointer to null-terminated string.</dd>

</dl>
<h4>
  <a name="1094086"> </a>Returns 
</h4>

<p><a name="1094087"> </a>Returns <code>errNone</code> if no error. May display a fatal error message if the record pointer is invalid or the function overwrites the record. </p>
<h4>
  <a name="1094088"> </a>Comments 
</h4>

<p><a name="1094089"> </a>This is one of the functions that must be used to write to Data Manager records; because the data storage area is write-protected, you cannot write to it directly. This function checks the validity of the chunk pointer for the record to ensure that writing the record will not exceed the chunk bounds. <code>DmStrCopy()</code> is a convenience method that determines the size of the supplied string and then simply calls <a href="DataMgr.html#1007510"><code>DmWrite()</code></a>.</p>
<h4>
  <a name="1094093"> </a>See Also 
</h4>

<p><a name="1094097"> </a><a href="DataMgr.html#1006207"><code>DmSet()</code></a></p>

<h3 class="hbH3">
  <a name="1007510"> </a>DmWrite Function <a href="#992934"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="1094120"> </a>Purpose 
</h4>

<p><a name="1094121"> </a>Copies a specified number of bytes to a record within a database that is open for writing.</p>
<h4>
  <a name="1094122"> </a>Declared In 
</h4>
<code>DataMgr.h<a name="1094123"> </a></code><h4>
  <a name="1094124"> </a>Prototype 
</h4>
<pre class="proto"><a name="1094125"></a>status_t DmWrite (
   void <code class="par">*pRecord</code>,
   uint32_t <code class="par">offset</code>,
   const void <code class="par">*pSrc</code>,
   uint32_t <code class="par">bytes</code>
)
</pre>
<h4>
  <a name="1094126"> </a>Parameters 
</h4>

<dl>
<dt><a name="1094127"> </a><code>&harr;  <i>pRecord</i></code></dt>
<dd><a name="1094128"> </a>Pointer to locked data record (chunk pointer).</dd>

<dt><a name="1094129"> </a><code>&rarr;  <i>offset</i></code></dt>
<dd><a name="1094130"> </a>Offset within record to start writing.</dd>

<dt><a name="1094131"> </a><code>&rarr;  <i>pSrc</i></code></dt>
<dd><a name="1094132"> </a>Pointer to data to copy into record.</dd>

<dt><a name="1094133"> </a><code>&rarr;  <i>bytes</i></code></dt>
<dd><a name="1094134"> </a>Number of bytes to write.</dd>

</dl>
<h4>
  <a name="1094135"> </a>Returns 
</h4>

<p><a name="1094136"> </a>Returns <code>errNone</code> if no error. May display a fatal error message if the record pointer is invalid or the function overwrites the record. </p>
<h4>
  <a name="1094137"> </a>Comments 
</h4>

<p><a name="1094138"> </a>This is one of the functions that must be used to write to Data Manager records; because the data storage area is write-protected, you cannot write to it directly. This function checks the validity of the chunk pointer for the record to ensure that writing the record will not exceed the chunk bounds.</p>
<h4>
  <a name="1094139"> </a>See Also 
</h4>

<p><a name="1094146"> </a><a href="DataMgr.html#1007456"><code>DmStrCopy()</code></a>, <a href="DataMgr.html#1006207"><code>DmSet()</code></a> </p>

<h3 class="hbH3">
  <a name="1007564"> </a>DmWriteCheckV50 Function <a href="#992934"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="1094166"> </a>Purpose 
</h4>

<p><a name="1094167"> </a>Check the parameters of a write operation to a classic database data storage chunk before actually performing the write.</p>
<h4>
  <a name="1094168"> </a>Declared In 
</h4>
<code>DataMgr.h<a name="1094169"> </a></code><h4>
  <a name="1094170"> </a>Prototype 
</h4>
<pre class="proto"><a name="1094171"></a>status_t DmWriteCheckV50 (
   void <code class="par">*pRecord</code>,
   uint32_t <code class="par">offset</code>,
   uint32_t <code class="par">bytes</code>
)
</pre>
<h4>
  <a name="1094172"> </a>Parameters 
</h4>

<dl>
<dt><a name="1094173"> </a><code>&rarr;  <i>pRecord</i></code></dt>
<dd><a name="1094174"> </a>Locked pointer to the record handle.</dd>

<dt><a name="1094175"> </a><code>&rarr;  <i>offset</i></code></dt>
<dd><a name="1094176"> </a>Offset into record to start writing.</dd>

<dt><a name="1094177"> </a><code>&rarr;  <i>bytes</i></code></dt>
<dd><a name="1094178"> </a>Number of bytes to write.</dd>

</dl>
<h4>
  <a name="1094179"> </a>Returns 
</h4>

<p><a name="1094180"> </a>Returns <code>errNone</code> if no error; returns <code>dmErrNotValidRecord</code> or <code>dmErrWriteOutOfBounds</code> if an error occurred.</p>
<h4>
  <a name="1133195"> </a>Compatibility 
</h4>

<p><a name="1133197"> </a>This function operates only with classic databases, and is provided only for compatibility purposes. Palm OS Cobalt applications should go ahead and write the data using a function such as <a href="DataMgr.html#1007510"><code>DmWrite()</code></a>, checking the returned status code to determine if an error occurred.</p>

<h2 class="haH2">
  <a name="1007918"> </a>Application-Defined Functions <a href="#992934"><span class="nav">^TOP^</span></a>
</h2>


<h3 class="hbH3">
  <a name="1007926"> </a>DmCompareFunctionType Function <a href="#992934"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="1094216"> </a>Purpose 
</h4>

<p><a name="1094217"> </a>Compares two records in a classic database. </p>
<h4>
  <a name="1094218"> </a>Declared In 
</h4>
<code>DataMgr.h<a name="1094219"> </a></code><h4>
  <a name="1094220"> </a>Prototype 
</h4>
<pre class="proto"><a name="1094221"></a>int16_t DmCompareFunctionType (
   void <code class="par">*rec1P</code>,
   void <code class="par">*rec2P</code>,
   int16_t <code class="par">other</code>,
   DmSortRecordInfoPtr <code class="par">rec1SortInfoP</code>,
   DmSortRecordInfoPtr <code class="par">rec2SortInfoP</code>,
   MemHandle <code class="par">appInfoH</code>
)
</pre>
<h4>
  <a name="1094222"> </a>Parameters 
</h4>

<dl>
<dt><a name="1094223"> </a><code>&rarr;  <i>rec1P</i></code></dt>
<dd><a name="1094224"> </a>Pointer to the first record to compare.</dd>

<dt><a name="1094225"> </a><code>&rarr;  <i>rec2P</i></code></dt>
<dd><a name="1094226"> </a>Pointer to the second record to compare.</dd>

<dt><a name="1094227"> </a><code>&rarr;  <i>other</i></code></dt>
<dd><a name="1094228"> </a>Any other custom information you want passed to the comparison function. This parameter is often used to indicate a sort direction (ascending or descending).</dd>

<dt><a name="1094229"> </a><code>&rarr;  <i>rec1SortInfoP</i></code></dt>
<dd><a name="1094233"> </a>Pointer to a <a href="DataMgr.html#994025"><code>DmSortRecordInfoType</code></a> structure that specifies unique sorting information for the first record.</dd>

<dt><a name="1094234"> </a><code>&rarr;  <i>rec2SortInfoP</i></code></dt>
<dd><a name="1094238"> </a>Pointer to a <a href="DataMgr.html#994025"><code>DmSortRecordInfoType</code></a> structure that specifies unique sorting information for the second record.</dd>

<dt><a name="1094239"> </a><code>&rarr;  <i>appInfoH</i></code></dt>
<dd><a name="1094240"> </a>A handle to the database's Application Info block.</dd>

</dl>
<h4>
  <a name="1094241"> </a>Returns 
</h4>

<p><a name="1094242"> </a>Your implementation of this function should return:</p>
<ul type="disc">
  <li><a name="1094243"> </a>0 if <code>rec1</code> = <code>rec2</code>.
  <li><a name="1094244"> </a>&lt; 0 if <code>rec1</code> &lt; <code>rec2</code>. 
  <li><a name="1094245"> </a>&gt; 0 if <code>rec1</code> &gt; <code>rec2</code>. 
</ul>
<h4>
  <a name="1094246"> </a>Comments 
</h4>

<p><a name="1094247"> </a>This function is used to sort the records in a database. It is specifically called by <a href="DataMgr.html#1000656"><code>DmGetRecordSortPosition()</code></a>, <a href="DataMgr.html#1001522"><code>DmInsertionSort()</code></a>, and <a href="DataMgr.html#1004245"><code>DmQuickSort()</code></a>. </p>
 

<hr> 
<p class="FNFootnote">
<a name="1093107"> </a><a href="#1093104">1</a>. An "orphaned chunk" is one that is allocated in the storage heap, but to which nothing refers. If the orphaned chunk is not put into a database as a record, an Application Info block, or the like, and if the application doesn't keep track of it&#8212;in a global variable, perhaps&#8212;it could get lost. If the application doesn't get around to freeing the chunk before it quits or crashes, or before the device is reset, that storage will be forever unusable: the user can't delete it since the user only deletes databases.</p>
<p class="FNFootnote">
<a name="1093108"> </a><a href="#1093104">1</a>. </p>
<p class="FNFootnote">
<a name="1093109"> </a><a href="#1093104">1</a>. 	During a soft reset, the OS walks through the storage heap and frees any orphaned chunks that it finds. Since most users reset only rarely, however, you shouldn't rely on this happening.</p>
<p class="FNFootnote">
<a name="1093259"> </a><a href="#1093256">2</a>. An "orphaned chunk" is one that is allocated in the storage heap, but to which nothing refers. If the orphaned chunk is not put into a database as a record, an Application Info block, or the like, and if the application doesn't keep track of it&#8212;in a global variable, perhaps&#8212;it could get lost. If the application doesn't get around to freeing the chunk before it quits or crashes, or before the device is reset, that storage will be forever unusable: the user can't delete it since the user only deletes databases.</p>
<p class="FNFootnote">
<a name="1093260"> </a><a href="#1093256">2</a>. </p>
<p class="FNFootnote">
<a name="1093261"> </a><a href="#1093256">2</a>. 	During a soft reset, the OS walks through the storage heap and frees any orphaned chunks that it finds. Since most users reset only rarely, however, you shouldn't rely on this happening.</p>
&nbsp;<br>
</div>
<!--END CONTENT-->

</td>
<td width="5">&nbsp;&nbsp;</td>
</tr>

</table>

<!-- BEGIN FOOTER -->
<table width="100%" border="0" cellspacing="0" cellpadding="0">
<tr>
<td width="7" rowspan="2"><img name="index_x" src="images/shim.gif" width="7" height="33" border="0" alt=""></td>
<td align="left"><img name="dashes" src="images/dashes.gif" width="744" height="3" border="0" alt=""></td>
<td width="10" rowspan="2"><img name="index_x" src="images/shim.gif" width="10" height="33" border="0" alt=""></td>
</tr>
<tr>
<td align="center">
<p class="footer">
Copyright © 1996&#8211;2004, PalmSource, Inc. and its affiliates. All rights reserved.<br>
<a href="http://www.palmsource.com/contact/">Write Us</a> | <a href="http://www.palmos.com/dev/training/">Training</a> | <a href="http://www.palmos.com/dev/support/kb/">Knowledge Base</a> | <a href="MDF_Front.html" target="_blank">Legal</a></p>
<br>
<!--BEGIN BOOK NAVIGATION-->
<p class="nav">
<A href="http://www.palmos.com/dev/support/docs/">Documentation</a>&nbsp;&nbsp;|&nbsp;&nbsp;
<a href="MDF_TOC.html">Table of Contents</a>&nbsp;&nbsp;
             |&nbsp;&nbsp;<a href="MDF_Part2.html">&lt;&nbsp;Previous</a>&nbsp;&nbsp;
             |&nbsp;&nbsp;<a href="FileStream.html">Next&nbsp;&gt;</a>&nbsp;&nbsp;
             |&nbsp;&nbsp;<a href="MDF_IX.html">Index</a>
</p>
</td>
</tr>
</table>
<!-- END FOOTER -->

</body>
</html>