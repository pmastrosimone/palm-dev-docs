<html>
<head>
<title>(Protein) Memory | Memory, Databases, and Files</title> 
<link href="psi_devpubs.css" rel="stylesheet" type="text/css">

<!-- BEGIN META DATA -->
<meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
<META NAME="PSITEMPLATE" CONTENT="1006-007 PalmSource_HTML_2003 20041101">
<META NAME="GENERATOR" CONTENT="Quadralay WebWorks AutoMap 2003 for FrameMaker 8.0.6.2138">
<META NAME="LASTUPDATED" CONTENT="11/22/04 11:15:29">
<!-- END META DATA -->
</head>

<body bgcolor="#ffffff" text="#000000" leftmargin="0" topmargin="0" marginwidth="0" marginheight="0">
<a name="608590"></a>

<!-- BEGIN TOPNAV -->
<table width="100%" border="0" cellspacing="0" cellpadding="0">
<tr>
<td><img src="images/shim.gif" width="7" height="75" border="0" alt=""></td>
<td align="left"><table border="0" cellpadding="0" cellspacing="0" width="744">
<tr>
<td><img name="index_r2_c1" src="images/shim.gif" width="25" height="75" border="0" alt=""></td>
<td valign="top"><table border="0" cellpadding="0" cellspacing="0" width="96">
<tr>
<td><img name="index_r2_c4" src="images/shim.gif" width="96" height="15" border="0" alt=""></td>
</tr>
<tr>
<td><a href="http://www.palmsource.com/"><img name="ps_logo" src="images/ps_logo.gif" width="96" height="54" border="0" alt=""></a></td>
</tr>

</table>
</td>

<td><table border="0" cellpadding="0" cellspacing="0" width="30">
<td><img name="index_x" src="images/shim.gif" width="30" height="75" border="0" alt=""></td>
</table></td>

<!--BEGIN MASTHEAD-->
<td><table border="0" cellpadding="0" cellspacing="0" width="96">
<tr>
<td><img name="index_x" src="images/shim.gif" width="615" height="5" border="0" alt=""></td>
</tr>
<tr>
<td>
<!--BEGIN BOOK NAVIGATION-->
<span class="nav">
<A href="http://www.palmos.com/dev/support/docs/">Documentation</a>&nbsp;&nbsp;|&nbsp;&nbsp;
<a href="MDF_TOC.html">Table of Contents</a>&nbsp;&nbsp;
             |&nbsp;&nbsp;<a href="MDF_Part1.html">&lt;&nbsp;Previous</a>&nbsp;&nbsp;
             |&nbsp;&nbsp;<a href="FilesAndDatabases.html">Next&nbsp;&gt;</a>&nbsp;&nbsp;
             |&nbsp;&nbsp;<a href="MDF_IX.html">Index</a>
</span>
<!--END BOOK NAVIGATION-->
</tr>
<tr>
<td>
<!--BEGIN PAGE TITLE-->
<h2 class="PageTitle">1 &nbsp;&nbsp;
Memory</h2></td>
<!--END PAGE TITLE-->
</tr>
<tr>
<td>
<!--BEGIN BOOK TITLE-->
<p class="BookTitle">Memory, Databases, and Files</p>
<p class="SubTitle">Exploring Palm OS&#174; </p>
<!--END BOOK TITLE-->
</td>
</tr>
<tr>
<td><img name="index_x" src="images/shim.gif" width="615" height="5" border="0" alt=""></td>
</tr>
</table>
</td>
<!--END MASTHEAD-->
</tr>
</table>
<img name="dashes" src="images/dashes.gif" width="744" height="3" border="0" alt=""></td>
</tr>
</table>
<!-- END TOPNAV -->

<table width="100%" border="0" cellspacing="0" cellpadding="0">
<tr>
<td valign="top" width="5"><img name="index_x" src="images/shim.gif" width="5" height="33" border="0" alt=""></td>

<!--BEGIN SIDETOC-->
<td valign="top" width="175">
<div id="sidetoc" valign="bottom">
<h1 class="SideTOC1-PartTab"><a href="MDF_Part1.html">Part I: Concepts</a> </h1>
<h1 class="SideTOC1"><a href="Memory.html">1  Memory</a></h1>

   <h2 class="SideTOC2"><a href="#993231">
   Memory Architecture</a></h2>

      <h3 class="SideTOC3"><a href="#995013">
      The Dynamic Heaps</a></h3>

      <h3 class="SideTOC3"><a href="#995014">
      The Storage Heaps</a></h3>

      <h3 class="SideTOC3"><a href="#995108">
      Heap Details</a></h3>

      <h3 class="SideTOC3"><a href="#995026">
      Chunks</a></h3>

   <h2 class="SideTOC2"><a href="#993414">
   The Memory Manager</a></h2>

      <h3 class="SideTOC3"><a href="#995448">
      Allocating and Freeing Memory Chunks</a></h3>

      <h3 class="SideTOC3"><a href="#995731">
      Manipulating Chunk Contents</a></h3>

   <h2 class="SideTOC2"><a href="#993734">
   Summary of Memory Management</a></h2>

</div>
</td>

<td width="5">&nbsp;&nbsp;</td>
<td width="2" background="images/index_r8_c10.gif"><img src="images/shim.gif" width="2" height="75" border="0" alt=""></td>
<td width="5">&nbsp;&nbsp;</td>

<!--END SIDETOC-->

<td valign="top">

<!--BEGIN CONTENT-->
<div id="content" valign="bottom">
<p><a name="993185"> </a>This chapter helps you understand memory use on Palm OS<sup>&#174;</sup>. </p>
<ul type="disc">
  <li><a name="993193"> </a><a href="Memory.html#993231">Memory Architecture</a> discusses how memory is structured on Palm OS. It examines the structure of the basic building blocks of Palm OS memory: heaps, chunks, and records.
  <li><a name="993197"> </a><a href="Memory.html#993414">The Memory Manager</a> discusses how to use the Palm OS Memory Manager in your applications.
</ul>

<div><hr>
  <a name="993217"> </a> <b>IMPORTANT: </b> Do not confuse the handheld's RAM with read/write memory on expansion cards, such as SD cards or Memory Stick media. You access expansion cards through a different API. See <a href="VFS.html#608590">Chapter 3, "Virtual File Systems,"</a> for more information. 
<hr>
</div>

<h2 class="haH2">
  <a name="993231"> </a>Memory Architecture <a href="#608590"><span class="nav">^TOP^</span></a>
</h2>


<div><hr>
  <a name="993232"> </a> <b>IMPORTANT: </b> This section describes the current implementation of Palm OS memory architecture. This implementation may change as Palm OS evolves. Do not rely on implementation-specific information described here; instead, always use the API provided to manipulate memory. 
<hr>
</div>

<p><a name="995346"> </a>The Palm OS divides the total available RAM store into two logical areas: <b>dynamic heaps</b> and the <b>storage heaps</b>. A process's dynamic heap is used as working space for temporary allocations, and is analogous to the RAM installed in a typical desktop system. RAM not reserved for dynamic use is designated for the storage heaps and is analogous to disk storage on a typical desktop system. </p>

<p><a name="993241"> </a>Because power is always applied to the memory system, the dynamic and storage heaps preserve their contents when the handheld is turned "off" (that is, when it is in low-power sleep mode). Storage heaps are preserved even when the handheld is explicitly reset (unless the user performs a hard reset, in which case the storage heaps are reinitialized). </p>
<h3 class="hbH3">
  <a name="995013"> </a>The Dynamic Heaps <a href="#608590"><span class="nav">^TOP^</span></a>
</h3>


<p><a name="993248"> </a>The dynamic heap provides memory for dynamic allocations. From this heap the system provides memory for dynamic data such as global variables, system dynamic allocations, application stacks, temporary memory allocations, and application dynamic allocations (such as those performed when the application calls <code>malloc()</code> or <a href="MemoryMgr.html#994503"><code>MemHandleNew()</code></a>). Each process has an independent dynamic heap that is created and destroyed along with the process.</p>

<p><a name="993252"> </a>The entire amount of RAM reserved for the dynamic heaps is always dedicated to this use, regardless of whether it is actually used for allocations. The size of the dynamic area of RAM on a particular handheld varies according to the OS version running, the amount of physical RAM available, the requirements of pre-installed software such as the TCP/IP stack or IrDA stack, and any other licensee requirements.</p>
<h3 class="hbH3">
  <a name="995014"> </a>The Storage Heaps <a href="#608590"><span class="nav">^TOP^</span></a>
</h3>


<p><a name="993365"> </a>The remaining portion of RAM not dedicated to use by the dynamic heaps is configured as a set of storage heaps and is used to hold nonvolatile user data such as appointments, to do lists, memos, address lists, and so on. An application accesses a storage heap by calling Data Manager functions such as <a href="DataMgr.html#1001715"><code>DmNewHandle()</code></a>. Storage heaps retain their contents through soft reset cycles.</p>

<p><a name="993366"> </a>The size of the storage heap available on a particular handheld varies according to the OS version that is running; the amount of physical RAM and ROM that is available; and the storage requirements of end-user application software such as the Address Book, Date Book, or third-party applications.</p>

<p><a name="996636"> </a>Note that you typically work with the storage heap by manipulating databases. See <a href="FilesAndDatabases.html#608590">Chapter 2, "Palm OS Databases,"</a> for information on creating and accessing Palm OS databases.</p>
<h3 class="hbH3">
  <a name="995108"> </a>Heap Details <a href="#608590"><span class="nav">^TOP^</span></a>
</h3>


<p><a name="995112"> </a>A <b>heap</b> is a contiguous area of memory used to contain and manage one or more smaller chunks of memory. When applications work with memory (for instance, allocate, resize, or free) they usually work with chunks of memory. An application can specify whether to allocate a new chunk of memory in a dynamic heap or a storage heap. The Memory Manager and the Data Manager each manages their respective heaps, rearranging chunks as necessary to defragment the heaps and merge free space. </p>

<p><a name="995113"> </a>Heaps in the Palm OS environment are referenced through heap IDs. A <b>heap ID</b> is a unique 16-bit value that is used to identify a heap within the Palm OS address space. The three defined heaps IDs are:</p>


<div class="tablediv"><table cellspacing="0" class="tTable">

  <tr valign="top">
    <th><p class="tt"><a name="995171"> </a><b>Heap ID</b></p>
    </th>
    <th><p class="tt"><a name="995173"> </a><b>Heap</b></p>
    </th>
    <th><p class="tt"><a name="995207"> </a><b>Managed By</b></p>
    </th>
  </tr>
  <tr valign="top">
    <td><p class="tt"><a name="995175"> </a>0</p>
    </td>
    <td><p class="tt"><a name="995177"> </a>Dynamic heap</p>
    </td>
    <td><p class="tt"><a name="995209"> </a>Memory Manager</p>
    </td>
  </tr>
  <tr valign="top">
    <td><p class="tt"><a name="995179"> </a>1</p>
    </td>
    <td><p class="tt"><a name="995181"> </a>Storage heap for classic and extended record databases, and extended resource databases except for those that contain ARM-native code.</p>
    </td>
    <td><p class="tt"><a name="995211"> </a>Data Manager</p>
    </td>
  </tr>
  <tr valign="top">
    <td><p class="tt"><a name="995183"> </a>2</p>
    </td>
    <td><p class="tt"><a name="995185"> </a>ROM heap</p>
    </td>
    <td><p class="tt"><a name="995213"> </a>Data Manager</p>
    </td>
  </tr>
  <tr valign="top">
    <td><p class="tt"><a name="998364"> </a>3</p>
    </td>
    <td><p class="tt"><a name="998366"> </a>Storage heap for schema databases and resource databases containing ARM-native code.</p>
    </td>
    <td><p class="tt"><a name="998368"> </a>Data Manager</p>
    </td>
  </tr>
</table>

</div>

<h3 class="hbH3">
  <a name="995026"> </a>Chunks <a href="#608590"><span class="nav">^TOP^</span></a>
</h3>


<p><a name="993377"> </a>In the Palm OS environment, all data are stored in chunks. A <b>chunk</b> is an area of contiguous memory between 1 byte and slightly less 2^26 bytes in a storage heap, or 2^31 bytes in a dynamic heap.</p>

<p><a name="993380"> </a>Every memory chunk used to hold storage data (as opposed to memory chunks that store dynamic data) is a record in a database implemented by the Palm OS Data Manager.</p>

<p><a name="995288"> </a>Memory chunks can be movable or immovable. When working with a storage heap, applications need to store data in movable chunks whenever feasible, thereby allowing the operating system to move chunks as necessary to create contiguous free space in memory for allocation requests. In a dynamic heap, on the other hand, applications should use the standard C APIs for working with memory (<code>malloc()</code>, <code>free()</code>, and the like); the standard C APIs have no concept of movable chunks.</p>

<p><a name="995289"> </a>When an application requests an immovable chunk it receives a pointer to that chunk. The pointer is simply that chunk's address in memory. Because the chunk cannot move, its pointer remains valid for the chunk's lifetime; thus, the pointer can be passed "as is" to the caller that requested the allocation. </p>

<p><a name="995290"> </a>When an application requests a movable chunk, the operating system generates a pointer to that chunk, just as it did for the immovable chunk, but it does not return the pointer to the caller. Instead, it stores the pointer to the chunk, called the <b>master chunk pointer</b>, in a <b>master pointer table</b> that is used to track all of the movable chunks in the heap, and returns a reference to the master chunk pointer. This reference to the master chunk pointer is known as a <b>handle</b>. It is this handle that the operating system returns to the caller that requested the allocation of a movable chunk.</p>

<p><a name="995291"> </a>Using handles imposes a slight performance penalty over direct pointer access but permits the operating system to move chunks around in the heap without invalidating any chunk references that an application might have stored away. As long as an application uses handles to reference data, only the master pointer to a chunk needs to be updated when the chunk is moved during heap defragmentation.</p>

<p><a name="995292"> </a>An application typically <b>locks</b> a chunk handle for a short time while it has to read or manipulate the contents of the chunk. The process of locking a chunk tells the Memory or Data Manager to mark that data chunk as immobile; a pointer to the chunk is returned that your application can use to manipulate the chunk contents. When an application no longer needs the data chunk, it should unlock the handle immediately to keep heap fragmentation to a minimum.</p>

<p><a name="995517"> </a>Chunks maintain a lock count. A count of zero indicates that the chunk is movable. Every time you lock a chunk, its lock count is incremented. You can lock a chunk a maximum of 14 times before an error is returned. (Unmovable chunks hold the value 15 in the lock field.) Unlocking a chunk decrements the value of the lock field by 1. When the lock count is reduced to 0, the chunk is again free to be moved by the operating system.</p>

<div><hr>
  <a name="995293"> </a> <b>IMPORTANT: </b> Note that any handle is good only until the system is reset. When the system resets, it reinitializes all dynamic memory areas and relaunches applications. Therefore, <i>you must not store a handle in a database</i>. 
<hr>
</div>

<p><a name="995386"> </a>Internally each chunk is located by means of a <b>local ID</b>. The local ID of immovable chunk is a pointer to the chunk; the local ID of movable chunk is equivalent to the chunk handle.</p>

<h4 class="hcH4">
  <a name="995611"> </a>Owner ID
</h4>

<p><a name="998198"> </a>In previous versions of Palm OS, the operating system used an <b>owner ID</b> to associate that chunk with an application. Because the dynamic heap of the main UI application is always destroyed and recreated during an application switch, owner IDs of memory chunks don't make sense in Palm OS Cobalt. The Memory Manager APIs for managing owner IDs exist for compatibility reasons; setting the owner ID of a chunk doesn't make the chunk persistent across application switches as in previous versions of Palm OS.</p>

<h2 class="haH2">
  <a name="993414"> </a>The Memory Manager <a href="#608590"><span class="nav">^TOP^</span></a>
</h2>


<p><a name="993415"> </a>The Palm OS Memory Manager is responsible for maintaining the location and size of every memory chunk in the dynamic heaps. It provides an API for allocating new chunks, disposing of chunks, resizing chunks, locking and unlocking chunks, and compacting heaps when they become fragmented.</p>

<div><hr>
  <a name="998177"> </a> <b>IMPORTANT: </b> In Palm OS Cobalt the Memory Manager APIs exist mainly for use by the Data Manager to manage storage heaps. Application developers should use the standard C library functions such as <code>malloc()</code> and <code>free()</code> to manage dynamic memory.
<hr>
</div>
<h3 class="hbH3">
  <a name="995448"> </a>Allocating and Freeing Memory Chunks <a href="#608590"><span class="nav">^TOP^</span></a>
</h3>


<p><a name="995677"> </a>To allocate a movable chunk, call <a href="MemoryMgr.html#994503"><code>MemHandleNew()</code></a> and pass the desired chunk size. To free a memory chunk given its handle, call <a href="MemoryMgr.html#994259"><code>MemHandleFree()</code></a>. The Memory Manager provides similar functions that work with immovable chunks: <a href="MemoryMgr.html#996040"><code>MemPtrNew()</code></a> allocates a memory chunk and returns a pointer to it, while <a href="MemoryMgr.html#995928"><code>MemPtrFree()</code></a> frees a chunk given its pointer.</p>

<div><hr>
  <a name="995826"> </a> <b>NOTE: </b> You cannot allocate a zero-size chunk.
<hr>
</div>

<p><a name="995715"> </a>The size of a chunk can be obtained with either <a href="MemoryMgr.html#994825"><code>MemHandleSize()</code></a> or <a href="MemoryMgr.html#996663"><code>MemPtrSize()</code></a>, depending on whether you have the chunk's handle or a pointer to its data. To resize a movable chunk use <a href="MemoryMgr.html#994681"><code>MemHandleResize()</code></a>. When resizing immovable chunks <a href="MemoryMgr.html#996148"><code>MemPtrRealloc()</code></a> is recommended; although there is a function called <a href="MemoryMgr.html#996299"><code>MemPtrResize()</code></a>, it should only be relied upon when you are making the chunk smaller since it can't increase the size of an immovable chunk unless there is free space in the heap immediately following the chunk.</p>

<p><a name="995917"> </a>If you have a pointer to a locked, movable chunk, you can recover the handle by calling <a href="MemoryMgr.html#996215"><code>MemPtrRecoverHandle()</code></a>.</p>
<h3 class="hbH3">
  <a name="995731"> </a>Manipulating Chunk Contents <a href="#608590"><span class="nav">^TOP^</span></a>
</h3>


<p><a name="995752"> </a>Because you have a pointer to any immovable chunk you've allocated with <code>MemPtrNew</code>, you can read or write that chunk's contents directly. Before you can read or write data to a movable chunk, however, you must call <a href="MemoryMgr.html#994367"><code>MemHandleLock()</code></a> to lock it and get a pointer to it. Then, when you no longer need direct access to the chunk's contents, call <a href="MemoryMgr.html#994867"><code>MemHandleUnlock()</code></a>. (Note that after a call to <code>MemHandleUnlock</code>, the pointer your application was using to access the chunk's contents is no longer valid.)</p>

<p><a name="995782"> </a>The Memory Manager provides three utility functions that you can use when working with the contents of a chunk:</p>
<ul type="disc">
  <li><a name="995789"> </a><a href="MemoryMgr.html#995658"><code>MemMove()</code></a> moves memory from one place to another.
  <li><a name="995793"> </a><a href="MemoryMgr.html#997019"><code>MemSet()</code></a> fills memory with a specific value.
  <li><a name="995804"> </a><a href="MemoryMgr.html#993802"><code>MemCmp()</code></a> compares two regions of memory.
</ul>

<p><a name="998385"> </a>Note that in Palm OS Cobalt, however, applications should normally use the standard C library functions such as <code>memmove()</code> or <code>memcpy()</code>, <code>memset()</code>, and <code>memcmp()</code> to manage dynamic memory.</p>

<h2 class="haH2">
  <a name="993734"> </a>Summary of Memory Management <a href="#608590"><span class="nav">^TOP^</span></a>
</h2>



<div class="tablediv"><table cellspacing="0" class="tTable">

  <tr valign="top">
    <th><p class="tt"><a name="993737"> </a><b><span style="color: #000000;  font-style: normal; font-weight: bold; text-decoration: none; text-transform: none; vertical-align: baseline">Memory Manager Functions</span></b></p>
    </th>
    <th><p class="tt"><a name="993739"> </a><b></b></p>
    </th>
  </tr>
  <tr valign="top">
    <td colspan="2" rowspan="1"><p class="tt"><a name="993741"> </a><b>Allocating and Freeing Memory</b></p>
    </td>
  </tr>
  <tr valign="top">
    <td><p class="tt"><a name="994420"> </a><a href="MemoryMgr.html#994259"><code>MemHandleFree()</code></a><br><a href="MemoryMgr.html#994367"><code>MemHandleLock()</code></a><br><a href="MemoryMgr.html#994503"><code>MemHandleNew()</code></a><br><a href="MemoryMgr.html#994867"><code>MemHandleUnlock()</code></a></p>
    </td>
    <td><p class="tt"><a name="993762"> </a><a href="MemoryMgr.html#995928"><code>MemPtrFree()</code></a><br><a href="MemoryMgr.html#996040"><code>MemPtrNew()</code></a><br><a href="MemoryMgr.html#996977"><code>MemPtrUnlock()</code></a><br></p>
    </td>
  </tr>
  <tr valign="top">
    <td><p class="tt"><a name="993773"> </a><b>Resizing Chunks</b></p>
    </td>
    <td><p class="tt"><a name="993775"> </a></p>
    </td>
  </tr>
  <tr valign="top">
    <td><p class="tt"><a name="993780"> </a><a href="MemoryMgr.html#994681"><code>MemHandleResize()</code></a><br><a href="MemoryMgr.html#994825"><code>MemHandleSize()</code></a><br><a href="MemoryMgr.html#996148"><code>MemPtrRealloc()</code></a></p>
    </td>
    <td><p class="tt"><a name="993791"> </a><a href="MemoryMgr.html#996299"><code>MemPtrResize()</code></a><br><a href="MemoryMgr.html#996663"><code>MemPtrSize()</code></a></p>
    </td>
  </tr>
  <tr valign="top">
    <td><p class="tt"><a name="993799"> </a><b>Working With Memory</b></p>
    </td>
    <td><p class="tt"><a name="993801"> </a></p>
    </td>
  </tr>
  <tr valign="top">
    <td><p class="tt"><a name="993806"> </a><a href="MemoryMgr.html#993802"><code>MemCmp()</code></a><br><a href="MemoryMgr.html#995658"><code>MemMove()</code></a><br><a href="MemoryMgr.html#997019"><code>MemSet()</code></a></p>
    </td>
    <td><p class="tt"><a name="993814"> </a><a href="MemoryMgr.html#994039"><code>MemDynHeapReleaseUnused()</code></a><br><a href="MemoryMgr.html#995147"><code>MemHeapCompact()</code></a></p>
    </td>
  </tr>
  <tr valign="top">
    <td><p class="tt"><a name="993845"> </a><b>Chunk Information</b></p>
    </td>
    <td><p class="tt"><a name="993847"> </a></p>
    </td>
  </tr>
  <tr valign="top">
    <td><p class="tt"><a name="993852"> </a><a href="MemoryMgr.html#994147"><code>MemHandleDataStorage()</code></a><br><a href="MemoryMgr.html#994325"><code>MemHandleHeapID()</code></a><br><a href="MemoryMgr.html#994727"><code>MemHandleSetOwner()</code></a></p>
    </td>
    <td><p class="tt"><a name="993866"> </a><a href="MemoryMgr.html#995840"><code>MemPtrDataStorage()</code></a><br><a href="MemoryMgr.html#996215"><code>MemPtrRecoverHandle()</code></a><br><a href="MemoryMgr.html#996617"><code>MemPtrSetOwner()</code></a></p>
    </td>
  </tr>
  <tr valign="top">
    <td><p class="tt"><a name="993874"> </a><b>Heap Information</b></p>
    </td>
    <td><p class="tt"><a name="993876"> </a></p>
    </td>
  </tr>
  <tr valign="top">
    <td><p class="tt"><a name="993881"> </a><a href="MemoryMgr.html#993927"><code>MemDynHeapGetInfo()</code></a><br><a href="MemoryMgr.html#993993"><code>MemDynHeapOption()</code></a><br><a href="MemoryMgr.html#994909"><code>MemHeapCheck()</code></a><br><a href="MemoryMgr.html#995189"><code>MemHeapDynamic()</code></a><br><a href="MemoryMgr.html#995259"><code>MemHeapFlags()</code></a><br><a href="MemoryMgr.html#995371"><code>MemHeapFreeBytes()</code></a></p>
    </td>
    <td><p class="tt"><a name="993892"> </a><a href="MemoryMgr.html#995473"><code>MemHeapID()</code></a><br><a href="MemoryMgr.html#995592"><code>MemHeapSize()</code></a><br><a href="MemoryMgr.html#995736"><code>MemNumHeaps()</code></a><br><a href="MemoryMgr.html#995800"><code>MemNumRAMHeaps()</code></a><br><a href="MemoryMgr.html#995970"><code>MemPtrHeapID()</code></a></p>
    </td>
  </tr>
  <tr valign="top">
    <td><p class="tt"><a name="993920"> </a><b>Debugging</b></p>
    </td>
    <td><p class="tt"><a name="993922"> </a></p>
    </td>
  </tr>
  <tr valign="top">
    <td><p class="tt"><a name="993927"> </a><a href="MemoryMgr.html#993852"><code>MemDebugMode()</code></a> <br><a href="MemoryMgr.html#997073"><code>MemSetDebugMode()</code></a></p>
    </td>
    <td><p class="tt"><a name="993935"> </a><a href="MemoryMgr.html#995515"><code>MemHeapScramble()</code></a></p>
    </td>
  </tr>
</table>

</div>


<p><a name="993937"> </a></p>
&nbsp;<br>
</div>
<!--END CONTENT-->

</td>
<td width="5">&nbsp;&nbsp;</td>
</tr>

</table>

<!-- BEGIN FOOTER -->
<table width="100%" border="0" cellspacing="0" cellpadding="0">
<tr>
<td width="7" rowspan="2"><img name="index_x" src="images/shim.gif" width="7" height="33" border="0" alt=""></td>
<td align="left"><img name="dashes" src="images/dashes.gif" width="744" height="3" border="0" alt=""></td>
<td width="10" rowspan="2"><img name="index_x" src="images/shim.gif" width="10" height="33" border="0" alt=""></td>
</tr>
<tr>
<td align="center">
<p class="footer">
Copyright © 1996&#8211;2004, PalmSource, Inc. and its affiliates. All rights reserved.<br>
<a href="http://www.palmsource.com/contact/">Write Us</a> | <a href="http://www.palmos.com/dev/training/">Training</a> | <a href="http://www.palmos.com/dev/support/kb/">Knowledge Base</a> | <a href="MDF_Front.html" target="_blank">Legal</a></p>
<br>
<!--BEGIN BOOK NAVIGATION-->
<p class="nav">
<A href="http://www.palmos.com/dev/support/docs/">Documentation</a>&nbsp;&nbsp;|&nbsp;&nbsp;
<a href="MDF_TOC.html">Table of Contents</a>&nbsp;&nbsp;
             |&nbsp;&nbsp;<a href="MDF_Part1.html">&lt;&nbsp;Previous</a>&nbsp;&nbsp;
             |&nbsp;&nbsp;<a href="FilesAndDatabases.html">Next&nbsp;&gt;</a>&nbsp;&nbsp;
             |&nbsp;&nbsp;<a href="MDF_IX.html">Index</a>
</p>
</td>
</tr>
</table>
<!-- END FOOTER -->

</body>
</html>