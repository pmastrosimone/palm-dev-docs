<html>
<head>
<title>(Protein) Palm OS Databases | Memory, Databases, and Files</title> 
<link href="psi_devpubs.css" rel="stylesheet" type="text/css">

<!-- BEGIN META DATA -->
<meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
<META NAME="PSITEMPLATE" CONTENT="1006-007 PalmSource_HTML_2003 20041101">
<META NAME="GENERATOR" CONTENT="Quadralay WebWorks AutoMap 2003 for FrameMaker 8.0.6.2138">
<META NAME="LASTUPDATED" CONTENT="11/22/04 11:15:29">
<!-- END META DATA -->
</head>

<body bgcolor="#ffffff" text="#000000" leftmargin="0" topmargin="0" marginwidth="0" marginheight="0">
<a name="608590"></a>

<!-- BEGIN TOPNAV -->
<table width="100%" border="0" cellspacing="0" cellpadding="0">
<tr>
<td><img src="images/shim.gif" width="7" height="75" border="0" alt=""></td>
<td align="left"><table border="0" cellpadding="0" cellspacing="0" width="744">
<tr>
<td><img name="index_r2_c1" src="images/shim.gif" width="25" height="75" border="0" alt=""></td>
<td valign="top"><table border="0" cellpadding="0" cellspacing="0" width="96">
<tr>
<td><img name="index_r2_c4" src="images/shim.gif" width="96" height="15" border="0" alt=""></td>
</tr>
<tr>
<td><a href="http://www.palmsource.com/"><img name="ps_logo" src="images/ps_logo.gif" width="96" height="54" border="0" alt=""></a></td>
</tr>

</table>
</td>

<td><table border="0" cellpadding="0" cellspacing="0" width="30">
<td><img name="index_x" src="images/shim.gif" width="30" height="75" border="0" alt=""></td>
</table></td>

<!--BEGIN MASTHEAD-->
<td><table border="0" cellpadding="0" cellspacing="0" width="96">
<tr>
<td><img name="index_x" src="images/shim.gif" width="615" height="5" border="0" alt=""></td>
</tr>
<tr>
<td>
<!--BEGIN BOOK NAVIGATION-->
<span class="nav">
<A href="http://www.palmos.com/dev/support/docs/">Documentation</a>&nbsp;&nbsp;|&nbsp;&nbsp;
<a href="MDF_TOC.html">Table of Contents</a>&nbsp;&nbsp;
             |&nbsp;&nbsp;<a href="Memory.html">&lt;&nbsp;Previous</a>&nbsp;&nbsp;
             |&nbsp;&nbsp;<a href="VFS.html">Next&nbsp;&gt;</a>&nbsp;&nbsp;
             |&nbsp;&nbsp;<a href="MDF_IX.html">Index</a>
</span>
<!--END BOOK NAVIGATION-->
</tr>
<tr>
<td>
<!--BEGIN PAGE TITLE-->
<h2 class="PageTitle">2 &nbsp;&nbsp;
Palm OS Databases</h2></td>
<!--END PAGE TITLE-->
</tr>
<tr>
<td>
<!--BEGIN BOOK TITLE-->
<p class="BookTitle">Memory, Databases, and Files</p>
<p class="SubTitle">Exploring Palm OS&#174; </p>
<!--END BOOK TITLE-->
</td>
</tr>
<tr>
<td><img name="index_x" src="images/shim.gif" width="615" height="5" border="0" alt=""></td>
</tr>
</table>
</td>
<!--END MASTHEAD-->
</tr>
</table>
<img name="dashes" src="images/dashes.gif" width="744" height="3" border="0" alt=""></td>
</tr>
</table>
<!-- END TOPNAV -->

<table width="100%" border="0" cellspacing="0" cellpadding="0">
<tr>
<td valign="top" width="5"><img name="index_x" src="images/shim.gif" width="5" height="33" border="0" alt=""></td>

<!--BEGIN SIDETOC-->
<td valign="top" width="175">
<div id="sidetoc" valign="bottom">
<h1 class="SideTOC1-PartTab"><a href="MDF_Part1.html">Part I: Concepts</a> </h1>
<h1 class="SideTOC1"><a href="FilesAndDatabases.html">2  Palm OS Databases</a></h1>

   <h2 class="SideTOC2"><a href="#993191">
   Database Overview</a></h2>

      <h3 class="SideTOC3"><a href="#1019825">
      Schema Databases</a></h3>

      <h3 class="SideTOC3"><a href="#993696">
      Resources and Resource Databases</a></h3>

      <h3 class="SideTOC3"><a href="#998500">
      Uniquely Identifying Databases</a></h3>

      <h3 class="SideTOC3"><a href="#1006973">
      Database Attributes</a></h3>

      <h3 class="SideTOC3"><a href="#1029499">
      Automatic Database Backup and Restore</a></h3>

   <h2 class="SideTOC2"><a href="#993748">
   Working with Schema Databases</a></h2>

      <h3 class="SideTOC3"><a href="#1007966">
      Schemas and Tables</a></h3>

      <h3 class="SideTOC3"><a href="#1008398">
      Schema Database Rows</a></h3>

      <h3 class="SideTOC3"><a href="#1015178">
      Cursors</a></h3>

      <h3 class="SideTOC3"><a href="#993997">
      Secure Databases</a></h3>

      <h3 class="SideTOC3"><a href="#995524">
      Concurrent Database Access</a></h3>

   <h2 class="SideTOC2"><a href="#1026501">
   Working with Non-Schema Databases</a></h2>

      <h3 class="SideTOC3"><a href="#1007421">
      Structure of a Non-Schema Database Header</a></h3>

      <h3 class="SideTOC3"><a href="#993293">
      Working with Non-Schema Databases</a></h3>

      <h3 class="SideTOC3"><a href="#1013859">
      Record Attributes</a></h3>

      <h3 class="SideTOC3"><a href="#993836">
      Resource Databases</a></h3>

   <h2 class="SideTOC2"><a href="#993420">
   Data Manager Tips</a></h2>

   <h2 class="SideTOC2"><a href="#993578">
   File Streaming Layer</a></h2>

      <h3 class="SideTOC3"><a href="#993582">
      Using the File Streaming API</a></h3>

</div>
</td>

<td width="5">&nbsp;&nbsp;</td>
<td width="2" background="images/index_r8_c10.gif"><img src="images/shim.gif" width="2" height="75" border="0" alt=""></td>
<td width="5">&nbsp;&nbsp;</td>

<!--END SIDETOC-->

<td valign="top">

<!--BEGIN CONTENT-->
<div id="content" valign="bottom">
<p><a name="1019963"> </a>This chapter describes how to work with Palm OS<sup>&#174;</sup> databases. Two separate header files declare the APIs you use: <code>SchemaDatabases.h</code> (documented in <a href="SchemaDatabases.html#992934">Chapter 7, "Schema Databases,"</a>) and <code>DataMgr.h</code> (documented in <a href="DataMgr.html#992934">Chapter 4, "Data Manager,"</a>). In addition, the File Streaming APIs, which allow you to access classic databases using a mechanism very similar to UNIX file streams, are declared in <code>FileStream.h</code> (and documented in <a href="FileStream.html#992934">Chapter 5, "File Stream,"</a>).</p>

<p><a name="1019978"> </a>This chapter is divided into the following major sections:</p>
   <blockquote class = "bq"><a name="1020001"> </a><a href="FilesAndDatabases.html#993191">Database Overview</a></blockquote>
   <blockquote class = "bq"><a name="1020005"> </a><a href="FilesAndDatabases.html#993748">Working with Schema Databases</a></blockquote>
   <blockquote class = "bq"><a name="1020009"> </a><a href="FilesAndDatabases.html#1026501">Working with Non-Schema Databases</a></blockquote>
   <blockquote class = "bq"><a name="1020013"> </a><a href="FilesAndDatabases.html#993578">File Streaming Layer</a></blockquote>

<div><hr>
  <a name="993186"> </a> <b>IMPORTANT: </b> To access data or resources on secondary storage (such as expansion cards), you use a different set of APIs. See <a href="VFS.html#608590">Chapter 3, "Virtual File Systems,"</a> for more information. 
<hr>
</div>

<h2 class="haH2">
  <a name="993191"> </a>Database Overview <a href="#608590"><span class="nav">^TOP^</span></a>
</h2>


<p><a name="1019359"> </a>A traditional file system first reads all or a portion of a file into a memory buffer from disk, using or updating the information in the memory buffer, and then writes the updated memory buffer back to disk. Because Palm Powered<sup>&#8482;</sup> handhelds have limited amounts of dynamic RAM and use nonvolatile RAM instead of disk storage, a traditional file system is not optimal for storing and retrieving Palm OS user data. Thus, except when working with expansion media (an SD card, Memory Stick, and the like), Palm OS doesn't make use of a traditional file system. Instead of files, Palm OS applications work with <b>databases</b>.</p>

<p><a name="1019596"> </a>Databases organize related rows (for schema databases) or records (for non-schema databases); each belongs to one and only one database. A database may be a collection of all address book entries, all datebook entries, and so on. A Palm OS application can create, delete, open, and close databases as necessary, just as a traditional file system can create, delete, open, and close a traditional file.</p>

<p><a name="1019212"> </a>For those new to Palm OS programming, the term "database" can be somewhat misleading. Palm OS Cobalt supports three different types of database, some of which look more like conventional databases than others. Schema databases, which were introduced in Palm OS Cobalt, bear a strong resemblance to relational databases. Data is organized into tables, which consist of rows and columns. <b>Schema databases</b> use the concept of a <b>schema</b> to define the structure of a table row. Unlike relational databases, however, schema databases don't allow you to perform joins and other complex operations.</p>

<p><a name="1019236"> </a>The other two database types are classified as "non-schema" databases because they are significantly less structured. There are two supported non-schema database types:</p>
<ul type="disc">
  <li><a name="1019252"> </a><b>Classic databases</b> are supported for compatibility with earlier versions of Palm OS. All versions of Palm OS back to Palm OS 1.0 support this database format, and this is the format used by applications running on Palm OS Cobalt through PACE.
  <li><a name="1019260"> </a><b>Extended databases</b> are an "extended" version of classic databases. There are three primary differences between classic and extended databases: extended databases records can exceed 64K in length (classic records cannot); extended databases are uniquely identified by a combination of name and creator ID (classic databases are uniquely identified by name alone); and extended databases can store data using the processor's native endianness (classic databases must store record data using big-endianness, for compatibility with the 68K-based Dragonball CPU used in the early Palm OS devices).
</ul>

<p><a name="1019344"> </a>Palm OS Cobalt applications that must remain compatible with an earlier OS release&#8212;perhaps a version of the application exists that runs on earlier versions of Palm OS and this application must be able to work with the earlier version's data&#8212;will use classic databases. Those Palm OS Cobalt applications that don't have such a compatibility requirement should use either extended or schema databases instead. Which to use depends on the nature of the application. Schema databases provide a great deal of support for organizing the database contents and for security, at the expense of performance. Extended databases, on the other hand, are faster to read and write, but less secure and less structured&#8212;meaning that your application has to do the work of maintaining and interpreting record contents itself.</p>
<h3 class="hbH3">
  <a name="1019825"> </a>Schema Databases <a href="#608590"><span class="nav">^TOP^</span></a>
</h3>


<p><a name="1019826"> </a>Non-schema databases treat their contents as lists of mostly opaque records. The Data Manager knows just enough about each record to understand category assignment, modification status, and deletion status. Applications are entirely responsible for structuring and interpreting database record contents. Traditional Palm OS applications, written for 68K-based handhelds and for PACE, work exclusively with classic databases.</p>

<p><a name="1019827"> </a>Schema databases add a layer of abstraction to the record contents. This extra layer of abstraction allows you to create more flexible applications, with improved sharing of data between applications. Because the Data Manager knows more about the structure of the database rows, it can provide additional capabilities, such as system-managed, optimized, and internationalized sorting. It lets you bind variables to various row fields, so as you move from one row to another the bound variables are automatically updated with the contents of the corresponding row's fields. And, you can create <b>cursors</b>, subsets of a database table's rows selected and sorted based upon application-specific criteria. Schema databases have other advantages as well:</p>
<ul type="disc">
  <li><a name="1019829"> </a>They provide more standardized data storage.
  <li><a name="1019830"> </a>Schema databases make synchronization simpler and more efficient.
  <li><a name="1019831"> </a>Schema databases can be more easily extended with additional fields.
  <li><a name="1019832"> </a>It is much easier to create conduits for schema databases, and it is easier to integrate a schema database with a database on the desktop computer or on a server.
</ul>
<h3 class="hbH3">
  <a name="993696"> </a>Resources and Resource Databases <a href="#608590"><span class="nav">^TOP^</span></a>
</h3>


<p><a name="993960"> </a>Applications can use the Data Manager to retrieve and save chunks of data conveniently. Non-schema databases that are designated as resource databases tag each chunk of data with a unique resource type and resource ID. These tagged data chunks are called <b>resources</b>. Resource databases are almost identical in structure to other non-schema databases except for a slight amount of increased storage overhead per resource record (two extra bytes).</p>

<p><a name="993964"> </a>Resources are typically used to store the user interface elements of an application, such as images, fonts, dialog layouts, and so forth. Part of building an application involves creating these resources and merging them with the actual executable code. In the Palm OS environment, an application is, in fact, simply a resource database with the executable code stored as one or more code resources and the graphics elements and other miscellaneous data stored in the same database as other resource types.</p>

<p><a name="993965"> </a>Applications may also find resource databases useful for storing and retrieving application preferences, saved window positions, state information, and so forth. These preferences settings can be stored in a separate resource database. </p>
<h3 class="hbH3">
  <a name="998500"> </a>Uniquely Identifying Databases <a href="#608590"><span class="nav">^TOP^</span></a>
</h3>


<p><a name="1005657"> </a>As in previous releases of Palm OS, classic databases must be uniquely identified by name. Schema and extended databases, however, are uniquely identified by a combination of the database's name and its creator ID. Thus, schema and extended database names need only be unique for a single creator ID: two such databases with the same name can reside on a single handheld as long as their creator IDs differ. </p>
<h3 class="hbH3">
  <a name="1006973"> </a>Database Attributes <a href="#608590"><span class="nav">^TOP^</span></a>
</h3>


<p><a name="1006974"> </a>In addition to the records that make up the database's contents&#8212;and in addition to the schemas that define the structure of the rows in a schema database table&#8212;all Palm OS databases have a set of flags that describe various aspects of the database itself, plus a set of dates identifying when the database was created, last modified, and last backed up. As well, non-schema databases have an <b>Application Info block</b> to hold application settings and the like, and a <b>Sort Info block</b> to control the ordering of database records (schema databases use a different mechanism to control row ordering; see <a href="FilesAndDatabases.html#1015178">"Cursors"</a>).</p>

<p><a name="1006981"> </a>You obtain the database attribute flags and dates, along with handles for the Sort Info block and the Application Info block if working with a non-schema database, by calling <a href="DataMgr.html#996192"><code>DmDatabaseInfo()</code></a>. </p>
<h3 class="hbH3">
  <a name="1029499"> </a>Automatic Database Backup and Restore <a href="#608590"><span class="nav">^TOP^</span></a>
</h3>


<p><a name="1029502"> </a>Palm OS Cobalt version 6.1 can be configured by a licensee to back up the contents of the RAM storage heaps to some sort of non-volatile NAND flash.  In the event that the RAM storage heaps are corrupted or are lost for some reason, the storage heaps can then be restored to their saved state. This provides an additional level of data reliability beyond what's already provided by HotSync. Devices without backup batteries may take advantage of this backup and restore capability to prevent data loss between power on/off sessions.</p>

<p><a name="1030151"> </a>For security, the backup is performed to a private internal VFS volume that can only be accessed by the Data Manager, only for purposes of backup and restore.</p>

<p><a name="1029503"> </a>Backup is triggered on a limited set of events:</p>
<ul type="disc">
  <li><a name="1029504"> </a>Database close. Any time that a database is closed, the database is backed up to the non-volatile store. 
  <li><a name="1029505"> </a>Database create. Upon creation, the database is backed up. This takes care of installed databases that are never modified and thus not otherwise backed up. 
  <li><a name="1029509"> </a>A successful call to <a href="DataMgr.html#1006265"><code>DmSetDatabaseInfo()</code></a>. Whenever a call to <code>DmSetDatabaseInfo()</code> succeeds, the database information is backed up to the non-volatile store. 
  <li><a name="1029510"> </a>Device sleep. Whenever the device goes to sleep as a result of the normal system sleep functionality, the Data Manager iterates through all open databases and backs them up to the non-volatile store. This takes care of those databases that are opened by an application and not closed until the application exits, and those databases that are opened by background threads that are running when the system goes to sleep.
  <li><a name="1029511"> </a>An explicit call to <a href="DataMgr.html#1191454"><code>DmInitiateAutoBackupOfOpenDatabase()</code></a>. 
</ul>

<p><a name="1029512"> </a>Every time the device resets with an indication that the contents of RAM may have been lost, the backup volume is restored to RAM. Before restoring the backup contents, a consistency check is performed on the backup and an attempt is made to fix any inconsistencies. Databases are only restored under these circumstances; developers cannot trigger a database restore programmatically.  </p>

<h2 class="haH2">
  <a name="993748"> </a>Working with Schema Databases <a href="#608590"><span class="nav">^TOP^</span></a>
</h2>


<p><a name="1012579"> </a>Schema databases consist of one or more tables. All of the rows in a given table have the same structure.</p>

<p><a name="1013048"> </a>All data in a schema database table is represented in the form of two-dimensional tables. A table contains zero or more rows and one or more columns. All rows in a table have the same sequence of columns, but with a different series of values in those columns. Note that a row doesn't have to have a value for a column; the special value <code>NULL</code> can be used to indicate that the value is undefined.</p>

<p><a name="1013052"> </a>As with a relational database, operations are defined by logic, not by the position of a row within a table. That is, you ask for all rows where (x = 3) and not for the first, third, and fifth rows, for example. The rows of a schema database table are in arbitrary order&#8212;the order in which they appear doesn't necessarily reflect the order in which they were entered or in which they are stored.</p>

<p><a name="1013064"> </a>One of the strengths of the relational approach (which applies to schema databases) is that you can deal with the data as information and, ideally, not worry about the details of how it is represented or physically maintained in the database itself. Having to deal with these kinds of implementation details makes extended and classic databases more difficult to manage. </p>
<h3 class="hbH3">
  <a name="1007966"> </a>Schemas and Tables <a href="#608590"><span class="nav">^TOP^</span></a>
</h3>


<p><a name="1012991"> </a>In Palm OS Cobalt, a <b>schema</b> is simply the collective definitions of a table's columns. While there is no single structure or identifier that represents a schema, the <a href="SchemaDatabases.html#993597"><code>DbTableDefinitionType</code></a> structure contains a count of the number of columns in the table and a series of pointers to the structures that define those table columns: essentially, the schema (this structure also contains the table's name, which isn't part of the schema itself).</p>

<p><a name="1013190"> </a>Each schema database can be heterogeneous in that it can support multiple tables. Because each table's definition includes the column definitions for that table&#8212;the schema&#8212;two tables can have the same schema, yet changes to one table's schema doesn't affect the other.</p>

<p><a name="1012787"> </a>Tables can be defined at the time a database is created, or added later.</p>

<p><a name="994212"> </a>Schema access is gated by the access restrictions for the database. Read-only access to a database implies read-only access to all of that database's schemas (and thus any attempt to modify the schema will fail). See <a href="FilesAndDatabases.html#993997">"Secure Databases"</a> for more information on database access restrictions.</p>

<h4 class="hcH4">
  <a name="1007534"> </a>Logical (External) vs. Physical (Internal) Views
</h4>

<p><a name="1007535"> </a>Schemas allow the Data Manager to decouple the logical (external) view of your data from the physical (internal) view. When working with a schema database you manipulate row data in terms of data types defined in the column property sets&#8212;this is the <b>logical data view</b>. In actual fact, however, the Data Manager stores row data internally in an unpublished variant format: the <b>physical data view</b>. This decoupling facilitates changes to internal data formats without affecting existing database consumers.</p>

<p><a name="1007536"> </a>Data types defined in column property sets are Palm OS primitives or their vectors. The Data Manager converts between its physical data types and the logical data types that are enforced during field get and set operations.</p>

<h4 class="hcH4">
  <a name="994214"> </a>Column Properties
</h4>

<p><a name="994215"> </a>A schema is a collection of column property sets. A column property set is represented as a <a href="SchemaDatabases.html#1052381"><code>DbSchemaColumnDefnType</code></a> structure. This structure contains the following:</p>

<dl>
<dt><a name="994216"> </a>ID</dt>
<dd><a name="1005898"> </a>A 32-bit application-defined identifier. This ID must be unique for a given table.</dd>

<dt><a name="994217"> </a>Name</dt>
<dd><a name="1024487"> </a>An application-defined name for the column. The column name must be unique for a given table. It can be up to 32 bytes in length, including the terminating null character, and must be a valid SQL identifier consisting only of 7-bit ASCII characters. The column name is stored in a single application-defined language encoding. </dd>

<dt><a name="994219"> </a>Data Type</dt>
<dd><a name="1005936"> </a>The type of data contained within the database column.</dd>

<dt><a name="1005926"> </a>Size</dt>
<dd><a name="1005927"> </a>The size, in bytes, for the column. For columns that contain variable-length strings, blobs, and vectors, this is the maximum size of the string, blob, or vector. For all other types this is the actual size of the type.</dd>

<dt><a name="994221"> </a>Attributes</dt>
<dd><a name="1005941"> </a>A set of flags that indicate whether the column data can be modified, whether the column was added to the table after the table was created, and whether or not the column data will be synchronized. (Modifications made to a "non-syncable" column's data don't change the modification state for the row, and thus by themselves don't cause the row to be synchronized during a HotSync operation.)</dd>

</dl>

<p><a name="994228"> </a>These are built-in column properties provided by the Data Manager. In addition to these built-in properties, you can define custom properties for a column: properties that facilitate application-specific semantics for columns. For more information on manipulating the column definitions that make up a schema, see <a href="FilesAndDatabases.html#993767">"Working with Column Definitions."</a></p>

<h4 class="hcH4">
  <a name="993763"> </a>Column Data Types
</h4>

<p><a name="994262"> </a>Palm OS Cobalt schema databases support the column data types listed in <a href="FilesAndDatabases.html#996672">Table 2.1</a>.</p>

<p class="caption"><a name="996672"> </a><b>Table 2.1&nbsp;&nbsp;Supported schema column data types </b></p>
<div class="tablediv"><table cellspacing="0" class="tTable">

  <tr valign="top">
    <th><p class="tt"><a name="996680"> </a><b>Palm Primitive/Logical Types</b></p>
    </th>
    <th><p class="tt"><a name="996682"> </a><b>Description</b></p>
    </th>
    <th><p class="tt"><a name="996684"> </a><b>Storage Requirement</b></p>
    </th>
    <th><p class="tt"><a name="996686"> </a><b>Range/Size</b></p>
    </th>
  </tr>
  <tr valign="top">
    <td><p class="tt"><a name="996688"> </a><code>uint8_t</code></p>
    </td>
    <td><p class="tt"><a name="996690"> </a>Unsigned char</p>
    </td>
    <td><p class="tt"><a name="996692"> </a>1 byte</p>
    </td>
    <td><p class="tt"><a name="996694"> </a>0 to 255</p>
    </td>
  </tr>
  <tr valign="top">
    <td><p class="tt"><a name="996897"> </a><code>uint16_t</code></p>
    </td>
    <td><p class="tt"><a name="996899"> </a>Unsigned short int</p>
    </td>
    <td><p class="tt"><a name="996901"> </a>2 bytes</p>
    </td>
    <td><p class="tt"><a name="996903"> </a>0 to 65535</p>
    </td>
  </tr>
  <tr valign="top">
    <td><p class="tt"><a name="996889"> </a><code>uint32_t</code></p>
    </td>
    <td><p class="tt"><a name="996891"> </a>Unsigned int</p>
    </td>
    <td><p class="tt"><a name="996893"> </a>4 bytes</p>
    </td>
    <td><p class="tt"><a name="996895"> </a>0 to 4294967295</p>
    </td>
  </tr>
  <tr valign="top">
    <td><p class="tt"><a name="996881"> </a><code>uint64_t</code></p>
    </td>
    <td><p class="tt"><a name="996883"> </a></p>
    </td>
    <td><p class="tt"><a name="996885"> </a>8 bytes</p>
    </td>
    <td><p class="tt"><a name="996887"> </a></p>
    </td>
  </tr>
  <tr valign="top">
    <td><p class="tt"><a name="996873"> </a><code>int8_t</code></p>
    </td>
    <td><p class="tt"><a name="996875"> </a>Signed char</p>
    </td>
    <td><p class="tt"><a name="996877"> </a>1 byte</p>
    </td>
    <td><p class="tt"><a name="996879"> </a>-128 to 127</p>
    </td>
  </tr>
  <tr valign="top">
    <td><p class="tt"><a name="996865"> </a><code>int16_t</code></p>
    </td>
    <td><p class="tt"><a name="996867"> </a>Signed short int</p>
    </td>
    <td><p class="tt"><a name="996869"> </a>2 bytes</p>
    </td>
    <td><p class="tt"><a name="996871"> </a>-32768 to 32767</p>
    </td>
  </tr>
  <tr valign="top">
    <td><p class="tt"><a name="996857"> </a><code>int32_t</code></p>
    </td>
    <td><p class="tt"><a name="996859"> </a>Signed int</p>
    </td>
    <td><p class="tt"><a name="996861"> </a>4 bytes</p>
    </td>
    <td><p class="tt"><a name="996863"> </a>-2147483648 to 2147483647</p>
    </td>
  </tr>
  <tr valign="top">
    <td><p class="tt"><a name="996849"> </a><code>int64_t</code></p>
    </td>
    <td><p class="tt"><a name="996851"> </a></p>
    </td>
    <td><p class="tt"><a name="996853"> </a>8 bytes</p>
    </td>
    <td><p class="tt"><a name="996855"> </a></p>
    </td>
  </tr>
  <tr valign="top">
    <td><p class="tt"><a name="996841"> </a><code>float</code></p>
    </td>
    <td><p class="tt"><a name="996843"> </a>Float</p>
    </td>
    <td><p class="tt"><a name="996845"> </a>4 bytes</p>
    </td>
    <td><p class="tt"><a name="996847"> </a></p>
    </td>
  </tr>
  <tr valign="top">
    <td><p class="tt"><a name="996833"> </a><code>double</code></p>
    </td>
    <td><p class="tt"><a name="996835"> </a>Double</p>
    </td>
    <td><p class="tt"><a name="996837"> </a>8 bytes</p>
    </td>
    <td><p class="tt"><a name="996839"> </a></p>
    </td>
  </tr>
  <tr valign="top">
    <td><p class="tt"><a name="996825"> </a><code>Boolean</code></p>
    </td>
    <td><p class="tt"><a name="996827"> </a>True /False value</p>
    </td>
    <td><p class="tt"><a name="996829"> </a>1 byte</p>
    </td>
    <td><p class="tt"><a name="996831"> </a>0 or 1</p>
    </td>
  </tr>
  <tr valign="top">
    <td><p class="tt"><a name="996817"> </a><code>DateTimeType</code></p>
    </td>
    <td><p class="tt"><a name="996819"> </a>Date-Time type</p>
    </td>
    <td><p class="tt"><a name="996821"> </a>14 bytes</p>
    </td>
    <td><p class="tt"><a name="996823"> </a></p>
    </td>
  </tr>
  <tr valign="top">
    <td><p class="tt"><a name="996809"> </a><code>DateType</code></p>
    </td>
    <td><p class="tt"><a name="996811"> </a>Date expressed as an absolute date</p>
    </td>
    <td><p class="tt"><a name="996813"> </a>2 bytes</p>
    </td>
    <td><p class="tt"><a name="996815"> </a></p>
    </td>
  </tr>
  <tr valign="top">
    <td><p class="tt"><a name="996801"> </a><code>TimeType</code></p>
    </td>
    <td><p class="tt"><a name="996803"> </a></p>
    </td>
    <td><p class="tt"><a name="996805"> </a>2 bytes</p>
    </td>
    <td><p class="tt"><a name="996807"> </a></p>
    </td>
  </tr>
  <tr valign="top">
    <td><p class="tt"><a name="1024519"> </a>time_t</p>
    </td>
    <td><p class="tt"><a name="1024521"> </a>(<code>dbDateTimeSecs</code>) Time in seconds since the UNIX epoch</p>
    </td>
    <td><p class="tt"><a name="1024523"> </a>4 bytes</p>
    </td>
    <td><p class="tt"><a name="1024551"> </a>-2147483648 to 2147483647</p>
    </td>
  </tr>
  <tr valign="top">
    <td><p class="tt"><a name="996793"> </a><code>char</code></p>
    </td>
    <td><p class="tt"><a name="996795"> </a>Fixed-length character string</p>
    </td>
    <td><p class="tt"><a name="996797"> </a><i>m</i> bytes, where m is the statically-defined length and 1 &lt;= <i>m</i> &lt;= 255</p>
    </td>
    <td><p class="tt"><a name="996799"> </a>1 &lt;= <i>m</i> &lt;= 255, where <i>m</i> is the maximum defined length.</p>
    </td>
  </tr>
  <tr valign="top">
    <td><p class="tt"><a name="996785"> </a>VarChar</p>
    </td>
    <td><p class="tt"><a name="996787"> </a>Variable-length character string</p>
    </td>
    <td><p class="tt"><a name="996789"> </a><i>n</i>+4, where <i>n</i> is the actual string length and where <i>n</i> &lt;= <i>m</i>. <i>m</i> is the maximum defined length and 1 &lt;= <i>m</i> &lt;= 2<sup>32</sup></p>
    </td>
    <td><p class="tt"><a name="996791"> </a>1 &lt;= <i>m</i> &lt;= 2<sup>32</sup>, where <i>m</i> is the maximum defined length.</p>
    </td>
  </tr>
  <tr valign="top">
    <td><p class="tt"><a name="996777"> </a>blob</p>
    </td>
    <td><p class="tt"><a name="996779"> </a>Variable-length array of bytes.</p>
    </td>
    <td><p class="tt"><a name="997140"> </a><i>n</i>+4, where <i>n</i> is the actual string length and where <i>n</i> &lt;= <i>m</i>. <i>m</i> is the maximum defined length and 1 &lt;= <i>m</i> &lt;= 2<sup>32</sup></p>
    </td>
    <td><p class="tt"><a name="997157"> </a>1 &lt;= <i>m</i> &lt;= 2<sup>32</sup>, where <i>m</i> is the maximum defined length.</p>
    </td>
  </tr>
  <tr valign="top">
    <td><p class="tt"><a name="996769"> </a>Vector</p>
    </td>
    <td><p class="tt"><a name="996771"> </a>Variable-length vectors of Palm primitive numeric, string, and date-time types. See <a href="FilesAndDatabases.html#997182">Table 2.2</a>, below, for a list of supported vector types.</p>
    </td>
    <td><p class="tt"><a name="996773"> </a><i>n</i>+4, where <i>n</i> is the number of bytes needed to contain the vector.</p>
    </td>
    <td><p class="tt"><a name="996775"> </a>2<sup>32</sup> bytes.</p>
    </td>
  </tr>
</table>

</div>


<p class="caption"><a name="997182"> </a><b>Table 2.2&nbsp;&nbsp;Supported vector types </b></p>
<div class="tablediv"><table cellspacing="0" class="tTable">

  <tr valign="top">
    <th><p class="tt"><a name="997186"> </a><b>Vector Types</b></p>
    </th>
    <th><p class="tt"><a name="997188"> </a><b>Usage</b></p>
    </th>
  </tr>
  <tr valign="top">
    <td><p class="tt"><a name="997190"> </a><code>uint8_t</code> vectors</p>
    </td>
    <td><p class="tt"><a name="997192"> </a><code>uint8_t[]</code></p>
    </td>
  </tr>
  <tr valign="top">
    <td><p class="tt"><a name="997194"> </a><code>uint16_t</code> vectors</p>
    </td>
    <td><p class="tt"><a name="997196"> </a><code>uint16_t[]</code></p>
    </td>
  </tr>
  <tr valign="top">
    <td><p class="tt"><a name="997198"> </a><code>uint32_t</code> vectors</p>
    </td>
    <td><p class="tt"><a name="997200"> </a><code>uint32_t[]</code></p>
    </td>
  </tr>
  <tr valign="top">
    <td><p class="tt"><a name="997202"> </a><code>uint64_t</code> vectors</p>
    </td>
    <td><p class="tt"><a name="997204"> </a><code>uint64_t[]</code></p>
    </td>
  </tr>
  <tr valign="top">
    <td><p class="tt"><a name="997206"> </a><code>float</code> vectors</p>
    </td>
    <td><p class="tt"><a name="997208"> </a><code>float[]</code></p>
    </td>
  </tr>
  <tr valign="top">
    <td><p class="tt"><a name="997210"> </a><code>double</code> vectors</p>
    </td>
    <td><p class="tt"><a name="997212"> </a><code>double[]</code></p>
    </td>
  </tr>
  <tr valign="top">
    <td><p class="tt"><a name="997214"> </a><code>Boolean</code> vectors</p>
    </td>
    <td><p class="tt"><a name="997216"> </a><code>Boolean[]</code></p>
    </td>
  </tr>
  <tr valign="top">
    <td><p class="tt"><a name="997218"> </a><code>DateTimeType</code> vectors</p>
    </td>
    <td><p class="tt"><a name="997220"> </a><code>DateTimeType[]</code></p>
    </td>
  </tr>
  <tr valign="top">
    <td><p class="tt"><a name="997222"> </a><code>DateType</code> vectors</p>
    </td>
    <td><p class="tt"><a name="997224"> </a><code>DateType[]</code></p>
    </td>
  </tr>
  <tr valign="top">
    <td><p class="tt"><a name="997226"> </a><code>TimeType</code> vectors</p>
    </td>
    <td><p class="tt"><a name="997228"> </a><code>TimeType[]</code></p>
    </td>
  </tr>
  <tr valign="top">
    <td><p class="tt"><a name="997323"> </a>String vectors</p>
    </td>
    <td><p class="tt"><a name="997325"> </a>Array of null-terminated strings, with an extra terminating null character marking the end of the vector. For instance, using 7-bit ASCII: <code>"String1\0String2\0String3\0\0"</code></p>
    </td>
  </tr>
</table>

</div>


<div><hr>
  <a name="994315"> </a> <b>NOTE: </b> In a string vector, the null characters must be interpreted as encoding-dependent null characters instead of null bytes. A null character may be multi-byte for a specific encoding scheme.
<hr>
</div>

<h4 class="hcH4">
  <a name="998849"> </a>Database, Table, and Column Identifiers
</h4>

<p><a name="1012864"> </a>Schema databases are uniquely identified by a combination of their name and their creator code. However, most of the schema database functions take database identifiers of the type <code>DatabaseID</code>. The function <a href="DataMgr.html#1077521"><code>DmFindDatabase()</code></a> returns a database ID for an existing database, while <a href="SchemaDatabases.html#994949"><code>DbCreateDatabase()</code></a> creates a new database (given a name, creator code, and type) and returns a database ID for the newly-created database.</p>

<p><a name="1012951"> </a>Database tables are identified by name. There is no need for a numeric "table identifier." However, each database does maintain an array of tables that you can access by index. This array is zero-based; its indices range from zero to <i>n</i>-1, where<i> n</i> is the number of tables defined for that database. This value can be obtained by calling <a href="SchemaDatabases.html#1000305"><code>DbNumTables()</code></a>. Given the index of a table within a database, you can translate it into the table's name by calling <a href="SchemaDatabases.html#999339"><code>DbGetTableName()</code></a>.</p>

<p><a name="1013394"> </a>A column is uniquely identified by either the column's descriptive name or by a 32-bit ID (both must be unique). These application-defined column names and IDs allow multiple applications within a given application context to share a common semantic understanding of a given column type. For instance, two applications might select a name of "EMNO" for the employee number column of the "EMPLOYEE" database and use column-based search and retrieval of values in the column named "EMNO". The design-time specification of both column identifiers and table names facilitates the development of public metadata interfaces for databases and encourages generic data exchange based on these interfaces.</p>

<p><a name="999276"> </a>As with tables in a database, you can iterate through the columns in a table. To obtain the number of columns in a given table, call <a href="SchemaDatabases.html#1000157"><code>DbNumColumns()</code></a>. You can retrieve the definitions for each of the columns in the row by calling <a href="SchemaDatabases.html#998449"><code>DbGetColumnDefinitions()</code></a>. To obtain the ID of an individual column given its index (which again ranges from 0 to <i>n</i>-1, where <i>n</i> is the number of columns in the table), use <a href="SchemaDatabases.html#998507"><code>DbGetColumnID()</code></a>.</p>

<h4 class="hcH4">
  <a name="993765"> </a>Creating, Modifying, and Deleting Tables
</h4>

<p><a name="998506"> </a>You can create tables either at the time you create a database or after the fact. Each table is a <a href="SchemaDatabases.html#993597"><code>DbTableDefinitionType</code></a> structure; this structure contains the table's name and an array of column definitions. Allocate memory as needed for the <code>DbTableDefinitionType</code> structures (and for the <a href="SchemaDatabases.html#1052381"><code>DbSchemaColumnDefnType</code></a> structures needed to define the table's columns), and initialize them as appropriate for your application. Then, either supply them when creating your database (with <a href="SchemaDatabases.html#994949"><code>DbCreateDatabase()</code></a> or <a href="SchemaDatabases.html#995225"><code>DbCreateSecureDatabase()</code></a>, as appropriate), or add them to an existing database with <a href="SchemaDatabases.html#994384"><code>DbAddTable()</code></a>.</p>

<p><a name="998605"> </a>You can remove a table from a database only if the table contains no non-deleted rows. If the table contains non-deleted rows, create a cursor that selects all of the table's rows, and then call <a href="SchemaDatabases.html#997225"><code>DbCursorRemoveAllRows()</code></a>. Once the table is empty, call <a href="SchemaDatabases.html#1001111"><code>DbRemoveTable()</code></a> to remove the table from the database.</p>

<p><a name="998728"> </a>When modifying an existing table, you are limited to adding and removing columns and modifying custom column properties. Get the existing table definition by calling <a href="SchemaDatabases.html#999389"><code>DbGetTableSchema()</code></a>. Use <a href="SchemaDatabases.html#994038"><code>DbAddColumn()</code></a> to add a a column to an existing table.</p>

<h4 class="hcH4">
  <a name="993767"> </a>Working with Column Definitions
</h4>

<p><a name="999397"> </a>Each table maintains a list of column definitions. As discussed in <a href="FilesAndDatabases.html#998849">"Database, Table, and Column Identifiers,"</a> given an index into that list you can obtain the corresponding column ID. This ID is necessary to work with individual columns, but isn't needed to obtain the complete set of column definitions that make up a schema.</p>

<p><a name="999567"> </a>To obtain the column definitions for a table, you can use one of two functions. <a href="SchemaDatabases.html#997950"><code>DbGetAllColumnDefinitions()</code></a> retrieves all column definitions for the specified table, while <a href="SchemaDatabases.html#998449"><code>DbGetColumnDefinitions()</code></a> retrieves one or more column definitions for the table&#8212;supply an array of column IDs indicating which column definitions are to be retrieved. Both functions return an array of column definitions (<a href="SchemaDatabases.html#1052381"><code>DbSchemaColumnDefnType</code></a> structures); when you are done with this array you must release the memory consumed by the array with a call to <a href="SchemaDatabases.html#1000459"><code>DbReleaseStorage()</code></a>.</p>

<p><a name="999632"> </a>In addition to any custom properties you define for a column definition, all columns have a set of built-in properties. These built-in properties are read-only, to prevent applications from modifying existing data row columns in a way that can impact other data consumers. Each built-in property has a corresponding constant definition that can be used as input to a generic accessor&#8212;<a href="SchemaDatabases.html#998769"><code>DbGetColumnPropertyValue()</code></a>&#8212;that retrieves the value of the specified column property. The constant definitions for the built-in properties are predefined; see <a href="SchemaDatabases.html#1201883">"DbSchemaColumnProperty"</a> for the constants themselves. The following are the built-in properties for a column:</p>
<ul type="disc">
  <li><a name="994489"> </a>Name (must be unique)
  <li><a name="994490"> </a>Data type
  <li><a name="994491"> </a>Size (maximum byte size for variable-length strings, blobs, and vectors)
  <li><a name="994492"> </a>Attributes
</ul>

<p><a name="999890"> </a>Unlike the built-in properties, custom properties may be read, written and deleted. Custom property IDs must fall outside the built-in property ID range. That is, they must be greater than <code>dbColumnPropertyUpperBound</code>.</p>

<p><a name="999891"> </a>For a given column, define custom properties using <a href="SchemaDatabases.html#1001297"><code>DbSetColumnPropertyValue()</code></a> or <a href="SchemaDatabases.html#1001383"><code>DbSetColumnPropertyValues()</code></a>. If the specified property ID does not exist, a custom property is created with the specified ID and value. If the specified property ID exists, its value is updated to the new value.</p>

<p><a name="999916"> </a>The value of any property&#8212;whether built-in or custom&#8212;can be obtained by calling either <a href="SchemaDatabases.html#998769"><code>DbGetColumnPropertyValue()</code></a>, to obtain a single property value, or <a href="SchemaDatabases.html#998835"><code>DbGetColumnPropertyValues()</code></a> to obtain multiple property values at one time.</p>

<p><a name="1000024"> </a>To remove a property from a given column, call <a href="SchemaDatabases.html#1000894"><code>DbRemoveColumnProperty()</code></a>. Note that this function is very different from <a href="SchemaDatabases.html#1000805"><code>DbRemoveColumn()</code></a>: whereas<code> DbRemoveColumnProperty()</code> removes only a property from a column, <code>DbRemoveColumn()</code> removes an entire column from a table, <i>along with that column's data</i>.</p>

<h4 class="hcH4">
  <a name="1008327"> </a>Row Attributes
</h4>

<p><a name="1014282"> </a>Schema database rows can have the attributes listed in <a href="FilesAndDatabases.html#1014286">Table 2.3</a>.</p>

<p class="caption"><a name="1014286"> </a><b>Table 2.3&nbsp;&nbsp;Schema database row attributes</b></p>
<div class="tablediv"><table cellspacing="0" class="tTable">

  <tr valign="top">
    <th><p class="tt"><a name="1014290"> </a><b>Attribute</b></p>
    </th>
    <th><p class="tt"><a name="1014292"> </a><b>Description</b></p>
    </th>
  </tr>
  <tr valign="top">
    <td><p class="tt"><a name="1014294"> </a><code>dbRecAttrArchive</code></p>
    </td>
    <td><p class="tt"><a name="1014296"> </a>The row's data is preserved until the next HotSync. When the <code>dbRecAttrArchive</code> bit is set, the <code>dbRecAttrDelete</code> bit is set as well, so archived rows are otherwise treated like deleted rows.</p>
    </td>
  </tr>
  <tr valign="top">
    <td><p class="tt"><a name="1014298"> </a><code>dbRecAttrDelete</code></p>
    </td>
    <td><p class="tt"><a name="1014300"> </a>The row has been deleted.</p>
    </td>
  </tr>
  <tr valign="top">
    <td><p class="tt"><a name="1014302"> </a><code>dbRecAttrReadOnly</code></p>
    </td>
    <td><p class="tt"><a name="1014304"> </a>The row is read-only, and cannot be written to.</p>
    </td>
  </tr>
  <tr valign="top">
    <td><p class="tt"><a name="1014306"> </a><code>dbRecAttrSecret</code></p>
    </td>
    <td><p class="tt"><a name="1014308"> </a>The row is private.</p>
    </td>
  </tr>
</table>

</div>


<div><hr>
  <a name="1014310"> </a> <b>NOTE: </b> The Data Manager does not place any semantics on the read-only attribute. It is up to the application to enforce the read-only semantics. 
<hr>
</div>

<p><a name="1014311"> </a>The read-only attribute is used to support certain record sharing scenarios that allow a user to view a record, but not to modify it. Note that schemas also allow the definition of "always writable" columns that allow particular fields to be writable in a read-only row. This might be used, for example, in a calendar event for a TV show that is read-only (you can't reschedule the show); the field containing the alarm information would be "always writable" allowing each user the option of setting an alarm.</p>

<p><a name="1008331"> </a><a href="FilesAndDatabases.html#1014001">Table 2.4</a> lists the functions that you use to get and set a schema database row's row ID, category, and attributes.</p>

<p class="caption"><a name="1014001"> </a><b>Table 2.4&nbsp;&nbsp;Functions used to access row information</b></p>
<div class="tablediv"><table cellspacing="0" class="tTable">

  <tr valign="top">
    <th><p class="tt"><a name="1014005"> </a><b>Category</b></p>
    </th>
    <th><p class="tt"><a name="1014007"> </a><b>Functions</b></p>
    </th>
  </tr>
  <tr valign="top">
    <td><p class="tt"><a name="1014009"> </a>Local ID</p>
    </td>
    <td><p class="tt"><a name="1014013"> </a><a href="SchemaDatabases.html#995682"><code>DbCursorGetCurrentRowID()</code></a><br><a href="SchemaDatabases.html#995824"><code>DbCursorGetRowIDForPosition()</code></a></p>
    </td>
  </tr>
  <tr valign="top">
    <td><p class="tt"><a name="1014019"> </a>Category Membership</p>
    </td>
    <td><p class="tt"><a name="1014024"> </a><a href="SchemaDatabases.html#993984"><code>DbAddCategory()</code></a><br><a href="SchemaDatabases.html#998391"><code>DbGetCategory()</code></a><br><a href="SchemaDatabases.html#999805"><code>DbIsRowInCategory()</code></a><br><a href="SchemaDatabases.html#1000103"><code>DbNumCategory()</code></a><br><a href="SchemaDatabases.html#1000667"><code>DbRemoveCategory()</code></a><br><a href="SchemaDatabases.html#1001237"><code>DbSetCategory()</code></a></p>
    </td>
  </tr>
  <tr valign="top">
    <td><p class="tt"><a name="1014041"> </a>Attributes</p>
    </td>
    <td><p class="tt"><a name="1014046"> </a><a href="SchemaDatabases.html#999088"><code>DbGetRowAttr()</code></a><br><a href="SchemaDatabases.html#1001758"><code>DbSetRowAttr()</code></a></p>
    </td>
  </tr>
</table>

</div>


<h4 class="hcH4">
  <a name="1008917"> </a>Categories
</h4>

<p><a name="1008918"> </a>Categories are a user-controlled means of grouping or filtering records or rows. Non-schema databases allow records to be a member of only one of 15 categories, or "Unfiled." Schema database rows, on the other hand, can be a member of any combination of up to 255 categories (or none&#8212;the equivalent of "Unfiled"). Thus, where in a extended database a record might, say, have to either fall into the "Personal" or "Business" category, in a schema database a row could fall into both.</p>

<p><a name="1008919"> </a>As with non-schema databases, category information is local to a database. However, unlike non-schema databases which store information about that database's categories in the Application Info block, schema databases rely upon an internal "category info" block to contain this information.</p>

<p><a name="1008923"> </a>Information about the database's categories, such as the number and names of the categories, as well as the order in which they occur in a UI list, is controlled by the Category Manager. The Data Manager is only responsible for managing the category membership of individual database rows.</p>

<p><a name="1008924"> </a>Category membership for a row is limited to the maximum number of categories that can be defined locally in a schema database. Since the maximum number of categories a database can support is limited to 255, any given row can only be a member of up to 255 categories. </p>

<p><a name="1008925"> </a>In a non-schema database, records are always in one category ("Unfiled" is just a specific category). In a schema database, rows may be in one category, multiple categories, or none. The notion of "Unfiled" as a category doesn't make sense here since rows shouldn't be able to be in the "Unfiled" category and in other categories at the same time. Because applications can display or perform other operations on rows with no category membership, a row that is a member of no database categories could be thought of as "Unfiled." Note that the Category Manager controls how rows with no category membership are displayed to end users.</p>

<p><a name="1008926"> </a>The Data Manager stores category IDs as category membership information for a record or row. Storing category IDs abstracts the Data Manager from any modifications performed on the internal category structure, such as adding or deleting a category.</p>

<p><a name="1008927"> </a>The following functions let you manipulate a schema database row's category membership:</p>

<dl>
<dt><a name="1008931"> </a><code><a href="SchemaDatabases.html#1001237"><code>DbSetCategory()</code></a></code></dt>
<dd><a name="1008932"> </a>Sets category membership for a single database row.</dd>

<dt><a name="1008936"> </a><code><a href="SchemaDatabases.html#993984"><code>DbAddCategory()</code></a></code></dt>
<dd><a name="1008937"> </a>Makes the specified row a member of one or more additional categories.</dd>

<dt><a name="1008941"> </a><code><a href="SchemaDatabases.html#998391"><code>DbGetCategory()</code></a></code></dt>
<dd><a name="1008942"> </a>Retrieves the category membership for the specified row.</dd>

<dt><a name="1008946"> </a><code><a href="SchemaDatabases.html#1000103"><code>DbNumCategory()</code></a></code></dt>
<dd><a name="1008947"> </a>For a specified row, determines how many categories the row is a member of.</dd>

<dt><a name="1008951"> </a><code><a href="SchemaDatabases.html#1000667"><code>DbRemoveCategory()</code></a></code></dt>
<dd><a name="1008952"> </a>Removes category membership in the specified categories from a single row.</dd>

</dl>

<p><a name="1008953"> </a>These functions let you manipulate rows that meet the given category membership criteria:</p>

<dl>
<dt><a name="1011462"> </a><code><a href="SchemaDatabases.html#999805"><code>DbIsRowInCategory()</code></a></code></dt>
<dd><a name="1011463"> </a>Determines if a row has membership for the specified categories, depending on the given match mode criteria.</dd>

<dt><a name="1011440"> </a><code><a href="SchemaDatabases.html#999965"><code>DbMoveCategory()</code></a></code></dt>
<dd><a name="1011441"> </a>Replaces one or more categories with the specified category for all rows, depending on the given match mode criteria.</dd>

<dt><a name="1011588"> </a><code><a href="SchemaDatabases.html#1000727"><code>DbRemoveCategoryAllRows()</code></a></code></dt>
<dd><a name="1011589"> </a>Removes category membership in the specified categories from all rows in the database, depending on the match mode criteria.</dd>

<dt><a name="1014425"> </a><code><a href="SchemaDatabases.html#997135"><code>DbCursorOpenWithCategory()</code></a></code></dt>
<dd><a name="1014426"> </a>Creates and opens a cursor containing all rows in the specified table that conform to a specified set of flags, ordered as specified. Rows are filtered based upon category membership.</dd>

</dl>

<h4 class="hcH4">
  <a name="1014428"> </a>The Application Info Block
</h4>

<p><a name="1014429"> </a>Schema databases don't have a dedicated Application Info block. For application-specific data of the type found in a non-schema database's Application Info block, create a database table specifically for this purpose.</p>
<h3 class="hbH3">
  <a name="1008398"> </a>Schema Database Rows <a href="#608590"><span class="nav">^TOP^</span></a>
</h3>


<p><a name="1014442"> </a>As discussed in <a href="FilesAndDatabases.html#1007966">"Schemas and Tables,"</a> a schema database table can have zero or more rows, and each row within the table shares a common structure, or schema.</p>

<p><a name="1014518"> </a>Rows are identified by a 32-bit identifier that is unique within the database. You supply the row ID (or, often, the cursor ID as discussed under <a href="FilesAndDatabases.html#1015178">"Cursors"</a>) when archiving rows, copying row contents, deleting rows, and the like. In the rare instance that you find yourself with a row ID independent of the table from which it came, you can determine to which table the row belongs by calling <a href="SchemaDatabases.html#999281"><code>DbGetTableForRow()</code></a>.</p>

<h4 class="hcH4">
  <a name="1014804"> </a>Creating New Rows
</h4>

<p><a name="1008404"> </a>To create a row, construct an array of <a href="SchemaDatabases.html#993312"><code>DbSchemaColumnValueType</code></a> structures, one for each of the row's values. To add your row to a table (you can't add a row to a database without adding it to a database table), you pass the structures to <a href="SchemaDatabases.html#999587"><code>DbInsertRow()</code></a>. Assuming that the row was added to the table successfully, this function returns the row ID of your new row. Optionally, you can add an "empty" row by calling <code>DbInsertRow()</code> without supplying the <code>DbSchemaColumnValueType</code> structures. See the description of <code>DbInsertRow()</code> for more information.</p>

<p><a name="1015068"> </a>Rows added to a table are added to the end of the database. You aren't given the opportunity to specify the position of the row within the table. The schema database APIs also don't include a function for altering the position of a row within a table. That is because when working with schema database rows you often are working within the context of a <b>cursor</b>, within which you can perform such operations.</p>

<h4 class="hcH4">
  <a name="1016939"> </a>Reading Data
</h4>

<p><a name="1016940"> </a>Columns in a row are identified either by a 32-bit application-defined ID or by an index. The index is zero-based and ranges from 0 &lt;= <i>index</i> &lt; <i>n</i>, where <i>n</i> is the number of columns in the schema. Note that the index of columns added after the schema is initially created may change, so do not make persistent references to table columns by their index.</p>

<p><a name="1016941"> </a>Individual row column values may only be extracted using column IDs. The Data Manager provides a function that returns a column's ID given its index: <a href="SchemaDatabases.html#998507"><code>DbGetColumnID()</code></a>.</p>

<p><a name="1016948"> </a><a href="SchemaDatabases.html#998897"><code>DbGetColumnValue()</code></a> retrieves a single column value. This function is restrictive, however, in the sense that it does not allow value retrieval into user-allocated buffers but always returns a reference to a storage heap buffer. Also, for greater efficiency most applications will want to retrieve multiple columns using either <a href="SchemaDatabases.html#998959"><code>DbGetColumnValues()</code></a> or <a href="SchemaDatabases.html#994887"><code>DbCopyColumnValues()</code></a>. </p>

<p><a name="1016955"> </a>For columns containing string or vector data, you can retrieve partial column values through the use of an offset. This is useful for columns containing large strings or blobs where, for space efficiency it makes sense to only read or write a portion of the column's data.</p>

<p><a name="1016956"> </a>When retrieving values, you can retrieve them either by copy or by reference.</p>

<dl>
<dt><a name="1016957"> </a>Value Copy</dt>
<dd><a name="1016958"> </a>You allocate output buffers, enclose each in a <a href="SchemaDatabases.html#993312"><code>DbSchemaColumnValueType</code></a> structure, and pass them to the Data Manager by calling either <a href="SchemaDatabases.html#994786"><code>DbCopyColumnValue()</code></a> or <a href="SchemaDatabases.html#994887"><code>DbCopyColumnValues()</code></a>. The Data Manager then copies column data into the buffers.</dd>

<dt><a name="1016968"> </a>Value Reference</dt>
<dd><a name="1016972"> </a>You call either <a href="SchemaDatabases.html#998129"><code>DbGetAllColumnValues()</code></a>, <a href="SchemaDatabases.html#998959"><code>DbGetColumnValues()</code></a>, or <a href="SchemaDatabases.html#998897"><code>DbGetColumnValue()</code></a>, and receive back references to column data. This saves RAM by not requiring an additional buffer for column value storage. When you are done working with the data, you must explicitly release the Data Manager-allocated buffer with <a href="SchemaDatabases.html#1000459"><code>DbReleaseStorage()</code></a>, which unlocks the row.</dd>

</dl>

<p><a name="1016982"> </a>The storage locality of the buffers for the various value retrieval functions is detailed in <a href="FilesAndDatabases.html#1016989">Table 2.5</a> for different database types.</p>

<p class="caption"><a name="1016989"> </a><b>Table 2.5&nbsp;&nbsp;Buffer storage locality for column value retrieval functions</b></p>
<div class="tablediv"><table cellspacing="0" class="tTable">

  <tr valign="top">
    <th><p class="tt"><a name="1016995"> </a><b>Function</b></p>
    </th>
    <th><p class="tt"><a name="1016997"> </a><b>Non-Secure</b></p>
    </th>
    <th><p class="tt"><a name="1016999"> </a><b>Secure</b></p>
    </th>
  </tr>
  <tr valign="top">
    <td><p class="tt"><a name="1017001"> </a><code>DbGetAllColumnValues()<br>DbGetColumnValues()<br>DbGetColumnValue()</code></p>
    </td>
    <td><p class="tt"><a name="1017003"> </a>Data Manager returns references to storage-heap-based column values.</p>
    </td>
    <td><p class="tt"><a name="1017005"> </a>Data Manager returns references to dynamic-heap-based column values. References to storage heap values are not returned for secure databases.</p>
    </td>
  </tr>
  <tr valign="top">
    <td><p class="tt"><a name="1017007"> </a><code>DbCopyColumnValue()<br>DbCopyColumnValues()</code></p>
    </td>
    <td><p class="tt"><a name="1017009"> </a>Data Manager copies column values to user-allocated dynamic heap storage.</p>
    </td>
    <td><p class="tt"><a name="1017011"> </a>Data Manager copies column values into user-allocated dynamic heap storage.</p>
    </td>
  </tr>
</table>

</div>


<p><a name="1017016"> </a>The code excerpt in <a href="FilesAndDatabases.html#1017018">Listing 2.1</a> illustrates how you can retrieve a single column value with <code>DbGetColumnValue()</code>.</p>
<p class="CCodeCaption">
  <a name="1017018"> </a><b>Listing 2.1&nbsp;&nbsp;Retrieving a single column value</b>
</p>

<div class="CodeRule"><hr></div><pre class="CodeBlock">
status_t errCode;<a name="1017019"> </a>
char nameP[25];<a name="1017020"> </a>
void *valueP;<a name="1017021"> </a>
uint32_t valueSize;<a name="1017022"> </a>
uint32_t columnID = 768;<a name="1017023"> </a>
<a name="1017024"> </a>
errCode = DbGetColumnValue(dbRef, rowID, columnID, 0,
   &amp;valueP, &amp;valueSize);<a name="1017025"> </a>
if (errNone == errCode){<a name="1017026"> </a>
   // process each column value<a name="1017027"> </a>
   memcpy(nameP, valueP, valueSize);<a name="1017028"> </a>
} else {<a name="1017029"> </a>
   ErrDisplay("Error in retrieving column value");<a name="1017030"> </a>
   return errCode;<a name="1017031"> </a>
}<a name="1017032"> </a>
<a name="1017033"> </a>
// release storage heap buffer returned by the Data Manager<a name="1017034"> </a>
DbReleaseStorage(dbRef, valueP);<a name="1017035"> </a>
</pre><div class="CodeRule"><hr></div>


<p><a name="1017039"> </a>The code in <a href="FilesAndDatabases.html#1017041">Listing 2.2</a> is similar to the above, but it shows how to use <code>DbGetAllColumnValues()</code> to retrieve every column value for a database row with a single call.</p>
<p class="CCodeCaption">
  <a name="1017041"> </a><b>Listing 2.2&nbsp;&nbsp;Retrieving all column values </b>
</p>

<div class="CodeRule"><hr></div><pre class="CodeBlock">
DbSchemaColumnValueType *columnValueArray;<a name="1017042"> </a>
status_t errCode;<a name="1017043"> </a>
uint32_t numColumns; <a name="1017044"> </a>
<a name="1017045"> </a>
errCode = DbGetAllColumnValues(dbRef, rowID,
   &amp;numColumns, &amp;columnValueArray);<a name="1017046"> </a>
if (errNone == errCode){<a name="1017047"> </a>
   // iterate through the column value array<a name="1017048"> </a>
   for (int i=0; i&lt;numColumns; i++){<a name="1017049"> </a>
      if (errNone == columnValueArray[i].errCode){<a name="1017050"> </a>
         // process each column value<a name="1017051"> </a>
      } else {<a name="1017052"> </a>
         // handle error in retrieving column value.<a name="1017053"> </a>
         ErrDisplay("Error in retrieving column value");<a name="1017054"> </a>
         break;<a name="1017055"> </a>
      }<a name="1017056"> </a>
   }<a name="1017057"> </a>
} else {<a name="1017058"> </a>
   ErrDisplay("Error in retrieving column values");<a name="1017059"> </a>
   return errCode;<a name="1017060"> </a>
}<a name="1017061"> </a>
<a name="1017062"> </a>
// Release storage heap buffer returned by the Data Manager<a name="1017063"> </a>
// This invalidates all columnValueArray[i].columnData<a name="1017064"> </a>
// references.<a name="1024625"> </a>
DbReleaseStorage(dbRef, columnValueArray);<a name="1017066"> </a>
}<a name="1017067"> </a>
</pre><div class="CodeRule"><hr></div>


<p><a name="1017068"> </a>In addition to retrieving a single column value or all column values, you can set up an array of column IDs and use <code>DbGetColumnValues()</code> to retrieve a subset of the row's values. <a href="FilesAndDatabases.html#1017073">Listing 2.3</a> illustrates the use of <code>DbGetColumnValues()</code> in this way.</p>
<p class="CCodeCaption">
  <a name="1017073"> </a><b>Listing 2.3&nbsp;&nbsp;Retrieving multiple, specific column values</b>
</p>

<div class="CodeRule"><hr></div><pre class="CodeBlock">
DbSchemaColumnValueType *columnValueArray;<a name="1017074"> </a>
status_t errCode;<a name="1017075"> </a>
uint32_t columnIDArray[] = {768, 770, 771};<a name="1017076"> </a>
uint32_t numColumns = sizeof(columnIDArray)/sizeof(uint32_t);<a name="1017077"> </a>
<a name="1017078"> </a>
errCode = DbGetColumnValues(dbRef, rowID, numColumns,
   columnIDArray, &amp;columnValueArray);<a name="1017079"> </a>
if (errNone == errCode){<a name="1017080"> </a>
   // iterate through the column value array<a name="1017081"> </a>
   for (int i=0; i&lt;numColumns; i++){<a name="1017082"> </a>
      if (errNone == columnValueArray[i].errCode){<a name="1017083"> </a>
         // process each column value<a name="1017084"> </a>
      } else {<a name="1017085"> </a>
         // handle error in retrieving column value.<a name="1017086"> </a>
         ErrDisplay("Error in retrieving column");<a name="1017087"> </a>
         break;<a name="1017088"> </a>
      }<a name="1017089"> </a>
   }<a name="1017090"> </a>
} else {<a name="1017091"> </a>
   ErrDisplay("Error in retrieving column values");<a name="1017092"> </a>
   return errCode;<a name="1017093"> </a>
<a name="1017094"> </a>
// Release storage heap buffer returned by the Data Manager.<a name="1017095"> </a>
// This invalidates all columnValueArray[i].columnData<a name="1017096"> </a>
// references.<a name="1024639"> </a>
DbReleaseStorage(dbRef, columnValueArray);<a name="1017098"> </a>
</pre><div class="CodeRule"><hr></div>


<p><a name="1017102"> </a>As a final example, <a href="FilesAndDatabases.html#1017104">Listing 2.4</a> shows how to retrieve multiple column values but have them copied into pre-allocated buffers by <code>DbCopyColumnValues()</code>.</p>
<p class="CCodeCaption">
  <a name="1017104"> </a><b>Listing 2.4&nbsp;&nbsp;Copying multiple, specific column values </b>
</p>

<div class="CodeRule"><hr></div><pre class="CodeBlock">
DbSchemaColumnValueType columnValueArray[4];<a name="1017105"> </a>
uint32_t numColumns = sizeof(columnValueArray) /
   sizeof(DbColumnValueType);<a name="1017106"> </a>
uint32_t rowIndex;<a name="1017107"> </a>
status_t errCode;<a name="1017108"> </a>
<a name="1017109"> </a>
typedef struct {<a name="1017110"> </a>
   char userName[20];<a name="1017111"> </a>
   char userAddressLine1[25];<a name="1017112"> </a>
   char userAddressLine2[25];<a name="1017113"> </a>
   char userAddressLine3[25];<a name="1017114"> </a>
} userDetailsType;<a name="1017115"> </a>
userDetailsType user;<a name="1017117"> </a>
<a name="1017118"> </a>
columnValueArray[0].columnID = 768;<a name="1017119"> </a>
columnValueArray[0].data = user.userName;<a name="1017120"> </a>
columnValueArray[0].dataSize = sizeof(user.userName);<a name="1017121"> </a>
<a name="1017122"> </a>
columnValueArray[1].columnID = 770;<a name="1017123"> </a>
columnValueArray[1].data = user.userAddressLine1;<a name="1017124"> </a>
columnValueArray[1].dataSize = sizeof(user.userAddressLine1);<a name="1017125"> </a>
<a name="1017126"> </a>
columnValueArray[2].columnID = 771;<a name="1017127"> </a>
columnValueArray[2].data = user.userAddressLine2;<a name="1017128"> </a>
columnValueArray[2].dataSize = sizeof(user.userAddressLine2);<a name="1017129"> </a>
<a name="1017130"> </a>
columnValueArray[3].columnID = 772;<a name="1017131"> </a>
columnValueArray[3].data = user.userAddressLine3;<a name="1017132"> </a>
columnValueArray[3].dataSize = sizeof(user.userAddressLine3);<a name="1017133"> </a>
<a name="1017134"> </a>
errCode = DbCopyColumnValues(dbRef, rowID,
   numColumns, columnValueArray);<a name="1017137"> </a>
if (errNone == errCode){<a name="1017138"> </a>
   // iterate through the column value array to check <a name="1017139"> </a>
   // for retrieval errors<a name="1017140"> </a>
   for (int i =0 ; i &lt; numColumns; i++){<a name="1017141"> </a>
      // process the user name column<a name="1017142"> </a>
      // process each column value directly from the user<a name="1017143"> </a>
      // structure or from columnValueArray[i].data.<a name="1017144"> </a>
      if (errNone == columnValueArray[0].errCode)<a name="1017145"> </a>
         FldSetTextPtr(fldP, user.username);<a name="1017146"> </a>
      else {<a name="1017147"> </a>
         // handle error in retrieving column value.<a name="1017148"> </a>
         ErrDisplay("Error in retrieving column value");<a name="1017149"> </a>
         break;<a name="1017150"> </a>
      }<a name="1017151"> </a>
<a name="1017153"> </a>
      // similarly, process the other columns...<a name="1024678"> </a>
   }<a name="1017154"> </a>
} else {<a name="1017155"> </a>
   ErrDisplay("Error in retrieving column values");<a name="1017156"> </a>
   return errCode;<a name="1017157"> </a>
}<a name="1017158"> </a>
<a name="1017160"> </a>
// no storage heap buffer release required here as column<a name="1017161"> </a>
// values are retrieved in a user-allocated buffer<a name="1017162"> </a>
</pre><div class="CodeRule"><hr></div>


<h4 class="hcH4">
  <a name="1017663"> </a>Writing Data
</h4>

<p><a name="1017664"> </a>Just as you can read either a single column value or multiple column values, you can also write a single column value or multiple column values. <a href="SchemaDatabases.html#1001832"><code>DbWriteColumnValue()</code></a> writes a single column value to the database. As when reading, for greater efficiency when writing more than one column value call <a href="SchemaDatabases.html#1001902"><code>DbWriteColumnValues()</code></a> rather than calling <code>DbWriteColumnValue()</code> multiple times.</p>

<p><a name="1017671"> </a>Partial column value writes are also possible for string, blob and vector columns through the use of an offset. This is useful for columns that contain large strings or blobs where, for space efficiency reasons, it makes sense to only write a portion of the column value.</p>

<p><a name="1017672"> </a>When calling either of these <code>DbWrite...()</code> functions, the Data Manager copies the input data values to the storage heap as row data. Because the database now contains a copy of the data, you may then free the input data.</p>

<p><a name="1017677"> </a><a href="FilesAndDatabases.html#1017679">Listing 2.5</a> shows how to use <code>DbWriteColumnValue()</code> to write a single column value to a schema database.</p>
<p class="CCodeCaption">
  <a name="1017679"> </a><b>Listing 2.5&nbsp;&nbsp;Writing a single column value</b>
</p>

<div class="CodeRule"><hr></div><pre class="CodeBlock">
uint32_t columnID = 1034;<a name="1017680"> </a>
char newName[] = "Terrence";<a name="1017681"> </a>
uint32_t nameSize = strlen(newName) + 1;  // include the null<a name="1017682"> </a>
int32_t oldSize = -1;   // replace the entire column's data<a name="1017683"> </a>
<a name="1017684"> </a>
// this will overwrite old name with new name. Other<a name="1017685"> </a>
// variations are possible depending on<a name="1017686"> </a>
// combinations of bytesToReplace and srcBytes<a name="1017687"> </a>
if (errNone != DbWriteColumnValue(dbRef, &amp;rowID,
   columnID, 0, oldSize, newName, nameSize)) {<a name="1017688"> </a>
   // handle error in writing column value.<a name="1017689"> </a>
   ErrDisplay("Error in writing column value");<a name="1017690"> </a>
}<a name="1017691"> </a>
</pre><div class="CodeRule"><hr></div>


<p><a name="1017695"> </a><a href="FilesAndDatabases.html#1017697">Listing 2.6</a> shows how to use <code>DbWriteColumnValues()</code> to write multiple column values to a schema database.</p>
<p class="CCodeCaption">
  <a name="1017697"> </a><b>Listing 2.6&nbsp;&nbsp;Writing multiple column values</b>
</p>

<div class="CodeRule"><hr></div><pre class="CodeBlock">
DbSchemaColumnValueType columnValueArray[3];<a name="1017698"> </a>
uint32_t columnIDArray[] = {1034, 1035, 1036};<a name="1017699"> </a>
uint32_t numColumns = sizeof(columnIDArray)/sizeof(uint32_t);<a name="1017700"> </a>
status_t errCode;<a name="1017701"> </a>
<a name="1017702"> </a>
typedef struct {<a name="1017703"> </a>
   uint32_t orderID;<a name="1017704"> </a>
   char orderType[4];<a name="1017705"> </a>
   uint32_t orderQuantity;<a name="1017706"> </a>
} orderDetailsType;<a name="1017707"> </a>
<a name="1017708"> </a>
orderDetailsType order;<a name="1017709"> </a>
<a name="1017710"> </a>
columnValueArray[0].data = order.orderID;<a name="1017711"> </a>
columnValueArray[0].dataSize = sizeof(order.orderID);<a name="1017712"> </a>
columnValueArray[0].columnID = columnIDArray[0];<a name="1024278"> </a>
<a name="1017713"> </a>
columnValueArray[1].data = order.orderType;<a name="1017714"> </a>
columnValueArray[1].dataSize = sizeof(order.orderType);<a name="1017715"> </a>
columnValueArray[1].columnID = columnIDArray[1];<a name="1024280"> </a>
<a name="1017716"> </a>
columnValueArray[2].data = order.orderQuantity;<a name="1017717"> </a>
columnValueArray[2].dataSize = sizeof(order.orderQuantity);<a name="1017718"> </a>
columnValueArray[2].columnID = columnIDArray[2];<a name="1024284"> </a>
<a name="1017719"> </a>
if (errNone != DbWriteColumnValues(dbRef, &amp;rowID,
   numColumns, columnValueArray)){<a name="1017720"> </a>
   // handle error in writing column value.<a name="1017721"> </a>
   ErrDisplay("Error in writing column value");<a name="1017722"> </a>
}<a name="1017723"> </a>
</pre><div class="CodeRule"><hr></div>


<h4 class="hcH4">
  <a name="1025275"> </a>Deleting Rows
</h4>

<p><a name="1025279"> </a>Delete individual database rows by calling <a href="SchemaDatabases.html#997650"><code>DbDeleteRow()</code></a>. To delete a set of rows in a single table, create a cursor that identifies those rows and then call <a href="SchemaDatabases.html#995590"><code>DbCursorDeleteAllRows()</code></a>. </p>
<h3 class="hbH3">
  <a name="1015178"> </a>Cursors <a href="#608590"><span class="nav">^TOP^</span></a>
</h3>


<p><a name="1015179"> </a>Cursors simplify data access for schema databases. A cursor is a logical view of a subset of rows from a table, ordered as specified by the cursor. Once a cursor is created, applications can iterate the rows from the cursor, retrieve data from rows in the cursor, and to write data to rows in the cursor.</p>

<p><a name="1015180"> </a>Cursors are temporary. They are not saved with the database. Cursors are simple to create and an application can have multiple cursors active at the same time, including multiple cursors on the same table.</p>

<p><a name="1015361"> </a>With the exception of <a href="SchemaDatabases.html#999587"><code>DbInsertRow()</code></a>, schema database functions with row access semantics can take either a row ID or a cursor ID as a parameter. These are both <code>uint32_t</code> values and generally may be used interchangeably. The Data Manager derives the actual type of the parameter based on a value-encoding scheme it uses for row IDs; this scheme ensures that a row ID is always differentiable from a cursor ID. If you need to know whether a given identifier is a row ID or a cursor ID (or neither), you can make use of the functions <a href="SchemaDatabases.html#999763"><code>DbIsRowID()</code></a> and <a href="SchemaDatabases.html#1063398"><code>DbIsCursorID()</code></a>.</p>

<p><a name="1024912"> </a>The rows in a cursor needn't be sorted. A cursor that is opened unsorted is said to use the <b>default sort index</b>. In this instance, the string you supply for the <code class="par">sql</code> parameter in the <code>DbCursorOpen...()</code> call should consist of the name of the table containing the database rows to be included and an optional WHERE clause indicating which of the table's rows should be included in the cursor. (See <a href="FilesAndDatabases.html#1025104">"The WHERE Clause"</a> for more information on the WHERE clause.)</p>

<h4 class="hcH4">
  <a name="1015191"> </a>Creating Cursors
</h4>

<p><a name="1015195"> </a>Create a cursor with <a href="SchemaDatabases.html#997075"><code>DbCursorOpen()</code></a> or <a href="SchemaDatabases.html#997135"><code>DbCursorOpenWithCategory()</code></a>. To create a cursor you supply a reference to an open database; a SELECT statement that specifies the database table from which the rows are to be taken, an optional selection criteria (WHERE clause), and an optional sort criteria (ORDER BY clause); and a set of flags that indicate whether deleted or secret rows should be included in the cursor, whether the rows should be sorted by category, and so on. (See <a href="SchemaDatabases.html#1063503">"Cursor Open Flags"</a> for the complete set). If you use <code>DbCursorOpenWithCategory()</code> you also can limit the rows in the cursor to those that meet the specified category criteria.</p>

<div><hr>
  <a name="1026551"> </a> <b>IMPORTANT: </b> The sort index&#8212;that is, the SELECT statement&#8212;that you supply when creating the cursor must have been added to the table prior to its use in the <code>DbCursorOpen...</code> call. See the documentation for the <a href="SchemaDatabases.html#994338"><code>DbAddSortIndex()</code></a> function for more information.
<hr>
</div>

<h4 class="hcH4">
  <a name="1025062"> </a>The SELECT Statement
</h4>

<p><a name="1025519"> </a>You use a limited form of the standard SQL SELECT statement to specify the rows that make up the cursor and the order in which those rows are to occur. You pass this SELECT statement, as an ASCII string, to <code>DbCursorOpen...()</code>. The following is the basic format of the schema database SELECT statement:</p>

<div class="CodeRule"><hr></div><pre class="CodeBlock">
[SELECT * FROM] <i>tableName</i> [WHERE <i>column</i> <i>op</i> <i>arg</i>] 
[ORDER BY (<i>col1</i>, <i>col2</i>, ...) [DESC | ASC | CASED | CASELESS] 
[, <i>col</i>...]]<a name="1025064"> </a>
</pre><div class="CodeRule"><hr></div>


<p><a name="1025065"> </a>"SELECT * FROM" is entirely optional; its inclusion has no effect at this point: schema database cursors don't do projection. <i>tableName</i> is the only required part of this statement, and must identify the table from which the cursor rows are to be taken. The optional WHERE clause allows you to filter the rows to be included in the cursor; see <a href="FilesAndDatabases.html#1025104">"The WHERE Clause"</a> for a complete description of this clause.</p>

<p><a name="1025069"> </a>The ORDER BY clause, also optional, controls the sorting of the rows within the cursor. Schema databases support two levels of sort keys, using parenthesis to identify the levels. The ORDER BY clause is perhaps best illustrated by way of example:</p>

<div class="CodeRule"><hr></div><pre class="CodeBlock">
myTable ORDER BY LNAME, FNAME DESC, (34, 56) ASC CASED<a name="1025070"> </a>
</pre><div class="CodeRule"><hr></div>


<p><a name="1025071"> </a>The rows are sorted according to the column names and IDs as listed here. The first column ("LNAME", in the above example) gets the highest priority. The second column ("FNAME", in the above example) determines the order within duplicate values of the first. And the third column determines the order within duplicate values of the second. In this example the third column ID is a two-level key: column 34 is used unless that column is empty, in which case column 56 is used instead. DESC, ASC, and CASED are options that clarify how the sort is performed. The following options are allowed:</p>

<dl>
<dt><a name="1025072"> </a><code>DESC</code></dt>
<dd><a name="1025073"> </a>(or <code>DESCENDING</code>): sort in descending order.</dd>

<dt><a name="1025074"> </a><code>ASC</code></dt>
<dd><a name="1025075"> </a>(or <code>ASCENDING</code>): sort in ascending order. This is the default if neither <code>DESC</code> or <code>ASC</code> is specified.</dd>

<dt><a name="1025076"> </a><code>CASED</code></dt>
<dd><a name="1025077"> </a>Take case into account when sorting.</dd>

<dt><a name="1025078"> </a><code>CASELESS</code></dt>
<dd><a name="1025079"> </a>Ignore case when sorting. This is the default if neither <code>CASED</code> or <code>CASELESS</code> is specified.</dd>

</dl>

<p><a name="1025080"> </a>Before you can use the SELECT statement when opening a cursor (other than one corresponding to the default sort index), you must have added to the database a sort index with a matching SELECT statement . This is done for efficiency reasons: schema databases maintain a list of rows in sorted order for each of the database's sort indices, and as a row is added, deleted, or modified the record lists for each sort index that applies to that row are updated. Because the lists are maintained in sorted order, the Data Manager doesn't have to perform a sort operation when you open a cursor that corresponds to an existing sort index.</p>

<h4 class="hcH4">
  <a name="1025724"> </a>Sort Indicies
</h4>

<p><a name="1025725"> </a>Sort indices allow you to specify how table rows should be automatically sorted. These sort indices are maintained by the Data Manager and are stored as part of the database. Any application that has read authorization for a database can use the sort indices for that database. Any application that has write authorization for the database can add, remove, or edit the sort indices for a database.</p>

<p><a name="1025726"> </a>There is no limit to the number of sort indices that you can define for a database, although for performance reasons you should limit the number of sort indices to a small number. Large numbers of sort indices affect the performance of adding, deleting, and modifying rows, because all indices must be adjusted appropriately as data in the database changes.</p>

<p><a name="1025727"> </a>When creating a sort index, you use the format discussed under <a href="FilesAndDatabases.html#1025062">"The SELECT Statement"</a> to specify the table name and the keys (by column name or ID) that constitute the sort index. A sort index can sort on multiple keys; one of those keys is designated as the primary sort key. The other key specifications are optional and constitute the secondary sort keys.</p>

<p><a name="1025728"> </a>Each key definition consists of the set of columns that constitute the key, the sort order (ascending or descending), and an indication as to whether or not row comparisons should be made in a case-sensitive manner. A key can be composed of multiple columns, although all of a key's columns must be of the same type. During a sort index update, when comparing two rows, if a row does not contain data in the first column of the sort key, the next specified column is checked and so on until a column with data is found. If the data in these two columns is equal, the next non-empty specified columns are checked.</p>

<p><a name="1025729"> </a>The Data Manager uses its own internal sorting and comparison routines to keep the index automatically sorted. Whenever a field is updated, all indices (except the default index) that use that field are automatically updated.</p>

<p><a name="1025733"> </a>Sort indices support the data types listed in <a href="FilesAndDatabases.html#1025740">Table 2.6</a>. Only columns of the listed types may be used for the sort indices. For <code>dbChar</code> and <code>dbVarChar</code> data types, you can indicate whether or not a case-sensitive comparison should be performed. Note that the Data Manager relies upon the Text Manager comparison APIs when comparing these data types. This ensures correct sorting with the appropriate case-sensitivity on localized string data. (Data is sorted using the current system locale.) Blob data (<code>dbBlob</code>) is compared using a simple <code>memcmp()</code>.</p>

<p class="caption"><a name="1025740"> </a><b>Table 2.6&nbsp;&nbsp;Data types supported by sort indices </b></p>
<div class="tablediv"><table cellspacing="0" class="tTable">

  <tr valign="top">
    <td><p class="tt"><a name="1025744"> </a><code>dbUInt8</code></p>
    </td>
    <td><p class="tt"><a name="1025746"> </a><code>dbUInt16</code></p>
    </td>
  </tr>
  <tr valign="top">
    <td><p class="tt"><a name="1025748"> </a><code>dbUInt32</code></p>
    </td>
    <td><p class="tt"><a name="1025750"> </a><code>dbUInt64</code></p>
    </td>
  </tr>
  <tr valign="top">
    <td><p class="tt"><a name="1025752"> </a><code>dbInt8</code></p>
    </td>
    <td><p class="tt"><a name="1025754"> </a><code>dbInt16</code></p>
    </td>
  </tr>
  <tr valign="top">
    <td><p class="tt"><a name="1025756"> </a><code>dbInt32</code></p>
    </td>
    <td><p class="tt"><a name="1025758"> </a><code>dbInt64</code></p>
    </td>
  </tr>
  <tr valign="top">
    <td><p class="tt"><a name="1025760"> </a><code>dbFloat</code></p>
    </td>
    <td><p class="tt"><a name="1025762"> </a><code>dbDouble</code></p>
    </td>
  </tr>
  <tr valign="top">
    <td><p class="tt"><a name="1025764"> </a><code>dbBoolean</code></p>
    </td>
    <td><p class="tt"><a name="1025766"> </a><code>dbDateTime</code></p>
    </td>
  </tr>
  <tr valign="top">
    <td><p class="tt"><a name="1025768"> </a><code>dbDate</code></p>
    </td>
    <td><p class="tt"><a name="1025770"> </a><code>dbTime</code></p>
    </td>
  </tr>
  <tr valign="top">
    <td><p class="tt"><a name="1025772"> </a><code>dbChar</code></p>
    </td>
    <td><p class="tt"><a name="1025774"> </a><code>dbVarChar</code></p>
    </td>
  </tr>
  <tr valign="top">
    <td><p class="tt"><a name="1025776"> </a><code>dbBlob</code></p>
    </td>
    <td><p class="tt"><a name="1025778"> </a></p>
    </td>
  </tr>
</table>

</div>


<p><a name="1025780"> </a>Application-provided comparison functions are not supported by sort indices, due to the performance overhead of having to call and potentially launch an application each time a field is modified. </p>

<p><a name="1025784"> </a>Add a sort index to a database with <a href="SchemaDatabases.html#994338"><code>DbAddSortIndex()</code></a>. If you no longer need a particular sort index you can improve the efficiency of the database by removing it (so that the database no longer has to maintain a list of rows in sorted order for that sort index) by calling <a href="SchemaDatabases.html#1001065"><code>DbRemoveSortIndex()</code></a>. Use the following functions to further manipulate the sort indices in a schema database:</p>

<dl>
<dt><a name="1025791"> </a><code><a href="SchemaDatabases.html#1000207"><code>DbNumSortIndexes()</code></a></code></dt>
<dd><a name="1025792"> </a>Get the number of sort indices defined for a given database. Within a database the defined sort indices have index values that range from 0 to one less than this number. Thus this function is particularly useful when iterating through a database's sort indices.</dd>

<dt><a name="1025796"> </a><code><a href="SchemaDatabases.html#999223"><code>DbGetSortDefinition()</code></a></code></dt>
<dd><a name="1025797"> </a>Get a sort index given its position in the list of sort indices defined for a database.</dd>

<dt><a name="1025801"> </a><code><a href="SchemaDatabases.html#999443"><code>DbHasSortIndex()</code></a></code></dt>
<dd><a name="1025802"> </a>Determine whether a particular sort index has been defined for a database. This function takes the same string that you supply when adding a sort index to a database or opening a cursor.</dd>

</dl>

<p><a name="1025803"> </a>When you no longer need a particular cursor, call <a href="SchemaDatabases.html#995544"><code>DbCursorClose()</code></a> to free all resources associated with the cursor.</p>

<p><a name="1025807"> </a>An application can temporarily suspend automatic sorting of the currently opened database by calling <a href="SchemaDatabases.html#997696"><code>DbEnableSorting()</code></a> with the <code class="par">enable</code> parameter set to <code>false</code>. This can be useful when doing a bulk update to the database, or during synchronization. Calling <code>DbEnableSorting()</code> with the <code class="par">enable</code> parameter set to <code>true</code> will re-enable automatic sorting and causes the indices to be re-sorted.</p>

<h4 class="hcH4">
  <a name="1025104"> </a>The WHERE Clause
</h4>

<p><a name="1025105"> </a>The Data Manager parses WHERE clauses and uses the information provided by applications to filter the set of rows returned as members of a cursor. For example, an application might request a cursor containing all rows where the value is greater then 42. </p>

<p><a name="1025106"> </a>The general format of the WHERE clause is:</p>

<div class="CodeRule"><hr></div><pre class="CodeBlock">
<i>column_name_or_ID</i> <i>operator</i> <i>value</i><a name="1025107"> </a>
</pre><div class="CodeRule"><hr></div>


<p><a name="1025108"> </a>In an SQL string the WHERE clauses must come after the table name and before an ORDER BY clause if one is provided. A simple example is "<code>table WHERE AGE &gt;= 42</code>"; the resulting cursor would only contain rows where the value of the column named "AGE" is greater than or equal to 42.</p>

<div><hr>
  <a name="1026576"> </a> <b>NOTE: </b> Although the general format of the WHERE clause indicates that you can use a column ID in place of the column name, this may not be supported in future releases. Developers should use column names when specifying a WHERE clause.
<hr>
</div>

<p><a name="1025109"> </a>Complex requests are supported by using the operators <code>AND</code> and <code>OR</code>. Both of these operators take WHERE clauses as their operands, allowing you to string requests together. <code>OR</code> has a lower operator precedence then <code>AND</code>, so all of the <code>AND</code> conditions are evaluated before the <code>OR</code> conditions. You can use parenthesis to group sub-clauses if operator precedence is an issue.</p>

<p><a name="1025110"> </a>The <code>PS_LIKE</code> operator allows applications to perform sub-string matching. The operand is compared with the value in the requested column using the <code>TxtFindString()</code> function. Positive matches are added to the cursor, while non-matches are not.</p>

<p><a name="1025111"> </a>The <code>IS NULL</code> and <code>IS NOT NULL</code> operators allow you to determine if a column has a value or is <code>NULL</code>. A <code>NULL</code> column value represents a lack of any value for a column. These operators may be used on all column types.</p>

<p><a name="1025115"> </a><a href="FilesAndDatabases.html#1025122">Table 2.7</a> lists the supported operators and the column types they can be used with.</p>

<p class="caption"><a name="1025122"> </a><b>Table 2.7&nbsp;&nbsp;WHERE clause operators </b></p>
<div class="tablediv"><table cellspacing="0" class="tTable">

  <tr valign="top">
    <th><p class="tt"><a name="1025128"> </a><b>Operator</b></p>
    </th>
    <th><p class="tt"><a name="1025130"> </a><b>Name</b></p>
    </th>
    <th><p class="tt"><a name="1025132"> </a><b>Supported Operand Types</b></p>
    </th>
  </tr>
  <tr valign="top">
    <td><p class="tt"><a name="1025134"> </a><code>=</code></p>
    </td>
    <td><p class="tt"><a name="1025136"> </a>Equal to</p>
    </td>
    <td><p class="tt"><a name="1025138"> </a><code>dbBoolean, dbUInt32, dbInt32, dbUInt16, dbInt16, dbUInt8, dbInt8, dbDateTimeSecs, dbVarChar</code></p>
    </td>
  </tr>
  <tr valign="top">
    <td><p class="tt"><a name="1025140"> </a><code>&lt;&gt;</code></p>
    </td>
    <td><p class="tt"><a name="1025142"> </a>Not equal to</p>
    </td>
    <td><p class="tt"><a name="1025144"> </a><code>dbBoolean, dbUInt32, dbInt32, dbUInt16, dbInt16, dbUInt8, dbInt8, dbDateTimeSecs, dbVarChar</code></p>
    </td>
  </tr>
  <tr valign="top">
    <td><p class="tt"><a name="1025146"> </a><code>&lt;</code></p>
    </td>
    <td><p class="tt"><a name="1025148"> </a>Less than</p>
    </td>
    <td><p class="tt"><a name="1025150"> </a><code>dbUInt32, dbInt32, dbUInt16, dbInt16, dbUInt8, dbInt8, dbDateTimeSecs, dbVarChar</code></p>
    </td>
  </tr>
  <tr valign="top">
    <td><p class="tt"><a name="1025152"> </a><code>&lt;=</code></p>
    </td>
    <td><p class="tt"><a name="1025154"> </a>Less than or equal to</p>
    </td>
    <td><p class="tt"><a name="1025156"> </a><code>dbUInt32, dbInt32, dbUInt16, dbInt16, dbUInt8, dbInt8, dbDateTimeSecs, dbVarChar</code></p>
    </td>
  </tr>
  <tr valign="top">
    <td><p class="tt"><a name="1025158"> </a><code>&gt;</code></p>
    </td>
    <td><p class="tt"><a name="1025160"> </a>Greater than</p>
    </td>
    <td><p class="tt"><a name="1025162"> </a><code>dbUInt32, dbInt32, dbUInt16, dbInt16, dbUInt8, dbInt8, dbDateTimeSecs, dbVarChar</code></p>
    </td>
  </tr>
  <tr valign="top">
    <td><p class="tt"><a name="1025164"> </a><code>&gt;=</code></p>
    </td>
    <td><p class="tt"><a name="1025166"> </a>Greater than or equal to</p>
    </td>
    <td><p class="tt"><a name="1025168"> </a><code>dbUInt32, dbInt32, dbUInt16, dbInt16, dbUInt8, dbInt8, dbDateTimeSecs, dbVarChar</code></p>
    </td>
  </tr>
  <tr valign="top">
    <td><p class="tt"><a name="1025170"> </a><code>PS_LIKE</code></p>
    </td>
    <td><p class="tt"><a name="1025172"> </a>PalmSource Like</p>
    </td>
    <td><p class="tt"><a name="1025174"> </a><code>dbVarChar</code></p>
    </td>
  </tr>
  <tr valign="top">
    <td><p class="tt"><a name="1025176"> </a><code>AND</code></p>
    </td>
    <td><p class="tt"><a name="1025178"> </a>And</p>
    </td>
    <td><p class="tt"><a name="1025180"> </a>Other WHERE clauses</p>
    </td>
  </tr>
  <tr valign="top">
    <td><p class="tt"><a name="1025182"> </a><code>OR</code></p>
    </td>
    <td><p class="tt"><a name="1025184"> </a>Or</p>
    </td>
    <td><p class="tt"><a name="1025186"> </a>Other WHERE clauses</p>
    </td>
  </tr>
  <tr valign="top">
    <td><p class="tt"><a name="1025188"> </a><code>IS NULL</code></p>
    </td>
    <td><p class="tt"><a name="1025190"> </a>Is NULL</p>
    </td>
    <td><p class="tt"><a name="1025192"> </a>All</p>
    </td>
  </tr>
  <tr valign="top">
    <td><p class="tt"><a name="1025194"> </a><code>IS NOT NULL</code></p>
    </td>
    <td><p class="tt"><a name="1025196"> </a>Is not NULL</p>
    </td>
    <td><p class="tt"><a name="1025198"> </a>All</p>
    </td>
  </tr>
</table>

</div>


<h4 class="hcH4">
  <a name="1015718"> </a>Moving Through the Rows in a Cursor
</h4>

<p><a name="1015205"> </a>When you create a cursor, the Data Manager takes a snapshot of the cursor's row IDs. This snapshot is used for iterating rows and is not affected by sorting updates. This is important to note, since operations that affect the number and order of rows in a database table won't affect the cursor contents until you explicitly refresh the cursor with <a href="SchemaDatabases.html#997499"><code>DbCursorRequery()</code></a>.</p>

<p><a name="1015757"> </a>Cursors have a concept of a current row. When you open a cursor the current row is initially positioned at the first row. <a href="SchemaDatabases.html#996209"><code>DbCursorMove()</code></a> alters that current position: it can be used in a variety of ways. For convenience, the Data Manager includes a set of macros that simplify the process of altering the current row position:</p>

<dl>
<dt><a name="1015821"> </a><code><a href="SchemaDatabases.html#996259"><code>DbCursorMoveFirst()</code></a></code></dt>
<dd><a name="1015760"> </a>Moves the current row position to the first row in the cursor. </dd>

<dt><a name="1015832"> </a><code><a href="SchemaDatabases.html#996551"><code>DbCursorMoveLast()</code></a></code></dt>
<dd><a name="1015843"> </a>Moves the current row position to the last row in the cursor.</dd>

<dt><a name="1015859"> </a><code><a href="SchemaDatabases.html#996593"><code>DbCursorMoveNext()</code></a></code></dt>
<dd><a name="1018620"> </a>Moves the current row position one row forward.</dd>

<dt><a name="1018624"> </a><code><a href="SchemaDatabases.html#996663"><code>DbCursorMovePrev()</code></a></code></dt>
<dd><a name="1015847"> </a>Moves the current row position one row backward.</dd>

<dt><a name="1015969"> </a><code><a href="SchemaDatabases.html#996779"><code>DbCursorMoveToRowID()</code></a></code></dt>
<dd><a name="1015222"> </a>Move the current row position to the row with the specified ID.</dd>

<dt><a name="1015991"> </a><code><a href="SchemaDatabases.html#997541"><code>DbCursorSetAbsolutePosition()</code></a></code></dt>
<dd><a name="1015995"> </a>Moves the current row position to the row with the specified index.</dd>

</dl>

<div><hr>
  <a name="1017221"> </a> <b>IMPORTANT: </b> The first row in a cursor has an index value (position) of 1, similar to ODBC and JDBC. This differs from other aspects of schema database programming: the first column in a table has an index value of zero, and the first table in a database also has an index value of zero.
<hr>
</div>

<p><a name="1016279"> </a>These macros, plus the fact that an error code is returned if you attempt to move beyond the bounds of the cursor, make it simple to iterate through a cursor's rows. See <a href="FilesAndDatabases.html#1024066">Listing 2.7</a> for an example of how to do this.</p>
<p class="CCodeCaption">
  <a name="1024066"> </a><b>Listing 2.7&nbsp;&nbsp;Iterating through a cursor's rows</b>
</p>

<div class="CodeRule"><hr></div><pre class="CodeBlock">
status_t err;<a name="1016311"> </a>
<a name="1026032"> </a>
err = DbCursorMoveFirst(myCursor);<a name="1016360"> </a>
if(err == errNone){<a name="1026054"> </a>
   while(!DbCursorIsEOF(myCursor)){<a name="1026059"> </a>
      // do something with the row data here, using the<a name="1026243"> </a>
      // cursor to indicate the current row. Like this:<a name="1026246"> </a>
      DbCopyColumnValue(dbRef, myCursor, ...);<a name="1026149"> </a>
<a name="1026158"> </a>
      DbCursorMoveNext(myCursor);<a name="1026159"> </a>
   }<a name="1026126"> </a>
}<a name="1026160"> </a>
</pre><div class="CodeRule"><hr></div>


<p><a name="1015237"> </a>Because the various Data Manager functions that accept a row ID also accept a cursor ID, you needn't obtain the row ID of the current cursor row. As shown in the above example, just supply the cursor ID when calling a function such as <code>DbCopyColumnValue()</code>.</p>

<p><a name="1016492"> </a>Rows that have been modified are not moved to their new sort position until <a href="SchemaDatabases.html#997499"><code>DbCursorRequery()</code></a> is called. Similarly, any newly-added rows are not available to the cursor until <code>DbCursorRequery()</code> is called. By calling <code>DbCursorRequery()</code>, you can refresh the cursor at any time to reflect the latest changes and sorting. Note that when a refresh occurs the current row may move to a new position and future move operations will move from the new position, not the old position. For example, if you change the data in the current row such that the row would wind up at the end of the cursor, and you then call <code>DbCursorRequery()</code>, a subsequent call to <a href="SchemaDatabases.html#996593"><code>DbCursorMoveNext()</code></a> will result in a <code>dmErrCursorEOF</code> error.</p>

<h4 class="hcH4">
  <a name="1015241"> </a>Data Variable Binding
</h4>

<p><a name="1015242"> </a>Cursors allow you to bind variables to columns of the schema. When a variable is bound to a column, that variable is automatically updated with the field value of the current row in the cursor whenever the cursor's current position is changed. You needn't call <a href="SchemaDatabases.html#998959"><code>DbGetColumnValues()</code></a>; the data is automatically copied to the bound variables for you.</p>

<p><a name="1015249"> </a>When calling <a href="SchemaDatabases.html#995395"><code>DbCursorBindData()</code></a> (or <a href="SchemaDatabases.html#995478"><code>DbCursorBindDataWithOffset()</code></a>), you must specify the ID of the column to which the variable is to be bound, a pointer to a data buffer (the bound variable), the length of that buffer, a pointer to a separate variable to hold the size of the data returned in the data buffer if the column type is one that has varying length, and a pointer to a variable that will receive an error code that is set each time the variable is updated. The error code will be set to <code>errNone</code> if the data is copied to the bound variable successfully, to <code>dmErrNoColumnData</code> if the column contains no data, or to some other value if an error of a different sort occurred.</p>

<p><a name="1015260"> </a>The <a href="SchemaDatabases.html#995478"><code>DbCursorBindDataWithOffset()</code></a> function is similar to <code>DbCursorBindData()</code> but adds an extra parameter that lets you specify a byte offset into the field's data. The data copied to the variable is taken from the database field at the specified offset. This allows you to bind a subset of the field data to a variable.</p>

<p><a name="1015261"> </a>You need to call <code>DbCursorBindData()</code> (or <code>DbCursorBindDataWithOffset()</code>) once for each column that you want to automatically retrieve or set data. It is not necessary to bind every column in the schema; only bind those that you are interested in. See <a href="FilesAndDatabases.html#1015262">Listing 2.8</a> for an example of how to use data variable binding.</p>
<p class="CCodeCaption">
  <a name="1015262"> </a><b>Listing 2.8&nbsp;&nbsp;Data variable binding example</b>
</p>

<div class="CodeRule"><hr></div><pre class="CodeBlock">
uint32_t cursor;<a name="1015263"> </a>
char name[32];<a name="1015265"> </a>
char phone[24];<a name="1015266"> </a>
uint32_t sizeName;<a name="1015267"> </a>
uint32_t sizePhone;<a name="1015268"> </a>
status_t errName;<a name="1015269"> </a>
status_t errPhone;<a name="1015270"> </a>
<a name="1015271"> </a>
dbRef = DbOpenDatabase(dbID, dmModeReadWrite, dbShareNone,
   idSortByName);<a name="1015272"> </a>
<a name="1015273"> </a>
// Create the cursor<a name="1015274"> </a>
err = DbCursorOpen(dbRef, selectString, 0, &amp;cursor);<a name="1015275"> </a>
<a name="1015276"> </a>
// Bind the local variables to columns<a name="1015277"> </a>
DbCursorBindData(cursor, idColName, name, 32, &amp;sizeName, 
&amp;errName);<a name="1015278"> </a>
DbCursorBindData(cursor, idColPhone, phone, 24, &amp;sizePhone,
   &amp;errPhone);<a name="1015279"> </a>
<a name="1015280"> </a>
// Read and display all rows in the cursor<a name="1015281"> </a>
err = DbCursorMoveFirst(cursor);<a name="1015282"> </a>
while (err == errNone){<a name="1015283"> </a>
   // Data is now in bound variables, so display it<a name="1015284"> </a>
   DisplayNameAndPhone(name, sizeName, phone, sizePhone);	<a name="1015285"> </a>
<a name="1015286"> </a>
   // Get data for next row<a name="1015287"> </a>
   err = DbCursorMoveNext(cursor);<a name="1015288"> </a>
}<a name="1015289"> </a>
<a name="1015290"> </a>
// Change the field values in the 5th row in cursor<a name="1015291"> </a>
DbCursorMoveTo(cursor, 4);<a name="1015292"> </a>
strcpy(name, "John Doe");<a name="1015293"> </a>
sizeName = strlen(name);<a name="1015294"> </a>
strcpy(phone, "555-1234");<a name="1015295"> </a>
sizePhone = strlen(phone);<a name="1015296"> </a>
err = DbCursorUpdate(cursor);<a name="1015297"> </a>
<a name="1015298"> </a>
DbCursorClose(cursor);<a name="1015299"> </a>
</pre><div class="CodeRule"><hr></div>


<p><a name="1017453"> </a>Variable binding can also be used to write data to the database. Simply set each bound variable to its desired value, then call <a href="SchemaDatabases.html#997608"><code>DbCursorUpdate()</code></a>. All values are written to the database for the current row. Note that for varying-length types (<code>dbVarChar</code> and d<code>bBlob</code>) you should also set the corresponding <code>dataSize</code> variable&#8212;specified when you bound the variable to the schema column&#8212;to indicate the size of the data to be written back to that field.</p>

<div><hr>
  <a name="1017471"> </a> <b>NOTE: </b> You must call <code>DbCursorUpdate()</code> each time you wish to update a schema database row with the contents of its bound variables. Changing the cursor's current position transfers data from the row to the bound variables; it doesn't automatically transfer data from the bound variables to the row's fields.
<hr>
</div>
<h3 class="hbH3">
  <a name="993997"> </a>Secure Databases <a href="#608590"><span class="nav">^TOP^</span></a>
</h3>


<p><a name="994008"> </a>Some applications need to create secure databases that restrict access to the database. The Data Manager supports the creation of secure databases that are protected by application-defined access rules, which are also known as <b>rule sets</b>. </p>

<p><a name="994009"> </a>To create a secure database, use <a href="SchemaDatabases.html#995225"><code>DbCreateSecureDatabase()</code></a>. When a secure database is initially created, it is completely protected and cannot be opened until access rules allowing read or write access have been defined for the database. <code>DbCreateSecureDatabase()</code> returns an initial rule set for the newly-created secure database. The initial rule set contains only one rule that allows the calling application, and no other, to modify the database's access rules. This is known as <b>modify access</b>.</p>

<p><a name="994010"> </a>There are six different actions that can be used in access rules:</p>

<dl>
<dt><a name="1004531"> </a><code>dbActionRead</code></dt>
<dt><a name="1004533"> </a><code>dbActionWrite</code></dt>
<dt><a name="1004535"> </a><code>dbActionDelete</code></dt>
<dt><a name="1004537"> </a><code>dbActionSchemaEdit</code></dt>
<dt><a name="1004539"> </a><code>dbActionBackup</code></dt>
<dt><a name="1004552"> </a><code>dbActionRestore</code></dt>
</dl>

<p><a name="1004553"> </a>Access rules can require a digital signature, require a password, require a PIN, or allow unrestricted access. You can define different access rules for each of the different actions defined by the Data Manager. For example, a secure database could be configured to allow read access to anyone, but require a password for all other access. Creating access rules that require digital signatures provides for databases that can only be accessed by applications that have the correct digital signature. For more information about access rules, see <i>Exploring Palm OS: Security and Cryptography</i>.</p>

<p><a name="994011"> </a>Security is maintained at the database level, not for each individual row. All rows in the database have the same level of security. There is no way to assign different levels of security for different rows in the same database.</p>

<p><a name="994012"> </a>Secure databases are only visible to the Data Manager process. They are stored in the Data Manager's private secure storage heap, separate from unsecured databases. Applications can use the Data Manager catalog functions, such as <a href="DataMgr.html#1077521"><code>DmFindDatabase()</code></a>, to determine if the secure database exists. But the database data is not available to an application until the application, the user, or both have been authorized. </p>

<p><a name="994013"> </a>When an application requests access to a secure database, the Data Manager first calls the Authorization Manager to verify that the current user and/or application has rights to access the database. If the Authorization Manager approves access to the secure database, the Data Manager copies the requested rows to the application process as needed. For read operations the database data is copied from the Data Manager's private secure storage heap to the application's dynamic heap. Note since the data is copied to the application's dynamic heap, the data is writable. Even though it is writable, the application must still call the appropriate Data Manager write functions to update the data. Writing directly to the copy of the data in the dynamic heap has no effect on the row data in the database.</p>

<p><a name="994014"> </a>The Data Manager requires <code>dbActionRead</code> authorization when using the following functions on a secure database:</p>
<ul type="disc">
  <li><a name="994015"> </a><code>DbOpenDatabase()</code> with read-only mode
  <li><a name="994016"> </a><code>DbOpenDatabaseByTypeCreator()</code> with read-only mode
</ul>

<p><a name="994017"> </a>The Data Manager requires <code>dbActionWrite</code> authorization when using the following functions on a secure database:</p>
<ul type="disc">
  <li><a name="994018"> </a><code>DbOpenDatabase()</code> with write-only mode or read-write mode
  <li><a name="994019"> </a><code>DbOpenDatabaseByTypeCreator()</code> with write-only mode or read-write mode
  <li><a name="994020"> </a><code>DmSetDatabaseInfo()</code> 
  <li><a name="994021"> </a><code>DmSetDatabaseProtection()</code> 
</ul>

<p><a name="994022"> </a>The Data Manager requires <code>dbActionDelete</code> authorization when using the following functions on a secure database:</p>
<ul type="disc">
  <li><a name="994023"> </a><code>DmDeleteDatabase()</code> 
</ul>

<p><a name="994024"> </a>The Data Manager requires <code>dbActionSchemaEdit</code> authorization when using following APIs on a secure database:</p>
<ul type="disc">
  <li><a name="994025"> </a><code>DbAddSchema()</code> 
  <li><a name="994026"> </a><code>DbAddColumn()</code> 
  <li><a name="994027"> </a><code>DbRemoveSchema()</code> 
  <li><a name="994028"> </a><code>DbRemoveColumn()</code> 
  <li><a name="994029"> </a><code>DbSetColumnPropertyValue()</code> 
  <li><a name="994030"> </a><code>DbSetColumnPropertyValues()</code> 
  <li><a name="994031"> </a><code>DbRemoveColumnProperty()</code> 
</ul>

<p><a name="994032"> </a>The Data Manager requires <code>dbActionBackup</code> authorization when using the following functions on a secure database:</p>
<ul type="disc">
  <li><a name="994033"> </a><code>DmBackupInitialize()</code> 
  <li><a name="994034"> </a><code>DmBackupUpdate()</code> 
  <li><a name="994035"> </a><code>DmBackupFinalize()</code> 
</ul>

<p><a name="994036"> </a>The Data Manager requires <code>dbActionRestore</code> authorization when using the following functions on a secure database:</p>
<ul type="disc">
  <li><a name="994037"> </a><code>DmRestoreInitialize()</code> 
  <li><a name="994038"> </a><code>DmRestoreUpdate()</code> 
  <li><a name="994039"> </a><code>DmRestoreFinalize()</code> 
</ul>

<p><a name="994040"> </a>All other Data Manager functions do not require authorization when used on a secure database, because they either require a previous open call before they can be used, or they do not perform an operation that necessitates authorization.</p>

<p><a name="994041"> </a>Once a secure database has been successfully authorized and opened, the Data Manager places a special key in the calling application's process that indicates that the process has been authorized to use the database. All Data Manager functions that take a <a href="DataMgr.html#993643"><code>DmOpenRef</code></a> as a parameter use this special key as proof that the application is allowed access. This allows the Data Manager to detect forged <code>DmOpenRef</code>s without needing to call the Authorization Manager for every function. The key is revoked when the database is closed.</p>

<p><a name="994042"> </a>The Data Manager also provides a function, <a href="SchemaDatabases.html#999138"><code>DbGetRuleSet()</code></a>, that allows an application to get the current rule set for a secure database. Once the rule set is obtained, the application can modify the access rules for the secure database&#8212;provided that the application has modify access. Once a secure database is open, any change in the access rules do not apply until the database is reopened.</p>

<p><a name="994043"> </a>Note that the Data Manager does not provide functions for creating or modifying the access rules, only functions for creating secure databases. Your application must use functions provided by the Authorization Manager and the Authentication Manager to define the access rules for a secure database.</p>

<h4 class="hcH4">
  <a name="994046"> </a>Secure Databases and HotSync Operations
</h4>

<p><a name="1004816"> </a>The Data Manager restricts access to a secure database to only those applications and users authorized by the database's access rules. During a sync operation the HotSync<sup>&#174;</sup> client on the handheld uses Data Manager functions to access the handheld databases on behalf of the conduits running on the desktop. The HotSync client application must be able to access secure databases that need to be synchronized or backed up. </p>

<p><a name="1004846"> </a>In order for an application to ensure that its secure database is syncable, it must modify the database access rules so that the HotSync client has special "bypass" access using the <code>AzmLibSetBypass()</code> function. When the HotSync client is given bypass access, any conduit on the desktop is able to access the database (the HotSync process does not provide a way to restrict access on a per-conduit basis). The bypass access must be made for each action needed. Since you can grant the HotSync client bypass access for each action separately, you can, for example, give the HotSync client read access, but not write or delete access.</p>

<p><a name="994049"> </a>If the HotSync client is not given bypass access, it is subject to the normal access rules as defined by the application. For example, if an application defines the access rules for its database so that only signed applications have access (read, write, or delete), during a HotSync operation the database isn't syncable since the HotSync client doesn't have the proper signature required to access the data. Therefore to allow syncing of the database the application must give "bypass" access to the HotSync client, which essentially grants access both to the HotSync client and to any properly-signed application.</p>

<p><a name="994050"> </a>The HotSync client on the handheld maintains a notion of trusted desktops. The HotSync process doesn't allow syncing or backing up of secure databases to non-trusted desktops.</p>

<h4 class="hcH4">
  <a name="994051"> </a>Backing up Secure Databases
</h4>

<p><a name="994052"> </a>When a secure database is backed up to the desktop it is sent to the desktop in encrypted form and is saved on the desktop encrypted. During a backup operation the Data Manager encrypts the data. This differs from a sync operation; when data is sent to the desktop during synchronization it is sent "in the clear"&#8212;it is not encrypted.</p>

<p><a name="994053"> </a>Secure databases that were encrypted during backup can only be decrypted and restored by the Data Manager. The Data Manager provides special functions to perform the backup and restore operations: you use a combination of <a href="DataMgr.html#995549"><code>DmBackupInitialize()</code></a>, <a href="DataMgr.html#995634"><code>DmBackupUpdate()</code></a>, and <a href="DataMgr.html#995503"><code>DmBackupFinalize()</code></a> to back the database up, and <a href="DataMgr.html#1005732"><code>DmRestoreInitialize()</code></a>, <a href="DataMgr.html#1005778"><code>DmRestoreUpdate()</code></a>, and <a href="DataMgr.html#1005674"><code>DmRestoreFinalize()</code></a> to restore the data. Note that these backup and restore functions work with both secure and non-secure databases. </p>
<h3 class="hbH3">
  <a name="995524"> </a>Concurrent Database Access <a href="#608590"><span class="nav">^TOP^</span></a>
</h3>


<p><a name="995525"> </a>When you open a non-schema database with write access, you have exclusive access to that database: no one else can open that database while you have it open, even if they are just opening it with read access. Or, when you open a non-schema database with read access, no one else can open that same database with write access. This can be somewhat restrictive: on a communicator-style device, for example, if you are editing a record in the address book when the phone rings, the phone application running in another process couldn't open the address book in order to perform a caller-ID lookup.</p>

<p><a name="1005298"> </a>Schema databases don't have this problem because they support concurrent access to a single database. Note that schema databases don't support concurrent write access: only one writer and multiple readers are allowed.</p>

<p><a name="995528"> </a>When opening a schema database you specify a <b>share mode</b> in addition to an access mode. The following share mode constants are supported for schema databases. Only one share mode can be specified when opening a database.</p>

<dl>
<dt><a name="995529"> </a><code>dbShareNone</code></dt>
<dd><a name="997554"> </a>No one else can open this database.</dd>

<dt><a name="995530"> </a><code>dbShareRead</code></dt>
<dd><a name="997557"> </a>Others can open this database with read access.</dd>

<dt><a name="995531"> </a><code>dbShareReadWrite</code></dt>
<dd><a name="997559"> </a>Others can open this database with read or write access.</dd>

</dl>

<p><a name="995532"> </a>Concurrent write access to the same database is not supported. That is, specifying an access mode of <code>dmModeReadWrite</code> and a share mode of <code>dbShareReadWrite</code> is not supported; an error will be returned if you attempt to open a database with this combination of access and share modes. </p>

<p><a name="995533"> </a><a href="FilesAndDatabases.html#998016">Table 2.8</a>, below, shows all of the allowed combinations of access modes and share modes, and identifies which combinations can be used together (those that are marked "OK").</p>

<p class="caption"><a name="998016"> </a><b>Table 2.8&nbsp;&nbsp;Allowable concurrent access/share mode combinations</b></p>
<div class="tablediv"><table cellspacing="0" class="tTable">

  <tr valign="top">
    <td><p class="tt"><a name="998028"> </a></p>
    </td>
    <td><p class="tt"><a name="998110"> </a><b>Mode=R<br>Share=None</b></p>
    </td>
    <td><p class="tt"><a name="998032"> </a>Mode=R<br>Share=R</p>
    </td>
    <td><p class="tt"><a name="998034"> </a>Mode=R<br>Share=R/W</p>
    </td>
    <td><p class="tt"><a name="998036"> </a>Mode=R/W<br>Share=None</p>
    </td>
    <td><p class="tt"><a name="998038"> </a>Mode=R/W<br>Share=R</p>
    </td>
  </tr>
  <tr valign="top">
    <td><p class="tt"><a name="998040"> </a><b>Mode=R<br>Share=None</b></p>
    </td>
    <td><p class="tt"><a name="998042"> </a>sharing not allowed</p>
    </td>
    <td><p class="tt"><a name="1028656"> </a>sharing not allowed</p>
    </td>
    <td><p class="tt"><a name="1028658"> </a>sharing not allowed</p>
    </td>
    <td><p class="tt"><a name="1028660"> </a>sharing not allowed</p>
    </td>
    <td><p class="tt"><a name="1028662"> </a>sharing not allowed</p>
    </td>
  </tr>
  <tr valign="top">
    <td><p class="tt"><a name="998052"> </a>Mode=R<br>Share=R</p>
    </td>
    <td><p class="tt"><a name="1028664"> </a>sharing not allowed</p>
    </td>
    <td><p class="tt"><a name="998056"> </a>OK</p>
    </td>
    <td><p class="tt"><a name="998058"> </a>OK</p>
    </td>
    <td><p class="tt"><a name="1028682"> </a>sharing not allowed</p>
    </td>
    <td><p class="tt"><a name="1028686"> </a>sharing not allowed</p>
    </td>
  </tr>
  <tr valign="top">
    <td><p class="tt"><a name="998064"> </a>Mode=R<br>Share=R/W</p>
    </td>
    <td><p class="tt"><a name="1028666"> </a>sharing not allowed</p>
    </td>
    <td><p class="tt"><a name="998068"> </a>OK</p>
    </td>
    <td><p class="tt"><a name="998070"> </a>OK</p>
    </td>
    <td><p class="tt"><a name="1028684"> </a>sharing not allowed</p>
    </td>
    <td><p class="tt"><a name="998074"> </a>OK</p>
    </td>
  </tr>
  <tr valign="top">
    <td><p class="tt"><a name="998076"> </a>Mode=R/W<br>Share=None</p>
    </td>
    <td><p class="tt"><a name="1028668"> </a>sharing not allowed</p>
    </td>
    <td><p class="tt"><a name="1028672"> </a>sharing not allowed</p>
    </td>
    <td><p class="tt"><a name="1028676"> </a>sharing not allowed</p>
    </td>
    <td><p class="tt"><a name="1028678"> </a>sharing not allowed</p>
    </td>
    <td><p class="tt"><a name="1028680"> </a>sharing not allowed</p>
    </td>
  </tr>
  <tr valign="top">
    <td><p class="tt"><a name="998088"> </a>Mode=R/W<br>Share=R</p>
    </td>
    <td><p class="tt"><a name="1028670"> </a>sharing not allowed</p>
    </td>
    <td><p class="tt"><a name="1028674"> </a>sharing not allowed</p>
    </td>
    <td><p class="tt"><a name="998094"> </a>OK</p>
    </td>
    <td><p class="tt"><a name="1028688"> </a>sharing not allowed</p>
    </td>
    <td><p class="tt"><a name="1028690"> </a>sharing not allowed</p>
    </td>
  </tr>
</table>

</div>


<p><a name="995556"> </a>When sharing is enabled (that is, when the database is opened with shared read or shared read/write), the Data Manager server synchronizes access to the database. The synchronization is done at the database level. Each schema database function call is atomic, thus providing data integrity at the function level. Since the Data Manager doesn't support multiple applications writing to the same database, it doesn't have to deal with issues around concurrent updates.</p>

<p><a name="1005489"> </a>As discussed in <a href="FilesAndDatabases.html#1016939">"Reading Data,"</a> you can access record values by copy or by reference. When using the "by reference" functions to read record values from a database opened with shared write access, the Data Manager maintains a reference count of the number of active readers for each row. Applications can only modify a row if its reference count is 0&#8212;that is, if no one is currently reading that row. This protects the row against concurrent updates.</p>

<p><a name="1026499"> </a>Whenever a schema database row is modified, added, deleted, or removed, the row index and any sort indices are automatically updated. This can only be done when the database is opened with write access. If another process has concurrently opened the same database with read access, however, it too will be affected by the changes to the sort indices. This is not a problem, however, since cursor shield the application from changes like this.</p>

<h2 class="haH2">
  <a name="1026501"> </a>Working with Non-Schema Databases <a href="#608590"><span class="nav">^TOP^</span></a>
</h2>


<p><a name="1018463"> </a>Schema databases impose a structure upon the data, organizing it into tables, rows, and columns. Non-schema databases, on the other hand, impose less overhead and are significantly more flexible. Of course, your application generally has to do more work when dealing with non-schema databases, since your application is entirely responsible for interpreting the structure of each record.</p>

<p><a name="1018466"> </a>Non-schema databases can either be record or resource databases. A <b>record database</b> holds application data. Each record can be structured in any fashion that the application desires. <b>Resource databases</b> are used to contain executable code, application resources, and the like. </p>

<p><a name="1018322"> </a>In Palm OS Cobalt, non-schema databases come in two "flavors": classic and extended. Classic databases are provided for compatibility with previous versions of Palm OS (and with applications running on Palm OS Cobalt through PACE). Because of a couple of long-standing limitations, however, unless your application needs this level of compatibility it should use extended or schema databases instead. Both classic and extended databases can be either record or resource databases.</p>

<p><a name="1018338"> </a>Extended databases are very similar to classic databases. They have the following differences:</p>


<div class="tablediv"><table cellspacing="0" class="tTable">

  <tr valign="top">
    <th><p class="tt"><a name="1018345"> </a><b>Classic Database</b></p>
    </th>
    <th><p class="tt"><a name="1018347"> </a><b>Extended Database</b></p>
    </th>
  </tr>
  <tr valign="top">
    <td><p class="tt"><a name="1018349"> </a>Records cannot exceed 64 KB in size. </p>
    </td>
    <td><p class="tt"><a name="1018351"> </a>Records can be more than 64 KB in length.</p>
    </td>
  </tr>
  <tr valign="top">
    <td><p class="tt"><a name="1018353"> </a>Are uniquely identified by name.</p>
    </td>
    <td><p class="tt"><a name="1018355"> </a>Are uniquely identified by a combination of name and creator ID.</p>
    </td>
  </tr>
  <tr valign="top">
    <td><p class="tt"><a name="1018388"> </a>Data should be stored in big-endian format (for 68K compatibility).</p>
    </td>
    <td><p class="tt"><a name="1018390"> </a>Data can be stored in either big-endian or little-endian format.</p>
    </td>
  </tr>
</table>

</div>


<p><a name="1018418"> </a>Because the two non-schema database types are so similar, you use many of the same functions when working with either database type. One of the most important functions that works only on extended databases is <a href="DataMgr.html#995780"><code>DmCreateDatabase()</code></a>. To create a classic database, you use <a href="DataMgr.html#995926"><code>DmCreateDatabaseV50()</code></a> instead. Other functions behave differently depending on whether you are operating on a classic or an extended database, and still others&#8212;such as <a href="DataMgr.html#1077521"><code>DmFindDatabase()</code></a>&#8212;use parameters to control their behavior in this area.</p>
<h3 class="hbH3">
  <a name="1007421"> </a>Structure of a Non-Schema Database Header <a href="#608590"><span class="nav">^TOP^</span></a>
</h3>


<p><a name="1007422"> </a>A non-schema database header consists of some basic database information and a list of records in the database. Each record entry in the header has the MemHandle of the record, 8 attribute bits, and a 3-byte unique ID for the record. </p>

<p><a name="1007424"> </a>This section provides information about database headers, discussing these topics:</p>
<ul type="disc">
  <li><a name="1007428"> </a><a href="FilesAndDatabases.html#1007435">Database Header Fields</a> 
  <li><a name="1007432"> </a><a href="FilesAndDatabases.html#1007475">Structure of a Record Entry in a Non-Schema Database Header</a> 
</ul>

<div><hr>
  <a name="1007433"> </a> <b>IMPORTANT: </b> Expect the database header structure to change in the future. Use the API to work with database structures.
<hr>
</div>

<h4 class="hcH4">
  <a name="1007435"> </a>Database Header Fields
</h4>

<p><a name="1007437"> </a>The database header has the following fields: </p>
<ul type="disc">
  <li><a name="1007438"> </a>The <code>name</code> field holds the name of the database. 
  <li><a name="1007439"> </a>The <code>attributes</code> field has flags for the database. 
  <li><a name="1007440"> </a>The <code>version</code> field holds an application-specific version number for that database. 
  <li><a name="1007441"> </a>The <code>modificationNumber</code> is incremented every time a record in the database is deleted, added, or modified. Thus applications can quickly determine if a shared database has been modified by another process. 
  <li><a name="1007442"> </a>The <code>appInfoID</code> is an optional field that an application can use to store application-specific information about the database. For example, it might be used to store user display preferences for a particular database. 
  <li><a name="1007443"> </a>The <code>sortInfoID</code> is another optional field an application can use for storing the ID of a sort table for the database. 
  <li><a name="1007444"> </a>The <code>type</code> and <code>creator</code> fields are each 4 bytes and hold the database type and creator. The system uses these fields to distinguish application databases from data databases and to associate data databases with the appropriate application. 
  <li><a name="1007445"> </a>The <code>numRecords</code> field holds the number of record entries stored in the database header itself. If all the record entries cannot fit in the header, then <code>nextRecordList</code> identifies a <code>recordList</code> that contains the next set of records. 
   <p><a name="1007446"> </a>Each record entry stored in a record list has three fields and is 8 bytes in length. Each entry has the MemHandle of the record which takes up 4 bytes: 1 byte of attributes and a 3-byte unique ID for the record. The <code>attribute</code> field, shown in <a href="FilesAndDatabases.html#1007451">Figure 2.1</a>, is 8 bits long and contains 4 flags and a 4-bit category number. The category number is used to place records into user-defined categories like "business" or "personal." </p>
</ul>

<p class="FFigureCaption">
  <a name="1007451"> </a><b>Figure 2.1&nbsp;&nbsp;Record Attributes</b>
</p>
<div align="left"><img src="images/FilesAndDatabasesa.jpg" height="179" width="482" border="0" hspace="0" vspace="0">
</div>

<h4 class="hcH4">
  <a name="1007475"> </a>Structure of a Record Entry in a Non-Schema Database Header
</h4>

<p><a name="1007476"> </a>Each record entry has the MemHandle of the record, 8 attribute bits, and a 3-byte unique ID for the record. </p>

<p><a name="1007479"> </a>The unique ID must be unique for each record within a database. It remains the same for a particular record no matter how many times the record is modified. It is used during synchronization with the desktop to track records on the Palm Powered handheld with the same records on the desktop system.</p>

<p><a name="1007480"> </a>The record attribute bits are set in the following circumstances:</p>
<ul type="disc">
  <li><a name="1007481"> </a>When the user deletes or archives a record the <code>delete</code> bit is set. Note, however, that its entry in the database header remains until the next synchronization with the PC. 
  <li><a name="1007482"> </a>The <code>dirty</code> bit is set whenever a record is updated. 
  <li><a name="1007483"> </a>The <code>busy</code> bit is set when an application currently has a record locked for reading or writing.
  <li><a name="1007484"> </a>The <code>secret</code> bit is set for records that should not be displayed before the user password has been entered on the handheld.
</ul>

<p><a name="1007485"> </a>When a user "deletes" a record on a Palm Powered handheld, the record's data chunk is freed, the MemHandle stored in the record entry is set to 0, and the <code>delete</code> bit is set in the attributes. When the user archives a record, the deleted bit is also set but the chunk is not freed and the MemHandle is preserved. This way, the next time the user synchronizes with the desktop system, the desktop computer can quickly determine which records to delete (since their record entries are still around on the handheld). In the case of archived records, the conduit can save the record data on the desktop before it permanently removes the record entry and data from the handheld. For deleted records, the conduit just has to delete the same record from the desktop before permanently removing the record entry from the handheld.</p>
<h3 class="hbH3">
  <a name="993293"> </a>Working with Non-Schema Databases <a href="#608590"><span class="nav">^TOP^</span></a>
</h3>


<p><a name="1007497"> </a>Using the Data Manager is similar to using a traditional file manager, except that the data is broken down into multiple records instead of being stored in one contiguous chunk. To create or delete a database, call <a href="DataMgr.html#995780"><code>DmCreateDatabase()</code></a> (or, for classic databases, <a href="DataMgr.html#995926"><code>DmCreateDatabaseV50()</code></a>) and <a href="DataMgr.html#996663"><code>DmDeleteDatabase()</code></a>.</p>

<p><a name="993302"> </a>To open a database for reading or writing, you must first get the database ID. Calling <a href="DataMgr.html#1077521"><code>DmFindDatabase()</code></a> searches for a database by name and type (schema, extended, or classic) and returns its database ID.</p>

<p><a name="993311"> </a>After determining the database ID, you can open the database for read-only or read/write access. When you open a database, the system locks down the database header and returns a reference to a database access structure, which tracks information about the open database and caches certain information for optimum performance. The database access structure is a relatively small structure (less than 100 bytes) allocated in the dynamic heap that is disposed of when the database is closed.</p>

<p><a name="993320"> </a>Call <a href="DataMgr.html#996192"><code>DmDatabaseInfo()</code></a>, <a href="DataMgr.html#1006265"><code>DmSetDatabaseInfo()</code></a>, and <a href="DataMgr.html#996477"><code>DmDatabaseSize()</code></a> to query or set information about a database, such as its name, size, creation and modification dates, attributes, type, and creator. </p>

<p><a name="993337"> </a>Call <a href="DataMgr.html#1000166"><code>DmGetRecord()</code></a>, <a href="DataMgr.html#1004199"><code>DmQueryRecord()</code></a>, and <a href="DataMgr.html#1004479"><code>DmReleaseRecord()</code></a> when viewing or updating a database. </p>
<ul type="disc">
  <li><a name="993342"> </a><a href="DataMgr.html#1000166"><code>DmGetRecord()</code></a> takes a record index as a parameter, marks the record busy, and returns a handle to the record. If a record is already busy when <a href="DataMgr.html#1000166"><code>DmGetRecord()</code></a> is called, an error is returned. 
  <li><a name="993349"> </a><a href="DataMgr.html#1004199"><code>DmQueryRecord()</code></a> is faster if the application only needs to view the record; it doesn't check or set the busy bit, so it's not necessary to call <code>DmReleaseRecord()</code> when finished viewing the record. 
  <li><a name="993353"> </a><a href="DataMgr.html#1004479"><code>DmReleaseRecord()</code></a> clears the <code>busy</code> bit, and updates the modification number of the database and marks the record dirty if the <code>dirty</code> parameter is true.
</ul>

<p><a name="993354"> </a>To resize a record to grow or shrink its contents, call <a href="DataMgr.html#1005163"><code>DmResizeRecord()</code></a>. During reallocation, the handle to the record may change. <a href="DataMgr.html#1005163"><code>DmResizeRecord()</code></a> returns the new handle to the record.</p>

<p><a name="993365"> </a>To add a new record to a database, call <a href="DataMgr.html#1001785"><code>DmNewRecord()</code></a>. This function can insert the new record at any index position, append it to the end, or replace an existing record by index. It returns a handle to the new record. </p>

<p><a name="993366"> </a>There are three methods for removing a record: <code>DmRemoveRecord()</code>, <code>DmDeleteRecord()</code>, and <code>DmArchiveRecord()</code>.</p>
<ul type="disc">
  <li><a name="993370"> </a><a href="DataMgr.html#1004638"><code>DmRemoveRecord()</code></a> removes the record's entry from the database header and disposes of the record data. 
  <li><a name="993374"> </a><a href="DataMgr.html#996913"><code>DmDeleteRecord()</code></a> also disposes of the record data, but instead of removing the record's entry from the database header, it sets the deleted bit in the record entry attributes field and clears the local chunk ID. 
  <li><a name="993378"> </a><a href="DataMgr.html#995341"><code>DmArchiveRecord()</code></a> does not dispose of the record's data; it just sets the deleted bit in the record entry. 
</ul>

<p><a name="993379"> </a>Both <code>DmDeleteRecord()</code> and <code>DmArchiveRecord()</code> are useful for synchronizing information with a desktop computer. Since the unique ID of the deleted or archived record is still kept in the database header, the desktop computer can perform the necessary operations on its own copy of the database before permanently removing the record from the Palm OS database.</p>

<p><a name="993386"> </a>Call <a href="DataMgr.html#1000420"><code>DmGetRecordAttr()</code></a>, <a href="DataMgr.html#1000470"><code>DmGetRecordCategory()</code></a>, and <a href="DataMgr.html#1000600"><code>DmGetRecordID()</code></a> to retrieve the record information stored in the database header, and <a href="DataMgr.html#1006959"><code>DmSetRecordAttr()</code></a>, <a href="DataMgr.html#1007171"><code>DmSetRecordCategory()</code></a>, and <a href="DataMgr.html#1007227"><code>DmSetRecordID()</code></a> to set this information. Typically, applications set or retrieve the category of a record, which is stored in the lower four bits of the record's attribute field.</p>

<p><a name="993398"> </a>To move records from one index to another or from one database to another, call <a href="DataMgr.html#1133286"><code>DmMoveRecord()</code></a>, <a href="DataMgr.html#1208108"><code>DmAttachRecord()</code></a>, and <a href="DataMgr.html#997011"><code>DmDetachRecord()</code></a>. <code>DmDetachRecord()</code> removes a record entry from the database header and returns the record handle. Given the handle of a new record, <code>DmAttachRecord()</code> inserts or appends that new record to a database or replaces an existing record with the new record. <code>DmMoveRecord()</code> is an optimized way to move a record from one index to another in the same database.</p>
<h3 class="hbH3">
  <a name="1013859"> </a>Record Attributes <a href="#608590"><span class="nav">^TOP^</span></a>
</h3>


<p><a name="1013863"> </a><a href="FilesAndDatabases.html#1014001">Table 2.4</a> lists the functions that you use to get and set a non-schema database record's ID, category, and attributes.</p>

<p class="caption"><a name="1013953"> </a><b>Table 2.9&nbsp;&nbsp;Functions used to access record information </b></p>
<div class="tablediv"><table cellspacing="0" class="tTable">

  <tr valign="top">
    <th><p class="tt"><a name="1013957"> </a><b></b></p>
    </th>
    <th><p class="tt"><a name="1013959"> </a><b>Non-Schema Database</b></p>
    </th>
  </tr>
  <tr valign="top">
    <td><p class="tt"><a name="1013961"> </a>Local ID</p>
    </td>
    <td><p class="tt"><a name="1013966"> </a><a href="DataMgr.html#1000600"><code>DmGetRecordID()</code></a><br><a href="DataMgr.html#1007227"><code>DmSetRecordID()</code></a></p>
    </td>
  </tr>
  <tr valign="top">
    <td><p class="tt"><a name="1013971"> </a>Category Membership</p>
    </td>
    <td><p class="tt"><a name="1013976"> </a><a href="DataMgr.html#1000470"><code>DmGetRecordCategory()</code></a><br><a href="DataMgr.html#1007171"><code>DmSetRecordCategory()</code></a></p>
    </td>
  </tr>
  <tr valign="top">
    <td><p class="tt"><a name="1013981"> </a>Attributes</p>
    </td>
    <td><p class="tt"><a name="1013986"> </a><a href="DataMgr.html#1000420"><code>DmGetRecordAttr()</code></a><br><a href="DataMgr.html#1006959"><code>DmSetRecordAttr()</code></a></p>
    </td>
  </tr>
</table>

</div>

<h3 class="hbH3">
  <a name="993836"> </a>Resource Databases <a href="#608590"><span class="nav">^TOP^</span></a>
</h3>


<h4 class="hcH4">
  <a name="1007194"> </a>Structure of a Resource Database Header
</h4>

<p><a name="1007196"> </a>A resource database header consists of some general database information followed by a list of resources in the database. The first portion of the header is identical in structure to a normal database header (see <a href="FilesAndDatabases.html#1007421">"Structure of a Non-Schema Database Header"</a>). Resource database headers are distinguished from normal database headers by the <code>dmHdrAttrResDB</code> bit in the <code>attributes</code> field. </p>

<div><hr>
  <a name="1007200"> </a> <b>IMPORTANT: </b> Expect the resource database header structure to change in the future. Use the API to work with resource database structures.
<hr>
</div>
<ul type="disc">
  <li><a name="1007201"> </a>The <code>name</code> field holds the name of the resource database. 
  <li><a name="1007202"> </a>The <code>attributes</code> field has flags for the database and always has the <code>dmHdrAttrResDB</code> bit set. 
  <li><a name="1007203"> </a>The <code>modificationNumber</code> is incremented every time a resource in the database is deleted, added, or modified. Thus, applications can quickly determine if a shared resource database has been modified by another process.
  <li><a name="1007204"> </a>The <code>appInfoID</code> and <code>sortInfoID</code> fields are not normally needed for a resource database but are included to match the structure of a regular database. An application may optionally use these fields for its own purposes. 
  <li><a name="1007205"> </a>The <code>type</code> and <code>creator</code> fields hold 4-byte signatures of the database <code>type</code> and <code>creator</code> as defined by the application that created the database.
  <li><a name="1007206"> </a>The <code>numResources</code> field holds the number of resource info entries that are stored in the header itself. In most cases, this is the total number of resources. If all the resource info entries cannot fit in the header, however, then <code>nextResourceList</code> has the <code>chunkID</code> of a <code>resourceList</code> that contains the next set of resource info entries.
</ul>

<p><a name="1007207"> </a>Each 10-byte resource info entry in the header has the resource type, the resource ID, and the ID of the Memory Manager chunk that contains the resource data.</p>

<h4 class="hcH4">
  <a name="1007217"> </a>Working with Resource Databases
</h4>

<p><a name="993838"> </a>You can create, delete, open, and close resource databases with the functions used to create normal record-based databases (see <a href="FilesAndDatabases.html#1026501">"Working with Non-Schema Databases"</a>). This includes all database-level (not record-level) functions in the Data Manager such as <a href="DataMgr.html#995780"><code>DmCreateDatabase()</code></a>, <a href="DataMgr.html#996663"><code>DmDeleteDatabase()</code></a>, <a href="DataMgr.html#996192"><code>DmDatabaseInfo()</code></a>, and so on. </p>

<p><a name="993857"> </a>When you create a new database using <a href="DataMgr.html#995780"><code>DmCreateDatabase()</code></a>, the type of database created (record or resource) depends on the value of the <code>resDB</code> parameter. If set, a resource database is created and the <code>dmHdrAttrResDB</code> bit is set in the <code>attributes</code> field of the database header. Given a database header ID, an application can determine which type of database it is by calling <a href="DataMgr.html#996192"><code>DmDatabaseInfo()</code></a> and examining the <code>dmHdrAttrResDB</code> bit in the returned <code>attributes</code> field.</p>

<p><a name="993861"> </a>Once a resource database has been opened, an application can read and manipulate its resources by using the resource-based access functions of the Resource Manager. Generally, applications use the <a href="DataMgr.html#1000738"><code>DmGetResource()</code></a> and <a href="DataMgr.html#1004572"><code>DmReleaseResource()</code></a> functions.</p>

<p><a name="993872"> </a><a href="DataMgr.html#1000738"><code>DmGetResource()</code></a> searches a specified resource database and returns a handle to a resource, given the resource type and ID. </p>

<div><hr>
  <a name="1006323"> </a> <b>NOTE: </b> Previous versions of Palm OS had the notion of a resource "search chain", the set of all open resource databases that were searched when looking for a specified resource. This concept isn't really supported in Palm OS 6, except for compatibility purposes: applications that run under PACE will work as originally designed. To support this level of compatibility, the Data Manager contains a number of deprecated functions that provide the old functionality. These functions are: <a href="DataMgr.html#1003012"><code>DmOpenDatabaseV50()</code></a>, <a href="DataMgr.html#1003392"><code>DmOpenDBNoOverlayV50()</code></a>, <a href="DataMgr.html#1002816"><code>DmOpenDatabaseByTypeCreatorV50()</code></a>, <a href="DataMgr.html#1000838"><code>DmGetResourceV50()</code></a>, and <a href="DataMgr.html#998108"><code>DmGet1ResourceV50()</code></a>. Because these functions are deprecated, applications written for Palm OS 6 should not rely upon them.
<hr>
</div>

<p><a name="993879"> </a><a href="DataMgr.html#1004572"><code>DmReleaseResource()</code></a> should be called as soon as an application finishes reading or writing the resource data. To resize a resource, call <a href="DataMgr.html#1005213"><code>DmResizeResource()</code></a>, which accepts a handle to a resource and reallocates the resource. It returns the handle of the resource, which might have been changed.</p>

<p><a name="993883"> </a>The remaining Resource Manager functions are usually not required for most applications. These include functions to get and set resource attributes, move resources from one database to another, get resources by index, and create new resources. Most of these functions reference resources by index to optimize performance. When referencing a resource by index, the <code>DmOpenRef</code> of the open resource database that the resource belongs to must also be specified. Call <a href="DataMgr.html#1006129"><code>DmSearchResourceOpenDatabases()</code></a> to find a resource by type and ID or by pointer by searching in all open resource databases opened by the process. Note that this function does not search resource databases opened in other processes.</p>

<p><a name="993887"> </a>To get the <code>DmOpenRef</code> of the topmost open resource database, call <a href="DataMgr.html#1002084"><code>DmNextOpenResDatabase()</code></a> and pass <code>NULL</code> as the current <code>DmOpenRef</code>. To find out the <code>DmOpenRef</code> of each successive database, call <code>DmNextOpenResDatabase()</code> repeatedly with each successive <code>DmOpenRef</code>.</p>

<p><a name="993891"> </a>Given the access pointer of a specific open resource database, <a href="DataMgr.html#997720"><code>DmFindResource()</code></a> can be used to return the index of a resource, given its type and ID. <a href="DataMgr.html#997774"><code>DmFindResourceType()</code></a> can be used to get the index of every resource of a given type. To get a resource handle by index, call <a href="DataMgr.html#1000792"><code>DmGetResourceByIndex()</code></a>.</p>

<p><a name="993901"> </a>To determine how many resources are in a given database, call <a href="DataMgr.html#1002470"><code>DmNumResources()</code></a>. To get and set attributes of a resource including its type and ID, call <a href="DataMgr.html#1005302"><code>DmResourceInfo()</code></a> and <a href="DataMgr.html#1007394"><code>DmSetResourceInfo()</code></a>. To attach an existing data chunk to a resource database as a new resource, call <a href="DataMgr.html#995445"><code>DmAttachResource()</code></a>. To detach a resource from a database, call <a href="DataMgr.html#997061"><code>DmDetachResource()</code></a>.</p>

<p><a name="993922"> </a>To create a new resource, call <a href="DataMgr.html#1001870"><code>DmNewResource()</code></a> and pass the desired size, type, and ID of the new resource. To delete a resource, call <a href="DataMgr.html#1004684"><code>DmRemoveResource()</code></a>. Removing a resource disposes of its data chunk and removes its entry from the database header.</p>

<h4 class="hcH4">
  <a name="995594"> </a>Overlays
</h4>

<p><a name="1006557"> </a>Resource databases (and only resource databases) can have overlay databases associated with them; these localization overlays provide a method of localizing a software module without requiring a recompile or modification of the software. Each overlay database is a separate resource database that provides an appropriately-localized set of resources for a single software module (the <b>base database</b>) and a single target locale (language and country). </p>

<p><a name="1006818"> </a>When a resource database is opened, the Data Manager looks for an overlay matching the base database and the current locale. When searching for an overlay database, the Data Manager first looks in RAM. If an appropriate overlay database isn't found there for the specified base database and target locale, it then tries to locate one in ROM.</p>

<p><a name="1006674"> </a>Most of the locale APIs are declared in the Locale Manager, which is documented in <i>Exploring Palm OS: Text and Localization</i>. The Data Manager does provide a few functions, however, that let you get and set the locale that is used when opening an overlay, that determines an overlay database's locale, and that identifies the proper overlay database given the name of a base database and a locale.</p>

<div><hr>
  <a name="1006688"> </a> <b>NOTE: </b> There is no system support for letting the user pick the language of a given application. A separate application&#8212;the "language picker"&#8212;lets the user change the Data Manager's overlay locale. This application sets the overlay locale indirectly, by changing the system locale and thus forcing a soft reset.
<hr>
</div>

<p><a name="1006644"> </a>The Data Manager's overlay locale is a global setting that applies to all processes and threads. The overlay locale is initialized to be the same as the system locale following a soft reset. After the overlay locale is changed by calling <a href="DataMgr.html#1006917"><code>DmSetOverlayLocale()</code></a>, whenever the Data Manager needs to automatically open an overlay it uses the specified locale. If no valid overlay exists for that overlay locale, the Data Manager uses the fallback overlay locale instead.</p>

<p><a name="1006699"> </a>You set the Data Manager's overlay locale with <a href="DataMgr.html#1006917"><code>DmSetOverlayLocale()</code></a>, and you get it with <a href="DataMgr.html#999814"><code>DmGetOverlayLocale()</code></a>. Similarly, set the fallback overlay locale by calling <a href="DataMgr.html#1006659"><code>DmSetFallbackOverlayLocale()</code></a> and get it by calling <a href="DataMgr.html#998819"><code>DmGetFallbackOverlayLocale()</code></a>.</p>

<p><a name="1006744"> </a>For a given overlay database, you can determine its locale by passing the overlay database name and a pointer to an <code>LmLocaleType</code> structure to <a href="DataMgr.html#999666"><code>DmGetOverlayDatabaseLocale()</code></a>. Upon return, the <code>LmLocaleType</code> structure contains the overlay database's locale.</p>

<p><a name="1006763"> </a>To locate the overlay database for a given base database, pass the name of the base database and an <code>LmLocaleType</code> structure indicating the desired locale to <a href="DataMgr.html#999764"><code>DmGetOverlayDatabaseName()</code></a>. It will return the name of the overlay database for the specified base database and locale. You can pass <code>NULL</code> instead of a pointer to an <code>LmLocaleType</code> structure to obtain the overlay database name for the base database and the current locale.</p>

<h5 class="hdH5">
  <a name="995629"> </a>Overlay Signature Verification
</h5>

<p><a name="1006633"> </a>If the base database is signed, then the overlay database must also be signed, and its signature must be validated using a certificate ID that comes from the base database's <code>'sign'</code> resource. More specifically, </p>
<ul type="disc">
  <li><a name="995631"> </a>The base database's <code>'sign'</code> resource must contain one or more overlay certificate ID values.
  <li><a name="995632"> </a>The overlay database must contain a <code>'sign'</code> resource.
  <li><a name="995633"> </a>One of the signatures in the overlay database's <code>'sign'</code> resource must use a certificate ID that comes from the base database's <code>'sign'</code> resource list of overlay certificate ID values, and this signature must validate the overlay database.
</ul>

<h2 class="haH2">
  <a name="993420"> </a>Data Manager Tips <a href="#608590"><span class="nav">^TOP^</span></a>
</h2>


<p><a name="993421"> </a>Working properly with databases makes your application run faster and synchronize without problems. Follow these suggestions: </p>
<ul type="disc">
  <li><a name="993422"> </a>Database names can be up to 31 characters in length, and on the handheld can be composed of any valid 7-bit ASCII characters (only). Some conduits&#8212;such as PalmSource's backup conduit&#8212;use a name-mangling scheme to preserve case-sensitive database names when generating backup filenames on Microsoft Windows. Other conduits may not do this, however, so you may want to avoid filenames that depend on case for distinction.
</ul>

<div><hr>
  <a name="1028514"> </a> <b>IMPORTANT: </b> Previous versions of Palm OS didn't enforce the requirement that database names be composed only of 7-bit ASCII characters. Palm OS Cobalt requires that this be so.
<hr>
</div>
   <p><a name="993425"> </a>By convention, filename extensions are not used on the handheld. Instead, database types are used to identify databases as members of a certain type or class. Note that when the PalmSource backup conduit transfers a file to the desktop, it automatically appends one of the following extensions to the database filename:</p>
  <ul type="disc">
    <li><a name="1024181"> </a>PRC for resource databases (classic or extended)
    <li><a name="1024182"> </a>PDB for non-schema record databases (classic or extended)
    <li><a name="1024183"> </a>SDB for non-secure schema databases
    <li><a name="1024184"> </a>SSD for secure schema databases
    <li><a name="1024185"> </a>VLT for vault databases used to hold security information (HEKs, rules, tokens, and the like)
  </ul>
   <p><a name="1024179"> </a>The extension is removed when the file is transferred back to the handheld.</p>
<ul type="disc">
  <li><a name="993430"> </a>When the user deletes a record from a database, call <a href="DataMgr.html#996913"><code>DmDeleteRecord()</code></a> (or <a href="SchemaDatabases.html#997650"><code>DbDeleteRow()</code></a>) to remove all data from the record, not <a href="DataMgr.html#1004638"><code>DmRemoveRecord()</code></a> (or <a href="SchemaDatabases.html#1000956"><code>DbRemoveRow()</code></a>) to remove the record itself. That way, the desktop application can retrieve the information that the record is deleted the next time there is a HotSync operation. 
   <p><a name="993435"> </a><span style="color: #000000;  font-style: normal; font-weight: bold; text-decoration: none; text-transform: none; vertical-align: baseline">Note</span>: If your application doesn't have an associated conduit, call <code>DmRemoveRecord()</code> to completely remove the record.</p>
  <li><a name="993437"> </a>Keep data in database records compact. To avoid performance problems, Palm OS databases are not compressed, but all data are tightly packed. This pays off for storage and during HotSync operations. 
  <li><a name="993438"> </a>All records in a non-schema database should be of the same type and format. This is not a requirement, but is highly recommended to avoid processing overhead. 
  <li><a name="993439"> </a>Be sure your application modifies the flags in the database header appropriately when the user deletes or otherwise modifies information. This flag modification is only required if you're synchronizing with the PalmSource PIM applications, but should likely be done with any database that is to be sync'd by a conduit.
  <li><a name="993441"> </a>Don't display deleted records. 
  <li><a name="993446"> </a>Call <a href="DataMgr.html#1006265"><code>DmSetDatabaseInfo()</code></a> when creating a non-schema database to assign a version number to your application. Databases default to version 0 if the version isn't explicitly set. 
  <li><a name="993451"> </a>Call <a href="DataMgr.html#996192"><code>DmDatabaseInfo()</code></a> to check the non-schema database version at application start-up.
</ul>

<h2 class="haH2">
  <a name="993578"> </a>File Streaming Layer <a href="#608590"><span class="nav">^TOP^</span></a>
</h2>


<p><a name="993579"> </a>The file streaming functions add a layer on top of the classic database functions and let you work with a Palm OS database using a more familiar set of operations. File streams allow you to read, write, seek to a specified offset, truncate, and do everything else you'd expect to do with a desktop-style file. </p>

<p><a name="993580"> </a>Other than backup and restore, Palm OS does not provide direct HotSync support for file streams. </p>

<p><a name="993581"> </a>The use of double-buffering imposes a performance penalty on file streams that may make them unsuitable for certain applications. Record-intensive applications tend to obtain better performance from the Data Manager.</p>
<h3 class="hbH3">
  <a name="993582"> </a>Using the File Streaming API <a href="#608590"><span class="nav">^TOP^</span></a>
</h3>


<p><a name="993583"> </a>The File Streaming API is derived from the C programming language's <code>&lt;stdio.h&gt;</code> interface. Any C book that explains the <code>&lt;stdio.h&gt;</code> interface should serve as a suitable introduction to the concepts underlying the Palm OS File Streaming API. This section provides only a brief overview of the most commonly used file streaming functions. </p>

<p><a name="1028614"> </a>The <a href="FileStream.html#994284"><code>FileOpen()</code></a> function opens or creates a file (an extended database; use <a href="FileStream.html#994394"><code>FileOpenV50()</code></a> to open or create a classic database), and the <a href="FileStream.html#994460"><code>FileRead()</code></a> function reads it. The semantics of <a href="FileStream.html#994460"><code>FileRead()</code></a> and <a href="FileStream.html#995398"><code>FileWrite()</code></a> are just like their <code>&lt;stdio.h&gt;</code> equivalents, the <code>fread()</code> and <code>fwrite()</code> functions. The other <code>&lt;stdio.h&gt;</code> functions have obvious analogs in the File Streaming API as well.</p>

<p><a name="993597"> </a>For example,</p>

<div class="CodeRule"><hr></div><pre class="CodeBlock">
theStream = FileOpen("KillerAppDataFile", 'KILR',
   'KILD', fileModeReadOnly, &amp;err); <a name="993598"> </a>
</pre><div class="CodeRule"><hr></div>


<p><a name="993599"> </a>As on a desktop, the filename is the unique item. The creator ID and file type are for informational purposes and your code may require that an opened file have the correct type and creator.</p>

<div><hr>
  <a name="1028573"> </a> <b>IMPORTANT: </b> Previous versions of Palm OS didn't enforce the requirement that database names passed to <code>FileOpen()</code> be composed only of 7-bit ASCII characters. Palm OS Cobalt requires that this be so.
<hr>
</div>

<p><a name="993603"> </a>Normally, the <a href="FileStream.html#994284"><code>FileOpen()</code></a> function returns an error when it attempts to open or replace an existing stream having a type and creator that do not match those specified. To suppress this error, pass the <code>fileModeAnyTypeCreator</code> selector as a flag in the <code>openMode</code> parameter to the <a href="FileStream.html#994284"><code>FileOpen()</code></a> function. </p>

<p><a name="993610"> </a>To read data, use the <a href="FileStream.html#994460"><code>FileRead()</code></a> function as in the following example: </p>

<div class="CodeRule"><hr></div><pre class="CodeBlock">
FileRead(theStream, &amp;buf, objSize, numObjs, &amp;err); <a name="993611"> </a>
</pre><div class="CodeRule"><hr></div>


<p><a name="993612"> </a>To free the memory used to store stream data as the data is read, you can use the <a href="FileStream.html#993548"><code>FileControl()</code></a> function to switch the stream to destructive read mode. This mode is useful for manipulating temporary data; for example, destructive read mode would be ideal for adding the objects in a large data stream to a database when sufficient memory for duplicating the entire file stream is not available. You can switch a stream to destructive read mode by passing the <code>fileOpDestructiveReadMode</code> selector as the value of the <code>op</code> parameter to the <a href="FileStream.html#993548"><code>FileControl()</code></a> function. </p>

<p><a name="993622"> </a>The <a href="FileStream.html#993974"><code>FileDmRead()</code></a> function can read data directly into a Data Manager chunk for immediate addition to a Palm OS database.</p>

<p><a name="1019124"> </a></p>
&nbsp;<br>
</div>
<!--END CONTENT-->

</td>
<td width="5">&nbsp;&nbsp;</td>
</tr>

</table>

<!-- BEGIN FOOTER -->
<table width="100%" border="0" cellspacing="0" cellpadding="0">
<tr>
<td width="7" rowspan="2"><img name="index_x" src="images/shim.gif" width="7" height="33" border="0" alt=""></td>
<td align="left"><img name="dashes" src="images/dashes.gif" width="744" height="3" border="0" alt=""></td>
<td width="10" rowspan="2"><img name="index_x" src="images/shim.gif" width="10" height="33" border="0" alt=""></td>
</tr>
<tr>
<td align="center">
<p class="footer">
Copyright © 1996&#8211;2004, PalmSource, Inc. and its affiliates. All rights reserved.<br>
<a href="http://www.palmsource.com/contact/">Write Us</a> | <a href="http://www.palmos.com/dev/training/">Training</a> | <a href="http://www.palmos.com/dev/support/kb/">Knowledge Base</a> | <a href="MDF_Front.html" target="_blank">Legal</a></p>
<br>
<!--BEGIN BOOK NAVIGATION-->
<p class="nav">
<A href="http://www.palmos.com/dev/support/docs/">Documentation</a>&nbsp;&nbsp;|&nbsp;&nbsp;
<a href="MDF_TOC.html">Table of Contents</a>&nbsp;&nbsp;
             |&nbsp;&nbsp;<a href="Memory.html">&lt;&nbsp;Previous</a>&nbsp;&nbsp;
             |&nbsp;&nbsp;<a href="VFS.html">Next&nbsp;&gt;</a>&nbsp;&nbsp;
             |&nbsp;&nbsp;<a href="MDF_IX.html">Index</a>
</p>
</td>
</tr>
</table>
<!-- END FOOTER -->

</body>
</html>