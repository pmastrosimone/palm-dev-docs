<html>
<head>
<title>(Protein) VFS Manager | Memory, Databases, and Files</title> 
<link href="psi_devpubs.css" rel="stylesheet" type="text/css">

<!-- BEGIN META DATA -->
<meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
<META NAME="PSITEMPLATE" CONTENT="1006-007 PalmSource_HTML_2003 20041101">
<META NAME="GENERATOR" CONTENT="Quadralay WebWorks AutoMap 2003 for FrameMaker 8.0.6.2138">
<META NAME="LASTUPDATED" CONTENT="11/22/04 11:16:08">
<!-- END META DATA -->
</head>

<body bgcolor="#ffffff" text="#000000" leftmargin="0" topmargin="0" marginwidth="0" marginheight="0">
<a name="992934"></a>

<!-- BEGIN TOPNAV -->
<table width="100%" border="0" cellspacing="0" cellpadding="0">
<tr>
<td><img src="images/shim.gif" width="7" height="75" border="0" alt=""></td>
<td align="left"><table border="0" cellpadding="0" cellspacing="0" width="744">
<tr>
<td><img name="index_r2_c1" src="images/shim.gif" width="25" height="75" border="0" alt=""></td>
<td valign="top"><table border="0" cellpadding="0" cellspacing="0" width="96">
<tr>
<td><img name="index_r2_c4" src="images/shim.gif" width="96" height="15" border="0" alt=""></td>
</tr>
<tr>
<td><a href="http://www.palmsource.com/"><img name="ps_logo" src="images/ps_logo.gif" width="96" height="54" border="0" alt=""></a></td>
</tr>

</table>
</td>

<td><table border="0" cellpadding="0" cellspacing="0" width="30">
<td><img name="index_x" src="images/shim.gif" width="30" height="75" border="0" alt=""></td>
</table></td>

<!--BEGIN MASTHEAD-->
<td><table border="0" cellpadding="0" cellspacing="0" width="96">
<tr>
<td><img name="index_x" src="images/shim.gif" width="615" height="5" border="0" alt=""></td>
</tr>
<tr>
<td>
<!--BEGIN BOOK NAVIGATION-->
<span class="nav">
<A href="http://www.palmos.com/dev/support/docs/">Documentation</a>&nbsp;&nbsp;|&nbsp;&nbsp;
<a href="MDF_TOC.html">Table of Contents</a>&nbsp;&nbsp;
             |&nbsp;&nbsp;<a href="SchemaDatabases.html">&lt;&nbsp;Previous</a>&nbsp;&nbsp;
             |&nbsp;&nbsp;<a href="MDF_IX.html">Next&nbsp;&gt;</a>&nbsp;&nbsp;
             |&nbsp;&nbsp;<a href="MDF_IX.html">Index</a>
</span>
<!--END BOOK NAVIGATION-->
</tr>
<tr>
<td>
<!--BEGIN PAGE TITLE-->
<h2 class="PageTitle">8 &nbsp;&nbsp;
VFS Manager</h2></td>
<!--END PAGE TITLE-->
</tr>
<tr>
<td>
<!--BEGIN BOOK TITLE-->
<p class="BookTitle">Memory, Databases, and Files</p>
<p class="SubTitle">Exploring Palm OS&#174; </p>
<!--END BOOK TITLE-->
</td>
</tr>
<tr>
<td><img name="index_x" src="images/shim.gif" width="615" height="5" border="0" alt=""></td>
</tr>
</table>
</td>
<!--END MASTHEAD-->
</tr>
</table>
<img name="dashes" src="images/dashes.gif" width="744" height="3" border="0" alt=""></td>
</tr>
</table>
<!-- END TOPNAV -->

<table width="100%" border="0" cellspacing="0" cellpadding="0">
<tr>
<td valign="top" width="5"><img name="index_x" src="images/shim.gif" width="5" height="33" border="0" alt=""></td>

<!--BEGIN SIDETOC-->
<td valign="top" width="175">
<div id="sidetoc" valign="bottom">
<h1 class="SideTOC1-PartTab"><a href="MDF_Part2.html">Part II: Reference</a> </h1>
<h1 class="SideTOC1"><a href="VFSMgr.html">8  VFS Manager</a></h1>

   <h2 class="SideTOC2"><a href="#992942">
   VFS Manager Structures and Types</a></h2>

      <h3 class="SideTOC3"><a href="#992950">
      FileInfoType</a></h3>

      <h3 class="SideTOC3"><a href="#992994">
      FileOrigin</a></h3>

      <h3 class="SideTOC3"><a href="#993019">
      FileRef</a></h3>

      <h3 class="SideTOC3"><a href="#993069">
      VFSAnyMountParamType</a></h3>

      <h3 class="SideTOC3"><a href="#993113">
      VFSPOSEMountParamType</a></h3>

      <h3 class="SideTOC3"><a href="#993157">
      VFSSlotMountParamType</a></h3>

      <h3 class="SideTOC3"><a href="#993429">
      VolumeInfoType</a></h3>

   <h2 class="SideTOC2"><a href="#993493">
   VFS Manager Constants</a></h2>

      <h3 class="SideTOC3"><a href="#1009262">
      VFS Manager Error Codes</a></h3>

      <h3 class="SideTOC3"><a href="#1011713">
      Defined File Systems</a></h3>

      <h3 class="SideTOC3"><a href="#1016238">
      Open Mode Constants</a></h3>

      <h3 class="SideTOC3"><a href="#1018829">
      File and Directory Attributes</a></h3>

      <h3 class="SideTOC3"><a href="#1022698">
      Volume Attributes</a></h3>

      <h3 class="SideTOC3"><a href="#1023080">
      Volume Mount Classes</a></h3>

      <h3 class="SideTOC3"><a href="#1070095">
      Date Types</a></h3>

      <h3 class="SideTOC3"><a href="#1073903">
      Seek Origins</a></h3>

      <h3 class="SideTOC3"><a href="#1074902">
      Iterator Controls and Constants</a></h3>

      <h3 class="SideTOC3"><a href="#1075555">
      Volume Mount Flags</a></h3>

      <h3 class="SideTOC3"><a href="#993501">
      Miscellaneous Constants and Definitions</a></h3>

   <h2 class="SideTOC2"><a href="#1074104">
   VFS Manager Functions and Macros</a></h2>

      <h3 class="SideTOC3"><a href="#1072937">
      VFSCustomControl</a></h3>

      <h3 class="SideTOC3"><a href="#994162">
      VFSDirCreate</a></h3>

      <h3 class="SideTOC3"><a href="#994232">
      VFSDirEntryEnumerate</a></h3>

      <h3 class="SideTOC3"><a href="#994325">
      VFSExportDatabaseToFile</a></h3>

      <h3 class="SideTOC3"><a href="#994399">
      VFSExportDatabaseToFileCustom</a></h3>

      <h3 class="SideTOC3"><a href="#994461">
      VFSExportDatabaseToFileCustomV40</a></h3>

      <h3 class="SideTOC3"><a href="#994527">
      VFSExportDatabaseToFileV40</a></h3>

      <h3 class="SideTOC3"><a href="#994581">
      VFSFileClose</a></h3>

      <h3 class="SideTOC3"><a href="#994627">
      VFSFileCreate</a></h3>

      <h3 class="SideTOC3"><a href="#994673">
      VFSFileDBGetRecord</a></h3>

      <h3 class="SideTOC3"><a href="#994939">
      VFSFileDBGetResource</a></h3>

      <h3 class="SideTOC3"><a href="#995089">
      VFSFileDBInfo</a></h3>

      <h3 class="SideTOC3"><a href="#995187">
      VFSFileDelete</a></h3>

      <h3 class="SideTOC3"><a href="#995233">
      VFSFileEOF</a></h3>

      <h3 class="SideTOC3"><a href="#995318">
      VFSFileGetAttributes</a></h3>

      <h3 class="SideTOC3"><a href="#995388">
      VFSFileGetDate</a></h3>

      <h3 class="SideTOC3"><a href="#995477">
      VFSFileOpen</a></h3>

      <h3 class="SideTOC3"><a href="#995539">
      VFSFileOpenFromURL</a></h3>

      <h3 class="SideTOC3"><a href="#995787">
      VFSFileRead</a></h3>

      <h3 class="SideTOC3"><a href="#995845">
      VFSFileReadData</a></h3>

      <h3 class="SideTOC3"><a href="#995946">
      VFSFileRename</a></h3>

      <h3 class="SideTOC3"><a href="#996020">
      VFSFileResize</a></h3>

      <h3 class="SideTOC3"><a href="#996105">
      VFSFileSeek</a></h3>

      <h3 class="SideTOC3"><a href="#996163">
      VFSFileSetAttributes</a></h3>

      <h3 class="SideTOC3"><a href="#996237">
      VFSFileSetDate</a></h3>

      <h3 class="SideTOC3"><a href="#996311">
      VFSFileSize</a></h3>

      <h3 class="SideTOC3"><a href="#996357">
      VFSFileTell</a></h3>

      <h3 class="SideTOC3"><a href="#996483">
      VFSFileWrite</a></h3>

      <h3 class="SideTOC3"><a href="#996558">
      VFSGetDefaultDirectory</a></h3>

      <h3 class="SideTOC3"><a href="#996612">
      VFSImportDatabaseFromFile</a></h3>

      <h3 class="SideTOC3"><a href="#996934">
      VFSImportDatabaseFromFileCustom</a></h3>

      <h3 class="SideTOC3"><a href="#996996">
      VFSImportDatabaseFromFileCustomV40</a></h3>

      <h3 class="SideTOC3"><a href="#997062">
      VFSImportDatabaseFromFileV40</a></h3>

      <h3 class="SideTOC3"><a href="#997241">
      VFSRegisterDefaultDirectory</a></h3>

      <h3 class="SideTOC3"><a href="#997400">
      VFSUnregisterDefaultDirectory</a></h3>

      <h3 class="SideTOC3"><a href="#997470">
      VFSVolumeEnumerate</a></h3>

      <h3 class="SideTOC3"><a href="#997555">
      VFSVolumeFormat</a></h3>

      <h3 class="SideTOC3"><a href="#997613">
      VFSVolumeGetLabel</a></h3>

      <h3 class="SideTOC3"><a href="#997667">
      VFSVolumeInfo</a></h3>

      <h3 class="SideTOC3"><a href="#997713">
      VFSVolumeMount</a></h3>

      <h3 class="SideTOC3"><a href="#997767">
      VFSVolumeSetLabel</a></h3>

      <h3 class="SideTOC3"><a href="#997813">
      VFSVolumeSize</a></h3>

      <h3 class="SideTOC3"><a href="#997867">
      VFSVolumeUnmount</a></h3>

   <h2 class="SideTOC2"><a href="#997909">
   Application-Defined Functions</a></h2>

      <h3 class="SideTOC3"><a href="#997944">
      VFSExportProcPtr</a></h3>

      <h3 class="SideTOC3"><a href="#998201">
      VFSImportProcPtr</a></h3>

</div>
</td>

<td width="5">&nbsp;&nbsp;</td>
<td width="2" background="images/index_r8_c10.gif"><img src="images/shim.gif" width="2" height="75" border="0" alt=""></td>
<td width="5">&nbsp;&nbsp;</td>

<!--END SIDETOC-->

<td valign="top">

<!--BEGIN CONTENT-->
<div id="content" valign="bottom">
<p><a name="992936"> </a>The Virtual File System (VFS) Manager is a layer of software that manages all installed file system libraries. It provides a unified API to application developers while allowing them to seamlessly access many different types of file systems &#8212;such as VFAT, HFS, and NFS&#8212;on many different types of media, including Compact Flash, Memory Stick, and SmartMedia.This chapter provides reference material for the VFS Manager API, organized as follows:</p>
   <blockquote class = "bq"><a name="992948"> </a><a href="VFSMgr.html#992942">VFS Manager Structures and Types</a></blockquote>
   <blockquote class = "bq"><a name="993499"> </a><a href="VFSMgr.html#993493">VFS Manager Constants</a></blockquote>
   <blockquote class = "bq"><a name="994055"> </a><a href="VFSMgr.html#1074104">VFS Manager Functions and Macros</a></blockquote>
   <blockquote class = "bq"><a name="1078804"> </a><a href="VFSMgr.html#997909">Application-Defined Functions</a></blockquote>

<p><a name="1078805"> </a>The header file <code>VFSMgr.h</code> declares the API that this chapter describes.</p>

<p><a name="1078935"> </a>For more information on file systems in Palm OS<sup>&#174; </sup>and the VFS Manager, see <a href="VFS.html#608590">Chapter 3, "Virtual File Systems."</a></p>

<h2 class="haH2">
  <a name="992942"> </a>VFS Manager Structures and Types <a href="#992934"><span class="nav">^TOP^</span></a>
</h2>


<h3 class="hbH3">
  <a name="992950"> </a>FileInfoType Struct <a href="#992934"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="992955"> </a>Purpose 
</h4>

<p><a name="998289"> </a>Contains information about a specified file or directory.</p>
<h4>
  <a name="992960"> </a>Declared In 
</h4>
<code>VFSMgr.h<a name="992963"> </a></code><h4>
  <a name="992965"> </a>Prototype 
</h4>
<pre class="proto"><a name="992968"></a>typedef struct FileInfoTag {
   uint32_t attributes;
   char *nameP;
   uint16_t nameBufLen;
   uint16_t reserved;
} FileInfoType, *FileInfoPtr
</pre>
<h4>
  <a name="992970"> </a>Fields 
</h4>

<dl>
<dt><a name="992973"> </a><code>attributes</code></dt>
<dd><a name="992975"> </a>Characteristics of the file or directory. See <a href="VFSMgr.html#1018829">File and Directory Attributes</a> for the bits that make up this field.</dd>

<dt><a name="992977"> </a><code>nameP</code></dt>
<dd><a name="992979"> </a>Pointer to the buffer that receives the full name of the file or directory. Initialize this parameter to <code>NULL</code> if you don't want to receive the name.</dd>

<dt><a name="992981"> </a><code>nameBufLen</code></dt>
<dd><a name="992983"> </a>Size of the <code>nameP</code> buffer, in bytes.</dd>

<dt><a name="992985"> </a><code>reserved</code></dt>
<dd><a name="992987"> </a>Reserved for future use.</dd>

</dl>
<h4>
  <a name="992989"> </a>Comments 
</h4>

<p><a name="992992"> </a>This information is returned as a parameter to <a href="VFSMgr.html#994232"><code>VFSDirEntryEnumerate()</code></a>.</p>

<h3 class="hbH3">
  <a name="992994"> </a>FileOrigin Typedef <a href="#992934"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="992999"> </a>Purpose 
</h4>

<p><a name="993002"> </a>Encodes references to files and directories.</p>
<h4>
  <a name="993004"> </a>Declared In 
</h4>
<code>VFSMgr.h<a name="993007"> </a></code><h4>
  <a name="993009"> </a>Prototype 
</h4>
<pre class="proto"><a name="993012"></a>typedef uint16_t FileOrigin
</pre>

<h3 class="hbH3">
  <a name="993019"> </a>FileRef Typedef <a href="#992934"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="993024"> </a>Purpose 
</h4>

<p><a name="1069759"> </a>Container for a reference to an opened file or directory which is supplied to various <code>VFSFile... </code>operations.</p>
<h4>
  <a name="993029"> </a>Declared In 
</h4>
<code>VFSMgr.h<a name="993032"> </a></code><h4>
  <a name="993034"> </a>Prototype 
</h4>
<pre class="proto"><a name="993037"></a>typedef uint32_t FileRef
</pre>
<h4>
  <a name="993039"> </a>Comments 
</h4>

<p><a name="993042"> </a>Use <a href="VFSMgr.html#995477"><code>VFSFileOpen()</code></a> to obtain a <code>FileRef</code> value.</p>

<h3 class="hbH3">
  <a name="993069"> </a>VFSAnyMountParamType Struct <a href="#992934"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="993074"> </a>Purpose 
</h4>

<p><a name="993077"> </a>A base structure for <a href="VFSMgr.html#993157"><code>VFSSlotMountParamType</code></a>, <a href="VFSMgr.html#993113"><code>VFSPOSEMountParamType</code></a>, and other similar structures that may be defined in the future. Use one or the other according to how you set the <code>mountClass</code> parameter.</p>
<h4>
  <a name="993079"> </a>Declared In 
</h4>
<code>VFSMgr.h<a name="993082"> </a></code><h4>
  <a name="993084"> </a>Prototype 
</h4>
<pre class="proto"><a name="999173"></a>typedef struct VFSAnyMountParamTag {
   uint16_t volRefNum;
   uint16_t size;
   uint32_t mountClass;
} VFSAnyMountParamType
</pre>
<pre class="proto"><a name="999196"></a>typedef VFSAnyMountParamType *VFSAnyMountParamPtr
</pre>
<h4>
  <a name="999174"> </a>Fields 
</h4>

<dl>
<dt><a name="999175"> </a><code>volRefNum</code></dt>
<dd><a name="993094"> </a>The volume reference number. This is initially obtained when you successfully mount a volume. It can then be used to format a volume with <a href="VFSMgr.html#997555"><code>VFSVolumeFormat()</code></a> or unmount a volume with <a href="VFSMgr.html#997867"><code>VFSVolumeUnmount()</code></a>. </dd>

<dt><a name="993096"> </a><code>size</code></dt>
<dd><a name="993102"> </a></dd>

<dt><a name="993104"> </a><code>mountClass</code></dt>
<dd><a name="993106"> </a>Defines the type of mount to use with the specified volume. See <a href="VFSMgr.html#1023080">Volume Mount Classes</a> for a list of mount types.</dd>

</dl>

<h3 class="hbH3">
  <a name="993113"> </a>VFSPOSEMountParamType Struct <a href="#992934"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="1001201"> </a>Purpose 
</h4>

<p><a name="1001202"> </a>When you are mounting a volume through Palm OS<sup>&#174;</sup> Emulator, the <code>vfsMountParam-&gt;mountClass</code> must be set to <code>VFSMountClass_POSE</code>. Note that ordinary applications and file systems shouldn't use <code>VFSPOSEMountParamType</code>.</p>
<h4>
  <a name="1001203"> </a>Declared In 
</h4>
<code>VFSMgr.h<a name="1001204"> </a></code><h4>
  <a name="993128"> </a>Prototype 
</h4>
<pre class="proto"><a name="993131"></a>typedef struct VFSPOSEMountParamTag {
   VFSAnyMountParamType vfsMountParam;
   uint8_t poseSlotNum;
   uint8_t reserved;
   uint16_t reserved2;
} VFSPOSEMountParamType
</pre>
<h4>
  <a name="993133"> </a>Fields 
</h4>

<dl>
<dt><a name="993136"> </a><code>vfsMountParam</code></dt>
<dd><a name="993138"> </a>See the description of <a href="VFSMgr.html#993069"><code>VFSAnyMountParamType</code></a> for an explanation of the fields in this structure. Set <code>vfsMountParam-&gt;mountClass</code> to <code>VFSMountClass_POSE</code> to mount a virtual slot.</dd>

<dt><a name="993140"> </a><code>poseSlotNum</code></dt>
<dd><a name="993142"> </a>Number of the virtual slot number to be mounted by Palm OS Emulator.</dd>

<dt><a name="993144"> </a><code>reserved</code></dt>
<dd><a name="993146"> </a>Reserved for future use.</dd>

<dt><a name="993148"> </a><code>reserved2</code></dt>
<dd><a name="993150"> </a>Reserved for future use.</dd>

</dl>

<h3 class="hbH3">
  <a name="993157"> </a>VFSSlotMountParamType Struct <a href="#992934"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="993162"> </a>Purpose 
</h4>

<p><a name="993165"> </a>When you are mounting a card located in an Expansion Manager slot, the <code>vfsMountParam-&gt;mountClass</code> field must be set to <code>VFSMountClass_SlotDriver</code>. </p>
<h4>
  <a name="993167"> </a>Declared In 
</h4>
<code>VFSMgr.h<a name="993170"> </a></code><h4>
  <a name="993172"> </a>Prototype 
</h4>
<pre class="proto"><a name="993175"></a>typedef struct VFSSlotMountParamTag {
   VFSAnyMountParamType vfsMountParam;
   uint16_t slotLibRefNum;
   uint16_t slotRefNum;
} VFSSlotMountParamType
</pre>
<h4>
  <a name="993193"> </a>Fields 
</h4>

<dl>
<dt><a name="993246"> </a><code>vfsMountParam</code></dt>
<dd><a name="993302"> </a>See the description of <a href="VFSMgr.html#993069"><code>VFSAnyMountParamType</code></a> for an explanation of the fields in this structure. Set <code>vfsMountParam-&gt;mountClass</code> to <code>VFSMountClass_SlotDriver</code> to mount an Expansion Manager slot.</dd>

<dt><a name="993360"> </a><code>slotLibRefNum</code></dt>
<dd><a name="993418"> </a>Reference number for the slot driver library allocated to the given slot number.</dd>

<dt><a name="993420"> </a><code>slotRefNum</code></dt>
<dd><a name="993422"> </a>Number of the slot to be mounted.</dd>

</dl>

<h3 class="hbH3">
  <a name="993429"> </a>VolumeInfoType Struct <a href="#992934"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="993434"> </a>Purpose 
</h4>

<p><a name="993437"> </a>Define information that is returned to <a href="VFSMgr.html#997667"><code>VFSVolumeInfo()</code></a> and used throughout the VFS functions.</p>
<h4>
  <a name="993439"> </a>Declared In 
</h4>
<code>VFSMgr.h<a name="993442"> </a></code><h4>
  <a name="993444"> </a>Prototype 
</h4>
<pre class="proto"><a name="993447"></a>typedef struct VolumeInfoTag {
   uint32_t attributes;
   uint32_t fsType;
   uint32_t fsCreator;
   uint32_t mountClass;
   uint16_t slotLibRefNum;
   uint16_t slotRefNum;
   uint32_t mediaType;
   uint32_t reserved;
} VolumeInfoType, *VolumeInfoPtr
</pre>
<h4>
  <a name="993449"> </a>Fields 
</h4>

<dl>
<dt><a name="993452"> </a><code>attributes</code></dt>
<dd><a name="993454"> </a>Characteristics of the volume. See <a href="VFSMgr.html#1022698">Volume Attributes</a> for the bits that make up this field.</dd>

<dt><a name="993456"> </a><code>fsType</code></dt>
<dd><a name="993458"> </a>File system type for this volume. See <a href="VFSMgr.html#1011713">Defined File Systems</a> for a list of the supported file systems.</dd>

<dt><a name="993460"> </a><code>fsCreator</code></dt>
<dd><a name="993466"> </a>Creator ID of this volume's file system driver. This information is used with <a href="VFSMgr.html#1072937"><code>VFSCustomControl()</code></a>.</dd>

<dt><a name="993468"> </a><code>mountClass</code></dt>
<dd><a name="993470"> </a>Mount class that mounted this volume. The supported mount classes are listed under <a href="VFSMgr.html#1023080">Volume Mount Classes</a>.</dd>

<dt><a name="993472"> </a><code>slotLibRefNum</code></dt>
<dd><a name="993474"> </a>Reference to the slot driver library with which the volume is mounted. This field is only valid when the mount class is <code>vfsMountClass_SlotDriver</code>.</dd>

<dt><a name="993476"> </a><code>slotRefNum</code></dt>
<dd><a name="993478"> </a>Slot number where the card containing the volume is loaded. This field is only valid when the mount class is <code>vfsMountClass_SlotDriver</code>.</dd>

<dt><a name="993480"> </a><code>mediaType</code></dt>
<dd><a name="1087492"> </a>Type of card media. See <a href="../System_Management/ExpansionMgr.html#999014">Defined Media Types</a> in <a href="../System_Management/ExpansionMgr.html#992934">Chapter 25, "Expansion Manager,"</a> of <i>Exploring Palm OS: System Management</i> for the list of values. This field is only valid when the mount class is <code>vfsMountClass_SlotDriver</code>.</dd>

<dt><a name="993484"> </a><code>reserved</code></dt>
<dd><a name="993486"> </a>Reserved for future use.</dd>

</dl>

<h2 class="haH2">
  <a name="993493"> </a>VFS Manager Constants <a href="#992934"><span class="nav">^TOP^</span></a>
</h2>


<h3 class="hbH3">
  <a name="1009262"> </a>VFS Manager Error Codes <a href="#992934"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="1009339"> </a>Purpose 
</h4>

<p><a name="1009981"> </a>Error codes returned by the various VFS Manager functions.</p>
<h4>
  <a name="1009407"> </a>Declared In 
</h4>
<code>VFSMgr.h<a name="1009486"> </a></code><h4>
  <a name="1009539"> </a>Constants 
</h4>

<dl>
<dt><a name="1009607"> </a><code>#define vfsErrBadData (vfsErrorClass | 12)</code></dt>
<dd><a name="1009608"> </a>The operation could not be completed because of invalid data.</dd>

<dt><a name="1009609"> </a><code>#define vfsErrBadName (vfsErrorClass | 14)</code></dt>
<dd><a name="1009610"> </a>Invalid filename, path, or volume label.</dd>

<dt><a name="1009611"> </a><code>#define vfsErrBufferOverflow (vfsErrorClass | 1)</code></dt>
<dd><a name="1009612"> </a>The supplied buffer is too small.</dd>

<dt><a name="1009613"> </a><code>#define vfsErrDirectoryNotFound (vfsErrorClass | 19)</code></dt>
<dd><a name="1009614"> </a>Returned when the path leading up to the file does not exist.</dd>

<dt><a name="1009615"> </a><code>#define vfsErrDirNotEmpty (vfsErrorClass | 13)</code></dt>
<dd><a name="1009616"> </a>The directory is not empty and therefore cannot be deleted.</dd>

<dt><a name="1009617"> </a><code>#define vfsErrFileAlreadyExists (vfsErrorClass | 6)</code></dt>
<dd><a name="1009618"> </a>A file with this name exists already in this location.</dd>

<dt><a name="1009619"> </a><code>#define vfsErrFileBadRef (vfsErrorClass | 3)</code></dt>
<dd><a name="1009620"> </a>The file reference is invalid: it has been closed or was not obtained from <a href="VFSMgr.html#995477"><code>VFSFileOpen()</code></a>.</dd>

<dt><a name="1009621"> </a><code>#define vfsErrFileEOF (vfsErrorClass | 7)</code></dt>
<dd><a name="1009622"> </a>The file pointer is at the end of the file.</dd>

<dt><a name="1009623"> </a><code>#define vfsErrFileGeneric (vfsErrorClass | 2)</code></dt>
<dd><a name="1009624"> </a>Generic file error.</dd>

<dt><a name="1009625"> </a><code>#define vfsErrFileNotFound (vfsErrorClass | 8)</code></dt>
<dd><a name="1009626"> </a>The file was not found at the specified location.</dd>

<dt><a name="1009627"> </a><code>#define vfsErrFilePermissionDenied (vfsErrorClass | 5)</code></dt>
<dd><a name="1009628"> </a>The requested permissions could not be granted.</dd>

<dt><a name="1009629"> </a><code>#define vfsErrFileStillOpen (vfsErrorClass | 4)</code></dt>
<dd><a name="1009630"> </a>Returned from the underlying file system's delete function if the file is still open.</dd>

<dt><a name="1009631"> </a><code>#define vfsErrIsADirectory (vfsErrorClass | 18)</code></dt>
<dd><a name="1009632"> </a>This operation can only be performed on a regular file, not a directory.</dd>

<dt><a name="1009633"> </a><code>#define vfsErrNameShortened (vfsErrorClass | 20)</code></dt>
<dd><a name="1009634"> </a>A volume name or filename was automatically shortened to conform to the file system specification.</dd>

<dt><a name="1009635"> </a><code>#define vfsErrNoFileSystem (vfsErrorClass | 11)</code></dt>
<dd><a name="1009636"> </a>None of the installed file systems support this operation.</dd>

<dt><a name="1009637"> </a><code>#define vfsErrNotADirectory (vfsErrorClass | 17)</code></dt>
<dd><a name="1009638"> </a>This operation can only performed on a directory.</dd>

<dt><a name="1009639"> </a><code>#define vfsErrUnimplemented (vfsErrorClass | 16)</code></dt>
<dd><a name="1009640"> </a></dd>

<dt><a name="1009641"> </a><code>#define vfsErrVolumeBadRef (vfsErrorClass | 9)</code></dt>
<dd><a name="1009642"> </a>The volume reference number is invalid.</dd>

<dt><a name="1009643"> </a><code>#define vfsErrVolumeFull (vfsErrorClass | 15)</code></dt>
<dd><a name="1009644"> </a>There is insufficient space left on the volume.</dd>

<dt><a name="1009645"> </a><code>#define vfsErrVolumeStillMounted (vfsErrorClass | 10)</code></dt>
<dd><a name="1009646"> </a>Returned from the underlying file system's format function if the volume is still mounted.</dd>

</dl>

<h3 class="hbH3">
  <a name="1011713"> </a>Defined File Systems <a href="#992934"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="1011770"> </a>Purpose 
</h4>

<p><a name="1011773"> </a>Identifiers for those file systems that are currently defined by the VFS Manager. These values are used with <a href="VFSMgr.html#997667"><code>VFSVolumeInfo()</code></a> in the <span style="color: #000000;  font-family: Courier; font-style: normal; font-weight: normal; text-decoration: none; text-transform: none; vertical-align: baseline">VolumeInfoType.fsType</span> parameter.</p>
<h4>
  <a name="1012099"> </a>Declared In 
</h4>
<code>VFSMgr.h<a name="1013816"> </a></code><h4>
  <a name="1014097"> </a>Constants 
</h4>

<dl>
<dt><a name="1015823"> </a><code>#define vfsFilesystemType_AFS 'afsu'</code></dt>
<dd><a name="1015824"> </a>Unix Andrew file system</dd>

<dt><a name="1015825"> </a><code>#define vfsFilesystemType_EXT2 'ext2'</code></dt>
<dd><a name="1015826"> </a>Linux file system</dd>

<dt><a name="1015827"> </a><code>#define vfsFilesystemType_FAT 'fats'</code></dt>
<dd><a name="1015828"> </a>FAT32, FAT16, and FAT12, but only using 8.3 filenames</dd>

<dt><a name="1015829"> </a><code>#define vfsFilesystemType_FFS 'ffsb'</code></dt>
<dd><a name="1015830"> </a>Unix Berkeley block based file system</dd>

<dt><a name="1015831"> </a><code>#define vfsFilesystemType_HFS 'hfss'</code></dt>
<dd><a name="1015832"> </a>Macintosh standard hierarchical file system</dd>

<dt><a name="1015833"> </a><code>#define vfsFilesystemType_HFSPlus 'hfse'</code></dt>
<dd><a name="1015834"> </a>Macintosh extended hierarchical file system</dd>

<dt><a name="1015835"> </a><code>#define vfsFilesystemType_HPFS 'hpfs'</code></dt>
<dd><a name="1015836"> </a>OS2 High Performance file system</dd>

<dt><a name="1015837"> </a><code>#define vfsFilesystemType_MFS 'mfso'</code></dt>
<dd><a name="1015838"> </a>Macintosh original file system</dd>

<dt><a name="1015839"> </a><code>#define vfsFilesystemType_NFS 'nfsu'</code></dt>
<dd><a name="1015840"> </a>Unix Networked file system</dd>

<dt><a name="1015841"> </a><code>#define vfsFilesystemType_Novell 'novl'</code></dt>
<dd><a name="1015842"> </a>Novell file system</dd>

<dt><a name="1015843"> </a><code>#define vfsFilesystemType_NTFS 'ntfs'</code></dt>
<dd><a name="1015844"> </a>Windows NT file system</dd>

<dt><a name="1015845"> </a><code>#define vfsFilesystemType_VFAT 'vfat'</code></dt>
<dd><a name="1015846"> </a>FAT32, FAT16, and FAT12 extended to handle long filenames</dd>

</dl>

<h3 class="hbH3">
  <a name="1016238"> </a>Open Mode Constants <a href="#992934"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="1016290"> </a>Purpose 
</h4>

<p><a name="1016412"> </a>Modes in which a file or directory is opened. They are used for the <code>openMode</code> parameter to the <a href="VFSMgr.html#995477"><code>VFSFileOpen()</code></a> function.</p>
<h4>
  <a name="1016535"> </a>Declared In 
</h4>
<code>VFSMgr.h<a name="1016598"> </a></code><h4>
  <a name="1016655"> </a>Constants 
</h4>

<dl>
<dt><a name="1018104"> </a><code>#define vfsModeAll (vfsModeExclusive | vfsModeRead | vfsModeWrite | vfsModeCreate | vfsModeTruncate | vfsModeReadWrite | vfsModeLeaveOpen)</code></dt>
<dd><a name="1018105"> </a>The complete set of open modes.</dd>

<dt><a name="1018106"> </a><code>#define vfsModeCreate (0x0008U)</code></dt>
<dd><a name="1018107"> </a>Create the file if it doesn't already exist. This open mode is implemented in the VFS layer, rather than in the file system library.</dd>

<dt><a name="1018108"> </a><code>#define vfsModeExclusive (0x0001U)</code></dt>
<dd><a name="1018109"> </a>Open and lock the file or directory. This mode excludes anyone else from using the file or directory until it is closed. </dd>

<dt><a name="1018110"> </a><code>#define vfsModeLeaveOpen (0x0020U)</code></dt>
<dd><a name="1018817"> </a>Leave the file open even after the application exits.</dd>

<dt><a name="1018112"> </a><code>#define vfsModeRead (0x0002U)</code></dt>
<dd><a name="1018113"> </a>Open for read access.</dd>

<dt><a name="1018114"> </a><code>#define vfsModeReadWrite (vfsModeWrite | vfsModeRead)</code></dt>
<dd><a name="1018115"> </a>Open for read/write access.</dd>

<dt><a name="1018116"> </a><code>#define vfsModeTruncate (0x0010U)</code></dt>
<dd><a name="1018117"> </a>Truncate the file to zero (0) bytes after opening, removing all existing data. This open mode is implemented in the VFS layer, rather than in the file system library. </dd>

<dt><a name="1018118"> </a><code>#define vfsModeVFSLayerOnly (vfsModeCreate | vfsModeTruncate)</code></dt>
<dd><a name="1018119"> </a>Mask used to isolate those flags that are only used by the VFS layer. These flags are not passed to the file system layer.</dd>

<dt><a name="1018120"> </a><code>#define vfsModeWrite (0x0004U | vfsModeExclusive)</code></dt>
<dd><a name="1018121"> </a>Open for write access.</dd>

</dl>

<h3 class="hbH3">
  <a name="1018829"> </a>File and Directory Attributes <a href="#992934"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="1018882"> </a>Purpose 
</h4>

<p><a name="1018939"> </a>Bits that can be used individually or in combination when setting or interpreting the file attributes for a given file or directory. See <a href="VFSMgr.html#995318"><code>VFSFileGetAttributes()</code></a>, <a href="VFSMgr.html#996163"><code>VFSFileSetAttributes()</code></a>, and the <a href="VFSMgr.html#992950">FileInfoType</a> data structure for specific use.</p>
<h4>
  <a name="1020729"> </a>Declared In 
</h4>
<code>VFSMgr.h<a name="1020784"> </a></code><h4>
  <a name="1021005"> </a>Constants 
</h4>

<dl>
<dt><a name="1022520"> </a><code>#define vfsFileAttrAll (0x0000007fUL)</code></dt>
<dd><a name="1022521"> </a>The complete set of file and directory attributes.</dd>

<dt><a name="1022522"> </a><code>#define vfsFileAttrArchive (0x00000020UL)</code></dt>
<dd><a name="1022523"> </a>Archived file or directory</dd>

<dt><a name="1022524"> </a><code>#define vfsFileAttrDirectory (0x00000010UL)</code></dt>
<dd><a name="1022525"> </a>Directory</dd>

<dt><a name="1022526"> </a><code>#define vfsFileAttrHidden (0x00000002UL)</code></dt>
<dd><a name="1022527"> </a>Hidden file or directory</dd>

<dt><a name="1022528"> </a><code>#define vfsFileAttrLink (0x00000040UL)</code></dt>
<dd><a name="1022529"> </a>Link to another file or directory</dd>

<dt><a name="1022530"> </a><code>#define vfsFileAttrReadOnly (0x00000001UL)</code></dt>
<dd><a name="1022531"> </a>Read-only file or directory</dd>

<dt><a name="1022532"> </a><code>#define vfsFileAttrSystem (0x00000004UL)</code></dt>
<dd><a name="1022533"> </a>System file or directory</dd>

<dt><a name="1022534"> </a><code>#define vfsFileAttrVolumeLabel (0x00000008UL)</code></dt>
<dd><a name="1022535"> </a>Volume label</dd>

</dl>

<h3 class="hbH3">
  <a name="1022698"> </a>Volume Attributes <a href="#992934"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="1022737"> </a>Purpose 
</h4>

<p><a name="1022826"> </a>Bits that can be used individually or in combination to make up the attributes field in the <a href="VFSMgr.html#993429"><code>VolumeInfoType</code></a> structure.</p>
<h4>
  <a name="1022891"> </a>Declared In 
</h4>
<code>VFSMgr.h<a name="1022931"> </a></code><h4>
  <a name="1022935"> </a>Constants 
</h4>

<dl>
<dt><a name="1023051"> </a><code>#define vfsVolumeAttrHidden (0x00000004UL)</code></dt>
<dd><a name="1023052"> </a>The volume should not be visible to the user.</dd>

<dt><a name="1023053"> </a><code>#define vfsVolumeAttrReadOnly (0x00000002UL)</code></dt>
<dd><a name="1023054"> </a>The volume is read only.</dd>

<dt><a name="1023055"> </a><code>#define vfsVolumeAttrSlotBased (0x00000001UL)</code></dt>
<dd><a name="1023056"> </a>Reserved. Check the mount class to determine how a volume is mounted.</dd>

</dl>

<h3 class="hbH3">
  <a name="1023080"> </a>Volume Mount Classes <a href="#992934"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="1023282"> </a>Purpose 
</h4>

<p><a name="1024562"> </a>Define how a given volume is mounted. The <code>mountClass</code> field in the <a href="VFSMgr.html#993069"><code>VFSAnyMountParamType</code></a> and <a href="VFSMgr.html#993429"><code>VolumeInfoType</code></a> structures takes on one of these values.</p>
<h4>
  <a name="1024851"> </a>Declared In 
</h4>
<code>VFSMgr.h<a name="1024949"> </a></code><h4>
  <a name="1025244"> </a>Constants 
</h4>

<dl>
<dt><a name="1028460"> </a><code>#define vfsMountClass_POSE 'pose'</code></dt>
<dd><a name="1028461"> </a>Mount the volume through Palm OS Emulator. This is used for testing.</dd>

<dt><a name="1028462"> </a><code>#define vfsMountClass_POSE_BE 'esop'</code></dt>
<dd><a name="1028463"> </a>Mount the volume through Palm OS Emulator, using big-endan ordering. This is used for testing.</dd>

<dt><a name="1028464"> </a><code>#define vfsMountClass_SlotDriver sysFileTSlotDriver</code></dt>
<dd><a name="1028465"> </a>Mount the volume with a slot driver shared library.</dd>

<dt><a name="1028466"> </a><code>#define vfsMountClass_SlotDriver_BE 'sbil'</code></dt>
<dd><a name="1028801"> </a>Mount the volume with a slot driver shared library, using big-endian ordering.</dd>

</dl>

<h3 class="hbH3">
  <a name="1070095"> </a>Date Types <a href="#992934"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="1070116"> </a>Purpose 
</h4>

<p><a name="1070147"> </a>Dates that can be obtained for an open file or directory.</p>
<h4>
  <a name="1070168"> </a>Declared In 
</h4>
<code>VFSMgr.h<a name="1070171"> </a></code><h4>
  <a name="1070176"> </a>Constants 
</h4>

<dl>
<dt><a name="1070325"> </a><code>#define vfsFileDateAccessed (3)</code></dt>
<dd><a name="1070326"> </a>Date the file was last accessed.</dd>

<dt><a name="1070327"> </a><code>#define vfsFileDateCreated (1)</code></dt>
<dd><a name="1070328"> </a>File creation date.</dd>

<dt><a name="1070329"> </a><code>#define vfsFileDateModified (2)</code></dt>
<dd><a name="1070330"> </a>Date the file was last modified.</dd>

</dl>
<h4>
  <a name="1070779"> </a>Comments 
</h4>

<p><a name="1070793"> </a>Use <a href="VFSMgr.html#995388"><code>VFSFileGetDate()</code></a> to obtain these dates for an open file or directory, and <a href="VFSMgr.html#996237"><code>VFSFileSetDate()</code></a> to set them.</p>

<h3 class="hbH3">
  <a name="1073903"> </a>Seek Origins <a href="#992934"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="1073904"> </a>Purpose 
</h4>

<p><a name="1073905"> </a>File positions to which an offset is added (or subtracted, if the offset is negative) to get a seek position within the file.</p>
<h4>
  <a name="1073906"> </a>Declared In 
</h4>
<code>VFSMgr.h<a name="1073907"> </a></code><h4>
  <a name="1073908"> </a>Compatibility 
</h4>

<dl>
<dt><a name="1073909"> </a><code>#define vfsOriginBeginning (0)</code></dt>
<dd><a name="1073910"> </a>The beginning of the file.</dd>

<dt><a name="1073911"> </a><code>#define vfsOriginCurrent (1)</code></dt>
<dd><a name="1073912"> </a>The current position within the file.</dd>

<dt><a name="1073913"> </a><code>#define vfsOriginEnd (2)</code></dt>
<dd><a name="1073914"> </a>The end of the file. Only negative offsets are allowed when <code>origin</code> is set to <code>vfsOriginEnd</code>.</dd>

</dl>

<h3 class="hbH3">
  <a name="1074902"> </a>Iterator Controls and Constants <a href="#992934"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="1074903"> </a>Purpose 
</h4>

<p><a name="1074904"> </a>Control the directory and volume iteration process.</p>
<h4>
  <a name="1074905"> </a>Declared In 
</h4>
<code>VFSMgr.h<a name="1074906"> </a></code><h4>
  <a name="1074907"> </a>Constants 
</h4>

<dl>
<dt><a name="1074908"> </a><code>#define vfsIteratorStart (0L)</code></dt>
<dd><a name="1074909"> </a>Start iterating.</dd>

<dt><a name="1074910"> </a><code>#define vfsIteratorStop (0xffffffffL)</code></dt>
<dd><a name="1074911"> </a>Iteration is complete.</dd>

<dt><a name="1075003"> </a><code>#define vfsInvalidFileRef (0L)</code></dt>
<dd><a name="1075082"> </a>There are no more files to be enumerated or an error occurred.</dd>

<dt><a name="1075005"> </a><code>#define vfsInvalidVolRef (0)</code></dt>
<dd><a name="1075006"> </a>There are no more volumes to be enumerated or an error occurred.</dd>

</dl>
<h4>
  <a name="1074937"> </a>Comments 
</h4>

<p><a name="1074956"> </a>To iterate the contents of a directory, use <a href="VFSMgr.html#994232"><code>VFSDirEntryEnumerate()</code></a>. To iterate the contents of a volume, use <a href="VFSMgr.html#997470"><code>VFSVolumeEnumerate()</code></a>.</p>

<h3 class="hbH3">
  <a name="1075555"> </a>Volume Mount Flags <a href="#992934"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="1075556"> </a>Purpose 
</h4>

<p><a name="1075557"> </a>Flags that control how a volume is mounted.</p>
<h4>
  <a name="1075558"> </a>Declared In 
</h4>
<code>VFSMgr.h<a name="1075559"> </a></code><h4>
  <a name="1075560"> </a>Constants 
</h4>

<dl>
<dt><a name="1075561"> </a><code>#define vfsMountFlagsReserved1 (0x08)</code></dt>
<dd><a name="1075562"> </a>Reserved for future use.</dd>

<dt><a name="1075563"> </a><code>#define vfsMountFlagsReserved2 (0x10)</code></dt>
<dd><a name="1075564"> </a>Reserved for future use.</dd>

<dt><a name="1075565"> </a><code>#define vfsMountFlagsReserved3 (0x20)</code></dt>
<dd><a name="1075566"> </a>Reserved for future use.</dd>

<dt><a name="1075567"> </a><code>#define vfsMountFlagsReserved4 (0x40)</code></dt>
<dd><a name="1075568"> </a>Reserved for future use.</dd>

<dt><a name="1075569"> </a><code>#define vfsMountFlagsReserved5 (0x80)</code></dt>
<dd><a name="1075570"> </a>Reserved for future use.</dd>

<dt><a name="1075571"> </a><code>#define vfsMountFlagsUseThisFileSystem (0x01)</code></dt>
<dd><a name="1075572"> </a>Pass this flag to cause the volume to be mounted or formatted using the file system specified by the specified file system.</dd>

</dl>
<h4>
  <a name="1075573"> </a>Comments 
</h4>

<p><a name="1075577"> </a>Volumes can be mounted explicitly, with <a href="VFSMgr.html#997713"><code>VFSVolumeMount()</code></a>, or as part of the volume format process, done with <a href="VFSMgr.html#997555"><code>VFSVolumeFormat()</code></a>.</p>

<p><a name="1075581"> </a>Pass no flags (0) to have the VFS Manager attempt to mount or format the volume using a file system appropriate to the slot.</p>

<h3 class="hbH3">
  <a name="993501"> </a>Miscellaneous Constants and Definitions <a href="#992934"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="993503"> </a>Purpose 
</h4>

<p><a name="993506"> </a>The VFS Manager also includes these <code>#defines</code>.</p>
<h4>
  <a name="993508"> </a>Declared In 
</h4>
<code>VFSMgr.h<a name="993511"> </a></code><h4>
  <a name="993513"> </a>Constants 
</h4>

<dl>
<dt><a name="993516"> </a><code>#define SIZEOF_LargestVFSMountParamType (128)</code></dt>
<dd><a name="993518"> </a></dd>

<dt><a name="993520"> </a><code>#define SIZEOF_VFSAnyMountParamType (8)</code></dt>
<dd><a name="993522"> </a></dd>

<dt><a name="993524"> </a><code>#define SIZEOF_VFSPOSEMountParamType (SIZEOF_VFSAnyMountParamType + 4)</code></dt>
<dd><a name="993526"> </a></dd>

<dt><a name="993528"> </a><code>#define SIZEOF_VFSSlotMountParamType (SIZEOF_VFSAnyMountParamType + 4)</code></dt>
<dd><a name="993530"> </a></dd>

<dt><a name="993716"> </a><code>#define vfsFtrIDDefaultFS (1)</code></dt>
<dd><a name="1087005"> </a>Feature number used in conjunction with a creator ID of <code>sysFileCVFSMgr</code> to determine the device's default filesystem.</dd>

<dt><a name="993720"> </a><code>#define vfsFtrIDVersion (0)</code></dt>
<dd><a name="993722"> </a>Feature number used to obtain the version of the VFS Manager in the device's ROM. Use this number in conjunction with a creator ID of <code>sysFileCVFSMgr</code>.</dd>

<dt><a name="993724"> </a><code>#define vfsHandledStartPrc (0x02)</code></dt>
<dd><a name="993726"> </a></dd>

<dt><a name="993728"> </a><code>#define vfsHandledUIAppSwitch (0x01)</code></dt>
<dd><a name="993730"> </a></dd>

<dt><a name="993756"> </a><code>#define vfsMgrVersionNum ((uint16_t)300)</code></dt>
<dd><a name="993758"> </a>The version of the VFS Manager APIs in this SDK. Compare this to the value of the <code>vfsFtrIDVersion</code> feature.</dd>

</dl>

<h2 class="haH2">
  <a name="1074104"> </a>VFS Manager Functions and Macros <a href="#992934"><span class="nav">^TOP^</span></a>
</h2>


<h3 class="hbH3">
  <a name="1072937"> </a>VFSCustomControl Function <a href="#992934"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="994081"> </a>Purpose 
</h4>

<p><a name="994084"> </a>Make a custom API call to a particular file system, given its creator ID. You can use <a href="VFSMgr.html#997667"><code>VFSVolumeInfo()</code></a> to determine the creator ID of the file system for a given volume.</p>
<h4>
  <a name="994086"> </a>Declared In 
</h4>
<code>VFSMgr.h<a name="994089"> </a></code><h4>
  <a name="994091"> </a>Prototype 
</h4>
<pre class="proto"><a name="994094"></a>status_t VFSCustomControl (
   uint32_t <code class="par">fsCreator</code>,
   uint32_t <code class="par">apiCreator</code>,
   uint16_t <code class="par">apiSelector</code>,
   void <code class="par">*valueP</code>,
   uint16_t <code class="par">*valueLenP</code>
)
</pre>
<h4>
  <a name="994096"> </a>Parameters 
</h4>

<dl>
<dt><a name="994099"> </a><code>&rarr;  <i>fsCreator</i></code></dt>
<dd><a name="994101"> </a>Creator of the file system to call. A value of zero (0) tells the VFS Manager to check each registered file system, looking for one which supports the call.</dd>

<dt><a name="994103"> </a><code>&rarr;  <i>apiCreator</i></code></dt>
<dd><a name="994105"> </a>Registered creator ID.</dd>

<dt><a name="994107"> </a><code>&rarr;  <i>apiSelector</i></code></dt>
<dd><a name="994109"> </a>Custom operation to perform.</dd>

<dt><a name="994111"> </a><code>&harr;  <i>valueP</i></code></dt>
<dd><a name="994113"> </a>A pointer to a buffer containing data specific to the operation. On exit, depending on the function of the particular custom call and on the value of <code>valueLenP</code>, the contents of this buffer may have been updated.</dd>

<dt><a name="994115"> </a><code>&harr;  <i>valueLenP</i></code></dt>
<dd><a name="994117"> </a>On entry, points to the size of the <code>valueP</code> buffer. On exit, this value reflects the size of the data written to the <code>valueP</code> buffer. If <code>valueLenP</code> is <code>NULL</code>, <code>valueP</code> is passed to the file system but is not updated on exit.</dd>

</dl>
<h4>
  <a name="994119"> </a>Returns 
</h4>

<p><a name="1032735"> </a>Returns <code>errNone</code> if the operation completed successfully, or one of the following otherwise:</p>

<dl>
<dt><a name="1032737"> </a><code>expErrNotOpen</code></dt>
<dd><a name="1032777"> </a>The file system library necessary for this call has not been installed or has not been opened.</dd>

<dt><a name="1032738"> </a><code>expErrUnsupportedOperation</code></dt>
<dd><a name="1032782"> </a>The specified opcode and/or creator is unsupported or undefined.</dd>

<dt><a name="1032739"> </a><code>sysErrParamErr</code></dt>
<dd><a name="1034564"> </a>The <code class="par">valueP</code> buffer is too small.</dd>

<dt><a name="994122"> </a><code>vfsErrNoFileSystem</code></dt>
<dd><a name="1033022"> </a>VFS Manager cannot find an appropriate file system to handle the request.</dd>

</dl>
<h4>
  <a name="994124"> </a>Comments 
</h4>

<p><a name="1034805"> </a>The driver identifies the call and its API by a registered creator ID and a selector. This allows file system developers to extend the API by defining selectors for their creator IDs. It also allows file system developers to support selectors (and custom calls) defined by other file system developers. </p>

<p><a name="994127"> </a>This function must return <code>expErrUnsupportedOperation</code> for all unsupported or undefined opcodes and/or creators.</p>

<h3 class="hbH3">
  <a name="994162"> </a>VFSDirCreate Function <a href="#992934"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="994191"> </a>Purpose 
</h4>

<p><a name="994194"> </a>Create a new directory.</p>
<h4>
  <a name="994196"> </a>Declared In 
</h4>
<code>VFSMgr.h<a name="994199"> </a></code><h4>
  <a name="994201"> </a>Prototype 
</h4>
<pre class="proto"><a name="994204"></a>status_t VFSDirCreate (
   uint16_t <code class="par">volRefNum</code>,
   const char <code class="par">*dirNameP</code>
)
</pre>
<h4>
  <a name="994206"> </a>Parameters 
</h4>

<dl>
<dt><a name="994209"> </a><code>&rarr;  <i>volRefNum</i></code></dt>
<dd><a name="994211"> </a>Volume reference number returned from <a href="VFSMgr.html#997470"><code>VFSVolumeEnumerate()</code></a>.</dd>

<dt><a name="994213"> </a><code>&rarr;  <i>dirNameP</i></code></dt>
<dd><a name="994215"> </a>Pointer to the full path of the directory to be created.</dd>

</dl>
<h4>
  <a name="994217"> </a>Returns 
</h4>

<p><a name="1075679"> </a>Returns <code>errNone</code> if the operation completed successfully, or one of the following otherwise:</p>

<dl>
<dt><a name="1035057"> </a><code><code>expErrNotOpen</code></code></dt>
<dd><a name="1035342"> </a>The file system library necessary for this call has not been installed or has not been opened.</dd>

<dt><a name="1035058"> </a><code><code>vfsErrBadName</code></code></dt>
<dd><a name="1035383"> </a>Some or all of the path, up to but not including the last component specified in the <code class="par">dirNameP</code> parameter, does not exist.</dd>

<dt><a name="1035059"> </a><code><code>vfsErrFileAlreadyExists</code></code></dt>
<dd><a name="1035384"> </a>A file with this name already exists in this location.</dd>

<dt><a name="1035060"> </a><code><code>vfsErrNoFileSystem</code></code></dt>
<dd><a name="1035425"> </a>The VFS Manager cannot find an appropriate file system to handle the request.</dd>

<dt><a name="1035061"> </a><code><code>vfsErrVolumeBadRef</code></code></dt>
<dd><a name="1035466"> </a>The volume has not been mounted.</dd>

<dt><a name="1035062"> </a><code><code>vfsErrVolumeFull</code></code></dt>
<dd><a name="1035507"> </a>There is not enough space left on the volume.</dd>

</dl>
<h4>
  <a name="994222"> </a>Comments 
</h4>

<p><a name="1035549"> </a>All parts of the path except the last component must already exist. The <code>vfsFileAttrDirectory</code> attribute is set with this function.</p>

<p><a name="1035553"> </a><a href="VFSMgr.html#994162"><code>VFSDirCreate()</code></a> does not open the directory. Any operations you want to perform on this directory require a reference, which is obtained through a call to <a href="VFSMgr.html#995477"><code>VFSFileOpen()</code></a>.</p>

<h3 class="hbH3">
  <a name="994232"> </a>VFSDirEntryEnumerate Function <a href="#992934"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="994237"> </a>Purpose 
</h4>

<p><a name="994240"> </a>Enumerate the entries in a given directory. Entries can include files, links, and other directories.</p>
<h4>
  <a name="994242"> </a>Declared In 
</h4>
<code>VFSMgr.h<a name="994245"> </a></code><h4>
  <a name="994247"> </a>Prototype 
</h4>
<pre class="proto"><a name="994250"></a>status_t VFSDirEntryEnumerate (
   FileRef <code class="par">dirRef</code>,
   uint32_t <code class="par">*dirEntryIteratorP</code>,
   FileInfoType <code class="par">*infoP</code>
)
</pre>
<h4>
  <a name="994252"> </a>Parameters 
</h4>

<dl>
<dt><a name="994255"> </a><code>&rarr;  <i>dirRef</i></code></dt>
<dd><a name="994257"> </a>Directory reference returned from <a href="VFSMgr.html#995477"><code>VFSFileOpen()</code></a>.</dd>

<dt><a name="994259"> </a><code>&harr;  <i>dirEntryIteratorP</i></code></dt>
<dd><a name="994261"> </a>Pointer to the index of the last entry enumerated. For the first iteration, initialize this parameter to the constant <code>vfsIteratorStart</code>. Upon return, this references the next entry in the directory. If <code>infoP</code> is the last entry, this parameter is set to <code>vfsIteratorStop</code>.</dd>

<dt><a name="994263"> </a><code>&harr;  <i>infoP</i></code></dt>
<dd><a name="994265"> </a>Pointer to the <a href="VFSMgr.html#992950"><code>FileInfoType</code></a> data structure that contains information about the given directory entry. The <code>nameP</code> and <code>nameBufLen</code> fields in this structure must be initialized prior to calling <code>VFSDirEntryEnumerate</code>.</dd>

</dl>
<h4>
  <a name="994267"> </a>Returns 
</h4>

<p><a name="1075684"> </a>Returns <code>errNone</code> if the operation completed successfully, or one of the following otherwise:</p>

<dl>
<dt><a name="1035644"> </a><code><code>expErrEnumerationEmpty</code></code></dt>
<dd><a name="1036370"> </a>There are no directory entries left to enumerate.</dd>

<dt><a name="1035645"> </a><code><code>expErrNotOpen</code></code></dt>
<dd><a name="1036371"> </a>The file system library necessary for this call has not been installed or has not been opened.</dd>

<dt><a name="1035646"> </a><code><code>sysErrParamErr</code></code></dt>
<dd><a name="1036372"> </a>The <code class="par">dirEntryIteratorP</code> is not valid.</dd>

<dt><a name="1035647"> </a><code><code>vfsErrFileBadRef</code></code></dt>
<dd><a name="1036373"> </a>The specified file reference is invalid.</dd>

<dt><a name="1035648"> </a><code><code>vfsErrIsNotADirectory</code></code></dt>
<dd><a name="1036374"> </a>The specified file reference is valid, but does not point to a directory. </dd>

<dt><a name="1035649"> </a><code><code>vfsErrNoFileSystem</code></code></dt>
<dd><a name="1036375"> </a>The VFS Manager cannot find an appropriate file system to handle the request.</dd>

</dl>
<h4>
  <a name="994272"> </a>Comments 
</h4>

<p><a name="1035912"> </a>The directory to be enumerated must first be opened with <a href="VFSMgr.html#995477"><code>VFSFileOpen()</code></a> in order to obtain a file reference. In order to obtain information on all entries in a directory you must make repeated calls to <code>VFSDirEntryEnumerate</code> inside a loop. Boundaries on the iteration are the defined constants <code>vfsIteratorStart</code> and <code>vfsIteratorStop</code>. Before the first call to <code>VFSDirEntryEnumerate</code>, <code>dirEntryIteratorP</code> should be initialized to <code>vfsIteratorStart</code>. Each iteration then changes the value pointed to by <code>dirEntryIteratorP</code>. When information on the last entry in the directory is returned, <code>dirEntryIteratorP</code> is set to <code>vfsIteratorStop</code>.</p>

<div><hr>
  <a name="1035916"> </a> <span class="warning">WARNING! </span> Creating, renaming, or deleting any file or directory invalidates the enumeration. After any such operation, the enumeration will need to be restarted.
<hr>
</div>
<h4>
  <a name="1035917"> </a>Example 
</h4>

<p><a name="1035918"> </a>The following code excerpt illustrates how to use <code>VFSDirEntryEnumerate</code>.</p>

<div class="CodeRule"><hr></div><pre class="CodeBlock">
FileInfoType info;<a name="1035919"> </a>
FileRef dirRef;<a name="1035920"> </a>
UInt32 dirIterator;<a name="1035921"> </a>
char *fileName = MemPtrNew(256);  // should check for err<a name="1035922"> </a>
 <a name="1035923"> </a>
// open the directory first, to get the directory reference<a name="1035924"> </a>
// volRefNum must have already been defined<a name="1035925"> </a>
err = VFSFileOpen(volRefNum, "/", vfsModeRead, &amp;dirRef);<a name="1035926"> </a>
if(err == errNone) {<a name="1035927"> </a>
 <a name="1035928"> </a>
   info.nameP = fileName;    // point to local buffer<a name="1035929"> </a>
   info.nameBufLen = 256;<a name="1035930"> </a>
   dirIterator = vfsIteratorStart<a name="1035931"> </a>
   while (dirIterator != vfsIteratorStop) {<a name="1035932"> </a>
      // Get the next file<a name="1035933"> </a>
      err = VFSDirEntryEnumerate (dirRef, &amp;dirIterator,
         &amp;info);<a name="1035934"> </a>
      if (err == errNone) {<a name="1035935"> </a>
         // Do something with the directory entry information<a name="1035936"> </a>
         // Pull the attributes from info.attributes<a name="1035937"> </a>
         // The file name is in fileName<a name="1035938"> </a>
      } else {<a name="1035939"> </a>
         // handle error, possibly by breaking out of the 
loop<a name="1035940"> </a>
      }<a name="1035941"> </a>
   } else {<a name="1035942"> </a>
      // handle directory open error here<a name="1035943"> </a>
   }<a name="1035944"> </a>
   MemPtrFree(fileName);<a name="1035945"> </a>
}<a name="1035946"> </a>
</pre><div class="CodeRule"><hr></div>


<h3 class="hbH3">
  <a name="994325"> </a>VFSExportDatabaseToFile Function <a href="#992934"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="994354"> </a>Purpose 
</h4>

<p><a name="994357"> </a>Save the specified database to a PDB or PRC file on an external storage card.</p>
<h4>
  <a name="994359"> </a>Declared In 
</h4>
<code>VFSMgr.h<a name="994362"> </a></code><h4>
  <a name="994364"> </a>Prototype 
</h4>
<pre class="proto"><a name="994367"></a>status_t VFSExportDatabaseToFile (
   uint16_t <code class="par">volRefNum</code>,
   const char <code class="par">*pathNameP</code>,
   DatabaseID <code class="par">dbID</code>
)
</pre>
<h4>
  <a name="994369"> </a>Parameters 
</h4>

<dl>
<dt><a name="994372"> </a><code>&rarr;  <i>volRefNum</i></code></dt>
<dd><a name="994374"> </a>Volume on which the destination file should be created.</dd>

<dt><a name="994376"> </a><code>&rarr;  <i>pathNameP</i></code></dt>
<dd><a name="994378"> </a>Pointer to the complete path and name of the destination file to be created.</dd>

<dt><a name="994380"> </a><code>&rarr;  <i>dbID</i></code></dt>
<dd><a name="994382"> </a>ID of the database being exported.</dd>

</dl>
<h4>
  <a name="994384"> </a>Returns 
</h4>

<p><a name="1075691"> </a>Returns <code>errNone</code> if the operation completed successfully, or one of the following otherwise:</p>

<dl>
<dt><a name="1036955"> </a><code><code>expErrNotEnoughPower</code></code></dt>
<dd><a name="1036963"> </a>There is insufficient battery power to perform the database export operation.</dd>

<dt><a name="1037085"> </a><code><code>vfsErrBadName</code></code></dt>
<dd><a name="1037086"> </a>The path name specified in <code class="par">pathNameP</code> is not valid.</dd>

</dl>
<h4>
  <a name="1037087"> </a>Comments 
</h4>

<p><a name="1037091"> </a>This utility function exports a database from main memory to a PDB or PRC file on an external storage card. This function is the opposite of <a href="VFSMgr.html#996612"><code>VFSImportDatabaseFromFile()</code></a>. It first creates the file specified in the <code>pathNameP</code> parameter with <a href="VFSMgr.html#994627"><code>VFSFileCreate()</code></a>. After opening the file the Exchange Manager function <a href="../High-Level_Communications/HLC_ExgMgrRef.html#1269343"><code>ExgDBWrite()</code></a> is called with an internal callback function for exporting the file from the Data Manager. The Exchange Manager makes repeated calls to this callback function, which receives the data back in blocks. Once all the data has been exported, VFS Manager closes the file.</p>

<p><a name="1037101"> </a>This function is used, for example, to copy applications from main memory to a storage card.</p>
<h4>
  <a name="994394"> </a>See Also 
</h4>

<p><a name="1037128"> </a><a href="VFSMgr.html#994399"><code>VFSExportDatabaseToFileCustom()</code></a>, <a href="VFSMgr.html#996483"><code>VFSFileWrite()</code></a>, <a href="VFSMgr.html#996612"><code>VFSImportDatabaseFromFile()</code></a></p>

<h3 class="hbH3">
  <a name="994399"> </a>VFSExportDatabaseToFileCustom Function <a href="#992934"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="994404"> </a>Purpose 
</h4>

<p><a name="994407"> </a>Save the specified database to a PDB or PRC file on an external storage card. This function differs from <a href="VFSMgr.html#994325"><code>VFSExportDatabaseToFile()</code></a> in that it allows you to track the progress of the export operation.</p>
<h4>
  <a name="994409"> </a>Declared In 
</h4>
<code>VFSMgr.h<a name="994412"> </a></code><h4>
  <a name="994414"> </a>Prototype 
</h4>
<pre class="proto"><a name="994417"></a>status_t VFSExportDatabaseToFileCustom (
   uint16_t <code class="par">volRefNum</code>,
   const char <code class="par">*pathNameP</code>,
   DatabaseID <code class="par">dbID</code>,
   VFSExportProcPtr <code class="par">exportProcP</code>,
   void <code class="par">*userDataP</code>
)
</pre>
<h4>
  <a name="994419"> </a>Parameters 
</h4>

<dl>
<dt><a name="994422"> </a><code>&rarr;  <i>volRefNum</i></code></dt>
<dd><a name="994424"> </a>Volume on which the destination file should be created.</dd>

<dt><a name="994426"> </a><code>&rarr;  <i>pathNameP</i></code></dt>
<dd><a name="994428"> </a>Pointer to the complete path and name of the destination file to be created.</dd>

<dt><a name="994434"> </a><code>&rarr;  <i>dbID</i></code></dt>
<dd><a name="994436"> </a>ID of the database being exported.</dd>

<dt><a name="994438"> </a><code>&rarr;  <i>exportProcP</i></code></dt>
<dd><a name="994440"> </a>User-defined callback function that tracks the progress of the export. This function should allow the user to cancel the export. Pass <code>NULL</code> if you don't have a progress callback function. See <a href="VFSMgr.html#997944"><code>VFSExportProcPtr()</code></a> for the requirements of this function.</dd>

<dt><a name="994442"> </a><code>&rarr;  <i>userDataP</i></code></dt>
<dd><a name="994444"> </a>Pointer to any data you want to pass to the callback function specified in <code>exportProcP</code>. This information is not used internally by the VFS Manager. Pass <code>NULL</code> if you don't have a progress callback function or if that function doesn't need any such data.</dd>

</dl>
<h4>
  <a name="994446"> </a>Returns 
</h4>

<p><a name="1075696"> </a>Returns <code>errNone</code> if the operation completed successfully, or one of the following otherwise:</p>

<dl>
<dt><a name="1037210"> </a><code><code>expErrNotEnoughPower</code></code></dt>
<dd><a name="1037443"> </a>There is insufficient battery power to perform the database export operation.</dd>

<dt><a name="1037211"> </a><code><code>vfsErrBadName</code></code></dt>
<dd><a name="1037494"> </a>The path name specified in <code class="par">pathNameP</code> is not valid.</dd>

</dl>

<p><a name="1037212"> </a>This function can also return any error code other than <code>errNone</code> produced by your callback function.</p>
<h4>
  <a name="994451"> </a>Comments 
</h4>

<p><a name="1037499"> </a>This function is similar to <a href="VFSMgr.html#994325"><code>VFSExportDatabaseToFile()</code></a> in that it exports a database from main memory to a PDB or PRC file on an external storage card. It extends the functionality by allowing you to specify a callback function that tracks the progress of the export. It first creates the file specified in the <code>pathNameP</code> parameter with <a href="VFSMgr.html#994627"><code>VFSFileCreate()</code></a>. After opening the file, the Exchange Manager function <a href="../High-Level_Communications/HLC_ExgMgrRef.html#1269343"><code>ExgDBWrite()</code></a> is called with an internal callback function for exporting the file from the Data Manager. Exchange Manager makes repeated calls to this function, which receives the data back in blocks. The progress tracker, if one has been specified, is also called every time a new chunk of data is passed back. Once all the data has been exported, the VFS Manager closes the file.</p>
<h4>
  <a name="994456"> </a>See Also 
</h4>

<p><a name="1037694"> </a><a href="VFSMgr.html#994325"><code>VFSExportDatabaseToFile()</code></a>, <a href="VFSMgr.html#996483"><code>VFSFileWrite()</code></a>, <a href="VFSMgr.html#996934"><code>VFSImportDatabaseFromFileCustom()</code></a></p>

<h3 class="hbH3">
  <a name="994461"> </a>VFSExportDatabaseToFileCustomV40 Function <a href="#992934"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="994466"> </a>Purpose 
</h4>

<p><a name="994469"> </a>Save the specified database to a PDB or PRC file on an external storage card. This function differs from <a href="VFSMgr.html#994325"><code>VFSExportDatabaseToFile()</code></a> in that it allows you to track the progress of the export operation.</p>
<h4>
  <a name="994471"> </a>Declared In 
</h4>
<code>VFSMgr.h<a name="994474"> </a></code><h4>
  <a name="994476"> </a>Prototype 
</h4>
<pre class="proto"><a name="994479"></a>status_t VFSExportDatabaseToFileCustomV40 (
   uint16_t <code class="par">volRefNum</code>,
   const char <code class="par">*pathNameP</code>,
   uint16_t <code class="par">cardNo</code>,
   LocalID <code class="par">dbID</code>,
   VFSExportProcPtr <code class="par">exportProcP</code>,
   void <code class="par">*userDataP</code>
)
</pre>
<h4>
  <a name="994481"> </a>Parameters 
</h4>

<dl>
<dt><a name="994484"> </a><code>&rarr;  <i>volRefNum</i></code></dt>
<dd><a name="994486"> </a>Volume on which the destination file should be created.</dd>

<dt><a name="994488"> </a><code>&rarr;  <i>pathNameP</i></code></dt>
<dd><a name="994490"> </a>Pointer to the complete path and name of the destination file to be created.</dd>

<dt><a name="994492"> </a><code>&rarr;  <i>cardNo</i></code></dt>
<dd><a name="994494"> </a>Card number on which the PDB or PRC being exported resides.</dd>

<dt><a name="994496"> </a><code>&rarr;  <i>dbID</i></code></dt>
<dd><a name="994502"> </a>ID of the database being exported.</dd>

<dt><a name="994504"> </a><code>&rarr;  <i>exportProcP</i></code></dt>
<dd><a name="994506"> </a>User-defined callback function that tracks the progress of the export. This function should allow the user to cancel the export. Pass <code>NULL</code> if you don't have a progress callback function. See <a href="VFSMgr.html#997944"><code>VFSExportProcPtr()</code></a> for the requirements of this function.</dd>

<dt><a name="994508"> </a><code>&rarr;  <i>userDataP</i></code></dt>
<dd><a name="994510"> </a>Pointer to any data you want to pass to the callback function specified in <code>exportProcP</code>. This information is not used internally by the VFS Manager. Pass <code>NULL</code> if you don't have a progress callback function or if that function doesn't need any such data.</dd>

</dl>
<h4>
  <a name="994512"> </a>Returns 
</h4>

<p><a name="1075714"> </a>Returns <code>errNone</code> if the operation completed successfully, or one of the following otherwise:</p>

<dl>
<dt><a name="1038078"> </a><code><code>expErrNotEnoughPower</code></code></dt>
<dd><a name="1038079"> </a>There is insufficient battery power to perform the database export operation.</dd>

<dt><a name="1038080"> </a><code><code>vfsErrBadName</code></code></dt>
<dd><a name="1038081"> </a>The path name specified in <code class="par">pathNameP</code> is not valid.</dd>

</dl>

<p><a name="1038082"> </a>This function can also return any error code other than <code>errNone</code> produced by your callback function.</p>
<h4>
  <a name="994517"> </a>Comments 
</h4>

<p><a name="1038297"> </a>This function is similar to <a href="VFSMgr.html#994325"><code>VFSExportDatabaseToFile()</code></a> in that it exports a database from main memory to a PDB or PRC file on an external storage card. It extends the functionality by allowing you to specify a callback function that tracks the progress of the export. It first creates the file specified in the <code>pathNameP</code> parameter with <a href="VFSMgr.html#994627"><code>VFSFileCreate()</code></a>. After opening the file, the Exchange Manager function <a href="../High-Level_Communications/HLC_ExgMgrRef.html#1269343"><code>ExgDBWrite()</code></a> is called with an internal callback function for exporting the file from the Data Manager. Exchange Manager makes repeated calls to this function, which receives the data back in blocks. The progress tracker, if one has been specified, is also called every time a new chunk of data is passed back. Once all the data has been exported, the VFS Manager closes the file.</p>

<p><a name="1038304"> </a>This function is used, for example, to copy applications from main memory to a storage card.</p>
<h4>
  <a name="1060594"> </a>Compatibility 
</h4>

<p><a name="1060595"> </a>This function is only provided for compatibility with previous versions of Palm OS; the <code class="par">cardNo</code> parameter is ignored.</p>
<h4>
  <a name="994522"> </a>See Also 
</h4>

<p><a name="1038397"> </a><a href="VFSMgr.html#994325"><code>VFSExportDatabaseToFile()</code></a>, <a href="VFSMgr.html#996483"><code>VFSFileWrite()</code></a>, <a href="VFSMgr.html#996934"><code>VFSImportDatabaseFromFileCustom()</code></a></p>

<h3 class="hbH3">
  <a name="994527"> </a>VFSExportDatabaseToFileV40 Function <a href="#992934"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="994532"> </a>Purpose 
</h4>

<p><a name="1038598"> </a>Save the specified database to a PDB or PRC file on an external storage card.</p>
<h4>
  <a name="994537"> </a>Declared In 
</h4>
<code>VFSMgr.h<a name="994540"> </a></code><h4>
  <a name="994542"> </a>Prototype 
</h4>
<pre class="proto"><a name="994545"></a>status_t VFSExportDatabaseToFileV40 (
   uint16_t <code class="par">volRefNum</code>,
   const char <code class="par">*pathNameP</code>,
   uint16_t <code class="par">cardNo</code>,
   LocalID <code class="par">dbID</code>
)
</pre>
<h4>
  <a name="994547"> </a>Parameters 
</h4>

<dl>
<dt><a name="994550"> </a><code>&rarr;  <i>volRefNum</i></code></dt>
<dd><a name="1038626"> </a>Volume on which the destination file should be created.</dd>

<dt><a name="1038630"> </a><code>&rarr;  <i>pathNameP</i></code></dt>
<dd><a name="1038631"> </a>Pointer to the complete path and name of the destination file to be created.</dd>

<dt><a name="1038632"> </a><code>&rarr;  <i>cardNo</i></code></dt>
<dd><a name="1038633"> </a>Card number on which the PDB or PRC being exported resides.</dd>

<dt><a name="1038634"> </a><code>&rarr;  <i>dbID</i></code></dt>
<dd><a name="1038635"> </a>ID of the database being exported.</dd>

</dl>
<h4>
  <a name="994566"> </a>Returns 
</h4>

<p><a name="1075720"> </a>Returns <code>errNone</code> if the operation completed successfully, or one of the following otherwise:</p>

<dl>
<dt><a name="1038658"> </a><code><code>expErrNotEnoughPower</code></code></dt>
<dd><a name="1038659"> </a>There is insufficient battery power to perform the database export operation.</dd>

<dt><a name="1038660"> </a><code><code>vfsErrBadName</code></code></dt>
<dd><a name="1038661"> </a>The path name specified in <code class="par">pathNameP</code> is not valid.</dd>

</dl>
<h4>
  <a name="1038662"> </a>Comments 
</h4>

<p><a name="1038663"> </a>This utility function exports a database from main memory to a PDB or PRC file on an external storage card. This function is the opposite of <a href="VFSMgr.html#996612"><code>VFSImportDatabaseFromFile()</code></a>. It first creates the file specified in the <code>pathNameP</code> parameter with <a href="VFSMgr.html#994627"><code>VFSFileCreate()</code></a>. After opening the file the Exchange Manager function <a href="../High-Level_Communications/HLC_ExgMgrRef.html#1269343"><code>ExgDBWrite()</code></a> is called with an internal callback function for exporting the file from the Data Manager. The Exchange Manager makes repeated calls to this callback function, which receives the data back in blocks. Once all the data has been exported, VFS Manager closes the file.</p>

<p><a name="1038673"> </a>This function is used, for example, to copy applications from main memory to a storage card.</p>
<h4>
  <a name="1062223"> </a>Compatibility 
</h4>

<p><a name="1062224"> </a>This function is only provided for compatibility with previous versions of Palm OS; the <code class="par">cardNo</code> parameter is ignored.</p>
<h4>
  <a name="1038674"> </a>See Also 
</h4>

<p><a name="1038681"> </a><a href="VFSMgr.html#994399"><code>VFSExportDatabaseToFileCustom()</code></a>, <a href="VFSMgr.html#996483"><code>VFSFileWrite()</code></a>, <a href="VFSMgr.html#996612"><code>VFSImportDatabaseFromFile()</code></a></p>

<h3 class="hbH3">
  <a name="994581"> </a>VFSFileClose Function <a href="#992934"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="994590"> </a>Purpose 
</h4>

<p><a name="994593"> </a>Close a file or directory that has been opened with <a href="VFSMgr.html#995477"><code>VFSFileOpen()</code></a>.</p>
<h4>
  <a name="994595"> </a>Declared In 
</h4>
<code>VFSMgr.h<a name="994598"> </a></code><h4>
  <a name="994600"> </a>Prototype 
</h4>
<pre class="proto"><a name="994603"></a>status_t VFSFileClose (
   FileRef <code class="par">fileRef</code>
)
</pre>
<h4>
  <a name="994605"> </a>Parameters 
</h4>

<dl>
<dt><a name="994608"> </a><code>&rarr;  <i>fileRef</i></code></dt>
<dd><a name="994610"> </a>File reference number returned from <a href="VFSMgr.html#995477"><code>VFSFileOpen()</code></a>.</dd>

</dl>
<h4>
  <a name="994612"> </a>Returns 
</h4>

<p><a name="1075757"> </a>Returns <code>errNone</code> if the operation completed successfully, or one of the following otherwise:</p>

<dl>
<dt><a name="1039123"> </a><code><code>expErrNotOpen</code></code></dt>
<dd><a name="1039129"> </a>The file system library necessary for this call has not been installed or has not been opened.</dd>

<dt><a name="1039124"> </a><code><code>vfsErrFileBadRef</code></code></dt>
<dd><a name="1039130"> </a>The specified file reference is invalid.</dd>

</dl>

<h3 class="hbH3">
  <a name="994627"> </a>VFSFileCreate Function <a href="#992934"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="994632"> </a>Purpose 
</h4>

<p><a name="994635"> </a>Create a file. This function cannot be used to create a directory; use <a href="VFSMgr.html#994162"><code>VFSDirCreate()</code></a> instead.</p>
<h4>
  <a name="994637"> </a>Declared In 
</h4>
<code>VFSMgr.h<a name="994640"> </a></code><h4>
  <a name="994642"> </a>Prototype 
</h4>
<pre class="proto"><a name="994645"></a>status_t VFSFileCreate (
   uint16_t <code class="par">volRefNum</code>,
   const char <code class="par">*pathNameP</code>
)
</pre>
<h4>
  <a name="994647"> </a>Parameters 
</h4>

<dl>
<dt><a name="994650"> </a><code>&rarr;  <i>volRefNum</i></code></dt>
<dd><a name="994652"> </a>Reference number of the volume on which to create the file. This volume reference number is returned from <a href="VFSMgr.html#997470"><code>VFSVolumeEnumerate()</code></a>.</dd>

<dt><a name="994654"> </a><code>&rarr;  <i>pathNameP</i></code></dt>
<dd><a name="994656"> </a>Pointer to the full path of the file to be created. All parts of the path, excluding the filename, must already exist.</dd>

</dl>
<h4>
  <a name="994658"> </a>Returns 
</h4>

<p><a name="1077415"> </a>Returns <code>errNone</code> if the operation completed successfully, or one of the following otherwise:</p>

<dl>
<dt><a name="1039160"> </a><code><code>expErrNotOpen</code></code></dt>
<dd><a name="1039515"> </a>The file system library necessary for this call has not been installed or has not been opened.</dd>

<dt><a name="1039161"> </a><code><code>vfsErrBadName</code></code></dt>
<dd><a name="1039548"> </a>The <code class="par">pathNameP</code> is invalid.</dd>

<dt><a name="1039162"> </a><code><code>vfsErrFileAlreadyExists</code></code></dt>
<dd><a name="1039577"> </a>A file with this name already exists in this location.</dd>

<dt><a name="1039163"> </a><code><code>vfsErrNoFileSystem</code></code></dt>
<dd><a name="1039638"> </a>The VFS Manager cannot find an appropriate file system to handle the request.</dd>

<dt><a name="1039164"> </a><code><code>vfsErrVolumeBadRef</code></code></dt>
<dd><a name="1039699"> </a>The volume has not been mounted.</dd>

<dt><a name="1039165"> </a><code><code>vfsErrVolumeFull</code></code></dt>
<dd><a name="1039760"> </a>There is not enough space left on the volume.</dd>

</dl>
<h4>
  <a name="1039166"> </a>Comments 	
</h4>

<p><a name="1039167"> </a>It is the responsibility of the file system library to ensure that all filenames are translated into a format that is compatible with the native format of the file system, such as the 8.3 convention for a FAT file system without long filename support. See <a href="VFS.html#993552">"Naming Files"</a> for a description of how to construct a valid path.</p>

<p><a name="1039180"> </a>This function does not open the file. Use <a href="VFSMgr.html#995477"><code>VFSFileOpen()</code></a> to open the file. </p>

<p><a name="1039181"> </a>This function should not be used to create a directory. To create a directory use <a href="VFSMgr.html#994162"><code>VFSDirCreate()</code></a>.</p>
<h4>
  <a name="994668"> </a>See Also 
</h4>

<p><a name="994671"> </a><a href="VFSMgr.html#995187"><code>VFSFileDelete()</code></a></p>

<h3 class="hbH3">
  <a name="994673"> </a>VFSFileDBGetRecord Function <a href="#992934"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="994678"> </a>Purpose 
</h4>

<p><a name="994681"> </a>Load a record from an opened PDB file on an external card into the storage heap.</p>
<h4>
  <a name="994683"> </a>Declared In 
</h4>
<code>VFSMgr.h<a name="994686"> </a></code><h4>
  <a name="994688"> </a>Prototype 
</h4>
<pre class="proto"><a name="994691"></a>status_t VFSFileDBGetRecord (
   FileRef <code class="par">ref</code>,
   uint16_t <code class="par">recIndex</code>,
   MemHandle <code class="par">*recHP</code>,
   uint8_t <code class="par">*recAttrP</code>,
   uint32_t <code class="par">*uniqueIDP</code>
)
</pre>
<h4>
  <a name="994709"> </a>Parameters 
</h4>

<dl>
<dt><a name="994760"> </a><code>&rarr;  <i>ref</i></code></dt>
<dd><a name="994810"> </a>The file reference returned from <a href="VFSMgr.html#995477"><code>VFSFileOpen()</code></a>. Note that the open file must be a PDB file.</dd>

<dt><a name="994860"> </a><code>&rarr;  <i>recIndex</i></code></dt>
<dd><a name="994910"> </a>The index of the record to load.</dd>

<dt><a name="994912"> </a><code>&larr;  <i>recHP</i></code></dt>
<dd><a name="994914"> </a>Pointer to the record data's handle in the storage heap. If <code>NULL</code> is returned in this parameter there is either no data in this field or an error occurred reading this data from the file. If the handle is not <code>NULL</code>, you must dispose of the allocated handle using <a href="MemoryMgr.html#994259"><code>MemHandleFree()</code></a>.</dd>

<dt><a name="994916"> </a><code>&larr;  <i>recAttrP</i></code></dt>
<dd><a name="994918"> </a>Pointer to the attributes of the record. The values returned are identical to the atttributes returned from <a href="DataMgr.html#1004375"><code>DmRecordInfoV50()</code></a>. See <a href="DataMgr.html#1041655">"Non-Schema Database Record Attributes"</a> for a description of each attribute. Pass <code>NULL</code> for this parameter if you do not want to retrieve this information.</dd>

<dt><a name="994920"> </a><code>&larr;  <i>uniqueIDP</i></code></dt>
<dd><a name="994922"> </a>Pointer to the unique identifier for this record. Pass <code>NULL</code> for this parameter if you do not want to retrieve this information.</dd>

</dl>
<h4>
  <a name="994924"> </a>Returns 
</h4>

<p><a name="1077420"> </a>Returns <code>errNone</code> if the operation completed successfully, or one of the following otherwise:</p>

<dl>
<dt><a name="1040312"> </a><code><code>dmErrIndexOutOfRange</code></code></dt>
<dd><a name="1040845"> </a>The <code class="par">recIndex</code> is out of range.</dd>

<dt><a name="1040313"> </a><code><code>dmErrNotRecordDB</code></code></dt>
<dd><a name="1040887"> </a>The file referenced by <code class="par">ref</code> is not a record database.</dd>

<dt><a name="1040314"> </a><code><code>memErrNotEnoughSpace</code></code></dt>
<dd><a name="1040942"> </a>There is not enough space in memory for the requested record entry.</dd>

<dt><a name="1040315"> </a><code><code>sysErrParamErr</code></code></dt>
<dd><a name="1040943"> </a>A <code>NULL</code> value was passed in for the <code class="par">recHP</code>, <code class="par">recAttrP</code>, and <code class="par">uniqueIDP</code> parameters.</dd>

<dt><a name="1040316"> </a><code><code>vfsErrBadData</code></code></dt>
<dd><a name="1040944"> </a>The local offsets (<code>localChunkID</code>) from the top of the PDB to the start of the raw record data for this entry are out of order.</dd>

</dl>
<h4>
  <a name="1040317"> </a>Comments 
</h4>

<p><a name="1040321"> </a>This function is analogous to <a href="DataMgr.html#1000166"><code>DmGetRecord()</code></a><code> </code>but works with files on an external card rather than databases in main memory. This function allocates a handle of the appropriate size from the storage heap and returns it in the <code>recHP</code> parameter. The caller is responsible for freeing this memory, using <a href="MemoryMgr.html#994259"><code>MemHandleFree()</code></a>, when it is no longer needed.</p>

<div><hr>
  <a name="1040325"> </a> <b>NOTE: </b> This function is not efficient for multiple accesses and should be used sparingly.
<hr>
</div>
<h4>
  <a name="994934"> </a>See Also 
</h4>

<p><a name="1040566"> </a><a href="VFSMgr.html#995845"><code>VFSFileReadData()</code></a></p>

<h3 class="hbH3">
  <a name="994939"> </a>VFSFileDBGetResource Function <a href="#992934"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="994944"> </a>Purpose 
</h4>

<p><a name="994947"> </a>Load a resource into the storage heap from an opened PRC file.</p>
<h4>
  <a name="994949"> </a>Declared In 
</h4>
<code>VFSMgr.h<a name="994952"> </a></code><h4>
  <a name="994954"> </a>Prototype 
</h4>
<pre class="proto"><a name="994957"></a>status_t VFSFileDBGetResource (
   FileRef <code class="par">ref</code>,
   DmResourceType <code class="par">type</code>,
   DmResourceID <code class="par">resID</code>,
   MemHandle <code class="par">*resHP</code>
)
</pre>
<h4>
  <a name="994959"> </a>Parameters 
</h4>

<dl>
<dt><a name="994962"> </a><code>&rarr;  <i>ref</i></code></dt>
<dd><a name="995012"> </a>The file reference returned from <a href="VFSMgr.html#995477"><code>VFSFileOpen()</code></a>. Note that the open file must be a <code>PRC</code> file.</dd>

<dt><a name="995014"> </a><code>&rarr;  <i>type</i></code></dt>
<dd><a name="995064"> </a>The type of resource to load. See <a href="FilesAndDatabases.html#608590">Chapter 2, "Palm OS Databases,"</a> for more information on resources.</dd>

<dt><a name="995066"> </a><code>&rarr;  <i>resID</i></code></dt>
<dd><a name="995068"> </a>The ID of resource to load.</dd>

<dt><a name="995070"> </a><code>&larr;  <i>resHP</i></code></dt>
<dd><a name="995072"> </a>Pointer to the resource data handle that was loaded into memory.</dd>

</dl>
<h4>
  <a name="995074"> </a>Returns 
</h4>

<p><a name="1077432"> </a>Returns <code>errNone</code> if the operation completed successfully, or one of the following otherwise:</p>

<dl>
<dt><a name="1040987"> </a><code><code>dmErrNotResourceDB</code></code></dt>
<dd><a name="1041181"> </a>The file referenced by <code class="par">ref</code> is not a resource database.</dd>

<dt><a name="1040988"> </a><code><code>dmErrResourceNotFound</code></code></dt>
<dd><a name="1041226"> </a>The requested resource was not found.</dd>

<dt><a name="1040989"> </a><code><code>memErrNotEnoughSpace</code></code></dt>
<dd><a name="1041271"> </a>There is not enough space in memory for the requested resource entries.</dd>

<dt><a name="1040990"> </a><code><code>sysErrParamErr</code></code></dt>
<dd><a name="1041316"> </a><code class="par">resHP</code> is <code>NULL</code>.</dd>

</dl>
<h4>
  <a name="1040991"> </a>Comments 
</h4>

<p><a name="1040992"> </a>This function locates the specified resource in the open PRC file. See <i>Exploring Palm OS: Palm OS File Formats</i> for more information on the layout of PRC files. </p>

<p><a name="1040993"> </a>Once the resource is found, <code>VFSFileDBGetResource</code> allocates a handle of the appropriate size in the storage heap and reads it into memory. The handle to this memory location is returned through the <code>resHP</code> parameter. The caller is responsible for freeing this memory, using <a href="MemoryMgr.html#994259"><code>MemHandleFree()</code></a>, when it is no longer needed.</p>

<div><hr>
  <a name="1040997"> </a> <b>NOTE: </b> This function is not efficient for multiple accesses and should be used sparingly.
<hr>
</div>

<h3 class="hbH3">
  <a name="995089"> </a>VFSFileDBInfo Function <a href="#992934"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="995094"> </a>Purpose 
</h4>

<p><a name="995097"> </a>Get information about a database represented by an open PRC or PDB file.</p>
<h4>
  <a name="995099"> </a>Declared In 
</h4>
<code>VFSMgr.h<a name="995102"> </a></code><h4>
  <a name="995104"> </a>Prototype 
</h4>
<pre class="proto"><a name="995107"></a>status_t VFSFileDBInfo (
   FileRef <code class="par">ref</code>,
   char <code class="par">*nameP</code>,
   uint16_t <code class="par">*attributesP</code>,
   uint16_t <code class="par">*versionP</code>,
   uint32_t <code class="par">*crDateP</code>,
   uint32_t <code class="par">*modDateP</code>,
   uint32_t <code class="par">*bckUpDateP</code>,
   uint32_t <code class="par">*modNumP</code>,
   MemHandle <code class="par">*appInfoHP</code>,
   MemHandle <code class="par">*sortInfoHP</code>,
   uint32_t <code class="par">*typeP</code>,
   uint32_t <code class="par">*creatorP</code>,
   uint16_t <code class="par">*numRecordsP</code>
)
</pre>
<h4>
  <a name="995109"> </a>Parameters 
</h4>

<dl>
<dt><a name="995112"> </a><code>&rarr;  <i>ref</i></code></dt>
<dd><a name="995114"> </a>The file reference returned from <a href="VFSMgr.html#995477"><code>VFSFileOpen()</code></a>. Note that the open file must be a PRC or PDB file.</dd>

<dt><a name="995116"> </a><code>&larr;  <i>nameP</i></code></dt>
<dd><a name="995118"> </a>Pointer to a 32-byte character array in which the database name is returned. Pass <code>NULL</code> for this parameter if you do not want to retrieve the database name.</dd>

<dt><a name="995120"> </a><code>&larr;  <i>attributesP</i></code></dt>
<dd><a name="995122"> </a>Pointer to the database attributes stored in the file. The values returned are identical to the atttributes returned from <a href="DataMgr.html#996192"><code>DmDatabaseInfo()</code></a>. See <a href="DataMgr.html#1049292">"Database Attributes"</a> for a description of each attribute. Pass <code>NULL</code> for this parameter if you do not want to retrieve the database's attributes.</dd>

<dt><a name="995124"> </a><code>&larr;  <i>versionP</i></code></dt>
<dd><a name="995126"> </a>Pointer to the application-specific version number of the database. The default version number is zero (0). Pass <code>NULL</code> for this parameter if you do not want to retrieve the version number.</dd>

<dt><a name="995132"> </a><code>&larr;  <i>crDateP</i></code></dt>
<dd><a name="995134"> </a>Pointer to the date the database was created, expressed in seconds since midnight (00:00:00) January 1, 1904. Pass <code>NULL</code> for this parameter if you do not want to retrieve the creation date.</dd>

<dt><a name="995136"> </a><code>&larr;  <i>modDateP</i></code></dt>
<dd><a name="995138"> </a>Pointer to the date the database was last modified, expressed in seconds since midnight (00:00:00) January 1, 1904. A database's modification date is updated only if a change has been made to the database when it is opened with write access. Pass <code>NULL</code> for this parameter if you do not want to retrieve the database's modification date.</dd>

<dt><a name="995140"> </a><code>&larr;  <i>bckUpDateP</i></code></dt>
<dd><a name="995142"> </a>Pointer to the date the database was last backed up, expressed in seconds since midnight (00:00:00) January 1, 1904. Pass <code>NULL</code> for this parameter if you do not want to retrieve the database's backup date.</dd>

<dt><a name="995144"> </a><code>&larr;  <i>modNumP</i></code></dt>
<dd><a name="995146"> </a>Pointer to the number of times the database was modified. This number is updated every time a record is added, modified, or deleted. Pass <code>NULL</code> for this parameter if you do not want to retrieve the modification count.</dd>

<dt><a name="995148"> </a><code>&larr;  <i>appInfoHP</i></code></dt>
<dd><a name="995150"> </a>Pointer to the application info block handle. If <code>NULL</code> is returned in this parameter, either there is no data in this field or an error occurred reading this data from the file. If a value other than <code>NULL</code> is returned, you must dispose of the allocated handle using <a href="MemoryMgr.html#994259"><code>MemHandleFree()</code></a>. If you do not want to retrieve the application info block, pass <code>NULL</code> for this parameter.</dd>

<dt><a name="995152"> </a><code>&larr;  <i>sortInfoHP</i></code></dt>
<dd><a name="995154"> </a>Pointer to the sort info block handle. If <code>NULL</code> is returned in this parameter, either there is no data in this field or an error occurred reading this data from the file. If a value other than <code>NULL</code> is returned, you must dispose of the allocated handle using <a href="MemoryMgr.html#994259"><code>MemHandleFree()</code></a>. Pass <code>NULL</code> for this parameter if you do not want to retrieve the sort info block handle.</dd>

<dt><a name="995156"> </a><code>&larr;  <i>typeP</i></code></dt>
<dd><a name="995158"> </a>Pointer to the type of database as it was created. This may be a user-defined database type or a database type defined by Palm OS. Some of the more common database types returned here are:</dd>

<dl>
<dt><a name="1041712"> </a><code><code>'appl'</code></code></dt>
<dd><a name="1041713"> </a>Standard Palm<sup>&#8482;</sup> application (resource database)</dd>

<dt><a name="1041714"> </a><code><code>'libr'</code></code></dt>
<dd><a name="1041715"> </a>Standard shared library</dd>

<dt><a name="1041716"> </a><code><code>'libf'</code></code></dt>
<dd><a name="1041717"> </a>File system shared library</dd>

<dt><a name="1041718"> </a><code><code>'libs'</code></code></dt>
<dd><a name="1041719"> </a>Slot driver shared library</dd>

<dt><a name="1041720"> </a><code><code>'data'</code></code></dt>
<dd><a name="1041898"> </a>Standard Palm data file (record database)</dd>

</dl>
<dd><a name="1041903"> </a>Pass <code>NULL</code> for this parameter if you do not want to retrieve the database's type.</dd>

<dt><a name="1041899"> </a><code>&larr;  <i>creatorP</i></code></dt>
<dd><a name="1041900"> </a>Pointer to the database's creator. Pass NULL for this parameter if you do not want to retrieve this information.</dd>

<dt><a name="995164"> </a><code>&larr;  <i>numRecordsP</i></code></dt>
<dd><a name="995166"> </a>Pointer to the number of records in the database. Pass <code>NULL</code> for this parameter if you do not want to retrieve this information.</dd>

</dl>
<h4>
  <a name="995172"> </a>Returns 
</h4>

<p><a name="1077437"> </a>Returns <code>errNone</code> if the operation completed successfully, or one of the following otherwise:</p>

<dl>
<dt><a name="1041973"> </a><code><code>memErrNotEnoughSpace</code></code></dt>
<dd><a name="1042279"> </a>There is not enough space in memory for the database header.</dd>

<dt><a name="1041974"> </a><code><code>vfsErrBadData</code></code></dt>
<dd><a name="1042368"> </a>The file referenced by the <code class="par">ref</code> parameter is too small to contain a database header, or the database header is corrupted.</dd>

</dl>
<h4>
  <a name="1041975"> </a>Comments 
</h4>

<p><a name="1041979"> </a>This function is analogous to <a href="DataMgr.html#996192"><code>DmDatabaseInfo()</code></a>, but it works with files on an external card rather than with databases in main memory. See <i>Exploring Palm OS: Palm OS File Formats</i><i> </i>for a description of the header block in PRC and PDB files. </p>
<h4>
  <a name="995182"> </a>See Also 
</h4>

<p><a name="1042416"> </a><a href="VFSMgr.html#995318"><code>VFSFileGetAttributes()</code></a>, <a href="VFSMgr.html#995388"><code>VFSFileGetDate()</code></a></p>

<h3 class="hbH3">
  <a name="995187"> </a>VFSFileDelete Function <a href="#992934"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="995192"> </a>Purpose 
</h4>

<p><a name="995195"> </a>Delete a closed file or directory.</p>
<h4>
  <a name="995197"> </a>Declared In 
</h4>
<code>VFSMgr.h<a name="995200"> </a></code><h4>
  <a name="995202"> </a>Prototype 
</h4>
<pre class="proto"><a name="995205"></a>status_t VFSFileDelete (
   uint16_t <code class="par">volRefNum</code>,
   const char <code class="par">*pathNameP</code>
)
</pre>
<h4>
  <a name="995207"> </a>Parameters 
</h4>

<dl>
<dt><a name="995210"> </a><code>&rarr;  <i>volRefNum</i></code></dt>
<dd><a name="995212"> </a>Volume reference number returned from <a href="VFSMgr.html#997470"><code>VFSVolumeEnumerate()</code></a>.</dd>

<dt><a name="995214"> </a><code>&rarr;  <i>pathNameP</i></code></dt>
<dd><a name="995216"> </a>Pointer to the full path of the file or directory to be deleted.</dd>

</dl>
<h4>
  <a name="1077449"> </a>Returns 
</h4>

<p><a name="1077476"> </a>Returns <code>errNone</code> if the operation completed successfully, or one of the following otherwise:</p>

<dl>
<dt><a name="1077453"> </a><code><code>expErrNotOpen</code></code></dt>
<dd><a name="1042822"> </a>The file system library necessary for this call has not been installed or has not been opened.</dd>

<dt><a name="1042624"> </a><code><code>vfsErrBadName</code></code></dt>
<dd><a name="1042855"> </a>The path name specified in <code>pathNameP</code> is not valid.</dd>

<dt><a name="1042625"> </a><code><code>vfsErrDirNotEmpty</code></code></dt>
<dd><a name="1042888"> </a>The directory being deleted is not empty.</dd>

<dt><a name="1042626"> </a><code><code>vfsErrFileStillOpen</code></code></dt>
<dd><a name="1042921"> </a>The file is still open.</dd>

<dt><a name="1042627"> </a><code><code>vfsErrFileNotFound</code></code></dt>
<dd><a name="1042954"> </a>The file could not be found.</dd>

<dt><a name="1042628"> </a><code><code>vfsErrFilePermissionDenied</code></code></dt>
<dd><a name="1042987"> </a>The requested permissions could not be granted.</dd>

<dt><a name="1042629"> </a><code><code>vfsErrNoFileSystem</code></code></dt>
<dd><a name="1043020"> </a>The VFS Manager cannot find an appropriate file system to handle the request.</dd>

<dt><a name="1042630"> </a><code><code>vfsErrVolumeBadRef</code></code></dt>
<dd><a name="1043053"> </a>The volume has not been mounted.</dd>

</dl>

<h3 class="hbH3">
  <a name="995233"> </a>VFSFileEOF Function <a href="#992934"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="995238"> </a>Purpose 
</h4>

<p><a name="1043087"> </a>Get end-of-file status for an open file. This function only operates on files and cannot be used with directories.</p>
<h4>
  <a name="995243"> </a>Declared In 
</h4>
<code>VFSMgr.h<a name="995246"> </a></code><h4>
  <a name="995248"> </a>Prototype 
</h4>
<pre class="proto"><a name="995251"></a>status_t VFSFileEOF (
   FileRef <code class="par">fileRef</code>
)
</pre>
<h4>
  <a name="995253"> </a>Parameters 
</h4>

<dl>
<dt><a name="995256"> </a><code>&rarr;  <i>fileRef</i></code></dt>
<dd><a name="995258"> </a>File reference returned from <a href="VFSMgr.html#995477"><code>VFSFileOpen()</code></a>.</dd>

</dl>
<h4>
  <a name="995260"> </a>Returns 
</h4>

<p><a name="1077572"> </a>Returns <code>errNone</code> if the operation completed successfully, or one of the following otherwise:</p>

<dl>
<dt><a name="1043156"> </a><code><code>vfsErrFileEOF</code></code></dt>
<dd><a name="1043350"> </a>The file pointer is at the end of file.</dd>

<dt><a name="1043157"> </a><code><code>expErrNotOpen</code></code></dt>
<dd><a name="1043351"> </a>The file system library necessary for this call has not been installed or has not been opened.</dd>

<dt><a name="1043158"> </a><code><code>vfsErrFileBadRef</code></code></dt>
<dd><a name="1043352"> </a>The specified file reference is invalid.</dd>

<dt><a name="1043159"> </a><code><code>vfsErrIsADirectory</code></code></dt>
<dd><a name="1043353"> </a>The specified file reference points to a directory instead of a file. This is an invalid operation on a directory.</dd>

<dt><a name="1043160"> </a><code><code>vfsErrNoFileSystem</code></code></dt>
<dd><a name="1043354"> </a>The VFS Manager cannot find an appropriate file system to handle the request.</dd>

</dl>

<h3 class="hbH3">
  <a name="995318"> </a>VFSFileGetAttributes Function <a href="#992934"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="995347"> </a>Purpose 
</h4>

<p><a name="1043356"> </a>Obtain the attributes of an open file or directory.</p>
<h4>
  <a name="995352"> </a>Declared In 
</h4>
<code>VFSMgr.h<a name="995355"> </a></code><h4>
  <a name="995357"> </a>Prototype 
</h4>
<pre class="proto"><a name="995360"></a>status_t VFSFileGetAttributes (
   FileRef <code class="par">fileRef</code>,
   uint32_t <code class="par">*attributesP</code>
)
</pre>
<h4>
  <a name="995362"> </a>Parameters 
</h4>

<dl>
<dt><a name="995365"> </a><code>&rarr;  <i>fileRef</i></code></dt>
<dd><a name="995367"> </a>File reference returned from <a href="VFSMgr.html#995477"><code>VFSFileOpen()</code></a>.</dd>

<dt><a name="995369"> </a><code>&larr;  <i>attributesP</i></code></dt>
<dd><a name="995371"> </a>Pointer to the attributes associated with the file or directory. See <a href="VFSMgr.html#1018829">"File and Directory Attributes"</a> for a list of values that can be returned through this parameter.</dd>

</dl>
<h4>
  <a name="995373"> </a>Returns 
</h4>

<p><a name="1077577"> </a>Returns <code>errNone</code> if the operation completed successfully, or one of the following otherwise:</p>

<dl>
<dt><a name="1043440"> </a><code><code>expErrNotOpen</code></code></dt>
<dd><a name="1043452"> </a>The file system library necessary for this call has not been installed or has not been opened.</dd>

<dt><a name="1043441"> </a><code><code>vfsErrFileBadRef</code></code></dt>
<dd><a name="1043453"> </a>The specified file reference is invalid.</dd>

<dt><a name="1043442"> </a><code><code>vfsErrNoFileSystem</code></code></dt>
<dd><a name="1043454"> </a>The VFS Manager cannot find an appropriate file system to handle the request.</dd>

</dl>
<h4>
  <a name="1043456"> </a>See Also 
</h4>

<p><a name="1043466"> </a><a href="VFSMgr.html#995089"><code>VFSFileDBInfo()</code></a>, <a href="VFSMgr.html#995388"><code>VFSFileGetDate()</code></a>, <a href="VFSMgr.html#996163"><code>VFSFileSetAttributes()</code></a></p>

<h3 class="hbH3">
  <a name="995388"> </a>VFSFileGetDate Function <a href="#992934"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="995393"> </a>Purpose 
</h4>

<p><a name="995396"> </a>Obtain the dates on an open file or directory.</p>
<h4>
  <a name="995398"> </a>Declared In 
</h4>
<code>VFSMgr.h<a name="995401"> </a></code><h4>
  <a name="995403"> </a>Prototype 
</h4>
<pre class="proto"><a name="995406"></a>status_t VFSFileGetDate (
   FileRef <code class="par">fileRef</code>,
   uint16_t <code class="par">whichDate</code>,
   uint32_t <code class="par">*dateP</code>
)
</pre>
<h4>
  <a name="995408"> </a>Parameters 
</h4>

<dl>
<dt><a name="995411"> </a><code>&rarr;  <i>fileRef</i></code></dt>
<dd><a name="995413"> </a>File reference returned from <a href="VFSMgr.html#995477"><code>VFSFileOpen()</code></a>.</dd>

<dt><a name="995415"> </a><code>&rarr;  <i>whichDate</i></code></dt>
<dd><a name="1043483"> </a>Specifies which date&#8212;creation, modification, or last access&#8212;you want. Supply one of the values listed under <a href="VFSMgr.html#1070095">"Date Types."</a></dd>

<dt><a name="995419"> </a><code>&larr;  <i>dateP</i></code></dt>
<dd><a name="995421"> </a>Pointer to the requested date. This field is expressed in the standard Palm OS date format &#8212; the number of seconds since midnight (00:00:00) January 1, 1904. </dd>

</dl>
<h4>
  <a name="995423"> </a>Returns 
</h4>

<p><a name="1077594"> </a>Returns <code>errNone</code> if the operation completed successfully, or one of the following otherwise:</p>

<dl>
<dt><a name="1043786"> </a><code><code>expErrNotOpen</code></code></dt>
<dd><a name="1044027"> </a>The file system library necessary for this call has not been installed or has not been opened.</dd>

<dt><a name="1043787"> </a><code><code>expErrUnsupportedOperation</code></code></dt>
<dd><a name="1044028"> </a>The specified date type is not supported by the underlying file system.</dd>

<dt><a name="1043788"> </a><code><code>vfsErrFileBadRef</code></code></dt>
<dd><a name="1044029"> </a>The specified file reference is invalid.</dd>

<dt><a name="1043789"> </a><code><code>sysErrParamErr</code></code></dt>
<dd><a name="1044030"> </a>The <code class="par">whichDate</code> parameter is not one of the defined constants.</dd>

</dl>
<h4>
  <a name="1071277"> </a>Comments 
</h4>

<p><a name="1071295"> </a>Note that not all file systems are required to support all date types. If the supplied date type is not supported by the file system, <code>VFSFileGetDate</code> returns <code>expErrUnsupportedOperation</code>. </p>
<h4>
  <a name="1043795"> </a>See Also 
</h4>

<p><a name="1043805"> </a><a href="VFSMgr.html#995089"><code>VFSFileDBInfo()</code></a>, <a href="VFSMgr.html#995318"><code>VFSFileGetAttributes()</code></a>, <a href="VFSMgr.html#996237"><code>VFSFileSetDate()</code></a></p>

<h3 class="hbH3">
  <a name="995477"> </a>VFSFileOpen Function <a href="#992934"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="995490"> </a>Purpose 
</h4>

<p><a name="995493"> </a>Open a file or directory and returns a reference for it.</p>
<h4>
  <a name="995495"> </a>Declared In 
</h4>
<code>VFSMgr.h<a name="995498"> </a></code><h4>
  <a name="995500"> </a>Prototype 
</h4>
<pre class="proto"><a name="995503"></a>status_t VFSFileOpen (
   uint16_t <code class="par">volRefNum</code>,
   const char <code class="par">*pathNameP</code>,
   uint16_t <code class="par">openMode</code>,
   FileRef <code class="par">*fileRefP</code>
)
</pre>
<h4>
  <a name="995505"> </a>Parameters 
</h4>

<dl>
<dt><a name="995508"> </a><code>&rarr;  <i>volRefNum</i></code></dt>
<dd><a name="995510"> </a>The volume reference number returned from <a href="VFSMgr.html#997470"><code>VFSVolumeEnumerate()</code></a>.</dd>

<dt><a name="995512"> </a><code>&rarr;  <i>pathNameP</i></code></dt>
<dd><a name="995514"> </a>Pointer to the full path of the file or directory to be opened. This must be a valid path. It cannot be empty and can not contain null characters. The format of the pathname should match what the underlying file system supports. See <a href="VFS.html#993552">"Naming Files"</a> for a description of how to construct a valid path.</dd>

<dt><a name="995516"> </a><code>&rarr;  <i>openMode</i></code></dt>
<dd><a name="995518"> </a>Mode to use when opening the file. See <a href="VFSMgr.html#1016238">"Open Mode Constants"</a> for a list of accepted modes.</dd>

<dt><a name="995520"> </a><code>&larr;  <i>fileRefP</i></code></dt>
<dd><a name="995522"> </a>Pointer to the opened file or directory reference which is supplied to various other <code>VFSFile... </code>operations. This value is filled in on return.</dd>

</dl>
<h4>
  <a name="995524"> </a>Returns 
</h4>

<p><a name="1077599"> </a>Returns <code>errNone</code> if the operation completed successfully, or one of the following otherwise:</p>

<dl>
<dt><a name="1044226"> </a><code><code>expErrCardReadOnly</code></code></dt>
<dd><a name="1044501"> </a>The open mode requested includes write access but the file is read-only.</dd>

<dt><a name="1044227"> </a><code><code>expErrNotOpen</code></code></dt>
<dd><a name="1044502"> </a>The file system library necessary for this call has not been installed or has not been opened.</dd>

<dt><a name="1044228"> </a><code><code>vfsErrBadName</code></code></dt>
<dd><a name="1044503"> </a>The <code class="par">pathNameP</code> parameter is invalid.</dd>

<dt><a name="1044229"> </a><code><code>vfsErrFileNotFound</code></code></dt>
<dd><a name="1044504"> </a>The specified file or directory could not be found.</dd>

<dt><a name="1044230"> </a><code><code>vfsErrFilePermissionDenied</code></code></dt>
<dd><a name="1045723"> </a>The file cannot be opened in the requested open mode, or it has already been opened with <code>vfsModeExclusive</code>.</dd>

<dt><a name="1044231"> </a><code><code>vfsErrVolumeBadRef</code></code></dt>
<dd><a name="1045724"> </a>The specified volume has not been mounted.</dd>

</dl>
<h4>
  <a name="1044237"> </a>See Also 
</h4>

<p><a name="1044244"> </a><a href="VFSMgr.html#994581"><code>VFSFileClose()</code></a>, <a href="VFSMgr.html#994232"><code>VFSDirEntryEnumerate()</code></a>, <a href="VFSMgr.html#995539"><code>VFSFileOpenFromURL()</code></a></p>

<h3 class="hbH3">
  <a name="995539"> </a>VFSFileOpenFromURL Function <a href="#992934"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="995544"> </a>Purpose 
</h4>

<p><a name="1045727"> </a>Open a file or directory given a URL to that file or directory.</p>
<h4>
  <a name="995549"> </a>Declared In 
</h4>
<code>VFSMgr.h<a name="995552"> </a></code><h4>
  <a name="995554"> </a>Prototype 
</h4>
<pre class="proto"><a name="995557"></a>status_t VFSFileOpenFromURL (
   const char <code class="par">*fileURLP</code>,
   uint16_t <code class="par">openMode</code>,
   FileRef <code class="par">*fileRefP</code>,
   uint16_t <code class="par">*numOccurrencesP</code>
)
</pre>
<h4>
  <a name="995559"> </a>Parameters 
</h4>

<dl>
<dt><a name="995600"> </a><code>&rarr;  <i>*fileURLP</i></code></dt>
<dd><a name="1045922"> </a>URL to the file or directory to be opened. This must be a valid URL. It cannot be empty and can not contain null characters.</dd>

<dt><a name="995696"> </a><code>&rarr;  <i>openMode</i></code></dt>
<dd><a name="1047249"> </a>Mode to use when opening the file. See <a href="VFSMgr.html#1016238">"Open Mode Constants"</a> for a list of accepted modes.</dd>

<dt><a name="1047251"> </a><code>&larr;  <i>fileRefP</i></code></dt>
<dd><a name="1047252"> </a>Pointer to the opened file or directory reference number which can then be supplied to various other <code>VFSFile... </code>operations. This value is filled in on return.</dd>

<dt><a name="1044493"> </a><code>&larr;  <i>numOccurrencesP</i></code></dt>
<dd><a name="995770"> </a>The number of files the URL matched. Set this pointer to <code>NULL</code> if you don't need this information.</dd>

</dl>
<h4>
  <a name="995772"> </a>Returns 
</h4>

<p><a name="1077620"> </a>Returns <code>errNone</code> if the operation completed successfully, or one of the following otherwise:</p>

<dl>
<dt><a name="1047259"> </a><code><code>expErrCardReadOnly</code></code></dt>
<dd><a name="1047260"> </a>The open mode requested includes write access but the file is read-only.</dd>

<dt><a name="1047261"> </a><code><code>expErrNotOpen</code></code></dt>
<dd><a name="1047262"> </a>The file system library necessary for this call has not been installed or has not been opened.</dd>

<dt><a name="1047263"> </a><code><code>vfsErrBadName</code></code></dt>
<dd><a name="1047264"> </a>The <code class="par">pathNameP</code> parameter is invalid.</dd>

<dt><a name="1047265"> </a><code><code>vfsErrFileNotFound</code></code></dt>
<dd><a name="1047266"> </a>The specified file or directory could not be found.</dd>

<dt><a name="1047267"> </a><code><code>vfsErrFilePermissionDenied</code></code></dt>
<dd><a name="1047268"> </a>The file cannot be opened in the requested open mode, or it has already been opened with <code>vfsModeExclusive</code>.</dd>

<dt><a name="1047269"> </a><code><code>vfsErrVolumeBadRef</code></code></dt>
<dd><a name="1047270"> </a>The specified volume has not been mounted.</dd>

</dl>
<h4>
  <a name="1084745"> </a>Comments 
</h4>

<p><a name="1084762"> </a><code>VFSOpenFileFromURL()</code> exists to aid a higher-level entity, such as the Exchange Manager, in opening a file referenced in a URL such as <code>file:///VolumeName/PALM/Launcher/myApp.prc</code> (see <i>Exploring Palm OS: High-Level Communications</i> for a specification of the URL format)  This function differs from <a href="VFSMgr.html#995477"><code>VFSFileOpen()</code></a> in its use of a volume name (in the URL) instead of a volume reference number to differentiate the card.  This difference allows the URL to be saved in a "bookmark" and later re-used to open the same file; this wouldn't work with volume reference numbers since they change with every insertion and removal of a card. In the case where multiple cards with the same volume name are present in a device at the same time, each card is checked for the presence of the file, and if multiple instances of the same file are found on these different cards the one with the most recent modification date is opened and returned.  In this instance the optional <code class="par">numOccurrencesP</code> parameter is set to the number of matching files found.</p>
<h4>
  <a name="1047271"> </a>See Also 
</h4>

<p><a name="1047278"> </a><a href="VFSMgr.html#994581"><code>VFSFileClose()</code></a>, <a href="VFSMgr.html#994232"><code>VFSDirEntryEnumerate()</code></a>, <a href="VFSMgr.html#995477"><code>VFSFileOpen()</code></a></p>

<h3 class="hbH3">
  <a name="995787"> </a>VFSFileRead Function <a href="#992934"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="995792"> </a>Purpose 
</h4>

<p><a name="1047450"> </a>Read data from a file into the dynamic heap. This function only operates on files and cannot be used with directories; use <a href="VFSMgr.html#994232"><code>VFSDirEntryEnumerate()</code></a> to explore the contents of a directory.</p>
<h4>
  <a name="995797"> </a>Declared In 
</h4>
<code>VFSMgr.h<a name="995800"> </a></code><h4>
  <a name="995802"> </a>Prototype 
</h4>
<pre class="proto"><a name="995805"></a>status_t VFSFileRead (
   FileRef <code class="par">fileRef</code>,
   uint32_t <code class="par">numBytes</code>,
   void <code class="par">*bufP</code>,
   uint32_t <code class="par">*numBytesReadP</code>
)
</pre>
<h4>
  <a name="995807"> </a>Parameters 
</h4>

<dl>
<dt><a name="995810"> </a><code>&rarr;  <i>fileRef</i></code></dt>
<dd><a name="995812"> </a>File reference returned from <a href="VFSMgr.html#995477"><code>VFSFileOpen()</code></a>.</dd>

<dt><a name="995814"> </a><code>&rarr;  <i>numBytes</i></code></dt>
<dd><a name="995820"> </a>Number of bytes to read.</dd>

<dt><a name="995822"> </a><code>&larr;  <i>bufP</i></code></dt>
<dd><a name="995824"> </a>Pointer to the destination chunk where the data is to be stored. This can be a pointer to any writable memory.</dd>

<dt><a name="995826"> </a><code>&larr;  <i>numBytesReadP</i></code></dt>
<dd><a name="995828"> </a>Pointer to an unsigned integer that reflects the number of bytes actually read. This value is set on return and does not need to be initialized. If no bytes are read the value is set to zero. Pass <code>NULL</code> for this parameter if you do not need to know how many bytes were read.</dd>

</dl>
<h4>
  <a name="995830"> </a>Returns 
</h4>

<p><a name="1077625"> </a>Returns <code>errNone</code> if the operation completed successfully, or one of the following otherwise:</p>

<dl>
<dt><a name="1047478"> </a><code><code>expErrNotOpen</code></code></dt>
<dd><a name="1047736"> </a>The file system library necessary for this call has not been installed or has not been opened.</dd>

<dt><a name="1047479"> </a><code><code>vfsErrFileBadRef</code></code></dt>
<dd><a name="1047757"> </a>The specified file reference is invalid.</dd>

<dt><a name="1047480"> </a><code><code>vfsErrFileEOF</code></code></dt>
<dd><a name="1047790"> </a>The end of the file has been reached.</dd>

<dt><a name="1047481"> </a><code><code>vfsErrFilePermissionDenied</code></code></dt>
<dd><a name="1047811"> </a>Read permission is not enabled for this file.</dd>

<dt><a name="1047482"> </a><code><code>vfsErrIsADirectory</code></code></dt>
<dd><a name="1047844"> </a>The specified file reference is for a directory instead of a file. This is an invalid operation on a directory.</dd>

<dt><a name="1047483"> </a><code><code>vfsErrNoFileSystem</code></code></dt>
<dd><a name="1047881"> </a>The VFS Manager cannot find an appropriate file system to handle the request.</dd>

</dl>
<h4>
  <a name="1047484"> </a>Comments 
</h4>

<p><a name="1047488"> </a>The file system does not use <a href="DataMgr.html#1007510"><code>DmWrite()</code></a> and cannot be used to read data into the storage heap.</p>
<h4>
  <a name="1047494"> </a>See Also 
</h4>

<p><a name="1047501"> </a><a href="VFSMgr.html#995845"><code>VFSFileReadData()</code></a>, <a href="VFSMgr.html#996483"><code>VFSFileWrite()</code></a>, <a href="VFSMgr.html#996612"><code>VFSImportDatabaseFromFile()</code></a></p>

<h3 class="hbH3">
  <a name="995845"> </a>VFSFileReadData Function <a href="#992934"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="995850"> </a>Purpose 
</h4>

<p><a name="1047927"> </a>Read data from a file into a chunk of memory in the storage heap. This function only operates on files and cannot be used with directories; use <a href="VFSMgr.html#994232"><code>VFSDirEntryEnumerate()</code></a> to explore the contents of a directory.</p>
<h4>
  <a name="995855"> </a>Declared In 
</h4>
<code>VFSMgr.h<a name="995858"> </a></code><h4>
  <a name="995860"> </a>Prototype 
</h4>
<pre class="proto"><a name="995863"></a>status_t VFSFileReadData (
   FileRef <code class="par">fileRef</code>,
   uint32_t <code class="par">numBytes</code>,
   void <code class="par">*bufBaseP</code>,
   uint32_t <code class="par">offset</code>,
   uint32_t <code class="par">*numBytesReadP</code>
)
</pre>
<h4>
  <a name="995865"> </a>Parameters 
</h4>

<dl>
<dt><a name="995868"> </a><code>&rarr;  <i>fileRef</i></code></dt>
<dd><a name="995870"> </a>File reference returned in <a href="VFSMgr.html#995477"><code>VFSFileOpen()</code></a>.</dd>

<dt><a name="995872"> </a><code>&rarr;  <i>numBytes</i></code></dt>
<dd><a name="995874"> </a>Number of bytes to read.</dd>

<dt><a name="995876"> </a><code>&larr;  <i>bufBaseP</i></code></dt>
<dd><a name="995878"> </a>Pointer to the destination chunk in the storage heap where the data is to be stored. This pointer must be obtained through the appropriate call to the <a href="MemoryMgr.html#992934">Memory Manager</a> API.</dd>

<dt><a name="995880"> </a><code>&rarr;  <i>offset</i></code></dt>
<dd><a name="995882"> </a>Offset, in bytes, within the <code class="par">bufBaseP</code> chunk where the data is to be written. </dd>

<dt><a name="995884"> </a><code>&larr;  <i>numBytesReadP</i></code></dt>
<dd><a name="995886"> </a>Pointer to an unsigned integer that reflects the number of bytes actually read. This value is set on return and does not need to be initialized. If no bytes are read, the value is set to zero. Pass <code>NULL</code> for this parameter if you do not need to know how many bytes were read.</dd>

</dl>
<h4>
  <a name="995888"> </a>Returns 
</h4>

<p><a name="1077650"> </a>Returns <code>errNone</code> if the operation completed successfully, or one of the following otherwise:</p>

<dl>
<dt><a name="1048050"> </a><code><code>expErrNotOpen</code></code></dt>
<dd><a name="1048228"> </a>The file system library necessary for this call has not been installed or has not been opened.</dd>

<dt><a name="1048051"> </a><code><code>vfsErrFileBadRef</code></code></dt>
<dd><a name="1048229"> </a>The specified file reference is invalid.</dd>

<dt><a name="1048052"> </a><code><code>vfsErrFileEOF</code></code></dt>
<dd><a name="1048230"> </a>The end of the file has been reached.</dd>

<dt><a name="1048053"> </a><code><code>vfsErrFilePermissionDenied</code></code></dt>
<dd><a name="1048231"> </a>Read permission is not enabled for this file.</dd>

<dt><a name="1048054"> </a><code><code>vfsErrIsADirectory</code></code></dt>
<dd><a name="1048232"> </a>The specified file reference is for a directory instead of a file. This is an invalid operation on a directory.</dd>

<dt><a name="1048055"> </a><code><code>vfsErrNoFileSystem</code></code></dt>
<dd><a name="1048233"> </a>The VFS Manager cannot find an appropriate file system to handle the request.</dd>

</dl>
<h4>
  <a name="1048056"> </a>Comments 
</h4>

<p><a name="1048057"> </a>When data is read from an external card with <code>VFSFileReadData</code>, it is copied into a chunk of memory in the storage heap. This chunk <b>must</b> be allocated by the application before the call to <a href="VFSMgr.html#995845"><code>VFSFileReadData()</code></a>. This function calls <a href="DataMgr.html#1007510"><code>DmWrite()</code></a> to put the data in the storage heap. </p>
<h4>
  <a name="1048069"> </a>See Also 
</h4>

<p><a name="1048076"> </a><a href="VFSMgr.html#995787"><code>VFSFileRead()</code></a>, <a href="VFSMgr.html#996483"><code>VFSFileWrite()</code></a></p>

<h3 class="hbH3">
  <a name="995946"> </a>VFSFileRename Function <a href="#992934"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="995975"> </a>Purpose 
</h4>

<p><a name="1048235"> </a>Rename a closed file or directory. This function cannot be used to move a file to another directory within the file system.</p>
<h4>
  <a name="995980"> </a>Declared In 
</h4>
<code>VFSMgr.h<a name="995983"> </a></code><h4>
  <a name="995985"> </a>Prototype 
</h4>
<pre class="proto"><a name="995988"></a>status_t VFSFileRename (
   uint16_t <code class="par">volRefNum</code>,
   const char <code class="par">*pathNameP</code>,
   const char <code class="par">*newNameP</code>
)
</pre>
<h4>
  <a name="995990"> </a>Parameters 
</h4>

<dl>
<dt><a name="995993"> </a><code>&rarr;  <i>volRefNum</i></code></dt>
<dd><a name="995995"> </a>Volume reference number returned from <a href="VFSMgr.html#997470"><code>VFSVolumeEnumerate()</code></a>.</dd>

<dt><a name="995997"> </a><code>&rarr;  <i>pathNameP</i></code></dt>
<dd><a name="995999"> </a>Pointer to the full path of the file or directory to be renamed.</dd>

<dt><a name="996001"> </a><code>&rarr;  <i>newNameP</i></code></dt>
<dd><a name="996003"> </a>Pointer to the new filename. Note that this is the name of the file only and does not include the path to the file.</dd>

</dl>
<h4>
  <a name="996005"> </a>Returns 
</h4>

<p><a name="1077655"> </a>Returns <code>errNone</code> if the operation completed successfully, or one of the following otherwise:</p>

<dl>
<dt><a name="1048288"> </a><code><code>expErrNotOpen</code></code></dt>
<dd><a name="1048520"> </a>The file system library necessary for this call has not been installed or has not been opened.</dd>

<dt><a name="1048289"> </a><code><code>vfsErrBadName</code></code></dt>
<dd><a name="1048521"> </a>The name provided in either <code class="par">pathNameP</code> or <code class="par">newNameP</code> is invalid. This is also returned if the string pointed to by <code class="par">newNameP</code> is a path, rather than a filename.</dd>

<dt><a name="1048290"> </a><code><code>vfsErrFileAlreadyExists</code></code></dt>
<dd><a name="1048522"> </a>A file with the new name already exists in this location.</dd>

<dt><a name="1048291"> </a><code><code>vfsErrFileNotFound</code></code></dt>
<dd><a name="1048551"> </a>The source file could not be found.</dd>

<dt><a name="1048292"> </a><code><code>vfsErrFilePermissionDenied</code></code></dt>
<dd><a name="1048552"> </a>Write permission is not enabled for this file.</dd>

<dt><a name="1048293"> </a><code><code>vfsErrNoFileSystem</code></code></dt>
<dd><a name="1048553"> </a>The VFS Manager cannot find an appropriate file system to handle the request.</dd>

<dt><a name="1048294"> </a><code><code>vfsErrVolumeBadRef</code></code></dt>
<dd><a name="1048554"> </a>The volume has not been mounted.</dd>

<dt><a name="1048295"> </a><code><code>vfsErrVolumeFull</code></code></dt>
<dd><a name="1048555"> </a>There is not enough space left on the volume.</dd>

</dl>
<h4>
  <a name="1048296"> </a>Comments 	
</h4>

<div><hr>
  <a name="1048297"> </a> <span class="warning">WARNING! </span> This function invalidates directory enumeration. You cannot continue enumerating files after renaming one of them with this function. If you need to operate on additional files in the directory, you must first restart the enumeration.
<hr>
</div>
<h4>
  <a name="1048298"> </a>Example 
</h4>

<p><a name="1048299"> </a>Below is an example of how to use <code>VFSFileRename</code>. Note that the renamed file remains in the <code>/PALM/Programs</code> directory; <code>VFSFileRename</code> can't be used to move files from one directory to another.</p>

<div class="CodeRule"><hr></div><pre class="CodeBlock">
// volRefNum must have been previously defined; most likely,<a name="1048300"> </a>
// it was returned by VFSVolumeEnumerate<a name="1048301"> </a>
 <a name="1048302"> </a>
err = VFSFileRename(volRefNum, "/PALM/Programs/foo.prc",
   "bar.prc");<a name="1048303"> </a>
if (err != errNone) {<a name="1048304"> </a>
      // handle error...<a name="1048305"> </a>
}<a name="1048306"> </a>
</pre><div class="CodeRule"><hr></div>


<h3 class="hbH3">
  <a name="996020"> </a>VFSFileResize Function <a href="#992934"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="996025"> </a>Purpose 
</h4>

<p><a name="1048557"> </a>Change the size of an open file. This function only operates on files and cannot be used with directories.</p>
<h4>
  <a name="996030"> </a>Declared In 
</h4>
<code>VFSMgr.h<a name="996033"> </a></code><h4>
  <a name="996035"> </a>Prototype 
</h4>
<pre class="proto"><a name="996038"></a>status_t VFSFileResize (
   FileRef <code class="par">fileRef</code>,
   uint32_t <code class="par">newSize</code>
)
</pre>
<h4>
  <a name="996040"> </a>Parameters 
</h4>

<dl>
<dt><a name="996043"> </a><code>&rarr;  <i>fileRef</i></code></dt>
<dd><a name="996045"> </a>File reference returned from <a href="VFSMgr.html#995477"><code>VFSFileOpen()</code></a>.</dd>

<dt><a name="996047"> </a><code>&rarr;  <i>newSize</i></code></dt>
<dd><a name="996049"> </a>The desired new size of the file. This can be larger or smaller then the current file size.</dd>

</dl>
<h4>
  <a name="996055"> </a>Returns 
</h4>

<p><a name="1077661"> </a>Returns <code>errNone</code> if the operation completed successfully, or one of the following otherwise:</p>

<dl>
<dt><a name="1048634"> </a><code><code>expErrNotOpen</code></code></dt>
<dd><a name="1048912"> </a>The file system library necessary for this call has not been installed or has not been opened.</dd>

<dt><a name="1048635"> </a><code><code>vfsErrFileBadRef</code></code></dt>
<dd><a name="1048913"> </a>The specified file reference is invalid.</dd>

<dt><a name="1048636"> </a><code><code>vfsErrIsADirectory</code></code></dt>
<dd><a name="1048914"> </a>The specified file reference points to a directory instead of a file. This is an invalid operation on a directory.</dd>

<dt><a name="1048637"> </a><code><code>vfsErrNoFileSystem</code></code></dt>
<dd><a name="1048963"> </a>The VFS Manager cannot find an appropriate file system to handle the request.</dd>

<dt><a name="1048638"> </a><code><code>vfsErrVolumeFull</code></code></dt>
<dd><a name="1049012"> </a>There is not enough space left on the volume.</dd>

</dl>
<h4>
  <a name="1048639"> </a>Comments 
</h4>

<p><a name="1048640"> </a>The location of the file pointer is undefined after a call to this function.</p>
<h4>
  <a name="1048646"> </a>See Also 
</h4>

<p><a name="1048650"> </a><a href="VFSMgr.html#996311"><code>VFSFileSize()</code></a></p>

<h3 class="hbH3">
  <a name="996105"> </a>VFSFileSeek Function <a href="#992934"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="996118"> </a>Purpose 
</h4>

<p><a name="1049062"> </a>Set the position within an open file from which to read or write. This function only operates on files and cannot be used with directories.</p>
<h4>
  <a name="996123"> </a>Declared In 
</h4>
<code>VFSMgr.h<a name="996126"> </a></code><h4>
  <a name="996128"> </a>Prototype 
</h4>
<pre class="proto"><a name="996131"></a>status_t VFSFileSeek (
   FileRef <code class="par">fileRef</code>,
   FileOrigin <code class="par">origin</code>,
   int32_t <code class="par">offset</code>
)
</pre>
<h4>
  <a name="996133"> </a>Parameters 
</h4>

<dl>
<dt><a name="996136"> </a><code>&rarr;  <i>fileRef</i></code></dt>
<dd><a name="996138"> </a>File reference returned from <a href="VFSMgr.html#995477"><code>VFSFileOpen()</code></a>.</dd>

<dt><a name="996140"> </a><code>&rarr;  <i>origin</i></code></dt>
<dd><a name="1049153"> </a>Origin to use when calculating the new position. The <code>offset</code> parameter indicates the desired new position relative to this origin, which can be one of the constants listed under <a href="VFSMgr.html#1073903">"Seek Origins."</a></dd>

<dt><a name="996144"> </a><code>&rarr;  <i>offset</i></code></dt>
<dd><a name="996146"> </a>Offset, either positive or negative, from the origin to which the current position should be set. A value of zero (0) positions you at the specified origin.</dd>

</dl>
<h4>
  <a name="996148"> </a>Returns 
</h4>

<p><a name="1077694"> </a>Returns <code>errNone</code> if the operation completed successfully, or one of the following otherwise:</p>

<dl>
<dt><a name="1049345"> </a><code><code>expErrNotOpen</code></code></dt>
<dd><a name="1049541"> </a>The file system library necessary for this call has not been installed or has not been opened.</dd>

<dt><a name="1049346"> </a><code><code>vfsErrFileBadRef</code></code></dt>
<dd><a name="1049542"> </a>The specified file reference is invalid.</dd>

<dt><a name="1049347"> </a><code><code>vfsErrFileEOF</code></code></dt>
<dd><a name="1049543"> </a>The file pointer is at the end of file.</dd>

<dt><a name="1049348"> </a><code><code>vfsErrIsADirectory</code></code></dt>
<dd><a name="1049544"> </a>The specified file reference points to a directory instead of a file. This is an invalid operation on a directory.</dd>

<dt><a name="1049349"> </a><code><code>sysErrParamErr</code></code></dt>
<dd><a name="1049945"> </a>The specified origin is not one of the defined constants.</dd>

</dl>
<h4>
  <a name="1049350"> </a>Comments 
</h4>

<p><a name="1049351"> </a>During a call to this function, if the resulting position would be beyond the end of the file, it sets the position to the end of the file.</p>
<h4>
  <a name="1049357"> </a>See Also 
</h4>

<p><a name="1049364"> </a><a href="VFSMgr.html#996311"><code>VFSFileSize()</code></a>, <a href="VFSMgr.html#996357"><code>VFSFileTell()</code></a></p>

<h3 class="hbH3">
  <a name="996163"> </a>VFSFileSetAttributes Function <a href="#992934"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="996168"> </a>Purpose 
</h4>

<p><a name="996171"> </a>Change the attributes of an open file or directory.</p>
<h4>
  <a name="996173"> </a>Declared In 
</h4>
<code>VFSMgr.h<a name="996176"> </a></code><h4>
  <a name="996178"> </a>Prototype 
</h4>
<pre class="proto"><a name="996181"></a>status_t VFSFileSetAttributes (
   FileRef <code class="par">fileRef</code>,
   uint32_t <code class="par">attributes</code>
)
</pre>
<h4>
  <a name="996183"> </a>Parameters 
</h4>

<dl>
<dt><a name="996186"> </a><code>&rarr;  <i>fileRef</i></code></dt>
<dd><a name="996188"> </a>File reference returned from <a href="VFSMgr.html#995477"><code>VFSFileOpen()</code></a>.</dd>

<dt><a name="996190"> </a><code>&rarr;  <i>attributes</i></code></dt>
<dd><a name="996192"> </a>Attributes to associate with the file or directory. See <a href="VFSMgr.html#1018829">"File and Directory Attributes"</a> for a list of values you can use when setting this parameter:</dd>

</dl>
<h4>
  <a name="996194"> </a>Returns 
</h4>

<p><a name="1077768"> </a>Returns <code>errNone</code> if the operation completed successfully, or one of the following otherwise:</p>

<dl>
<dt><a name="1050056"> </a><code><code>expErrNotOpen</code></code></dt>
<dd><a name="1050489"> </a>The file system library necessary for this call has not been installed or has not been opened.</dd>

<dt><a name="1050057"> </a><code><code>sysErrParamErr</code></code></dt>
<dd><a name="1050494"> </a>One of the parameters is invalid.</dd>

<dt><a name="1050058"> </a><code><code>vfsErrFileBadRef</code></code></dt>
<dd><a name="1050580"> </a>The specified file reference is invalid.</dd>

<dt><a name="1050059"> </a><code><code>vfsErrNoFileSystem	<br></code>The VFS Manager cannot find an appropriate file system to handle the request.</code></dt>
</dl>
<h4>
  <a name="1050060"> </a>Comments 
</h4>

<div><hr>
  <a name="1050061"> </a> <b>NOTE: </b> You cannot use this function to set the <code>vfsFileAttrDirectory</code> or <code>vfsFileAttrVolumeLabel</code> attributes. The <code>vfsFileAttrDirectory</code> is set when you call <a href="VFSMgr.html#994162"><code>VFSDirCreate()</code></a>. The <code>vfsFileAttrVolumeLabel</code> is set when you call <a href="VFSMgr.html#997767"><code>VFSVolumeSetLabel()</code></a>. This function may fail when setting other attributes, depending on the underlying file system.
<hr>
</div>
<h4>
  <a name="1050073"> </a>See Also 
</h4>

<p><a name="1050080"> </a><a href="VFSMgr.html#995318"><code>VFSFileGetAttributes()</code></a>, <a href="VFSMgr.html#996237"><code>VFSFileSetDate()</code></a></p>

<h3 class="hbH3">
  <a name="996237"> </a>VFSFileSetDate Function <a href="#992934"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="996266"> </a>Purpose 
</h4>

<p><a name="1050582"> </a>Change the dates on an open file or directory.</p>
<h4>
  <a name="996271"> </a>Declared In 
</h4>
<code>VFSMgr.h<a name="996274"> </a></code><h4>
  <a name="996276"> </a>Prototype 
</h4>
<pre class="proto"><a name="996279"></a>status_t VFSFileSetDate (
   FileRef <code class="par">fileRef</code>,
   uint16_t <code class="par">whichDate</code>,
   uint32_t <code class="par">date</code>
)
</pre>
<h4>
  <a name="996281"> </a>Parameters 
</h4>

<dl>
<dt><a name="996284"> </a><code>&rarr;  <i>fileRef</i></code></dt>
<dd><a name="996286"> </a>File reference returned in <a href="VFSMgr.html#995477"><code>VFSFileOpen()</code></a>.</dd>

<dt><a name="996288"> </a><code>&rarr;  <i>whichDate</i></code></dt>
<dd><a name="1050641"> </a>Specifies which date&#8212;creation, modification, or last access&#8212;to modify. Supply one of the values listed under <a href="VFSMgr.html#1070095">"Date Types."</a></dd>

<dt><a name="996292"> </a><code>&rarr;  <i>date</i></code></dt>
<dd><a name="996294"> </a>The new date. This field should be expressed in the standard Palm OS date format &#8212; the number of seconds since midnight (00:00:00) January 1, 1904.</dd>

</dl>
<h4>
  <a name="996296"> </a>Returns 
</h4>

<p><a name="1077773"> </a>Returns <code>errNone</code> if the operation completed successfully, or one of the following otherwise:</p>

<dl>
<dt><a name="1050969"> </a><code><code>expErrNotOpen</code></code></dt>
<dd><a name="1051140"> </a>The file system library necessary for this call has not been installed or has not been opened.</dd>

<dt><a name="1050970"> </a><code><code>expErrUnsupportedOperation</code></code></dt>
<dd><a name="1051141"> </a>The specified date type is not supported by the underlying file system.</dd>

<dt><a name="1050971"> </a><code><code>sysErrParamErr</code></code></dt>
<dd><a name="1051142"> </a>The <code class="par">whichDate</code> parameter is not one of the defined constants.</dd>

<dt><a name="1050972"> </a><code><code>vfsErrFileBadRef</code></code></dt>
<dd><a name="1051145"> </a>The specified file reference is invalid.</dd>

<dt><a name="1051146"> </a><code><code>vfsErrFilePermissionDenied</code></code></dt>
<dd><a name="1051149"> </a>Write permission is not enabled for this file.</dd>

<dt><a name="1050974"> </a><code><code>vfsErrNoFileSystem</code></code></dt>
<dd><a name="1051150"> </a>The VFS Manager cannot find an appropriate file system to handle the request.</dd>

</dl>
<h4>
  <a name="1071399"> </a>Comments 
</h4>

<p><a name="1071482"> </a>Note that not all file systems are required to support all date types. If the supplied date type is not supported by the file system, <code>VFSFileGetDate</code> returns <code>expErrUnsupportedOperation</code>. </p>
<h4>
  <a name="1050980"> </a>See Also 
</h4>

<p><a name="1050987"> </a><a href="VFSMgr.html#995388"><code>VFSFileGetDate()</code></a>, <a href="VFSMgr.html#996163"><code>VFSFileSetAttributes()</code></a></p>

<h3 class="hbH3">
  <a name="996311"> </a>VFSFileSize Function <a href="#992934"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="996316"> </a>Purpose 
</h4>

<p><a name="996319"> </a>Obtain the size of an open file. This function only operates on files and cannot be used with directories.</p>
<h4>
  <a name="996321"> </a>Declared In 
</h4>
<code>VFSMgr.h<a name="996324"> </a></code><h4>
  <a name="996326"> </a>Prototype 
</h4>
<pre class="proto"><a name="996329"></a>status_t VFSFileSize (
   FileRef <code class="par">fileRef</code>,
   uint32_t <code class="par">*fileSizeP</code>
)
</pre>
<h4>
  <a name="996331"> </a>Parameters 
</h4>

<dl>
<dt><a name="996334"> </a><code>&rarr;  <i>fileRef</i></code></dt>
<dd><a name="996336"> </a>File reference returned from <a href="VFSMgr.html#995477"><code>VFSFileOpen()</code></a>.</dd>

<dt><a name="996338"> </a><code>&larr;  <i>fileSizeP</i></code></dt>
<dd><a name="996340"> </a>Pointer to the size of the open file.</dd>

</dl>
<h4>
  <a name="996342"> </a>Returns 
</h4>

<p><a name="1077786"> </a>Returns <code>errNone</code> if the operation completed successfully, or one of the following otherwise:</p>

<dl>
<dt><a name="1051181"> </a><code><code>expErrNotOpen</code></code></dt>
<dd><a name="1052096"> </a>The file system library necessary for this call has not been installed or has not been opened.</dd>

<dt><a name="1051182"> </a><code><code>vfsErrFileBadRef</code></code></dt>
<dd><a name="1052141"> </a>The specified file reference is invalid.</dd>

<dt><a name="1051183"> </a><code><code>vfsErrIsADirectory</code></code></dt>
<dd><a name="1052794"> </a>The specified file reference points to a directory instead of a file. This is an invalid operation on a directory.</dd>

<dt><a name="1051184"> </a><code><code>vfsErrNoFileSystem</code></code></dt>
<dd><a name="1053511"> </a>The VFS Manager cannot find an appropriate file system to handle the request.</dd>

</dl>
<h4>
  <a name="1051190"> </a>See Also 
</h4>

<p><a name="1051200"> </a><a href="VFSMgr.html#996020"><code>VFSFileResize()</code></a>, <a href="VFSMgr.html#996357"><code>VFSFileTell()</code></a>, <a href="VFSMgr.html#997813"><code>VFSVolumeSize()</code></a></p>

<h3 class="hbH3">
  <a name="996357"> </a>VFSFileTell Function <a href="#992934"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="996366"> </a>Purpose 
</h4>

<p><a name="1053513"> </a>Get the current position of the file pointer within an open file. This function only operates on files and cannot be used with directories.</p>
<h4>
  <a name="996379"> </a>Declared In 
</h4>
<code>VFSMgr.h<a name="996390"> </a></code><h4>
  <a name="996400"> </a>Prototype 
</h4>
<pre class="proto"><a name="996411"></a>status_t VFSFileTell (
   FileRef <code class="par">fileRef</code>,
   uint32_t <code class="par">*filePosP</code>
)
</pre>
<h4>
  <a name="996425"> </a>Parameters 
</h4>

<dl>
<dt><a name="996436"> </a><code>&rarr;  <i>fileRef</i></code></dt>
<dd><a name="996446"> </a>File reference returned from <a href="VFSMgr.html#995477"><code>VFSFileOpen()</code></a>.</dd>

<dt><a name="996456"> </a><code>&larr;  <i>filePosP</i></code></dt>
<dd><a name="996466"> </a>Pointer to the current file position.</dd>

</dl>
<h4>
  <a name="996468"> </a>Returns 
</h4>

<p><a name="1077823"> </a>Returns <code>errNone</code> if the operation completed successfully, or one of the following otherwise:</p>

<dl>
<dt><a name="1053530"> </a><code><code>expErrNotOpen</code></code></dt>
<dd><a name="1053715"> </a>The file system library necessary for this call has not been installed or has not been opened.</dd>

<dt><a name="1053531"> </a><code><code>vfsErrFileBadRef</code></code></dt>
<dd><a name="1053748"> </a>The specified file reference is invalid.</dd>

<dt><a name="1053532"> </a><code><code>vfsErrIsADirectory</code></code></dt>
<dd><a name="1053815"> </a>The specified file reference points to a directory instead of a file. This is an invalid operation on a directory.</dd>

<dt><a name="1053533"> </a><code><code>vfsErrNoFileSystem</code></code></dt>
<dd><a name="1053888"> </a>The VFS Manager cannot find an appropriate file system to handle the request.</dd>

</dl>
<h4>
  <a name="996478"> </a>See Also 
</h4>

<p><a name="1053968"> </a><a href="VFSMgr.html#996105"><code>VFSFileSeek()</code></a>, <a href="VFSMgr.html#996311"><code>VFSFileSize()</code></a></p>

<h3 class="hbH3">
  <a name="996483"> </a>VFSFileWrite Function <a href="#992934"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="996488"> </a>Purpose 
</h4>

<p><a name="996491"> </a>Write data to an open file. This function only operates on files and cannot be used with directories.</p>
<h4>
  <a name="996493"> </a>Declared In 
</h4>
<code>VFSMgr.h<a name="996496"> </a></code><h4>
  <a name="996498"> </a>Prototype 
</h4>
<pre class="proto"><a name="996501"></a>status_t VFSFileWrite (
   FileRef <code class="par">fileRef</code>,
   uint32_t <code class="par">numBytes</code>,
   const void <code class="par">*dataP</code>,
   uint32_t <code class="par">*numBytesWrittenP</code>
)
</pre>
<h4>
  <a name="996503"> </a>Parameters 
</h4>

<dl>
<dt><a name="996506"> </a><code>&rarr;  <i>fileRef</i></code></dt>
<dd><a name="996508"> </a>File reference returned from <a href="VFSMgr.html#995477"><code>VFSFileOpen()</code></a>.</dd>

<dt><a name="996510"> </a><code>&rarr;  <i>numBytes</i></code></dt>
<dd><a name="996512"> </a>The number of bytes to write.</dd>

<dt><a name="996514"> </a><code>&rarr;  <i>dataP</i></code></dt>
<dd><a name="996516"> </a>Pointer to the data that is to be written.</dd>

<dt><a name="996518"> </a><code>&larr;  <i>numBytesWrittenP</i></code></dt>
<dd><a name="996520"> </a>Pointer to an unsigned integer that reflects the number of bytes actually written. This value is set on return and does not need to be initialized. If no bytes are written the value is set to zero. Pass <code>NULL</code> for this parameter if you do not need to know how many bytes were written. </dd>

</dl>
<h4>
  <a name="996526"> </a>Returns 
</h4>

<p><a name="1077860"> </a>Returns <code>errNone</code> if the operation completed successfully, or one of the following otherwise:</p>

<dl>
<dt><a name="1054779"> </a><code><code>expErrNotOpen</code></code></dt>
<dd><a name="1054927"> </a>The file system library necessary for this call has not been installed or has not been opened.</dd>

<dt><a name="1054780"> </a><code><code>vfsErrFileBadRef	</code></code></dt>
<dd><a name="1054928"> </a>The specified file reference is invalid.</dd>

<dt><a name="1054781"> </a><code><code>vfsErrFilePermissionDenied</code></code></dt>
<dd><a name="1054929"> </a>Write permission is not enabled for this file.</dd>

<dt><a name="1054782"> </a><code><code>vfsErrIsADirectory</code></code></dt>
<dd><a name="1054930"> </a>The specified file reference points to a directory instead of a file. This is an invalid operation on a directory.</dd>

<dt><a name="1054783"> </a><code><code>vfsErrNoFileSystem</code></code></dt>
<dd><a name="1054931"> </a>The VFS Manager cannot find an appropriate file system to handle the request.</dd>

<dt><a name="1054784"> </a><code><code>vfsErrVolumeFull</code></code></dt>
<dd><a name="1054932"> </a>There is not enough space left on the volume.</dd>

</dl>
<h4>
  <a name="1054790"> </a>See Also 
</h4>

<p><a name="1054796"> </a><a href="VFSMgr.html#994325"><code>VFSExportDatabaseToFile()</code></a>, <a href="VFSMgr.html#994399"><code>VFSExportDatabaseToFileCustom()</code></a>, <a href="VFSMgr.html#995787"><code>VFSFileRead()</code></a>, <a href="VFSMgr.html#995845"><code>VFSFileReadData()</code></a></p>

<h3 class="hbH3">
  <a name="996558"> </a>VFSGetDefaultDirectory Function <a href="#992934"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="996563"> </a>Purpose 
</h4>

<p><a name="1054934"> </a>Determine the default location on the given volume for files of a particular type.</p>
<h4>
  <a name="996568"> </a>Declared In 
</h4>
<code>VFSMgr.h<a name="996571"> </a></code><h4>
  <a name="996573"> </a>Prototype 
</h4>
<pre class="proto"><a name="996576"></a>status_t VFSGetDefaultDirectory (
   uint16_t <code class="par">volRefNum</code>,
   const char <code class="par">*fileTypeStr</code>,
   char <code class="par">*pathStr</code>,
   uint16_t <code class="par">*bufSizeP</code>
)
</pre>
<h4>
  <a name="996578"> </a>Parameters 
</h4>

<dl>
<dt><a name="996581"> </a><code>&rarr;  <i>volRefNum</i></code></dt>
<dd><a name="996583"> </a>Volume reference number returned from <a href="VFSMgr.html#997470"><code>VFSVolumeEnumerate()</code></a>.</dd>

<dt><a name="996585"> </a><code>&rarr;  <i>fileTypeStr</i></code></dt>
<dd><a name="996587"> </a>Pointer to the requested file type, as a null-terminated string. The file type may either be a MIME media type/subtype pair, such as "image/jpeg", "text/plain", or "audio/basic"; or a file extension, such as "<code>.jpeg</code>."</dd>

<dt><a name="996589"> </a><code>&larr;  <i>pathStr</i></code></dt>
<dd><a name="996591"> </a>Pointer to the buffer which receives the default directory path for the requested file type.</dd>

<dt><a name="996593"> </a><code>&larr;  <i>bufSizeP</i></code></dt>
<dd><a name="996595"> </a>Pointer to the size of the path (including the null terminator). Set this to the size of <code class="par">pathStr</code> buffer on input. Reflects the number of bytes copied to <code class="par">pathStr</code> on output. Note that if truncation occurred the actual length of the string might be less than indicated by this value.</dd>

</dl>
<h4>
  <a name="996597"> </a>Returns 
</h4>

<p><a name="1077865"> </a>Returns <code>errNone</code> if the operation completed successfully, or one of the following otherwise:</p>

<dl>
<dt><a name="1055120"> </a><code><code>vfsErrBadName</code></code></dt>
<dd><a name="1055830"> </a>There is no default directory registered for the requested file type.</dd>

<dt><a name="1055121"> </a><code><code>vfsErrBufferOverflow</code></code></dt>
<dd><a name="1055831"> </a>A match was found, but the <code class="par">pathStr</code> buffer is too small to hold the resulting path string. A partial path is returned in <code class="par">pathStr</code>.</dd>

<dt><a name="1055122"> </a><code><code>vfsErrFileNotFound</code></code></dt>
<dd><a name="1056404"> </a>No match was found for the specified volume. The error could have occurred with either the media type specified for this volume or the file type requested.</dd>

</dl>
<h4>
  <a name="1055123"> </a>Comments 
</h4>

<p><a name="1055124"> </a>This function returns the complete path to the default directory registered for the specified file type. A default directory can be registered for each type of media supported. The directory should be registered under media and file type. Note that this directory is typically a "root" directory for the file type; any subdirectories under this root directory should also be searched for files of the appropriate type.</p>

<p><a name="1055125"> </a>This function can be used by an image viewer application, for example, to find the directory containing images without having to know what type of media the volume was on. This could be <br>"/DCIM", "/images", or something else depending on the type of media.</p>
<h4>
  <a name="1055131"> </a>See Also 
</h4>

<p><a name="1055138"> </a><a href="VFSMgr.html#994232"><code>VFSDirEntryEnumerate()</code></a>, <a href="VFSMgr.html#997241"><code>VFSRegisterDefaultDirectory()</code></a>, <a href="VFSMgr.html#997400"><code>VFSUnregisterDefaultDirectory()</code></a></p>

<h3 class="hbH3">
  <a name="996612"> </a>VFSImportDatabaseFromFile Function <a href="#992934"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="996617"> </a>Purpose 
</h4>

<p><a name="996620"> </a>Create a database from a PDB or PRC file on an external storage card.</p>
<h4>
  <a name="996622"> </a>Declared In 
</h4>
<code>VFSMgr.h<a name="996625"> </a></code><h4>
  <a name="996627"> </a>Prototype 
</h4>
<pre class="proto"><a name="996656"></a>status_t VFSImportDatabaseFromFile (
   uint16_t <code class="par">volRefNum</code>,
   const char <code class="par">*pathNameP</code>,
   DatabaseID <code class="par">*dbIDP</code>
)
</pre>
<h4>
  <a name="996712"> </a>Parameters 
</h4>

<dl>
<dt><a name="996763"> </a><code>&rarr;  <i>volRefNum</i></code></dt>
<dd><a name="996813"> </a>Volume on which the source file resides.</dd>

<dt><a name="996863"> </a><code>&rarr;  <i>pathNameP</i></code></dt>
<dd><a name="996913"> </a>Pointer to the full path and name of the source file.</dd>

<dt><a name="996915"> </a><code>&larr;  <i>dbIDP</i></code></dt>
<dd><a name="996917"> </a>Pointer to a variable that receives the database ID of the new database. If the database already resides in the storage heap, the database ID of the existing database is returned along with the error <code>dmErrAlreadyExists</code>.</dd>

</dl>
<h4>
  <a name="996919"> </a>Returns 
</h4>

<p><a name="1077870"> </a>Returns <code>errNone</code> if the operation completed successfully, or one of the following otherwise:</p>

<dl>
<dt><a name="1057418"> </a><code><code>dmErrAlreadyExists</code></code></dt>
<dd><a name="1057732"> </a>The PRC or PDB file already exists in the storage heap. In this case <code class="par">dbIDP</code> is set to point to the existing file.</dd>

<dt><a name="1057419"> </a><code><code>expErrNotEnoughPower</code></code></dt>
<dd><a name="1057953"> </a>There is insufficient battery power to complete the requested operation.</dd>

<dt><a name="1057420"> </a><code><code>vfsErrBadName</code></code></dt>
<dd><a name="1057954"> </a>The path name specified in <code class="par">pathNameP</code> is not valid.</dd>

</dl>
<h4>
  <a name="1057421"> </a>Comments 
</h4>

<p><a name="1057422"> </a>This utility function imports a PDB or PRC file resident on an external storage card into a new database in the storage heap. It first calls <a href="VFSMgr.html#995477"><code>VFSFileOpen()</code></a> to open the file specified in <code>pathNameP</code>. Assuming that a corresponding PRC or PDB does not already exist in the storage heap, <a href="VFSMgr.html#996612"><code>VFSImportDatabaseFromFile()</code></a><span style="color: #000000;  font-family: Courier; font-style: normal; font-weight: normal; text-decoration: none; text-transform: none; vertical-align: baseline"> </span>calls the Exchange Manager function <a href="../High-Level_Communications/HLC_ExgMgrRef.html#1269276"><code>ExgDBRead()</code></a> with an internal callback function for importing a file to the Data Manager. The Exchange Manager makes repeated calls to this function, which passes the data back in blocks. Once the file has been successfully imported, the owner (the imported file, if it's an executable, or the associated application if it is not) is sent a <a href="../Programming_Basics/CmnLaunchCodes.html#993716"><code>sysAppLaunchCmdSyncNotify</code></a> launch code to make it aware of the new database.</p>

<p><a name="1057435"> </a>This function only imports the specified PDB or PRC file; it does not import bundled databases or overlays. If there are bundled databases and/or overlays associated with the PDB or PRC file you are importing, you will need to write additional code to explicitly handle them.</p>

<p><a name="1057436"> </a>This function doesn't provide any progress indication to the user. If you need to provide feedback to the user as the file import progresses, use <a href="VFSMgr.html#996934"><code>VFSImportDatabaseFromFileCustom()</code></a> instead.</p>

<p><a name="1057440"> </a>This function is used, for example, to copy applications from a storage card to main memory.</p>
<h4>
  <a name="1057446"> </a>See Also 
</h4>

<p><a name="1057453"> </a><a href="VFSMgr.html#994325"><code>VFSExportDatabaseToFile()</code></a>, <a href="VFSMgr.html#995787"><code>VFSFileRead()</code></a></p>

<h3 class="hbH3">
  <a name="996934"> </a>VFSImportDatabaseFromFileCustom Function <a href="#992934"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="996939"> </a>Purpose 
</h4>

<p><a name="1062474"> </a>Create a database from the specified PDB or PRC file on an external storage card. This function differs from <a href="VFSMgr.html#996612"><code>VFSImportDatabaseFromFile()</code></a> in that it allows you to track the progress of the import operation.</p>
<h4>
  <a name="996944"> </a>Declared In 
</h4>
<code>VFSMgr.h<a name="996947"> </a></code><h4>
  <a name="996949"> </a>Prototype 
</h4>
<pre class="proto"><a name="996952"></a>status_t VFSImportDatabaseFromFileCustom (
   uint16_t <code class="par">volRefNum</code>,
   const char <code class="par">*pathNameP</code>,
   DatabaseID <code class="par">*dbIDP</code>,
   VFSImportProcPtr <code class="par">importProcP</code>,
   void <code class="par">*userDataP</code>
)
</pre>
<h4>
  <a name="996954"> </a>Parameters 
</h4>

<dl>
<dt><a name="1064195"> </a><code>&rarr;  <i>volRefNum</i></code></dt>
<dd><a name="1064196"> </a>Volume on which the source file resides.</dd>

<dt><a name="1064197"> </a><code>&rarr;  <i>pathNameP</i></code></dt>
<dd><a name="1064198"> </a>Pointer to the full path and name of the source file.</dd>

<dt><a name="1064204"> </a><code>&larr;  <i>dbIDP</i></code></dt>
<dd><a name="1064205"> </a>Pointer to the variable that receives the database ID of the new database. If the database already resides in the storage heap, the database ID of the existing database is returned along with the error <code>dmErrAlreadyExists</code>.</dd>

<dt><a name="1064206"> </a><code>&rarr;  <i>importProcP</i></code></dt>
<dd><a name="1064207"> </a>User-defined callback function that tracks the progress of the import. This function should allow the user to cancel the import. Pass <code>NULL</code> if you don't have a progress callback function. See <a href="VFSMgr.html#998201"><code>VFSImportProcPtr()</code></a> for the requirements of this function.</dd>

<dt><a name="1064211"> </a><code>&rarr;  <i>userDataP</i></code></dt>
<dd><a name="1064212"> </a>Pointer to any data you want to pass to the callback function specified in <code class="par">importProcP</code>. This information is not used internally by the VFS Manager. Pass <code>NULL</code> if you don't have a progress callback function, or if that function doesn't need any such data.</dd>

</dl>
<h4>
  <a name="1064213"> </a>Returns 
</h4>

<p><a name="1077875"> </a>Returns <code>errNone</code> if the operation completed successfully, or one of the following otherwise:</p>

<dl>
<dt><a name="1064217"> </a><code><code>vfsErrBadName</code></code></dt>
<dd><a name="1064218"> </a>The path name specified in <code class="par">pathNameP</code> is not valid.</dd>

<dt><a name="1064219"> </a><code><code>expErrNotEnoughPower</code></code></dt>
<dd><a name="1064220"> </a>The power required to import a database is not available.</dd>

<dt><a name="1064221"> </a><code><code>dmErrAlreadyExists</code></code></dt>
<dd><a name="1064222"> </a>The PRC or PDB file already exists in main memory. In this case the <code class="par">cardNoP</code> and <code class="par">dbIDP</code> are set to point to the existing file.</dd>

</dl>
<h4>
  <a name="1064223"> </a>Comments 
</h4>

<p><a name="1064227"> </a>This function is similar to <a href="VFSMgr.html#996612"><code>VFSImportDatabaseFromFile()</code></a> in that it imports a PDB or PRC file on an external storage card into a new database on the storage heap. It extends the functionality by allowing you to specify a callback function that tracks the progress of the export. It first calls <a href="VFSMgr.html#995477"><code>VFSFileOpen()</code></a> to open the file specified in <code class="par">pathNameP</code>. If a corresponding PRC or PDB does not already exist in main memory, it calls the Exchange Manager function <a href="../High-Level_Communications/HLC_ExgMgrRef.html#1269276"><code>ExgDBRead()</code></a> with an internal callback function for importing the file from the Data Manager. The Exchange Manager makes repeated calls to this function, which receives the data back in blocks. The progress tracker, if one has been specified, is also called every time a new chunk of data is passed back. Once the file has been successfully imported, the owner (the imported file, if it's an executable, or the associated application if it is not) is sent a <a href="../Programming_Basics/CmnLaunchCodes.html#993716"><code>sysAppLaunchCmdSyncNotify</code></a> launch code to make it aware of the new database.</p>

<p><a name="1064237"> </a>Like <code>VFSImportDatabaseFromFile</code>, this function only imports the specified PDB or PRC file; it does not import bundled databases or overlays.</p>

<p><a name="1064238"> </a>This function is used, for example, to copy applications from a storage card to main memory.</p>
<h4>
  <a name="1064241"> </a>See Also 
</h4>

<p><a name="1064248"> </a><a href="VFSMgr.html#995787"><code>VFSFileRead()</code></a>, <a href="VFSMgr.html#994399"><code>VFSExportDatabaseToFileCustom()</code></a></p>

<h3 class="hbH3">
  <a name="996996"> </a>VFSImportDatabaseFromFileCustomV40 Function <a href="#992934"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="997001"> </a>Purpose 
</h4>

<p><a name="1062487"> </a>Create a database from the specified PDB or PRC file on an external storage card. This function differs from <a href="VFSMgr.html#996612"><code>VFSImportDatabaseFromFile()</code></a> in that it allows you to track the progress of the import operation.</p>
<h4>
  <a name="997006"> </a>Declared In 
</h4>
<code>VFSMgr.h<a name="997009"> </a></code><h4>
  <a name="997011"> </a>Prototype 
</h4>
<pre class="proto"><a name="997014"></a>status_t VFSImportDatabaseFromFileCustomV40 (
   uint16_t <code class="par">volRefNum</code>,
   const char <code class="par">*pathNameP</code>,
   uint16_t <code class="par">*cardNoP</code>,
   LocalID <code class="par">*dbIDP</code>,
   VFSImportProcPtr <code class="par">importProcP</code>,
   void <code class="par">*userDataP</code>
)
</pre>
<h4>
  <a name="997016"> </a>Parameters 
</h4>

<dl>
<dt><a name="997019"> </a><code>&rarr;  <i>volRefNum</i></code></dt>
<dd><a name="997021"> </a>Volume on which the source file resides.</dd>

<dt><a name="997023"> </a><code>&rarr;  <i>pathNameP</i></code></dt>
<dd><a name="997025"> </a>Pointer to the full path and name of the source file.</dd>

<dt><a name="997027"> </a><code>&larr;  <i>cardNoP</i></code></dt>
<dd><a name="997029"> </a>Pointer to the variable that receives the card number of the newly-created database. If the database already resides in the storage heap, the card number of the existing database is returned along with the error <code>dmErrAlreadyExists</code>.</dd>

<dt><a name="997031"> </a><code>&larr;  <i>dbIDP</i></code></dt>
<dd><a name="997037"> </a>Pointer to the variable that receives the database ID of the new database. If the database already resides in the storage heap, the database ID of the existing database is returned along with the error <code>dmErrAlreadyExists</code>.</dd>

<dt><a name="997039"> </a><code>&rarr;  <i>importProcP</i></code></dt>
<dd><a name="997041"> </a>User-defined callback function that tracks the progress of the import. This function should allow the user to cancel the import. Pass <code>NULL</code> if you don't have a progress callback function. See <a href="VFSMgr.html#998201"><code>VFSImportProcPtr()</code></a> for the requirements of this function.</dd>

<dt><a name="997043"> </a><code>&rarr;  <i>userDataP</i></code></dt>
<dd><a name="997045"> </a>Pointer to any data you want to pass to the callback function specified in <code class="par">importProcP</code>. This information is not used internally by the VFS Manager. Pass <code>NULL</code> if you don't have a progress callback function, or if that function doesn't need any such data.</dd>

</dl>
<h4>
  <a name="997047"> </a>Returns 
</h4>

<p><a name="1077884"> </a>Returns <code>errNone</code> if the operation completed successfully, or one of the following otherwise:</p>

<dl>
<dt><a name="1063123"> </a><code><code>vfsErrBadName</code></code></dt>
<dd><a name="1063885"> </a>The path name specified in <code class="par">pathNameP</code> is not valid.</dd>

<dt><a name="1063124"> </a><code><code>expErrNotEnoughPower</code></code></dt>
<dd><a name="1063886"> </a>The power required to import a database is not available.</dd>

<dt><a name="1063125"> </a><code><code>dmErrAlreadyExists</code></code></dt>
<dd><a name="1064017"> </a>The PRC or PDB file already exists in main memory. In this case the <code class="par">cardNoP</code> and <code class="par">dbIDP</code> are set to point to the existing file.</dd>

</dl>
<h4>
  <a name="1063126"> </a>Comments 
</h4>

<p><a name="1063130"> </a>This function is similar to <a href="VFSMgr.html#996612"><code>VFSImportDatabaseFromFile()</code></a> in that it imports a PDB or PRC file on an external storage card into a new database on the storage heap. It extends the functionality by allowing you to specify a callback function that tracks the progress of the export. It first calls <a href="VFSMgr.html#995477"><code>VFSFileOpen()</code></a> to open the file specified in <code class="par">pathNameP</code>. If a corresponding PRC or PDB does not already exist in main memory, it calls the Exchange Manager function <a href="../High-Level_Communications/HLC_ExgMgrRef.html#1269276"><code>ExgDBRead()</code></a> with an internal callback function for importing the file from the Data Manager. The Exchange Manager makes repeated calls to this function, which receives the data back in blocks. The progress tracker, if one has been specified, is also called every time a new chunk of data is passed back. Once the file has been successfully imported, the owner (the imported file, if it's an executable, or the associated application if it is not) is sent a <a href="../Programming_Basics/CmnLaunchCodes.html#993716"><code>sysAppLaunchCmdSyncNotify</code></a> launch code to make it aware of the new database.</p>

<p><a name="1063140"> </a>Like <code>VFSImportDatabaseFromFile</code>, this function only imports the specified PDB or PRC file; it does not import bundled databases or overlays.</p>

<p><a name="1063141"> </a>This function is used, for example, to copy applications from a storage card to main memory.</p>
<h4>
  <a name="1059109"> </a>Compatibility 
</h4>

<p><a name="1059110"> </a>This function is only provided for compatibility with previous versions of Palm OS. The returned <code class="par">*cardNoP</code> is always 0.</p>
<h4>
  <a name="1063828"> </a>See Also 
</h4>

<p><a name="1063835"> </a><a href="VFSMgr.html#995787"><code>VFSFileRead()</code></a>, <a href="VFSMgr.html#994399"><code>VFSExportDatabaseToFileCustom()</code></a>, <a href="VFSMgr.html#996934"><code>VFSImportDatabaseFromFileCustom()</code></a></p>

<h3 class="hbH3">
  <a name="997062"> </a>VFSImportDatabaseFromFileV40 Function <a href="#992934"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="997067"> </a>Purpose 
</h4>

<p><a name="1057956"> </a>Create a database from a PDB or PRC file on an external storage card.</p>
<h4>
  <a name="997072"> </a>Declared In 
</h4>
<code>VFSMgr.h<a name="997075"> </a></code><h4>
  <a name="997077"> </a>Prototype 
</h4>
<pre class="proto"><a name="997080"></a>status_t VFSImportDatabaseFromFileV40 (
   uint16_t <code class="par">volRefNum</code>,
   const char <code class="par">*pathNameP</code>,
   uint16_t <code class="par">*cardNoP</code>,
   LocalID <code class="par">*dbIDP</code>
)
</pre>
<h4>
  <a name="997082"> </a>Parameters 
</h4>

<dl>
<dt><a name="1057988"> </a><code>&rarr;  <i>volRefNum</i></code></dt>
<dd><a name="1057989"> </a>Volume on which the source file resides.</dd>

<dt><a name="1057990"> </a><code>&rarr;  <i>pathNameP</i></code></dt>
<dd><a name="1057991"> </a>Pointer to the full path and name of the source file.</dd>

<dt><a name="1058436"> </a><code>&larr;  <i>cardNoP</i></code></dt>
<dd><a name="1058437"> </a>Pointer to a variable that receives the card number of the newly-created database. If the database already resides in the storage heap, the card number of the existing database is returned along with the error <code>dmErrAlreadyExists</code>.</dd>

<dt><a name="1057992"> </a><code>&larr;  <i>dbIDP</i></code></dt>
<dd><a name="1057993"> </a>Pointer to a variable that receives the database ID of the new database. If the database already resides in the storage heap, the database ID of the existing database is returned along with the error <code>dmErrAlreadyExists</code>.</dd>

</dl>
<h4>
  <a name="997105"> </a>Returns 
</h4>

<p><a name="1078009"> </a>Returns <code>errNone</code> if the operation completed successfully, or one of the following otherwise:</p>

<dl>
<dt><a name="1058953"> </a><code><code>dmErrAlreadyExists</code></code></dt>
<dd><a name="1058954"> </a>The PRC or PDB file already exists in the storage heap. In this case <code class="par">dbIDP</code> is set to point to the existing file.</dd>

<dt><a name="1058955"> </a><code><code>expErrNotEnoughPower</code></code></dt>
<dd><a name="1058956"> </a>There is insufficient battery power to complete the requested operation.</dd>

<dt><a name="1058957"> </a><code><code>vfsErrBadName</code></code></dt>
<dd><a name="1058958"> </a>The path name specified in <code class="par">pathNameP</code> is not valid.</dd>

</dl>
<h4>
  <a name="1058959"> </a>Comments 
</h4>

<p><a name="1058960"> </a>This utility function imports a PDB or PRC file resident on an external storage card into a new database in the storage heap. It first calls <a href="VFSMgr.html#995477"><code>VFSFileOpen()</code></a> to open the file specified in <code>pathNameP</code>. Assuming that a corresponding PRC or PDB does not already exist in the storage heap, <a href="VFSMgr.html#996612"><code>VFSImportDatabaseFromFile()</code></a><span style="color: #000000;  font-family: Courier; font-style: normal; font-weight: normal; text-decoration: none; text-transform: none; vertical-align: baseline"> </span>calls the Exchange Manager function <a href="../High-Level_Communications/HLC_ExgMgrRef.html#1269276"><code>ExgDBRead()</code></a> with an internal callback function for importing a file to the Data Manager. The Exchange Manager makes repeated calls to this function, which passes the data back in blocks. Once the file has been successfully imported, the owner (the imported file, if it's an executable, or the associated application if it is not) is sent a <a href="../Programming_Basics/CmnLaunchCodes.html#993716"><code>sysAppLaunchCmdSyncNotify</code></a> launch code to make it aware of the new database.</p>

<p><a name="1058973"> </a>This function only imports the specified PDB or PRC file; it does not import bundled databases or overlays. If there are bundled databases and/or overlays associated with the PDB or PRC file you are importing, you will need to write additional code to explicitly handle them.</p>

<p><a name="1058974"> </a>This function doesn't provide any progress indication to the user. If you need to provide feedback to the user as the file import progresses, use <a href="VFSMgr.html#996934"><code>VFSImportDatabaseFromFileCustom()</code></a> instead.</p>

<p><a name="1058978"> </a>This function is used, for example, to copy applications from a storage card to main memory.</p>
<h4>
  <a name="1059189"> </a>Compatibility 
</h4>

<p><a name="1059190"> </a>This function is only provided for compatibility with previous versions of Palm OS. The returned <code class="par">*cardNoP</code> is always 0.</p>
<h4>
  <a name="1058979"> </a>See Also 
</h4>

<p><a name="1058986"> </a><a href="VFSMgr.html#994325"><code>VFSExportDatabaseToFile()</code></a>, <a href="VFSMgr.html#995787"><code>VFSFileRead()</code></a>, <a href="VFSMgr.html#996612"><code>VFSImportDatabaseFromFile()</code></a></p>

<h3 class="hbH3">
  <a name="997241"> </a>VFSRegisterDefaultDirectory Function <a href="#992934"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="997270"> </a>Purpose 
</h4>

<p><a name="1065054"> </a>Register a specific directory as the default location for files of a given type on a particular kind of external storage card. This function is generally called by a slot driver for files and media types that are supported by that slot driver.</p>
<h4>
  <a name="997275"> </a>Declared In 
</h4>
<code>VFSMgr.h<a name="997278"> </a></code><h4>
  <a name="997280"> </a>Prototype 
</h4>
<pre class="proto"><a name="997283"></a>status_t VFSRegisterDefaultDirectory (
   const char <code class="par">*fileTypeStr</code>,
   uint32_t <code class="par">mediaType</code>,
   const char <code class="par">*pathStr</code>
)
</pre>
<h4>
  <a name="997285"> </a>Parameters 
</h4>

<dl>
<dt><a name="997288"> </a><code>&rarr;  <i>fileTypeStr</i></code></dt>
<dd><a name="997290"> </a>Pointer to the file type to register. This is a null-terminated string that can either be a MIME media type/subtype pair, such as "image/jpeg", "text/plain", or "audio/basic"; or a file extension, such as "<code>.jpeg</code>".</dd>

<dt><a name="997292"> </a><code>&rarr;  <i>mediaType</i></code></dt>
<dd><a name="997294"> </a>Type of card media for which the default directory is being associated. See <a href="../System_Management/ExpansionMgr.html#999014">"Defined Media Types"</a> in <i>Exploring Palm OS: System Management</i> for the list of accepted values.</dd>

<dt><a name="997296"> </a><code>&rarr;  <i>pathStr</i></code></dt>
<dd><a name="997298"> </a>Pointer to the default directory path to be associated with the specified file type. This string must be null-terminated, and must be the full path to the directory.</dd>

</dl>
<h4>
  <a name="997300"> </a>Returns 
</h4>

<p><a name="1078050"> </a>Returns <code>errNone</code> if the operation completed successfully, or one of the following otherwise:</p>

<dl>
<dt><a name="1065439"> </a><code><code>sysErrParamErr</code></code></dt>
<dd><a name="1065731"> </a>Either the <code class="par">fileTypeStr</code> parameter is <code>NULL</code> or the <code class="par">pathStr</code> parameter is <code>NULL</code>.</dd>

<dt><a name="1065440"> </a><code><code>vfsErrFileAlreadyExists</code></code></dt>
<dd><a name="1065736"> </a>A default directory has already been registered for this file type on the specified card media type.</dd>

</dl>
<h4>
  <a name="1065441"> </a>Comments 
</h4>

<p><a name="1065442"> </a>This function first verifies that a default directory has not already been registered for the specified combination of file type and media type, and returns <code>vfsErrFileAlreadyExists</code> if one has been registered. To change an existing entry in the registry, you must first remove the existing entry with a call to <a href="VFSMgr.html#997400"><code>VFSUnregisterDefaultDirectory()</code></a> before re-registering it with <code>VFSRegisterDefaultDirectory</code>.</p>

<p><a name="1065446"> </a>The specified directory registered for a given file type is intended to be the "root" default directory. If a given default directory has one or more subdirectories, applications should also search those subdirectories for files of the appropriate type.</p>

<div><hr>
  <a name="1095229"> </a> <b>NOTE: </b> Registering a directory as the default location for files of a given type on a particular type of media doesn't automatically register that file type with HotSync Exchange. See <a href="../High-Level_Communications/HLC_ExgMgrConcept.html#1007009">"HotSync Exchange"</a> of <i>Exploring Palm OS: High-Level Communications</i> for information on registering file types with HotSync Exchange.
<hr>
</div>
<h4>
  <a name="1065452"> </a>See Also 
</h4>

<p><a name="1065456"> </a><a href="VFSMgr.html#996558"><code>VFSGetDefaultDirectory()</code></a></p>

<h3 class="hbH3">
  <a name="997400"> </a>VFSUnregisterDefaultDirectory Function <a href="#992934"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="1066290"> </a>Purpose 
</h4>

<p><a name="1066291"> </a>Sever the association between a particular file type and a default directory for a given type of card media.</p>
<h4>
  <a name="1066292"> </a>Declared In 
</h4>
<code>VFSMgr.h<a name="997437"> </a></code><h4>
  <a name="997439"> </a>Prototype 
</h4>
<pre class="proto"><a name="997442"></a>status_t VFSUnregisterDefaultDirectory (
   const char <code class="par">*fileTypeStr</code>,
   uint32_t <code class="par">mediaType</code>
)
</pre>
<h4>
  <a name="997444"> </a>Parameters 
</h4>

<dl>
<dt><a name="997447"> </a><code>&rarr;  <i>fileTypeStr</i></code></dt>
<dd><a name="997449"> </a>Pointer to the file type with which the default directory is associated. This is a null-terminated string that can either be a MIME media type/subtype pair, such as "image/jpeg", "text/plain", or "audio/basic"; or a file extension, such as "<code>.jpeg</code>".</dd>

<dt><a name="997451"> </a><code>&rarr;  <i>mediaType</i></code></dt>
<dd><a name="997453"> </a>Type of card media for which the default directory is associated. See <a href="../System_Management/ExpansionMgr.html#999014">"Defined Media Types"</a> in <i>Exploring Palm OS: System Management</i> for the list of accepted values.</dd>

</dl>
<h4>
  <a name="997455"> </a>Returns 
</h4>

<p><a name="1078120"> </a>Returns <code>errNone</code> if the operation completed successfully, or one of the following otherwise:</p>

<dl>
<dt><a name="1066481"> </a><code><code>sysErrParamErr</code></code></dt>
<dd><a name="1066613"> </a>The <code class="par">fileTypeStr</code> parameter is <code>NULL</code>.</dd>

<dt><a name="1066482"> </a><code><code>vfsErrFileNotFound</code></code></dt>
<dd><a name="1066614"> </a>A default directory could not be found in the registry for the specified file and media type.</dd>

</dl>
<h4>
  <a name="1066483"> </a>Comments 
</h4>

<div><hr>
  <a name="1066484"> </a> <b>NOTE: </b> Caution is advised when using this function, since you may remove another application's registration, causing data to mysteriously disappear from those applications.
<hr>
</div>
<h4>
  <a name="1066490"> </a>See Also 
</h4>

<p><a name="1066497"> </a><a href="VFSMgr.html#996558"><code>VFSGetDefaultDirectory()</code></a>, <a href="VFSMgr.html#997241"><code>VFSRegisterDefaultDirectory()</code></a></p>

<h3 class="hbH3">
  <a name="997470"> </a>VFSVolumeEnumerate Function <a href="#992934"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="997475"> </a>Purpose 
</h4>

<p><a name="997478"> </a>Enumerate the mounted volumes.</p>
<h4>
  <a name="997480"> </a>Declared In 
</h4>
<code>VFSMgr.h<a name="997483"> </a></code><h4>
  <a name="997485"> </a>Prototype 
</h4>
<pre class="proto"><a name="997488"></a>status_t VFSVolumeEnumerate (
   uint16_t <code class="par">*volRefNumP</code>,
   uint32_t <code class="par">*volIteratorP</code>
)
</pre>
<h4>
  <a name="997490"> </a>Parameters 
</h4>

<dl>
<dt><a name="997493"> </a><code>&larr;  <i>volRefNumP</i></code></dt>
<dd><a name="997495"> </a>Pointer to the reference number for the volume represented by the current enumeration, or <code>vfsInvalidVolRef</code> if there are no more volumes to be enumerated or an error occurred.</dd>

<dt><a name="997497"> </a><code>&harr;  <i>volIteratorP</i></code></dt>
<dd><a name="997499"> </a>Pointer to a variable that holds the index of the current enumeration. Set the variable to <code>vfsIteratorStart</code> prior to the first iteration. Each call to <code>VFSVolumeEnumerate</code> updates the variable to the index of the next volume. When the last volume is reached, the variable pointed to by <code>volIteratorP</code> is set to <code>vfsIteratorStop</code>.</dd>

</dl>
<h4>
  <a name="997501"> </a>Returns 
</h4>

<p><a name="1078125"> </a>Returns <code>errNone</code> if the operation completed successfully, or one of the following otherwise:</p>

<dl>
<dt><a name="1066807"> </a><code><code>expErrEnumerationEmpty</code></code></dt>
<dd><a name="1066945"> </a>There are no volumes to enumerate.</dd>

<dt><a name="1066808"> </a><code><code>sysErrParamErr</code></code></dt>
<dd><a name="1067034"> </a>The value pointed to by <code class="par">volIteratorP</code> is not valid. This error is also returned when <code class="par">volIteratorP</code> is <code>vfsIteratorStop</code>.</dd>

</dl>
<h4>
  <a name="997520"> </a>Comments 
</h4>

<p><a name="1067080"> </a>This function returns a pointer to the volume reference number in the <code class="par">volRefNumP</code> parameter. In order to traverse all volumes you must make repeated calls to <a href="VFSMgr.html#997470"><code>VFSVolumeEnumerate()</code></a> inside a loop. Before the first call to <code>VFSVolumeEnumerate</code>, the variable pointed to by <code class="par">volIteratorP</code> should be initialized to <code>vfsIteratorStart</code>. Each iteration then increments <code class="par">volIteratorP</code> to the next entry after updating <code class="par">volRefNumP</code>. When the last volume is reached, <code>*</code><code class="par">volIteratorP</code> is set to <code>vfsIteratorStop</code>. If there are no volumes to enumerate, <code>VFSVolumeEnumerate</code> returns <code>expErrEnumerationEmpty</code> when first called.</p>
<h4>
  <a name="1067084"> </a>Example 
</h4>

<p><a name="1067085"> </a>Below is an example of how to use <code>VFSVolumeEnumerate</code>. </p>

<div class="CodeRule"><hr></div><pre class="CodeBlock">
UInt16 volRefNum;<a name="1067086"> </a>
UInt32 volIterator = vfsIteratorStart;<a name="1067087"> </a>
 <a name="1067088"> </a>
while (volIterator != vfsIteratorStop) {<a name="1067089"> </a>
   err = VFSVolumeEnumerate(&amp;volRefNum, &amp;volIterator); <a name="1067090"> </a>
   if (err == errNone) {<a name="1067091"> </a>
      // Do something with the volRefNum<a name="1067092"> </a>
   } else {<a name="1067093"> </a>
      // handle error... possibly by <a name="1067094"> </a>
      // breaking out of the loop<a name="1067095"> </a>
   }<a name="1067096"> </a>
}<a name="1067097"> </a>
</pre><div class="CodeRule"><hr></div>


<h3 class="hbH3">
  <a name="997555"> </a>VFSVolumeFormat Function <a href="#992934"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="997568"> </a>Purpose 
</h4>

<p><a name="1067153"> </a>Format and mount the volume installed in a given slot.</p>
<h4>
  <a name="997573"> </a>Declared In 
</h4>
<code>VFSMgr.h<a name="997576"> </a></code><h4>
  <a name="997578"> </a>Prototype 
</h4>
<pre class="proto"><a name="997581"></a>status_t VFSVolumeFormat (
   uint8_t <code class="par">flags</code>,
   uint16_t <code class="par">fsLibRefNum</code>,
   VFSAnyMountParamPtr <code class="par">vfsMountParamP</code>
)
</pre>
<h4>
  <a name="997583"> </a>Parameters 
</h4>

<dl>
<dt><a name="997586"> </a><code>&rarr;  <i>flags</i></code></dt>
<dd><a name="997588"> </a>Flags that control how the volume should be formatted. Currently, the only flag not reserved is <code>vfsMountFlagsUseThisFileSystem</code>. Pass this flag to cause the volume to be formatted using the file system specified by <code>fsLibRefNum</code>. Pass zero (0) to have the VFS Manager attempt to format the volume using a file system appropriate to the slot.</dd>

<dt><a name="997590"> </a><code>&rarr;  <i>fsLibRefNum</i></code></dt>
<dd><a name="997592"> </a>Reference number of the file system library for which the volume should be formatted. If the <code>flags</code> field is not set to <code>vfsMountFlagsUseThisFileSystem</code>, this parameter is ignored.</dd>

<dt><a name="997594"> </a><code>&harr;  <i>vfsMountParamP</i></code></dt>
<dd><a name="997596"> </a>Parameters to be used when formatting the volume and when mounting the volume after it has been formatted. Supply a pointer to either a <a href="VFSMgr.html#993157"><code>VFSSlotMountParamType</code></a> or a <a href="VFSMgr.html#993113"><code>VFSPOSEMountParamType</code></a> structure. Note that you'll need to cast your structure pointer to a <code>VFSAnyMountParamPtr</code>. Set the <code>mountClass</code> field to the appropriate value: if you are mounting to an Expansion Manager slot, set <code>mountClass</code> to <code>VFSMountClass_SlotDriver</code> and initialize <code>slotLibRefNum</code> and <code>slotRefNum</code> to the appropriate values. See the descriptions of <a href="VFSMgr.html#993069"><code>VFSAnyMountParamType</code></a>, <a href="VFSMgr.html#993157"><code>VFSSlotMountParamType</code></a>, and <a href="VFSMgr.html#993113"><code>VFSPOSEMountParamType</code></a> for information on the fields that make up these data structures.</dd>

</dl>
<h4>
  <a name="997598"> </a>Returns 
</h4>

<p><a name="1078139"> </a>Returns <code>errNone</code> if the operation completed successfully, or one of the following otherwise:</p>

<dl>
<dt><a name="1067314"> </a><code><code>expErrNotEnoughPower</code></code></dt>
<dd><a name="1067512"> </a>There is insufficient battery power to format and/or mount a volume.</dd>

<dt><a name="1067315"> </a><code><code>expErrNotOpen</code></code></dt>
<dd><a name="1067513"> </a>The file system library necessary for this call has not been installed or has not been opened.</dd>

<dt><a name="1067316"> </a><code><code>vfsErrNoFileSystem</code></code></dt>
<dd><a name="1067514"> </a>The VFS Manager cannot find an appropriate file system to handle the request.</dd>

</dl>
<h4>
  <a name="1067317"> </a>Comments 
</h4>

<p><a name="1067318"> </a>The slot driver currently only supports one volume per slot. If the volume is successfully formatted and mounted, the reference number of the mounted volume is returned in <code>vfsMountParamP-&gt;volRefNum</code>. If the format is unsuccessful or cancelled, <code>vfsMountParamP-&gt;volRefNum</code> is set to <code>vfsInvalidVolRef</code>.</p>

<p><a name="1067319"> </a>If <code>vfsMountFlagsUseThisFileSystem</code> is passed as a flag, <code>VFSVolumeFormat</code> attempts to format the volume using the file system library specified by <code class="par">fsLibRefNum</code>. Typically the flag parameter is not set. In this case <code>VFSVolumeFormat</code> tries to find a compatible library to format the volume, as follows:</p>
<ol type="1">
  <li value="1"><a name="1067320"> </a>Check to see if the default file system library feature is set. If it is, and if that file system is installed, it is used to format the volume. You can set the default file system using <a href="../System_Management/FeatureMgr.html#993944"><code>FtrSet()</code></a>; supply <code>sysFileCVFSMgr</code> for the feature creator, and <code>vfsFtrIDDefaultFS</code> for the feature number.
  <li value="2"><a name="1067324"> </a>Check to see if any of the installed file systems are natively supported for the slot on which the VFS Manager is trying to format. If one of them is, it is used to format the volume.
  <li value="3"><a name="1067325"> </a>If none of the installed file systems can perform the format using the slot's native type, a dialog displays warning the user that their media may become incompatible with other devices if they continue with the format. The user may continue or cancel the format. If the user chooses to continue, <code>VFSVolumeFormat</code> formats the volume using the first file system library that was installed.
</ol>

<p><a name="1067326"> </a>When calling <code>VFSVolumeFormat</code>, the volume can either be mounted or unmounted. The underlying file system library call requires the volume to be unmounted. <code>VFSVolumeFormat</code> checks to see if the volume is currently mounted and unmounts it, if necessary, using <a href="VFSMgr.html#997867"><code>VFSVolumeUnmount()</code></a> before making the file system call. If the file system successfully formats the volume, <code>VFSVolumeFormat</code> mounts it and posts a <a href="../Programming_Basics/NotifyMgr.html#996627"><code>sysNotifyVolumeMountedEvent</code></a> notification.</p>
<h4>
  <a name="1067333"> </a>Example 	
</h4>

<p><a name="1067334"> </a>The following code excerpt formats a volume on an Expansion Manager slot using a compatible file system.</p>

<div class="CodeRule"><hr></div><pre class="CodeBlock">
VFSSlotMountParamType slotParam;<a name="1067335"> </a>
UInt32 slotIterator = expIteratorStart;<a name="1067336"> </a>
 <a name="1067337"> </a>
slotParam.vfsMountParamP.mountClass = 
   VFSMountClass_SlotDriver;<a name="1067338"> </a>
err = ExpSlotEnumerate(&amp;slotParam.slotRefNum, 
   &amp;slotIterator);<a name="1067339"> </a>
err = ExpSlotLibFind(slotParam.slotRefNum,
   &amp;slotParam.slotLibRefNum);<a name="1067340"> </a>
 <a name="1067341"> </a>
err = VFSVolumeFormat(NULL, NULL, 
   (VFSAnyMountParamPtr) &amp; slotParam);<a name="1067342"> </a>
</pre><div class="CodeRule"><hr></div>

<h4>
  <a name="1067348"> </a>See Also 
</h4>

<p><a name="1067352"> </a><a href="VFSMgr.html#997713"><code>VFSVolumeMount()</code></a></p>

<h3 class="hbH3">
  <a name="997613"> </a>VFSVolumeGetLabel Function <a href="#992934"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="997618"> </a>Purpose 
</h4>

<p><a name="997621"> </a>Determine the volume label for a particular volume.</p>
<h4>
  <a name="997623"> </a>Declared In 
</h4>
<code>VFSMgr.h<a name="997626"> </a></code><h4>
  <a name="997628"> </a>Prototype 
</h4>
<pre class="proto"><a name="997631"></a>status_t VFSVolumeGetLabel (
   uint16_t <code class="par">volRefNum</code>,
   char <code class="par">*labelP</code>,
   size_t <code class="par">bufSize</code>
)
</pre>
<h4>
  <a name="997633"> </a>Parameters 
</h4>

<dl>
<dt><a name="997636"> </a><code>&rarr;  <i>volRefNum</i></code></dt>
<dd><a name="997638"> </a>Volume reference number returned from <a href="VFSMgr.html#997470"><code>VFSVolumeEnumerate()</code></a>.</dd>

<dt><a name="997640"> </a><code>&larr;  <i>labelP</i></code></dt>
<dd><a name="997642"> </a>Pointer to a character buffer into which the volume name is placed.</dd>

<dt><a name="997648"> </a><code>&rarr;  <i>bufSize</i></code></dt>
<dd><a name="997650"> </a>Length, in bytes, of the <code class="par">labelP</code> buffer.</dd>

</dl>
<h4>
  <a name="997652"> </a>Returns 
</h4>

<p><a name="1078144"> </a>Returns <code>errNone</code> if the operation completed successfully, or one of the following otherwise:</p>

<dl>
<dt><a name="1067537"> </a><code><code>expErrNotOpen</code></code></dt>
<dd><a name="1067802"> </a>The file system library necessary for this call has not been installed or has not been opened.</dd>

<dt><a name="1067538"> </a><code><code>vfsErrNoFileSystem</code></code></dt>
<dd><a name="1067803"> </a>The VFS Manager cannot find an appropriate file system to handle the request.</dd>

<dt><a name="1067539"> </a><code><code>vfsErrVolumeBadRef</code></code></dt>
<dd><a name="1067852"> </a>The specified volume has not been mounted.</dd>

<dt><a name="1067540"> </a><code><code>vfsErrBufferOverflow</code></code></dt>
<dd><a name="1067901"> </a>The value specified in <code class="par">bufSize</code> is not big enough to receive the full volume label.</dd>

<dt><a name="1067541"> </a><code><code>vfsErrNameShortened</code></code></dt>
<dd><a name="1067950"> </a>There was an error reading the full volume name. A shortened version is being returned.</dd>

</dl>
<h4>
  <a name="1067542"> </a>Comments 
</h4>

<p><a name="1067543"> </a>Volume reference numbers can change each time you mount a given volume. To keep track of a particular volume, save the volume's label rather than its reference number. Volume labels can be up to 255 characters long. They can contain any normal character, including spaces and lower case characters, in any character set as well as the following special characters: $ % ' - _ @ ~ ` ! ( ) ^ # &amp; + , ; = [ ].</p>
<h4>
  <a name="1067549"> </a>See Also 
</h4>

<p><a name="1067553"> </a><a href="VFSMgr.html#997767"><code>VFSVolumeSetLabel()</code></a></p>

<h3 class="hbH3">
  <a name="997667"> </a>VFSVolumeInfo Function <a href="#992934"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="997672"> </a>Purpose 
</h4>

<p><a name="1068000"> </a>Get information about the specified volume.</p>
<h4>
  <a name="997677"> </a>Declared In 
</h4>
<code>VFSMgr.h<a name="997680"> </a></code><h4>
  <a name="997682"> </a>Prototype 
</h4>
<pre class="proto"><a name="997685"></a>status_t VFSVolumeInfo (
   uint16_t <code class="par">volRefNum</code>,
   VolumeInfoType <code class="par">*volInfoP</code>
)
</pre>
<h4>
  <a name="997687"> </a>Parameters 
</h4>

<dl>
<dt><a name="997690"> </a><code>&rarr;  <i>volRefNum</i></code></dt>
<dd><a name="997692"> </a>Volume reference number returned from <a href="VFSMgr.html#997470"><code>VFSVolumeEnumerate()</code></a>.</dd>

<dt><a name="997694"> </a><code>&larr;  <i>volInfoP</i></code></dt>
<dd><a name="997696"> </a>Pointer to the structure that receives the volume information for the specified volume. See <a href="VFSMgr.html#993429"><code>VolumeInfoType</code></a> for more information on the fields in this data structure.</dd>

</dl>
<h4>
  <a name="997698"> </a>Returns 
</h4>

<p><a name="1078149"> </a>Returns <code>errNone</code> if the operation completed successfully, or one of the following otherwise:</p>

<dl>
<dt><a name="1068108"> </a><code><code>expErrNotOpen</code></code></dt>
<dd><a name="1068188"> </a>The file system library necessary for this call has not been installed or has not been opened.</dd>

<dt><a name="1068109"> </a><code><code>vfsErrNoFileSystem</code></code></dt>
<dd><a name="1068193"> </a>The VFS Manager cannot find an appropriate file system to handle the request.</dd>

<dt><a name="1068110"> </a><code><code>vfsErrVolumeBadRef</code></code></dt>
<dd><a name="1068198"> </a>The specified volume reference number is invalid.</dd>

</dl>
<h4>
  <a name="1068116"> </a>See Also 
</h4>

<p><a name="1068123"> </a><a href="VFSMgr.html#997613"><code>VFSVolumeGetLabel()</code></a>, <a href="VFSMgr.html#997813"><code>VFSVolumeSize()</code></a></p>

<h3 class="hbH3">
  <a name="997713"> </a>VFSVolumeMount Function <a href="#992934"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="997718"> </a>Purpose 
</h4>

<p><a name="1068212"> </a>Mount the card's volume on the specified slot.</p>
<h4>
  <a name="997723"> </a>Declared In 
</h4>
<code>VFSMgr.h<a name="997726"> </a></code><h4>
  <a name="997728"> </a>Prototype 
</h4>
<pre class="proto"><a name="997731"></a>status_t VFSVolumeMount (
   uint8_t <code class="par">flags</code>,
   uint16_t <code class="par">fsLibRefNum</code>,
   VFSAnyMountParamPtr <code class="par">vfsMountParamP</code>
)
</pre>
<h4>
  <a name="997733"> </a>Parameters 
</h4>

<dl>
<dt><a name="997736"> </a><code>&rarr;  <i>flags</i></code></dt>
<dd><a name="997738"> </a>Flags that control how the volume should be mounted. Currently, the only flag not reserved is <code>vfsMountFlagsUseThisFileSystem</code>. Pass this flag to cause the volume to be mounted using the file system specified by <code class="par">fsLibRefNum</code>. Pass zero (0) to have the VFS Manager attempt to mount the volume using a file system appropriate for the slot.</dd>

<dt><a name="997740"> </a><code>&rarr;  <i>fsLibRefNum</i></code></dt>
<dd><a name="997742"> </a>Reference number of the file system library for which the volume should be mounted. If the <code>flags</code> field is not set to <code>vfsMountFlagsUseThisFileSystem</code>, this parameter is ignored.</dd>

<dt><a name="997748"> </a><code>&harr;  <i>vfsMountParamP</i></code></dt>
<dd><a name="997750"> </a>Parameters to be used when mounting the volume after it has been formatted. Supply a pointer to either a <a href="VFSMgr.html#993157"><code>VFSSlotMountParamType</code></a> or a <a href="VFSMgr.html#993113"><code>VFSPOSEMountParamType</code></a> structure. Note that you'll need to cast your structure pointer to a <code>VFSAnyMountParamPtr</code>. Set the <code>mountClass</code> field to the appropriate value: if you are mounting to an Expansion Manager slot, set <code>mountClass</code> to <code>VFSMountClass_SlotDriver</code> and initialize <code>slotLibRefNum</code> and <code>slotRefNum</code> to the appropriate values. See the descriptions of <a href="VFSMgr.html#993069"><code>VFSAnyMountParamType</code></a>, <a href="VFSMgr.html#993157"><code>VFSSlotMountParamType</code></a>, and <a href="VFSMgr.html#993113"><code>VFSPOSEMountParamType</code></a> for information on the fields that make up these data structures.</dd>

</dl>
<h4>
  <a name="997752"> </a>Returns 
</h4>

<p><a name="1078208"> </a>Returns <code>errNone</code> if the operation completed successfully, or one of the following otherwise:</p>

<dl>
<dt><a name="1068337"> </a><code><code>expErrNotEnoughPower</code></code></dt>
<dd><a name="1068504"> </a>There is insufficient battery power to mount a volume.</dd>

<dt><a name="1068338"> </a><code><code>expErrNotOpen</code></code></dt>
<dd><a name="1068509"> </a>The file system library necessary for this call has not been installed or has not been opened.</dd>

<dt><a name="1068339"> </a><code><code>sysErrParamErr</code></code></dt>
<dd><a name="1068510"> </a><code class="par">vfsMountParamP</code> was initialized to <code>NULL</code>.</dd>

<dt><a name="1068340"> </a><code><code>vfsErrNoFileSystem</code></code></dt>
<dd><a name="1068511"> </a>The VFS Manager cannot find an appropriate file system to handle the request.</dd>

<dt><a name="1068341"> </a><code><code>vfsErrVolumeStillMounted</code></code></dt>
<dd><a name="1068512"> </a>The volume is already mounted with a different file system than was specified in <code class="par">fsLibRefNum</code>.</dd>

</dl>
<h4>
  <a name="1068342"> </a>Comments 
</h4>

<p><a name="1068343"> </a>The slot driver only supports one volume per slot. The reference number of the mounted volume is returned in <code>vfsMountParamP-&gt;volRefNum</code>. If <code>vfsMountFlagsUseThisFileSystem</code> is passed as a flag, <code>VFSVolumeMount</code> attempts to mount the volume using the file system library specified by <code>fsLibRefNum</code>. Otherwise <code>VFSVolumeMount</code> tries to find a file system library which is able to mount the volume. If none of the installed file system libraries is able to mount the volume, <code>VFSVolumeMount</code> attempts to re-format the volume (using <a href="VFSMgr.html#997555"><code>VFSVolumeFormat()</code></a>) and then mount it. If <code>VFSVolumeMount</code> manages to successfully mount the volume, it ends by posting a <a href="../Programming_Basics/NotifyMgr.html#996627"><code>sysNotifyVolumeMountedEvent</code></a> notification.</p>

<p><a name="1068350"> </a>After VFSVolumeMount successfully mounts a volume, it broadcasts <code>sysNotifyVolumeMountedEvent</code>. The VFS Manager, upon being notified of this event, searches the newly-mounted volume for <code>/PALM/start.prc</code>. If <code>start.prc</code> is found in the <code>/PALM</code> directory, the VFS Manager copies it to main memory and launches it. If <code>start.prc</code> is not found, the VFS Manager switches to the Launcher instead. This behavior can be overridden; see <a href="../System_Management/Expansion.html#1001095">"Card Insertion and Removal"</a> of <i>Exploring Palm OS: System Management</i>.</p>

<p><a name="1068360"> </a>When <code>VFSVolumeMount</code> is called, if the volume is already mounted with a different file system than was specified in <code>fsLibRefNum</code>, a <code>vfsErrVolumeStillMounted</code> error is returned. If the volume is already mounted with the same file system that is specified in <code>fsLibRefNum</code>, or if <code>vfsMountFlagsUseThisFileSystem</code> is not set, <code>VFSVolumeMount</code> returns <code>errNone</code> and sets <code>volRefNumP</code> to the reference number of the currently mounted volume.</p>
<h4>
  <a name="1068361"> </a>Example 	
</h4>

<p><a name="1068362"> </a>The following code excerpt mounts a volume on an Expansion Manager slot using a compatible file system.</p>

<div class="CodeRule"><hr></div><pre class="CodeBlock">
VFSSlotMountParamType slotParam ;<a name="1068363"> </a>
UInt32 slotIterator = expIteratorStart;<a name="1068364"> </a>
 <a name="1068365"> </a>
slotParam.vfsMountParamP.mountClass = 
   VFSMountClass_SlotDriver;<a name="1068366"> </a>
err = ExpSlotEnumerate(&amp;slotParam.slotRefNum, 
   &amp;slotIterator);<a name="1068367"> </a>
err = ExpSlotLibFind(slotParam.slotRefNum, 
   &amp;slotParam.slotLibRefNum);<a name="1068368"> </a>
 <a name="1068369"> </a>
err = VFSVolumeMount(NULL, NULL,
   (VFSAnyMountParamPtr) &amp; slotParam);<a name="1068370"> </a>
</pre><div class="CodeRule"><hr></div>

<h4>
  <a name="1068376"> </a>See Also 
</h4>

<p><a name="1068383"> </a><a href="VFSMgr.html#997555"><code>VFSVolumeFormat()</code></a>, <a href="VFSMgr.html#997867"><code>VFSVolumeUnmount()</code></a></p>

<h3 class="hbH3">
  <a name="997767"> </a>VFSVolumeSetLabel Function <a href="#992934"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="997772"> </a>Purpose 
</h4>

<p><a name="1068514"> </a>Change the volume label for a mounted volume.</p>
<h4>
  <a name="997777"> </a>Declared In 
</h4>
<code>VFSMgr.h<a name="997780"> </a></code><h4>
  <a name="997782"> </a>Prototype 
</h4>
<pre class="proto"><a name="997785"></a>status_t VFSVolumeSetLabel (
   uint16_t <code class="par">volRefNum</code>,
   const char <code class="par">*labelP</code>
)
</pre>
<h4>
  <a name="997787"> </a>Parameters 
</h4>

<dl>
<dt><a name="997790"> </a><code>&rarr;  <i>volRefNum</i></code></dt>
<dd><a name="997792"> </a>Volume reference number returned from <a href="VFSMgr.html#997470"><code>VFSVolumeEnumerate()</code></a>.</dd>

<dt><a name="997794"> </a><code>&rarr;  <i>labelP</i></code></dt>
<dd><a name="997796"> </a>Pointer to the label to be applied to the specified volume. This string must be null-terminated.</dd>

</dl>
<h4>
  <a name="997798"> </a>Returns 
</h4>

<p><a name="1078270"> </a>Returns <code>errNone</code> if the operation completed successfully, or one of the following otherwise:</p>

<dl>
<dt><a name="1068629"> </a><code><code>expErrNotOpen</code></code></dt>
<dd><a name="1068846"> </a>The file system library necessary for this call has not been installed or has not been opened.</dd>

<dt><a name="1068630"> </a><code><code>vfsErrBadName</code></code></dt>
<dd><a name="1068887"> </a>The supplied label is invalid.</dd>

<dt><a name="1068631"> </a><code><code>vfsErrNameShortened</code></code></dt>
<dd><a name="1068888"> </a>Indicates that the label name was too long. A shortened version of the label name was used instead.</dd>

<dt><a name="1068632"> </a><code><code>vfsErrVolumeBadRef</code></code></dt>
<dd><a name="1068929"> </a>The specified volume has not been mounted.</dd>

</dl>
<h4>
  <a name="1068633"> </a>Comments 
</h4>

<p><a name="1068634"> </a>Volume labels can be up to 255 characters long. They can contain any normal character, including spaces and lower case characters, in any character set as well as the following special characters: $ % ' - _ @ ~ ` ! ( ) ^ # &amp; + , ; = [ ]. See <a href="VFS.html#993340">"Naming Volumes"</a> for guidelines on naming.</p>

<div><hr>
  <a name="1068644"> </a> <b>NOTE: </b> Most clients should not need to call this function. This function may create or delete a file in the root directory, which would invalidate any current calls to <a href="VFSMgr.html#994232"><code>VFSDirEntryEnumerate()</code></a>.
<hr>
</div>
<h4>
  <a name="1068653"> </a>See Also 
</h4>

<p><a name="1068657"> </a><a href="VFSMgr.html#997613"><code>VFSVolumeGetLabel()</code></a></p>

<h3 class="hbH3">
  <a name="997813"> </a>VFSVolumeSize Function <a href="#992934"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="997818"> </a>Purpose 
</h4>

<p><a name="1068971"> </a>Determine the total amount of space on a volume, as well as the amount that is currently being used.</p>
<h4>
  <a name="997823"> </a>Declared In 
</h4>
<code>VFSMgr.h<a name="997826"> </a></code><h4>
  <a name="997828"> </a>Prototype 
</h4>
<pre class="proto"><a name="997831"></a>status_t VFSVolumeSize (
   uint16_t <code class="par">volRefNum</code>,
   uint32_t <code class="par">*volumeUsedP</code>,
   uint32_t <code class="par">*volumeTotalP</code>
)
</pre>
<h4>
  <a name="997833"> </a>Parameters 
</h4>

<dl>
<dt><a name="997836"> </a><code>&rarr;  <i>volRefNum</i></code></dt>
<dd><a name="997838"> </a>Volume reference number returned from <a href="VFSMgr.html#997470"><code>VFSVolumeEnumerate()</code></a>.</dd>

<dt><a name="997840"> </a><code>&larr;  <i>volumeUsedP</i></code></dt>
<dd><a name="997846"> </a>Pointer to a variable that receives the amount of space, in bytes, in use on the volume.</dd>

<dt><a name="997848"> </a><code>&larr;  <i>volumeTotalP</i></code></dt>
<dd><a name="997850"> </a>Pointer to a variable that receives the total amount of space on the volume, in bytes.</dd>

</dl>
<h4>
  <a name="997852"> </a>Returns 
</h4>

<p><a name="1078307"> </a>Returns <code>errNone</code> if the operation completed successfully, or one of the following otherwise:</p>

<dl>
<dt><a name="1069224"> </a><code><code>expErrNotOpen</code></code></dt>
<dd><a name="1069297"> </a>The file system library necessary for this call has not been installed or has not been opened.</dd>

<dt><a name="1069225"> </a><code><code>vfsErrNoFileSystem</code></code></dt>
<dd><a name="1069306"> </a>The VFS Manager cannot find an appropriate file system to handle the request.</dd>

<dt><a name="1069226"> </a><code><code>vfsErrVolumeBadRef</code></code></dt>
<dd><a name="1069323"> </a>The specified volume has not been mounted.</dd>

</dl>
<h4>
  <a name="1069232"> </a>See Also 
</h4>

<p><a name="1069236"> </a><a href="VFSMgr.html#997667"><code>VFSVolumeInfo()</code></a></p>

<h3 class="hbH3">
  <a name="997867"> </a>VFSVolumeUnmount Function <a href="#992934"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="997872"> </a>Purpose 
</h4>

<p><a name="1069352"> </a>Unmount the given volume.</p>
<h4>
  <a name="997877"> </a>Declared In 
</h4>
<code>VFSMgr.h<a name="997880"> </a></code><h4>
  <a name="997882"> </a>Prototype 
</h4>
<pre class="proto"><a name="997885"></a>status_t VFSVolumeUnmount (
   uint16_t <code class="par">volRefNum</code>
)
</pre>
<h4>
  <a name="997887"> </a>Parameters 
</h4>

<dl>
<dt><a name="997890"> </a><code>&rarr;  <i>volRefNum</i></code></dt>
<dd><a name="997892"> </a>Volume reference number returned from <a href="VFSMgr.html#997470"><code>VFSVolumeEnumerate()</code></a>.</dd>

</dl>
<h4>
  <a name="997894"> </a>Returns 
</h4>

<p><a name="1078364"> </a>Returns <code>errNone</code> if the operation completed successfully, or one of the following otherwise:</p>

<dl>
<dt><a name="1069372"> </a><code><code>expErrNotOpen</code></code></dt>
<dd><a name="1069460"> </a>The file system library necessary for this call has not been installed or has not been opened.</dd>

<dt><a name="1069373"> </a><code><code>vfsErrNoFileSystem</code></code></dt>
<dd><a name="1069469"> </a>The VFS Manager cannot find an appropriate file system to handle the request.</dd>

<dt><a name="1069374"> </a><code><code>vfsErrVolumeBadRef</code></code></dt>
<dd><a name="1069490"> </a>The specified volume has not been mounted.</dd>

</dl>
<h4>
  <a name="1069375"> </a>Comments 
</h4>

<p><a name="1069376"> </a>This function closes any opened files and posts a <a href="../Programming_Basics/NotifyMgr.html#996649"><code>sysNotifyVolumeUnmountedEvent</code></a> notification once the file system is successfully unmounted.</p>
<h4>
  <a name="1069385"> </a>See Also 
</h4>

<p><a name="1069389"> </a><a href="VFSMgr.html#997713"><code>VFSVolumeMount()</code></a></p>

<h2 class="haH2">
  <a name="997909"> </a>Application-Defined Functions <a href="#992934"><span class="nav">^TOP^</span></a>
</h2>


<h3 class="hbH3">
  <a name="997944"> </a>VFSExportProcPtr Function <a href="#992934"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="997949"> </a>Purpose 
</h4>

<p><a name="1069512"> </a>User-defined callback function supplied to <a href="VFSMgr.html#994399"><code>VFSExportDatabaseToFileCustom()</code></a> that tracks the progress of the export.</p>
<h4>
  <a name="997954"> </a>Declared In 
</h4>
<code>VFSMgr.h<a name="997957"> </a></code><h4>
  <a name="997959"> </a>Prototype 
</h4>
<pre class="proto"><a name="997962"></a>status_t (
   *VFSExportProcPtr
) (
   uint32_t <code class="par">totalBytes</code>,
   uint32_t <code class="par">offset</code>,
   void <code class="par">*userDataP</code>
)
</pre>
<h4>
  <a name="997964"> </a>Parameters 
</h4>

<dl>
<dt><a name="998017"> </a><code>&rarr;  <i>totalBytes</i></code></dt>
<dd><a name="998075"> </a>The total number of bytes being exported.</dd>

<dt><a name="998098"> </a><code>&rarr;  <i>offset</i></code></dt>
<dd><a name="998180"> </a>Undefined.</dd>

<dt><a name="998182"> </a><code>&rarr;  <i>userDataP</i></code></dt>
<dd><a name="998184"> </a>Pointer to any application-specific data passed to the callback function. This pointer may be <code>NULL</code> if your callback doesn't need any such data.</dd>

</dl>
<h4>
  <a name="998186"> </a>Returns 
</h4>

<p><a name="1069555"> </a>Your progress tracker should allow the user to abort the export. Return <code>errNone</code> if the export should continue, or any other value to abort the export process. If you return a value other than <code>errNone</code>, that value will be returned by <a href="VFSMgr.html#994399"><code>VFSExportDatabaseToFileCustom()</code></a>.</p>
<h4>
  <a name="1069559"> </a>Comments 
</h4>

<p><a name="1069565"> </a>See <a href="../User_Interface/UI_FormConcept.html#998412">"Progress Dialogs"</a> of <i>Exploring Palm OS: User Interface</i> for more information on writing a progress tracker.</p>
<h4>
  <a name="1069572"> </a>See Also 
</h4>

<p><a name="1069576"> </a><a href="VFSMgr.html#998201"><code>VFSImportProcPtr()</code></a></p>

<h3 class="hbH3">
  <a name="998201"> </a>VFSImportProcPtr Function <a href="#992934"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="998206"> </a>Purpose 
</h4>

<p><a name="1069624"> </a>User-defined callback function supplied to <a href="VFSMgr.html#996934"><code>VFSImportDatabaseFromFileCustom()</code></a> that tracks the progress of the import.</p>
<h4>
  <a name="998211"> </a>Declared In 
</h4>
<code>VFSMgr.h<a name="998214"> </a></code><h4>
  <a name="998216"> </a>Prototype 
</h4>
<pre class="proto"><a name="998219"></a>status_t (
   *VFSImportProcPtr
) (
   uint32_t <code class="par">totalBytes</code>,
   uint32_t <code class="par">offset</code>,
   void <code class="par">*userDataP</code>
)
</pre>
<h4>
  <a name="998221"> </a>Parameters 
</h4>

<dl>
<dt><a name="998224"> </a><code>&rarr;  <i>totalBytes</i></code></dt>
<dd><a name="998226"> </a>The total number of bytes being imported.</dd>

<dt><a name="998228"> </a><code>&rarr;  <i>offset</i></code></dt>
<dd><a name="998230"> </a>The number of bytes that have already been imported. This value, along with the total number of bytes being imported, allows you to inform the user how far along the import is.</dd>

<dt><a name="998232"> </a><code>&rarr;  <i>userDataP</i></code></dt>
<dd><a name="998238"> </a>Pointer to NY application-specific data passed to the callback function. This pointer may be <code>NULL</code> if your callback doesn't need any such data.</dd>

</dl>
<h4>
  <a name="998240"> </a>Returns 
</h4>

<p><a name="1069661"> </a>Your progress tracker should allow the user to abort the import. Return <code>errNone</code> if the import should continue, or any other value to abort the import process. If you return a value other than <code>errNone</code>, that value will be returned by <a href="VFSMgr.html#996934"><code>VFSImportDatabaseFromFileCustom()</code></a>.</p>
<h4>
  <a name="1069665"> </a>Comments 
</h4>

<p><a name="1069671"> </a>See <a href="../User_Interface/UI_FormConcept.html#998412">"Progress Dialogs"</a> of <i>Exploring Palm OS: User Interface</i> for more information on writing a progress tracker.</p>
<h4>
  <a name="1069678"> </a>See Also 
</h4>

<p><a name="1069682"> </a><a href="VFSMgr.html#997944"><code>VFSExportProcPtr()</code></a></p>

<p><a name="992930"> </a></p>
&nbsp;<br>
</div>
<!--END CONTENT-->

</td>
<td width="5">&nbsp;&nbsp;</td>
</tr>

</table>

<!-- BEGIN FOOTER -->
<table width="100%" border="0" cellspacing="0" cellpadding="0">
<tr>
<td width="7" rowspan="2"><img name="index_x" src="images/shim.gif" width="7" height="33" border="0" alt=""></td>
<td align="left"><img name="dashes" src="images/dashes.gif" width="744" height="3" border="0" alt=""></td>
<td width="10" rowspan="2"><img name="index_x" src="images/shim.gif" width="10" height="33" border="0" alt=""></td>
</tr>
<tr>
<td align="center">
<p class="footer">
Copyright © 1996&#8211;2004, PalmSource, Inc. and its affiliates. All rights reserved.<br>
<a href="http://www.palmsource.com/contact/">Write Us</a> | <a href="http://www.palmos.com/dev/training/">Training</a> | <a href="http://www.palmos.com/dev/support/kb/">Knowledge Base</a> | <a href="MDF_Front.html" target="_blank">Legal</a></p>
<br>
<!--BEGIN BOOK NAVIGATION-->
<p class="nav">
<A href="http://www.palmos.com/dev/support/docs/">Documentation</a>&nbsp;&nbsp;|&nbsp;&nbsp;
<a href="MDF_TOC.html">Table of Contents</a>&nbsp;&nbsp;
             |&nbsp;&nbsp;<a href="SchemaDatabases.html">&lt;&nbsp;Previous</a>&nbsp;&nbsp;
             |&nbsp;&nbsp;<a href="MDF_IX.html">Next&nbsp;&gt;</a>&nbsp;&nbsp;
             |&nbsp;&nbsp;<a href="MDF_IX.html">Index</a>
</p>
</td>
</tr>
</table>
<!-- END FOOTER -->

</body>
</html>