<html>
<head>
<title>(Protein) SysThread | System Management</title> 
<link href="psi_devpubs.css" rel="stylesheet" type="text/css">

<!-- BEGIN META DATA -->
<meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
<META NAME="PSITEMPLATE" CONTENT="1006-007 PalmSource_HTML_2003 20041101">
<META NAME="GENERATOR" CONTENT="Quadralay WebWorks AutoMap 2003 for FrameMaker 8.0.6.2138">
<META NAME="LASTUPDATED" CONTENT="11/22/04 11:27:53">
<!-- END META DATA -->
</head>

<body bgcolor="#ffffff" text="#000000" leftmargin="0" topmargin="0" marginwidth="0" marginheight="0">
<a name="992934"></a>

<!-- BEGIN TOPNAV -->
<table width="100%" border="0" cellspacing="0" cellpadding="0">
<tr>
<td><img src="images/shim.gif" width="7" height="75" border="0" alt=""></td>
<td align="left"><table border="0" cellpadding="0" cellspacing="0" width="744">
<tr>
<td><img name="index_r2_c1" src="images/shim.gif" width="25" height="75" border="0" alt=""></td>
<td valign="top"><table border="0" cellpadding="0" cellspacing="0" width="96">
<tr>
<td><img name="index_r2_c4" src="images/shim.gif" width="96" height="15" border="0" alt=""></td>
</tr>
<tr>
<td><a href="http://www.palmsource.com/"><img name="ps_logo" src="images/ps_logo.gif" width="96" height="54" border="0" alt=""></a></td>
</tr>

</table>
</td>

<td><table border="0" cellpadding="0" cellspacing="0" width="30">
<td><img name="index_x" src="images/shim.gif" width="30" height="75" border="0" alt=""></td>
</table></td>

<!--BEGIN MASTHEAD-->
<td><table border="0" cellpadding="0" cellspacing="0" width="96">
<tr>
<td><img name="index_x" src="images/shim.gif" width="615" height="5" border="0" alt=""></td>
</tr>
<tr>
<td>
<!--BEGIN BOOK NAVIGATION-->
<span class="nav">
<A href="http://www.palmos.com/dev/support/docs/">Documentation</a>&nbsp;&nbsp;|&nbsp;&nbsp;
<a href="SysMgt_TOC.html">Table of Contents</a>&nbsp;&nbsp;
             |&nbsp;&nbsp;<a href="SystemMgr.html">&lt;&nbsp;Previous</a>&nbsp;&nbsp;
             |&nbsp;&nbsp;<a href="SysUtils.html">Next&nbsp;&gt;</a>&nbsp;&nbsp;
             |&nbsp;&nbsp;<a href="SysMgt_IX.html">Index</a>
</span>
<!--END BOOK NAVIGATION-->
</tr>
<tr>
<td>
<!--BEGIN PAGE TITLE-->
<h2 class="PageTitle">36 &nbsp;&nbsp;
SysThread</h2></td>
<!--END PAGE TITLE-->
</tr>
<tr>
<td>
<!--BEGIN BOOK TITLE-->
<p class="BookTitle">System Management</p>
<p class="SubTitle">Exploring Palm OS&#174; </p>
<!--END BOOK TITLE-->
</td>
</tr>
<tr>
<td><img name="index_x" src="images/shim.gif" width="615" height="5" border="0" alt=""></td>
</tr>
</table>
</td>
<!--END MASTHEAD-->
</tr>
</table>
<img name="dashes" src="images/dashes.gif" width="744" height="3" border="0" alt=""></td>
</tr>
</table>
<!-- END TOPNAV -->

<table width="100%" border="0" cellspacing="0" cellpadding="0">
<tr>
<td valign="top" width="5"><img name="index_x" src="images/shim.gif" width="5" height="33" border="0" alt=""></td>

<!--BEGIN SIDETOC-->
<td valign="top" width="175">
<div id="sidetoc" valign="bottom">
<h1 class="SideTOC1-PartTab"><a href="SysMgt_Part2.html">Part II: Reference</a> </h1>
<h1 class="SideTOC1"><a href="SysThread.html">36  SysThread</a></h1>

   <h2 class="SideTOC2"><a href="#992942">
   SysThread Structures and Types</a></h2>

      <h3 class="SideTOC3"><a href="#992950">
      SysConditionVariableType</a></h3>

      <h3 class="SideTOC3"><a href="#992975">
      SysCriticalSectionType</a></h3>

      <h3 class="SideTOC3"><a href="#993000">
      SysThreadExitCallbackID</a></h3>

      <h3 class="SideTOC3"><a href="#993205">
      SysThreadGroupHandle</a></h3>

      <h3 class="SideTOC3"><a href="#993270">
      SysThreadGroupTag</a></h3>

      <h3 class="SideTOC3"><a href="#993300">
      SysThreadGroupType</a></h3>

      <h3 class="SideTOC3"><a href="#993330">
      SysTSDSlotID</a></h3>

   <h2 class="SideTOC2"><a href="#993384">
   SysThread Constants</a></h2>

      <h3 class="SideTOC3"><a href="#1002445">
      Thread Priorities</a></h3>

      <h3 class="SideTOC3"><a href="#993404">
      Miscellaneous System Thread Constants</a></h3>

      <h3 class="SideTOC3"><a href="#993480">
      Predefined TSD Slot Names</a></h3>

      <h3 class="SideTOC3"><a href="#993507">
      Predefined Semaphore Counts</a></h3>

      <h3 class="SideTOC3"><a href="#1050398">
      timeoutFlags_t</a></h3>

   <h2 class="SideTOC2"><a href="#993577">
   SysThread Functions and Macros</a></h2>

      <h3 class="SideTOC3"><a href="#993589">
      SysAtomicAdd32</a></h3>

      <h3 class="SideTOC3"><a href="#993685">
      SysAtomicAnd32</a></h3>

      <h3 class="SideTOC3"><a href="#993731">
      SysAtomicCompareAndSwap32</a></h3>

      <h3 class="SideTOC3"><a href="#993958">
      SysAtomicOr32</a></h3>

      <h3 class="SideTOC3"><a href="#994028">
      SysConditionVariableBroadcast</a></h3>

      <h3 class="SideTOC3"><a href="#994070">
      SysConditionVariableClose</a></h3>

      <h3 class="SideTOC3"><a href="#994116">
      SysConditionVariableOpen</a></h3>

      <h3 class="SideTOC3"><a href="#994158">
      SysConditionVariableWait</a></h3>

      <h3 class="SideTOC3"><a href="#994464">
      SysCriticalSectionEnter</a></h3>

      <h3 class="SideTOC3"><a href="#994506">
      SysCriticalSectionExit</a></h3>

      <h3 class="SideTOC3"><a href="#1044504">
      SysCurrentThread</a></h3>

      <h3 class="SideTOC3"><a href="#994892">
      SysGetRunTime</a></h3>

      <h3 class="SideTOC3"><a href="#1025693">
      SysSemaphoreCreate</a></h3>

      <h3 class="SideTOC3"><a href="#995038">
      SysSemaphoreCreateEZ</a></h3>

      <h3 class="SideTOC3"><a href="#995127">
      SysSemaphoreDestroy</a></h3>

      <h3 class="SideTOC3"><a href="#995193">
      SysSemaphoreSignal</a></h3>

      <h3 class="SideTOC3"><a href="#995235">
      SysSemaphoreSignalCount</a></h3>

      <h3 class="SideTOC3"><a href="#995555">
      SysSemaphoreWait</a></h3>

      <h3 class="SideTOC3"><a href="#995605">
      SysSemaphoreWaitCount</a></h3>

      <h3 class="SideTOC3"><a href="#995739">
      SysThreadChangePriority</a></h3>

      <h3 class="SideTOC3"><a href="#995791">
      SysThreadCreate</a></h3>

      <h3 class="SideTOC3"><a href="#995881">
      SysThreadCreateEZ</a></h3>

      <h3 class="SideTOC3"><a href="#996239">
      SysThreadDelay</a></h3>

      <h3 class="SideTOC3"><a href="#996328">
      SysThreadExit</a></h3>

      <h3 class="SideTOC3"><a href="#996392">
      SysThreadGroupCreate</a></h3>

      <h3 class="SideTOC3"><a href="#996432">
      SysThreadGroupDestroy</a></h3>

      <h3 class="SideTOC3"><a href="#996539">
      SysThreadGroupWait</a></h3>

      <h3 class="SideTOC3"><a href="#996581">
      SysThreadInstallExitCallback</a></h3>

      <h3 class="SideTOC3"><a href="#996652">
      SysThreadRemoveExitCallback</a></h3>

      <h3 class="SideTOC3"><a href="#996694">
      SysThreadResume</a></h3>

      <h3 class="SideTOC3"><a href="#996736">
      SysThreadStart</a></h3>

      <h3 class="SideTOC3"><a href="#997042">
      SysThreadSuspend</a></h3>

      <h3 class="SideTOC3"><a href="#997084">
      SysTSDAllocate</a></h3>

      <h3 class="SideTOC3"><a href="#1026539">
      SysTSDFree</a></h3>

      <h3 class="SideTOC3"><a href="#997180">
      SysTSDGet</a></h3>

      <h3 class="SideTOC3"><a href="#997222">
      SysTSDSet</a></h3>

   <h2 class="SideTOC2"><a href="#997272">
   Application-Defined Functions</a></h2>

      <h3 class="SideTOC3"><a href="#997280">
      SysThreadEnterFunc</a></h3>

      <h3 class="SideTOC3"><a href="#997321">
      SysThreadExitCallbackFunc</a></h3>

      <h3 class="SideTOC3"><a href="#997566">
      SysTSDDestructorFunc</a></h3>

</div>
</td>

<td width="5">&nbsp;&nbsp;</td>
<td width="2" background="images/index_r8_c10.gif"><img src="images/shim.gif" width="2" height="75" border="0" alt=""></td>
<td width="5">&nbsp;&nbsp;</td>

<!--END SIDETOC-->

<td valign="top">

<!--BEGIN CONTENT-->
<div id="content" valign="bottom">
<p><a name="1047701"> </a>This chapter provides reference documentation for the threading APIs provided by Palm OS. These APIs allow you to work with threads and thread groups, semaphores, condition variables, and critical sections. As well, the threading APIs include a set of atomic operations that some applications may find useful.</p>

<p><a name="1047934"> </a>The contents of this chapter is divided into the following sections:</p>
   <blockquote class = "bq"><a name="992948"> </a><a href="SysThread.html#992942">SysThread Structures and Types</a></blockquote>
   <blockquote class = "bq"><a name="993390"> </a><a href="SysThread.html#993384">SysThread Constants</a></blockquote>
   <blockquote class = "bq"><a name="993583"> </a><a href="SysThread.html#993577">SysThread Functions and Macros</a></blockquote>
   <blockquote class = "bq"><a name="997278"> </a><a href="SysThread.html#997272">Application-Defined Functions</a></blockquote>

<p><a name="992938"> </a>The header file <code>SysThread.h</code> declares the API that this chapter describes.</p>

<p><a name="992940"> </a>This chapter provides reference information on the individual types, constants, and functions that you use when writing multi-threaded applications. For background information as well as tips on using these APIs, see <a href="Threading.html#1009989">Chapter 8, "Threading."</a></p>

<h2 class="haH2">
  <a name="992942"> </a>SysThread Structures and Types <a href="#992934"><span class="nav">^TOP^</span></a>
</h2>


<h3 class="hbH3">
  <a name="992950"> </a>SysConditionVariableType Typedef <a href="#992934"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="992955"> </a>Purpose 
</h4>

<p><a name="992958"> </a>Defines a condition variable upon which threads will block until the variable becomes open.</p>
<h4>
  <a name="992960"> </a>Declared In 
</h4>
<code>SysThread.h<a name="992963"> </a></code><h4>
  <a name="992965"> </a>Prototype 
</h4>
<pre class="proto"><a name="992968"></a>typedef void *SysConditionVariableType
</pre>
<h4>
  <a name="992970"> </a>Comments 
</h4>

<p><a name="992973"> </a>Variables of this type should be initialized to <span style="color: #000000;  font-family: Courier; font-style: normal; font-weight: normal; text-decoration: none; text-transform: none; vertical-align: baseline">sysConditionVariableInitializer</span>. This marks the condition variable as closed: to open it, call <a href="SysThread.html#994116"><code>SysConditionVariableOpen()</code></a>. To block on the condition variable, use <a href="SysThread.html#994158"><code>SysConditionVariableWait()</code></a>.</p>

<h3 class="hbH3">
  <a name="992975"> </a>SysCriticalSectionType Typedef <a href="#992934"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="992980"> </a>Purpose 
</h4>

<p><a name="992983"> </a>Defines a mutex that is used to control access to a critical section.</p>
<h4>
  <a name="992985"> </a>Declared In 
</h4>
<code>SysThread.h<a name="992988"> </a></code><h4>
  <a name="992990"> </a>Prototype 
</h4>
<pre class="proto"><a name="992993"></a>typedef void *SysCriticalSectionType
</pre>
<h4>
  <a name="992995"> </a>Comments 
</h4>

<p><a name="1048075"> </a>Use <code>SysCriticalSectionType</code> variables in conjunction with <a href="SysThread.html#994464"><code>SysCriticalSectionEnter()</code></a> and <a href="SysThread.html#994506"><code>SysCriticalSectionExit()</code></a> to prevent more than one thread from executing the code in the critical section at the same time.</p>

<p><a name="1048082"> </a>Initialize variables of this type to <span style="color: #000000;  font-family: Courier; font-style: normal; font-weight: normal; text-decoration: none; text-transform: none; vertical-align: baseline">sysCriticalSectionInitializer</span>. </p>

<h3 class="hbH3">
  <a name="993000"> </a>SysThreadExitCallbackID Typedef <a href="#992934"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="993005"> </a>Purpose 
</h4>

<p><a name="993008"> </a>ID of a thread exit callback function.</p>
<h4>
  <a name="993010"> </a>Declared In 
</h4>
<code>SysThread.h<a name="993023"> </a></code><h4>
  <a name="993043"> </a>Prototype 
</h4>
<pre class="proto"><a name="993080"></a>typedef uint32_t SysThreadExitCallbackID
</pre>
<h4>
  <a name="993120"> </a>Comments 
</h4>

<p><a name="993163"> </a>This identifier can be returned to you when you install the exit callback function with <a href="SysThread.html#996581"><code>SysThreadInstallExitCallback()</code></a>. You use it to identify the callback function to be removed when calling <a href="SysThread.html#996652"><code>SysThreadRemoveExitCallback()</code></a>.</p>

<h3 class="hbH3">
  <a name="993205"> </a>SysThreadGroupHandle Typedef <a href="#992934"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="993250"> </a>Purpose 
</h4>

<p><a name="993253"> </a>Handle to a thread group.</p>
<h4>
  <a name="993255"> </a>Declared In 
</h4>
<code>SysThread.h<a name="993258"> </a></code><h4>
  <a name="993260"> </a>Prototype 
</h4>
<pre class="proto"><a name="993263"></a>typedef SysThreadGroupType *SysThreadGroupHandle
</pre>
<h4>
  <a name="993265"> </a>Comments 
</h4>

<p><a name="993268"> </a>Thread groups are identified by a <code>SysThreadGroupHandle</code>. You obtain a thread group handle when you create the group with <a href="SysThread.html#996392"><code>SysThreadGroupCreate()</code></a>. You then supply this handle when adding threads to the group (at creation time, with <a href="SysThread.html#995791"><code>SysThreadCreate()</code></a>), or when waiting on the group's threads or destroying the group (<a href="SysThread.html#996539"><code>SysThreadGroupWait()</code></a> and <a href="SysThread.html#996432"><code>SysThreadGroupDestroy()</code></a>, respectively).</p>

<h3 class="hbH3">
  <a name="993270"> </a>SysThreadGroupTag Struct <a href="#992934"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="993275"> </a>Purpose 
</h4>

<p><a name="993278"> </a>Identifier for an internal structure that represents a thread group.</p>
<h4>
  <a name="993280"> </a>Declared In 
</h4>
<code>SysThread.h<a name="993283"> </a></code><h4>
  <a name="993285"> </a>Prototype 
</h4>
<pre class="proto"><a name="993288"></a>struct SysThreadGroupTag
</pre>

<h3 class="hbH3">
  <a name="993300"> </a>SysThreadGroupType Struct <a href="#992934"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="993305"> </a>Purpose 
</h4>

<p><a name="993308"> </a>Type definition for an internal structure that represents a thread group.</p>
<h4>
  <a name="993310"> </a>Declared In 
</h4>
<code>SysThread.h<a name="993313"> </a></code><h4>
  <a name="993315"> </a>Prototype 
</h4>
<pre class="proto"><a name="993318"></a>typedef struct SysThreadGroupTag 
SysThreadGroupType
</pre>

<h3 class="hbH3">
  <a name="993330"> </a>SysTSDSlotID Typedef <a href="#992934"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="993339"> </a>Purpose 
</h4>

<p><a name="993342"> </a>Thread-specific data (TSD) slot identifier.</p>
<h4>
  <a name="993344"> </a>Declared In 
</h4>
<code>SysThread.h<a name="993347"> </a></code><h4>
  <a name="993349"> </a>Prototype 
</h4>
<pre class="proto"><a name="993352"></a>typedef uint32_t SysTSDSlotID
</pre>
<h4>
  <a name="993354"> </a>Comments 
</h4>

<p><a name="993357"> </a>You receive a <code>SysTSDSlotID</code> when you allocate a new thread-specific data slot with <a href="SysThread.html#997084"><code>SysTSDAllocate()</code></a>.</p>

<h2 class="haH2">
  <a name="993384"> </a>SysThread Constants <a href="#992934"><span class="nav">^TOP^</span></a>
</h2>


<h3 class="hbH3">
  <a name="1002445"> </a>Thread Priorities <a href="#992934"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="1002446"> </a>Purpose 
</h4>

<p><a name="1002449"> </a>Common thread priority values.</p>
<h4>
  <a name="1002486"> </a>Declared In 
</h4>
<code>SysThread.h<a name="1002625"> </a></code><h4>
  <a name="1002662"> </a>Constants 
</h4>

<dl>
<dt><a name="1058212"> </a><code>#define sysThreadPriorityBestApp 80</code></dt>
<dd><a name="1058288"> </a>The highest priority for the application process and any thread created by it.</dd>

<dt><a name="1003253"> </a><code>#define sysThreadPriorityBestSystem 5</code></dt>
<dd><a name="1003254"> </a>The highest priority reserved for system programs.</dd>

<dt><a name="1003256"> </a><code>#define sysThreadPriorityBestUser 30</code></dt>
<dd><a name="1003257"> </a>The highest priority that should be used by user programs.</dd>

<dt><a name="1003259"> </a><code>#define sysThreadPriorityDisplay 60</code></dt>
<dd><a name="1003260"> </a>Priority that can be used when drawing to the screen.</dd>

<dt><a name="1003262"> </a><code>#define sysThreadPriorityHigh sysThreadPriorityRealTime</code></dt>
<dd><a name="1003263"> </a>An alias for <code>sysThreadPriorityRealTime</code>.</dd>

<dt><a name="1003265"> </a><code>#define sysThreadPriorityLow sysThreadPriorityLowered</code></dt>
<dd><a name="1003266"> </a>An alias for <code>sysThreadPriorityLowered</code>.</dd>

<dt><a name="1007683"> </a><code>#define sysThreadPriorityLowered 100</code></dt>
<dd><a name="1007685"> </a>Priority to be used by background threads or threads that are "CPU hogs."</dd>

<dt><a name="1003268"> </a><code>#define sysThreadPriorityNormal 80</code></dt>
<dd><a name="1003269"> </a>Default priority for event handling.</dd>

<dt><a name="1007688"> </a><code>#define sysThreadPriorityRaised 70</code></dt>
<dd><a name="1007690"> </a>Increased priority (over <code>sysThreadPriorityNormal</code>) for user operations.</dd>

<dt><a name="1003271"> </a><code>#define sysThreadPriorityRealTime 40</code></dt>
<dd><a name="1007755"> </a>Priority to be used by time-critical code, such as that doing audio recording and playback.</dd>

<dt><a name="1007730"> </a><code>#define sysThreadPriorityTransaction 65</code></dt>
<dd><a name="1003272"> </a>Priority to be used for UI transactions.</dd>

<dt><a name="1003274"> </a><code>#define sysThreadPriorityUrgentDisplay 50</code></dt>
<dd><a name="1003275"> </a>Priority that can be used during event collection and dispatching.</dd>

</dl>
<h4>
  <a name="1055163"> </a>Comments 
</h4>

<p><a name="1058075"> </a><a href="SysThread.html#995791"><code>SysThreadCreate()</code></a> and <a href="../Programming_Basics/Event.html#995443"><code>EvtCreateBackgroundThread()</code></a> do not guarantee that the requested priority will be satisfied. A return value of <code>errNone</code> does not guarantee that the thread has been created at requested priority. Depending upon the context in which the function was called, the actual thread priority may be lower than what was requested. In operating system processes, the highest priority is <span style="color: #000000;  font-family: Courier; font-style: normal; font-weight: normal; text-decoration: none; text-transform: none; vertical-align: baseline">sysThreadPriorityBestSystem</span>. For an application, the highest is <span style="color: #000000;  font-family: Courier; font-style: normal; font-weight: normal; text-decoration: none; text-transform: none; vertical-align: baseline">sysThreadPriorityBestApp</span>. Accordingly, if an application calls <code>SysThreadCreate()</code> and specifies a priority of 79, the thread will be created successfully but the actual priority of the new thread will be 80.</p>

<h3 class="hbH3">
  <a name="993404"> </a>Miscellaneous System Thread Constants <a href="#992934"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="993406"> </a>Purpose 
</h4>

<p><a name="1023429"> </a>The header file <code>SysThread.h</code> also declares these constants.</p>
<h4>
  <a name="993411"> </a>Declared In 
</h4>
<code>SysThread.h<a name="993414"> </a></code><h4>
  <a name="993416"> </a>Constants 
</h4>

<dl>
<dt><a name="993419"> </a><code>#define sysConditionVariableInitializer NULL</code></dt>
<dd><a name="1045602"> </a>Initial value for a condition variable of type <a href="SysThread.html#992950"><code>SysConditionVariableType</code></a>.</dd>

<dt><a name="993423"> </a><code>#define sysCriticalSectionInitializer NULL</code></dt>
<dd><a name="993425"> </a>Initial value for a critical section mutex of type <a href="SysThread.html#992975"><code>SysCriticalSectionType</code></a>.</dd>

<dt><a name="993427"> </a><code>#define sysThreadNoGroup NULL</code></dt>
<dd><a name="993429"> </a>A thread group handle value that represents "no thread group." This value is returned from <a href="SysThread.html#996392"><code>SysThreadGroupCreate()</code></a> if the thread group couldn't be created. Pass this value to <a href="SysThread.html#995791"><code>SysThreadCreate()</code></a> if you don't want the thread you are creating to be part of a thread group. Note that <a href="SysThread.html#995881"><code>SysThreadCreateEZ()</code></a> only creates threads that are not part of a thread group: it calls <code>SysThreadCreate()</code> and passes a value of <code>sysThreadNoGroup</code> for the <code class="par">group</code> parameter.</dd>

<dt><a name="993467"> </a><code>#define sysThreadStackBasic 4*1024</code></dt>
<dd><a name="993469"> </a>The size of a stack, in bytes, required by a typical non-UI thread.</dd>

<dt><a name="993471"> </a><code>#define sysThreadStackUI 8*1024</code></dt>
<dd><a name="993473"> </a>The size of a stack, in bytes, required by a typical UI thread. Threads created with <a href="SysThread.html#995881"><code>SysThreadCreateEZ()</code></a> have a stack of this size.</dd>

</dl>

<h3 class="hbH3">
  <a name="993480"> </a>Predefined TSD Slot Names Enum <a href="#992934"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="993485"> </a>Purpose 
</h4>

<p><a name="993488"> </a>Defines a set of TSD slot names that have special meaning to the operating system.</p>
<h4>
  <a name="993490"> </a>Declared In 
</h4>
<code>SysThread.h<a name="993493"> </a></code><h4>
  <a name="993495"> </a>Constants 
</h4>

<dl>
<dt><a name="993498"> </a><code>sysTSDAnonymous = 0</code></dt>
<dd><a name="993500"> </a>Anonymous slot. Supply this value for the slot name when allocating a new TSD slot (using <a href="SysThread.html#997084"><code>SysTSDAllocate()</code></a>) if you don't need to update the slot's destructor function pointer and thus don't need to give the slot a particular name.</dd>

</dl>

<h3 class="hbH3">
  <a name="993507"> </a>Predefined Semaphore Counts Enum <a href="#992934"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="993512"> </a>Purpose 
</h4>

<p><a name="993515"> </a>Defines useful semaphore count values.</p>
<h4>
  <a name="993517"> </a>Declared In 
</h4>
<code>SysThread.h<a name="993520"> </a></code><h4>
  <a name="993522"> </a>Constants 
</h4>

<dl>
<dt><a name="993525"> </a><code>sysSemaphoreMaxCount = 0xffff</code></dt>
<dd><a name="993527"> </a>The greatest value that can be supplied either for the initial or maximum semaphore counts when creating a semaphore with either <a href="SysThread.html#1025693"><code>SysSemaphoreCreate()</code></a> or <a href="SysThread.html#995038"><code>SysSemaphoreCreateEZ()</code></a>.</dd>

</dl>

<h3 class="hbH3">
  <a name="1050398"> </a>timeoutFlags_t Typedef <a href="#992934"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="1050400"> </a>Purpose 
</h4>

<p><a name="1050401"> </a>Variables of this type contain flags that indicate how a given timeout value should be interpreted.</p>
<h4>
  <a name="1050405"> </a>Declared In 
</h4>
<code>SysThread.h<a name="1050406"> </a></code><h4>
  <a name="1050407"> </a>Prototype 
</h4>
<pre class="proto"><a name="1050408"></a>typedef uint16_t timeoutFlags_t
</pre>
<h4>
  <a name="993553"> </a>Constants 
</h4>

<dl>
<dt><a name="993556"> </a><code>P_WAIT_FOREVER = 0x0000</code></dt>
<dd><a name="993558"> </a>The specified timeout value should be ignored; the thread or semaphore should wait for an indefinite period of time. This flag should never be used with <a href="SysThread.html#996239"><code>SysThreadDelay()</code></a>.</dd>

<dt><a name="993560"> </a><code>P_POLL = 0x0300</code></dt>
<dd><a name="993562"> </a>The timeout value should be ignored, and the function should return immediately.</dd>

<dt><a name="993564"> </a><code>P_RELATIVE_TIMEOUT = 0x0100</code></dt>
<dd><a name="993566"> </a>The timeout value is a number of nanoseconds that should be added to the amount of time the thread or semaphore is already scheduled to wait.</dd>

<dt><a name="993568"> </a><code>P_ABSOLUTE_TIMEOUT = 0x0200</code></dt>
<dd><a name="993570"> </a>The timeout value specifies the absolute number of nanoseconds that the thread or semaphore should wait.</dd>

</dl>
<h4>
  <a name="993572"> </a>Comments 
</h4>

<p><a name="993575"> </a>These flags are used in conjunction with the <a href="SysThread.html#995555"><code>SysSemaphoreWait()</code></a>, <a href="SysThread.html#995605"><code>SysSemaphoreWaitCount()</code></a>, and <a href="SysThread.html#996239"><code>SysThreadDelay()</code></a> functions. These values are contained in a variable of type <a href="SysThread.html#1050398"><code>timeoutFlags_t</code></a>.</p>

<h2 class="haH2">
  <a name="993577"> </a>SysThread Functions and Macros <a href="#992934"><span class="nav">^TOP^</span></a>
</h2>


<h3 class="hbH3">
  <a name="993589"> </a>SysAtomicAdd32 Function <a href="#992934"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="993594"> </a>Purpose 
</h4>

<p><a name="1026962"> </a>Atomically adds a 32-bit quantity to a location in memory and returns the value of that memory location as it was prior to the addition. </p>
<h4>
  <a name="993599"> </a>Declared In 
</h4>
<code>SysThread.h<a name="993602"> </a></code><h4>
  <a name="993604"> </a>Prototype 
</h4>
<pre class="proto"><a name="993607"></a>int32_t SysAtomicAdd32 (
   int32_t volatile <code class="par">*ioOperandP</code>,
   int32_t <code class="par">iAddend</code>
)
</pre>
<h4>
  <a name="993609"> </a>Parameters 
</h4>

<dl>
<dt><a name="993612"> </a><code>&harr;  <i>ioOperandP</i></code></dt>
<dd><a name="993614"> </a>Pointer to a 32-bit quantity to which <code class="par">iAddend</code> is to be added.</dd>

<dt><a name="993616"> </a><code>&rarr;  <i>iAddend</i></code></dt>
<dd><a name="993618"> </a>Value to be added to <code>*</code><code class="par">ioOperandP</code>.</dd>

</dl>
<h4>
  <a name="993620"> </a>Returns 
</h4>

<p><a name="993623"> </a>Returns the value in <code>*</code><code class="par">ioOperandP</code> before <code class="par">iAddend</code> was added to it.</p>
<h4>
  <a name="993630"> </a>See Also 
</h4>

<p><a name="993633"> </a><a href="SysThread.html#993685"><code>SysAtomicAnd32()</code></a>, <a href="SysThread.html#993731"><code>SysAtomicCompareAndSwap32()</code></a>, <a href="SysThread.html#993958"><code>SysAtomicOr32()</code></a></p>

<h3 class="hbH3">
  <a name="993685"> </a>SysAtomicAnd32 Function <a href="#992934"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="993690"> </a>Purpose 
</h4>

<p><a name="1032060"> </a>Atomically ANDs a 32-bit quantity into a location in memory and returns the value of that memory location as it was prior to the AND operation. </p>
<h4>
  <a name="993695"> </a>Declared In 
</h4>
<code>SysThread.h<a name="993698"> </a></code><h4>
  <a name="993700"> </a>Prototype 
</h4>
<pre class="proto"><a name="993703"></a>uint32_t SysAtomicAnd32 (
   uint32_t volatile <code class="par">*ioOperandP</code>,
   uint32_t <code class="par">iValue</code>
)
</pre>
<h4>
  <a name="993705"> </a>Parameters 
</h4>

<dl>
<dt><a name="993708"> </a><code>&harr;  <i>ioOperandP</i></code></dt>
<dd><a name="1032396"> </a>Pointer to a 32-bit quantity to which <code class="par">ivalue</code> is to be ANDed. Upon return the indicated memory location contains the results of the AND operation.</dd>

<dt><a name="993712"> </a><code>&rarr;  <i>iValue</i></code></dt>
<dd><a name="1032472"> </a>Value to be ANDed with <code>*</code><code class="par">ioOperandP</code>.</dd>

</dl>
<h4>
  <a name="993716"> </a>Returns 
</h4>

<p><a name="1032614"> </a>Returns the value in <code>*</code><code class="par">ioOperandP</code> before <code class="par">iValue</code> was ANDed with it.</p>
<h4>
  <a name="993726"> </a>See Also 
</h4>

<p><a name="1033028"> </a><a href="SysThread.html#993589"><code>SysAtomicAdd32()</code></a>, <a href="SysThread.html#993731"><code>SysAtomicCompareAndSwap32()</code></a>, <a href="SysThread.html#993958"><code>SysAtomicOr32()</code></a></p>

<h3 class="hbH3">
  <a name="993731"> </a>SysAtomicCompareAndSwap32 Function <a href="#992934"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="993740"> </a>Purpose 
</h4>

<p><a name="993745"> </a>In a single atomic operation, compares the contents of a location in memory with a supplied 32-bit value, and, if they are the same, changes the location in memory to a second supplied 32-bit value.</p>
<h4>
  <a name="993753"> </a>Declared In 
</h4>
<code>SysThread.h<a name="993764"> </a></code><h4>
  <a name="993774"> </a>Prototype 
</h4>
<pre class="proto"><a name="993785"></a>uint32_t SysAtomicCompareAndSwap32 (
   uint32_t volatile <code class="par">*ioOperandP</code>,
   uint32_t <code class="par">iOldValue</code>,
   uint32_t <code class="par">iNewValue</code>
)
</pre>
<h4>
  <a name="993799"> </a>Parameters 
</h4>

<dl>
<dt><a name="993810"> </a><code>&harr;  <i>ioOperandP</i></code></dt>
<dd><a name="1034014"> </a>Pointer to a 32-bit quantity against which <code class="par">iOldValue</code> is to be compared. Upon return the indicated memory location is set to <code class="par">iNewValue</code> if <code>*</code><code class="par">ioOperandP</code> proved equal to <code class="par">iOldValue</code>.</dd>

<dt><a name="993834"> </a><code>&rarr;  <i>iOldValue</i></code></dt>
<dd><a name="993844"> </a>Value against which <code>*</code><code class="par">ioOperandP</code> is to be compared.</dd>

<dt><a name="993846"> </a><code>&rarr;  <i>iNewValue</i></code></dt>
<dd><a name="993848"> </a>Value to be stored in <code>*</code><code class="par">ioOperandP</code> if <code>*</code><code class="par">ioOperandP</code> is equal to <code class="par">iOldValue</code>.</dd>

</dl>
<h4>
  <a name="993850"> </a>Returns 
</h4>

<p><a name="993853"> </a>Returns 0 if the swap was performed, or 1 if the swap was not performed (thus indicating that the location pointed to by <code class="par">ioOperandP</code> wasn't equal to <code class="par">iOldvalue</code>).</p>
<h4>
  <a name="993860"> </a>See Also 
</h4>

<p><a name="1033975"> </a><a href="SysThread.html#993589"><code>SysAtomicAdd32()</code></a>, <a href="SysThread.html#993685"><code>SysAtomicAnd32()</code></a>, <a href="SysThread.html#993958"><code>SysAtomicOr32()</code></a></p>

<h3 class="hbH3">
  <a name="993958"> </a>SysAtomicOr32 Function <a href="#992934"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="993987"> </a>Purpose 
</h4>

<p><a name="1033290"> </a>Atomically ORs a 32-bit quantity into a location in memory and returns the value of that memory location as it was prior to the OR operation. </p>
<h4>
  <a name="993992"> </a>Declared In 
</h4>
<code>SysThread.h<a name="993995"> </a></code><h4>
  <a name="993997"> </a>Prototype 
</h4>
<pre class="proto"><a name="994000"></a>uint32_t SysAtomicOr32 (
   uint32_t volatile <code class="par">*ioOperandP</code>,
   uint32_t <code class="par">iValue</code>
)
</pre>
<h4>
  <a name="994002"> </a>Parameters 
</h4>

<dl>
<dt><a name="994005"> </a><code>&harr;  <i>ioOperandP</i></code></dt>
<dd><a name="1033334"> </a>Pointer to a 32-bit quantity to which <code class="par">ivalue</code> is to be ORed. Upon return the indicated memory location contains the results of the OR operation.</dd>

<dt><a name="1033335"> </a><code>&rarr;  <i>iValue</i></code></dt>
<dd><a name="1033336"> </a>Value to be ORed with <code>*</code><code class="par">ioOperandP</code>.</dd>

</dl>
<h4>
  <a name="1033337"> </a>Returns 
</h4>

<p><a name="1033338"> </a>Returns the value in <code>*</code><code class="par">ioOperandP</code> before <code class="par">iValue</code> was ORed with it.</p>
<h4>
  <a name="1033339"> </a>See Also 
</h4>

<p><a name="1033346"> </a><a href="SysThread.html#993589"><code>SysAtomicAdd32()</code></a>, <a href="SysThread.html#993685"><code>SysAtomicAnd32()</code></a>, <a href="SysThread.html#993731"><code>SysAtomicCompareAndSwap32()</code></a></p>

<h3 class="hbH3">
  <a name="994028"> </a>SysConditionVariableBroadcast Function <a href="#992934"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="994033"> </a>Purpose 
</h4>

<p><a name="994036"> </a>Cause all threads waiting on a specified condition variable to continue.</p>
<h4>
  <a name="994038"> </a>Declared In 
</h4>
<code>SysThread.h<a name="994041"> </a></code><h4>
  <a name="994043"> </a>Prototype 
</h4>
<pre class="proto"><a name="994046"></a>void SysConditionVariableBroadcast (
   SysConditionVariableType <code class="par">*iCV</code>
)
</pre>
<h4>
  <a name="994048"> </a>Parameters 
</h4>

<dl>
<dt><a name="994051"> </a><code>&rarr;  <i>iCV</i></code></dt>
<dd><a name="994053"> </a>Pointer to the condition variable upon which waiting threads are to be released.</dd>

</dl>
<h4>
  <a name="994055"> </a>Returns 
</h4>

<p><a name="994058"> </a>Nothing.</p>
<h4>
  <a name="994060"> </a>Comments 
</h4>

<p><a name="994063"> </a>All threads waiting on the specified condition variable are released. Upon completion of this function, the condition variable remains closed.</p>
<h4>
  <a name="994065"> </a>See Also 
</h4>

<p><a name="994068"> </a><a href="SysThread.html#994116"><code>SysConditionVariableOpen()</code></a>, <a href="SysThread.html#994158"><code>SysConditionVariableWait()</code></a></p>

<h3 class="hbH3">
  <a name="994070"> </a>SysConditionVariableClose Function <a href="#992934"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="994079"> </a>Purpose 
</h4>

<p><a name="994082"> </a>Transition a condition variable from opened to closed.</p>
<h4>
  <a name="994084"> </a>Declared In 
</h4>
<code>SysThread.h<a name="994087"> </a></code><h4>
  <a name="994089"> </a>Prototype 
</h4>
<pre class="proto"><a name="994092"></a>void SysConditionVariableClose (
   SysConditionVariableType <code class="par">*iCV</code>
)
</pre>
<h4>
  <a name="994094"> </a>Parameters 
</h4>

<dl>
<dt><a name="994097"> </a><code>&rarr;  <i>iCV</i></code></dt>
<dd><a name="994099"> </a>Pointer to the condition variable that is to be closed.</dd>

</dl>
<h4>
  <a name="994101"> </a>Returns 
</h4>

<p><a name="994104"> </a>Nothing.</p>
<h4>
  <a name="994106"> </a>Comments 
</h4>

<p><a name="994109"> </a>If the condition variable is not open when this function is called, it is left as-is.</p>
<h4>
  <a name="994111"> </a>See Also 
</h4>

<p><a name="994114"> </a><a href="SysThread.html#994116"><code>SysConditionVariableOpen()</code></a>, <a href="SysThread.html#994158"><code>SysConditionVariableWait()</code></a></p>

<h3 class="hbH3">
  <a name="994116"> </a>SysConditionVariableOpen Function <a href="#992934"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="994121"> </a>Purpose 
</h4>

<p><a name="1046787"> </a>Transition a condition variable from closed to opened.</p>
<h4>
  <a name="994126"> </a>Declared In 
</h4>
<code>SysThread.h<a name="994129"> </a></code><h4>
  <a name="994131"> </a>Prototype 
</h4>
<pre class="proto"><a name="994134"></a>void SysConditionVariableOpen (
   SysConditionVariableType <code class="par">*iCV</code>
)
</pre>
<h4>
  <a name="994136"> </a>Parameters 
</h4>

<dl>
<dt><a name="1046893"> </a><code>&rarr;  <i>iCV</i></code></dt>
<dd><a name="1046894"> </a>Pointer to the condition variable that is to be opened.</dd>

</dl>
<h4>
  <a name="994143"> </a>Returns 
</h4>

<p><a name="994146"> </a>Nothing.</p>
<h4>
  <a name="1048418"> </a>Comments 
</h4>

<p><a name="1048423"> </a>All threads that are blocked on the specified condition variable are released. If the specified condition variable is already open when this function is called, it does nothing.</p>
<h4>
  <a name="994153"> </a>See Also 
</h4>

<p><a name="994156"> </a><a href="SysThread.html#994028"><code>SysConditionVariableBroadcast()</code></a>, <a href="SysThread.html#994070"><code>SysConditionVariableClose()</code></a></p>

<h3 class="hbH3">
  <a name="994158"> </a>SysConditionVariableWait Function <a href="#992934"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="994163"> </a>Purpose 
</h4>

<p><a name="994166"> </a>Wait for a specified condition variable to become open.</p>
<h4>
  <a name="994168"> </a>Declared In 
</h4>
<code>SysThread.h<a name="994171"> </a></code><h4>
  <a name="994173"> </a>Prototype 
</h4>
<pre class="proto"><a name="994176"></a>void SysConditionVariableWait (
   SysConditionVariableType <code class="par">*iCV</code>,
   SysCriticalSectionType <code class="par">*iOptionalCS</code>
)
</pre>
<h4>
  <a name="994194"> </a>Parameters 
</h4>

<dl>
<dt><a name="994247"> </a><code>&rarr;  <i>iCV</i></code></dt>
<dd><a name="994303"> </a>Pointer to the condition variable upon which to wait.</dd>

<dt><a name="994389"> </a><code>&rarr;  <i>iOptionalCS</i></code></dt>
<dd><a name="994447"> </a>Pointer to the mutex for a critical section if this function is called from within the critical section and the critical section is to be temporarily exited while this thread waits on the condition variable. Pass <code>NULL</code> if the call doesn't come from within a critical section, or if it does but other threads shouldn't be granted access to the critical section while this thread waits.</dd>

</dl>
<h4>
  <a name="994449"> </a>Returns 
</h4>

<p><a name="994452"> </a>Nothing.</p>
<h4>
  <a name="994454"> </a>Comments 
</h4>

<p><a name="994457"> </a>If the critical section is not open when this function is called, the calling thread is put in the WAIT state and placed in a queue associated with the specified condition variable. Once the condition variable is opened, all threads waiting on the variable are released. Note that you can also release all waiting threads by calling <a href="SysThread.html#994028"><code>SysConditionVariableBroadcast()</code></a>, which, unlike <a href="SysThread.html#994116"><code>SysConditionVariableOpen()</code></a>, leaves the condition variable in a closed state.</p>

<p><a name="1048718"> </a>If the call to this function occurs within a critical section, you may want to supply the critical section mutex as the <code class="par">iOptionalCS</code> parameter. This causes the critical section to be exited in the event that the thread is put into the WAIT state. Once the thread is released the specified critical section is immediately re-entered. This has the effect of allowing other threads to enter the critical section while this thread is waiting on the condition variable. If the call to this function does not occur within a critical section, or if it does but other threads shouldn't be able to enter the critical section while this thread is waiting, pass <code>NULL</code> for the <code class="par">iOptionalCS</code> parameter.</p>
<h4>
  <a name="994459"> </a>See Also 
</h4>

<p><a name="994462"> </a><a href="SysThread.html#994028"><code>SysConditionVariableBroadcast()</code></a>, <a href="SysThread.html#994116"><code>SysConditionVariableOpen()</code></a></p>

<h3 class="hbH3">
  <a name="994464"> </a>SysCriticalSectionEnter Function <a href="#992934"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="994469"> </a>Purpose 
</h4>

<p><a name="994472"> </a>Acquire a critical section&#8212;a block of code that can only be executed by one thread at a time.</p>
<h4>
  <a name="994474"> </a>Declared In 
</h4>
<code>SysThread.h<a name="994477"> </a></code><h4>
  <a name="994479"> </a>Prototype 
</h4>
<pre class="proto"><a name="994482"></a>void SysCriticalSectionEnter (
   SysCriticalSectionType <code class="par">*iCS</code>
)
</pre>
<h4>
  <a name="994484"> </a>Parameters 
</h4>

<dl>
<dt><a name="994487"> </a><code>&rarr;  <i>iCS</i></code></dt>
<dd><a name="994489"> </a>Pointer to a <a href="SysThread.html#992975"><code>SysCriticalSectionType</code></a> variable that acts as the mutex for the code block. This variable should be either globally or statically defined and should be initialized to <code>sysCriticalSectionInitializer</code>.</dd>

</dl>
<h4>
  <a name="994491"> </a>Returns 
</h4>

<p><a name="994494"> </a>Nothing.</p>
<h4>
  <a name="994496"> </a>Comments 
</h4>

<p><a name="994499"> </a>Call this function at the beginning of the critical section to ensure that yours is the only process that is executing the code in the critical section&#8212;that code that is bounded by the <code>SysCriticalSectionEnter()</code> and <a href="SysThread.html#994506"><code>SysCriticalSectionExit()</code></a> calls.</p>
<h4>
  <a name="994501"> </a>See Also 
</h4>

<p><a name="994504"> </a><a href="SysThread.html#994506"><code>SysCriticalSectionExit()</code></a></p>

<h3 class="hbH3">
  <a name="994506"> </a>SysCriticalSectionExit Function <a href="#992934"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="994511"> </a>Purpose 
</h4>

<p><a name="994514"> </a>Release a critical section.</p>
<h4>
  <a name="994516"> </a>Declared In 
</h4>
<code>SysThread.h<a name="994533"> </a></code><h4>
  <a name="994553"> </a>Prototype 
</h4>
<pre class="proto"><a name="994590"></a>void SysCriticalSectionExit (
   SysCriticalSectionType <code class="par">*iCS</code>
)
</pre>
<h4>
  <a name="994650"> </a>Parameters 
</h4>

<dl>
<dt><a name="994693"> </a><code>&rarr;  <i>iCS</i></code></dt>
<dd><a name="1044635"> </a>Pointer to a <a href="SysThread.html#992975"><code>SysCriticalSectionType</code></a> variable that acts as the mutex for the code block.</dd>

</dl>
<h4>
  <a name="994797"> </a>Returns 
</h4>

<p><a name="994840"> </a>Nothing.</p>
<h4>
  <a name="994842"> </a>Comments 
</h4>

<p><a name="994845"> </a>Call this function at the end of the critical section, thereby allowing another process to enter the critical section.</p>
<h4>
  <a name="1044500"> </a>See Also 
</h4>

<p><a name="1044501"> </a><a href="SysThread.html#994464"><code>SysCriticalSectionEnter()</code></a></p>

<h3 class="hbH3">
  <a name="1044504"> </a>SysCurrentThread Function <a href="#992934"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="994857"> </a>Purpose 
</h4>

<p><a name="994860"> </a>Return the identity of the current thread.</p>
<h4>
  <a name="994862"> </a>Declared In 
</h4>
<code>SysThread.h<a name="994865"> </a></code><h4>
  <a name="994867"> </a>Prototype 
</h4>
<pre class="proto"><a name="994870"></a>SysHandle SysCurrentThread (
   void
)
</pre>
<h4>
  <a name="994872"> </a>Parameters 
</h4>

<p><a name="994875"> </a>None.</p>
<h4>
  <a name="994877"> </a>Returns 
</h4>

<p><a name="994880"> </a>Returns the thread ID of the current thread.</p>

<h3 class="hbH3">
  <a name="994892"> </a>SysGetRunTime Function <a href="#992934"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="994897"> </a>Purpose 
</h4>

<p><a name="994900"> </a>Get the length of time since last reset, in nanoseconds.</p>
<h4>
  <a name="994902"> </a>Declared In 
</h4>
<code>SysThread.h<a name="994905"> </a></code><h4>
  <a name="994907"> </a>Prototype 
</h4>
<pre class="proto"><a name="994910"></a>nsecs_t SysGetRunTime (
   void
)
</pre>
<h4>
  <a name="994912"> </a>Parameters 
</h4>

<p><a name="994915"> </a>None.</p>
<h4>
  <a name="994917"> </a>Returns 
</h4>

<p><a name="994920"> </a>Returns the amount of time, in nanoseconds, since the last reset.</p>

<h3 class="hbH3">
  <a name="1025693"> </a>SysSemaphoreCreate Function <a href="#992934"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="994989"> </a>Purpose 
</h4>

<p><a name="994992"> </a>Create a new counting semaphore with the specified initial count and maximum count values.</p>
<h4>
  <a name="994994"> </a>Declared In 
</h4>
<code>SysThread.h<a name="994997"> </a></code><h4>
  <a name="994999"> </a>Prototype 
</h4>
<pre class="proto"><a name="995002"></a>status_t SysSemaphoreCreate (
   uint32_t <code class="par">initialCount</code>,
   uint32_t <code class="par">maxCount</code>,
   uint32_t <code class="par">flags</code>,
   SysHandle <code class="par">*outSemaphore</code>
)
</pre>
<h4>
  <a name="995004"> </a>Parameters 
</h4>

<dl>
<dt><a name="995007"> </a><code>&rarr;  <i>initialCount</i></code></dt>
<dd><a name="995009"> </a>The initial count of the newly-created semaphore. This value can range from zero to <code>sysSemaphoreMaxCount</code>. Typically, this represents the number of objects available in a resource pool.</dd>

<dt><a name="995011"> </a><code>&rarr;  <i>maxCount</i></code></dt>
<dd><a name="995013"> </a>The maximum count of the newly-created semaphore. This value can range from one to <code>sysSemaphoreMaxCount</code>. The maximum count typically represents the maximum number of objects that can be in the resource pool.</dd>

<dt><a name="995015"> </a><code>&rarr;  <i>flags</i></code></dt>
<dd><a name="995017"> </a>Flags that specify how the semaphore is to be created. This parameter is currently ignored; applications should pass zero for <code class="par">flags</code>.</dd>

<dt><a name="995019"> </a><code>&larr;  <i>outSemaphore</i></code></dt>
<dd><a name="1036313"> </a>ID of the newly-created semaphore.</dd>

</dl>
<h4>
  <a name="995023"> </a>Returns 
</h4>

<p><a name="1035237"> </a>Returns <code>errNone</code> if the semaphore was successfully created, or one of the following otherwise:</p>

<dl>
<dt><a name="1035238"> </a><code>sysErrOutOfRange</code></dt>
<dd><a name="1035239"> </a><code class="par">initialCount</code> or <code class="par">maxCount</code> exceeds <code>sysSemaphoreMaxCount</code>.</dd>

<dt><a name="1035458"> </a><code>sysErrParamErr</code></dt>
<dd><a name="1035512"> </a><code class="par">initialCount</code> exceeds <code class="par">maxCount</code>.</dd>

<dt><a name="1035333"> </a><code>sysErrNoFreeResource</code></dt>
<dd><a name="1035523"> </a>All possible semaphores are already in use.</dd>

</dl>
<h4>
  <a name="1037633"> </a>Comments 
</h4>

<p><a name="1037714"> </a>Counting semaphores are used to keep track of the availability of a resource within a pool of limited size.</p>
<h4>
  <a name="995033"> </a>See Also 
</h4>

<p><a name="995036"> </a><a href="SysThread.html#995038"><code>SysSemaphoreCreateEZ()</code></a>, <a href="SysThread.html#995127"><code>SysSemaphoreDestroy()</code></a></p>

<h3 class="hbH3">
  <a name="995038"> </a>SysSemaphoreCreateEZ Function <a href="#992934"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="995043"> </a>Purpose 
</h4>

<p><a name="995046"> </a>Creates a new counting semaphore with a maximum count value of <span style="color: #000000;  font-family: Courier; font-style: normal; font-weight: normal; text-decoration: none; text-transform: none; vertical-align: baseline">sysSemaphoreMaxCount</span> (65535).</p>
<h4>
  <a name="995048"> </a>Declared In 
</h4>
<code>SysThread.h<a name="995051"> </a></code><h4>
  <a name="995053"> </a>Prototype 
</h4>
<pre class="proto"><a name="995056"></a>status_t SysSemaphoreCreateEZ (
   uint32_t <code class="par">initialCount</code>,
   SysHandle <code class="par">*outSemaphore</code>
)
</pre>
<h4>
  <a name="995058"> </a>Parameters 
</h4>

<dl>
<dt><a name="995061"> </a><code>&rarr;  <i>initialCount</i></code></dt>
<dd><a name="1035738"> </a>The initial count of the newly-created semaphore. This value can range from zero to <code>sysSemaphoreMaxCount</code>.</dd>

<dt><a name="995065"> </a><code>&larr;  <i>outSemaphore</i></code></dt>
<dd><a name="1034513"> </a>ID of the newly-created semaphore.</dd>

</dl>
<h4>
  <a name="995069"> </a>Returns 
</h4>

<p><a name="995072"> </a>Returns <code>errNone</code> if the semaphore was successfully created, or one of the following otherwise:</p>

<dl>
<dt><a name="1035085"> </a><code>sysErrOutOfRange</code></dt>
<dd><a name="1035222"> </a><code class="par">initialCount</code> exceeds <code>sysSemaphoreMaxCount</code>.</dd>

<dt><a name="1035772"> </a><code>sysErrNoFreeResource</code></dt>
<dd><a name="1035773"> </a>All possible semaphores are already in use.</dd>

</dl>
<h4>
  <a name="995074"> </a>Comments 
</h4>

<p><a name="995083"> </a>This function simply calls <a href="SysThread.html#1025693"><code>SysSemaphoreCreate()</code></a> and passes a value of zero for the <code class="par">flags</code> parameter and a value of <span style="color: #000000;  font-family: Courier; font-style: normal; font-weight: normal; text-decoration: none; text-transform: none; vertical-align: baseline">sysSemaphoreMaxCount</span> for the <code class="par">maxCount</code> parameter.</p>
<h4>
  <a name="995093"> </a>See Also 
</h4>

<p><a name="1035881"> </a><a href="SysThread.html#1025693"><code>SysSemaphoreCreate()</code></a>, <a href="SysThread.html#995127"><code>SysSemaphoreDestroy()</code></a></p>

<h3 class="hbH3">
  <a name="995127"> </a>SysSemaphoreDestroy Function <a href="#992934"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="995156"> </a>Purpose 
</h4>

<p><a name="995159"> </a>Destroy a counting semaphore.</p>
<h4>
  <a name="995161"> </a>Declared In 
</h4>
<code>SysThread.h<a name="995164"> </a></code><h4>
  <a name="995166"> </a>Prototype 
</h4>
<pre class="proto"><a name="995169"></a>status_t SysSemaphoreDestroy (
   SysHandle <code class="par">semaphore</code>
)
</pre>
<h4>
  <a name="995171"> </a>Parameters 
</h4>

<dl>
<dt><a name="995174"> </a><code>&rarr;  <i>semaphore</i></code></dt>
<dd><a name="995176"> </a>ID of the semaphore to be destroyed.</dd>

</dl>
<h4>
  <a name="995178"> </a>Returns 
</h4>

<p><a name="995181"> </a>Always returns <code>errNone</code>.</p>
<h4>
  <a name="995183"> </a>Comments 
</h4>

<p><a name="1036319"> </a>Any threads that are blocked on this semaphore are released and their return values are set to <code>kalErrObjectDestroyed</code>.</p>
<h4>
  <a name="995188"> </a>See Also 
</h4>

<p><a name="995191"> </a><a href="SysThread.html#1025693"><code>SysSemaphoreCreate()</code></a>, <a href="SysThread.html#995038"><code>SysSemaphoreCreateEZ()</code></a></p>

<h3 class="hbH3">
  <a name="995193"> </a>SysSemaphoreSignal Function <a href="#992934"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="995198"> </a>Purpose 
</h4>

<p><a name="1038096"> </a>Release a single resource back to the semaphore. One of the threads waiting on the semaphore (assuming that there are any) is released.</p>
<h4>
  <a name="995203"> </a>Declared In 
</h4>
<code>SysThread.h<a name="995206"> </a></code><h4>
  <a name="995208"> </a>Prototype 
</h4>
<pre class="proto"><a name="995211"></a>status_t SysSemaphoreSignal (
   SysHandle <code class="par">semaphore</code>
)
</pre>
<h4>
  <a name="995213"> </a>Parameters 
</h4>

<dl>
<dt><a name="995216"> </a><code>&rarr;  <i>semaphore</i></code></dt>
<dd><a name="1040613"> </a>ID of the semaphore to which resources are to be released.</dd>

</dl>
<h4>
  <a name="995220"> </a>Returns 
</h4>

<p><a name="1037508"> </a>Returns <code>errNone</code> if the maximum semaphore count wasn't exceeded, or <code>kalErrLimitReached</code> if the supplied count would cause the semaphore's count to exceed the maximum value specified when the semaphore was created.</p>
<h4>
  <a name="995225"> </a>Comments 
</h4>

<p><a name="1042798"> </a>This function is equivalent to calling <a href="SysThread.html#995235"><code>SysSemaphoreSignalCount()</code></a> with a count of 1. See the comments under that function for more on how this function operates.</p>
<h4>
  <a name="995230"> </a>See Also 
</h4>

<p><a name="995233"> </a><a href="SysThread.html#995235"><code>SysSemaphoreSignalCount()</code></a>, <a href="SysThread.html#995555"><code>SysSemaphoreWait()</code></a></p>

<h3 class="hbH3">
  <a name="995235"> </a>SysSemaphoreSignalCount Function <a href="#992934"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="995240"> </a>Purpose 
</h4>

<p><a name="995243"> </a>Release a specified number of resources back to the semaphore. As a result, as many threads as possible that are waiting on the semaphore are released.</p>
<h4>
  <a name="995245"> </a>Declared In 
</h4>
<code>SysThread.h<a name="995248"> </a></code><h4>
  <a name="995250"> </a>Prototype 
</h4>
<pre class="proto"><a name="995253"></a>status_t SysSemaphoreSignalCount (
   SysHandle <code class="par">semaphore</code>,
   uint32_t <code class="par">count</code>
)
</pre>
<h4>
  <a name="995313"> </a>Parameters 
</h4>

<dl>
<dt><a name="995366"> </a><code>&rarr;  <i>semaphore</i></code></dt>
<dd><a name="995422"> </a>ID of the semaphore to which resources are to be released.</dd>

<dt><a name="995480"> </a><code>&rarr;  <i>count</i></code></dt>
<dd><a name="995538"> </a>The amount to be added to the semaphore's count.</dd>

</dl>
<h4>
  <a name="995540"> </a>Returns 
</h4>

<p><a name="995543"> </a>Returns <code>errNone</code> if the maximum semaphore count wasn't exceeded, or <code>kalErrLimitReached</code> if the supplied count would cause the semaphore's count to exceed the maximum value specified when the semaphore was created.</p>
<h4>
  <a name="995545"> </a>Comments 
</h4>

<p><a name="1036339"> </a>Use this function to return one or more resources to the specified semaphore. If there are threads waiting at the semaphore, as many threads as possible (given the new available resource count) are released either to the RUN or READY states. After this the semaphore's new resource count becomes its old count, plus <code class="par">count</code>, minus the resources consumed by the newly-released threads.</p>

<p><a name="1043091"> </a>Note that it is not an error if the semaphore count exceeds the initial semaphore count that was specified when the semaphore was created. If a semaphore is going to be used for exclusive control, create the semaphore with the maximum count equal to the initial semaphore count.</p>
<h4>
  <a name="995550"> </a>See Also 
</h4>

<p><a name="1037596"> </a><a href="SysThread.html#995193"><code>SysSemaphoreSignal()</code></a>, <a href="SysThread.html#995605"><code>SysSemaphoreWaitCount()</code></a></p>

<h3 class="hbH3">
  <a name="995555"> </a>SysSemaphoreWait Function <a href="#992934"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="995560"> </a>Purpose 
</h4>

<p><a name="1040349"> </a>Obtains a single resource from a specified semaphore.</p>
<h4>
  <a name="995565"> </a>Declared In 
</h4>
<code>SysThread.h<a name="995568"> </a></code><h4>
  <a name="995570"> </a>Prototype 
</h4>
<pre class="proto"><a name="995573"></a>status_t SysSemaphoreWait (
   SysHandle <code class="par">semaphore</code>,
   timeoutFlags_t <code class="par">iTimeoutFlags</code>,
   nsecs_t <code class="par">iTimeout</code>
)
</pre>
<h4>
  <a name="995575"> </a>Parameters 
</h4>

<dl>
<dt><a name="995578"> </a><code>&rarr;  <i>semaphore</i></code></dt>
<dd><a name="1040443"> </a>ID of the semaphore from which resources are to be acquired.</dd>

<dt><a name="995582"> </a><code>&rarr;  <i>iTimeoutFlags</i></code></dt>
<dd><a name="1050788"> </a>A value specifying how the timeout value should be interpreted. See <a href="SysThread.html#1050398"><code>timeoutFlags_t</code></a>.</dd>

<dt><a name="995586"> </a><code>&rarr;  <i>iTimeout</i></code></dt>
<dd><a name="995588"> </a>Timeout value, in nanoseconds. </dd>

</dl>
<h4>
  <a name="995590"> </a>Returns 
</h4>

<p><a name="1042243"> </a>Returns <code>errNone</code> if the specified number of resources were successfully obtained, or one of the following otherwise:</p>

<dl>
<dt><a name="1042246"> </a><code>sysErrTimeout</code></dt>
<dd><a name="1042247"> </a>There aren't <code class="par">count</code> resources available, and either the timeout expired before enough resources were made available, or the timeout flags were set to <code>P_POLL</code>, indicating that this function shouldn't wait for additional resources to become available.</dd>

</dl>
<h4>
  <a name="995595"> </a>Comments 
</h4>

<p><a name="995598"> </a>This function is equivalent to calling <a href="SysThread.html#995605"><code>SysSemaphoreWaitCount()</code></a> with a count of 1. See the comments under that function for more on how this function operates.</p>
<h4>
  <a name="995600"> </a>See Also 
</h4>

<p><a name="1040115"> </a><a href="SysThread.html#995193"><code>SysSemaphoreSignal()</code></a>, <a href="SysThread.html#995605"><code>SysSemaphoreWaitCount()</code></a></p>

<h3 class="hbH3">
  <a name="995605"> </a>SysSemaphoreWaitCount Function <a href="#992934"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="995614"> </a>Purpose 
</h4>

<p><a name="995619"> </a>Obtains one or more resources from a specified semaphore.</p>
<h4>
  <a name="995627"> </a>Declared In 
</h4>
<code>SysThread.h<a name="995638"> </a></code><h4>
  <a name="995648"> </a>Prototype 
</h4>
<pre class="proto"><a name="995659"></a>status_t SysSemaphoreWaitCount (
   SysHandle <code class="par">semaphore</code>,
   timeoutFlags_t <code class="par">iTimeoutFlags</code>,
   nsecs_t <code class="par">iTimeout</code>,
   uint32_t <code class="par">count</code>
)
</pre>
<h4>
  <a name="995673"> </a>Parameters 
</h4>

<dl>
<dt><a name="995684"> </a><code>&rarr;  <i>semaphore</i></code></dt>
<dd><a name="1040529"> </a>ID of the semaphore from which resources are to be acquired.</dd>

<dt><a name="995704"> </a><code>&rarr;  <i>iTimeoutFlags</i></code></dt>
<dd><a name="1042018"> </a>A value specifying how the timeout value should be interpreted. See <a href="SysThread.html#1050398"><code>timeoutFlags_t</code></a>.</dd>

<dt><a name="1041719"> </a><code>&rarr;  <i>iTimeout</i></code></dt>
<dd><a name="1041720"> </a>Timeout value, in nanoseconds. </dd>

<dt><a name="1041721"> </a><code>&rarr;  <i>count</i></code></dt>
<dd><a name="1041722"> </a>The number of resources to be acquired.</dd>

</dl>
<h4>
  <a name="995724"> </a>Returns 
</h4>

<p><a name="995727"> </a>Returns <code>errNone</code> if the specified number of resources were successfully obtained, or one of the following otherwise:</p>

<dl>
<dt><a name="1042075"> </a><code>sysErrParamErr</code></dt>
<dd><a name="1042164"> </a><code class="par">count</code> is zero, or <code class="par">count</code> exceeds the maximum count specified when the resource was created.</dd>

<dt><a name="1042167"> </a><code>sysErrTimeout</code></dt>
<dd><a name="1042172"> </a>There aren't <code class="par">count</code> resources available, and either the timeout expired before enough resources were made available, or the timeout flags were set to <code>P_POLL</code>, indicating that this function shouldn't wait for additional resources to become available.</dd>

</dl>
<h4>
  <a name="995729"> </a>Comments 
</h4>

<p><a name="1038467"> </a>If the available count for the specified semaphore is greater than or equal to the number of requested resources, the available count is decrement by the number of requested resources and the function returns with <code>errNone</code>. If the number of available resources is less than the number of resources being requested, the calling thread is put in the WAIT state and placed in a queue associated with the semaphore. Until the request is fulfilled, the semaphore's count is not changed.</p>
<h4>
  <a name="995734"> </a>See Also 
</h4>

<p><a name="995737"> </a><a href="SysThread.html#995235"><code>SysSemaphoreSignalCount()</code></a>, <a href="SysThread.html#995555"><code>SysSemaphoreWait()</code></a></p>

<h3 class="hbH3">
  <a name="995739"> </a>SysThreadChangePriority Function <a href="#992934"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="995744"> </a>Purpose 
</h4>

<p><a name="995747"> </a>Change the current priority of a thread.</p>
<h4>
  <a name="995749"> </a>Declared In 
</h4>
<code>SysThread.h<a name="995752"> </a></code><h4>
  <a name="995754"> </a>Prototype 
</h4>
<pre class="proto"><a name="995757"></a>status_t SysThreadChangePriority (
   SysHandle <code class="par">thread</code>,
   uint8_t <code class="par">priority</code>
)
</pre>
<h4>
  <a name="995759"> </a>Parameters 
</h4>

<dl>
<dt><a name="995762"> </a><code>&rarr;  <i>thread</i></code></dt>
<dd><a name="995764"> </a>The thread's identifier.</dd>

<dt><a name="995766"> </a><code>&rarr;  <i>priority</i></code></dt>
<dd><a name="1010561"> </a>The thread's new priority. Useful thread priority values are defined under <a href="SysThread.html#1002445">"Thread Priorities."</a></dd>

</dl>
<h4>
  <a name="995770"> </a>Returns 
</h4>

<p><a name="995773"> </a>Returns <code>errNone</code> if the thread's priority was changed, or <code>sysErrParamErr</code> if either the specified priority is out of the range of allowable thread priorities, or <code class="par">thread</code> doesn't identify a known thread.</p>
<h4>
  <a name="995775"> </a>Comments 
</h4>

<p><a name="995778"> </a>If this function is successful, the thread's new priority remains in effect until it is changed again.</p>

<p><a name="1010313"> </a>This function may result in the re-ordering of the thread queues.</p>

<p><a name="1010381"> </a>If <code>SysThreadChangePriority()</code> is called for a thread waiting on the ready queue (including running threads) or another priority-based queue, the thread will be moved to the end of that part of the queue designated for the new priority.  If the priority specified is the same as the current priority, the thread is still moved behind other threads of the same priority.  Thus, a thread can relinquish its execution privileges by calling <code>SysThreadChangePriority()</code> on itself and specifying its current priority.</p>
<h4>
  <a name="995780"> </a>See Also 
</h4>

<p><a name="995789"> </a><a href="SysThread.html#995791"><code>SysThreadCreate()</code></a></p>

<h3 class="hbH3">
  <a name="995791"> </a>SysThreadCreate Function <a href="#992934"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="995820"> </a>Purpose 
</h4>

<p><a name="995823"> </a>Create a new thread.</p>
<h4>
  <a name="995825"> </a>Declared In 
</h4>
<code>SysThread.h<a name="995828"> </a></code><h4>
  <a name="995830"> </a>Prototype 
</h4>
<pre class="proto"><a name="995833"></a>status_t SysThreadCreate (
   SysThreadGroupHandle <code class="par">group</code>,
   const char <code class="par">*name</code>,
   uint8_t <code class="par">priority</code>,
   uint32_t <code class="par">stackSize</code>,
   SysThreadEnterFunc <code class="par">*func</code>,
   void <code class="par">*argument</code>,
   SysHandle <code class="par">*outThread</code>
)
</pre>
<h4>
  <a name="995835"> </a>Parameters 
</h4>

<dl>
<dt><a name="1008931"> </a><code>&rarr;  <i>group</i></code></dt>
<dd><a name="1008932"> </a>The thread group of which this thread is to be a part (obtained from <a href="SysThread.html#996392"><code>SysThreadGroupCreate()</code></a>), or <code>sysThreadNoGroup</code> if the thread isn't to be part of a thread group.</dd>

<dt><a name="1008933"> </a><code>&rarr;  <i>name</i></code></dt>
<dd><a name="995844"> </a>The name of the thread. The first four characters are used as the thread's ID. If a thread name isn't provided, the thread's ID is <code>'----'</code>.</dd>

<dt><a name="995846"> </a><code>&rarr;  <i>priority</i></code></dt>
<dd><a name="995848"> </a>The requested thread priority. Valid thread priorities range from 1 to 255, with lower values having higher priority. Priority level 0 is reserved and cannot be used&#8212;applications typically have a thread priority no higher than 30. Common thread priority values are defined under <a href="SysThread.html#1002445">"Thread Priorities."</a></dd>

<dt><a name="995850"> </a><code>&rarr;  <i>stackSize</i></code></dt>
<dd><a name="995852"> </a>The size of the thread's stack, in bytes. For a UI thread this is typically 8 KB.</dd>

<dt><a name="995854"> </a><code>&rarr;  <i>func</i></code></dt>
<dd><a name="995856"> </a>Pointer to the function that should initially be executed when the thread is started. See <a href="SysThread.html#997280"><code>SysThreadEnterFunc()</code></a> for the prototype of this function.</dd>

<dt><a name="995858"> </a><code>&rarr;  <i>argument</i></code></dt>
<dd><a name="995860"> </a>Pointer to the argument block to be passed to the thread entry function identified by <code class="par">func</code>, or <code>NULL</code> if the function takes no arguments.</dd>

<dt><a name="995862"> </a><code>&larr;  <i>outThread</i></code></dt>
<dd><a name="995864"> </a>The thread identifier. This value is owned by the newly-created thread and will be freed when the thread exits.</dd>

</dl>
<h4>
  <a name="995866"> </a>Returns 
</h4>

<p><a name="1010048"> </a>Returns <code>errNone</code> if the thread was successfully created, or one of the following otherwise:</p>

<dl>
<dt><a name="1010651"> </a><code><code>sysErrParamErr</code></code></dt>
<dd><a name="1010654"> </a>The <code class="par">func</code> parameter is NULL, or the <code class="par">stackSize</code> parameter is zero.</dd>

<dt><a name="1010641"> </a><code>sysErrNoFreeResource</code></dt>
<dd><a name="1010650"> </a>The system has no free threads.</dd>

</dl>
<h4>
  <a name="995871"> </a>Comments 
</h4>

<p><a name="1018278"> </a>This function creates the specified thread. The new thread is put in the DORMANT state.</p>

<div><hr>
  <a name="1055088"> </a> <b>NOTE: </b> <code>SysThreadCreate()</code> does not guarantee that the requested priority will be satisfied. A return value of <code>errNone</code> does not guarantee that the thread has been created at requested priority. Depending upon the context in which the function was called, the actual thread priority may be lower than what was requested.
<hr>
</div>
<h4>
  <a name="995876"> </a>See Also 
</h4>

<p><a name="995879"> </a><a href="../Programming_Basics/Event.html#995443"><code>EvtCreateBackgroundThread()</code></a>, <a href="SysThread.html#995881"><code>SysThreadCreateEZ()</code></a>, <a href="SysThread.html#996392"><code>SysThreadGroupCreate()</code></a>, <a href="SysThread.html#996581"><code>SysThreadInstallExitCallback()</code></a>, <a href="SysThread.html#996736"><code>SysThreadStart()</code></a></p>

<h3 class="hbH3">
  <a name="995881"> </a>SysThreadCreateEZ Function <a href="#992934"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="995886"> </a>Purpose 
</h4>

<p><a name="995889"> </a>Create a new thread, using default values for the thread group, priority, and stack size.</p>
<h4>
  <a name="995891"> </a>Declared In 
</h4>
<code>SysThread.h<a name="995908"> </a></code><h4>
  <a name="995928"> </a>Prototype 
</h4>
<pre class="proto"><a name="995965"></a>status_t SysThreadCreateEZ (
   const char <code class="par">*name</code>,
   SysThreadEnterFunc <code class="par">*func</code>,
   void <code class="par">*argument</code>,
   SysHandle <code class="par">*outThread</code>
)
</pre>
<h4>
  <a name="996025"> </a>Parameters 
</h4>

<dl>
<dt><a name="1009764"> </a><code>&rarr;  <i>name</i></code></dt>
<dd><a name="1009765"> </a>The name of the thread. The first four characters are used as the thread's ID. If a thread name isn't provided, the thread's ID is <code>'----'</code>.</dd>

<dt><a name="1009825"> </a><code>&rarr;  <i>func</i></code></dt>
<dd><a name="1009826"> </a>Pointer to the function that should initially be executed when the thread is started. See <a href="SysThread.html#997280"><code>SysThreadEnterFunc()</code></a> for the prototype of this function.</dd>

<dt><a name="1009830"> </a><code>&rarr;  <i>argument</i></code></dt>
<dd><a name="1009831"> </a>Pointer to the argument block to be passed to the thread entry function identified by <code class="par">func</code>, or <code>NULL</code> if the function takes no arguments.</dd>

<dt><a name="1009832"> </a><code>&larr;  <i>outThread</i></code></dt>
<dd><a name="1009833"> </a>The thread identifier. This value is owned by the newly-created thread and will be freed when the thread exits.</dd>

</dl>
<h4>
  <a name="996224"> </a>Returns 
</h4>

<p><a name="1010660"> </a>Returns <code>errNone</code> if the thread was successfully created, or one of the following otherwise:</p>

<dl>
<dt><a name="1010661"> </a><code><code>sysErrParamErr</code></code></dt>
<dd><a name="1010662"> </a>The <code class="par">func</code> parameter is NULL, or the <code class="par">stackSize</code> parameter is zero.</dd>

<dt><a name="1010663"> </a><code>sysErrNoFreeResource</code></dt>
<dd><a name="1010664"> </a>The system has no free threads.</dd>

</dl>
<h4>
  <a name="996229"> </a>Comments 
</h4>

<p><a name="996232"> </a>This function simply calls <a href="SysThread.html#995791"><code>SysThreadCreate()</code></a> with the <code class="par">group</code> parameter set to <code>sysThreadNoGroup</code>, the <code class="par">priority</code> parameter set to <code>sysThreadPriorityNormal</code>, and the <code class="par">stackSize</code> parameter set to <code>sysThreadStackUI</code>.</p>
<h4>
  <a name="996234"> </a>See Also 
</h4>

<p><a name="996237"> </a><a href="SysThread.html#996581"><code>SysThreadInstallExitCallback()</code></a>, <a href="SysThread.html#996736"><code>SysThreadStart()</code></a></p>

<h3 class="hbH3">
  <a name="996239"> </a>SysThreadDelay Function <a href="#992934"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="996244"> </a>Purpose 
</h4>

<p><a name="996247"> </a>Halts execution of the thread calling this function for a specified period of time.</p>
<h4>
  <a name="996249"> </a>Declared In 
</h4>
<code>SysThread.h<a name="996252"> </a></code><h4>
  <a name="996254"> </a>Prototype 
</h4>
<pre class="proto"><a name="996257"></a>status_t SysThreadDelay (
   nsecs_t <code class="par">timeout</code>,
   timeoutFlags_t <code class="par">flags</code>
)
</pre>
<h4>
  <a name="996259"> </a>Parameters 
</h4>

<dl>
<dt><a name="996262"> </a><code>&rarr;  <i>timeout</i></code></dt>
<dd><a name="996264"> </a>Timeout value, in nanoseconds. </dd>

<dt><a name="996266"> </a><code>&rarr;  <i>flags</i></code></dt>
<dd><a name="1050851"> </a>A value specifying how the timeout value should be interpreted. See <a href="SysThread.html#1050398"><code>timeoutFlags_t</code></a>.</dd>

</dl>
<h4>
  <a name="996270"> </a>Returns 
</h4>

<p><a name="996273"> </a>Returns <code>errNone</code> if the function executed successfully, or <code>sysErrParamErr</code> if <code class="par">flags</code> was set to <code>P_WAIT_FOREVER</code>.</p>
<h4>
  <a name="996275"> </a>Comments 
</h4>

<p><a name="1021317"> </a>This system call temporarily halts the execution of the calling thread and makes it enter the time elapse wait state (this is one type of WAIT state).  The thread halts execution for the amount of time defined by <code class="par">timeout</code>.  If <code class="par">timeout</code> is 0 or if <code class="par">flags</code> is <code>P_POLL</code>, the function does a yield, moving the invoking thread to the end of the priority level in the ready queue.</p>

<p><a name="1019674"> </a>The time count continues even if the calling thread later enters the SUSPEND state (placing it in the WAIT-SUSPEND state).</p>

<p><a name="1019680"> </a>This function returns after the calling thread has been delayed by the specified amount of time.</p>
<h4>
  <a name="1021888"> </a>See Also 
</h4>

<p><a name="996304"> </a><a href="SysThread.html#995739"><code>SysThreadChangePriority()</code></a>, <a href="SysThread.html#996539"><code>SysThreadGroupWait()</code></a>, <a href="SysThread.html#997042"><code>SysThreadSuspend()</code></a></p>

<h3 class="hbH3">
  <a name="996328"> </a>SysThreadExit Function <a href="#992934"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="996357"> </a>Purpose 
</h4>

<p><a name="1010808"> </a>Causes the issuing thread to exit. </p>
<h4>
  <a name="996362"> </a>Declared In 
</h4>
<code>SysThread.h<a name="996365"> </a></code><h4>
  <a name="996367"> </a>Prototype 
</h4>
<pre class="proto"><a name="996370"></a>void SysThreadExit (
   void
)
</pre>
<h4>
  <a name="996372"> </a>Parameters 
</h4>

<p><a name="996375"> </a>None.</p>
<h4>
  <a name="996377"> </a>Returns 
</h4>

<p><a name="996380"> </a>Nothing.</p>
<h4>
  <a name="996382"> </a>Comments 
</h4>

<p><a name="1010922"> </a>A thread can exit either by calling this function or by returning from its initial entry function (specified by the <code class="par">func</code> parameter when creating the thread with <a href="SysThread.html#995791"><code>SysThreadCreate()</code></a>).</p>

<p><a name="1017904"> </a>This function changes the state of the specified thread to the DORMANT state. Because the thread still exists and is in the DORMANT state, it can again be started (at which point the initial entry function is executed, just as it was when the thread was originally started) by calling <a href="SysThread.html#996736"><code>SysThreadStart()</code></a>.   </p>

<p><a name="1017744"> </a>When a thread calls this function to exit, that thread does not automatically release all of the resources (stack, memory blocks, semaphores, thread-specific data slots, and so on) which it had obtained prior to the function call. Your code is responsible for releasing all resources beforehand or, as in the case of the stack, after this function returns.</p>

<p><a name="1010929"> </a>Note that if an error is detected during the execution of this function, the error is not returned to the thread which called this function.</p>
<h4>
  <a name="1012282"> </a>See Also 
</h4>

<p><a name="1012333"> </a><a href="SysThread.html#997042"><code>SysThreadSuspend()</code></a></p>

<h3 class="hbH3">
  <a name="996392"> </a>SysThreadGroupCreate Function <a href="#992934"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="996397"> </a>Purpose 
</h4>

<p><a name="996400"> </a>Create a new thread group.</p>
<h4>
  <a name="996402"> </a>Declared In 
</h4>
<code>SysThread.h<a name="996405"> </a></code><h4>
  <a name="996407"> </a>Prototype 
</h4>
<pre class="proto"><a name="996410"></a>SysThreadGroupHandle SysThreadGroupCreate (
   void
)
</pre>
<h4>
  <a name="996412"> </a>Parameters 
</h4>

<p><a name="996415"> </a>None.</p>
<h4>
  <a name="996417"> </a>Returns 
</h4>

<p><a name="996420"> </a>Returns a handle to the new thread group, or <code>sysThreadNoGroup</code> if the a new thread group couldn't be created.</p>
<h4>
  <a name="996422"> </a>Comments 
</h4>

<p><a name="1024507"> </a>Thread groups are a convenience provided by the operating system that allows you to wait for one or more threads to exit.  Thread groups are useful for unloading libraries that have spawned their own threads. Note that destroying a thread group implicitly waits for all threads in that group to exit.</p>

<p><a name="1024103"> </a>Threads must be added to a thread group at the time that they are created. Specify the thread group handle returned from <code>SysThreadGroupCreate()</code> to <a href="SysThread.html#995791"><code>SysThreadCreate()</code></a> in order to have the newly-created thread added to the thread group.</p>
<h4>
  <a name="996427"> </a>See Also 
</h4>

<p><a name="996430"> </a><a href="SysThread.html#995791"><code>SysThreadCreate()</code></a>, <a href="SysThread.html#996432"><code>SysThreadGroupDestroy()</code></a>, <a href="SysThread.html#996539"><code>SysThreadGroupWait()</code></a></p>

<h3 class="hbH3">
  <a name="996432"> </a>SysThreadGroupDestroy Function <a href="#992934"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="996437"> </a>Purpose 
</h4>

<p><a name="996440"> </a>Destroy a thread group.</p>
<h4>
  <a name="996442"> </a>Declared In 
</h4>
<code>SysThread.h<a name="996445"> </a></code><h4>
  <a name="996447"> </a>Prototype 
</h4>
<pre class="proto"><a name="996450"></a>status_t SysThreadGroupDestroy (
   SysThreadGroupHandle <code class="par">group</code>
)
</pre>
<h4>
  <a name="996452"> </a>Parameters 
</h4>

<dl>
<dt><a name="996455"> </a><code>&rarr;  <i>group</i></code></dt>
<dd><a name="996457"> </a>Handle to the thread group to be destroyed.</dd>

</dl>
<h4>
  <a name="996463"> </a>Returns 
</h4>

<p><a name="996513"> </a>Always returns <code>errNone</code>.</p>
<h4>
  <a name="996521"> </a>Comments 
</h4>

<p><a name="996532"> </a>This function waits until all of the group's threads have exited before destroying the thread group.</p>
<h4>
  <a name="996534"> </a>See Also 
</h4>

<p><a name="996537"> </a><a href="SysThread.html#995791"><code>SysThreadCreate()</code></a>, <a href="SysThread.html#996392"><code>SysThreadGroupCreate()</code></a>, <a href="SysThread.html#996539"><code>SysThreadGroupWait()</code></a></p>

<h3 class="hbH3">
  <a name="996539"> </a>SysThreadGroupWait Function <a href="#992934"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="996544"> </a>Purpose 
</h4>

<p><a name="996547"> </a>Wait until all of the threads in the specified thread group have exited.</p>
<h4>
  <a name="996549"> </a>Declared In 
</h4>
<code>SysThread.h<a name="996552"> </a></code><h4>
  <a name="996554"> </a>Prototype 
</h4>
<pre class="proto"><a name="996557"></a>status_t SysThreadGroupWait (
   SysThreadGroupHandle <code class="par">group</code>
)
</pre>
<h4>
  <a name="996559"> </a>Parameters 
</h4>

<dl>
<dt><a name="996562"> </a><code>&rarr;  <i>group</i></code></dt>
<dd><a name="996564"> </a>Handle to the thread group upon which to wait.</dd>

</dl>
<h4>
  <a name="996566"> </a>Returns 
</h4>

<p><a name="1023782"> </a>Always returns <code>errNone</code>.</p>
<h4>
  <a name="996576"> </a>See Also 
</h4>

<p><a name="996579"> </a><a href="SysThread.html#995791"><code>SysThreadCreate()</code></a>, <a href="SysThread.html#996392"><code>SysThreadGroupCreate()</code></a>, <a href="SysThread.html#996432"><code>SysThreadGroupDestroy()</code></a></p>

<h3 class="hbH3">
  <a name="996581"> </a>SysThreadInstallExitCallback Function <a href="#992934"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="996586"> </a>Purpose 
</h4>

<p><a name="996589"> </a>Installs a function that will be executed when the current thread exits.</p>
<h4>
  <a name="996591"> </a>Declared In 
</h4>
<code>SysThread.h<a name="996594"> </a></code><h4>
  <a name="996596"> </a>Prototype 
</h4>
<pre class="proto"><a name="996599"></a>status_t SysThreadInstallExitCallback (
   SysThreadExitCallbackFunc <code class="par">*iExitCallbackP</code>,
   void <code class="par">*iCallbackArg</code>,
   SysThreadExitCallbackID <code class="par">*oThreadExitCallbackId</code>
)
</pre>
<h4>
  <a name="996601"> </a>Parameters 
</h4>

<dl>
<dt><a name="996604"> </a><code>&rarr;  <i>iExitCallbackP</i></code></dt>
<dd><a name="996606"> </a>Pointer to the function to be executed when the thread exits. Your callback function should have the prototype defined by <a href="SysThread.html#997321"><code>SysThreadExitCallbackFunc()</code></a>.</dd>

<dt><a name="996608"> </a><code>&rarr;  <i>iCallbackArg</i></code></dt>
<dd><a name="996610"> </a>Pointer to the argument block needed by the exit callback function, or <code>NULL</code> if the callback requires no arguments.</dd>

<dt><a name="996612"> </a><code>&larr;  <i>oThreadExitCallbackId</i></code></dt>
<dd><a name="996614"> </a>Pointer to a location where the ID of the exit callback function is stored, or <code>NULL</code> if you don't need this ID. You use this value in the event that you need to remove the exit callback function with <a href="SysThread.html#996652"><code>SysThreadRemoveExitCallback()</code></a>.</dd>

</dl>
<h4>
  <a name="996620"> </a>Returns 
</h4>

<p><a name="996626"> </a>Returns <code>errNone</code> if the exit callback function was installed successfully, or <code>sysErrNoFreeRAM</code> if there wasn't enough memory to allocate the thread callback structure.</p>
<h4>
  <a name="996634"> </a>Comments 
</h4>

<p><a name="996645"> </a>A thread's exit callback functions are executed when the thread exits. You can install multiple exit callback functions for a given thread: when the thread exits, they are executed in the reverse order in which they were installed. That is, the last exit callback function installed will be the first executed.</p>

<p><a name="1022905"> </a>The exit callback functions are stored in a thread-specific data (TSD) slot for the current thread.</p>
<h4>
  <a name="996647"> </a>See Also 
</h4>

<p><a name="996650"> </a><a href="SysThread.html#996328"><code>SysThreadExit()</code></a>, <a href="SysThread.html#996652"><code>SysThreadRemoveExitCallback()</code></a></p>

<h3 class="hbH3">
  <a name="996652"> </a>SysThreadRemoveExitCallback Function <a href="#992934"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="996657"> </a>Purpose 
</h4>

<p><a name="996660"> </a>Removes a thread exit callback function originally installed with <a href="SysThread.html#996581"><code>SysThreadInstallExitCallback()</code></a>.</p>
<h4>
  <a name="996662"> </a>Declared In 
</h4>
<code>SysThread.h<a name="996665"> </a></code><h4>
  <a name="996667"> </a>Prototype 
</h4>
<pre class="proto"><a name="996670"></a>status_t SysThreadRemoveExitCallback (
   SysThreadExitCallbackID <code class="par">iThreadCallbackId</code>
)
</pre>
<h4>
  <a name="996672"> </a>Parameters 
</h4>

<dl>
<dt><a name="996675"> </a><code>&rarr;  <i>iThreadCallbackId</i></code></dt>
<dd><a name="996677"> </a>ID of the exit callback function returned from <a href="SysThread.html#996581"><code>SysThreadInstallExitCallback()</code></a>.</dd>

</dl>
<h4>
  <a name="996679"> </a>Returns 
</h4>

<p><a name="996682"> </a>Returns <code>errNone</code> if the specified exit callback function was successfully removed, or <code>sysErrParamErr</code> if the supplied callback ID doesn't reference an exit callback function in the current thread's TSD (thread-specific data).</p>
<h4>
  <a name="1023075"> </a>See Also 
</h4>

<p><a name="1023130"> </a><a href="SysThread.html#996328"><code>SysThreadExit()</code></a>, <a href="SysThread.html#996581"><code>SysThreadInstallExitCallback()</code></a></p>

<h3 class="hbH3">
  <a name="996694"> </a>SysThreadResume Function <a href="#992934"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="996699"> </a>Purpose 
</h4>

<p><a name="996702"> </a>Resumes execution of a suspended thread.</p>
<h4>
  <a name="996704"> </a>Declared In 
</h4>
<code>SysThread.h<a name="996707"> </a></code><h4>
  <a name="996709"> </a>Prototype 
</h4>
<pre class="proto"><a name="996712"></a>status_t SysThreadResume (
   SysHandle <code class="par">thread</code>
)
</pre>
<h4>
  <a name="996714"> </a>Parameters 
</h4>

<dl>
<dt><a name="996717"> </a><code>&rarr;  <i>thread</i></code></dt>
<dd><a name="996719"> </a>The ID of the thread that is to resume execution.</dd>

</dl>
<h4>
  <a name="996721"> </a>Returns 
</h4>

<p><a name="996724"> </a>Returns <code>errNone</code> if the operation completed successfully (but note that because <a href="SysThread.html#997042"><code>SysThreadSuspend()</code></a> can be called multiple times on a given thread, a return value of <code>errNone</code> from <code>SysThreadResume()</code> doesn't necessarily mean that the thread is now executing). If <code class="par">thread</code> doesn't reference a suspended thread, this function returns <code>kalErrObjectInvalid</code>.</p>
<h4>
  <a name="996726"> </a>Comments 
</h4>

<p><a name="1016292"> </a>This function releases the SUSPEND state of the specified thread.  Specifically, it causes the SUSPEND state to be released and the execution of the specifie prior call to <a href="SysThread.html#997042"><code>SysThreadSuspend()</code></a>.</p>

<p><a name="1015321"> </a>If the specified thread is in WAIT-SUSPEND state, a call to <code>SysThreadResume()</code> only releases the SUSPEND state; the thread will then be in the WAIT state.</p>

<p><a name="1015325"> </a>A thread cannot specify itself to this function. If a thread attempts to do so, <code>kalErrObjectInvalid</code> is returned.</p>

<p><a name="1015328"> </a><code>SysThreadResume()</code> only counters a single suspend request.  Accordingly, if <code>SysThreadSuspend()</code> has been called more than once for the thread, that thread will remain suspended even after <code>SysThreadResume()</code> returns.</p>

<p><a name="1015335"> </a>After resuming, the thread in the ready queue remains in the same position it was prior to suspension.</p>
<h4>
  <a name="996731"> </a>See Also 
</h4>

<p><a name="996734"> </a><a href="SysThread.html#996736"><code>SysThreadStart()</code></a>, <a href="SysThread.html#997042"><code>SysThreadSuspend()</code></a></p>

<h3 class="hbH3">
  <a name="996736"> </a>SysThreadStart Function <a href="#992934"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="996741"> </a>Purpose 
</h4>

<p><a name="996744"> </a>Start a thread created with <a href="SysThread.html#995791"><code>SysThreadCreate()</code></a>.</p>
<h4>
  <a name="996746"> </a>Declared In 
</h4>
<code>SysThread.h<a name="996763"> </a></code><h4>
  <a name="996783"> </a>Prototype 
</h4>
<pre class="proto"><a name="996820"></a>status_t SysThreadStart (
   SysHandle <code class="par">thread</code>
)
</pre>
<h4>
  <a name="996860"> </a>Parameters 
</h4>

<dl>
<dt><a name="996903"> </a><code>&rarr;  <i>thread</i></code></dt>
<dd><a name="996945"> </a>Handle to the thread to be started. This is the value returned through the <code class="par">outThread</code> parameter of <a href="SysThread.html#995791"><code>SysThreadCreate()</code></a>.</dd>

</dl>
<h4>
  <a name="996987"> </a>Returns 
</h4>

<p><a name="1017267"> </a>Returns <code>errNone</code> if the thread was started, or <code>kalErrObjectInvalid</code> if the specified thread is not in the DORMANT state.</p>
<h4>
  <a name="997032"> </a>Comments 
</h4>

<p><a name="1016316"> </a>This function changes the state of the specified thread from DORMANT to RUN/READY.</p>

<p><a name="1016318"> </a>The thread priority on starting the thread is that which was specified when the thread was created.  That priority may have been changed by any calls to <a href="SysThread.html#995739"><code>SysThreadChangePriority()</code></a> prior to this function call.</p>

<p><a name="1016330"> </a>If this function is called for a thread that is not in the DORMANT state, this function does nothing and returns <code>kalErrObjectInvalid</code>. If the thread is suspended, call <a href="SysThread.html#996694"><code>SysThreadResume()</code></a> instead.</p>
<h4>
  <a name="997037"> </a>See Also 
</h4>

<p><a name="1017270"> </a><a href="SysThread.html#995791"><code>SysThreadCreate()</code></a>, <a href="SysThread.html#996694"><code>SysThreadResume()</code></a></p>

<h3 class="hbH3">
  <a name="997042"> </a>SysThreadSuspend Function <a href="#992934"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="997047"> </a>Purpose 
</h4>

<p><a name="997050"> </a>Suspend execution of a thread.</p>
<h4>
  <a name="997052"> </a>Declared In 
</h4>
<code>SysThread.h<a name="997055"> </a></code><h4>
  <a name="997057"> </a>Prototype 
</h4>
<pre class="proto"><a name="997060"></a>status_t SysThreadSuspend (
   SysHandle <code class="par">thread</code>
)
</pre>
<h4>
  <a name="997062"> </a>Parameters 
</h4>

<dl>
<dt><a name="997065"> </a><code>&rarr;  <i>thread</i></code></dt>
<dd><a name="997067"> </a>The thread ID of the thread to suspend.</dd>

</dl>
<h4>
  <a name="997069"> </a>Returns 
</h4>

<p><a name="997072"> </a>Returns <code>errNone</code> if the thread was supended, or one of the following otherwise:</p>

<dl>
<dt><a name="1012560"> </a><code>kalErrObjectInvalid</code></dt>
<dd><a name="1012644"> </a>The specified thread is dormant, or the specified thread is the current thread.</dd>

<dt><a name="1012950"> </a><code>kalErrLimitReached</code></dt>
<dd><a name="1012951"> </a>This function has been called more than 255 times for the given thread.</dd>

</dl>
<h4>
  <a name="997074"> </a>Comments 
</h4>

<p><a name="997077"> </a>A thread cannot suspend itself by calling this function. </p>

<p><a name="1012453"> </a>The specified thread is placed into the SUSPEND state. To cause this thread to resume, call <a href="SysThread.html#996694"><code>SysThreadResume()</code></a>.</p>

<p><a name="1012744"> </a>If the thread specified is already in the WAIT state, it is put in the combined WAIT-SUSPEND state.  If wait conditions for the thread are later fulfilled, it will enter the SUSPEND state.  If you supply a thread that is in the combined WAIT-SUSPEND state to <code>SysThreadResume()</code>, the thread returns to the WAIT state. The upshot of all of this is that the WAIT and SUSPEND states are independent and either one prevents execution.</p>

<p><a name="1013738"> </a>If <a href="SysThread.html#997042"><code>SysThreadSuspend()</code></a> is called more than once for a given thread, that thread is put in multiple SUSPEND states. This is called suspend request nesting.  In this case, you must call <code>SysThreadResume()</code> the same number of times that <code>SysThreadSuspend()</code> was called in order to return the thread to its original state before the suspension. Note that the maximum number of times suspend requests may be nested is 255.</p>

<p><a name="1012767"> </a>A thread which is suspended in addition to waiting for resources (such as waiting for a semaphore) can be allocated resources (such as semaphore counts) based on the same conditions as threads which are not suspended. Even when suspended, the allocation of resources is not delayed in any way.  Conditions concerning resource allocation and release of the wait state remain unchanged.  In other words, the SUSPEND state is completely independent of other processing and thread states.</p>

<p><a name="1012777"> </a>If you need to delay the allocation of resources to a thread which is suspended, the use <a href="SysThread.html#995739"><code>SysThreadChangePriority()</code></a> in conjunction with <code>SysThreadSuspend() </code>and <code>SysThreadResume()</code>.</p>
<h4>
  <a name="997079"> </a>See Also 
</h4>

<p><a name="997082"> </a><a href="SysThread.html#996239"><code>SysThreadDelay()</code></a>, <a href="SysThread.html#996328"><code>SysThreadExit()</code></a>, <a href="SysThread.html#996694"><code>SysThreadResume()</code></a></p>

<h3 class="hbH3">
  <a name="997084"> </a>SysTSDAllocate Function <a href="#992934"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="997089"> </a>Purpose 
</h4>

<p><a name="997092"> </a>Allocates a new thread-specific data (TSD) slot.</p>
<h4>
  <a name="997094"> </a>Declared In 
</h4>
<code>SysThread.h<a name="997097"> </a></code><h4>
  <a name="997099"> </a>Prototype 
</h4>
<pre class="proto"><a name="997102"></a>status_t SysTSDAllocate (
   SysTSDSlotID <code class="par">*oTSDSlot</code>,
   SysTSDDestructorFunc <code class="par">*iDestructor</code>,
   uint32_t <code class="par">iName</code>
)
</pre>
<h4>
  <a name="997104"> </a>Parameters 
</h4>

<dl>
<dt><a name="997107"> </a><code>&larr;  <i>oTSDSlot</i></code></dt>
<dd><a name="997109"> </a>TSD slot identifier, set upon successful allocation of the slot.</dd>

<dt><a name="997111"> </a><code>&rarr;  <i>iDestructor</i></code></dt>
<dd><a name="997117"> </a>Pointer to a destructor function that is called to clean up any data associated with the slot when the thread exits. This function is optional; pass <code>NULL</code> if you don't want to use a destructor. The destructor function should have the prototype defined by <a href="SysThread.html#997566"><code>SysTSDDestructorFunc()</code></a>.</dd>

<dt><a name="997119"> </a><code>&rarr;  <i>iName</i></code></dt>
<dd><a name="997121"> </a>TSD slot name (note that this is a 32-bit value). Pass <span style="color: #000000;  font-family: Courier; font-style: normal; font-weight: normal; text-decoration: none; text-transform: none; vertical-align: baseline">sysTSDAnonymous</span> if you don't care about the slot name (see the Comments section, below, for more on why you might care about the TSD slot name).</dd>

</dl>
<h4>
  <a name="997123"> </a>Returns 
</h4>

<p><a name="997126"> </a>Returns <code>errNone</code> if the operation completed successfully, or <code>kalErrLimitReached</code> if the thread already has the maximum number of TSD slots allocated for it.</p>
<h4>
  <a name="997128"> </a>Comments 
</h4>

<p><a name="997131"> </a>Calling <code>SysTSDAllocate()</code> more than once with the same slot name simply updates the destructor function pointer; the same TSD slot identifer is returned each time. If you don't need to update the TSD slot's destructor function pointer, you can pass <code>sysTSDAnonymous</code> for the TSD slot name. This simply allocates the next available slot, sets its destructor pointer to the supplied value, and returns the slot's identifier.</p>
<h4>
  <a name="1026535"> </a>See Also 
</h4>

<p><a name="1026536"> </a><a href="SysThread.html#1026539"><code>SysTSDFree()</code></a>, <a href="SysThread.html#997180"><code>SysTSDGet()</code></a>, <a href="SysThread.html#997222"><code>SysTSDSet()</code></a></p>

<h3 class="hbH3">
  <a name="1026539"> </a>SysTSDFree Function <a href="#992934"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="997143"> </a>Purpose 
</h4>

<p><a name="997146"> </a>Deallocates a previously created thread-specific data (TSD) slot.</p>
<h4>
  <a name="997148"> </a>Declared In 
</h4>
<code>SysThread.h<a name="997151"> </a></code><h4>
  <a name="997153"> </a>Prototype 
</h4>
<pre class="proto"><a name="997156"></a>status_t SysTSDFree (
   SysTSDSlotID <code class="par">tsdslot</code>
)
</pre>
<h4>
  <a name="997158"> </a>Parameters 
</h4>

<dl>
<dt><a name="997161"> </a><code>&rarr;  <i>tsdslot</i></code></dt>
<dd><a name="1026626"> </a>TSD slot identifier obtained from <a href="SysThread.html#997084"><code>SysTSDAllocate()</code></a>.</dd>

</dl>
<h4>
  <a name="997165"> </a>Returns 
</h4>

<p><a name="997168"> </a>Returns <code>errNone</code> if the TSD slot was successfully freed, or <code>sysErrParamErr</code> if <code class="par">tsdslot</code> doesn't reference a valid slot.</p>
<h4>
  <a name="997170"> </a>Comments 
</h4>

<p><a name="997173"> </a>Applications should not normally make use of this function. A thread's TSD slots are deallocated automatically when the thread exits, so applications generally don't need to free the slots explicitly.</p>
<h4>
  <a name="997175"> </a>See Also 
</h4>

<p><a name="997178"> </a><a href="SysThread.html#996328"><code>SysThreadExit()</code></a>, <a href="SysThread.html#997084"><code>SysTSDAllocate()</code></a>, <a href="SysThread.html#997566"><code>SysTSDDestructorFunc()</code></a></p>

<h3 class="hbH3">
  <a name="997180"> </a>SysTSDGet Function <a href="#992934"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="997185"> </a>Purpose 
</h4>

<p><a name="997188"> </a>Get the contents of a specified thread-specific data (TSD) slot.</p>
<h4>
  <a name="997190"> </a>Declared In 
</h4>
<code>SysThread.h<a name="997193"> </a></code><h4>
  <a name="997195"> </a>Prototype 
</h4>
<pre class="proto"><a name="997198"></a>void *SysTSDGet (
   SysTSDSlotID <code class="par">tsdslot</code>
)
</pre>
<h4>
  <a name="997200"> </a>Parameters 
</h4>

<dl>
<dt><a name="997203"> </a><code>&rarr;  <i>tsdslot</i></code></dt>
<dd><a name="1026663"> </a>TSD slot identifier obtained from <a href="SysThread.html#997084"><code>SysTSDAllocate()</code></a>.</dd>

</dl>
<h4>
  <a name="997207"> </a>Returns 
</h4>

<p><a name="997210"> </a>Returns the slot contents, or 0 if <code class="par">tsdslot</code> doesn't reference a valid TSD slot.</p>
<h4>
  <a name="997217"> </a>See Also 
</h4>

<p><a name="997220"> </a><a href="SysThread.html#997084"><code>SysTSDAllocate()</code></a>, <a href="SysThread.html#997222"><code>SysTSDSet()</code></a></p>

<h3 class="hbH3">
  <a name="997222"> </a>SysTSDSet Function <a href="#992934"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="997231"> </a>Purpose 
</h4>

<p><a name="1026654"> </a>Set the contents of a specified thread-specific data (TSD) slot.</p>
<h4>
  <a name="997236"> </a>Declared In 
</h4>
<code>SysThread.h<a name="997239"> </a></code><h4>
  <a name="997241"> </a>Prototype 
</h4>
<pre class="proto"><a name="997244"></a>void SysTSDSet (
   SysTSDSlotID <code class="par">tsdslot</code>,
   void <code class="par">*iValue</code>
)
</pre>
<h4>
  <a name="997246"> </a>Parameters 
</h4>

<dl>
<dt><a name="997249"> </a><code>&rarr;  <i>tsdslot</i></code></dt>
<dd><a name="1026670"> </a>TSD slot identifier obtained from <a href="SysThread.html#997084"><code>SysTSDAllocate()</code></a>.</dd>

<dt><a name="997253"> </a><code>&rarr;  <i>iValue</i></code></dt>
<dd><a name="997255"> </a>A 32-bit value to be placed into the specified TSD slot.</dd>

</dl>
<h4>
  <a name="997257"> </a>Returns 
</h4>

<p><a name="997260"> </a>Nothing.</p>
<h4>
  <a name="997262"> </a>Comments 
</h4>

<p><a name="997265"> </a>This function does nothing if <code class="par">tsdslot</code> doesn't reference a valid TSD slot.</p>
<h4>
  <a name="997267"> </a>See Also 
</h4>

<p><a name="1026694"> </a><a href="SysThread.html#997084"><code>SysTSDAllocate()</code></a>, <a href="SysThread.html#997180"><code>SysTSDGet()</code></a></p>

<h2 class="haH2">
  <a name="997272"> </a>Application-Defined Functions <a href="#992934"><span class="nav">^TOP^</span></a>
</h2>


<h3 class="hbH3">
  <a name="997280"> </a>SysThreadEnterFunc Function <a href="#992934"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="997285"> </a>Purpose 
</h4>

<p><a name="1023249"> </a>Prototype of a thread entry function.</p>
<h4>
  <a name="997290"> </a>Declared In 
</h4>
<code>SysThread.h<a name="997293"> </a></code><h4>
  <a name="997295"> </a>Prototype 
</h4>
<pre class="proto"><a name="997298"></a>void (
   SysThreadEnterFunc
) (
   void <code class="par">*param</code>
)
</pre>
<h4>
  <a name="997300"> </a>Parameters 
</h4>

<dl>
<dt><a name="997303"> </a><code>&rarr;  <i>param</i></code></dt>
<dd><a name="1023280"> </a>The parameter pointer originally supplied to the <a href="SysThread.html#995791"><code>SysThreadCreate()</code></a> or <a href="SysThread.html#995881"><code>SysThreadCreateEZ()</code></a> function</dd>

</dl>
<h4>
  <a name="997306"> </a>Returns 
</h4>

<p><a name="997309"> </a>Nothing.</p>
<h4>
  <a name="997316"> </a>See Also 
</h4>

<p><a name="997319"> </a><a href="SysThread.html#997321"><code>SysThreadExitCallbackFunc()</code></a></p>

<h3 class="hbH3">
  <a name="997321"> </a>SysThreadExitCallbackFunc Function <a href="#992934"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="997326"> </a>Purpose 
</h4>

<p><a name="997329"> </a>Prototype of a thread exit callback function.</p>
<h4>
  <a name="997339"> </a>Declared In 
</h4>
<code>SysThread.h<a name="997360"> </a></code><h4>
  <a name="997384"> </a>Prototype 
</h4>
<pre class="proto"><a name="997411"></a>void (
   SysThreadExitCallbackFunc
) (
   void <code class="par">*param</code>
)
</pre>
<h4>
  <a name="997437"> </a>Parameters 
</h4>

<dl>
<dt><a name="997464"> </a><code>&rarr;  <i>param</i></code></dt>
<dd><a name="997489"> </a>The parameter pointer originally supplied to the <a href="SysThread.html#996581"><code>SysThreadInstallExitCallback()</code></a> function</dd>

</dl>
<h4>
  <a name="997527"> </a>Returns 
</h4>

<p><a name="997554"> </a>Nothing.</p>
<h4>
  <a name="997561"> </a>See Also 
</h4>

<p><a name="997564"> </a><a href="SysThread.html#997280"><code>SysThreadEnterFunc()</code></a></p>

<h3 class="hbH3">
  <a name="997566"> </a>SysTSDDestructorFunc Function <a href="#992934"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="997571"> </a>Purpose 
</h4>

<p><a name="997574"> </a>Prototype of a thread-specific data (TSD) slot destructor function.</p>
<h4>
  <a name="997576"> </a>Declared In 
</h4>
<code>SysThread.h<a name="997579"> </a></code><h4>
  <a name="997581"> </a>Prototype 
</h4>
<pre class="proto"><a name="997584"></a>void (
   SysTSDDestructorFunc
) (
   void <code class="par">*param</code>
)
</pre>
<h4>
  <a name="997586"> </a>Parameters 
</h4>

<dl>
<dt><a name="997589"> </a><code>&rarr;  <i>param</i></code></dt>
<dd><a name="1026825"> </a>The contents of the TSD slot. This is the value supplied in the most recent call to <a href="SysThread.html#997222"><code>SysTSDSet()</code></a> for the slot.</dd>

</dl>
<h4>
  <a name="997592"> </a>Returns 
</h4>

<p><a name="997595"> </a>Nothing.</p>
<h4>
  <a name="1026847"> </a>Comments 
</h4>

<p><a name="1026848"> </a>The slot's destructor function&#8212;specified when the TSD slot was allocated with <a href="SysThread.html#997084"><code>SysTSDAllocate()</code></a>&#8212;is called to clean up any data associated with the slot when the thread exits. This function is only called for a slot if the slot contents are non-<code>NULL</code>. Slots are initialized to <code>NULL</code> when they are allocated, so if you never call <a href="SysThread.html#997222"><code>SysTSDSet()</code></a> for a slot, when the thread exits the slot destructor isn't called for that slot.</p>
<h4>
  <a name="997602"> </a>See Also 
</h4>

<p><a name="997605"> </a><a href="SysThread.html#997084"><code>SysTSDAllocate()</code></a></p>

<p><a name="992930"> </a></p>
&nbsp;<br>
</div>
<!--END CONTENT-->

</td>
<td width="5">&nbsp;&nbsp;</td>
</tr>

</table>

<!-- BEGIN FOOTER -->
<table width="100%" border="0" cellspacing="0" cellpadding="0">
<tr>
<td width="7" rowspan="2"><img name="index_x" src="images/shim.gif" width="7" height="33" border="0" alt=""></td>
<td align="left"><img name="dashes" src="images/dashes.gif" width="744" height="3" border="0" alt=""></td>
<td width="10" rowspan="2"><img name="index_x" src="images/shim.gif" width="10" height="33" border="0" alt=""></td>
</tr>
<tr>
<td align="center">
<p class="footer">
Copyright © 1996&#8211;2004, PalmSource, Inc. and its affiliates. All rights reserved.<br>
<a href="http://www.palmsource.com/contact/">Write Us</a> | <a href="http://www.palmos.com/dev/training/">Training</a> | <a href="http://www.palmos.com/dev/support/kb/">Knowledge Base</a> | <a href="SysMgt_Front.html" target="_blank">Legal</a></p>
<br>
<!--BEGIN BOOK NAVIGATION-->
<p class="nav">
<A href="http://www.palmos.com/dev/support/docs/">Documentation</a>&nbsp;&nbsp;|&nbsp;&nbsp;
<a href="SysMgt_TOC.html">Table of Contents</a>&nbsp;&nbsp;
             |&nbsp;&nbsp;<a href="SystemMgr.html">&lt;&nbsp;Previous</a>&nbsp;&nbsp;
             |&nbsp;&nbsp;<a href="SysUtils.html">Next&nbsp;&gt;</a>&nbsp;&nbsp;
             |&nbsp;&nbsp;<a href="SysMgt_IX.html">Index</a>
</p>
</td>
</tr>
</table>
<!-- END FOOTER -->

</body>
</html>