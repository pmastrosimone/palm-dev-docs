<html>
<head>
<title>(Protein) Object Exchange | High-Level Communications</title> 
<link href="psi_devpubs.css" rel="stylesheet" type="text/css">

<!-- BEGIN META DATA -->
<meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
<META NAME="PSITEMPLATE" CONTENT="1006-007 PalmSource_HTML_2003 20041101">
<META NAME="GENERATOR" CONTENT="Quadralay WebWorks AutoMap 2003 for FrameMaker 8.0.6.2138">
<META NAME="LASTUPDATED" CONTENT="11/22/04 11:11:20">
<!-- END META DATA -->
</head>

<body bgcolor="#ffffff" text="#000000" leftmargin="0" topmargin="0" marginwidth="0" marginheight="0">
<a name="994958"></a>

<!-- BEGIN TOPNAV -->
<table width="100%" border="0" cellspacing="0" cellpadding="0">
<tr>
<td><img src="images/shim.gif" width="7" height="75" border="0" alt=""></td>
<td align="left"><table border="0" cellpadding="0" cellspacing="0" width="744">
<tr>
<td><img name="index_r2_c1" src="images/shim.gif" width="25" height="75" border="0" alt=""></td>
<td valign="top"><table border="0" cellpadding="0" cellspacing="0" width="96">
<tr>
<td><img name="index_r2_c4" src="images/shim.gif" width="96" height="15" border="0" alt=""></td>
</tr>
<tr>
<td><a href="http://www.palmsource.com/"><img name="ps_logo" src="images/ps_logo.gif" width="96" height="54" border="0" alt=""></a></td>
</tr>

</table>
</td>

<td><table border="0" cellpadding="0" cellspacing="0" width="30">
<td><img name="index_x" src="images/shim.gif" width="30" height="75" border="0" alt=""></td>
</table></td>

<!--BEGIN MASTHEAD-->
<td><table border="0" cellpadding="0" cellspacing="0" width="96">
<tr>
<td><img name="index_x" src="images/shim.gif" width="615" height="5" border="0" alt=""></td>
</tr>
<tr>
<td>
<!--BEGIN BOOK NAVIGATION-->
<span class="nav">
<A href="http://www.palmos.com/dev/support/docs/">Documentation</a>&nbsp;&nbsp;|&nbsp;&nbsp;
<a href="HLC_TOC.html">Table of Contents</a>&nbsp;&nbsp;
             |&nbsp;&nbsp;<a href="HLC_ExgMgrPart.html">&lt;&nbsp;Previous</a>&nbsp;&nbsp;
             |&nbsp;&nbsp;<a href="HLC_ExgMgrRef.html">Next&nbsp;&gt;</a>&nbsp;&nbsp;
             |&nbsp;&nbsp;<a href="HLC_IX.html">Index</a>
</span>
<!--END BOOK NAVIGATION-->
</tr>
<tr>
<td>
<!--BEGIN PAGE TITLE-->
<h2 class="PageTitle">4 &nbsp;&nbsp;
Object Exchange</h2></td>
<!--END PAGE TITLE-->
</tr>
<tr>
<td>
<!--BEGIN BOOK TITLE-->
<p class="BookTitle">High-Level Communications</p>
<p class="SubTitle">Exploring Palm OS&#174; </p>
<!--END BOOK TITLE-->
</td>
</tr>
<tr>
<td><img name="index_x" src="images/shim.gif" width="615" height="5" border="0" alt=""></td>
</tr>
</table>
</td>
<!--END MASTHEAD-->
</tr>
</table>
<img name="dashes" src="images/dashes.gif" width="744" height="3" border="0" alt=""></td>
</tr>
</table>
<!-- END TOPNAV -->

<table width="100%" border="0" cellspacing="0" cellpadding="0">
<tr>
<td valign="top" width="5"><img name="index_x" src="images/shim.gif" width="5" height="33" border="0" alt=""></td>

<!--BEGIN SIDETOC-->
<td valign="top" width="175">
<div id="sidetoc" valign="bottom">
<h1 class="SideTOC1-PartTab"><a href="HLC_ExgMgrPart.html">Part II: Exchange Manager</a> </h1>
<h1 class="SideTOC1"><a href="HLC_ExgMgrConcept.html">4  Object Exchange</a></h1>

   <h2 class="SideTOC2"><a href="#995014">
   About the Exchange Manager </a></h2>

      <h3 class="SideTOC3"><a href="#995025">
      Exchange Libraries</a></h3>

      <h3 class="SideTOC3"><a href="#995084">
      Typed Data Objects</a></h3>

   <h2 class="SideTOC2"><a href="#1013421">
   Initializing the Exchange Socket Structure</a></h2>

      <h3 class="SideTOC3"><a href="#995168">
      Identifying the Exchange Library</a></h3>

      <h3 class="SideTOC3"><a href="#995242">
      Identifying the Type of Data </a></h3>

   <h2 class="SideTOC2"><a href="#995259">
   Registering for Data</a></h2>

      <h3 class="SideTOC3"><a href="#995288">
      General Registration Guidelines</a></h3>

      <h3 class="SideTOC3"><a href="#995317">
      Setting the Default Application</a></h3>

      <h3 class="SideTOC3"><a href="#995445">
      Registering to Receive Unwrapped Data</a></h3>

   <h2 class="SideTOC2"><a href="#995470">
   Sending Data</a></h2>

      <h3 class="SideTOC3"><a href="#995485">
      Sending a Single Object</a></h3>

      <h3 class="SideTOC3"><a href="#995548">
      Sending Multiple Objects</a></h3>

      <h3 class="SideTOC3"><a href="#995605">
      Implementing the Send Command </a></h3>

   <h2 class="SideTOC2"><a href="#995618">
   Receiving Data</a></h2>

      <h3 class="SideTOC3"><a href="#995654">
      Controlling the Exchange Dialog</a></h3>

      <h3 class="SideTOC3"><a href="#1014039">
      Getting the Object Description</a></h3>

      <h3 class="SideTOC3"><a href="#995765">
      Receiving the Data</a></h3>

   <h2 class="SideTOC2"><a href="#995872">
   Sending and Receiving Databases</a></h2>

      <h3 class="SideTOC3"><a href="#995877">
      Sending a Database</a></h3>

      <h3 class="SideTOC3"><a href="#995959">
      Receiving a Database</a></h3>

   <h2 class="SideTOC2"><a href="#995989">
   Requesting Data</a></h2>

      <h3 class="SideTOC3"><a href="#996017">
      Sending a Get Request for a Single Object</a></h3>

      <h3 class="SideTOC3"><a href="#1013545">
      Responding to a Get Request </a></h3>

      <h3 class="SideTOC3"><a href="#996068">
      Two-Way Communications</a></h3>

      <h3 class="SideTOC3"><a href="#1010214">
      Getting the Sender's URL</a></h3>

      <h3 class="SideTOC3"><a href="#996088">
      Requesting a URL </a></h3>

   <h2 class="SideTOC2"><a href="#996108">
   Sending and Receiving Locally</a></h2>

   <h2 class="SideTOC2"><a href="#996174">
   Interacting with the Launcher</a></h2>

   <h2 class="SideTOC2"><a href="#1007009">
   HotSync Exchange</a></h2>

      <h3 class="SideTOC3"><a href="#1007177">
      Sending Files with HotSync Exchange</a></h3>

      <h3 class="SideTOC3"><a href="#1007358">
      Example</a></h3>

   <h2 class="SideTOC2"><a href="#1003329">
   Attachment Support Guidelines</a></h2>

      <h3 class="SideTOC3"><a href="#1014475">
      Viewing Attachments</a></h3>

      <h3 class="SideTOC3"><a href="#1003821">
      Sending an Attachment from a Messaging Application</a></h3>

      <h3 class="SideTOC3"><a href="#1005530">
      Sending an Attachment from a Display Application</a></h3>

      <h3 class="SideTOC3"><a href="#1005608">
      Email Application Guidelines</a></h3>

   <h2 class="SideTOC2"><a href="#996189">
   Summary of Exchange Manager</a></h2>

</div>
</td>

<td width="5">&nbsp;&nbsp;</td>
<td width="2" background="images/index_r8_c10.gif"><img src="images/shim.gif" width="2" height="75" border="0" alt=""></td>
<td width="5">&nbsp;&nbsp;</td>

<!--END SIDETOC-->

<td valign="top">

<!--BEGIN CONTENT-->
<div id="content" valign="bottom">
<p><a name="999059"> </a>The simplest form of communication for a Palm OS<sup>&#174;</sup> application to implement is the sending and receiving of typed data objects, such as MIME data, databases, or database records. </p>

<p><a name="994970"> </a>You use the Exchange Manager to send and receive typed data objects. The Exchange Manager interface is independent of the transport mechanism. You can use Bluetooth, email, IR, SMS, or any other protocol that has an Exchange Manager plug-in called an <b>exchange library</b>. </p>

<p><a name="994974"> </a>This chapter describes how applications use the Exchange Manager to send and receive typed data objects. It covers the following topics: </p>
<ul type="disc">
  <li><a name="994978"> </a><a href="HLC_ExgMgrConcept.html#995014">About the Exchange Manager</a>
  <li><a name="994982"> </a><a href="HLC_ExgMgrConcept.html#1013421">Initializing the Exchange Socket Structure</a>
  <li><a name="994986"> </a><a href="HLC_ExgMgrConcept.html#995259">Registering for Data</a>
  <li><a name="994990"> </a><a href="HLC_ExgMgrConcept.html#995445">Registering to Receive Unwrapped Data</a>
  <li><a name="994994"> </a><a href="HLC_ExgMgrConcept.html#995618">Receiving Data</a>
  <li><a name="994998"> </a><a href="HLC_ExgMgrConcept.html#995872">Sending and Receiving Databases</a>
  <li><a name="995002"> </a><a href="HLC_ExgMgrConcept.html#995989">Requesting Data</a>
  <li><a name="995006"> </a><a href="HLC_ExgMgrConcept.html#996108">Sending and Receiving Locally</a>
  <li><a name="995010"> </a><a href="HLC_ExgMgrConcept.html#996174">Interacting with the Launcher</a>
  <li><a name="1007064"> </a><a href="HLC_ExgMgrConcept.html#1007009">HotSync Exchange</a>
  <li><a name="1005049"> </a><a href="HLC_ExgMgrConcept.html#1003329">Attachment Support Guidelines</a>
  <li><a name="1005073"> </a><a href="HLC_ExgMgrConcept.html#996189">Summary of Exchange Manager</a>
</ul>

<h2 class="haH2">
  <a name="995014"> </a>About the Exchange Manager  <a href="#994958"><span class="nav">^TOP^</span></a>
</h2>


<p><a name="995015"> </a>This section explains concepts you need to know before you can begin using the Exchange Manager. It discusses the following topics: </p>
<ul type="disc">
  <li><a name="995019"> </a><a href="HLC_ExgMgrConcept.html#995025">Exchange Libraries</a>
  <li><a name="995023"> </a><a href="HLC_ExgMgrConcept.html#995084">Typed Data Objects</a>
</ul>
<h3 class="hbH3">
  <a name="995025"> </a>Exchange Libraries <a href="#994958"><span class="nav">^TOP^</span></a>
</h3>


<p><a name="995026"> </a>The Exchange Manager works in conjunction with an exchange library. Each <b>exchange library</b> is transport-dependent and performs the actual communication with the remote device. When an application makes an Exchange Manager call, the Exchange Manager forwards the request to the appropriate exchange library. The Exchange Manager's main duty is to maintain a registry of which libraries implement each protocol and which applications receive each type of data. See <a href="HLC_ExgMgrConcept.html#995032">Figure 4.1</a>.</p>

<p class="FFigureCaption">
  <a name="995032"> </a><b>Figure 4.1&nbsp;&nbsp;Object exchange using Exchange Manager</b>
</p>
<div align="left"><img src="images/ExchangeMgr.jpg" height="220" width="624" border="0" hspace="0" vspace="0">
</div>

<p><a name="995040"> </a>The list of available exchange libraries depends on the particular device hardware and on what other software the user has installed. Some typically available libraries include: IR Library (IrDA), Local Exchange Library, SMS (Short Messaging System) Library, Bluetooth Library, and HotSync<sup>&#174;</sup> Exchange Library.</p>



<p><a name="995081"> </a>As other exchange libraries become available, users can install them on their Palm Powered<sup>&#8482;</sup> handhelds and use the communications functionality they provide.</p>
<h3 class="hbH3">
  <a name="995084"> </a>Typed Data Objects <a href="#994958"><span class="nav">^TOP^</span></a>
</h3>


<p><a name="995085"> </a>The Exchange Manager sends and receives typed data objects. A <b>typed data object</b> (or <b>object</b>) is a stream of bytes plus some information about its contents. The content information includes any of: a creator ID, a MIME data type, or a filename. </p>

<p><a name="995088"> </a>The object itself can be in any format, but it's best to use a standardized data format rather than a proprietary one if you have a choice. <a href="HLC_ExgMgrConcept.html#995098">Table 4.1</a> lists the standardized data formats that the built-in Palm OS applications can receive.</p>

<p class="caption"><a name="995098"> </a><b>Table 4.1&nbsp;&nbsp;Built-in applications and standard data types </b></p>
<div class="tablediv"><table cellspacing="0" class="tTable">

  <tr valign="top">
    <th><p class="tt"><a name="995102"> </a><b>Application</b></p>
    </th>
    <th><p class="tt"><a name="995104"> </a><b>Data Type</b></p>
    </th>
  </tr>
  <tr valign="top">
    <td><p class="tt"><a name="995106"> </a>Address Book</p>
    </td>
    <td><p class="tt"><a name="995109"> </a>vCards (vcf file extension, text/x-vCard MIME type). Palm OS supports vCard version 2.1 and most features of version 3.0 (except for the '\' 'n' sequence in properties).</p>
    </td>
  </tr>
  <tr valign="top">
    <td><p class="tt"><a name="995111"> </a>Datebook</p>
    </td>
    <td><p class="tt"><a name="995114"> </a>vCalendars (vcs file extension, text/x-vCalendar MIME type). Palm OS supports vCalendar version 1.0.</p>
    </td>
  </tr>
  <tr valign="top">
    <td><p class="tt"><a name="995116"> </a>Launcher</p>
    </td>
    <td><p class="tt"><a name="995118"> </a>Palm OS databases (prc, pdb, oprc, and pqa file extensions, application/x-pilot and application/vnd.palm MIME types)</p>
    </td>
  </tr>
  <tr valign="top">
    <td><p class="tt"><a name="995120"> </a>Memo</p>
    </td>
    <td><p class="tt"><a name="995122"> </a>Plain text (txt file extension, text/plain MIME type)</p>
    </td>
  </tr>
  <tr valign="top">
    <td><p class="tt"><a name="995124"> </a>ToDo</p>
    </td>
    <td><p class="tt"><a name="995126"> </a>Not explicitly registered, but receives vCalendar objects from Datebook as appropriate </p>
    </td>
  </tr>
</table>

</div>


<div><hr>
  <a name="1013346"> </a> <b>NOTE: </b> The MIME type application/vnd.palm has been registered with the IANA and is preferred over the application/x-pilot MIME type.
<hr>
</div>

<p><a name="995128"> </a>More information on the vCard and vCalendar formats is available at <a href="http://www.imc.org/pdi/">http://www.imc.org/pdi/</a>. For text, the basic MIME text format is described in RFC 822 (<a href="http://www.ietf.org/rfc/rfc822.txt">http://www.ietf.org/rfc/rfc822.txt</a>). Palm OS builds on that with support for the quoted printable format (for international character sets) in RFC 2045 (<a href="http://www.ietf.org/rfc/rfc2045.txt">http://www.ietf.org/rfc/rfc2045.txt</a>) and multipart MIME (for categories) in RFC 2046 (<a href="http://www.ietf.org/rfc/rfc2046.txt">http://www.ietf.org/rfc/rfc2046.txt</a>). Palm OS doesn't implement everything in these RFCs, but it does generate and read content that is compliant with these standards.</p>

<p><a name="995129"> </a>If you want your application to receive objects, you must first register with the Exchange Manager for the type of data you want to receive. See <a href="HLC_ExgMgrConcept.html#995259">"Registering for Data"</a> for instructions on how to do so. You can override the built-in applications by registering for any data type listed in <a href="HLC_ExgMgrConcept.html#995098">Table 4.1</a> and becoming the default application for that type (but only with the user's permission). See <a href="HLC_ExgMgrConcept.html#995317">"Setting the Default Application"</a> for more information. </p>

<p><a name="1013416"> </a>If you only want to send data, you do not have to register. Your application can send data of the types listed in <a href="HLC_ExgMgrConcept.html#995098">Table 4.1</a>, and the Exchange Manager ensures that the appropriate application receives it. </p>

<h2 class="haH2">
  <a name="1013421"> </a>Initializing the Exchange Socket Structure <a href="#994958"><span class="nav">^TOP^</span></a>
</h2>


<p><a name="995145"> </a>The Exchange Manager, exchange library, and application use an exchange socket structure (<a href="HLC_ExgMgrRef.html#1268710"><code>ExgSocketType</code></a>) to communicate with each other. This structure is passed from the application to the Exchange Manager to the exchange library and vice versa. (The use of the term "socket" in the Exchange Manager API is not related to the term "socket" as used in sockets communication programming.) When your application sends data, you must create this structure and initialize it with the appropriate information. When you receive data, this structure provides information about the connection and the incoming data. </p>

<p><a name="995150"> </a>The <code>ExgSocketType</code> structure you use must identify two important pieces of information: </p>
<ul type="disc">
  <li><a name="995151"> </a>the exchange library that should do the sending (see <a href="HLC_ExgMgrConcept.html#995168">"Identifying the Exchange Library"</a>) 
  <li><a name="995157"> </a>the type of data being sent (see <a href="HLC_ExgMgrConcept.html#995242">"Identifying the Type of Data"</a>) 
</ul>

<p><a name="995159"> </a>The socket structure defines other fields that you may use to provide other information if you want. See the description of the <a href="HLC_ExgMgrRef.html#1268710"><code>ExgSocketType</code></a> structure for complete details. </p>

<div><hr>
  <a name="995166"> </a> <b>IMPORTANT: </b> When initializing the <code>ExgSocketType</code> structure, set all unused fields to 0. 
<hr>
</div>
<h3 class="hbH3">
  <a name="995168"> </a>Identifying the Exchange Library <a href="#994958"><span class="nav">^TOP^</span></a>
</h3>


<p><a name="1002477"> </a>The <a href="HLC_ExgMgrRef.html#1268710"><code>ExgSocketType</code></a> structure identifies the library to be used via a Uniform Resource Locator (URL) in the <code>name</code> field.</p>

<p><a name="1002479"> </a>When your application sends data, it should always identify which exchange library to use. (If you do not specify an exchange library, the IR Library is used to maintain backward compatibility.)</p>

<p><a name="995179"> </a>The URL scheme<b> </b>specifies which exchange library to use. The <b>scheme</b> is the part of the URL that appears before the colon (:). For example, the scheme in the following URL is "http" </p>
<pre class="sl">http://www.palmos.com </pre>

<p><a name="995182"> </a>When you pass the preceding URL to a web browser, the scheme tells the browser to connect to the server using the HTTP protocol. Similarly, when you pass the Exchange Manager a URL, the scheme tells the Exchange Manager which exchange library to use. For example, the following URL tells the Exchange Manager to connect to a remote Palm Powered device using the IR Library: </p>
<pre class="sl">_beam:BusinessCard.vcf</pre>

<p><a name="1012503"> </a>Multiple exchange libraries can register for the same scheme.</p>

<p><a name="1011724"> </a>On Palm OS, a URL has the following format (in BNF notation): </p>
<pre class="sl">[?][<code class="par">scheme</code>{;<code class="par">scheme</code>}:]<code class="par">filename</code></pre>

<p><a name="995186"> </a>where: </p>

<dl>
<dt><a name="995187"> </a><code><code>?</code></code></dt>
<dd><a name="996943"> </a>If more than one exchange library is registered for the provided schemes, the Exchange Manager has the user select the exchange library by displaying the Send With dialog. </dd>

<dt><a name="995188"> </a><code><code class="par">scheme</code>{;<code class="par">scheme</code>}</code></dt>
<dd><a name="996947"> </a>The URL schemes that identify which exchange library should be used. If more than one exchange library is registered for the scheme, the default exchange library is selected unless the URL begins with a question mark. </dd>

<dd><a name="995189"> </a>As shown, multiple schemes may be provided, separated by semicolons. Multiple schemes are only supported in conjunction with the question mark. For example, the string "?_send;_beam:" has the Exchange Manager display a Send With dialog that lists all exchange libraries that support either the _send scheme or the _beam scheme. </dd>

<dt><a name="995190"> </a><code><i>filename</i></code></dt>
<dd><a name="997018"> </a>The name of the file to send. Typically, this file also has an extension that is used, if necessary, to determine which application should receive the data. See <a href="HLC_ExgMgrConcept.html#995242">"Identifying the Type of Data"</a> for more information about the file extension. </dd>

</dl>

<p><a name="995194"> </a>Palm OS URL schemes all begin with the underscore (_) character. Standard schemes, such as mailto, are supported without the underscore.</p>

<p><a name="1009993"> </a>Palm OS defines some URL prefixes that any application can use to connect with the installed exchange libraries. A URL prefix is everything up to and including the colon character. <a href="HLC_ExgMgrConcept.html#995204">Table 4.2</a> describes the prefix constants. Note that you generally only need to use <code>exgBeamPrefix</code> or <code>exgSendPrefix</code> unless a specific transport is required.</p>

<p class="caption"><a name="995204"> </a><b>Table 4.2&nbsp;&nbsp;Exchange Library URL Prefixes </b></p>
<div class="tablediv"><table cellspacing="0" class="tTable">

  <tr valign="top">
    <th><p class="tt"><a name="995208"> </a><b>Exchange Library</b></p>
    </th>
    <th><p class="tt"><a name="995210"> </a><b>URL Prefix</b></p>
    </th>
  </tr>
  <tr valign="top">
    <td><p class="tt"><a name="995212"> </a>IR Library</p>
    </td>
    <td><p class="tt"><a name="995215"> </a><code>exgBeamPrefix</code></p>
    </td>
  </tr>
  <tr valign="top">
    <td><p class="tt"><a name="995217"> </a>Local Exchange Library </p>
    </td>
    <td><p class="tt"><a name="995220"> </a><code>exgLocalPrefix</code> </p>
    </td>
  </tr>
  <tr valign="top">
    <td><p class="tt"><a name="995222"> </a>SMS Library </p>
    </td>
    <td><p class="tt"><a name="995225"> </a><code>kSmsScheme</code>:</p>
    </td>
  </tr>
  <tr valign="top">
    <td><p class="tt"><a name="1002604"> </a>Bluetooth Library</p>
    </td>
    <td><p class="tt"><a name="1002606"> </a><code>_btobex:</code></p>
    </td>
  </tr>
  <tr valign="top">
    <td><p class="tt"><a name="1002336"> </a>Mobile Mail Exchange Library </p>
    </td>
    <td><p class="tt"><a name="1002339"> </a><code>exgMobileMailPrefix</code> </p>
<p class="tt"><a name="1010012"> </a>and <code>exgMailtoScheme:</code></p>
    </td>
  </tr>
  <tr valign="top">
    <td><p class="tt"><a name="1001859"> </a>HotSync Exchange Library </p>
    </td>
    <td><p class="tt"><a name="1001862"> </a><code>exgDesktopPrefix</code> </p>
    </td>
  </tr>
  <tr valign="top">
    <td><p class="tt"><a name="995227"> </a>Any library that supports the _send scheme (user's choice)</p>
    </td>
    <td><p class="tt"><a name="995230"> </a><code>exgSendPrefix</code> </p>
    </td>
  </tr>
  <tr valign="top">
    <td><p class="tt"><a name="995232"> </a>Any library that supports the _send or _beam scheme (user's choice)</p>
    </td>
    <td><p class="tt"><a name="995235"> </a><code>exgSendBeamPrefix</code> </p>
    </td>
  </tr>
  <tr valign="top">
    <td><p class="tt"><a name="1002562"> </a>Any library that supports the _get scheme (user's choice)</p>
    </td>
    <td><p class="tt"><a name="1002565"> </a><code>exgGetPrefix</code></p>
    </td>
  </tr>
</table>

</div>


<p><a name="995240"> </a>The section <a href="HLC_ExgMgrConcept.html#995605">"Implementing the Send Command"</a> provides more information on using <code>exgSendPrefix</code> or <code>exgSendBeamPrefix</code>.</p>

<p><a name="1007122"> </a>The section <a href="HLC_ExgMgrConcept.html#1007009">"HotSync Exchange"</a> provides more information on using <code>exgDesktopPrefix</code>.</p>

<p><a name="1007097"> </a>The section <a href="HLC_ExgMgrConcept.html#1003329">"Attachment Support Guidelines"</a> provides more information on using <code>exgGetPrefix</code>.</p>

<p><a name="1011263"> </a>For more information on the SMS exchange library, refer to <a href="../Telephony_and_SMS/TelSMS_SMSRef.html#608590">Chapter 5, "SMS Exchange Library Reference,"</a> in <i>Exploring Palm OS: Telephony and SMS</i>.</p>

<p><a name="1011270"> </a>For more information on the Bluetooth exchange library, refer to <a href="../Low-Level_Communications/LowLevelComms_BtExg.html#608590">Chapter 12, "Bluetooth Exchange Library Support,"</a> in <i>Exploring Palm OS: Low-Level Communications</i>.</p>
<h3 class="hbH3">
  <a name="995242"> </a>Identifying the Type of Data  <a href="#994958"><span class="nav">^TOP^</span></a>
</h3>


<p><a name="995243"> </a>When your application sends data, the exchange socket structure (<a href="HLC_ExgMgrRef.html#1268710"><code>ExgSocketType</code></a>) identifies the type of data being sent. It can do so with one of the following values: </p>
<ul type="disc">
  <li><a name="995247"> </a>A MIME type in the <code>type</code> field.
  <li><a name="995248"> </a>A file extension for the file in the <code>name</code> field. That is, you might supply <code>MyDB.pdb</code> as the value of the <code>name</code> field. The part after the last period (.) is the extension. 
</ul>

<p><a name="995249"> </a>In most cases, the data type determines which application receives the data on the remote side. (If the <code>target</code> field is specified, it determines which application receives the data instead of the data type as described below.) The Exchange Manager maintains a registry of applications and the types of data each application can receive. When the Exchange Manager receives an object, it checks the exchange socket for the data type. It checks the <code>type</code> field first, and if it is not defined or if no application is registered to receive that MIME type, it checks the <code>name</code> field for a file extension. This is discussed in more detail in the <a href="HLC_ExgMgrConcept.html#995259">"Registering for Data"</a> section. </p>

<p><a name="995253"> </a>Note that you may also directly specify which application should receive the data. To do so, place the creator ID in the <code>target</code> field. You do not have to specify a MIME type or file extension in this instance. If the <code>target</code> field is nonzero, the Exchange Manager checks to see if an application is registered for that creator ID and, if so, delivers the data directly to that application. </p>

<p><a name="1011774"> </a>If the target application does not exist, the Exchange Manager searches the registry as usual. Use the <code>target</code> field only if you know that you are communicating with a Palm Powered device and want to explicitly specify which application should receive the data. </p>

<p><a name="995254"> </a>An application can register for another application's creator ID and receive all objects targeted to that creator ID, but only with the user's permission. See <a href="HLC_ExgMgrConcept.html#995317">"Setting the Default Application"</a> for more details. </p>

<h2 class="haH2">
  <a name="995259"> </a>Registering for Data <a href="#994958"><span class="nav">^TOP^</span></a>
</h2>


<p><a name="995260"> </a>In most cases, applications that want to receive data from the Exchange Manager must register for the MIME type and/or file extension that they want to receive. </p>

<p><a name="995268"> </a>To do so, call <a href="HLC_ExgMgrRef.html#1270252"><code>ExgRegisterDatatype()</code></a> and pass it five parameters:</p>
<ul type="disc">
  <li><a name="999803"> </a>Your application's creator ID.
  <li><a name="999817"> </a>A constant that identifies the type of data you want to register to receive: <code>exgRegExtensionID</code> for file extensions, <code>exgRegTypeID</code> for MIME types, <code>exgRegCreatorID</code> for creator IDs (see <a href="HLC_ExgMgrConcept.html#995317">"Setting the Default Application"</a>), or <code>exgRegSchemeID</code> for URL schemes (see <a href="HLC_ExgMgrConcept.html#996088">"Requesting a URL"</a>). Alternatively, you can register for direct delivery of data (bypassing an email application) by specifying one of these constants: <code>exgRegDirectExtensionID</code>, <code>exgRegDirectCreatorID</code>, or <code>exgRegDirectTypeID</code>. Or, you can indicate that the application supports data viewing by specifying one of these constants: <code>exgRegViewExtensionID</code>, <code>exgRegViewCreatorID</code>, or <code>exgRegViewTypeID</code>.
  <li><a name="999818"> </a>A string that lists the MIME types or file extensions.
  <li><a name="995281"> </a>A string containing descriptions of the data you are registering to receive; these are displayed to preview the data in the exchange dialog under certain circumstances.
  <li><a name="1000057"> </a>A flag value of zero.
</ul>

<p><a name="995285"> </a>For example: </p>
<pre class="sl"><code>ExgRegisterDatatype</code>(beamerCreator,
  exgRegExtensionID, BitmapExt, "bitmap", 0);</pre>
<h3 class="hbH3">
  <a name="995288"> </a>General Registration Guidelines <a href="#994958"><span class="nav">^TOP^</span></a>
</h3>


<p><a name="995289"> </a>Follow these guidelines when registering for data: </p>
<ul type="disc">
  <li><a name="995290"> </a>Register as early as possible. 
   <p><a name="995291"> </a>To ensure that your application can receive data at any time after it is installed, call <a href="HLC_ExgMgrRef.html#1270252"><code>ExgRegisterDatatype()</code></a> in response to the <a href="../Programming_Basics/CmnLaunchCodes.html#993716"><code>sysAppLaunchCmdSyncNotify</code></a> and <a href="../Programming_Basics/CmnLaunchCodes.html#993896"><code>sysAppLaunchCmdSystemReset</code></a> launch codes. The <code>sysAppLaunchCmdSyncNotify</code> launch code is sent to your application upon its first installation and any time the HotSync<sup>&#174;</sup> operation modifies the application's database. The <span style="color: #000000;  font-family: Courier; font-style: normal; font-weight: normal; text-decoration: none; text-transform: none; vertical-align: baseline">sysAppLaunchCmdSystemReset</span> is sent to your application when the system is reset.</p>
  <li><a name="995303"> </a>It's best to use a standardized data format rather than a proprietary one if you have a choice. 
  <li><a name="1002635"> </a>Provide user-friendly descriptive information for the <code class="par">descriptionsP</code> parameter of <code>ExgRegisterDatatype()</code>. The descriptions are used in dialogs displayed by Exchange Manager to identify applications or libraries. Use information that describes the type of information handled, such as pictures, sounds, contact information, etc. Don't use MIME types or file extensions because they are not meaningful to the average user.
  <li><a name="995304"> </a>Multiple applications can register to receive the same data type, however, an application <b>must not</b> automatically register itself as the default application without prompting the user for permission. The section <a href="HLC_ExgMgrConcept.html#995317">"Setting the Default Application"</a> describes this further. An application might check when it is launched if it is still the default application (with <a href="HLC_ExgMgrRef.html#1269660"><code>ExgGetDefaultApplication()</code></a>). However, it must honor the user's choices for handling a particular data type by saving this information in its database and by providing a "Don't ask me again" option regarding changing the default.
  <li><a name="995308"> </a>When registering for file extensions, do not include the period (.) as part of the extension. Register for "TXT", for example, not ".TXT". 
  <li><a name="995309"> </a>Do <b>not</b> make multiple calls if you want to register for more than one MIME type or more than one file extension. 
   <p><a name="995310"> </a>Instead, make one call for all file extensions and one call for all MIME types. Pass a single string containing file extensions or MIME types separated by a tab (\t) character. For example, the following call registers the application for two file extensions, TXT and DOC: </p>
</ul>
<pre class="sl"><code>ExgRegisterDatatype(myCreator,
exgRegExtensionID,"TXT\tDOC", "plain text", 0);</code></pre>
<ul type="disc">
  <li><a name="1012491"> </a>Applications that want to serve as display applications for specific kinds of data should register to receive data in view mode by using one of the view mode constants: <code>exgRegViewExtensionID</code>, <code>exgRegViewCreatorID</code>, or <code>exgRegViewTypeID</code>. For more details on supporting view mode, see <a href="HLC_ExgMgrConcept.html#1014475">"Viewing Attachments."</a>
</ul>
<h3 class="hbH3">
  <a name="995317"> </a>Setting the Default Application <a href="#994958"><span class="nav">^TOP^</span></a>
</h3>


<p><a name="995318"> </a>Because multiple applications can register for the same data type, the Exchange Manager supports the concept of a default application that receives all objects of a particular data type. To set the default application, call the function <a href="HLC_ExgMgrRef.html#1270489"><code>ExgSetDefaultApplication()</code></a>. There is one default application per data type in the registry.</p>

<p><a name="995323"> </a>Suppose a device receives a vCard object, and it has three applications registered to receive vCards. The Exchange Manager checks the registry to see if any of these applications is assigned as the default. If so, the default application receives all vCards (unless the exchange socket structure's <code>target</code> field is set). If none of the three applications is the default, the Exchange Manager chooses one, and that application receives all vCards. </p>

<p><a name="1002782"> </a>Do <b>not</b> automatically register as the default application without the user's permission. It's imperative that you allow users to choose which application is the default. To do so, you could display a panel via a menu option that shows users the applications that can receive the same type of data as your application, show them which is the default, and allow them to select a different default. Use <a href="HLC_ExgMgrRef.html#1269717"><code>ExgGetRegisteredApplications()</code></a> to get a list of all applications registered to receive the same data type as yours, and use <a href="HLC_ExgMgrRef.html#1269660"><code>ExgGetDefaultApplication()</code></a> to retrieve the current default, if any. See <a href="HLC_ExgMgrConcept.html#995397">Listing 4.2</a> to see how an application performs this task for the <code>mailto</code> URL scheme. </p>
<p class="CCodeCaption">
  <a name="995337"> </a><b>Listing 4.1&nbsp;&nbsp;Initializing a List of Registered Applications</b>
</p>

<div class="CodeRule"><hr></div><pre class="CodeBlock">
void PrvSetMailAppsList(int32_t listSelection)<a name="995338"> </a>
{<a name="995339"> </a>
   ControlPtr ctl;<a name="995340"> </a>
   ListPtr lst;<a name="995341"> </a>
   uint32_t defaultID;<a name="995342"> </a>
 <a name="995343"> </a>
   ctl = GetObjectPtr(PrefDefaultMailTrigger);<a name="995344"> </a>
   lst = GetObjectPtr(PrefDefaultMailList);<a name="995345"> </a>
 <a name="995346"> </a>
   // crIDs, appCnt, appNames are all global variables. <a name="995347"> </a>
   // Get the list of creator IDs if we don't have it already. <a name="995348"> </a>
   if(!crIDs) {<a name="995349"> </a>
      ExgGetRegisteredApplications(&amp;crIDs, &amp;appCnt, &amp;appNames, NULL, <a name="995350"> </a>
         exgRegSchemeID, "mailto");<a name="995351"> </a>
      if(appCnt) {<a name="995352"> </a>
         MemHandle tmpH = SysFormPointerArrayToStrings(appNames, appCnt);<a name="995353"> </a>
         if(tmpH)<a name="995354"> </a>
            appNamesArray = MemHandleLock(tmpH);<a name="995355"> </a>
         else<a name="995356"> </a>
            return;<a name="995357"> </a>
      }<a name="995358"> </a>
      else<a name="995359"> </a>
         return;<a name="995360"> </a>
   }<a name="995361"> </a>
 <a name="995362"> </a>
   if(appNamesArray)<a name="995363"> </a>
      LstSetListChoices(lst, appNamesArray, appCnt);<a name="995364"> </a>
   LstSetHeight(lst, appCnt &lt; 6 ? appCnt : 6);<a name="995365"> </a>
 <a name="995366"> </a>
   if(listSelection == -1)<a name="995367"> </a>
   {<a name="995368"> </a>
      uint16_t i;<a name="995369"> </a>
      ExgGetDefaultApplication(&amp;defaultID, exgRegSchemeID, "mailto");<a name="995370"> </a>
 <a name="995371"> </a>
      for(i=0;i&lt;appCnt;i++) {<a name="995372"> </a>
         if(crIDs[i] == defaultID)<a name="995373"> </a>
            LstSetSelection(lst, i);<a name="995374"> </a>
      }<a name="995375"> </a>
   }<a name="995376"> </a>
   else<a name="995377"> </a>
      LstSetSelection(lst, listSelection);<a name="995378"> </a>
 <a name="995379"> </a>
   CtlSetLabel(ctl, appNamesArray[LstGetSelection(lst)]);<a name="995380"> </a>
}<a name="995381"> </a>
</pre><div class="CodeRule"><hr></div>


<p><a name="995382"> </a>To become the default application for a data type that a built-in Palm OS application is registered to receive (see <a href="HLC_ExgMgrConcept.html#995098">Table 4.1</a>), you must perform some extra steps to ensure that you can receive that type of object when it is beamed from a device running Palm OS 3.X. You must register for the built-in application's creator ID and become the default application for that creator ID. </p>

<p><a name="1000176"> </a>On Palm OS 3.X, the built-in applications always set their creator IDs in the <code>target</code> field when sending data, causing the data to always be sent to that application. On Palm OS 4.0 and higher, the built-in applications still register to receive the same type of data, but they do not set the <code>target</code> field when sending. This means that if your application is registered for the same data type and is the default application, it receives the data from devices running Palm OS 4.0 and higher as expected, but if the data is sent from a device running Palm OS 3.X, you still won't receive that data because it is specifically targeted for the built-in application. </p>

<p><a name="995388"> </a>To solve this problem, the <code>ExgRegisterDatatype()</code> function supports registering for another application's creator ID. <a href="HLC_ExgMgrConcept.html#995397">Listing 4.2</a> shows how an application that receives vCards might set the default application after allowing the user to select the default from a list, assuming the list is initialized with code similar to that in <a href="HLC_ExgMgrConcept.html#995337">Listing 4.1</a>.</p>

<p><a name="995395"> </a>Note that, as with all data types, your application won't receive the data targeted for the other application unless yours is the default application for that creator ID. </p>
<p class="CCodeCaption">
  <a name="995397"> </a><b>Listing 4.2&nbsp;&nbsp;Setting the default application for vCards</b>
</p>

<div class="CodeRule"><hr></div><pre class="CodeBlock">
uint32_t PilotMain (uint16_t cmd, void *cmdPBP, uint16_t launchFlags)<a name="995398"> </a>
{<a name="995399"> </a>
   ...<a name="995400"> </a>
   // Register for vCard MIME type, extension, and Address Book's creator ID. <a name="995401"> </a>
   // At this point, we are not the default application so we do not receive<a name="995402"> </a>
   // vCards. We still must register upon install so that our application <a name="995403"> </a>
   // appears in the preferences list when the user chooses the default <a name="995404"> </a>
   // application for vCards. <a name="995405"> </a>
   case sysAppLaunchCmdSyncNotify:<a name="995406"> </a>
   case sysAppLaunchCmdSystemReset:<a name="1001841"> </a>
      char addressCreatorStr[5];<a name="995407"> </a>
      <a name="995408"> </a>
      // Create a string from Address Book's creator ID. <a name="995409"> </a>
      <code>MemMove(addressCreatorStr, </code>sysFileCAddress<code>, 4);</code><a name="995410"> </a>
      <code>address</code>CreatorStr[4] = chrNull;<a name="995411"> </a>
 <a name="995412"> </a>
      ExgRegisterDatatype(crID, exgRegTypeID, "text/x-vCard", "vCard", 0);<a name="995413"> </a>
      ExgRegisterDatatype(crID, exgRegExtensionID, "vcf", "vCard", 0);<a name="995414"> </a>
      ExgRegisterDatatype(crID, exgRegCreatorID, addressCreatorStr, NULL, 0);<a name="995415"> </a>
      ...<a name="995416"> </a>
}<a name="995417"> </a>
 <a name="995418"> </a>
static void PrefApply (void)<a name="995419"> </a>
{<a name="995420"> </a>
   MemHandle h;<a name="995421"> </a>
   FieldType *fld;<a name="995422"> </a>
   ControlType *ctl;<a name="995423"> </a>
   uint16_t listItem;<a name="995424"> </a>
 <a name="995425"> </a>
   // Set the default vCard app<a name="995426"> </a>
vif(appCnt &amp;&amp; crIDs)<a name="995427"> </a>
   {<a name="995428"> </a>
      uint32_t crID;<a name="995429"> </a>
      char addressCreatorStr[5];<a name="995430"> </a>
      <a name="995431"> </a>
      // Create a string from Address Book's creator ID. <a name="995432"> </a>
      <code>MemMove(addressCreatorStr, </code>sysFileCAddress<code>, 4);</code><a name="995433"> </a>
      <code>address</code>CreatorStr[4] = chrNull;<a name="995434"> </a>
      <a name="995435"> </a>
      listItem = LstGetSelection(GetObjectPtr(PrefDefaultAppList));<a name="995436"> </a>
      crID = crIDs[listItem];<a name="995437"> </a>
      ExgSetDefaultApplication(crID, exgRegTypeID, "text/x-vCard");<a name="995438"> </a>
      ExgSetDefaultApplication(crID, exgRegExtensionID, "vcf");<a name="995439"> </a>
      ExgSetDefaultApplication(crID, exgRegCreatorID, <code>addressCreatorStr</code>);<a name="995440"> </a>
   }<a name="995441"> </a>
}<a name="995442"> </a>
</pre><div class="CodeRule"><hr></div>

<h3 class="hbH3">
  <a name="995445"> </a>Registering to Receive Unwrapped Data <a href="#994958"><span class="nav">^TOP^</span></a>
</h3>


<p><a name="995446"> </a>In rare circumstances, you can register to receive data that is sent enclosed in another object. </p>

<p><a name="995447"> </a>For example, suppose you have a stock quote application that wants to receive vStock objects. If the device is sent an email message that has the vStock object attached, your application may want to register to receive the vStock object directly rather than having the email application receive it. To do so, call <a href="HLC_ExgMgrRef.html#1270252"><code>ExgRegisterDatatype()</code></a> and pass one of the direct delivery constants (<code>exgRegDirectCreatorID</code>, <code>exgRegDirectExtensionID</code>, or <code>exgRegDirectTypeID</code>) as the second parameter. </p>

<p><a name="1011971"> </a>If you want to register to receive an object when it is sent as part of another object, you probably also want to receive it when it is sent by itself. This requires two calls to <code>ExgRegisterDatatype()</code>: one with one of the direct delivery constants, and one without. </p>

<div class="CodeRule"><hr></div><pre class="CodeBlock">
<code>ExgRegisterDatatype(myCreator, exgRegDirectExtensionID, "TXT\tDOC", </code><a name="1011996"> </a>
<code>  "plain text", 0);</code><a name="1013115"> </a>
<code>ExgRegisterDatatype(myCreator, exgRegExtensionID, "TXT\tDOC", "plain text", 0);</code><a name="1011997"> </a>
</pre><div class="CodeRule"><hr></div>


<p><a name="995460"> </a>Thus, you might make four calls to <code>ExgRegisterDatatype()</code>: </p>
<ul type="disc">
  <li><a name="995461"> </a>one call to register for the file extensions 
  <li><a name="995462"> </a>one call to register for file extensions that are sent as part of another object
  <li><a name="995463"> </a>one call to register for MIME types
  <li><a name="995464"> </a>one call to register for MIME types that are sent as part of another object
</ul>

<p><a name="995465"> </a>As mentioned previously, it's rare for an application to register to receive unwrapped data directly. It's more common for one application (such as an email application) to receive the entire compound object and then unwrap and disperse the enclosed objects using the Local Exchange Library. See <a href="HLC_ExgMgrConcept.html#996108">"Sending and Receiving Locally"</a> and <a href="HLC_ExgMgrConcept.html#1003329">"Attachment Support Guidelines"</a> for more information. </p>

<h2 class="haH2">
  <a name="995470"> </a>Sending Data <a href="#994958"><span class="nav">^TOP^</span></a>
</h2>


<p><a name="995471"> </a>This section describes how to send data using the Exchange Manager. It discusses the following topics: </p>
<ul type="disc">
  <li><a name="995475"> </a><a href="HLC_ExgMgrConcept.html#995485">Sending a Single Object</a>
  <li><a name="995479"> </a><a href="HLC_ExgMgrConcept.html#995548">Sending Multiple Objects</a>
  <li><a name="995483"> </a><a href="HLC_ExgMgrConcept.html#995605">Implementing the Send Command</a>
</ul>

<p><a name="1006839"> </a>For information about sending data as an attachment from a messaging application such as email or SMS, see <a href="HLC_ExgMgrConcept.html#1003329">"Attachment Support Guidelines."</a></p>
<h3 class="hbH3">
  <a name="995485"> </a>Sending a Single Object <a href="#994958"><span class="nav">^TOP^</span></a>
</h3>


<p><a name="995486"> </a>The most common use of the Exchange Manager is to send or receive a single object. To send an object, do the following: </p>
<ol type="1">
  <li value="1"><a name="995491"> </a>Create and initialize an <a href="HLC_ExgMgrRef.html#1268710"><code>ExgSocketType</code></a> data structure with information about which library to use and the data to be sent. See <a href="HLC_ExgMgrConcept.html#1013421">"Initializing the Exchange Socket Structure"</a> for more information. 
  <li value="2"><a name="995499"> </a>Call <a href="HLC_ExgMgrRef.html#1270113"><code>ExgPut()</code></a> to establish the connection with the exchange library. 
  <li value="3"><a name="995504"> </a>Call <a href="HLC_ExgMgrRef.html#1270444"><code>ExgSend()</code></a> one or more times to send the data. 
   <p><a name="995505"> </a>In this function, you specify the number of bytes to send. You may need to call it multiple times if you don't send all the data in the first call. </p>
  <li value="4"><a name="995510"> </a>Call <a href="HLC_ExgMgrRef.html#1269394"><code>ExgDisconnect()</code></a> to end the connection. 
   <p><a name="995511"> </a>A zero (0) return value indicates a successful transmission. However, this doesn't necessarily mean that the receiver kept the data. If the target application for an object doesn't exist on the receiving device, the data is discarded; or the user can decide to discard any received objects.</p>
</ol>

<p><a name="995512"> </a>Note that the <code>ExgSend()</code> function blocks until it returns. However, most libraries provide a user interface dialog that keeps the user informed of transmission progress and allows them to cancel the operation. </p>

<p><a name="995513"> </a>The Exchange Manager automatically displays error dialogs as well, if errors occur. You must check for error codes from Exchange Manager routines, but you don't need to display an error dialog if you get one because the Exchange Manager handles this for you.</p>

<p><a name="995517"> </a>For example, <a href="HLC_ExgMgrConcept.html#995519">Listing 4.3</a> shows how to send the current draw window from one Palm Powered handheld to another Palm Powered handheld. </p>
<p class="CCodeCaption">
  <a name="995519"> </a><b>Listing 4.3&nbsp;&nbsp;Sending data using Exchange Manager</b>
</p>

<div class="CodeRule"><hr></div><pre class="CodeBlock">
status_t SendData(void)<a name="995520"> </a>
{<a name="995521"> </a>
   ExgSocketType exgSocket;<a name="995522"> </a>
   uint32_t size = 0;<a name="995523"> </a>
   uint32_t sizeSent = 0;<a name="995524"> </a>
   status_t err = 0;<a name="995525"> </a>
   BitmapType *bmpP;<a name="995526"> </a>
 <a name="995527"> </a>
   // copy draw area into the bitmap<a name="995528"> </a>
   SaveWindow();<a name="995529"> </a>
   bmpP = PrvGetBitmap(canvasWinH, &amp;size, &amp;err);<a name="995530"> </a>
   // Is there data in the field?<a name="995531"> </a>
   if (!err &amp;&amp; size) {<a name="995532"> </a>
      // important to init structure to zeros...<a name="995533"> </a>
      MemSet(&amp;exgSocket,sizeof(exgSocket),0);<a name="995534"> </a>
      exgSocket.description = "Beamer picture";<a name="995535"> </a>
      exgSocket.name = "Beamer.pbm";<a name="995536"> </a>
      exgSocket.length = size;<a name="995537"> </a>
      err = ExgPut(&amp;exgSocket); <a name="995538"> </a>
      if (!err) {<a name="995539"> </a>
         sizeSent = ExgSend(&amp;exgSocket,bmpP,size,&amp;err);<a name="995540"> </a>
         ExgDisconnect(&amp;exgSocket,err);<a name="995541"> </a>
      }<a name="995542"> </a>
   }<a name="995543"> </a>
   if (bmpP) MemPtrFree(bmpP);	<a name="995544"> </a>
   return err;<a name="995545"> </a>
}<a name="995546"> </a>
</pre><div class="CodeRule"><hr></div>

<h3 class="hbH3">
  <a name="995548"> </a>Sending Multiple Objects <a href="#994958"><span class="nav">^TOP^</span></a>
</h3>


<p><a name="995549"> </a>If the exchange library supports it, you can send multiple objects in a single connection. To send multiple objects, do the following: </p>
<ol type="1">
  <li value="1"><a name="995554"> </a>Create and initialize an <a href="HLC_ExgMgrRef.html#1268710"><code>ExgSocketType</code></a> data structure with information about which library to use and the data to be sent. See <a href="HLC_ExgMgrConcept.html#1013421">"Initializing the Exchange Socket Structure"</a> for more information. You might also supply a value for the <code>count</code> field to specify how many objects are to be sent. 
  <li value="2"><a name="995562"> </a>Call <a href="HLC_ExgMgrRef.html#1269073"><code>ExgConnect()</code></a> to establish the connection with the exchange library. 
  <li value="3"><a name="995563"> </a>For each object, do the following: 
  <ol type="a">
    <li><a name="995568"> </a>Call <a href="HLC_ExgMgrRef.html#1270113"><code>ExgPut()</code></a> to signal the start of a new object. 
    <li><a name="995573"> </a>Call <a href="HLC_ExgMgrRef.html#1270444"><code>ExgSend()</code></a> one or more times to send the data. 
      <p><a name="995574"> </a>You may need to call it multiple times if you don't send all the data in the first call. </p>
  </ol>
  <li value="4"><a name="995579"> </a>Call <a href="HLC_ExgMgrRef.html#1269394"><code>ExgDisconnect()</code></a> to end the connection. 
   <p><a name="995580"> </a>A zero (0) return value indicates a successful transmission. However, this doesn't necessarily mean that the receiver kept the data. If the target application for an object doesn't exist on the receiving device, the data is discarded; or the user can decide to discard any beamed objects.</p>
</ol>

<p><a name="995581"> </a>The <code>ExgConnect()</code> call is optional. Some exchange libraries, such as the IR Library, support the sending of multiple objects but do not support <code>ExgConnect()</code>. If <code>ExgConnect()</code> returns an error, the first call to <code>ExgPut()</code> initiates the connection. You should only continue to send objects if the first <code>ExgPut()</code> call succeeds. See <a href="HLC_ExgMgrConcept.html#995586">Listing 4.4</a>. Libraries that support the <code>ExgConnect()</code> call also support sending multiple objects without using <code>ExgConnect()</code>. </p>
<p class="CCodeCaption">
  <a name="995586"> </a><b>Listing 4.4&nbsp;&nbsp;Sending multiple objects</b>
</p>

<div class="CodeRule"><hr></div><pre class="CodeBlock">
Boolean isConnected = false;<a name="995587"> </a>
err = ExgConnect(&amp;exgSocket);      //optional<a name="995588"> </a>
if (!err)<a name="995589"> </a>
   isConnected = true;<a name="995590"> </a>
if (!err || err == exgErrNotSupported) {<a name="995591"> </a>
   while (/* we have objects to send */) {<a name="995592"> </a>
      err = ExgPut(&amp;exgSocket);<a name="995593"> </a>
      if (!isConnected &amp;&amp; !err)<a name="995594"> </a>
         isConnected = true; //auto-connected on first put.<a name="995595"> </a>
      sizeSent = ExgSend(&amp;exgSocket,dataP,size,&amp;err);<a name="998523"> </a>
      if (err)<a name="998524"> </a>
         break;<a name="995599"> </a>
   }<a name="995600"> </a>
}<a name="995601"> </a>
if (isConnected) <a name="995602"> </a>
   ExgDisconnect(&amp;exgSocket, err);<a name="995603"> </a>
</pre><div class="CodeRule"><hr></div>

<h3 class="hbH3">
  <a name="995605"> </a>Implementing the Send Command  <a href="#994958"><span class="nav">^TOP^</span></a>
</h3>


<p><a name="995607"> </a>The built-in applications support a Send menu command. The purpose of this command is to allow the user to send data using any available transport mechanism. </p>

<p><a name="998458"> </a>The Exchange Manager defines a _send URL scheme. The intent is that any exchange library that supports sending is registered for the _send scheme. Currently, the Bluetooth, HotSync, SMS, and Mobile Mail libraries are registered for this scheme on release ROMs. The IR Library is <b>not</b> registered for the _send scheme.</p>

<p><a name="995610"> </a>To implement the Send command in your application, construct a URL that has the prefix <code>exgSendPrefix</code>, and send the data in the normal manner. You can also use the <code>exgSendBeamPrefix</code> instead so that the user can select from all exchange libraries registered for either sending or beaming (which includes the IR Library). Both of these prefixes begin with a question mark, causing the Exchange Manager to display a dialog if it finds more than one exchange library registered for the specified schemes. </p>

<p><a name="995616"> </a>For an example of how to implement the Send command, see the Memo application example code distributed with the Palm OS SDK. </p>

<h2 class="haH2">
  <a name="995618"> </a>Receiving Data <a href="#994958"><span class="nav">^TOP^</span></a>
</h2>


<p><a name="995619"> </a>To have your application receive data from the Exchange Manager, do the following:</p>
<ol type="1">
  <li value="1"><a name="995620"> </a>Register for the type of data you want to receive. See <a href="HLC_ExgMgrConcept.html#995259">"Registering for Data"</a> for more information. 
  <li value="2"><a name="995628"> </a>Handle the launch code <a href="HLC_ExgMgrRef.html#1327297"><code>sysAppLaunchCmdExgAskUser</code></a> if you want to control the user confirmation dialog that is displayed. See <a href="HLC_ExgMgrConcept.html#995654">"Controlling the Exchange Dialog"</a> for more information. 
  <li value="3"><a name="995640"> </a>Handle the launch code <a href="HLC_ExgMgrRef.html#1327402"><code>sysAppLaunchCmdExgReceiveData</code></a> to view and/or receive the data. See <a href="HLC_ExgMgrConcept.html#995765">"Receiving the Data"</a> for more information on receiving the data, and see <a href="HLC_ExgMgrConcept.html#1014475">"Viewing Attachments"</a> for more information about viewing the data; it's best to follow the guidelines in <a href="HLC_ExgMgrConcept.html#1003957">"Put with View Mode."</a>
  <li value="4"><a name="995652"> </a>If you want, handle <a href="../Programming_Basics/CmnLaunchCodes.html#993710"><code>sysAppLaunchCmdGoTo</code></a> to display the record. 
</ol>
<h3 class="hbH3">
  <a name="995654"> </a>Controlling the Exchange Dialog <a href="#994958"><span class="nav">^TOP^</span></a>
</h3>


<p><a name="995655"> </a>When the Exchange Manager receives an object and decides that your application is the target for that object, it sends your application a series of launch codes. The first launch code your application receives, in most cases, is <a href="HLC_ExgMgrRef.html#1327297"><code>sysAppLaunchCmdExgAskUser</code></a>. </p>

<div><hr>
  <a name="995660"> </a> <b>NOTE: </b> The Exchange Manager allows the exchange library to turn off the user confirmation dialog. In this case, your application does not receive the <code>sysAppLaunchCmdExgAskUser</code> launch code. 
<hr>
</div>

<p><a name="995662"> </a>The Exchange Manger sends this launch code because it is about to display the exchange dialog, which asks the user to confirm the receipt of data. The launch code is your opportunity to accept the data without confirmation, reject the data without confirmation, or replace the exchange dialog. </p>

<p><a name="995663"> </a>Responding to this launch code is optional. If you don't respond, the Exchange Manager calls <a href="HLC_ExgMgrRef.html#1269493"><code>ExgDoDialog()</code></a> to display the exchange dialog. </p>

<p><a name="995668"> </a>The <code>ExgDoDialog()</code> function allows you to specify that the dialog display a category pop-up list. This pop-up list allows the user to receive the data into a certain category in the database, but the pop-up list is not shown by default. If you want the exchange dialog to display the pop-up list, you must respond to <code>sysAppLaunchCmdExgAskUser</code> and call <code>ExgDoDialog()</code> yourself. Pass a pointer to an <code>ExgDialogInfoType</code> structure. The <code>ExgDialogInfoType</code> structure is defined as follows: </p>

<div class="CodeRule"><hr></div><pre class="CodeBlock">
typedef struct {<a name="995669"> </a>
  uint16_t     version;<a name="995670"> </a>
  DmOpenRef  db;<a name="995671"> </a>
  uint16_t     categoryIndex;<a name="995672"> </a>
} ExgDialogInfoType;<a name="995674"> </a>
<a name="995675"> </a>
</pre><div class="CodeRule"><hr></div>


<dl>
<dt><a name="995676"> </a><code>&rarr;  <i>version</i></code></dt>
<dd><a name="996996"> </a>Set this field to 0 to specify version 0 of this structure. </dd>

<dt><a name="995677"> </a><code>&rarr;  <i><code>db</code></i></code></dt>
<dd><a name="997000"> </a>A pointer to an open database that defines the categories the dialog should display. </dd>

<dt><a name="995678"> </a><code>&larr;  <i><code>categoryIndex</code></i></code></dt>
<dd><a name="997004"> </a>The index of the category in which the user wants to file the incoming data. </dd>

</dl>

<p><a name="995679"> </a>If <code>db</code> is valid, the function extracts the category information from the specified database and displays it in a pop-up list. Upon return, the <code>categoryIndex</code> field contains the index of the category the user selected, or <code>dmUnfiledCategory</code> if the user did not select a category. </p>

<p><a name="995681"> </a>If the call to <code>ExgDoDialog()</code> is successful, your application is responsible for retaining the value returned in <code>categoryIndex</code> and using it to file the incoming data as a record in that category. One way to do this is to store the <code>categoryIndex</code> in the socket's <code>appData</code> field (see <a href="HLC_ExgMgrRef.html#1268710"><code>ExgSocketType</code></a>) and then extract it from the socket in your response to the launch code <a href="HLC_ExgMgrRef.html#1327402"><code>sysAppLaunchCmdExgReceiveData</code></a>. See <a href="HLC_ExgMgrConcept.html#995693">Listing 4.5</a> for an example. </p>
<p class="CCodeCaption">
  <a name="995693"> </a><b>Listing 4.5&nbsp;&nbsp;Extracting the category from the exchange socket</b>
</p>

<div class="CodeRule"><hr></div><pre class="CodeBlock">
uint16_t categoryID = (ExgSocketType *)cmdPBP-&gt;appData;<a name="995694"> </a>
 <a name="995695"> </a>
/* Receive the data, and create a new record using the<a name="995696"> </a>
   received data. indexNew is the index of this record. */<a name="995697"> </a>
if (category != dmUnfiledCategory){<a name="995698"> </a>
   uint16_t attr;<a name="995699"> </a>
   status_t err;<a name="995700"> </a>
   err = DmRecordInfo(dbP, indexNew, &amp;attr, NULL, NULL);<a name="995701"> </a>
 <a name="995702"> </a>
   // Set the category to the one the user specified, and <a name="995703"> </a>
   // mark the record dirty. <a name="995704"> </a>
   if ((attr &amp; dmRecAttrCategoryMask) != category) {<a name="995705"> </a>
     attr &amp;= ~dmRecAttrCategoryMask;<a name="995706"> </a>
     attr |= category | dmRecAttrDirty;<a name="995707"> </a>
     err = DmSetRecordInfo(dbP, indexNew, &amp;attr, NULL);<a name="995708"> </a>
   }<a name="995709"> </a>
}<a name="995710"> </a>
</pre><div class="CodeRule"><hr></div>


<p><a name="995711"> </a>Some of the Palm OS built-in applications (Address Book, Memo, and ToDo) use this method of setting the category on data received through beaming. Refer to the example code provided in the Palm OS SDK for these applications for a more complete example of how to use <code>ExgDoDialog()</code>.</p>

<p><a name="995712"> </a>When you explicitly call <code>ExgDoDialog()</code>, you must set the <code>result</code> field of the <code>sysAppLaunchCmdExgAskUser</code> launch code's parameter block to either <code>exgAskOk</code> (upon success) or <code>exgAskCancel</code> (upon failure) to prevent the system from displaying the dialog a second time. </p>
<h3 class="hbH3">
  <a name="1014039"> </a>Getting the Object Description <a href="#994958"><span class="nav">^TOP^</span></a>
</h3>


<p><a name="1014101"> </a>The user might need more information about the object being received, so the Exchange Manager displays information about the object in the exchange dialog. Some exchange libraries do not transmit information for the exchange socket's <code>description</code> field, so the Exchange Manager must provide another means of supplying the user with information about the data being received. </p>

<p><a name="1014054"> </a>The Exchange Manager displays the first item that it locates in the following list: </p>
<ul type="disc">
  <li><a name="1014055"> </a>The data's description from the exchange socket's <code>description</code> field
  <li><a name="1014056"> </a>The filename in the socket's <code>name</code> field
  <li><a name="1014057"> </a>The receiving application's description as stored in the exchange registry (you pass this description to <a href="HLC_ExgMgrRef.html#1270252"><code>ExgRegisterDatatype()</code></a> when registering) 
  <li><a name="1014062"> </a>The MIME type in the socket's <code>type</code> field
  <li><a name="1014063"> </a>The file extension in the socket's <code>name</code> field
</ul>

<p><a name="1014064"> </a>If you want to support viewing the data in an application, the Exchange Manager can launch a display application with the launch code <a href="HLC_ExgMgrRef.html#1327402"><code>sysAppLaunchCmdExgReceiveData</code></a>. Display applications should register both file extension(s) and MIME type(s) of data that they can handle. Ideally, display applications should register for receiving data in view mode by registering with one or more of the view mode data type constants: <code>exgRegViewExtensionID</code>, <code>exgRegViewCreatorID</code>, or <code>exgRegViewTypeID</code>. Refer to <a href="HLC_ExgMgrConcept.html#995288">"General Registration Guidelines."</a></p>

<p><a name="1014256"> </a>For detailed information about supporting data viewing, see <a href="HLC_ExgMgrConcept.html#1014475">"Viewing Attachments"</a>; particularly, you should follow the guidelines in <a href="HLC_ExgMgrConcept.html#1003957">"Put with View Mode."</a> This information applies not only to email attachments, but to any incoming data.</p>
<h3 class="hbH3">
  <a name="995765"> </a>Receiving the Data <a href="#994958"><span class="nav">^TOP^</span></a>
</h3>


<p><a name="995767"> </a>If the Exchange Manager receives <code>exgAskOk</code> in response to the exchange dialog or the <a href="HLC_ExgMgrRef.html#1327297"><code>sysAppLaunchCmdExgAskUser</code></a> launch code, the next step is to launch the application with <a href="HLC_ExgMgrRef.html#1327402"><code>sysAppLaunchCmdExgReceiveData</code></a>. This launch code tells the application to actually receive the data. </p>

<p><a name="995776"> </a>To respond to this launch code, do the following: </p>
<ol type="1">
  <li value="1"><a name="995781"> </a>Call <a href="HLC_ExgMgrRef.html#1283452"><code>ExgAccept()</code></a> to accept the connection.
  <li value="2"><a name="995785"> </a>Call <a href="HLC_ExgMgrRef.html#1270187"><code>ExgReceive()</code></a> one or more times to receive the data.
   <p><a name="995786"> </a>In this function you specify the number of bytes to receive, and <code>ExgReceive()</code> returns the number of bytes that were received. You may need to call it multiple times if data is remaining to be received after the first and subsequent calls. </p>
   <p><a name="995787"> </a>Note that in the socket structure, the <code>length</code> field may not be accurate, so in your receive loop you should be flexible in handling more or less data than <code>length</code> specifies.</p>
  <li value="3"><a name="1001017"> </a>If you want your application launched again with the <a href="../Programming_Basics/CmnLaunchCodes.html#993710"><code>sysAppLaunchCmdGoTo</code></a> launch code, place your application's creator ID in the <a href="HLC_ExgMgrRef.html#1268710"><code>ExgSocketType</code></a>'s <code>goToCreator</code> field and supply the information that should be passed to the launch code in the <code>gotoParams</code> field. (The <code>ExgSocketType</code> structure is the parameter block for the <code>sysAppLaunchCmdExgReceiveData</code> launch code.) 
  <li value="4"><a name="1001024"> </a>Call <a href="HLC_ExgMgrRef.html#1269394"><code>ExgDisconnect()</code></a> to end the connection. 
   <p><a name="995800"> </a>A zero (0) return value indicates a successful transmission. </p>
</ol>

<p><a name="995801"> </a>After your application returns from <code>sysAppLaunchCmdExgReceiveData</code>, if the <code>goToCreator</code> specifies your application's creator ID and if the exchange library supports it, your application is launched with <code>sysAppLaunchCmdGoto</code>. In response to this launch code, your application should launch, open its database, and display the record identified by the <code>recordNum</code> field (or <code>matchCustom</code> field) in the parameter block. The Exchange Manager always does a full application launch with <code>sysAppLaunchCmdGoto</code>, so your application has access to global variables; however, if you also use this launch code to implement the global find facility, you may not have access to global variables in that instance. The example code in <a href="HLC_ExgMgrConcept.html#995806">Listing 4.6</a> checks to see if globals are available, and if so, calls <code>StartApplication</code> to initialize them. </p>
<p class="CCodeCaption">
  <a name="995806"> </a><b>Listing 4.6&nbsp;&nbsp;Responding to sysAppLaunchCmdGoto</b>
</p>

<div class="CodeRule"><hr></div><pre class="CodeBlock">
case sysAppLaunchCmdGoto:<a name="995807"> </a>
  if (launchFlags &amp; sysAppLaunchFlagNewGlobals) {
     err = StartApplication();<a name="995808"> </a>
     if (err) return err;<a name="995809"> </a>
     GoTo(cmdPBP, true);<a name="995810"> </a>
     EventLoop();<a name="995811"> </a>
     StopApplication();<a name="995812"> </a>
  } else {<a name="995813"> </a>
     GoTo(cmdPBP, false);<a name="995814"> </a>
}<a name="995815"> </a>
</pre><div class="CodeRule"><hr></div>


<p><a name="995816"> </a>Not all exchange libraries support using the <code>sysAppLaunchCmdGoto</code> launch code after the receipt of data. </p>

<p><a name="995817"> </a>Because Palm OS supports multiple object exchange, there is no guarantee that your application is the one that is launched at the end of a receipt of data. If multiple objects are being received, it is possible for another application to receive data after yours and to set the <code>goToCreator</code> field to its own creator ID. In this case, the last application to set the field is the one that is launched. </p>

<p><a name="995821"> </a><a href="HLC_ExgMgrConcept.html#995823">Listing 4.7</a> shows a function that receives a data object and sets the <code>goToCreator</code> and <code>goToParams</code>. </p>
<p class="CCodeCaption">
  <a name="995823"> </a><b>Listing 4.7&nbsp;&nbsp;Receiving a data object</b>
</p>

<div class="CodeRule"><hr></div><pre class="CodeBlock">
status_t ReceiveData(ExgSocketPtr exgSocketP)<a name="995824"> </a>
{<a name="995825"> </a>
   status_t err;<a name="995826"> </a>
   MemHandle dataH;<a name="995827"> </a>
   uint16_t size;<a name="995828"> </a>
   uint8_t *dataP;<a name="995829"> </a>
   int16_t len;<a name="995830"> </a>
   uint16_t dataLen = 0;<a name="995831"> </a>
   <a name="995832"> </a>
   if (exgSocketP-&gt;length)<a name="995833"> </a>
      size = exgSocketP-&gt;length;<a name="995834"> </a>
   else<a name="995835"> </a>
      size = ChunkSize; <a name="995836"> </a>
   dataH = MemHandleNew(size);  <a name="995837"> </a>
   if (!dataH) return -1;  // <a name="995838"> </a>
   // accept will open a progress dialog and wait for your receive commands<a name="995839"> </a>
   err = ExgAccept(exgSocketP);<a name="995840"> </a>
   if (!err){<a name="995841"> </a>
      dataP = MemHandleLock(dataH);<a name="995842"> </a>
      do {<a name="995843"> </a>
         len = ExgReceive(exgSocketP,&amp;dataP[dataLen], size-dataLen,&amp;err);<a name="995844"> </a>
         if (len &amp;&amp; !err) {<a name="995845"> </a>
            dataLen+=len;<a name="995846"> </a>
            // resize block when we reach the limit of this one...<a name="995847"> </a>
            if (dataLen &gt;= size) {<a name="995848"> </a>
               MemHandleUnlock(dataH);<a name="995849"> </a>
               err = MemHandleResize(dataH,size+ChunkSize);<a name="995850"> </a>
               dataP = MemHandleLock(dataH);<a name="995851"> </a>
               if (!err) size += ChunkSize;<a name="995852"> </a>
            }<a name="995853"> </a>
         }<a name="995854"> </a>
      }<a name="995855"> </a>
      while (len &amp;&amp; !err);<a name="995856"> </a>
 <a name="995857"> </a>
      MemHandleUnlock(dataH);<a name="995858"> </a>
      <a name="995859"> </a>
      ExgDisconnect(exgSocketP,err); // closes transfer dialog<a name="995860"> </a>
      <a name="995861"> </a>
      if (!err) {<a name="995862"> </a>
         exgSocketP-&gt;goToCreator = beamerCreator;<a name="995863"> </a>
         exgSocketP-&gt;goToParams.matchCustom = (uint32_t)dataH;<a name="995864"> </a>
      }<a name="995865"> </a>
   }<a name="995866"> </a>
   // release memory if an error occured<a name="995867"> </a>
   if (err) MemHandleFree(dataH);<a name="995868"> </a>
   return err;<a name="995869"> </a>
}<a name="995870"> </a>
</pre><div class="CodeRule"><hr></div>


<h2 class="haH2">
  <a name="995872"> </a>Sending and Receiving Databases <a href="#994958"><span class="nav">^TOP^</span></a>
</h2>


<p><a name="995874"> </a>It's common to want to send and receive an entire database using the Exchange Manager. For example, you might want to allow your application's users to share their versions of the PDB file associated with your application by beaming that file to each other. </p>

<p><a name="995875"> </a>Sending and receiving a database involves the extra steps of flattening the database into a byte stream when sending and un-flattening it upon return. </p>

<p><a name="1012612"> </a>In addition to the process documented in this section, you can now also use the Data Manager function <a href="../Memory_Databases_Files/DataMgr.html#995634"><code>DmBackupUpdate()</code></a> to flatten a database into a bye stream, and <a href="../Memory_Databases_Files/DataMgr.html#1005778"><code>DmRestoreUpdate()</code></a> to restore a database from a byte stream. These functions are more flexible than the Exchange Manager functions.</p>
<h3 class="hbH3">
  <a name="995877"> </a>Sending a Database <a href="#994958"><span class="nav">^TOP^</span></a>
</h3>


<p><a name="995878"> </a>To send a database, do the following: </p>
<ol type="1">
  <li value="1"><a name="995883"> </a>Create and initialize an <a href="HLC_ExgMgrRef.html#1268710"><code>ExgSocketType</code></a> data structure with information about which library to use and the data to be sent. See <a href="HLC_ExgMgrConcept.html#1013421">"Initializing the Exchange Socket Structure"</a> for more information. 
  <li value="2"><a name="995891"> </a>Call <a href="HLC_ExgMgrRef.html#1270113"><code>ExgPut()</code></a> to establish the connection with the exchange library. 
  <li value="3"><a name="995896"> </a>Call <a href="HLC_ExgMgrRef.html#1269343"><code>ExgDBWrite()</code></a> and pass it a pointer to a callback function in your application that it can use to send the database. You make the call to <a href="HLC_ExgMgrRef.html#1270444"><code>ExgSend()</code></a> in that function.
  <li value="4"><a name="995905"> </a>Call <a href="HLC_ExgMgrRef.html#1269394"><code>ExgDisconnect()</code></a> to end the connection. 
</ol>

<p><a name="995906"> </a>The <code>ExgDBWrite()</code> function takes as parameters the local ID of the database to be sent and a pointer to a callback function. You may also pass in the name of the database as it should appear in a file list and any application-specific data you want passed to the callback function. In this case, you would pass the pointer to the exchange socket structure as the application-specific data. If you need any other data, create a structure that contains the exchange socket and pass a pointer to that structure instead. </p>

<p><a name="995907"> </a>The write callback function is called as many times as is necessary to send the data. It takes three arguments: a pointer to the data to be sent, the size of the data, and the application-specific data passed as the second argument to <code>ExgDBWrite()</code>. </p>

<p><a name="995911"> </a><a href="HLC_ExgMgrConcept.html#995913">Listing 4.8</a> shows an example of how to send a database. The <code>SendMe()</code> function looks up the database creator ID and passes it to the <code>SendDatabase()</code> function. The <code>SendDatabase()</code> function creates and initializes the exchange socket structure and then passes all that information along to the <code>ExgDBWrite()</code> function. The <code>ExgDBWrite()</code> function locates the database in the storage heap, translates it into a stream of bytes and passes that byte stream as the first argument to the write callback function <code>WriteDBData()</code>. <code>WriteDBData()</code> forwards the exchange socket and the data stream to the <code>ExgSend()</code> call, sets its size parameter to the number of bytes sent (the return value of <code>ExgSend()</code>), and returns any error returned by <code>ExgSend()</code>. </p>
<p class="CCodeCaption">
  <a name="995913"> </a><b>Listing 4.8&nbsp;&nbsp;Sending a database</b>
</p>

<div class="CodeRule"><hr></div><pre class="CodeBlock">
// Callback for ExgDBWrite to send data with Exchange Manager <a name="995915"> </a>
status_t WriteDBData(const void* dataP, uint32_t* sizeP, void* userDataP) <a name="995916"> </a>
{<a name="995917"> </a>
   status_t err;<a name="995918"> </a>
 <a name="995919"> </a>
   *sizeP = ExgSend((ExgSocketPtr)userDataP, (void*)dataP, *sizeP, &amp;err);<a name="995920"> </a>
   return err;<a name="995921"> </a>
}<a name="995922"> </a>
 <a name="995923"> </a>
status_t SendDatabase (LocalID dbID, CharPtr nameP, CharPtr descriptionP) <a name="995924"> </a>
{<a name="995926"> </a>
   ExgSocketType exgSocket;<a name="995927"> </a>
   status_t err;<a name="995928"> </a>
 <a name="995929"> </a>
   // Create exgSocket structure<a name="995930"> </a>
   MemSet(&amp;exgSocket, sizeof(exgSocket), 0);<a name="995931"> </a>
   exgSocket.description = descriptionP;<a name="995932"> </a>
   exgSocket.name = nameP;<a name="995933"> </a>
 <a name="995934"> </a>
   // Start an exchange put operation<a name="995935"> </a>
   err = ExgPut(&amp;exgSocket);<a name="995936"> </a>
   if (!err) {<a name="995937"> </a>
      err = ExgDBWrite(WriteDBData, &amp;exgSocket, NULL, dbID);<a name="995938"> </a>
      err = ExgDisconnect(&amp;exgSocket, err);<a name="995939"> </a>
   }<a name="995940"> </a>
   return err;<a name="995941"> </a>
}<a name="995942"> </a>
 <a name="995943"> </a>
// Sends this application<a name="995944"> </a>
status_t SendMe(void)<a name="995945"> </a>
{<a name="995946"> </a>
   status_t err;<a name="995947"> </a>
   // Find our app using its internal name<a name="995949"> </a>
   LocalID dbID = DmFindDatabase(0, "Beamer");<a name="995950"> </a>
   if (dbID)<a name="995952"> </a>
      err = SendDatabase(dbID, "Beamer.prc", "Beamer application");<a name="995953"> </a>
   else<a name="995954"> </a>
      err = DmGetLastErr();<a name="995955"> </a>
   return err;<a name="995956"> </a>
}<a name="995957"> </a>
</pre><div class="CodeRule"><hr></div>


<p><a name="995958"> </a>Note that there is nothing about <code>ExgDBWrite()</code> that is tied to the Exchange Manager, so it may be used to send a database using other transport mechanisms as well. For example, if you wanted to transfer a database from your Palm Powered handheld to your desktop PC using the serial port, you could use <code>ExgDBWrite()</code> to do so. </p>
<h3 class="hbH3">
  <a name="995959"> </a>Receiving a Database <a href="#994958"><span class="nav">^TOP^</span></a>
</h3>


<p><a name="995960"> </a>The Launcher application receives databases with the <code>.prc</code> or <code>.pdb</code> file extension. If you want your application to be launched when the database is received, you can use a different extension and handle receiving the database within your application. For example, a book reader application might want to be launched when the user is beamed a book. In this case, the book reader application might use an extension such as <code>.bk</code> for the book databases. </p>

<p><a name="995961"> </a>You receive a database by responding to the same launch codes that you do for receiving any other data object (see <a href="HLC_ExgMgrConcept.html#995618">"Receiving Data"</a>); however, your response to the <a href="HLC_ExgMgrRef.html#1327402"><code>sysAppLaunchCmdExgReceiveData</code></a> launch code is a little different: </p>
<ol type="1">
  <li value="1"><a name="995972"> </a>Call <a href="HLC_ExgMgrRef.html#1283452"><code>ExgAccept()</code></a> to accept the connection.
  <li value="2"><a name="995977"> </a>Call <a href="HLC_ExgMgrRef.html#1269276"><code>ExgDBRead()</code></a> and pass it a pointer to a callback function in your application that it can use to read the database. You make the call to <a href="HLC_ExgMgrRef.html#1270187"><code>ExgReceive()</code></a> in that function.
  <li value="3"><a name="995986"> </a>Call <a href="HLC_ExgMgrRef.html#1269394"><code>ExgDisconnect()</code></a> to end the connection. 
</ol>

<p><a name="995987"> </a>The <code>ExgDBRead()</code> function takes as parameters two pointers to callback functions. The first callback function is a function that is called multiple times to read the data. The second function is used if the database to be received already exists on the device. </p>

<h2 class="haH2">
  <a name="995989"> </a>Requesting Data <a href="#994958"><span class="nav">^TOP^</span></a>
</h2>


<p><a name="995999"> </a>This section describes how to use the Exchange Manager to request data. It covers: </p>
<ul type="disc">
  <li><a name="996003"> </a><a href="HLC_ExgMgrConcept.html#996017">Sending a Get Request for a Single Object</a>
  <li><a name="996007"> </a><a href="HLC_ExgMgrConcept.html#1013545">Responding to a Get Request</a>
  <li><a name="996011"> </a><a href="HLC_ExgMgrConcept.html#996068">Two-Way Communications</a>
  <li><a name="996015"> </a><a href="HLC_ExgMgrConcept.html#996088">Requesting a URL</a>
</ul>

<p><a name="1014353"> </a>Some exchange libraries may allow you to request data from a remote device through a call to <a href="HLC_ExgMgrRef.html#1269590"><code>ExgGet()</code></a>. If supported, you can use <code>ExgGet()</code> to implement two-way communications between two Palm Powered devices. </p>

<div><hr>
  <a name="1014358"> </a> <b>NOTE: </b> The only standard exchange library that supports <code>ExgGet()</code> is the Local Exchange Library; currently there are no transports that support remote get requests.
<hr>
</div>

<p><a name="1006889"> </a>For information on using <code>ExgGet()</code> to attach a document to a message from a messaging application, see <a href="HLC_ExgMgrConcept.html#1003821">"Sending an Attachment from a Messaging Application."</a></p>
<h3 class="hbH3">
  <a name="996017"> </a>Sending a Get Request for a Single Object <a href="#994958"><span class="nav">^TOP^</span></a>
</h3>


<p><a name="996018"> </a>To request data from a remote device, do the following: </p>
<ol type="1">
  <li value="1"><a name="996019"> </a>Create and initialize an exchange socket structure (<a href="HLC_ExgMgrRef.html#1268710"><code>ExgSocketType</code></a>) as described in <a href="HLC_ExgMgrConcept.html#1013421">"Initializing the Exchange Socket Structure"</a>section. The data structure should identify the exchange library and the type of data that your application wants to receive. 
  <li value="2"><a name="996031"> </a>Call <a href="HLC_ExgMgrRef.html#1269590"><code>ExgGet()</code></a> to establish the connection and request the data. 
   <p><a name="996032"> </a>In response, the exchange library establishes a connection with the remote device, and upon return has data that your application should receive. If the remote device is a Palm Powered device, the exchange library obtains this data from an application on the remote side using the process described in the <a href="HLC_ExgMgrConcept.html#1013545">"Responding to a Get Request"</a> section. </p>
  <li value="3"><a name="996040"> </a>Call <a href="HLC_ExgMgrRef.html#1270187"><code>ExgReceive()</code></a> one or more times to receive the data.
  <li value="4"><a name="996045"> </a>Call <a href="HLC_ExgMgrRef.html#1269394"><code>ExgDisconnect()</code></a> to end the connection. 
</ol>
<h3 class="hbH3">
  <a name="1013545"> </a>Responding to a Get Request  <a href="#994958"><span class="nav">^TOP^</span></a>
</h3>


<p><a name="1013590"> </a>When the Exchange Manager receives a get request, it launches the appropriate application with the launch code <a href="HLC_ExgMgrRef.html#1327329"><code>sysAppLaunchCmdExgGetData</code></a>. Applications can register their support for the Get mechanism by registering to handle the <code>_get</code> scheme.</p>

<div><hr>
  <a name="1014429"> </a> <b>NOTE: </b> Since no standard transports support remote get requests, this section describes how to support a local get request.
<hr>
</div>

<p><a name="1013862"> </a>Your response to the <code>sysAppLaunchCmdExgGetData</code> launch code should be to send the requested data: </p>
<ol type="1">
  <li value="1"><a name="1013863"> </a>Present a document selection screen so that the user can choose an object to send.
  <li value="2"><a name="1013999"> </a>Set the name, type, and description fields in the socket.
  <li value="3"><a name="1013661"> </a>Call <a href="HLC_ExgMgrRef.html#1283452"><code>ExgAccept()</code></a>. (Do not call <a href="HLC_ExgMgrRef.html#1270113"><code>ExgPut()</code></a>.)
  <li value="4"><a name="996058"> </a>Call <a href="HLC_ExgMgrRef.html#1270444"><code>ExgSend()</code></a> one or more times. 
  <li value="5"><a name="996062"> </a>Call <a href="HLC_ExgMgrRef.html#1269394"><code>ExgDisconnect()</code></a> when finished. 
</ol>

<p><a name="1013622"> </a>For more information on supporting the Get mechanism, see <a href="HLC_ExgMgrConcept.html#1003821">"Sending an Attachment from a Messaging Application."</a></p>

<p><a name="1013620"> </a>See the <a href="HLC_ExgMgrConcept.html#995485">"Sending a Single Object"</a> section for more information on sending objects. </p>
<h3 class="hbH3">
  <a name="996068"> </a>Two-Way Communications <a href="#994958"><span class="nav">^TOP^</span></a>
</h3>


<p><a name="996076"> </a>You can use <a href="HLC_ExgMgrRef.html#1269590"><code>ExgGet()</code></a> and <a href="HLC_ExgMgrRef.html#1270113"><code>ExgPut()</code></a> in combination with the <a href="HLC_ExgMgrRef.html#1269073"><code>ExgConnect()</code></a> call to have your application perform two-way communication. For example, you may want to implement two-way communication in a multiuser game. </p>

<p><a name="996081"> </a>In such a situation, one device acts as a client and the other acts as a server. The client calls <code>ExgConnect()</code>, which tells the exchange library that a connection is established to perform multiple operations, such as the sending of multiple objects. The client then calls <code>ExgGet()</code> or <code>ExgPut()</code> repeatedly and calls <a href="HLC_ExgMgrRef.html#1269394"><code>ExgDisconnect()</code></a> when finished. On the server device, the appropriate application is launched for each of these requests. The server also calls <code>ExgDisconnect()</code> when it is done sending or receiving each object. The swapping of client and server roles is not supported. </p>

<p><a name="996086"> </a>Remember that not all exchange libraries support <code>ExgConnect()</code> and <code>ExgGet()</code>. If either one of these returns an error, your application should assume that this feature is not available. </p>
<h3 class="hbH3">
  <a name="1010214"> </a>Getting the Sender's URL <a href="#994958"><span class="nav">^TOP^</span></a>
</h3>


<p><a name="1010231"> </a>For some applications, you might need to know the URL that addresses the remote device from which you are receiving data. This is especially useful for games and other two-way communications. You can get the URL after calling <code>ExgAccept()</code> by calling <a href="HLC_ExgMgrRef.html#1269178"><code>ExgControl()</code></a> and passing the <code>exgLibCtlGetURL</code> operation code. </p>

<p><a name="1010290"> </a>Not all exchange libraries support this operation. The Bluetooth exchange library does support it, and you can find more information in <a href="../Low-Level_Communications/LowLevelComms_BtExg.html#608590">Chapter 12, "Bluetooth Exchange Library Support,"</a> in <i>Exploring Palm OS: Low-Level Communications</i>.</p>
<h3 class="hbH3">
  <a name="996088"> </a>Requesting a URL  <a href="#994958"><span class="nav">^TOP^</span></a>
</h3>


<p><a name="1009656"> </a>In addition to requesting data with an <a href="HLC_ExgMgrRef.html#1269590"><code>ExgGet()</code></a> call, you can request a URL with a <a href="HLC_ExgMgrRef.html#1270381"><code>ExgRequest()</code></a> call. The idea behind the <code>ExgRequest()</code> call is to follow the model of pull technology. You could, for example, implement a web browser if you had an exchange library that supported the HTTP protocol. You could then send an <code>ExgRequest()</code> call with an exchange socket containing a URL such as <code>http://www.palmos.com</code> and receive the web page in response. </p>

<p><a name="1009661"> </a>The fundamental differences between <code>ExgRequest()</code> and <code>ExgGet()</code> are: </p>
<ul type="disc">
  <li><a name="996100"> </a><code>ExgRequest()</code> does not automatically send the data back to the application that requested it. With <code>ExgRequest()</code>, when the exchange library receives the requested data, it has the Exchange Manager send it to the default application for that data type. 
  <li><a name="1001100"> </a>Applications can register for URLs sent using <code>ExgRequest()</code>. <code>ExgRequest()</code> first looks for an exchange library that handles the URL scheme. If it cannot find one, it looks for an application instead. If it finds an application, it launches it with the <a href="../Programming_Basics/CmnLaunchCodes.html#1003495"><code>sysAppLaunchCmdGoToURL</code></a> launch code. 
   <p><a name="1001121"> </a>For example, suppose an application that handles email registers for the <code>mailto</code> URL scheme. If another application wants to implement an email command, it could do so by calling <code>ExgRequest()</code> and passing an exchange socket with a URL that begins with <code>mailto</code>. In response to this command, the Exchange Manager launches the application that handles email, allowing the user to compose the email.</p>
</ul>

<p><a name="1006976"> </a>For information on another method of implemented email and attaching a document to a message, see <a href="HLC_ExgMgrConcept.html#1005530">"Sending an Attachment from a Display Application."</a></p>

<h2 class="haH2">
  <a name="996108"> </a>Sending and Receiving Locally <a href="#994958"><span class="nav">^TOP^</span></a>
</h2>


<p><a name="996110"> </a>Most of this chapter has described how to use the Exchange Manager to send data to a remote device and receive data from a remote device. </p>

<p><a name="996111"> </a>You may also use the Exchange Manager to exchange data with other applications on the local device. To do so, use the Local Exchange Library. You might want to do so in the following circumstances: </p>
<ul type="disc">
  <li><a name="996112"> </a>You might have an application that creates some sort of event in the Datebook application. Your users might have an application that they use in place of the built-in Datebook. To ensure that the appointment is sent to the user's chosen application, you can send that data as a vCalendar object using the Local Exchange Manager. This way, whichever application is the default in the Exchange Manager registry is the one that receives your vCalendar. 
  <li><a name="996120"> </a>Your application receives compound data objects, such as email messages that contain attachments intended for other applications. As described in the <a href="HLC_ExgMgrConcept.html#995445">"Registering to Receive Unwrapped Data"</a> section, exchange libraries can "unwrap" a compound object and deliver the objects it contains directly; however, doing so is the exception the rule. 
   <p><a name="996124"> </a>It's much more common for the email message to be sent to the email application and have the attachments delivered to the appropriate applications only when the user requests it. In response to a user request, the email application extracts the attached object and uses the Local Exchange Library to send it to the application that should receive it, for viewing and/or storage. For detailed guidelines on handling attachments, see <a href="HLC_ExgMgrConcept.html#1003329">"Attachment Support Guidelines."</a></p>
  <li><a name="996125"> </a>Your application exchanges data with a remote device, and you want to debug the code that interacts with the Exchange Manager. In this case, using the Local Exchange Library causes your application to send data in loopback mode, where it is also the recipient of the data. 
</ul>

<p><a name="996126"> </a>To use the Local Exchange Library, do the following: </p>
<ol type="1">
  <li value="1"><a name="996131"> </a>Use a URL in the <code>name</code> field of the <a href="HLC_ExgMgrRef.html#1268710"><code>ExgSocketType</code></a> structure to identify the Local Exchange Library. Begin the URL with the constant string <code>exgLocalPrefix</code>. 
  <li value="2"><a name="996133"> </a>If you want to suppress the exchange dialog, create and initialize an <a href="HLC_ExgMgrRef.html#1268556"><code>ExgLocalSocketInfoType</code></a> structure and assign it to the socket's <code>socketRef</code> field. 

<div class="CodeRule"><hr></div><pre class="CodeBlock">
typedef struct {<a name="996138"> </a>
  Boolean freeOnDisconnect;<a name="996139"> </a>
  Boolean noAsk;<a name="996140"> </a>
  ExgPreviewInfoType *previewInfoP;<a name="996141"> </a>
  ExgLocalOpType op;<a name="996142"> </a>
  FileHand tempFileH;<a name="996143"> </a>
} ExgLocalSocketInfoType;<a name="996144"> </a>
</pre><div class="CodeRule"><hr></div>

   <p><a name="996145"> </a>where the following are parameters you might want to set:</p>
</ol>


<div class="tablediv"><table cellspacing="0" class="tTableNR">

  <tr valign="top">
    <td><p class="tt"><a name="996148"> </a><code>freeOnDisconnect </code></p>
    </td>
    <td><p class="tt"><a name="996150"> </a>Determines whether the structure is freed when the <code>ExgDisconnect()</code> call is made. The default is <code>true</code>. In general, code that allocates a structure should be responsible for freeing that structure. Therefore, if you have allocated <code>ExgLocalSocketInfoType</code>, you should set this field to <code>false</code> and explicitly free the structure when you are finished with it. </p>
    </td>
  </tr>
  <tr valign="top">
    <td><p class="tt"><a name="996152"> </a><code>noAsk </code></p>
    </td>
    <td><p class="tt"><a name="996154"> </a>Set to <code>true</code> to disable the display of the exchange dialog. For example, if you want to create a vCalendar object and send it to the datebook application in response to a user command, you probably want to set <code>noAsk</code> to <code>true</code> so that the user does not have to confirm the receipt of the data they just requested you to send. </p>
    </td>
  </tr>
  <tr valign="top">
    <td><p class="tt"><a name="996156"> </a><code>previewInfoP </code></p>
    </td>
    <td><p class="tt"><a name="996162"> </a>A pointer to an <a href="HLC_ExgMgrRef.html#1268619"><code>ExgPreviewInfoType</code></a> structure, used to display a preview of the data. The preview feature is deprecated and is maintained only for backward compatibility.</p>
    </td>
  </tr>
</table>

</div>

   <p><a name="996164"> </a>All other fields are set by the Local Exchange Library. If you don't create this structure, the library does it for you; therefore, you only need to create this structure if you want to supply non-default values for the <code>noAsk</code> or <code>previewInfoP</code> fields. </p>
<ol type="1">
  <li value="3"><a name="996165"> </a>You can suppress the display of the progress dialogs that the exchange libraries typically display by setting the <code>noStatus</code> field of the <code>ExgSocketType</code> structure to <code>true</code>. 
  <li value="4"><a name="996168"> </a>Send and receive data in the normal manner. See <a href="HLC_ExgMgrConcept.html#995470">"Sending Data"</a> and <a href="HLC_ExgMgrConcept.html#995618">"Receiving Data"</a> for details. 
</ol>

<h2 class="haH2">
  <a name="996174"> </a>Interacting with the Launcher <a href="#994958"><span class="nav">^TOP^</span></a>
</h2>


<p><a name="996176"> </a>When you beam an application from the Launcher, other databases can be automatically beamed with it. If the application has an associated overlay database, the overlay is beamed along with the application. You do not have to perform any extra work to allow this to happen. This bundling behavior is available only when beaming from the launcher, not if an application manually beams an application.</p>

<p><a name="996179"> </a>In addition to beaming overlays, you can set up a record database so that the Launcher beams it along with the application database and the overlay. For example, a dictionary application might have its dictionary data in an associated database. When a user beams the dictionary application to another user, the dictionary data should be beamed along with the application itself. To allow this to happen, you set the bit <span style="color: #000000;  font-family: Courier; font-style: normal; font-weight: normal; text-decoration: none; text-transform: none; vertical-align: baseline">dmHdrAttrBundle</span> in the database's attributes.</p>

<p><a name="996188"> </a>If you beam an application plus databases to a device running Palm OS 4.0 or higher, the user sees a single confirmation message. If you beam the application to a device running Palm OS 3.X, the device receives only the application database and displays an alert saying that it cannot receive the other databases.</p>

<h2 class="haH2">
  <a name="1007009"> </a>HotSync Exchange <a href="#994958"><span class="nav">^TOP^</span></a>
</h2>


<p><a name="1007132"> </a>HotSync Exchange allows a Palm OS Cobalt device and a desktop computer running the Palm Desktop to exchange files in their native formats. For example, HotSync Exchange enables installation of JPEG (.JPG) files to a handheld image viewer via the standard HotSync desktop install tool and the HotSync exchange library, provided the viewer application has registered with the Exchange Manager for the .JPG extension. This feature eliminates the need for the viewer application developer to write a custom conduit to pack JPEG data into the Palm OS database format. </p>

<p><a name="1007429"> </a>Similarly, the viewer application can send JPEG files via the Exchange Manager directly to the desktop where HotSync stores them in standard .JPG format.</p>

<p><a name="1007948"> </a>HotSync Exchange also supports bundled install, which is the installation of an application and its data files in a single HotSync session. Bundled install requires the newly installed application to register for its data types with the Exchange Manager when it receives the <code>sysAppLaunchCmdSyncNotify</code> launch code. This allows the HotSync exchange library to deliver the data files when it receives the subsequent <code>sysNotifySyncFinishEvent</code>.</p>

<p><a name="1008034"> </a>For more information about the desktop side of HotSync Exchange, refer to the book <i>Introduction to Conduit Development</i>.</p>

<p><a name="1008038"> </a>Note that HotSync Exchange is supported only by Palm OS devices running Palm OS Cobalt.</p>
<h3 class="hbH3">
  <a name="1007177"> </a>Sending Files with HotSync Exchange <a href="#994958"><span class="nav">^TOP^</span></a>
</h3>


<p><a name="1007269"> </a>Applications use the HotSync exchange library to send files to a HotSync desktop. The HotSync exchange library supports the following Exchange Manager schemes:</p>
<ul type="disc">
  <li><a name="1007270"> </a>The desktop scheme (_desktop). This scheme supports direct exchange of a file to a HotSync desktop.    
  <li><a name="1007271"> </a>The _send scheme. This scheme allows users to send data using any transport that supports this scheme, such as the HotSync exchange library.
</ul>

<p><a name="1007272"> </a>These schemes support the exchange of files during a HotSync operation to a directly connected desktop.</p>

<p><a name="1007273"> </a>Neither scheme supports the specification of a target desktop in the Exchange URL, so the file will, by default, be sent during the next HotSync operation to any desktop. However, the user may select a specific target desktop for each file pending HotSync Exchange via the HotSync client user interface, if desired (see below). This will cause the file to be sent during the next HotSync operation with the selected desktop.</p>
<h3 class="hbH3">
  <a name="1007358"> </a>Example <a href="#994958"><span class="nav">^TOP^</span></a>
</h3>


<p><a name="1008201"> </a>The following example illustrates the data flow involving the HotSync exchange library and the desktop. Say that a device application wants to transfer palmuser.id to the desktop. The user also wants to install the picture mountain.jpg to the handheld to view on a registered JPEG picture viewer.</p>

<p class="FFigureCaption">
  <a name="1008324"> </a><b>Figure 4.2&nbsp;&nbsp;HotSync Exchange example</b>
</p>
<div align="left"><img src="images/HotSyncExchange2.jpg" height="370" width="624" border="0" hspace="0" vspace="0">
</div>

<h5 class="hdH5">
  <a name="1008327"> </a>Prior to the HotSync Operation
</h5>

<p><a name="1008542"> </a>Before the HotSync operation the following operations are performed:</p>

<p><a name="1008203"> </a>The user queues the file mountain.jpg for install to the handheld during a subsequent HotSync. The file is queued in a user-specific download folder on the desktop.</p>

<p><a name="1007949"> </a>The device application uses the Exchange Manager API to do the following (represented by red lines in the figure):</p>
<ol type="1">
  <li value="1"><a name="1007359"> </a>Initialize the <a href="HLC_ExgMgrRef.html#1268710"><code>ExgSocketType</code></a> structure with the file name palmuser.id.
  <li value="2"><a name="1012981"> </a>Call <a href="HLC_ExgMgrRef.html#1270113"><code>ExgPut()</code></a>. This causes the HotSync exchange library to allocate a temporary cache to store the data. It also stores information about the pending transaction in a catalog of pending desktop exchanges.
  <li value="3"><a name="1012986"> </a>Call <a href="HLC_ExgMgrRef.html#1270444"><code>ExgSend()</code></a> to fill the database with the data.
  <li value="4"><a name="1012990"> </a>Call <a href="HLC_ExgMgrRef.html#1269394"><code>ExgDisconnect()</code></a> to close the cache. The data is then queued until it can be successfully sent during a HotSync operation.
</ol>

<h5 class="hdH5">
  <a name="1008579"> </a>During the HotSync Operation
</h5>

<p><a name="1008621"> </a>During the HotSync Exchange operation, the conduit performs several actions, represented by the black lines in the figure.</p>

<p><a name="1008581"> </a>The HotSync Exchange conduit first checks if there are any pending handheld-to-desktop transfer requests for the local desktop by examining the handheld exchange catalog mentioned above. Since the conduit finds an entry, it proceeds to create a desktop file with the associated file name (palmuser.id) in the user's directory on the desktop that contains the contents of the associated temporary cache. Afterwards, the conduit deletes the catalog entry and the temporary cache from the handheld.</p>

<p><a name="1008582"> </a>The conduit then checks to see if there are any files to be installed to the device. It finds mountains.jpg and creates a cache named mountains.jpg on the handheld.</p>

<h5 class="hdH5">
  <a name="1008551"> </a>After the HotSync Operation
</h5>

<p><a name="1007382"> </a>After the HotSync operation the following operations are performed (represented by blue lines in the figure):</p>

<p><a name="1007384"> </a>The system launches newly installed applications and applications whose data has been modified by the HotSync operation. At this point newly installed applications can register supported file types with the Exchange Manager. (So, if the HotSync operation had installed a JPEG viewer, it would now register for .JPG files). When the HotSync exchange library receives the <code>sysNotifySyncFinishEvent</code> notification, it searches for temporary HotSync caches. On finding mountains.jpg, it opens the cache and calls <a href="HLC_ExgMgrRef.html#1270008"><code>ExgNotifyReceive()</code></a>. This causes the Exchange Manager to launch the viewer for JPEG files and transfer the file mountains.jpg to it. The application may choose to convert and store it in a Palm OS database. When the application calls <a href="HLC_ExgMgrRef.html#1269394"><code>ExgDisconnect()</code></a>, the HotSync exchange library deletes the temporary cache created by the conduit.</p>

<p><a name="1007570"> </a>The HotSync exchange library disables the confirm receipt dialog that is normally displayed when data is sent via the Exchange Manager. Thus there is no user interface on the handheld device during a successful desktop to handheld exchange.</p>

<h2 class="haH2">
  <a name="1003329"> </a>Attachment Support Guidelines <a href="#994958"><span class="nav">^TOP^</span></a>
</h2>


<p><a name="1003330"> </a>This section outlines how Palm OS applications should interoperate to exchange email attachments. On other platforms attachments are stored intermediately on a file system for the handover between a messaging application (email, instant messaging, etc.) and a display application (word processor, image viewer, etc.). On Palm OS, which doesn't provide a file system, the Exchange Manager enables data exchange between applications. </p>

<p><a name="1003367"> </a>The following sections describe how applications should use the Exchange Manager to handle attachments. These guidelines were designed with the following goals: </p>
<ul type="disc">
  <li><a name="1003372"> </a>Leveraging existing capabilities of today's applications. 
  <li><a name="1003375"> </a>Ensuring backwards compatibility with Palm OS 4 by using existing standard mechanisms. 
  <li><a name="1003384"> </a>Providing a good user experience. 
</ul>

<p><a name="1003489"> </a>Application providers are strongly encouraged to follow these guidelines to enable a consistent user experience on Palm OS.</p>

<p><a name="1003393"> </a>The following topics are covered:</p>
<ul type="disc">
  <li><a name="1003529"> </a><a href="HLC_ExgMgrConcept.html#1014475">Viewing Attachments</a>
  <li><a name="1003565"> </a><a href="HLC_ExgMgrConcept.html#1003821">Sending an Attachment from a Messaging Application</a>
  <li><a name="1003580"> </a><a href="HLC_ExgMgrConcept.html#1005530">Sending an Attachment from a Display Application</a>
  <li><a name="1003692"> </a><a href="HLC_ExgMgrConcept.html#1005608">Email Application Guidelines</a>
</ul>

<p><a name="1003331"> </a>The Attachment Support sample code shows how to implement the guidelines covered in this section. It is available in the Developer Knowledge Base at <a href="http://kb.palmsource.com/">http://kb.palmsource.com/</a> </p>
<h3 class="hbH3">
  <a name="1014475"> </a>Viewing Attachments <a href="#994958"><span class="nav">^TOP^</span></a>
</h3>


<p><a name="1003713"> </a>Messaging applications should leverage dedicated display applications already available on the device rather than implementing their own content viewers. Passing data from the messaging application to a display application is facilitated by the Exchange Manager. </p>

<div><hr>
  <a name="1014387"> </a> <b>NOTE: </b> The data viewing mechanism described here can be used for more than just viewing email attachments. It can be used as a general purpose mechanism to view any data incoming via the Exchange Manager. Follow the guidelines for display applications to support data viewing in a display application.
<hr>
</div>

<p><a name="1014386"> </a>There are two methods of exchanging attachments:</p>
<ul type="disc">
  <li><a name="1003715"> </a><a href="HLC_ExgMgrConcept.html#1003819">Regular Put</a>: This is the standard put mechanism (using <a href="HLC_ExgMgrRef.html#1270008"><code>ExgNotifyReceive()</code></a> or <a href="HLC_ExgMgrRef.html#1270113"><code>ExgPut()</code></a>). It is backwards compatible with older applications that don't know about attachment support.
  <li><a name="1003719"> </a><a href="HLC_ExgMgrConcept.html#1003957">Put with View Mode</a>: This method defines an enhanced view mode. It enables display applications to distinguish between data sent for temporary viewing versus data sent to be accepted into the database.
   <p><a name="1003818"> </a>Additionally, this method defines a return mechanism to the messaging application. This allows display applications to execute a full launch of one or more other applications before returning control to the messaging application.</p>
</ul>

<h4 class="hcH4">
  <a name="1003819"> </a>Regular Put
</h4>

<p><a name="1003834"> </a>This method, which has been around for several years, enables an application to send data to another application. Older display applications, which are not attachment aware, will simply accept the data into their database and not return to the messaging application. (The user needs to return via the launcher). Although this behavior doesn't present an optimal user experience, it provides a way to take advantage of older applications.</p>

<p><a name="1003849"> </a>Newer applications, which follow the guidelines outlined in this section, provide the user with the option to return to the messaging application (for example, via a Done button). The recommended method is that the display application simply exits. The system will automatically launch the previous application (implicit launch of the messaging application).</p>

<p><a name="1003863"> </a>The interaction between the messaging application, Exchange Manager, and the display application for a regular Put operation is shown in <a href="HLC_ExgMgrConcept.html#1003888">Figure 4.3</a>. Specific guidelines for messaging applications and display applications follow the figure.</p>

<p class="FFigureCaption">
  <a name="1003888"> </a><b>Figure 4.3&nbsp;&nbsp;Regular Put operation</b>
</p>
<div align="left"><img src="images/RegularPut3.jpg" height="482" width="624" border="0" hspace="0" vspace="0">
</div>

<h5 class="hdH5">
  <a name="1003935"> </a>Guidelines for Messaging Applications
</h5>

<p><a name="1004027"> </a>To handle attachment viewing with the regular Put method, messaging applications should follow these guidelines:</p>
<ul type="disc">
  <li><a name="1003975"> </a>Messaging applications are strongly encouraged to implement their own exchange library to support the Put mechanism (minimal implementation of accept/receive/disconnect).
   <p><a name="1003977"> </a>Although Put can be implemented without an exchange library (by using <a href="HLC_ExgMgrRef.html#1270113"><code>ExgPut()</code></a>, <a href="HLC_ExgMgrRef.html#1270444"><code>ExgSend()</code></a>, and <a href="HLC_ExgMgrRef.html#1269394"><code>ExgDisconnect()</code></a>), this implementation is slow, especially for large attachments, because the Exchange Manager first reads and copies all the data before handing it over to the display application.</p>
  <li><a name="1004274"> </a>Messaging applications can query the Exchange Manager registry to determine if a dedicated application is available to handle a specific content type (use <a href="HLC_ExgMgrRef.html#1269768"><code>ExgGetRegisteredTypes()</code></a>). If no application can handle the attachment, the messaging application may convert the content into a different format that can be displayed on the device. The conversion might take place either on the client side or, in the case of a distributed email solution, on a server or desktop computer. For example, if no application has registered with the Exchange Manager to handle HTML content, the email application could convert it to text and display it itself.
  <li><a name="1004278"> </a>Whenever possible, messaging applications should include the MIME type information (besides the file extension) when sending data to the Exchange Manager. File extensions do not uniquely identify the content of a document. In some cases, the same file extension has been used for different file formats (for example, ".doc"). Refer to IANA (<a href="http://www.iana.org/assignments/media-types/">http://www.iana.org/assignments/media-types/</a>) for the official list of registered MIME types.
   <p><a name="1004330"> </a>Some notes on MIME types: MIME type information in the Content-Type field of email messages isn't always reliable. Some email programs use non-registered MIME types (for example, application/powerpoint instead of application/vnd.ms-powerpoint) or use a generic MIME type (for example, application/octet) when attaching documents. It is recommended that email applications analyze the Content-Type field carefully (including file extensions), and map it to the correct MIME type before passing this information to the Exchange Manager. Developers of messaging applications are encouraged to present a list of applications that can handle the attachment, instead of simply using the default application. (The <a href="HLC_ExgMgrRef.html#1269717"><code>ExgGetRegisteredApplications()</code></a> function allows messaging applications to query for applications that have registered for a specific MIME type or file extension).</p>
  <li><a name="1004338"> </a>Messaging applications should send only one data object (document) at a time to a document application in a single connection. Although the exchange library is capable of handling multiple objects in a single connection, the assumption is that a display application can display only one document at a time.
  <li><a name="1004340"> </a>For regular Put, the default Exchange Manager dialog ("Do you want to accept...") should not be disabled. (Use <a href="HLC_ExgMgrRef.html#1270008"><code>ExgNotifyReceive()</code></a><code>(...,0)</code> in the exchange library).
  <li><a name="1004313"> </a>Messaging applications are responsible for transport-related encoding and decoding of the content. All content exchanged with a display application happens in binary format.
</ul>

<p><a name="1003940"> </a>Guidelines for Display Applications</p>

<p><a name="1004501"> </a>To handle attachment viewing with the regular Put method, display applications should follow these guidelines:</p>
<ul type="disc">
  <li><a name="1004526"> </a>Display applications should register both file extension(s) and MIME type(s) of data that they can handle. Refer to <a href="HLC_ExgMgrConcept.html#995288">"General Registration Guidelines."</a>
  <li><a name="1004528"> </a>Applications should be prepared to receive invalid data and deal with this situation gracefully.
  <li><a name="1004530"> </a>Applications that accept data or documents into their databases should avoid unnecessary duplication. For instance, if a user views an attachment several times, the data should not be duplicated.
  <li><a name="1004532"> </a>Applications should provide the user with an option to return to the messaging application (for example, a Done button).
  <li><a name="1003956"> </a>Display applications and messaging applications exchange data in its normal binary format. Messaging applications will encode/decode the data according to their transport requirements.
</ul>

<h4 class="hcH4">
  <a name="1003957"> </a>Put with View Mode
</h4>

<p><a name="1004621"> </a>This method defines an extension to the standard Put mechanism. It allows display applications to implement a special view mode where data is displayed, but not automatically added to the application's database. During view mode, the default Exchange Manager "Accept..." dialog can be disabled, which saves the user an extra step.</p>

<p><a name="1004623"> </a>Moreover, view mode defines a mechanism to return to the messaging application across an arbitrary number of nested launches of other applications. This is useful, for instance, when a messaging application hands a .zip or .tar file to a decompression utility application that, after the user chooses a specific document, sends the content to the appropriate display application.</p>

<p><a name="1004625"> </a>Implementation of the view mode requires collaboration of both the messaging and display applications. Display applications indicate support for view mode by using the following exchange registry IDs during registration:</p>

<div class="CodeRule"><hr></div><pre class="CodeBlock">
// New Exchange registry IDs for View registry. Don't change values! <a name="1004627"> </a>
#define exgRegViewExtensionID 0xff8d // filename ext. registry for View <a name="1004670"> </a>
#define exgRegViewTypeID 0xff8e // MIME type registry for View <a name="1004671"> </a>
<a name="1004685"> </a>
ExgRegisterDatatype(...,exgRegViewExtensionID,...,...,...);<a name="1004697"> </a>
ExgRegisterDatatype(...,exgRegViewTypeID,...,...,...);<a name="1004689"> </a>
</pre><div class="CodeRule"><hr></div>


<p><a name="1004762"> </a>These two exchange registry IDs, one for file extensions and the other for MIME types, allow display applications to support view mode only for a subset of the content they usually accept. </p>

<p><a name="1004764"> </a>Before a messaging application calls <a href="HLC_ExgMgrRef.html#1270008"><code>ExgNotifyReceive()</code></a>, it must first check if the receiving application supports view mode for the content that is to be sent. If the display application supports view mode, the messaging application must add its own GoTo information to the <a href="HLC_ExgMgrRef.html#1268710"><code>ExgSocketType</code></a> structure. <a href="HLC_ExgMgrConcept.html#1004774">Figure 4.4</a> shows the interaction between the applications and the Exchange Manager in more detail.</p>

<p class="FFigureCaption">
  <a name="1004774"> </a><b>Figure 4.4&nbsp;&nbsp;Put with view mode</b>
</p>
<div align="left"><img src="images/PutWithView4.jpg" height="664" width="624" border="0" hspace="0" vspace="0">
</div>

<h5 class="hdH5">
  <a name="1004597"> </a>Guidelines for Messaging Applications
</h5>

<p><a name="1004818"> </a>Messaging applications are strongly encouraged to support view mode.</p>

<p><a name="1004820"> </a>In addition to the guidelines defined in <a href="HLC_ExgMgrConcept.html#1003819">"Regular Put,"</a> messaging applications that want to take advantage of display applications with view mode support must follow these guidelines:</p>
<ul type="disc">
  <li><a name="1004821"> </a>Messaging applications must check if the receiving application supports view mode, before adding their own GoTo information. The default "Accept" dialog can be disabled only if the target application supports view mode, resides on the same device, and if GoTo information is added.

<div class="CodeRule"><hr></div><pre class="CodeBlock">
ExgGetRegisteredApplications(..., ..., ..., 
exgRegViewExtensionID,...)<a name="1004823"> </a>
ExgGetRegisteredApplications(..., ..., ..., exgRegViewTypeID,...)<a name="1004824"> </a>
...<a name="1004825"> </a>
if (supportsView) {<a name="1004826"> </a>
  add_my_GoTo_info();<a name="1004827"> </a>
  ask = exgNoAsk;<a name="1004828"> </a>
}<a name="1004829"> </a>
ExgNotifyReceive(..., ask);<a name="1004830"> </a>
</pre><div class="CodeRule"><hr></div>

  <li><a name="1004833"> </a>If the receiving application does not support view mode, the <code>gotoCreator</code> field and the <code>goToParams</code> structure fields in the <a href="HLC_ExgMgrRef.html#1268710"><code>ExgSocketType</code></a> structure passed to <a href="HLC_ExgMgrRef.html#1270008"><code>ExgNotifyReceive()</code></a> (or <a href="HLC_ExgMgrRef.html#1270113"><code>ExgPut()</code></a>) must be set to zero and the "Accept" dialog must not be disabled. The reason for this is that some applications (for example, certain built-in PIM applications) that don't support view mode, use some <code>goToParams</code> fields to determine certain states. Supplying wrong information could lead to unwanted behavior. 
  <li><a name="1004834"> </a>When a messaging application is relaunched after view mode, it should return to the same state it was in when the display application was launched. Especially, the same message should be displayed and any splash screens should be skipped.
</ul>

<p><a name="1004616"> </a>Guidelines for Display Applications</p>

<p><a name="1004951"> </a>In addition to the guidelines defined in <a href="HLC_ExgMgrConcept.html#1003819">"Regular Put,"</a> display applications that want to implement view mode support must follow these guidelines:</p>
<ul type="disc">
  <li><a name="1004952"> </a>Support for view mode must be indicated by registering with the Exchange Manager like this:

<div class="CodeRule"><hr></div><pre class="CodeBlock">
// New Exchange registry IDs for View registry. Don't change values!<a name="1004954"> </a>
#define exgRegViewExtensionID 0xff8d // filename extension ID<a name="1004955"> </a>
#define exgRegViewTypeID 0xff8e // MIME type registry <a name="1004956"> </a>
<a name="1004957"> </a>
ExgRegisterDatatype(...,exgRegViewExtensionID,...,...,...);<a name="1004958"> </a>
ExgRegisterDatatype(...,exgRegViewTypeID,...,...,...);<a name="1004959"> </a>
</pre><div class="CodeRule"><hr></div>

  <li><a name="1004961"> </a>Always check if your application is called in view mode by checking if <code>goToCreator</code> information is available (in the <a href="HLC_ExgMgrRef.html#1268710"><code>ExgSocketType</code></a> structure). 
  <li><a name="1004962"> </a>When applications receive data in view mode, the data should be stored temporarily and not automatically accepted into the application database. Instead, the user should be given the option to save the data. To save memory space, temporary data should be removed before the application exists.
  <li><a name="1004963"> </a>Applications that support view mode must provide an option to return to the messaging application (for example, a Done button). Returning to the messaging application must be implemented by actively launching the messaging application (with <code>SysUIAppSwitch()</code> or the <code>AppLaunchWithCommand()</code> macro), using the GoTo information provided by the messaging application. 
</ul>
<h3 class="hbH3">
  <a name="1003821"> </a>Sending an Attachment from a Messaging Application <a href="#994958"><span class="nav">^TOP^</span></a>
</h3>


<p><a name="1005094"> </a>Traditionally, when the user composes a message, messaging applications provide an option to select a document and attach it to the outgoing message. This has not been straightforward on Palm Powered devices in the past, since the Palm OS doesn't provide a file system. These guidelines define a standard way to implement this feature using the Exchange Manager's Get mechanism. This mechanism isn't limited to attachment support, but rather defines a general import mechanism. </p>

<p><a name="1005096"> </a>The process of selecting an attachment includes two steps:</p>
<ol type="1">
  <li value="1"><a name="1005097"> </a>Let the user select the application where the data is stored.
  <li value="2"><a name="1005098"> </a>Launch this application and let the user pick from a list of data objects. 
</ol>

<p><a name="1005100"> </a>The idea is to enable users to perform a data lookup by application (in contrast to a path lookup on other platforms). This fits the Palm OS model where data is associated with one particular application. The application that stores the data is responsible for providing the user interface in step 2. This makes it possible to present a user interface that is optimized for that particular data type. For instance, a calendar application can present information in an appropriate calendar context rather then as a simple list, allowing for a better user experience. </p>

<p><a name="1005118"> </a>The Get mechanism requires implementation for both the messaging application as well as the display application. Although the Get mechanism has been available since Palm OS 4, it hasn't been widely used yet by applications, due to lack of guidelines and usage scenarios. However, with more and more applications supporting the exchange of native file formats across different platforms, this situation will change rapidly. </p>

<p><a name="1005120"> </a>To leverage the existing Get mechanism for the purpose of supporting attachments, a new <code>_get</code> exchange scheme has been defined (similar to <code>_local</code> or <code>_send</code>). Display applications must register this scheme with the Exchange Manager to let other applications know that they support the Get mechanism. </p>

<p><a name="1004590"> </a><a href="HLC_ExgMgrConcept.html#1005150">Figure 4.5</a> shows the interaction between the applications and the Exchange Manager.</p>

<p class="FFigureCaption">
  <a name="1005150"> </a><b>Figure 4.5&nbsp;&nbsp;Sending attachment from messaging application</b>
</p>
<div align="left"><img src="images/AttachingWithGet5.jpg" height="592" width="624" border="0" hspace="0" vspace="0">
</div>

<div><hr>
  <a name="1005180"> </a> <b>NOTE: </b> There are bugs in some versions of Palm OS that prevent using the Get mechanism as documented here. The Attachment Support sample code shows how to work around these problems. It is available in the Developer Knowledge Base at <a href="http://kb.palmsource.com/">http://kb.palmsource.com/</a> 
<hr>
</div>

<h4 class="hcH4">
  <a name="1005202"> </a>Guidelines for Messaging Applications
</h4>

<p><a name="1005339"> </a>To handle attachment sending, messaging applications should follow these guidelines:</p>
<ul type="disc">
  <li><a name="1005204"> </a>Messaging Applications must use the <code>_get</code> scheme to identify the available display applications that implement attachment support. 
  <li><a name="1005205"> </a>Messaging applications should offer a way to add multiple attachments to a message by repeating the attachment selection process. 
  <li><a name="1005206"> </a>Messaging application should never try to read/write directly from/to the databases of other applications. Database formats might change or databases might be encrypted. Using the Exchange Manager not only prevents database corruption by other applications but also ensures interoperability between 68K and ARM applications.
  <li><a name="1005207"> </a>Before calling <a href="HLC_ExgMgrRef.html#1269590"><code>ExgGet()</code></a>, messaging applications must: 
  <ul type="disc">
    <li><a name="1005208"> </a>allocate buffers for the <code>exgSocket.name</code>, <code>exgSocket.type</code>, and <code>exgSocket.description</code> fields. The size of these buffers are:
      <p><a name="1005209"> </a><code>description</code>: <code>exgMaxDescriptionLength + 1</code> </p>
      <p><a name="1005210"> </a><code>type</code>: <code>exgMaxTypeLength + 1</code> </p>
      <p><a name="1005211"> </a><code>name</code>: <code>exgMaxTypeLength + 1</code> (same as for type)</p>
    <li><a name="1005212"> </a>initialize all buffers with zeros
    <li><a name="1005213"> </a>set <code>exgSocket.name</code> to "_local:"
  </ul>
</ul>

<h4 class="hcH4">
  <a name="1005353"> </a>Guidelines for Display Applications
</h4>

<p><a name="1005322"> </a>To handle attachment sending from a messaging application, display applications should follow these guidelines:</p>
<ul type="disc">
  <li><a name="1005324"> </a>Applications must register the <code>_get</code> scheme with the Exchange Manager if they implement attachment support. Refer to <a href="HLC_ExgMgrConcept.html#995288">"General Registration Guidelines."</a>
  <li><a name="1005325"> </a>Applications must not send more then one data object for every <a href="HLC_ExgMgrRef.html#1269590"><code>ExgGet()</code></a> request. 
  <li><a name="1005326"> </a>When responding to a <code>sysAppLaunchCmdExgGetData</code> launch code, an application should copy the file name, type, and description information of the content into the supplied <code>exgSocket.name</code>, <code>exgSocket.type</code>, and <code>exgSocket.description</code> fields. Memory for these fields has been allocated by the calling application. The usable size of these fields is:
  <ul type="disc">
    <li><a name="1005327"> </a><code>name</code>: <code>exgMaxTypeLength</code> (same as type)
    <li><a name="1005328"> </a><code>type</code>: <code>exgMaxTypeLength</code>
    <li><a name="1005329"> </a><code>description</code>: <code>exgMaxDescriptionLength</code> 
   <p><a name="1005330"> </a>Applications should first check if memory was allocated (check for NULL pointers) before writing to the buffers. An application should never allocate or reallocate memory for these fields itself.</p>
   <p><a name="1005331"> </a>If the <code>exgSocket.name</code> field contains a scheme (for example, <code>"_local:"</code>), this scheme information should not be overwritten. Rather, name information should be appended to the scheme (for example, <code>"_local:myname.txt"</code>).</p>
  </ul>
  <li><a name="1005332"> </a>Display applications should provide a familiar document selection screen, similar to the document list users might see when they usually launch the display application. 
  <li><a name="1005333"> </a>When responding to a <code>sysAppLaunchCmdExgGetData</code> launch code, applications may support requests for a specific record (for example, via an application-specific URL scheme passed in the <code>name</code> field of the <a href="HLC_ExgMgrRef.html#1268710"><code>ExgSocketType</code></a> structure). Such a request should be handled without a user interface. 
</ul>

<p><a name="1014501"> </a>A display application may be launched with a full launch in response to a get request. This implementation is shown in detail in the Attachment Support sample code. It is available in the Developer Knowledge Base at <a href="http://kb.palmsource.com/">http://kb.palmsource.com/</a> </p>
<h3 class="hbH3">
  <a name="1005530"> </a>Sending an Attachment from a Display Application <a href="#994958"><span class="nav">^TOP^</span></a>
</h3>


<p><a name="1005535"> </a>Any display application should be able to send data to another device using any messaging application as a transport. For instance, a user could send a JPEG image from an image viewer to another person via email. This feature is implemented via the Exchange Manager using the <code>_send</code> URL scheme. Because the send capability is has been available since Palm OS 4, many existing display applications already support it. </p>

<h4 class="hcH4">
  <a name="1005531"> </a>Guidelines for Messaging Applications
</h4>

<p><a name="1005532"> </a>To handle attachment sending from a display application, messaging applications should follow these guidelines:</p>
<ul type="disc">
  <li><a name="1005516"> </a>Messaging applications must provide an exchange library that supports the <code>_send</code> URL scheme and register the scheme with the Exchange Manager (see <a href="HLC_ExgMgrConcept.html#995288">"General Registration Guidelines."</a>). Email applications will prompt the user for additional information (recipient information, subject line, etc.) and add the received data as an attachment to the message. 
  <li><a name="1005605"> </a>Messaging applications should be able to accept any content type to act as a transport mechanism.
</ul>

<h4 class="hcH4">
  <a name="1005674"> </a>Guidelines for Display Applications
</h4>

<p><a name="1005626"> </a>To handle attachment sending, display applications should follow these guidelines:</p>
<ul type="disc">
  <li><a name="1005628"> </a>Display applications must use the <code>_send</code> URL scheme to send data to the Exchange Manager. The Send mechanism is a general mechanism that provides the user with a choice of all the transport mechanisms available on the device that support the <code>_send</code> scheme (for example, Bluetooth, email, etc.).
   <p><a name="1005631"> </a>The sample code below shows how to send or beam data. The question mark in the <code>name</code> field means that on OS 4.0 and higher, it'll display a dialog to let the user choose which transport to use (for example, IR, Bluetooth, SMS, etc.).</p>

<div class="CodeRule"><hr></div><pre class="CodeBlock">
status_t err;<a name="1005633"> </a>
ExgSocketType exgSocket;<a name="1005634"> </a>
<a name="1005635"> </a>
// Fill out exgSocket with the description of the data and the<a name="1005636"> </a>
// package's "address"<a name="1005637"> </a>
MemSet(&amp;exgSocket, sizeof(exgSocket), 0);<a name="1005638"> </a>
exgSocket.description = "SuperApp data";<a name="1005639"> </a>
exgSocket.name = "?_send;_beam:SuperAppData.sad";<a name="1005640"> </a>
exgSocket.type = "application/x-superappdata";<a name="1005641"> </a>
<a name="1005642"> </a>
err = ExgPut(&amp;exgSocket); // open the connection<a name="1005644"> </a>
ExgSend(&amp;exgSocket, theData, theDataSize, &amp;err); // send the data<a name="1005645"> </a>
err = ExgDisconnect(&amp;exgSocket, err); // that's all!<a name="1005646"> </a>
</pre><div class="CodeRule"><hr></div>

  <li><a name="1005606"> </a>Display applications must set at least the type information (<code>exgSocket.type</code>). Name information (<code>exgSocket.name</code>), including file extension and description information (<code>exgSocket.description</code>), should also be provided. This allows messaging applications to format outgoing messages correctly, with the proper MIME content-type fields.
</ul>
<h3 class="hbH3">
  <a name="1005608"> </a>Email Application Guidelines <a href="#994958"><span class="nav">^TOP^</span></a>
</h3>


<p><a name="1005822"> </a>Email applications should follow these guidelines to support the <code>mailto</code> scheme and the helper APIs.</p>

<h4 class="hcH4">
  <a name="1005823"> </a>Support for Mailto URL Scheme
</h4>

<p><a name="1005983"> </a>Applications like a web browser must be able to launch an email application to start composing a new message. In contrast to the <code>_send</code> scheme, the <code>mailto</code> URL automatically implies email as a transport medium and allows applications to provide additional information, like recipients, subject line, etc.</p>

<p><a name="1005984"> </a>Therefore:</p>
<ul type="disc">
  <li><a name="1005826"> </a>Email applications must implement the <code>mailto</code> URL scheme and register the scheme with the Exchange Manager. For more information on the <code>mailto</code> scheme, see RFC 2368 at <a href="http://www.ietf.org/rfc/rfc2368.txt">http://www.ietf.org/rfc/rfc2368.txt</a> 
  <li><a name="1005827"> </a>The application must display the message content before a message is sent. This prevents malicious applications from sending uncontrolled spam without the user's knowledge.
</ul>

<h4 class="hcH4">
  <a name="1005829"> </a>Support for Helper API
</h4>

<p><a name="1005830"> </a>Messaging applications should register their services with the helper API as described in <a href="../Programming_Basics/Notifications.html#972327">"Helper Notifications"</a> in <i>Exploring Palm OS: Programming Basics</i>. In particular, email applications should support the mail service class.</p>

<h2 class="haH2">
  <a name="996189"> </a>Summary of Exchange Manager <a href="#994958"><span class="nav">^TOP^</span></a>
</h2>



<div class="tablediv"><table cellspacing="0" class="tTable">

  <tr valign="top">
    <th colspan="2" rowspan="1"><p class="tt"><a name="996192"> </a><b>Exchange Manager Functions</b></p>
    </th>
  </tr>
  <tr valign="top">
    <td><p class="tt"><a name="996196"> </a><b>Sending Data </b></p>
    </td>
    <td><p class="tt"><a name="996198"> </a><b></b></p>
    </td>
  </tr>
  <tr valign="top">
    <td><p class="tt"><a name="996203"> </a><a href="HLC_ExgMgrRef.html#1270444"><code>ExgSend()</code></a></p>
<p class="tt"><a name="996207"> </a><a href="HLC_ExgMgrRef.html#1270113"><code>ExgPut()</code></a></p>
    </td>
    <td><p class="tt"><a name="996212"> </a><a href="HLC_ExgMgrRef.html#1269343"><code>ExgDBWrite()</code></a><br></p>
    </td>
  </tr>
  <tr valign="top">
    <td><p class="tt"><a name="996214"> </a><b>Receiving Data </b></p>
    </td>
    <td><p class="tt"><a name="996216"> </a><b></b></p>
    </td>
  </tr>
  <tr valign="top">
    <td><p class="tt"><a name="996221"> </a><a href="HLC_ExgMgrRef.html#1270187"><code>ExgReceive()</code></a></p>
<p class="tt"><a name="996225"> </a><a href="HLC_ExgMgrRef.html#1283452"><code>ExgAccept()</code></a></p>
    </td>
    <td><p class="tt"><a name="996230"> </a><a href="HLC_ExgMgrRef.html#1269276"><code>ExgDBRead()</code></a></p>
<p class="tt"><a name="996231"> </a></p>
    </td>
  </tr>
  <tr valign="top">
    <td><p class="tt"><a name="996233"> </a><b>Registering for Data </b></p>
    </td>
    <td><p class="tt"><a name="996235"> </a><b></b></p>
    </td>
  </tr>
  <tr valign="top">
    <td><p class="tt"><a name="996240"> </a><a href="HLC_ExgMgrRef.html#1270252"><code>ExgRegisterDatatype()</code></a></p>
<p class="tt"><a name="996244"> </a><a href="HLC_ExgMgrRef.html#1270489"><code>ExgSetDefaultApplication()</code></a></p>
    </td>
    <td><p class="tt"><a name="996249"> </a><a href="HLC_ExgMgrRef.html#1270353"><code>ExgRegisterData()</code></a></p>
<p class="tt"><a name="996250"> </a></p>
    </td>
  </tr>
  <tr valign="top">
    <td><p class="tt"><a name="996252"> </a><b>Requesting Data </b></p>
    </td>
    <td><p class="tt"><a name="996254"> </a><b></b></p>
    </td>
  </tr>
  <tr valign="top">
    <td><p class="tt"><a name="996259"> </a><a href="HLC_ExgMgrRef.html#1269590"><code>ExgGet()</code></a></p>
    </td>
    <td><p class="tt"><a name="996264"> </a><a href="HLC_ExgMgrRef.html#1270381"><code>ExgRequest()</code></a></p>
    </td>
  </tr>
  <tr valign="top">
    <td><p class="tt"><a name="996266"> </a><b>Connecting and Disconnecting </b></p>
    </td>
    <td><p class="tt"><a name="996268"> </a><b></b></p>
    </td>
  </tr>
  <tr valign="top">
    <td><p class="tt"><a name="996273"> </a><a href="HLC_ExgMgrRef.html#1269394"><code>ExgDisconnect()</code></a></p>
    </td>
    <td><p class="tt"><a name="996278"> </a><a href="HLC_ExgMgrRef.html#1269073"><code>ExgConnect()</code></a></p>
    </td>
  </tr>
  <tr valign="top">
    <td><p class="tt"><a name="996280"> </a><b>Displaying the Exchange Dialog</b></p>
    </td>
    <td><p class="tt"><a name="996282"> </a><b></b></p>
    </td>
  </tr>
  <tr valign="top">
    <td><p class="tt"><a name="996287"> </a><a href="HLC_ExgMgrRef.html#1269493"><code>ExgDoDialog()</code></a></p>
    </td>
    <td><p class="tt"><a name="996289"> </a></p>
    </td>
  </tr>
  <tr valign="top">
    <td><p class="tt"><a name="996291"> </a><b>Obtaining Registry Information</b></p>
    </td>
    <td><p class="tt"><a name="996293"> </a><b></b></p>
    </td>
  </tr>
  <tr valign="top">
    <td><p class="tt"><a name="996298"> </a><a href="HLC_ExgMgrRef.html#1269811"><code>ExgGetTargetApplication()</code></a></p>
<p class="tt"><a name="996302"> </a><a href="HLC_ExgMgrRef.html#1269717"><code>ExgGetRegisteredApplications()</code></a></p>
    </td>
    <td><p class="tt"><a name="996307"> </a><a href="HLC_ExgMgrRef.html#1269768"><code>ExgGetRegisteredTypes()</code></a></p>
<p class="tt"><a name="996311"> </a><a href="HLC_ExgMgrRef.html#1269660"><code>ExgGetDefaultApplication()</code></a></p>
    </td>
  </tr>
  <tr valign="top">
    <td><p class="tt"><a name="996313"> </a><b>Querying the Exchange Library</b></p>
    </td>
    <td><p class="tt"><a name="996315"> </a><b></b></p>
    </td>
  </tr>
  <tr valign="top">
    <td><p class="tt"><a name="996320"> </a><a href="HLC_ExgMgrRef.html#1269178"><code>ExgControl()</code></a></p>
    </td>
    <td><p class="tt"><a name="996322"> </a></p>
    </td>
  </tr>
  <tr valign="top">
    <td><p class="tt"><a name="996324"> </a><b>For Exchange Library Use Only</b></p>
    </td>
    <td><p class="tt"><a name="996326"> </a><b></b></p>
    </td>
  </tr>
  <tr valign="top">
    <td><p class="tt"><a name="996331"> </a><a href="HLC_ExgMgrRef.html#1270008"><code>ExgNotifyReceive()</code></a></p>
<p class="tt"><a name="996335"> </a><a href="HLC_ExgMgrRef.html#1269936"><code>ExgNotifyPreview()</code></a></p>
    </td>
    <td><p class="tt"><a name="996340"> </a><a href="HLC_ExgMgrRef.html#1269880"><code>ExgNotifyGoto()</code></a><br></p>
    </td>
  </tr>
</table>

</div>
&nbsp;<br>
</div>
<!--END CONTENT-->

</td>
<td width="5">&nbsp;&nbsp;</td>
</tr>

</table>

<!-- BEGIN FOOTER -->
<table width="100%" border="0" cellspacing="0" cellpadding="0">
<tr>
<td width="7" rowspan="2"><img name="index_x" src="images/shim.gif" width="7" height="33" border="0" alt=""></td>
<td align="left"><img name="dashes" src="images/dashes.gif" width="744" height="3" border="0" alt=""></td>
<td width="10" rowspan="2"><img name="index_x" src="images/shim.gif" width="10" height="33" border="0" alt=""></td>
</tr>
<tr>
<td align="center">
<p class="footer">
Copyright © 1996&#8211;2004, PalmSource, Inc. and its affiliates. All rights reserved.<br>
<a href="http://www.palmsource.com/contact/">Write Us</a> | <a href="http://www.palmos.com/dev/training/">Training</a> | <a href="http://www.palmos.com/dev/support/kb/">Knowledge Base</a> | <a href="HLC_Front.html" target="_blank">Legal</a></p>
<br>
<!--BEGIN BOOK NAVIGATION-->
<p class="nav">
<A href="http://www.palmos.com/dev/support/docs/">Documentation</a>&nbsp;&nbsp;|&nbsp;&nbsp;
<a href="HLC_TOC.html">Table of Contents</a>&nbsp;&nbsp;
             |&nbsp;&nbsp;<a href="HLC_ExgMgrPart.html">&lt;&nbsp;Previous</a>&nbsp;&nbsp;
             |&nbsp;&nbsp;<a href="HLC_ExgMgrRef.html">Next&nbsp;&gt;</a>&nbsp;&nbsp;
             |&nbsp;&nbsp;<a href="HLC_IX.html">Index</a>
</p>
</td>
</tr>
</table>
<!-- END FOOTER -->

</body>
</html>