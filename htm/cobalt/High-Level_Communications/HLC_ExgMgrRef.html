<html>
<head>
<title>(Protein) Exchange Manager Reference | High-Level Communications</title> 
<link href="psi_devpubs.css" rel="stylesheet" type="text/css">

<!-- BEGIN META DATA -->
<meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
<META NAME="PSITEMPLATE" CONTENT="1006-007 PalmSource_HTML_2003 20041101">
<META NAME="GENERATOR" CONTENT="Quadralay WebWorks AutoMap 2003 for FrameMaker 8.0.6.2138">
<META NAME="LASTUPDATED" CONTENT="11/22/04 11:11:32">
<!-- END META DATA -->
</head>

<body bgcolor="#ffffff" text="#000000" leftmargin="0" topmargin="0" marginwidth="0" marginheight="0">
<a name="1322464"></a>

<!-- BEGIN TOPNAV -->
<table width="100%" border="0" cellspacing="0" cellpadding="0">
<tr>
<td><img src="images/shim.gif" width="7" height="75" border="0" alt=""></td>
<td align="left"><table border="0" cellpadding="0" cellspacing="0" width="744">
<tr>
<td><img name="index_r2_c1" src="images/shim.gif" width="25" height="75" border="0" alt=""></td>
<td valign="top"><table border="0" cellpadding="0" cellspacing="0" width="96">
<tr>
<td><img name="index_r2_c4" src="images/shim.gif" width="96" height="15" border="0" alt=""></td>
</tr>
<tr>
<td><a href="http://www.palmsource.com/"><img name="ps_logo" src="images/ps_logo.gif" width="96" height="54" border="0" alt=""></a></td>
</tr>

</table>
</td>

<td><table border="0" cellpadding="0" cellspacing="0" width="30">
<td><img name="index_x" src="images/shim.gif" width="30" height="75" border="0" alt=""></td>
</table></td>

<!--BEGIN MASTHEAD-->
<td><table border="0" cellpadding="0" cellspacing="0" width="96">
<tr>
<td><img name="index_x" src="images/shim.gif" width="615" height="5" border="0" alt=""></td>
</tr>
<tr>
<td>
<!--BEGIN BOOK NAVIGATION-->
<span class="nav">
<A href="http://www.palmos.com/dev/support/docs/">Documentation</a>&nbsp;&nbsp;|&nbsp;&nbsp;
<a href="HLC_TOC.html">Table of Contents</a>&nbsp;&nbsp;
             |&nbsp;&nbsp;<a href="HLC_ExgMgrConcept.html">&lt;&nbsp;Previous</a>&nbsp;&nbsp;
             |&nbsp;&nbsp;<a href="HLC_PDIPart.html">Next&nbsp;&gt;</a>&nbsp;&nbsp;
             |&nbsp;&nbsp;<a href="HLC_IX.html">Index</a>
</span>
<!--END BOOK NAVIGATION-->
</tr>
<tr>
<td>
<!--BEGIN PAGE TITLE-->
<h2 class="PageTitle">5 &nbsp;&nbsp;
Exchange Manager Reference</h2></td>
<!--END PAGE TITLE-->
</tr>
<tr>
<td>
<!--BEGIN BOOK TITLE-->
<p class="BookTitle">High-Level Communications</p>
<p class="SubTitle">Exploring Palm OS&#174; </p>
<!--END BOOK TITLE-->
</td>
</tr>
<tr>
<td><img name="index_x" src="images/shim.gif" width="615" height="5" border="0" alt=""></td>
</tr>
</table>
</td>
<!--END MASTHEAD-->
</tr>
</table>
<img name="dashes" src="images/dashes.gif" width="744" height="3" border="0" alt=""></td>
</tr>
</table>
<!-- END TOPNAV -->

<table width="100%" border="0" cellspacing="0" cellpadding="0">
<tr>
<td valign="top" width="5"><img name="index_x" src="images/shim.gif" width="5" height="33" border="0" alt=""></td>

<!--BEGIN SIDETOC-->
<td valign="top" width="175">
<div id="sidetoc" valign="bottom">
<h1 class="SideTOC1-PartTab"><a href="HLC_ExgMgrPart.html">Part II: Exchange Manager</a> </h1>
<h1 class="SideTOC1"><a href="HLC_ExgMgrRef.html">5  Exchange Manager Reference</a></h1>

   <h2 class="SideTOC2"><a href="#1268481">
   Exchange Manager Data Structures</a></h2>

      <h3 class="SideTOC3"><a href="#1328854">
      ExgAskParamType</a></h3>

      <h3 class="SideTOC3"><a href="#1311146">
      ExgCtlGetURLType</a></h3>

      <h3 class="SideTOC3"><a href="#1268515">
      ExgGoToType</a></h3>

      <h3 class="SideTOC3"><a href="#1268556">
      ExgLocalSocketInfoType</a></h3>

      <h3 class="SideTOC3"><a href="#1268619">
      ExgPreviewInfoType</a></h3>

      <h3 class="SideTOC3"><a href="#1268710">
      ExgSocketType</a></h3>

   <h2 class="SideTOC2"><a href="#1283810">
   Exchange Manager Constants</a></h2>

      <h3 class="SideTOC3"><a href="#1332410">
      ExgAskResultType</a></h3>

      <h3 class="SideTOC3"><a href="#1283812">
      Registry ID Constants</a></h3>

      <h3 class="SideTOC3"><a href="#1268906">
      Predefined URL Schemes</a></h3>

      <h3 class="SideTOC3"><a href="#1268943">
      Predefined URL Prefixes</a></h3>

   <h2 class="SideTOC2"><a href="#1325697">
   Exchange Manager Launch Codes</a></h2>

      <h3 class="SideTOC3"><a href="#1327297">
      sysAppLaunchCmdExgAskUser</a></h3>

      <h3 class="SideTOC3"><a href="#1327329">
      sysAppLaunchCmdExgGetData</a></h3>

      <h3 class="SideTOC3"><a href="#1328314">
      sysAppLaunchCmdExgPreview</a></h3>

      <h3 class="SideTOC3"><a href="#1327402">
      sysAppLaunchCmdExgReceiveData</a></h3>

   <h2 class="SideTOC2"><a href="#1268996">
   Exchange Manager Functions</a></h2>

      <h3 class="SideTOC3"><a href="#1283452">
      ExgAccept</a></h3>

      <h3 class="SideTOC3"><a href="#1269073">
      ExgConnect</a></h3>

      <h3 class="SideTOC3"><a href="#1269178">
      ExgControl</a></h3>

      <h3 class="SideTOC3"><a href="#1269276">
      ExgDBRead</a></h3>

      <h3 class="SideTOC3"><a href="#1269343">
      ExgDBWrite</a></h3>

      <h3 class="SideTOC3"><a href="#1269394">
      ExgDisconnect</a></h3>

      <h3 class="SideTOC3"><a href="#1269493">
      ExgDoDialog</a></h3>

      <h3 class="SideTOC3"><a href="#1269590">
      ExgGet</a></h3>

      <h3 class="SideTOC3"><a href="#1269660">
      ExgGetDefaultApplication</a></h3>

      <h3 class="SideTOC3"><a href="#1269717">
      ExgGetRegisteredApplications</a></h3>

      <h3 class="SideTOC3"><a href="#1269768">
      ExgGetRegisteredTypes</a></h3>

      <h3 class="SideTOC3"><a href="#1269811">
      ExgGetTargetApplication</a></h3>

      <h3 class="SideTOC3"><a href="#1269880">
      ExgNotifyGoto</a></h3>

      <h3 class="SideTOC3"><a href="#1269936">
      ExgNotifyPreview</a></h3>

      <h3 class="SideTOC3"><a href="#1270008">
      ExgNotifyReceive</a></h3>

      <h3 class="SideTOC3"><a href="#1270113">
      ExgPut</a></h3>

      <h3 class="SideTOC3"><a href="#1270187">
      ExgReceive</a></h3>

      <h3 class="SideTOC3"><a href="#1270252">
      ExgRegisterDatatype</a></h3>

      <h3 class="SideTOC3"><a href="#1270353">
      ExgRegisterData</a></h3>

      <h3 class="SideTOC3"><a href="#1270381">
      ExgRequest</a></h3>

      <h3 class="SideTOC3"><a href="#1270444">
      ExgSend</a></h3>

      <h3 class="SideTOC3"><a href="#1270489">
      ExgSetDefaultApplication</a></h3>

   <h2 class="SideTOC2"><a href="#1270534">
   Application-Defined Functions</a></h2>

      <h3 class="SideTOC3"><a href="#1270537">
      ExgDBDeleteProcPtr</a></h3>

      <h3 class="SideTOC3"><a href="#1270565">
      ExgDBReadProcPtr</a></h3>

      <h3 class="SideTOC3"><a href="#1270606">
      ExgDBWriteProcPtr</a></h3>

</div>
</td>

<td width="5">&nbsp;&nbsp;</td>
<td width="2" background="images/index_r8_c10.gif"><img src="images/shim.gif" width="2" height="75" border="0" alt=""></td>
<td width="5">&nbsp;&nbsp;</td>

<!--END SIDETOC-->

<td valign="top">

<!--BEGIN CONTENT-->
<div id="content" valign="bottom">
<p><a name="1268454"> </a>This chapter describes the Exchange Manager API declared in the header file <code>ExgMgr.h</code> and the Exchange Local Library API declared in the header file <code>ExgLocalLib.h</code>. It discusses the following topics: </p>
<ul type="disc">
  <li><a name="1268460"> </a><a href="HLC_ExgMgrRef.html#1268481">Exchange Manager Data Structures</a>
  <li><a name="1268464"> </a><a href="HLC_ExgMgrRef.html#1283810">Exchange Manager Constants</a>
  <li><a name="1327210"> </a><a href="HLC_ExgMgrRef.html#1325697">Exchange Manager Launch Codes</a>
  <li><a name="1268468"> </a><a href="HLC_ExgMgrRef.html#1268996">Exchange Manager Functions</a>
  <li><a name="1268472"> </a><a href="HLC_ExgMgrRef.html#1270534">Application-Defined Functions</a>
</ul>

<p><a name="1268473"> </a>For more information on the Exchange Manager, see <a href="HLC_ExgMgrConcept.html#994958">Chapter 4, "Object Exchange."</a></p>

<h2 class="haH2">
  <a name="1268481"> </a>Exchange Manager Data Structures <a href="#1322464"><span class="nav">^TOP^</span></a>
</h2>


<h3 class="hbH3">
  <a name="1328854"> </a>ExgAskParamType Struct <a href="#1322464"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="1328856"> </a>Purpose 
</h4>

<p><a name="1328857"> </a>The <code>ExgAskParamType</code> structure is the parameter block for the <a href="HLC_ExgMgrRef.html#1327297"><code>sysAppLaunchCmdExgAskUser</code></a> launch code.</p>
<h4>
  <a name="1333395"> </a>Declared In 
</h4>
<code>ExgMgr.h<a name="1333464"> </a></code><h4>
  <a name="1328861"> </a>Prototype 
</h4>
<pre class="proto"><a name="1329809"></a><code>typedef struct {
</code>   ExgSocketPtr socketP;
   ExgAskResultType result;
   uint8_t reserved;
   uint16_t padding_1;
} ExgAskParamType;
</pre>
<h4>
  <a name="1329688"> </a>Fields 
</h4>

<dl>
<dt><a name="1330094"> </a><code>&harr;  <i><code>socketP</code></i></code></dt>
<dd><a name="1330098"> </a>Socket pointer (see <a href="HLC_ExgMgrRef.html#1268710"><code>ExgSocketType</code></a>).</dd>

<dt><a name="1330099"> </a><code>&larr;  <i><code>result</code></i></code></dt>
<dd><a name="1330100"> </a>One of the <a href="HLC_ExgMgrRef.html#1332410"><code>ExgAskResultType</code></a> enumerated values.</dd>

<dt><a name="1330101"> </a><code>&rarr;  <i><code>reserved</code></i></code></dt>
<dd><a name="1330102"> </a>Reserved for future use.</dd>

<dt><a name="1330345"> </a><code>&rarr;  <i><code>padding_1</code></i></code></dt>
<dd><a name="1330346"> </a>Padding; not used.</dd>

</dl>

<h3 class="hbH3">
  <a name="1311146"> </a>ExgCtlGetURLType Struct <a href="#1322464"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="1311148"> </a>Purpose 
</h4>

<p><a name="1311149"> </a>The <code>ExgCtlGetURLType</code> structure identifies the URL of a remote device as returned by the <a href="HLC_ExgMgrRef.html#1269178"><code>ExgControl()</code></a>function with the <code>exgLibCtlGetURL</code> operation code.</p>
<h4>
  <a name="1335352"> </a>Declared In 
</h4>
<code>ExgMgr.h<a name="1335353"> </a></code><h4>
  <a name="1311158"> </a>Prototype 
</h4>
<pre class="proto"><a name="1314038"></a>typedef struct ExgCtlGetURLType{
   ExgSocketType *socketP;
   char *URLP;
   uint16_t URLSize;
   uint16_t padding;
} ExgCtlGetURLType;
</pre>
<h4>
  <a name="1311160"> </a>Fields 
</h4>

<dl>
<dt><a name="1311163"> </a><code>socketP</code></dt>
<dd><a name="1311165"> </a>Pointer to the socket structure (see <a href="HLC_ExgMgrRef.html#1268710"><code>ExgSocketType</code></a>).</dd>

<dt><a name="1311167"> </a><code>URLP</code></dt>
<dd><a name="1311169"> </a>Pointer to the URL string. </dd>

<dt><a name="1311171"> </a><code>URLSize</code></dt>
<dd><a name="1311173"> </a>Size of the URL string. </dd>

<dt><a name="1311175"> </a><code>padding</code></dt>
<dd><a name="1311177"> </a>Padding; not used.</dd>

</dl>

<h3 class="hbH3">
  <a name="1268515"> </a>ExgGoToType Struct <a href="#1322464"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="1284528"> </a>Purpose 
</h4>

<p><a name="1268516"> </a>The <code>ExgGoToType</code> structure defines the <code>goToParams</code> field of the <a href="HLC_ExgMgrRef.html#1268710"><code>ExgSocketType</code></a> structure. Applications that want to be launched after the data is received place their creator IDs in the <code>goToCreator</code> field and define the <code>goToParams</code> field. The values in this structure are copied to the <a href="../Programming_Basics/CmnLaunchCodes.html#993710"><code>sysAppLaunchCmdGoTo</code></a> launch code's parameter block.</p>
<h4>
  <a name="1335871"> </a>Declared In 
</h4>
<code>ExgMgr.h<a name="1335872"> </a></code><h4>
  <a name="1284519"> </a>Prototype 
</h4>
<pre class="proto"><a name="1268525"></a>typedef struct {
   LocalID dbID;
   uint32_t recordNum;
   uint32_t uniqueID;
   uint32_t matchCustom;
} ExgGoToType;
</pre>
<h4>
  <a name="1268532"> </a>Fields 
</h4>

<dl>
<dt><a name="1268539"> </a><code><code>dbID</code></code></dt>
<dd><a name="1268541"> </a>The local ID of the database that contains the added record.</dd>

<dt><a name="1268543"> </a><code><code>recordNum</code></code></dt>
<dd><a name="1268545"> </a>The index of the record that was added. </dd>

<dt><a name="1268547"> </a><code><code>uniqueID</code></code></dt>
<dd><a name="1268549"> </a>The unique ID of the record that was added. This field is not used. </dd>

<dt><a name="1268551"> </a><code><code>matchCustom </code></code></dt>
<dd><a name="1268553"> </a>Application-specific information.</dd>

</dl>

<h3 class="hbH3">
  <a name="1268556"> </a>ExgLocalSocketInfoType Struct <a href="#1322464"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="1284542"> </a>Purpose 
</h4>

<p><a name="1268558"> </a>The <code>ExgLocalSocketInfoType</code> structure identifies information specific to the Local Exchange Library. The <code>socketRef</code> field of the <a href="HLC_ExgMgrRef.html#1268710"><code>ExgSocketType</code></a> structure is set to this structure when you send and receive data using the Local Exchange Library. The Local Exchange Library creates this structure if it does not already exist. You only need to create it if you want to supply non-default values for the <code>noAsk</code> or <code>previewInfoP</code> fields.</p>
<h4>
  <a name="1295653"> </a>Declared In 
</h4>
<code>ExgLocalLib.h<a name="1295660"> </a></code><h4>
  <a name="1284537"> </a>Prototype 
</h4>
<pre class="proto"><a name="1268562"></a>typedef struct {
   Boolean freeOnDisconnect;
   Boolean noAsk;
   ExgPreviewInfoType *previewInfoP;
   void *tempFileH;
   status_t err;
   ExgLocalOpType op;
} ExgLocalSocketInfoType;
</pre>
<h4>
  <a name="1268571"> </a>Fields 
</h4>

<dl>
<dt><a name="1268574"> </a><code><code>freeOnDisconnect </code></code></dt>
<dd><a name="1268576"> </a>Determines whether the structure is freed when the <a href="HLC_ExgMgrRef.html#1269394"><code>ExgDisconnect()</code></a> call is made. The default is <code>true</code>. In general, code that allocates a structure should be responsible for freeing that structure. Therefore, if you have allocated <code>ExgLocalSocketInfoType</code>, you should set this field to <code>false</code> and explicitly free the structure when you are finished with it. </dd>

<dt><a name="1268581"> </a><code><code>noAsk </code></code></dt>
<dd><a name="1268583"> </a>Set to <code>true</code> to disable the display of the exchange dialog. For example, if you want to create a vCalendar object and send it to the Datebook application in response to a user command, you probably want to set <code>noAsk</code> to <code>true</code> so that the user does not have to confirm the receipt of the data they just requested you to send. </dd>

<dt><a name="1268585"> </a><code><code>previewInfoP </code></code></dt>
<dd><a name="1268591"> </a>A pointer to an <a href="HLC_ExgMgrRef.html#1268619"><code>ExgPreviewInfoType</code></a> structure. The preview feature is deprecated and is maintained only for backward compatibility. </dd>

<dt><a name="1268593"> </a><code><code>tempFileH</code> </code></dt>
<dd><a name="1268595"> </a>A temporary buffer that the Local Exchange Library uses. Do not set this field directly; the Local Exchange Library should set it. </dd>

<dt><a name="1268597"> </a><code><code>err</code> </code></dt>
<dd><a name="1268599"> </a>The error code returned from the Local Exchange Library. Do not set this field directly; the Local Exchange Library should set it. </dd>

<dt><a name="1268601"> </a><code><code>op</code> </code></dt>
<dd><a name="1268603"> </a>The operation in progress. Do not set this field directly. The Local Exchange Library sets this field to one of the following constants: </dd>

<dl>
<dt><a name="1268608"> </a><code><code>exgLocalOpNone</code> </code></dt>
<dd><a name="1282581"> </a>No operation in progress. </dd>

<dt><a name="1268610"> </a><code><code>exgLocalOpPut</code> </code></dt>
<dd><a name="1282587"> </a>A send is in progress. </dd>

<dt><a name="1268612"> </a><code><code>exgLocalOpAccept</code> </code></dt>
<dd><a name="1282288"> </a>A receive is in progress. </dd>

<dt><a name="1268614"> </a><code><code>exgLocalOpGet</code> </code></dt>
<dd><a name="1282593"> </a>A get is in progress. </dd>

<dt><a name="1268616"> </a><code><code>exgLocalOpGetSender</code> </code></dt>
<dd><a name="1282301"> </a>The library is receiving information from the sending application during a get operation.</dd>

</dl>
</dl>

<h3 class="hbH3">
  <a name="1268619"> </a>ExgPreviewInfoType Struct <a href="#1322464"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="1284557"> </a>Purpose 
</h4>

<p><a name="1268621"> </a>The <code>ExgPreviewInfoType</code> structure provides information to the <a href="HLC_ExgMgrRef.html#1269936"><code>ExgNotifyPreview()</code></a> function. The preview feature is deprecated and is maintained only for backward compatibility. Applications should no longer implement preview via this mechanism, but should follow the data viewing guidelines described in <a href="HLC_ExgMgrConcept.html#1003957">"Put with View Mode."</a></p>
<h4>
  <a name="1336330"> </a>Declared In 
</h4>
<code>ExgMgr.h<a name="1336331"> </a></code><h4>
  <a name="1284552"> </a>Prototype 
</h4>
<pre class="proto"><a name="1268626"></a>typedef struct {
   uint16_t version;
   uint16_t padding1;
   ExgSocketType *socketP;
   uint16_t op;
   uint16_t padding2;
   char *string;
   uint32_t size;
   RectangleType bounds;
   uint16_t types;
   uint16_t padding3;
   status_t error;
} ExgPreviewInfoType;
</pre>
<h4>
  <a name="1268636"> </a>Fields 
</h4>

<dl>
<dt><a name="1268639"> </a><code><code>version</code> </code></dt>
<dd><a name="1268641"> </a>Set this field to 0 to specify version 0 of this structure. </dd>

<dt><a name="1296010"> </a><code><code>padding1</code> </code></dt>
<dd><a name="1296027"> </a>Padding; not used.</dd>

<dt><a name="1268643"> </a><code><code>socketP</code> </code></dt>
<dd><a name="1268645"> </a>A pointer to the socket structure (see <a href="HLC_ExgMgrRef.html#1268710"><code>ExgSocketType</code></a>). The <code>name</code> field must identify the exchange library from which data should be received, and the <code>target</code> or <code>type</code> field should be defined as well. </dd>

<dt><a name="1268650"> </a><code><code>op</code> </code></dt>
<dd><a name="1268652"> </a>One of the following constants: </dd>

<dl>
<dt><a name="1268657"> </a><code><code>exgPreviewDialog</code></code></dt>
<dd><a name="1282314"> </a>Display a modal dialog containing the preview. This constant is only used in situations where one application launches another to display data. </dd>

<dt><a name="1268662"> </a><code><code>exgPreviewDraw</code></code></dt>
<dd><a name="1282319"> </a>The preview is a graphic. </dd>

<dt><a name="1268667"> </a><code><code>exgPreviewLongString</code></code></dt>
<dd><a name="1282324"> </a>The preview is a long string. </dd>

<dt><a name="1268672"> </a><code><code>exgPreviewQuery</code></code></dt>
<dd><a name="1282329"> </a>Ask the application which preview operations it supports. The answer is returned in the <code>types</code> field. If the application does not support any preview modes, the <code>error</code> field contains <code>exgErrNotSupported</code>. </dd>

<dt><a name="1268678"> </a><code><code>exgPreviewShortString</code></code></dt>
<dd><a name="1282334"> </a>The preview is a short string. </dd>

</dl>
<dt><a name="1296049"> </a><code><code>padding2</code> </code></dt>
<dd><a name="1296051"> </a>Padding; not used.</dd>

<dt><a name="1268680"> </a><code><code>string</code> </code></dt>
<dd><a name="1268682"> </a>A buffer into which the application places the string preview if <code>exgPreviewLongString</code> or <code>exgPreviewShortString</code> is specified in <code>op</code>. </dd>

<dt><a name="1268684"> </a><code><code>size</code> </code></dt>
<dd><a name="1268686"> </a>The allocated size of the <code>string</code> field. </dd>

<dt><a name="1268688"> </a><code><code>bounds</code> </code></dt>
<dd><a name="1268690"> </a>The bounds of the rectangle in which the application draws the graphic if <code>exgPreviewDraw</code> is specified in <code>op</code>. </dd>

<dt><a name="1268692"> </a><code><code>types</code> </code></dt>
<dd><a name="1268694"> </a>Upon return from an <code>exgPreviewQuery</code> operation, a bit field identifying the types of previews the application supports. </dd>

<dt><a name="1296249"> </a><code><code>padding3</code> </code></dt>
<dd><a name="1296251"> </a>Padding; not used.</dd>

<dt><a name="1268696"> </a><code><code>error</code> </code></dt>
<dd><a name="1268698"> </a>The error code returned from the application. If <code>errNone</code>, the preview operation was successful. </dd>

</dl>



<h3 class="hbH3">
  <a name="1268710"> </a>ExgSocketType Struct <a href="#1322464"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="1284567"> </a>Purpose 
</h4>

<p><a name="1268711"> </a>The <code>ExgSocketType</code> structure defines an Exchange Manager socket, which is passed to most Exchange Manager functions. The <code>ExgSocketPtr</code> type points to a <code>ExgSocketType</code> structure.</p>
<h4>
  <a name="1336587"> </a>Declared In 
</h4>
<code>ExgMgr.h<a name="1336588"> </a></code><h4>
  <a name="1284562"> </a>Prototype 
</h4>
<pre class="proto"><a name="1296368"></a>typedef struct ExgSocketTag {
   uint16_t libraryRef;
   uint16_t socketRefSize;
   uint32_t socketRef;
   uint32_t target;
   uint32_t count;
   uint32_t length;
   uint32_t time;
   uint32_t appData;
   uint32_t goToCreator;
   ExgGoToType goToParams;
   uint16_t localMode:1;
   uint16_t packetMode:1;
   uint16_t noGoTo:1;
   uint16_t noStatus:1;
   uint16_t preview:1;
   uint16_t cnvFrom68KApp:1;
   uint16_t acceptedSocket:1;
   uint16_t reserved:9;
   uint8_t componentIndex;
   uint8_t padding_1;
   char *description;
   char *type;
   char *name;
} ExgSocketType;
</pre>
<pre class="proto"><a name="1268732"></a>typedef ExgSocketTag *ExgSocketPtr;
</pre>

<p><a name="1268733"> </a>Note that when data is received, some of the fields in this structure may not have values. When you are sending data, it is recommended that you provide values for all of these fields, but you should not rely on receiving values for the fields marked optional. </p>
<h4>
  <a name="1268734"> </a>Fields 
</h4>

<dl>
<dt><a name="1268737"> </a><code><code>libraryRef</code></code></dt>
<dd><a name="1268739"> </a>The exchange library in use. When an application or library receives a socket, this field is already assigned. This is no longer used for ARM code development, but is kept for compatibility with 68K exchange libraries.</dd>

<dd><a name="1268743"> </a>When sending data, applications may identify the exchange library they want to connect with by providing a URL in the <code>name</code> field, and should use 0 for the <code>libraryRef</code> field. </dd>

<dt><a name="1296420"> </a><code><code>socketRefSize</code></code></dt>
<dd><a name="1296422"> </a>Size of the data block referenced by <code>socketRef</code>, if <code>socketRef</code> is a pointer to a data block. </dd>

<dt><a name="1268748"> </a><code><code>socketRef</code></code></dt>
<dd><a name="1268750"> </a>The connection identifier. This value is supplied by the exchange library when a connection is established. It contains any necessary library-specific data. For an ARM exchange library, this <i>must</i> be a single data block without pointer references to other blocks.</dd>

<dt><a name="1268752"> </a><code><code>target</code></code></dt>
<dd><a name="1268754"> </a>The creator ID of the application that should receive the message. </dd>

<dt><a name="1268756"> </a><code><code>count</code></code></dt>
<dd><a name="1268758"> </a>The number of objects in this connection, usually 1 (optional). </dd>

<dt><a name="1268760"> </a><code><code>length</code></code></dt>
<dd><a name="1268762"> </a>The total byte count for all objects being sent (optional).</dd>

<dt><a name="1268764"> </a><code><code>time</code></code></dt>
<dd><a name="1268766"> </a>The last modified time of object (optional).</dd>

<dt><a name="1268768"> </a><code><code>appData</code></code></dt>
<dd><a name="1268770"> </a>Application-specific information (optional). For an ARM exchange library, do <i>not</i> pass pointer values here; only the 32-bit value itself is safe.</dd>

<dt><a name="1268772"> </a><code><code>goToCreator</code></code></dt>
<dd><a name="1268774"> </a>The creator ID of the application to launch using the <a href="../Programming_Basics/CmnLaunchCodes.html#993710"><code>sysAppLaunchCmdGoTo</code></a> launch code after the item is received if <code>noGoTo</code> is 0. The value is assigned by the application that receives the object. See the Comments section in <a href="HLC_ExgMgrRef.html#1269394"><code>ExgDisconnect()</code></a> for more information. </dd>

<dt><a name="1268782"> </a><code><code>goToParams</code></code></dt>
<dd><a name="1268784"> </a>If <code>goToCreator</code> is specified, then this field contains data that is copied into the launch code's parameter block. See <a href="HLC_ExgMgrRef.html#1268515"><code>ExgGoToType</code></a>.</dd>

<dt><a name="1268789"> </a><code><code>localMode</code></code></dt>
<dd><a name="1268791"> </a>Deprecated; set to 0. To use local exchange, specify a URL with the <code>exgLocalPrefix</code>. (Note that this flag still works for backward compatibility.)</dd>

<dt><a name="1268794"> </a><code><code>packetMode</code></code></dt>
<dd><a name="1268796"> </a>Deprecated; set to 0.</dd>

<dt><a name="1268798"> </a><code><code>noGoTo</code> </code></dt>
<dd><a name="1268800"> </a>Set to 1 to disable launching the application with <a href="../Programming_Basics/CmnLaunchCodes.html#993710"><code>sysAppLaunchCmdGoTo</code></a>. The default is 0. </dd>

<dt><a name="1268806"> </a><code><code>noStatus</code> </code></dt>
<dd><a name="1268808"> </a>If <code>true</code>, the exchange library should not display a progress dialog. If <code>false</code>, the library can display a progress dialog. The default is <code>false</code>. </dd>

<dd><a name="1268812"> </a>The Exchange Manager sets and clears this bit at various times while data is received. Applications may also want to set this bit if they use the Local Exchange Library and want to prevent the progress dialog from being displayed during a send. </dd>

<dt><a name="1268814"> </a><code><code>preview</code> </code></dt>
<dd><a name="1268816"> </a>If <code>true</code>, a preview is in progress. The <a href="HLC_ExgMgrRef.html#1269936"><code>ExgNotifyPreview()</code></a> function sets this bit while the preview takes place and clears it when the preview is finished. Exchange libraries should not discard any data while a preview is in progress because the full data must be sent later if the receiving user accepts it. The preview feature is deprecated and is maintained only for backward compatibility.</dd>

<dt><a name="1297890"> </a><code><code>cnvFrom68KApp</code></code></dt>
<dd><a name="1297892"> </a>If set to 1, indicates that the socket was created by a 68K application. This lets the library know that it may need to convert some data (such as the <code>socketRef</code> data). </dd>

<dt><a name="1298233"> </a><code><code>acceptedSocket</code></code></dt>
<dd><a name="1298235"> </a>If set to 1, indicates that this socket was passed into <a href="HLC_ExgMgrRef.html#1283452"><code>ExgAccept()</code></a>.</dd>

<dt><a name="1268821"> </a><code><code>reserved</code></code></dt>
<dd><a name="1268823"> </a>Reserved system flags.</dd>

<dt><a name="1298310"> </a><code><code>componentIndex</code></code></dt>
<dd><a name="1298312"> </a>The Exchange Manager C++ component holding this socket (if any). Nonzero for valid sockets.</dd>

<dt><a name="1298330"> </a><code><code>padding_1</code></code></dt>
<dd><a name="1298332"> </a>Padding; not used.</dd>

<dt><a name="1268825"> </a><code><code>description</code></code></dt>
<dd><a name="1268827"> </a>A pointer to the text description of the object (optional). </dd>

<dt><a name="1268829"> </a><code><code>type</code></code></dt>
<dd><a name="1268831"> </a>A pointer to the MIME type of the object (optional). </dd>

<dt><a name="1268833"> </a><code><code>name</code></code></dt>
<dd><a name="1268835"> </a>The name of the object being sent. This can be a URL whose scheme identifies the exchange library to connect with. </dd>

<dd><a name="1268839"> </a>If the name has a colon, it is treated as a URL. </dd>

</dl>

<h2 class="haH2">
  <a name="1283810"> </a>Exchange Manager Constants <a href="#1322464"><span class="nav">^TOP^</span></a>
</h2>


<h3 class="hbH3">
  <a name="1332410"> </a>ExgAskResultType Enum <a href="#1322464"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="1332412"> </a>Purpose 
</h4>

<p><a name="1332414"> </a>The <code>ExgAskResultType</code> enum defines possible values for the <code>result</code> field of the <a href="HLC_ExgMgrRef.html#1328854"><code>ExgAskParamType</code></a> launch code parameter block.</p>
<h4>
  <a name="1333776"> </a>Declared In 
</h4>
<code>ExgMgr.h<a name="1333777"> </a></code><h4>
  <a name="1332418"> </a>Prototype 
</h4>
<pre class="proto"><a name="1332419"></a>typedef enum {
   exgAskDialog,
   exgAskOk,
   exgAskCancel
} ExgAskResultType;
</pre>
<h4>
  <a name="1333833"> </a>Constants 
</h4>

<dl>
<dt><a name="1333834"> </a><code><code>exgAskDialog </code></code></dt>
<dd><a name="1333835"> </a>The Exchange Manager should display a dialog that prompts the user to confirm the receipt of data. See <a href="HLC_ExgMgrRef.html#1269493"><code>ExgDoDialog()</code></a>. </dd>

<dt><a name="1333840"> </a><code><code>exgAskOk </code></code></dt>
<dd><a name="1333841"> </a>Accept the data.</dd>

<dt><a name="1333842"> </a><code><code>exgAskCancel </code></code></dt>
<dd><a name="1333843"> </a>Reject the data.</dd>

</dl>

<h3 class="hbH3">
  <a name="1283812"> </a>Registry ID Constants <a href="#1322464"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="1283813"> </a>Purpose 
</h4>

<p><a name="1336809"> </a>The registry ID constants are used in the Exchange Manager registry. Exchange libraries register for the URL prefixes they handle, and applications register for the types of data they receive. The registry ID constants specify which type of data is being registered for. </p>
<h4>
  <a name="1336789"> </a>Declared In 
</h4>
<code>ExgMgr.h<a name="1336790"> </a></code><h4>
  <a name="1336857"> </a>Constants 
</h4>

<dl>
<dt><a name="1336912"> </a><code>#define exgRegCreatorID 0xfffb</code></dt>
<dd><a name="1337290"> </a>Register for a creator ID. The <code>target</code> field of the <a href="HLC_ExgMgrRef.html#1268710"><code>ExgSocketType</code></a> contains the creator ID of the application that should receive the data. Typically, the application with the matching creator ID receives the data, but it is possible for one application to register for another's creator ID and receive data in its place. </dd>

<dt><a name="1336913"> </a><code>#define exgRegSchemeID 0xfffc</code></dt>
<dd><a name="1337583"> </a>Register for a URL scheme. Typically, only exchange libraries register for URL schemes. Applications can register for URL schemes, but they only receive the URL when <a href="HLC_ExgMgrRef.html#1270381"><code>ExgRequest()</code></a> is called. If the <code>name</code> field of the <code>ExgSocketType</code> contains a colon (:), the portion of the URL before the colon is the URL scheme. The default library registered for URLs with that scheme will handle the message. </dd>

<dt><a name="1336914"> </a><code>#define exgRegExtensionID 0xfffd</code></dt>
<dd><a name="1337876"> </a>Register for a filename extension. If the <code>name</code> field of the <code>ExgSocketType</code> contains a period (.), the portion of the name after the last period is the filename extension. The application registered to handle files of that extension will handle the message. </dd>

<dt><a name="1336915"> </a><code>#define exgRegTypeID 0xfffe</code></dt>
<dd><a name="1338166"> </a>Register for a MIME type. If the <code>type</code> field of the <code>ExgSocketType</code> contains a value, the application registered to receive that MIME type handles the message. </dd>

<dt><a name="1338457"> </a><code>#define exgRegDirectCreatorID 0xffeb</code></dt>
<dd><a name="1338760"> </a>Register for a creator ID for direct delivery. The <code>target</code> field of the <a href="HLC_ExgMgrRef.html#1268710"><code>ExgSocketType</code></a> contains the creator ID of the application that should directly receive the data instead of an email application. (This is used instead of the <code>exgUnwrap</code> flag and must <i>not</i> be used with it.)</dd>

<dt><a name="1338458"> </a><code>#define exgRegDirectExtensionID 0xffed</code></dt>
<dd><a name="1339053"> </a>Register for a filename extension for direct delivery. If the <code>name</code> field of the <code>ExgSocketType</code> contains a period (.), the portion of the name after the last period is the filename extension. The application registered to handle files of that extension will handle the message, instead of an email application. (This is used instead of the <code>exgUnwrap</code> flag and must <i>not</i> be used with it.)</dd>

<dt><a name="1338459"> </a><code>#define exgRegDirectTypeID 0xffee</code></dt>
<dd><a name="1337002"> </a>Register for a MIME type for direct delivery. If the <code>type</code> field of the <code>ExgSocketType</code> contains a value, the application registered to receive that MIME type handles the message instead of an email application. (This is used instead of the <code>exgUnwrap</code> flag and must <i>not</i> be used with it.)</dd>

<dt><a name="1339346"> </a><code>#define exgRegViewCreatorID 0xff8b</code></dt>
<dd><a name="1339677"> </a>Register for a creator ID for view mode. The <code>target</code> field of the <a href="HLC_ExgMgrRef.html#1268710"><code>ExgSocketType</code></a> contains the creator ID of an application that can be used to view the data. </dd>

<dt><a name="1339347"> </a><code>#define exgRegViewExtensionID 0xff8d</code></dt>
<dd><a name="1339970"> </a>Register for a filename extension for view mode. If the <code>name</code> field of the <code>ExgSocketType</code> contains a period (.), the portion of the name after the last period is the filename extension. The application registered to handle files of that extension can be used to view the data.</dd>

<dt><a name="1339348"> </a><code>#define exgRegViewTypeID 0xff8e</code></dt>
<dd><a name="1340260"> </a>Register for a MIME type. If the <code>type</code> field of the <code>ExgSocketType</code> contains a value, the application registered to receive that MIME type can be used to view the data.</dd>

</dl>

<h3 class="hbH3">
  <a name="1268906"> </a>Predefined URL Schemes <a href="#1322464"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="1340770"> </a>Purpose 
</h4>

<p><a name="1341213"> </a>The Exchange Manager provides these predefined URL schemes, for which exchange libraries can register.</p>
<h4>
  <a name="1340772"> </a>Declared In 
</h4>
<code>ExgMgr.h and ExgLocalLib.h<a name="1340773"> </a></code><h4>
  <a name="1340774"> </a>Constants 
</h4>

<dl>
<dt><a name="1341251"> </a><code>#define exgBeamScheme "_beam"</code></dt>
<dd><a name="1341581"> </a>The URL scheme for Beam commands. By default, the IR Library handles this scheme. </dd>

<dt><a name="1341252"> </a><code>#define exgSendScheme "_send"</code></dt>
<dd><a name="1341591"> </a>The URL scheme for Send commands. The purpose of the Send command is to provide a choice of transport mechanisms to the user; therefore, any exchange library that sends data should register for this scheme. </dd>

<dt><a name="1341253"> </a><code>#define exgGetScheme "_get"</code></dt>
<dd><a name="1341603"> </a>The URL scheme for the Get mechanism. </dd>

<dt><a name="1341335"> </a><code>#define exgLocalScheme "_local"</code></dt>
<dd><a name="1341597"> </a>The URL scheme for the Local Exchange Library. </dd>

</dl>

<h3 class="hbH3">
  <a name="1268943"> </a>Predefined URL Prefixes <a href="#1322464"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="1342076"> </a>Purpose 
</h4>

<p><a name="1342708"> </a>The Exchange Manager provides these prefixes, which can be used to construct URLs appropriate for the <code>name</code> field of the <a href="HLC_ExgMgrRef.html#1268710"><code>ExgSocketType</code></a> structure. When sending data, applications provide a URL to identify the exchange library that should transport the data. </p>
<h4>
  <a name="1342078"> </a>Declared In 
</h4>
<code>ExgMgr.h<a name="1342079"> </a></code><h4>
  <a name="1342080"> </a>Constants 
</h4>

<dl>
<dt><a name="1342879"> </a><code>#define exgBeamPrefix exgBeamScheme ":"</code></dt>
<dd><a name="1343205"> </a>The URL to beam data. </dd>

<dt><a name="1342880"> </a><code>#define exgSendPrefix "?" exgSendScheme ":"</code></dt>
<dd><a name="1343674"> </a>A URL for the general Send command. Because this URL begins with a question mark (?), the Exchange Manager displays a dialog with a list of exchange libraries registered for the <code>exgSendScheme</code>. The user then chooses the desired exchange library. </dd>

<dt><a name="1342881"> </a><code>#define exgSendBeamPrefix "?" exgSendScheme ";" exgBeamScheme ":"</code></dt>
<dd><a name="1344292"> </a>A URL for the general Send command. The Exchange Manager displays a dialog with a list of exchange libraries registered for either the <code>exgSendScheme</code> or the <code>exgBeamScheme</code>. </dd>

<dt><a name="1342882"> </a><code>#define exgLocalPrefix exgLocalScheme ":"</code></dt>
<dd><a name="1344467"> </a>The URL for using the Local Exchange Library. </dd>

<dt><a name="1342883"> </a><code>#define exgGetPrefix exgGetScheme ":"</code></dt>
<dd><a name="1344913"> </a>The URL for using the Get mechanism. </dd>

</dl>

<h2 class="haH2">
  <a name="1325697"> </a>Exchange Manager Launch Codes <a href="#1322464"><span class="nav">^TOP^</span></a>
</h2>


<h3 class="hbH3">
  <a name="1327297"> </a>sysAppLaunchCmdExgAskUser <a href="#1322464"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="1327299"> </a>Purpose 
</h4>

<p><a name="1327300"> </a>The Exchange Manager sends this launch code to an application when data has arrived for that application. This launch code allows the application to tell the Exchange Manager not to display the exchange dialog, which it uses to have the user confirm the receipt of data. If the application does not handle this launch code, the default course of action is that the Exchange Manager displays the exchange dialog. </p>
<h4>
  <a name="1327301"> </a>Declared In 
</h4>
<code>CmnLaunchCodes.h<a name="1327302"> </a></code><h4>
  <a name="1327303"> </a>Prototype 
</h4>
<pre class="proto"><a name="1327304"></a>#define sysAppLaunchCmdExgAskUser 27


</pre>
<h4>
  <a name="1327305"> </a>Parameters 
</h4>

<p><a name="1328827"> </a>The launch code's parameter block pointer references a <a href="HLC_ExgMgrRef.html#1328854"><code>ExgAskParamType</code></a> structure.</p>
<h4>
  <a name="1328828"> </a>Comments 
</h4>

<p><a name="1327308"> </a>Applications may want to respond to this launch code under these circumstances: </p>
<ul type="disc">
  <li><a name="1327309"> </a>To reject all incoming data or to reject data under certain circumstances without first prompting the user. To reject incoming data, set the <code>result</code> field of the parameter block to <code>exgAskCancel</code> and then return. 
  <li><a name="1327311"> </a>To receive incoming data without confirmation. To automatically receive incoming data, set the result field to <code>exgAskOk</code>. 
  <li><a name="1327313"> </a>To provide a user confirmation dialog with extra functionality. This is described in more detail below. 
</ul>

<p><a name="1327314"> </a>The Exchange Manager allows applications to provide extra functionality in the exchange dialog. You can have the dialog include a category pop-up list from which the user chooses a category in which to file the incoming data. If you want to provide a category pop-up list, call the <a href="HLC_ExgMgrRef.html#1269493"><code>ExgDoDialog()</code></a> function in response to this launch code and pass it a database that contains the categories to be listed. See the description of this function for more information. </p>

<p><a name="1327316"> </a>Applications may also bypass the call to <code>ExgDoDialog()</code> altogether and provide their own dialogs. </p>

<p><a name="1327317"> </a>If an application responds to this launch code, it must set the <code>result</code> field in the parameter block to the appropriate value. Possible values are defined by the <a href="HLC_ExgMgrRef.html#1332410"><code>ExgAskResultType</code></a> enum.</p>

<p><a name="1327321"> </a>If you don't use the default version of the dialog, return <code>exgAskOk</code> if the user confirmed or <code>exgAskCancel</code> if the user canceled. If you don't set the <code>result</code> field properly, two dialogs are displayed.</p>
<h4>
  <a name="1327322"> </a>See Also 
</h4>

<p><a name="1327326"> </a><a href="HLC_ExgMgrRef.html#1328314"><code>sysAppLaunchCmdExgPreview</code></a>, and <a href="../Programming_Basics/CmnLaunchCodes.html#992934">Chapter 6, "Common Launch Codes,"</a> in <i>Exploring Palm OS: Programming Basics</i></p>

<h3 class="hbH3">
  <a name="1327329"> </a>sysAppLaunchCmdExgGetData <a href="#1322464"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="1327331"> </a>Purpose 
</h4>

<p><a name="1327332"> </a>The Exchange Manager sends this launch code when the exchange library requests data to be sent to a remote device. That is, an application on a remote device has called the <a href="HLC_ExgMgrRef.html#1269590"><code>ExgGet()</code></a> function to request data, and the Exchange Manager has determined that the launched application should handle the request. </p>
<h4>
  <a name="1327333"> </a>Declared In 
</h4>
<code>CmnLaunchCodes.h<a name="1327334"> </a></code><h4>
  <a name="1327335"> </a>Prototype 
</h4>
<pre class="proto"><a name="1327336"></a>#define sysAppLaunchCmdExgGetData 59


</pre>
<h4>
  <a name="1327337"> </a>Parameters 
</h4>

<p><a name="1327338"> </a>The parameter block sent with this launch code is a pointer to the <a href="HLC_ExgMgrRef.html#1268710"><code>ExgSocketType</code></a> structure corresponding to the Exchange Manager connection on which the data is to be sent. You pass this socket pointer to <a href="HLC_ExgMgrRef.html#1283452"><code>ExgAccept()</code></a>. For more details, see <a href="HLC_ExgMgrConcept.html#1013545">"Responding to a Get Request."</a></p>
<h4>
  <a name="1327349"> </a>Comments 
</h4>

<p><a name="1327350"> </a>To respond to this launch code, applications should accept a connection with <a href="HLC_ExgMgrRef.html#1283452"><code>ExgAccept()</code></a>, use <a href="HLC_ExgMgrRef.html#1270444"><code>ExgSend()</code></a> to send the data, and call <a href="HLC_ExgMgrRef.html#1269394"><code>ExgDisconnect()</code></a> when finished.</p>
<h4>
  <a name="1348222"> </a>See Also 
</h4>

<p><a name="1348228"> </a><a href="../Programming_Basics/CmnLaunchCodes.html#992934">Chapter 6, "Common Launch Codes,"</a> in <i>Exploring Palm OS: Programming Basics</i></p>

<h3 class="hbH3">
  <a name="1328314"> </a>sysAppLaunchCmdExgPreview <a href="#1322464"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="1328315"> </a>Purpose 
</h4>

<p><a name="1328319"> </a>Sent after <a href="HLC_ExgMgrRef.html#1327297"><code>sysAppLaunchCmdExgAskUser</code></a> to have the application display the preview in the exchange dialog.</p>
<h4>
  <a name="1327372"> </a>Declared In 
</h4>
<code>CmnLaunchCodes.h<a name="1327373"> </a></code><h4>
  <a name="1327374"> </a>Prototype 
</h4>
<pre class="proto"><a name="1327375"></a>#define sysAppLaunchCmdExgPreview 57


</pre>
<h4>
  <a name="1327376"> </a>Parameters 
</h4>

<p><a name="1327377"> </a>The launch code's parameter block pointer references a <a href="HLC_ExgMgrRef.html#1268619"><code>ExgPreviewInfoType</code></a> structure. </p>
<h4>
  <a name="1327378"> </a>Comments 
</h4>

<p><a name="1335288"> </a>This launch command is deprecated and is maintained only for backward compatibility. Applications should no longer implement preview via this mechanism, but should follow the data viewing guidelines described in <a href="HLC_ExgMgrConcept.html#1003957">"Put with View Mode."</a></p>
<h4>
  <a name="1348598"> </a>See Also 
</h4>

<p><a name="1348604"> </a><a href="../Programming_Basics/CmnLaunchCodes.html#992934">Chapter 6, "Common Launch Codes,"</a> in <i>Exploring Palm OS: Programming Basics</i></p>

<h3 class="hbH3">
  <a name="1327402"> </a>sysAppLaunchCmdExgReceiveData <a href="#1322464"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="1327404"> </a>Purpose 
</h4>

<p><a name="1327405"> </a>The Exchange Manager sends this launch code following the <a href="HLC_ExgMgrRef.html#1327297"><code>sysAppLaunchCmdExgAskUser</code></a> and <a href="HLC_ExgMgrRef.html#1328314"><code>sysAppLaunchCmdExgPreview</code></a> launch codes to notify the application that it should receive the data (assuming that the application or the user has indicated the data should be received).</p>
<h4>
  <a name="1327413"> </a>Declared In 
</h4>
<code>CmnLaunchCodes.h<a name="1327414"> </a></code><h4>
  <a name="1327415"> </a>Prototype 
</h4>
<pre class="proto"><a name="1327416"></a>#define sysAppLaunchCmdExgReceiveData 26


</pre>
<h4>
  <a name="1327417"> </a>Parameters 
</h4>

<p><a name="1328804"> </a>The parameter block sent with this launch code is a pointer to the <a href="HLC_ExgMgrRef.html#1268710"><code>ExgSocketType</code></a> structure corresponding to the Exchange Manager connection on which the data is arriving. Pass this pointer to the <a href="HLC_ExgMgrRef.html#1283452"><code>ExgAccept()</code></a> function to begin receiving the data. For more details, see <a href="HLC_ExgMgrConcept.html#995765">"Receiving the Data."</a></p>
<h4>
  <a name="1327428"> </a>Comments 
</h4>

<p><a name="1327429"> </a>The application should use Exchange Manager functions to receive the data and store it or do whatever it needs to with the data. Specifically, most applications should respond to this launch code by calling <a href="HLC_ExgMgrRef.html#1283452"><code>ExgAccept()</code></a> to accept the connection and then <a href="HLC_ExgMgrRef.html#1270187"><code>ExgReceive()</code></a> to receive the data. </p>

<p><a name="1327438"> </a>Note that the application may not be the active application, and thus may not have globals available when it is launched with this launch code. You can check if you have globals by using this code in the <a href="../Programming_Basics/AppMgr.html#994755"><code>PilotMain()</code></a> function:</p>

<div class="CodeRule"><hr></div><pre class="CodeBlock">
Boolean appIsActive = launchFlags &amp; sysAppLaunchFlagSubCall;<a name="1327442"> </a>
</pre><div class="CodeRule"><hr></div>


<p><a name="1327443"> </a>The <code>appIsActive</code> value is <code>true</code> if your application is active and globals are available; otherwise, you won't be able to access any of your global variables during the receive operation.</p>
<h4>
  <a name="1348611"> </a>See Also 
</h4>

<p><a name="1348617"> </a><a href="../Programming_Basics/CmnLaunchCodes.html#992934">Chapter 6, "Common Launch Codes,"</a> in <i>Exploring Palm OS: Programming Basics</i></p>

<h2 class="haH2">
  <a name="1268996"> </a>Exchange Manager Functions <a href="#1322464"><span class="nav">^TOP^</span></a>
</h2>


<h3 class="hbH3">
  <a name="1283452"> </a>ExgAccept Function <a href="#1322464"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="1283454"> </a>Purpose 
</h4>

<p><a name="1269001"> </a>Accepts a connection from a remote device.</p>
<h4>
  <a name="1269002"> </a>Declared In 
</h4>
<code>ExgMgr.h<a name="1269003"> </a></code><h4>
  <a name="1269004"> </a>Prototype 
</h4>
<pre class="proto"><a name="1269005"></a>status_t ExgAccept (
   ExgSocketPtr <code class="par">socketP</code>
)
</pre>
<h4>
  <a name="1269006"> </a>Parameters 
</h4>

<dl>
<dt><a name="1269007"> </a><code>&rarr;  <i><code>socketP</code></i></code></dt>
<dd><a name="1282599"> </a>A pointer to the socket structure (see <a href="HLC_ExgMgrRef.html#1268710"><code>ExgSocketType</code></a>). </dd>

</dl>
<h4>
  <a name="1269011"> </a>Returns 
</h4>

<p><a name="1269012"> </a>Returns one of the following error codes:</p>


<div class="tablediv"><table cellspacing="0" class="tTableNR">

  <tr valign="top">
    <td><p class="tt"><a name="1269015"> </a><!-PS02-><span style="color: #000000;  font-family: Courier; font-style: normal; font-weight: normal; text-decoration: none; text-transform: none; vertical-align: baseline">errNone</span></p>
    </td>
    <td><p class="tt"><a name="1269017"> </a>Success</p>
    </td>
  </tr>
  <tr valign="top">
    <td><p class="tt"><a name="1269019"> </a><code>exgErrBadLibrary</code></p>
    </td>
    <td><p class="tt"><a name="1269021"> </a>Couldn't find default exchange library</p>
    </td>
  </tr>
  <tr valign="top">
    <td><p class="tt"><a name="1269023"> </a><code>exgErrNotSupported</code> </p>
    </td>
    <td><p class="tt"><a name="1269025"> </a>A preview is in progress, and the exchange library doesn't support preview mode </p>
    </td>
  </tr>
</table>

</div>


<p><a name="1269027"> </a>Other error codes depend on the exchange library. </p>
<h4>
  <a name="1269029"> </a>Comments 
</h4>

<p><a name="1269030"> </a>Applications call this function when launched with the <a href="HLC_ExgMgrRef.html#1327402"><code>sysAppLaunchCmdExgReceiveData</code></a> or <a href="HLC_ExgMgrRef.html#1328314"><code>sysAppLaunchCmdExgPreview</code></a> launch code. The launch code contains <code>socketP</code> in its parameter block. Applications should pass this socket to <code>ExgAccept()</code> to accept the connection, then call <a href="HLC_ExgMgrRef.html#1270187"><code>ExgReceive()</code></a> one or more times to receive the data, and then call <a href="HLC_ExgMgrRef.html#1269394"><code>ExgDisconnect()</code></a> to disconnect.</p>

<div><hr>
  <a name="1269045"> </a> <b>NOTE: </b> Don't create the socket on the receiving side of an exchange. The socket is passed to you in the command parameter block of the <a href="HLC_ExgMgrRef.html#1327402"><code>sysAppLaunchCmdExgReceiveData</code></a> or <a href="HLC_ExgMgrRef.html#1328314"><code>sysAppLaunchCmdExgPreview</code></a> launch code.
<hr>
</div>
<h4>
  <a name="1269060"> </a>See Also 
</h4>

<p><a name="1269070"> </a><a href="HLC_ExgMgrRef.html#1269073"><code>ExgConnect()</code></a>, <a href="HLC_ExgMgrRef.html#1270113"><code>ExgPut()</code></a>, <a href="HLC_ExgMgrRef.html#1269590"><code>ExgGet()</code></a></p>

<h3 class="hbH3">
  <a name="1269073"> </a>ExgConnect Function <a href="#1322464"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="1269074"> </a>Purpose 
</h4>

<p><a name="1269075"> </a>Establishes a connection with a remote socket. </p>
<h4>
  <a name="1269076"> </a>Declared In 
</h4>
<code>ExgMgr.h<a name="1269077"> </a></code><h4>
  <a name="1269078"> </a>Prototype 
</h4>
<pre class="proto"><a name="1269079"></a>status_t ExgConnect (
   ExgSocketPtr <code class="par">socketP</code>
)
</pre>
<h4>
  <a name="1269080"> </a>Parameters 
</h4>

<dl>
<dt><a name="1269081"> </a><code>&rarr;  <i>socketP</i></code></dt>
<dd><a name="1282605"> </a>A pointer to the socket structure (see <a href="HLC_ExgMgrRef.html#1268710"><code>ExgSocketType</code></a>). Specify a URL in the <code>name</code> field and 0 for the <code>libraryRef</code> field. </dd>

</dl>
<h4>
  <a name="1269085"> </a>Returns 
</h4>

<p><a name="1269086"> </a>Returns one of the following error codes:</p>


<div class="tablediv"><table cellspacing="0" class="tTableNR">

  <tr valign="top">
    <td><p class="tt"><a name="1269089"> </a><code>errNone</code></p>
    </td>
    <td><p class="tt"><a name="1269091"> </a>Success</p>
    </td>
  </tr>
  <tr valign="top">
    <td><p class="tt"><a name="1269093"> </a><code>exgErrBadLibrary</code></p>
    </td>
    <td><p class="tt"><a name="1269095"> </a>Couldn't find exchange library</p>
    </td>
  </tr>
  <tr valign="top">
    <td><p class="tt"><a name="1269097"> </a><code>exgErrNotSupported</code> </p>
    </td>
    <td><p class="tt"><a name="1269099"> </a>The library doesn't support the operation specified in <code>socketP</code> </p>
    </td>
  </tr>
  <tr valign="top">
    <td><p class="tt"><a name="1269101"> </a><code>exgErrUserCancel</code> </p>
    </td>
    <td><p class="tt"><a name="1269103"> </a>The user cancelled the connection operation </p>
    </td>
  </tr>
  <tr valign="top">
    <td><p class="tt"><a name="1269105"> </a><code>exgMemError</code> </p>
    </td>
    <td><p class="tt"><a name="1269107"> </a>There isn't enough free memory to respond to the request</p>
    </td>
  </tr>
  <tr valign="top">
    <td><p class="tt"><a name="1269109"> </a><code>exgErrNotEnoughPower</code> </p>
    </td>
    <td><p class="tt"><a name="1269111"> </a>The battery does not have enough power to perform the operation </p>
    </td>
  </tr>
</table>

</div>


<p><a name="1269113"> </a>Other error codes depend on the exchange library. </p>
<h4>
  <a name="1269114"> </a>Comments 
</h4>

<p><a name="1285420"> </a>Applications can call this function to initiate a connection for sending multiple objects or for performing two-way communications. Some exchange libraries support sending multiple objects but do not support this call. See <a href="HLC_ExgMgrConcept.html#995548">"Sending Multiple Objects"</a> for more information. </p>

<p><a name="1285424"> </a>Before calling this function, the application must initialize the <code>socketP</code> parameter. The socket should identify the exchange library to connect with by providing a URL in the <code>name</code> field. The default exchange library registered for that type of URL handles the connection. </p>

<p><a name="1290344"> </a>To provide users with a choice of transport mechanisms, specify a URL that begins with a question mark (?). The Exchange Manager displays a dialog with a list of all exchange libraries that respond to URLs of the specified type. If only one exchange library is registered for this URL scheme, no dialog is displayed. </p>

<p><a name="1290345"> </a>For example, many applications support a Send command. This command generates a URL with the prefix <code>exgSendPrefix</code> (see <a href="HLC_ExgMgrRef.html#1268943">Predefined URL Prefixes</a>). The Exchange Manager displays a dialog containing a list of libraries registered for that URL scheme. The user selects an exchange library, and that library's <code>ExgLibConnect()</code> function is called. </p>

<p><a name="1269132"> </a>If the library is not specified by URL, the Exchange Manager by default uses the IR Library; however, if the <code>localMode</code> flag is set, the Local Exchange Library is used instead. </p>

<p><a name="1269133"> </a>In addition to specifying the library, you can set the <code>count</code> field in <code>socketP</code> before making this call to indicate the number of objects that are going to be sent. Use a <code>count</code> of 0 if the number of objects isn't known in advance. </p>

<p><a name="1269134"> </a>If no error is returned from <code>ExgConnect()</code>, applications can follow this call either by sending multiple objects or requesting data from the remote device or both. To send an object, call <a href="HLC_ExgMgrRef.html#1270113"><code>ExgPut()</code></a> at the beginning of each object and call <a href="HLC_ExgMgrRef.html#1270444"><code>ExgSend()</code></a> one or more times per object to send the data. To request data from the remote device, use <a href="HLC_ExgMgrRef.html#1269590"><code>ExgGet()</code></a> (and then use <a href="HLC_ExgMgrRef.html#1270187"><code>ExgReceive()</code></a> to receive the requested data). You can use these calls in combination with each other to support two-way communications. After all of the objects have been sent and received, call <a href="HLC_ExgMgrRef.html#1269394"><code>ExgDisconnect()</code></a> to disconnect. </p>

<div><hr>
  <a name="1269155"> </a> <b>IMPORTANT: </b> Not all exchange libraries support the sending of multiple objects or using <code>ExgGet()</code> to request data. 
<hr>
</div>
<h4>
  <a name="1269165"> </a>See Also 
</h4>

<p><a name="1269175"> </a><a href="HLC_ExgMgrRef.html#1270113"><code>ExgPut()</code></a>, <a href="HLC_ExgMgrRef.html#1283452"><code>ExgAccept()</code></a>, <a href="HLC_ExgMgrRef.html#1269590"><code>ExgGet()</code></a></p>

<h3 class="hbH3">
  <a name="1269178"> </a>ExgControl Function <a href="#1322464"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="1269179"> </a>Purpose 
</h4>

<p><a name="1269180"> </a>Requests that an exchange library perform an operation. </p>
<h4>
  <a name="1269181"> </a>Declared In 
</h4>
<code>ExgMgr.h<a name="1269182"> </a></code><h4>
  <a name="1269183"> </a>Prototype 
</h4>
<pre class="proto"><a name="1269184"></a>status_t ExgControl (
   ExgSocketType *<code class="par">socketP</code>,
   uint16_t <code class="par">op</code>,
   void *<code class="par">valueP</code>,
   uint16_t *<code class="par">valueLenP</code>
)
</pre>
<h4>
  <a name="1269185"> </a>Parameters 
</h4>

<dl>
<dt><a name="1269186"> </a><code>&rarr;  <i>socketP</i></code></dt>
<dd><a name="1282607"> </a>A pointer to the socket structure (see <a href="HLC_ExgMgrRef.html#1268710"><code>ExgSocketType</code></a>). Specify a URL in the <code>name</code> field and 0 for the <code>libraryRef</code> field. </dd>

<dt><a name="1269190"> </a><code>&rarr;  <i><code>op</code></i></code></dt>
<dd><a name="1282609"> </a>A constant identifying the operation that the exchange library should perform. See the Comments section for more information. </dd>

<dt><a name="1269191"> </a><code>&harr;  <i><code>valueP</code></i></code></dt>
<dd><a name="1282611"> </a>Upon entry, a parameter that the exchange library requires to perform the operation, if any. Most operations do not require an input parameter. Upon return, contains the result of the operation. </dd>

<dt><a name="1269192"> </a><code>&harr;  <i><code>valueLenP</code></i></code></dt>
<dd><a name="1282637"> </a>The size of the <code>valueP</code> buffer. The size is updated upon return to show the actual length of the content returned. </dd>

</dl>
<h4>
  <a name="1269193"> </a>Returns 
</h4>

<p><a name="1269194"> </a>Returns one of the following error codes:</p>


<div class="tablediv"><table cellspacing="0" class="tTableNR">

  <tr valign="top">
    <td><p class="tt"><a name="1269197"> </a><code>errNone</code></p>
    </td>
    <td><p class="tt"><a name="1269199"> </a>Success</p>
    </td>
  </tr>
  <tr valign="top">
    <td><p class="tt"><a name="1269201"> </a><code>exgErrBadLibrary</code></p>
    </td>
    <td><p class="tt"><a name="1269203"> </a>Couldn't find the requested exchange library</p>
    </td>
  </tr>
  <tr valign="top">
    <td><p class="tt"><a name="1269205"> </a><code>exgErrNotSupported</code></p>
    </td>
    <td><p class="tt"><a name="1269207"> </a>The exchange library does not support the requested operation </p>
    </td>
  </tr>
</table>

</div>


<p><a name="1269209"> </a>Other error codes depend on the exchange library. </p>
<h4>
  <a name="1269210"> </a>Comments 
</h4>

<p><a name="1269211"> </a>The Exchange Manager uses this function to request information from the exchange library. Applications may also call this function. </p>

<p><a name="1269212"> </a>The Exchange Manager defines and uses a set of operation constants that it might send to any exchange library. These constants begin with the prefix <code>exgLibCtlGet</code>. The type of the variable pointed to by <code>valueP</code> depends on the type of operation to be performed. <a href="HLC_ExgMgrRef.html#1269222">Table 5.1</a> lists and describes the predefined Exchange Manager operations. </p>

<p class="caption"><a name="1269222"> </a><b>Table 5.1&nbsp;&nbsp;ExgControl operations for all exchange libraries </b></p>
<div class="tablediv"><table cellspacing="0" class="tTable">

  <tr valign="top">
    <th><p class="tt"><a name="1269228"> </a><b>Operation exgLibCtlGet...</b></p>
    </th>
    <th><p class="tt"><a name="1269230"> </a><b>value Data Type</b></p>
    </th>
    <th><p class="tt"><a name="1269232"> </a><b>Description</b></p>
    </th>
  </tr>
  <tr valign="top">
    <td><p class="tt"><a name="1269235"> </a><code>Preview</code> </p>
    </td>
    <td><p class="tt"><a name="1269237"> </a>Boolean. Output only. </p>
    </td>
    <td><p class="tt"><a name="1269239"> </a>Returns <code>true</code> if the exchange library supports preview mode or <code>false</code> if not. If the exchange library does not respond to this operation, it is assumed to support preview mode. The preview feature is deprecated and is maintained only for backward compatibility.</p>
    </td>
  </tr>
  <tr valign="top">
    <td><p class="tt"><a name="1269242"> </a><code>Title</code></p>
    </td>
    <td><p class="tt"><a name="1269244"> </a>String buffer of size <code>exgTitleBufferSize</code> bytes. Output only. </p>
    </td>
    <td><p class="tt"><a name="1269247"> </a>Returns the name of the exchange library as it should appear in the Send dialog. All exchange libraries must respond to this operation. </p>
    </td>
  </tr>
  <tr valign="top">
    <td><p class="tt"><a name="1310992"> </a><code>URL</code></p>
    </td>
    <td><p class="tt"><a name="1310994"> </a><a href="HLC_ExgMgrRef.html#1311146"><code>ExgCtlGetURLType</code></a> structure.</p>
    </td>
    <td><p class="tt"><a name="1310997"> </a>Returns the URL that addresses the remote device from which you receive data. You can get the URL after calling <a href="HLC_ExgMgrRef.html#1283452"><code>ExgAccept()</code></a>.</p>
    </td>
  </tr>
  <tr valign="top">
    <td><p class="tt"><a name="1269250"> </a><code>Version</code></p>
    </td>
    <td><p class="tt"><a name="1269252"> </a><code>uint16_t</code>. Output only. </p>
    </td>
    <td><p class="tt"><a name="1269254"> </a>Returns the version of the exchange library API that this library implements. The constant <code>exgLibAPIVersion</code> defines the current version number. If the exchange library does not respond to this operation, the library supports the version of the Exchange Library API defined in Palm OS 4.0. </p>
    </td>
  </tr>
</table>

</div>


<p><a name="1269257"> </a>An exchange library may also define its own operations. Operations specific to an exchange library are numbered starting at <code>exgLibCtlSpecificOp</code>. </p>

<p><a name="1269265"> </a>The <code>socketP</code> passed to this function must identify an exchange library with a URL in the <code>name</code> field. The Comments section in <a href="HLC_ExgMgrRef.html#1269073"><code>ExgConnect()</code></a> describes how an application should identify the exchange library. </p>

<h3 class="hbH3">
  <a name="1269276"> </a>ExgDBRead Function <a href="#1322464"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="1269277"> </a>Purpose 
</h4>

<p><a name="1269278"> </a>Converts a Palm OS database from its internal format and writes it to storage RAM. </p>
<h4>
  <a name="1269279"> </a>Declared In 
</h4>
<code>ExgMgr.h<a name="1269280"> </a></code><h4>
  <a name="1269281"> </a>Prototype 
</h4>
<pre class="proto"><a name="1269282"></a>status_t ExgDBRead (
   ExgDBReadProcPtr <code class="par">readProcP</code>,
   ExgDBDeleteProcPtr <code class="par">deleteProcP</code>,
   void *<code class="par">userDataP</code>,
   DatabaseID *<code class="par">dbIDP</code>,
   Boolean *<code class="par">needResetP</code>,
   Boolean <code class="par">keepDates</code>
)
</pre>
<h4>
  <a name="1269283"> </a>Parameters 
</h4>

<dl>
<dt><a name="1269284"> </a><code>&rarr;  <i><code>readProcP</code></i></code></dt>
<dd><a name="1282663"> </a>A pointer to a function that reads in the database and passes it to <code>ExgDBRead()</code>. See <a href="HLC_ExgMgrRef.html#1270565"><code>ExgDBReadProcPtr()</code></a> for details.</dd>

<dt><a name="1269290"> </a><code>&rarr;  <i><code>deleteProcP</code></i></code></dt>
<dd><a name="1282685"> </a>A pointer to a function that is called if a database with an identical name already exists on the device. See <a href="HLC_ExgMgrRef.html#1270537"><code>ExgDBDeleteProcPtr()</code></a> for details.</dd>

<dt><a name="1269295"> </a><code>&rarr;  <i><code>userDataP</code></i></code></dt>
<dd><a name="1298396"> </a>A pointer to any data you want to pass to either the <code>readProcP</code> or <code>deleteProcP</code> functions. Often, this parameter is used to pass the <a href="HLC_ExgMgrRef.html#1268710"><code>ExgSocketType</code></a> that is required by many Exchange Manager functions. </dd>

<dt><a name="1298401"> </a><code>&larr;  <i><code>dbIDP</code></i></code></dt>
<dd><a name="1298402"> </a>The ID of the database that <code>ExgDBRead()</code> created on the local device.</dd>

<dt><a name="1269302"> </a><code>&larr;  <i><code>needResetP</code></i></code></dt>
<dd><a name="1282757"> </a>Set to <code>true</code> by <code>ExgDBRead()</code> if the <code>dmHdrAttrResetAfterInstall</code> attribute bit is set in the received database.</dd>

<dt><a name="1269303"> </a><code>&rarr;  <i><code>keepDates</code></i></code></dt>
<dd><a name="1282766"> </a>Specify <code>true</code> to retain the creation, modification, and last backup dates as set in the received database header. Specify <code>false</code> to reset these dates to the current date.</dd>

</dl>
<h4>
  <a name="1269304"> </a>Returns 
</h4>

<p><a name="1269305"> </a>Returns <code>errNone</code> if successful; otherwise, returns one of the data manager error codes (<code>dmErr...</code>) or a callback-specific error code. (If the <code>readProcP</code> function returns an error, it is also returned by <code>ExgDBRead()</code>.)</p>
<h4>
  <a name="1269307"> </a>Comments 
</h4>

<p><a name="1269308"> </a>This function converts data received from an exchange library or from any other transport mechanism into a Palm OS database and stores that database in the storage heap. It is not required that you use this function in conjunction with Exchange Manager calls. That is, it's possible to use this function to perform other operations, such as converting a database created on the desktop computer to a Palm OS formatted database in the storage heap.</p>

<p><a name="1269309"> </a>The primary use of this function, however, is to receive a database that has been beamed onto the device. In this case, call <code>ExgDBRead()</code> in response to the launch code <a href="HLC_ExgMgrRef.html#1327402"><code>sysAppLaunchCmdExgReceiveData</code></a> after calling <a href="HLC_ExgMgrRef.html#1283452"><code>ExgAccept()</code></a> to accept the connection. Place the call to <a href="HLC_ExgMgrRef.html#1270187"><code>ExgReceive()</code></a> in the read callback function you passed as the <code>readProcP</code> parameter. Pass the <a href="HLC_ExgMgrRef.html#1268710"><code>ExgSocketType</code></a> structure returned from <code>ExgAccept()</code> in the <code>userDataP</code> parameter so that you have access to it in the read callback function. </p>

<p><a name="1299619"> </a>The read callback function performs the actual reading of data. <code>ExgDBRead()</code> calls the read callback function multiple times. Each time, the <code>sizeP</code> parameter contains the number of bytes <code>ExgDBRead()</code> expects the data returned in <code>dataP</code> to contain. It's important for the read callback function to set the number of bytes (in <code>sizeP</code>) that it actually placed in <code>dataP</code> if it's not the same as what <code>ExgDBRead</code> expected. <code>ExgDBRead()</code> stops calling the read callback function after 0 is returned in <code>sizeP</code>.</p>

<p><a name="1269326"> </a>The callback function you pass in <code>deleteProcP</code> handles the case where the database being read already exists on the device. It is called only in that circumstance. The callback function may want to close the database if it is open, change the existing database's name, or delete the existing database to allow an overwrite. See <a href="HLC_ExgMgrRef.html#1270537"><code>ExgDBDeleteProcPtr()</code></a> for more information. </p>
<h4>
  <a name="1269336"> </a>See Also 
</h4>

<p><a name="1269340"> </a><a href="HLC_ExgMgrRef.html#1269343"><code>ExgDBWrite()</code></a></p>

<h3 class="hbH3">
  <a name="1269343"> </a>ExgDBWrite Function <a href="#1322464"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="1269344"> </a>Purpose 
</h4>

<p><a name="1269345"> </a>Converts a given Palm OS database from its internal format on the local device and writes it using a function you supply. </p>
<h4>
  <a name="1269346"> </a>Declared In 
</h4>
<code>ExgMgr.h<a name="1269347"> </a></code><h4>
  <a name="1269348"> </a>Prototype 
</h4>
<pre class="proto"><a name="1299126"></a>status_t ExgDBWrite (
   ExgDBWriteProcPtr <code class="par">writeProcP</code>,
   void *<code class="par">userDataP</code>,
   const char *<code class="par">nameP</code>,
   DatabaseID <code class="par">dbID</code>
)
</pre>
<h4>
  <a name="1299127"> </a>Parameters 
</h4>

<dl>
<dt><a name="1269352"> </a><code>&rarr;  <i><code>writeProcP</code></i></code></dt>
<dd><a name="1282768"> </a>A pointer to a function that writes out the database identified by <code>dbID</code>. See <a href="HLC_ExgMgrRef.html#1270606"><code>ExgDBWriteProcPtr()</code></a> for details.</dd>

<dt><a name="1269357"> </a><code>&rarr;  <i><code>userDataP</code></i></code></dt>
<dd><a name="1282774"> </a>A pointer to any data you want to pass to the <code>writeProcP</code> function. Often, this parameter is used to pass the <a href="HLC_ExgMgrRef.html#1268710"><code>ExgSocketType</code></a> that is required by many Exchange Manager functions. </dd>

<dt><a name="1269362"> </a><code>&rarr;  <i><code>nameP</code></i></code></dt>
<dd><a name="1282776"> </a>A pointer to the name of the database that you want <code>ExgDBWrite()</code> to write. This database is passed to <code>writeProcP</code>.</dd>

<dt><a name="1269363"> </a><code>&rarr;  <i><code>dbID</code></i></code></dt>
<dd><a name="1282784"> </a>The ID of the database that you want <code>ExgDBWrite()</code> to pass to <code>writeProcP</code>. If you don't supply an ID, then <code>nameP</code> is used to search for the database by name.</dd>

</dl>
<h4>
  <a name="1269365"> </a>Returns 
</h4>

<p><a name="1269366"> </a>Returns <code>errNone</code> if successful; otherwise, returns one of the data manager error codes (<code>dmErr...</code>) or a callback-specific error code. (If the <code>writeProcP</code> function returns an error, it is also returned by <code>ExgDBWrite()</code>.)</p>
<h4>
  <a name="1269367"> </a>Comments 
</h4>

<p><a name="1269368"> </a>This function converts a Palm OS formatted database on the storage heap into a stream of bytes that can be sent over the Internet or over any other transport mechanism. It is not required that you use this function in conjunction with Exchange Manager calls. </p>

<p><a name="1269369"> </a>The primary use of this function, however, is to write a database that is going to be beamed onto another device. In this case, call <code>ExgDBWrite()</code> after establishing the connection with <a href="HLC_ExgMgrRef.html#1270113"><code>ExgPut()</code></a>. Place the call to <a href="HLC_ExgMgrRef.html#1270444"><code>ExgSend()</code></a> in the write callback function you passed as the <code>writeProcP</code> parameter. Pass the <a href="HLC_ExgMgrRef.html#1268710"><code>ExgSocketType</code></a> structure returned from <code>ExgSend()</code> in the <code>userDataP</code> parameter so that you have access to it in the write callback function. </p>

<p><a name="1269381"> </a>The write callback function performs the actual writing of data. <code>ExgDBWrite()</code> calls the write callback function multiple times. Each time, the <code>sizeP</code> parameter contains the number of bytes of <code>dataP</code> that are to be written. If the write callback function didn't handle it all, it's important that it set in <code>sizeP</code> the number of bytes that it did handle successfully. <code>ExgDBWrite()</code> stops calling the write callback function after 0 is returned in <code>sizeP</code>.</p>
<h4>
  <a name="1269387"> </a>See Also 
</h4>

<p><a name="1269391"> </a><a href="HLC_ExgMgrRef.html#1269276"><code>ExgDBRead()</code></a></p>

<h3 class="hbH3">
  <a name="1269394"> </a>ExgDisconnect Function <a href="#1322464"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="1269395"> </a>Purpose 
</h4>

<p><a name="1269396"> </a>Terminates an Exchange Manager transfer and disconnects.</p>
<h4>
  <a name="1269397"> </a>Declared In 
</h4>
<code>ExgMgr.h<a name="1269398"> </a></code><h4>
  <a name="1269399"> </a>Prototype 
</h4>
<pre class="proto"><a name="1269400"></a>status_t ExgDisconnect (
   ExgSocketPtr <code class="par">socketP</code>,
   status_t <code class="par">error</code>
)
</pre>
<h4>
  <a name="1269401"> </a>Parameters 
</h4>

<dl>
<dt><a name="1269402"> </a><code>&rarr;  <i><code>socketP</code></i></code></dt>
<dd><a name="1282804"> </a>A pointer to the socket structure (see <a href="HLC_ExgMgrRef.html#1268710"><code>ExgSocketType</code></a>) identifying the connection to terminate. </dd>

<dt><a name="1269406"> </a><code>&rarr;  <i><code>error</code></i></code></dt>
<dd><a name="1282814"> </a>Any error that occurred. This parameter tells the exchange library why the connection is being broken. Normally the error code from <a href="HLC_ExgMgrRef.html#1270444"><code>ExgSend()</code></a> or <a href="HLC_ExgMgrRef.html#1270187"><code>ExgReceive()</code></a> is passed in here. </dd>

</dl>
<h4>
  <a name="1269413"> </a>Returns 
</h4>

<p><a name="1269414"> </a>Returns one of the following error codes:</p>


<div class="tablediv"><table cellspacing="0" class="tTableNR">

  <tr valign="top">
    <td><p class="tt"><a name="1269417"> </a><code>errNone</code> </p>
    </td>
    <td><p class="tt"><a name="1269419"> </a>Success</p>
    </td>
  </tr>
  <tr valign="top">
    <td><p class="tt"><a name="1269421"> </a><code>exgErrBadLibrary</code></p>
    </td>
    <td><p class="tt"><a name="1269423"> </a>Couldn't find default exchange library</p>
    </td>
  </tr>
  <tr valign="top">
    <td><p class="tt"><a name="1269425"> </a><code>exgMemError</code></p>
    </td>
    <td><p class="tt"><a name="1269427"> </a>Couldn't read data to send</p>
    </td>
  </tr>
  <tr valign="top">
    <td><p class="tt"><a name="1269429"> </a><code>exgErrUserCancel</code></p>
    </td>
    <td><p class="tt"><a name="1269431"> </a>User cancelled transfer</p>
    </td>
  </tr>
</table>

</div>


<p><a name="1269433"> </a>Other error codes depend on the exchange library. </p>
<h4>
  <a name="1269435"> </a>Comments 
</h4>

<p><a name="1269436"> </a>Applications must call this function when finished sending data or receiving data. It terminates the connection made with <a href="HLC_ExgMgrRef.html#1269073"><code>ExgConnect()</code></a>, <a href="HLC_ExgMgrRef.html#1283452"><code>ExgAccept()</code></a>, <a href="HLC_ExgMgrRef.html#1270113"><code>ExgPut()</code></a>, or <a href="HLC_ExgMgrRef.html#1269590"><code>ExgGet()</code></a>. </p>

<p><a name="1269453"> </a>In the <code>error</code> parameter, pass any error that occurs during the application loop, including errors returned from other Exchange Manager functions. This ensures that the connection is shut down knowing that it failed rather than succeeded.</p>

<p><a name="1269454"> </a>It's especially important to check the result code from this function, since this will tell you if the transfer was successful. An <code>errNone</code> return value means that the item was delivered to the destination successfully. It does not mean that the user on the other end actually kept the data. </p>

<p><a name="1269455"> </a><code>ExgDisconnect()</code> is used after sending and receiving. When receiving, the application can insert its creator ID into the <code>goToCreator</code> field in the socket structure and add other goto information in the <code>goToParams</code> field. After the application returns from the <a href="HLC_ExgMgrRef.html#1327402"><code>sysAppLaunchCmdExgReceiveData</code></a> launch code, the exchange library may call <a href="HLC_ExgMgrRef.html#1269880"><code>ExgNotifyGoto()</code></a>, which launches the <code>goToCreator</code> application with the standard launch code <a href="../Programming_Basics/CmnLaunchCodes.html#993710"><code>sysAppLaunchCmdGoTo</code></a>.</p>

<div><hr>
  <a name="1269468"> </a> <b>IMPORTANT: </b> Placing your creator ID in the <code>goToCreator</code> field is not a guarantee that you receive this launch code, because Palm OS supports the sending of multiple objects at once. Thus, another application might overwrite the <code>goToCreator</code> field after your application has disconnected, making that application the recipient of the launch code. 
<hr>
</div>

<p><a name="1269469"> </a>Note that some exchange libraries wait to establish a connection until <code>ExgDisconnect()</code> is called. The IR Library, for example, buffers the data that it receives and then waits until <code>ExgDisconnect()</code> to actually send this data unless <code>ExgConnect()</code> is called to establish a multi-object send connection. </p>

<p><a name="1291659"> </a>The Exchange Manager does not automatically launch the <code>goToCreator</code> application, if one was provided, upon return from this function. Exchange libraries that want this behavior must explicitly call <a href="HLC_ExgMgrRef.html#1269880"><code>ExgNotifyGoto()</code></a>. </p>
<h4>
  <a name="1269483"> </a>See Also 
</h4>

<p><a name="1269490"> </a><a href="HLC_ExgMgrRef.html#1270187"><code>ExgReceive()</code></a>, <a href="HLC_ExgMgrRef.html#1270444"><code>ExgSend()</code></a></p>

<h3 class="hbH3">
  <a name="1269493"> </a>ExgDoDialog Function <a href="#1322464"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="1269494"> </a>Purpose 
</h4>

<p><a name="1269495"> </a>Displays a dialog that allows users to accept or reject the receipt of data. </p>
<h4>
  <a name="1269496"> </a>Declared In 
</h4>
<code>ExgMgr.h<a name="1269497"> </a></code><h4>
  <a name="1269498"> </a>Prototype 
</h4>
<pre class="proto"><a name="1269499"></a>Boolean ExgDoDialog (
   ExgSocketType *<code class="par">socketP</code>,
   ExgDialogInfoType *<code class="par">infoP</code>,
   status_t *<code class="par">errP</code>
)
</pre>
<h4>
  <a name="1269500"> </a>Parameters 
</h4>

<dl>
<dt><a name="1269501"> </a><code>&rarr;  <i><code>socketP</code></i></code></dt>
<dd><a name="1282826"> </a>A pointer to the socket structure (see <a href="HLC_ExgMgrRef.html#1268710"><code>ExgSocketType</code></a>) identifying the connection.</dd>

<dd><a name="1269505"> </a>Applications can obtain the socket structure from the <a href="HLC_ExgMgrRef.html#1327297"><code>sysAppLaunchCmdExgAskUser</code></a> launch code parameter block. </dd>

<dt><a name="1269511"> </a><code>&harr;  <i><code>infoP</code></i></code></dt>
<dd><a name="1282886"> </a>A pointer to an <code>ExgDialogInfoType</code> structure (see the Comments section below). </dd>

<dt><a name="1269513"> </a><code>&larr;  <i><code>errP</code></i></code></dt>
<dd><a name="1282914"> </a><code>errNone</code> if no error, or the error code if an error occurred. Currently, no errors are returned.</dd>

</dl>
<h4>
  <a name="1269514"> </a>Returns 
</h4>

<p><a name="1269515"> </a>Returns <code>true</code> if the user clicks the OK button on the dialog, or <code>false</code> otherwise. </p>
<h4>
  <a name="1269516"> </a>Comments 
</h4>

<p><a name="1269517"> </a>This function displays the exchange dialog, which prompts the user to accept or reject incoming data. </p>

<p><a name="1269518"> </a>By default, the Exchange Manager calls this function if the receiving application doesn't handle the <a href="HLC_ExgMgrRef.html#1327297"><code>sysAppLaunchCmdExgAskUser</code></a> launch code or if it returns <code>exgAskDialog</code> from the launch code handler. When the Exchange Manager calls <code>ExgDoDialog()</code>, the dialog displays a message similar to "Do you want to accept 'John Doe' into Address Book?" and allows the user to accept or reject the data. If the user clicks OK, the data should be received as an unfiled record. </p>

<p><a name="1269523"> </a>The Exchange Manager attempts to display a preview of the data in the exchange dialog to provide users with enough information to determine if they want to accept or reject the data. To display the preview data, it calls <a href="HLC_ExgMgrRef.html#1269936"><code>ExgNotifyPreview()</code></a>. See the <code>ExgNotifyPreview()</code> function's description for more information.</p>

<p><a name="1269532"> </a>Applications may also want to allow users to select a category in which to accept the incoming data. To do so, handle <code>sysAppLaunchCmdExgAskUser</code> to call <code>ExgDoDialog()</code> directly and pass it a pointer to an <code>ExgDialogInfoType</code> structure. The <code>ExgDialogInfoType</code> structure is defined as follows: </p>

<p><a name="1364747"> </a></p>
<pre class="proto"><a name="1269533"></a>typedef struct {
  uint16_t version;
  DmOpenRef db;
  uint16_t categoryIndex;
} ExgDialogInfoType;
</pre>

<dl>
<dt><a name="1269539"> </a><code>&rarr;  <i><code>version</code></i></code></dt>
<dd><a name="1282916"> </a>Set this field to 0 to specify version 0 of this structure. </dd>

<dt><a name="1269540"> </a><code>&rarr;  <i><code>db</code></i></code></dt>
<dd><a name="1282918"> </a>A pointer to an open database that defines the categories the dialog should display. </dd>

<dt><a name="1269541"> </a><code>&larr;  <i><code>categoryIndex</code></i></code></dt>
<dd><a name="1282339"> </a>The index of the category in which the user wants to file the incoming data. </dd>

</dl>

<p><a name="1269542"> </a>If <code>db</code> is valid, the function extracts the category information from the specified database and displays it in a pop-up list. Upon return, the <code>categoryIndex</code> field contains the index of the category the user selected, or <code>dmUnfiledCategory</code> if the user did not select a category. </p>

<p><a name="1269544"> </a>If the call to <code>ExgDoDialog()</code> is successful, your application is responsible for retaining the value returned in <code>categoryIndex</code> and using it to file the incoming data as a record in that category. One way to do this is to store the <code>categoryIndex</code> in the socket's <code>appData</code> field (see <a href="HLC_ExgMgrRef.html#1268710"><code>ExgSocketType</code></a>) and then extract it from the socket in your response to the launch code <a href="HLC_ExgMgrRef.html#1327402"><code>sysAppLaunchCmdExgReceiveData</code></a>. For example: </p>

<div class="CodeRule"><hr></div><pre class="CodeBlock">
if (cmd == sysAppLaunchCmdExgReceiveData) {<a name="1269552"> </a>
  uint16_t category = <a name="1269553"> </a>
    (ExgSocketPtr)cmdPBP-&gt;appData;<a name="1269554"> </a>
  /* other declarations */<a name="1269555"> </a>
 <a name="1269556"> </a>
/* Receive the data, and create a new record <a name="1269557"> </a>
  using the received data. indexNew is the <a name="1269558"> </a>
  index of this record. */<a name="1269559"> </a>
  if (category !- <code>dmUnfiledCategory</code>) {<a name="1269560"> </a>
    uint16_t attr;<a name="1269561"> </a>
    status_t err;<a name="1269562"> </a>
    err = DmRecordInfo(dbP, indexNew, &amp;attr, <a name="1269563"> </a>
      NULL, NULL);<a name="1269564"> </a>
 <a name="1269565"> </a>
    // Set the category to the one the user <a name="1269566"> </a>
    // specified, and mark the record dirty. <a name="1269567"> </a>
    if ((attr &amp; dmRecAttrCategoryMask) != <a name="1269568"> </a>
      category) {<a name="1269569"> </a>
      attr &amp;= ~dmRecAttrCategoryMask;<a name="1269570"> </a>
      attr |= category | dmRecAttrDirty;<a name="1269571"> </a>
      err = DmSetRecordInfo(dbP, indexNew, <a name="1269572"> </a>
        &amp;attr, NULL);<a name="1269573"> </a>
    }<a name="1269574"> </a>
  }<a name="1269575"> </a>
}<a name="1269576"> </a>
</pre><div class="CodeRule"><hr></div>


<p><a name="1269577"> </a>Some of the Palm OS built-in applications (Address Book, Memo, and ToDo) use this method of setting the category on data received through beaming. Refer to the example code for these applications provided in the SDK for a more complete example of how to use <code>ExgDoDialog</code>.</p>

<p><a name="1269578"> </a>When you explicitly call <code>ExgDoDialog()</code>, you must set the <code>result</code> field of the <code>sysAppLaunchCmdExgAskUser</code> launch code's parameter block to either <code>exgAskOk</code> (upon success) or <code>exgAskCancel</code> (upon failure) to prevent the system from displaying the dialog a second time. </p>

<h3 class="hbH3">
  <a name="1269590"> </a>ExgGet Function <a href="#1322464"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="1269591"> </a>Purpose 
</h4>

<p><a name="1269592"> </a>Establishes a connection and requests an object from a remote or local device. </p>
<h4>
  <a name="1269593"> </a>Declared In 
</h4>
<code>ExgMgr.h<a name="1269594"> </a></code><h4>
  <a name="1269595"> </a>Prototype 
</h4>
<pre class="proto"><a name="1269596"></a>status_t ExgGet (
   ExgSocketPtr <code class="par">socketP</code>
)
</pre>
<h4>
  <a name="1269597"> </a>Parameters 
</h4>

<dl>
<dt><a name="1269598"> </a><code>&rarr;  <i>socketP</i></code></dt>
<dd><a name="1306276"> </a>A pointer to the socket structure (see <a href="HLC_ExgMgrRef.html#1268710"><code>ExgSocketType</code></a>). Specify a URL in the <code>name</code> field and 0 for the <code>libraryRef</code> field. The <code>target</code> or <code>type</code> fields should identify the data being requested. </dd>

</dl>
<h4>
  <a name="1269602"> </a>Returns 
</h4>

<p><a name="1269603"> </a>Returns one of the following error codes: </p>


<div class="tablediv"><table cellspacing="0" class="tTableNR">

  <tr valign="top">
    <td><p class="tt"><a name="1269606"> </a><code>errNone</code> </p>
    </td>
    <td><p class="tt"><a name="1269608"> </a>Success</p>
    </td>
  </tr>
  <tr valign="top">
    <td><p class="tt"><a name="1269610"> </a><code>exgErrBadLibrary</code></p>
    </td>
    <td><p class="tt"><a name="1269612"> </a>Couldn't find default exchange library</p>
    </td>
  </tr>
  <tr valign="top">
    <td><p class="tt"><a name="1269614"> </a><code>exgErrUserCancel</code> </p>
    </td>
    <td><p class="tt"><a name="1269616"> </a>The user cancelled the operation </p>
    </td>
  </tr>
  <tr valign="top">
    <td><p class="tt"><a name="1269618"> </a><code>exgMemError</code> </p>
    </td>
    <td><p class="tt"><a name="1269620"> </a>There is not enough free memory to perform the operation </p>
    </td>
  </tr>
  <tr valign="top">
    <td><p class="tt"><a name="1294557"> </a><code>exgErrNotSupported</code> </p>
    </td>
    <td><p class="tt"><a name="1294559"> </a>The exchange library doesn't support this function</p>
    </td>
  </tr>
</table>

</div>


<p><a name="1269622"> </a>Other error codes depend on the exchange library. </p>
<h4>
  <a name="1269623"> </a>Comments 
</h4>

<p><a name="1294492"> </a>Applications use this function to request data (initiate a send) from a remote or local device. Not all exchange libraries support this operation; among the exchange libraries built into the Palm OS only the Local Exchange library supports it.</p>

<p><a name="1269625"> </a>Before calling this function, the application must initialize the <code>socketP</code> parameter. The socket should identify the exchange library to connect with by providing a URL in the <code>name</code> field. The default exchange library registered for the URL's scheme handles the connection. The socket should also specify what data it is requesting by providing values for at least one of the <code>target</code>, <code>name</code>, and <code>type</code> fields. Specifying the data in the <code>name</code> field is the most common method.</p>

<p><a name="1269626"> </a>To provide users with a choice of transport mechanisms, the application can provide a URL that begins with a question mark (?). The Exchange Manager displays a dialog with a list of all exchange libraries that respond to URLs of the specified type. If only one exchange library is registered for this URL scheme, no dialog is displayed. </p>

<p><a name="1269627"> </a>If the library is not specified by URL, the Exchange Manager by default uses the IR Library; however, if the <code>localMode</code> flag is set, the Local Exchange Library is used instead. </p>

<p><a name="1269629"> </a>Applications can use <code>ExgGet()</code> to initiate a send from the Local Exchange Library. For more information, see <a href="HLC_ExgMgrConcept.html#996108">"Sending and Receiving Locally"</a>. </p>

<p><a name="1269636"> </a>If no error is returned, applications should follow this call with one or more calls to <a href="HLC_ExgMgrRef.html#1270187"><code>ExgReceive()</code></a>, to receive the data, or <a href="HLC_ExgMgrRef.html#1269394"><code>ExgDisconnect()</code></a>, to disconnect. </p>
<h4>
  <a name="1269650"> </a>See Also 
</h4>

<p><a name="1269657"> </a><a href="HLC_ExgMgrRef.html#1270113"><code>ExgPut()</code></a>, <a href="HLC_ExgMgrRef.html#1269073"><code>ExgConnect()</code></a></p>

<h3 class="hbH3">
  <a name="1269660"> </a>ExgGetDefaultApplication Function <a href="#1322464"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="1269661"> </a>Purpose 
</h4>

<p><a name="1269662"> </a>Retrieves the default application for the specified type of data or the default exchange library for URLs with the specified scheme. </p>
<h4>
  <a name="1269663"> </a>Declared In 
</h4>
<code>ExgMgr.h<a name="1269664"> </a></code><h4>
  <a name="1269665"> </a>Prototype 
</h4>
<pre class="proto"><a name="1269666"></a>status_t ExgGetDefaultApplication (
   uint32_t *<code class="par">creatorIDP</code>,
   uint16_t <code class="par">id</code>,
   const char *<code class="par">dataTypeP</code>
)
</pre>
<h4>
  <a name="1269667"> </a>Parameters 
</h4>

<dl>
<dt><a name="1269668"> </a><code>&larr;  <i><code>creatorIDP</code></i></code></dt>
<dd><a name="1282922"> </a>A pointer to the creator ID of the default application or default exchange library. </dd>

<dt><a name="1269669"> </a><code>&rarr;  <i><code>id</code></i></code></dt>
<dd><a name="1282924"> </a>The registry ID constant identifying the type of data in <code>dataTypeP</code>. See <a href="HLC_ExgMgrRef.html#1283812">Registry ID Constants</a>.</dd>

<dt><a name="1269673"> </a><code>&rarr;  <i><code>dataTypeP</code></i></code></dt>
<dd><a name="1282926"> </a>A pointer to a string that contains the type of data for which to retrieve the default application or library. If <code>dataTypeP</code> is a file extension, do not include the period (.). If it is a URL, do not include the colon (:).</dd>

</dl>
<h4>
  <a name="1269674"> </a>Returns 
</h4>

<p><a name="1269675"> </a>Returns <code>errNone</code> if a match was found or <code>exgErrNoKnownTarget</code> if there is no default application or library for this type of data. </p>
<h4>
  <a name="1269677"> </a>Comments 
</h4>

<p><a name="1269678"> </a>You might use this function to see which application on this device will receive a particular type of data or to see which library on this device handles URLs of a particular scheme. </p>

<p><a name="1269679"> </a>For example, to find out which application receives TXT files on this device, do the following: </p>

<div class="CodeRule"><hr></div><pre class="CodeBlock">
uint32_t creatorID;<a name="1269680"> </a>
status_t error;<a name="1269681"> </a>
error = ExgGetDefaultApplication(&amp;creatorID, <a name="1269682"> </a>
  <code>exgRegExtensionID, "TXT");</code><a name="1269684"> </a>
if (!error) {<a name="1269685"> </a>
    //creatorID contains default application.<a name="1269686"> </a>
</pre><div class="CodeRule"><hr></div>


<p><a name="1269687"> </a>To find out which exchange library handles URLs that use the beam prefix, do the following: </p>

<div class="CodeRule"><hr></div><pre class="CodeBlock">
uint32_t creatorID;<a name="1269688"> </a>
status_t error;<a name="1269689"> </a>
error = ExgGetDefaultApplication(&amp;creatorID, <a name="1269690"> </a>
  <code>exgRegSchemeID, exgBeamScheme);</code><a name="1269692"> </a>
if (!error) {<a name="1269693"> </a>
    //creatorID contains default library.<a name="1269694"> </a>
</pre><div class="CodeRule"><hr></div>


<p><a name="1269695"> </a>It's possible to have several applications registered to receive the same type of data, but none of them is the default. When the Exchange Manager receives an object of that type, it selects an application to receive the data, and it selects that same application every time. The selected application effectively becomes the default for the data type even though it is not explicitly set as the default. If this is the case, the <code>ExgGetDefaultApplication()</code> function returns the creator ID of this de-facto default application. </p>
<h4>
  <a name="1269701"> </a>See Also 
</h4>

<p><a name="1269707"> </a><a href="HLC_ExgMgrRef.html#1269717"><code>ExgGetRegisteredApplications()</code></a>, <a href="HLC_ExgMgrRef.html#1269768"><code>ExgGetRegisteredTypes()</code></a>, <a href="HLC_ExgMgrRef.html#1270252"><code>ExgRegisterDatatype()</code></a>, <a href="HLC_ExgMgrRef.html#1270489"><code>ExgSetDefaultApplication()</code></a></p>

<h3 class="hbH3">
  <a name="1269717"> </a>ExgGetRegisteredApplications Function <a href="#1322464"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="1269718"> </a>Purpose 
</h4>

<p><a name="1269719"> </a>Retrieves a list of all applications registered to receive data of a specified type.</p>
<h4>
  <a name="1269720"> </a>Declared In 
</h4>
<code>ExgMgr.h<a name="1269721"> </a></code><h4>
  <a name="1269722"> </a>Prototype 
</h4>
<pre class="proto"><a name="1269723"></a>status_t ExgGetRegisteredApplications (
   uint32_t **<code class="par">creatorIDsP</code>,
   uint32_t *<code class="par">numAppsP</code>,
   char **<code class="par">namesP</code>,
   char **<code class="par">descriptionsP</code>,
   uint16_t <code class="par">id</code>,
   const char *<code class="par">dataTypeP</code>
)
</pre>
<h4>
  <a name="1269724"> </a>Parameters 
</h4>

<dl>
<dt><a name="1269725"> </a><code>&larr;  <i>creatorIDsP</i></code></dt>
<dd><a name="1282928"> </a>An array of the creator IDs of the applications registered to receive objects of this type. Pass <code>NULL</code> for this parameter if you only want to know how many applications are registered for this type. </dd>

<dt><a name="1269726"> </a><code>&larr;  <i>numAppsP</i></code></dt>
<dd><a name="1282930"> </a>The number of applications registered to receive objects of this type. This is the number of elements in the <code>creatorIDsP</code> array, the <code>namesP</code> array, and the <code>descriptionsP</code> array. </dd>

<dt><a name="1269727"> </a><code>&larr;  <i>namesP</i></code></dt>
<dd><a name="1282966"> </a>A packed list of strings, suitable for passing to <a href="../System_Management/SysUtils.html#994353"><code>SysFormPointerArrayToStrings()</code></a>, containing the names of the applications or libraries. Each string is no more than <code>exgMaxTitleLen</code> characters. Pass <code>NULL</code> for this parameter if you don't want to retrieve it. </dd>

<dt><a name="1269733"> </a><code>&larr;  <i>descriptionsP</i></code></dt>
<dd><a name="1282344"> </a>A packed list of strings, suitable for passing to <code>SysFormPointerArrayToStrings()</code>, containing the descriptions of the applications or libraries. Descriptions are specified when the applications or libraries register for data. Each string is no more than <code>exgMaxDescriptionLength</code> characters. Pass <code>NULL</code> for this parameter if you don't want to retrieve it. </dd>

<dt><a name="1269735"> </a><code>&rarr;  <i><code>id</code></i></code></dt>
<dd><a name="1282968"> </a>The registry ID constant identifying the type of data in <code>dataTypeP</code>. See <a href="HLC_ExgMgrRef.html#1283812">Registry ID Constants</a>.</dd>

<dt><a name="1269739"> </a><code>&rarr;  <i><code>dataTypesP</code></i></code></dt>
<dd><a name="1282990"> </a>A pointer to a tab-delimited, null-terminated string listing the items to register. (Use <code>\t </code>for the tab character.) Each item in the string must be no more than <code>exgMaxTypeLength</code> characters. There can be no more than 16 types total. </dd>

</dl>
<h4>
  <a name="1269741"> </a>Returns 
</h4>

<p><a name="1269742"> </a>Returns <code>errNone</code> upon success or <code>exgMemError</code> if the function cannot allocate space for the creator IDs, names, or descriptions. </p>

<div><hr>
  <a name="1269743"> </a> <b>IMPORTANT: </b> This function allocates enough space for the <code>creatorIDsP</code>, <code>namesP</code>, and <code>descriptionsP</code> arrays as long as you do not pass <code>NULL</code> for the parameters. You are still responsible for freeing these arrays. 
<hr>
</div>
<h4>
  <a name="1269744"> </a>Comments 
</h4>

<p><a name="1269745"> </a>You might use this function to see which applications on this device can receive a particular type of data or to see which libraries on this device handle URLs of a particular scheme. You can also use it to built a list of choices from which the user can select a default application or default exchange library for a particular data type or URL scheme. </p>

<p><a name="1269746"> </a>The Exchange Manager itself uses <code>ExgGetRegisteredApplications()</code> to find exchange libraries when it is given a URL that begins with a question mark (?). It displays the returned list to the user in the Send With dialog. </p>
<h4>
  <a name="1269752"> </a>See Also 
</h4>

<p><a name="1269759"> </a><a href="HLC_ExgMgrRef.html#1269660"><code>ExgGetDefaultApplication()</code></a>, <a href="HLC_ExgMgrRef.html#1269768"><code>ExgGetRegisteredTypes()</code></a>, <a href="HLC_ExgMgrRef.html#1270252"><code>ExgRegisterDatatype()</code></a>, <a href="HLC_ExgMgrRef.html#1270489"><code>ExgSetDefaultApplication()</code></a></p>

<h3 class="hbH3">
  <a name="1269768"> </a>ExgGetRegisteredTypes Function <a href="#1322464"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="1269769"> </a>Purpose 
</h4>

<p><a name="1269770"> </a>Retrieve a list of all data types for which a registration exists. </p>
<h4>
  <a name="1269771"> </a>Declared In 
</h4>
<code>ExgMgr.h<a name="1269772"> </a></code><h4>
  <a name="1269773"> </a>Prototype 
</h4>
<pre class="proto"><a name="1269774"></a>status_t ExgGetRegisteredTypes (
   char **<code class="par">dataTypesP</code>,
   uint32_t *<code class="par">sizeP</code>,
   uint16_t <code class="par">id</code>
)
</pre>
<h4>
  <a name="1269775"> </a>Parameters 
</h4>

<dl>
<dt><a name="1269776"> </a><code>&larr;  <i><code>dataTypesP</code></i></code></dt>
<dd><a name="1283012"> </a>A packed list of strings, suitable for passing to <a href="../System_Management/SysUtils.html#994353"><code>SysFormPointerArrayToStrings()</code></a>, containing a sorted list of data types for which a registration exists. Each string is no more than <code>exgMaxTypeLength</code> characters. </dd>

<dt><a name="1269782"> </a><code>&larr;  <i><code>sizeP</code></i></code></dt>
<dd><a name="1283038"> </a>The number of elements in the <code>dataTypesP</code> array. </dd>

<dt><a name="1269783"> </a><code>&rarr;  <i><code>id</code></i></code></dt>
<dd><a name="1283060"> </a>The type of data to search for. For example, you can search for all registered creator IDs, all registered MIME types, and so on. </dd>

</dl>
<h4>
  <a name="1269784"> </a>Returns 
</h4>

<p><a name="1269786"> </a>Returns <code>errNone</code> upon success or <code>exgMemError</code> if the function cannot allocate space for the data types array. </p>

<div><hr>
  <a name="1269787"> </a> <b>IMPORTANT: </b> This function allocates enough space for the <code>dataTypesP</code> array as long as you do not pass <code>NULL</code> for the parameter. You are still responsible for freeing this array. 
<hr>
</div>
<h4>
  <a name="1269788"> </a>Comments 
</h4>

<p><a name="1269789"> </a>This function could be used to create an application that allows users to choose the default application for each data type. </p>
<h4>
  <a name="1269795"> </a>See Also 
</h4>

<p><a name="1269801"> </a><a href="HLC_ExgMgrRef.html#1269660"><code>ExgGetDefaultApplication()</code></a>, <a href="HLC_ExgMgrRef.html#1269717"><code>ExgGetRegisteredApplications()</code></a>, <a href="HLC_ExgMgrRef.html#1270252"><code>ExgRegisterDatatype()</code></a>, <a href="HLC_ExgMgrRef.html#1270489"><code>ExgSetDefaultApplication()</code></a></p>

<h3 class="hbH3">
  <a name="1269811"> </a>ExgGetTargetApplication Function <a href="#1322464"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="1269812"> </a>Purpose 
</h4>

<p><a name="1269813"> </a>Retrieves the application that should receive a specific message. This function does not search for libraries. </p>
<h4>
  <a name="1269814"> </a>Declared In 
</h4>
<code>ExgMgr.h<a name="1269815"> </a></code><h4>
  <a name="1269816"> </a>Prototype 
</h4>
<pre class="proto"><a name="1269817"></a>status_t ExgGetTargetApplication (
   ExgSocketType *<code class="par">socketP</code>,
   Boolean <code class="par">unwrap</code>,
   uint32_t *<code class="par">creatorIDP</code>,
   char *<code class="par">descriptionP</code>,
   uint32_t <code class="par">descriptionSize</code>
)
</pre>
<h4>
  <a name="1269818"> </a>Parameters 
</h4>

<dl>
<dt><a name="1269819"> </a><code>&rarr;  <i>socketP</i></code></dt>
<dd><a name="1283082"> </a>A pointer to the socket structure (see <a href="HLC_ExgMgrRef.html#1268710"><code>ExgSocketType</code></a>). The structure should contain values for the <code>target</code>, <code>type</code>, or <code>name</code> fields. </dd>

<dt><a name="1269823"> </a><code>&rarr;  <i><code>unwrap</code></i></code></dt>
<dd><a name="1283108"> </a>If <code>true</code>, only an application that registered to receive the data type with the <code>exgUnwrap</code> flag set should be the target application. If <code>false</code>, the target application should be an application that registered with the <code>exgUnwrap</code> flag clear. Note that usage of the <code>exgUnwrap</code> flag is deprecated.</dd>

<dt><a name="1269824"> </a><code>&larr;  <i><code>creatorIDP</code></i></code></dt>
<dd><a name="1283110"> </a>The creator ID of the application that should receive this object. </dd>

<dt><a name="1269825"> </a><code>&harr;  <i><code>descriptionP</code></i></code></dt>
<dd><a name="1282397"> </a>The application's description from the registry, if any. </dd>

<dt><a name="1269826"> </a><code>&rarr;  <i><code>descriptionSize</code></i></code></dt>
<dd><a name="1282418"> </a>The size of the <code>descriptionP</code> buffer. </dd>

</dl>
<h4>
  <a name="1269827"> </a>Returns 
</h4>

<p><a name="1269828"> </a>Returns one of the following error codes: </p>


<div class="tablediv"><table cellspacing="0" class="tTableNR">

  <tr valign="top">
    <td><p class="tt"><a name="1269831"> </a><code>errNone</code> </p>
    </td>
    <td><p class="tt"><a name="1269833"> </a>Success</p>
    </td>
  </tr>
  <tr valign="top">
    <td><p class="tt"><a name="1269835"> </a><code>exgErrTargetMissing </code></p>
    </td>
    <td><p class="tt"><a name="1269837"> </a>The <code>target</code> field contains a creator ID, but the application with that creator ID does not exist </p>
    </td>
  </tr>
  <tr valign="top">
    <td><p class="tt"><a name="1269840"> </a><code>exgErrNoKnownTarget</code> </p>
    </td>
    <td><p class="tt"><a name="1269842"> </a>No application is registered to receive the data type </p>
    </td>
  </tr>
</table>

</div>

<h4>
  <a name="1269844"> </a>Comments 
</h4>

<p><a name="1269845"> </a>The Exchange Manager uses this function to determine which application should be launched to receive incoming data. Applications and libraries may call this function as well. </p>

<p><a name="1269846"> </a><code>ExgGetTargetApplication()</code> determines the target application by doing the following: </p>
<ul type="disc">
  <li><a name="1269847"> </a>If the <code>socketP-&gt;target</code> field contains a creator ID, the Exchange Manager searches the registry to see if an application is registered for that creator ID as the default application. If the registry does not contain an entry for the creator ID, it checks to see if the application identified by the creator ID is installed on this device. If an application is found for the <code>target</code>, that is the application returned. 
  <li><a name="1269848"> </a>If the <code>socketP-&gt;type</code> field contains a MIME type, the Exchange Manager searches the registry for an application registered to receive objects of that type. If one is found, that is the application returned. 
  <li><a name="1269849"> </a>If the <code>socketP-&gt;name</code> field contains a period (.), the portion after the last period is taken to be the file extension. The Exchange Manager searches the registry for an application registered to receive a file with the specified extension. If one is found, that is the application returned. If not, <code>exgErrNoKnownTarget</code> is returned. 
</ul>

<p><a name="1269851"> </a>If more than one application is registered for the target, type, or file extension, this function returns the one that is registered as the default. If no application is registered as the default, then a specific application is chosen. The Exchange Manager chooses this same application each time. That is, each time a file with a TXT extension is sent with no target or MIME type specified, the <code>ExgGetTargetApplication()</code> returns the same application to handle the receipt. </p>

<p><a name="1269852"> </a>Set the <code>unwrap</code> parameter to <code>true</code> if the object was sent as part of another object, such as a vStock object that was sent as an attachment to an email message. In this case, the Exchange Manager searches for an application that registered to receive the target, the type, or the file extension of the vStock object with the <code>exgUnwrap</code> flag set. If an application is found, the vStock object is delivered, and the exchange library should discard the object that contained it (the email message). If there is no application registered to receive the data with the <code>exgUnwrap</code> flag set, this function returns <code>exgErrNoKnownTarget</code>. In this case, the exchange library should call <a href="HLC_ExgMgrRef.html#1270008"><code>ExgNotifyReceive()</code></a> again passing the entire email message instead of just the vStock attachment. </p>
<h4>
  <a name="1269863"> </a>See Also 
</h4>

<p><a name="1269870"> </a><a href="HLC_ExgMgrRef.html#1270489"><code>ExgSetDefaultApplication()</code></a>, <a href="HLC_ExgMgrRef.html#1269936"><code>ExgNotifyPreview()</code></a>, <a href="HLC_ExgMgrRef.html#1270008"><code>ExgNotifyReceive()</code></a>, <a href="HLC_ExgMgrRef.html#1270252"><code>ExgRegisterDatatype()</code></a></p>

<h3 class="hbH3">
  <a name="1269880"> </a>ExgNotifyGoto Function <a href="#1322464"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="1302475"> </a>Purpose 
</h4>

<p><a name="1302480"> </a>Launches the target application using <a href="../Programming_Basics/CmnLaunchCodes.html#993710"><code>sysAppLaunchCmdGoTo</code></a>. </p>
<h4>
  <a name="1302481"> </a>Declared In 
</h4>
<code>ExgMgr.h<a name="1269888"> </a></code><h4>
  <a name="1269889"> </a>Prototype 
</h4>
<pre class="proto"><a name="1269890"></a>status_t ExgNotifyGoto (
   ExgSocketType *<code class="par">socketP</code>,
   uint16_t <code class="par">flags</code>
)
</pre>
<h4>
  <a name="1269891"> </a>Parameters 
</h4>

<dl>
<dt><a name="1269892"> </a><code>&rarr;  <i><code>socketP</code></i></code></dt>
<dd><a name="1283112"> </a>A socket identifying the object to deliver (see <a href="HLC_ExgMgrRef.html#1268710"><code>ExgSocketType</code></a>). The <code>goToCreator</code> field contains the application to be launched, and the <code>goToParams</code> field contains data for the launch code's parameter block. </dd>

<dt><a name="1269896"> </a><code>&rarr;  <i><code>flags</code></i></code></dt>
<dd><a name="1283114"> </a>Not currently used. Pass 0 for this parameter. </dd>

</dl>
<h4>
  <a name="1269897"> </a>Returns 
</h4>

<p><a name="1269898"> </a>Returns one of the following error codes: </p>


<div class="tablediv"><table cellspacing="0" class="tTableNR">

  <tr valign="top">
    <td><p class="tt"><a name="1269901"> </a><code>errNone</code> </p>
    </td>
    <td><p class="tt"><a name="1269903"> </a>Success or the <code>goToCreator</code> field is empty </p>
    </td>
  </tr>
  <tr valign="top">
    <td><p class="tt"><a name="1269905"> </a><code>dmErr...</code> (one of the data manager error codes)</p>
    </td>
    <td><p class="tt"><a name="1269907"> </a>The specified application could not be found</p>
    </td>
  </tr>
  <tr valign="top">
    <td><p class="tt"><a name="1269909"> </a><code>memErrNotEnoughSpace </code></p>
    </td>
    <td><p class="tt"><a name="1269911"> </a>Not enough memory available to create the launch code's parameter block</p>
    </td>
  </tr>
</table>

</div>

<h4>
  <a name="1269913"> </a>Comments 
</h4>

<p><a name="1269914"> </a>Exchange libraries call this function if they want to support immediate display of the received object. Applications do not call this function. </p>

<p><a name="1269915"> </a>Most exchange libraries should call <code>ExgNotifyGoto()</code> after the return from <a href="HLC_ExgMgrRef.html#1270008"><code>ExgNotifyReceive()</code></a> so that the user can inspect the newly received data. If the exchange library is most often used by a single application that does not require the launch code, this call to <code>ExgNotifyGoto()</code> can be skipped. For example, the SMS Library does not call <code>ExgNotifyGoto()</code>. SMS messages are received by the SMS Messenger application, which does not launch upon receiving data.</p>

<p><a name="1269920"> </a><code>ExgNotifyGoto()</code> launches an application only if one is specified in the <code>goToCreator</code> field and the <code>noGoTo</code> parameter is <code>false</code>. If a <code>goToCreator</code> is not specified, it is not considered an error. This gives the application a way to override the default behavior. </p>
<h4>
  <a name="1269926"> </a>See Also 
</h4>

<p><a name="1269933"> </a><a href="HLC_ExgMgrRef.html#1270008"><code>ExgNotifyReceive()</code></a>, <a href="HLC_ExgMgrRef.html#1269394"><code>ExgDisconnect()</code></a></p>

<h3 class="hbH3">
  <a name="1269936"> </a>ExgNotifyPreview Function <a href="#1322464"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="1269937"> </a>Purpose 
</h4>

<p><a name="1269938"> </a>Gets a description of the data to be received for the exchange dialog. </p>
<h4>
  <a name="1269939"> </a>Declared In 
</h4>
<code>ExgMgr.h<a name="1269940"> </a></code><h4>
  <a name="1269941"> </a>Prototype 
</h4>
<pre class="proto"><a name="1269942"></a>status_t ExgNotifyPreview (
   ExgPreviewInfoType *<code class="par">infoP</code>
)
</pre>
<h4>
  <a name="1269943"> </a>Parameters 
</h4>

<dl>
<dt><a name="1269948"> </a><code>&harr;  <i><code>infoP</code></i></code></dt>
<dd><a name="1283116"> </a>An <a href="HLC_ExgMgrRef.html#1268619"><code>ExgPreviewInfoType</code></a> structure containing information about the operation. </dd>

</dl>
<h4>
  <a name="1269949"> </a>Returns 
</h4>

<p><a name="1269950"> </a>Returns one of the following error codes: </p>


<div class="tablediv"><table cellspacing="0" class="tTableNR">

  <tr valign="top">
    <td><p class="tt"><a name="1269953"> </a><code>errNone</code> </p>
    </td>
    <td><p class="tt"><a name="1269955"> </a>Success</p>
    </td>
  </tr>
  <tr valign="top">
    <td><p class="tt"><a name="1269958"> </a><code>exgErrNotSupported </code></p>
    </td>
    <td><p class="tt"><a name="1269960"> </a>The exchange library doesn't support preview mode </p>
    </td>
  </tr>
  <tr valign="top">
    <td><p class="tt"><a name="1269963"> </a><code>exgErrNoKnownTarget</code> </p>
    </td>
    <td><p class="tt"><a name="1269965"> </a>There is no application registered to receive the type of object </p>
    </td>
  </tr>
</table>

</div>


<p><a name="1269967"> </a>Other error codes depend on the application. </p>
<h4>
  <a name="1269968"> </a>Comments 
</h4>

<p><a name="1300363"> </a>The <a href="HLC_ExgMgrRef.html#1269493"><code>ExgDoDialog()</code></a> function calls this function to get a description of the data to show in the exchange dialog. Exchange libraries might want to call this function in certain circumstances. An application rarely calls this function, but it may do so if it displays its own dialog in response to the launch code <a href="HLC_ExgMgrRef.html#1327297"><code>sysAppLaunchCmdExgAskUser</code></a>. </p>

<p><a name="1307906"> </a>The preview feature is deprecated and is maintained only for backward compatibility. Applications should no longer implement preview via this mechanism, but should follow the data viewing guidelines described in <a href="HLC_ExgMgrConcept.html#1003957">"Put with View Mode."</a></p>

<p><a name="1322410"> </a>This function provides to the exchange dialog the first of the following object descriptions that it finds: </p>
<ul type="disc">
  <li><a name="1269988"> </a>the data's description from <code>socketP-&gt;description</code> 
  <li><a name="1269989"> </a>the filename in <code>socketP-&gt;name</code> 
  <li><a name="1269990"> </a>the target application's description as stored in the exchange registry 
  <li><a name="1269991"> </a>the MIME type in <code>socketP-&gt;type</code> 
  <li><a name="1269992"> </a>the file extension in <code>socketP-&gt;name</code>
</ul>
<h4>
  <a name="1269998"> </a>See Also 
</h4>

<p><a name="1270005"> </a><a href="HLC_ExgMgrRef.html#1270008"><code>ExgNotifyReceive()</code></a>, <a href="HLC_ExgMgrRef.html#1269394"><code>ExgDisconnect()</code></a> </p>

<h3 class="hbH3">
  <a name="1270008"> </a>ExgNotifyReceive Function <a href="#1322464"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="1270009"> </a>Purpose 
</h4>

<p><a name="1270010"> </a>Delivers an object to the appropriate application using the registry. </p>
<h4>
  <a name="1270011"> </a>Declared In 
</h4>
<code>ExgMgr.h<a name="1270012"> </a></code><h4>
  <a name="1270013"> </a>Prototype 
</h4>
<pre class="proto"><a name="1270014"></a>status_t ExgNotifyReceive (
   ExgSocketType *<code class="par">socketP</code>,
   uint16_t <code class="par">flags</code>
)
</pre>
<h4>
  <a name="1270015"> </a>Parameters 
</h4>

<dl>
<dt><a name="1270016"> </a><code>&harr;  <i>socketP</i></code></dt>
<dd><a name="1283118"> </a>A pointer to the socket structure (see <a href="HLC_ExgMgrRef.html#1268710"><code>ExgSocketType</code></a>). </dd>

<dt><a name="1270020"> </a><code>&rarr;  <i><code>flags</code></i></code></dt>
<dd><a name="1283120"> </a>A bit field. Pass 0 or a combination of the following constants (OR the constants together to specify more than one): </dd>

<dl>
<dt><a name="1270022"> </a><code><code>exgUnwrap</code> </code></dt>
<dd><a name="1282439"> </a>The object being delivered should only be handled by an application that registered to receive it with the <code>exgUnwrap</code> flag set.</dd>

<dt><a name="1270025"> </a><code><code>exgNoAsk</code> </code></dt>
<dd><a name="1282444"> </a>Do not ask the user to confirm receipt of data. If this constant is passed, the target application does not receive the <a href="HLC_ExgMgrRef.html#1327297"><code>sysAppLaunchCmdExgAskUser</code></a> launch code, and the Exchange Manager does not call <a href="HLC_ExgMgrRef.html#1269493"><code>ExgDoDialog()</code></a> to display the user confirmation dialog. </dd>

<dt><a name="1270035"> </a><code><code>exgGet</code> </code></dt>
<dd><a name="1282449"> </a>Specifies that this is a request for the application to send data rather than to receive data. </dd>

</dl>
</dl>
<h4>
  <a name="1270036"> </a>Returns 
</h4>

<p><a name="1270037"> </a>Returns one of the following error codes: </p>


<div class="tablediv"><table cellspacing="0" class="tTableNR">

  <tr valign="top">
    <td><p class="tt"><a name="1270040"> </a><code>errNone</code> </p>
    </td>
    <td><p class="tt"><a name="1270042"> </a>Success</p>
    </td>
  </tr>
  <tr valign="top">
    <td><p class="tt"><a name="1270044"> </a><code>exgErrTargetMissing </code></p>
    </td>
    <td><p class="tt"><a name="1270046"> </a>The <code>target</code> field contains a creator ID, but the application with that creator ID does not exist </p>
    </td>
  </tr>
  <tr valign="top">
    <td><p class="tt"><a name="1270049"> </a><code>exgErrNoKnownTarget</code> </p>
    </td>
    <td><p class="tt"><a name="1270051"> </a>No application is registered to receive the data type </p>
    </td>
  </tr>
  <tr valign="top">
    <td><p class="tt"><a name="1270053"> </a><code>exgErrUserCancel</code> </p>
    </td>
    <td><p class="tt"><a name="1270055"> </a>The user cancelled the operation </p>
    </td>
  </tr>
</table>

</div>


<p><a name="1270057"> </a>Other error codes depend on the application that is launched. </p>
<h4>
  <a name="1270058"> </a>Comments 
</h4>

<p><a name="1270059"> </a>Exchange libraries call this function to initiate a receive operation on the receiving device. Applications do not call this function. </p>

<p><a name="1270060"> </a>The <code>ExgNotifyReceive()</code> function uses <a href="HLC_ExgMgrRef.html#1269811"><code>ExgGetTargetApplication()</code></a> to determine which application should receive the data, then sends that application the appropriate launch codes. </p>

<p><a name="1270065"> </a>If the <code>flags</code> parameter is 0, a receive operation is assumed. The <code>ExgNotifyReceive()</code> function does the following: </p>
<ol type="1">
  <li value="1"><a name="1270066"> </a>It sends the application the <a href="HLC_ExgMgrRef.html#1327297"><code>sysAppLaunchCmdExgAskUser</code></a> launch code. 
  <li value="2"><a name="1300408"> </a>If the application returns <code>exgAskDialog</code> or does not respond to the launch code, it calls <a href="HLC_ExgMgrRef.html#1269493"><code>ExgDoDialog()</code></a>, which sends the application the <a href="HLC_ExgMgrRef.html#1328314"><code>sysAppLaunchCmdExgPreview</code></a> launch code to have the application receive preview data for the dialog. 
  <li value="3"><a name="1270077"> </a>It sends the application the <a href="HLC_ExgMgrRef.html#1327402"><code>sysAppLaunchCmdExgReceiveData</code></a> launch code to tell the application to receive the data. 
</ol>

<p><a name="1270081"> </a>If the <code>flags</code> field contains the <code>exgNoAsk</code> flag, the first and second steps are skipped. </p>

<p><a name="1270082"> </a>If the <code>flags</code> field contains <code>exgGet</code>, this function is a request for data to send to the remote device, not a request to receive data from the remote device. In this case, <code>ExgNotifyReceive()</code> launches the target application with the <a href="HLC_ExgMgrRef.html#1327329"><code>sysAppLaunchCmdExgGetData</code></a> launch code. </p>

<p><a name="1270087"> </a>If the <code>flags</code> field has the <code>exgUnwrap</code> bit set, it means that the object to be received was sent as part of another object, and it should only be sent to an application that registered to receive it with the <code>exgUnwrap</code> flag set. For example, if the exchange library receives an email message with an attached vStock object, the exchange library may call <code>ExgNotifyReceive()</code> with the <code>exgUnwrap</code> flag set and a socket that describes the vStock data type to see if there is an application that registered to receive it directly. If no application is registered to receive vStock objects with the <code>exgUnwrap</code> flag set, <code>ExgNotifyReceive()</code> returns <code>exgErrNoKnownTarget</code>. The exchange library should then call <code>ExgNotifyReceive()</code> again, but this time without the <code>exgUnwrap</code> flag and with a socket that describes the email message data type. This second call sends the object to the application registered to receive the email message rather than its vStock attachment. That application may extract the vStock attachment from the message and use the Local Exchange Library to send it to an application registered to receive vStock objects normally (without the <code>exgUnwrap</code> flag). </p>
<h4>
  <a name="1270106"> </a>See Also 
</h4>

<p><a name="1270110"> </a><a href="HLC_ExgMgrRef.html#1269936"><code>ExgNotifyPreview()</code></a></p>

<h3 class="hbH3">
  <a name="1270113"> </a>ExgPut Function <a href="#1322464"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="1270114"> </a>Purpose 
</h4>

<p><a name="1270115"> </a>Initiates the transfer of data to the destination device.</p>
<h4>
  <a name="1270116"> </a>Declared In 
</h4>
<code>ExgMgr.h<a name="1270117"> </a></code><h4>
  <a name="1270118"> </a>Prototype 
</h4>
<pre class="proto"><a name="1270119"></a>status_t ExgPut (
   ExgSocketPtr <code class="par">socketP</code>
)
</pre>
<h4>
  <a name="1270120"> </a>Parameters 
</h4>

<dl>
<dt><a name="1270121"> </a><code>&rarr;  <i>socketP</i></code></dt>
<dd><a name="1283122"> </a>Pointer to the socket structure (see <a href="HLC_ExgMgrRef.html#1268710"><code>ExgSocketType</code></a>). Specify a URL in the <code>name</code> field. The structure should also contain a value for the <code>target</code> or <code>type</code> fields. </dd>

</dl>
<h4>
  <a name="1270125"> </a>Returns 
</h4>

<p><a name="1270126"> </a>Returns one of the following error codes:</p>


<div class="tablediv"><table cellspacing="0" class="tTableNR">

  <tr valign="top">
    <td><p class="tt"><a name="1270129"> </a><code>errNone</code></p>
    </td>
    <td><p class="tt"><a name="1270131"> </a>Success</p>
    </td>
  </tr>
  <tr valign="top">
    <td><p class="tt"><a name="1270133"> </a><code>exgErrBadLibrary</code></p>
    </td>
    <td><p class="tt"><a name="1270135"> </a>Couldn't find default exchange library</p>
    </td>
  </tr>
  <tr valign="top">
    <td><p class="tt"><a name="1270137"> </a><code>exgMemError</code></p>
    </td>
    <td><p class="tt"><a name="1270139"> </a>Not enough memory to initialize transfer</p>
    </td>
  </tr>
  <tr valign="top">
    <td><p class="tt"><a name="1270141"> </a><code>exgErrNotEnoughPower</code> </p>
    </td>
    <td><p class="tt"><a name="1270143"> </a>The battery does not have enough power to perform the operation </p>
    </td>
  </tr>
</table>

</div>


<p><a name="1270145"> </a>Other error codes depend on the exchange library. </p>
<h4>
  <a name="1270146"> </a>Comments 
</h4>

<p><a name="1270147"> </a>Applications call this function to start a send operation. </p>

<p><a name="1270148"> </a>If the connection does not already exist, this function establishes one. You must create and initialize an <code>ExgSocketType</code> structure containing information about the data to send and the destination application. All unused fields in the structure <b>must</b> be set to 0. </p>

<p><a name="1270153"> </a>If no error is returned, this call <b>must</b> be followed by <a href="HLC_ExgMgrRef.html#1270444"><code>ExgSend()</code></a>, to begin sending data, or <a href="HLC_ExgMgrRef.html#1269394"><code>ExgDisconnect()</code></a>, to disconnect. You may want to call <code>ExgSend()</code> multiple times to send the data in chunks.</p>

<p><a name="1270158"> </a>The socket's <code>name</code> field must identify by URL the library that performs the transfer. The socket should also specify what data is being sent by providing values for at least one of the <code>target</code> and <code>type</code> fields.</p>

<p><a name="1270159"> </a>To provide users with a choice of transport mechanisms, the application can provide a URL that begins with a question mark (?). The Exchange Manager displays a dialog with a list of all exchange libraries that respond to URLs of the specified type. If only one exchange library is registered for this URL scheme, no dialog is displayed. </p>

<p><a name="1270160"> </a>For example, many applications support a Send command. This command generates a URL with the prefix <code>exgSendPrefix</code> (see <a href="HLC_ExgMgrRef.html#1268943">Predefined URL Prefixes</a>). The Exchange Manager displays a dialog containing a list of libraries registered for that URL scheme. The user selects an exchange library, and that library's <code>ExgLibSend()</code> function is called. </p>

<p><a name="1270164"> </a>If the library is not specified by URL, the Exchange Manager by default uses the IR Library; however, if the <code>localMode</code> flag is set, the Local Exchange Library is used instead. </p>
<h4>
  <a name="1270174"> </a>See Also 
</h4>

<p><a name="1270184"> </a><a href="HLC_ExgMgrRef.html#1269394"><code>ExgDisconnect()</code></a>, <a href="HLC_ExgMgrRef.html#1270444"><code>ExgSend()</code></a>, <a href="HLC_ExgMgrRef.html#1269073"><code>ExgConnect()</code></a></p>

<h3 class="hbH3">
  <a name="1270187"> </a>ExgReceive Function <a href="#1322464"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="1270188"> </a>Purpose 
</h4>

<p><a name="1270189"> </a>Receives data from a remote device.</p>
<h4>
  <a name="1270190"> </a>Declared In 
</h4>
<code>ExgMgr.h<a name="1270191"> </a></code><h4>
  <a name="1270192"> </a>Prototype 
</h4>
<pre class="proto"><a name="1270193"></a>uint32_t ExgReceive (
   ExgSocketPtr <code class="par">socketP</code>,
   void *<code class="par">bufP</code>,
   uint32_t <code class="par">bufLen</code>,
   status_t *<code class="par">err</code>
)
</pre>
<h4>
  <a name="1270194"> </a>Parameters 
</h4>

<dl>
<dt><a name="1270195"> </a><code>&rarr;  <i><code>socketP</code></i></code></dt>
<dd><a name="1283136"> </a>A pointer to the socket structure (see <a href="HLC_ExgMgrRef.html#1268710"><code>ExgSocketType</code></a>). </dd>

<dt><a name="1270199"> </a><code>&larr;  <i><code>bufP</code></i></code></dt>
<dd><a name="1283142"> </a>A pointer to the buffer in which to receive the data.</dd>

<dt><a name="1270200"> </a><code>&rarr;  <i><code>bufLen</code></i></code></dt>
<dd><a name="1283144"> </a>The number of bytes to receive.</dd>

<dt><a name="1270201"> </a><code>&larr;  <i><code>err</code></i></code></dt>
<dd><a name="1283146"> </a>A pointer to an error code result. </dd>

</dl>
<h4>
  <a name="1270202"> </a>Returns 
</h4>

<p><a name="1270203"> </a>Returns the number of bytes actually received. A zero result indicates the end of the transmission. </p>

<p><a name="1270204"> </a>An error code is returned in the address indicated by <code>err</code>. The error code <code>exgErrUserCancel</code> is returned if the user cancels the operation. The error code <code>exgErrNotSupported</code> is returned if the application calls this function during a preview and the exchange library does not have any more data available or does not support preview. </p>
<h4>
  <a name="1270206"> </a>Comments 
</h4>

<p><a name="1270207"> </a>Applications call this function in the following circumstances: </p>
<ul type="disc">
  <li><a name="1270212"> </a>In response to the <a href="HLC_ExgMgrRef.html#1327402"><code>sysAppLaunchCmdExgReceiveData</code></a> launch code, following a successful call to <a href="HLC_ExgMgrRef.html#1283452"><code>ExgAccept()</code></a>. 
  <li><a name="1270221"> </a>In response to the <a href="HLC_ExgMgrRef.html#1328314"><code>sysAppLaunchCmdExgPreview</code></a> launch code, following a successful call to <code>ExgAccept()</code>. 
  <li><a name="1270222"> </a>To receive requested data following a successful call to <a href="HLC_ExgMgrRef.html#1269590"><code>ExgGet()</code></a>. 
</ul>

<p><a name="1270231"> </a>After receiving the data, applications call <a href="HLC_ExgMgrRef.html#1269394"><code>ExgDisconnect()</code></a> to terminate the connection.</p>

<p><a name="1270232"> </a>This function blocks the application until the end of the transmission or until the requested number of bytes has been received. However, exchange libraries can provide their own user interface that is shown during this call, is updated as necessary, and allows the user to cancel the operation in progress. </p>
<h4>
  <a name="1270245"> </a>See Also 
</h4>

<p><a name="1270249"> </a><a href="HLC_ExgMgrRef.html#1270008"><code>ExgNotifyReceive()</code></a></p>

<h3 class="hbH3">
  <a name="1270252"> </a>ExgRegisterDatatype Function <a href="#1322464"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="1270253"> </a>Purpose 
</h4>

<p><a name="1270254"> </a>Registers an application to receive a specific type of data, or registers an exchange library to handle specific URL schemes.</p>
<h4>
  <a name="1270255"> </a>Declared In 
</h4>
<code>ExgMgr.h<a name="1270256"> </a></code><h4>
  <a name="1270257"> </a>Prototype 
</h4>
<pre class="proto"><a name="1270258"></a>status_t ExgRegisterDatatype (
   uint32_t <code class="par">creatorID</code>,
   uint16_t <code class="par">id</code>,
   const char *<code class="par">dataTypesP</code>,
   const char *<code class="par">descriptionsP</code>,
   uint16_t <code class="par">flags</code>
)
</pre>
<h4>
  <a name="1270259"> </a>Parameters 
</h4>

<dl>
<dt><a name="1270260"> </a><code>&rarr;  <i><code>creatorID</code></i></code></dt>
<dd><a name="1283148"> </a>The creator ID of the registering application or exchange library.</dd>

<dt><a name="1270261"> </a><code>&rarr;  <i><code>id</code></i></code></dt>
<dd><a name="1283162"> </a>A registry ID constant identifying the type of the items being registered. See <a href="HLC_ExgMgrRef.html#1283812">Registry ID Constants</a>.</dd>

<dt><a name="1270265"> </a><code>&rarr;  <i><code>dataTypesP</code></i></code></dt>
<dd><a name="1283176"> </a>Pointer to a tab-delimited, null-terminated string listing the items to register. (Use <code>"\t"</code> for the tab character.) To unregister, pass a <code>NULL</code> value. Each item in the string must be no more than <code>exgMaxTypeLength</code> characters. There can be no more than 16 types total. </dd>

</dl>

<div><hr>
  <a name="1270267"> </a> <b>NOTE: </b> If specifying file extensions, do not include the period (.) that precedes the extension. If specifying URL prefixes, do not include the colon (:) at the end of the prefix. 
<hr>
</div>

<dl>
<dt><a name="1270268"> </a><code>&rarr;  <i><code>descriptionsP</code></i></code></dt>
<dd><a name="1282454"> </a>Pointer to a tab-delimited, null-terminated string that lists descriptions for the items in the <code>dataTypesP</code> parameter. (Use <code>"\t"</code> for the tab character.) Each description must be no longer than <code>exgMaxDescriptionLength</code>. Pass <code>NULL</code> to leave out the descriptions. </dd>

<dd><a name="1270270"> </a>There must either be one description for all types or the number of descriptions must match the number of types.</dd>

<dd><a name="1270271"> </a>The descriptions are used in dialogs displayed by Exchange Manager to identify applications or libraries, so they should be user-friendly. Use information that describes the type of information handled, such as pictures, sounds, contact information, etc. Don't use MIME types or file extensions because they are not meaningful to the average user.</dd>

<dt><a name="1270272"> </a><code>&rarr;  <i><code>flags</code></i></code></dt>
<dd><a name="1283210"> </a>Always pass zero for this parameter. (This was formerly used for the <code>exgUnwrap</code> flag, but that is now deprecated.)  </dd>

</dl>
<h4>
  <a name="1270274"> </a>Returns 
</h4>

<p><a name="1270276"> </a>Returns <code>errNone</code> if successful, <code>exgMemError</code> if there is not enough memory to save the registration info, or one of the data manager error codes (<code>dmErr</code>...). </p>
<h4>
  <a name="1270277"> </a>Comments 
</h4>

<p><a name="1270278"> </a>Both applications and exchange libraries use this function to register with the Exchange Manager to receive certain types of data. </p>

<p><a name="1270279"> </a>Applications must register with the Exchange Manager to receive data objects that do not specifically target that application using the creator ID in the <code>target</code> field. </p>

<p><a name="1270280"> </a>Exchange libraries register to receive data with certain URL schemes. Otherwise, the IR Library handles all incoming data for which a library could not be found. </p>

<p><a name="1270284"> </a>Both applications and libraries should register to receive data as soon as possible after they are installed and as soon as possible after a hard reset. For example, applications can call <code>ExgRegisterDatatype()</code> in response to the <a href="../Programming_Basics/CmnLaunchCodes.html#993716"><code>sysAppLaunchCmdSyncNotify</code></a> launch code, which they receive immediately after install. Exchange libraries implemented as applications can also use this strategy. Exchange libraries implemented as shared libraries should call <code>ExgRegisterDatatype()</code> in their startup functions. </p>

<p><a name="1270289"> </a>Make only one call to <code>ExgRegisterDatatype()</code> per registry type. If you want to register to receive multiple items, use a tab character (<code>\t</code>) to separate the items. If you were to, for example, make one call to register for the DOC file extension and one call to register for the TXT extension, the second call overwrites the first. </p>

<p><a name="1270290"> </a>Specify <code>exgRegExtensionID</code> to register to receive data that has a filename with a particular extension. For example, if your application wants to receive files with a TXT extension, it could register like this:</p>

<div class="CodeRule"><hr></div><pre class="CodeBlock">
<code>ExgRegisterDatatype(myCreator, </code><a name="1270291"> </a>
<code>  exgRegExtensionID, "TXT", NULL, 0);</code><a name="1270292"> </a>
</pre><div class="CodeRule"><hr></div>


<p><a name="1270293"> </a>If the application wants to receive files with a TXT extension or with a DOC extension, it could register like this: </p>

<div class="CodeRule"><hr></div><pre class="CodeBlock">
<code>ExgRegisterDatatype(myCreator, </code><a name="1270294"> </a>
<code>  exgRegExtensionID, "TXT\tDOC", NULL, 0);</code><a name="1270295"> </a>
</pre><div class="CodeRule"><hr></div>


<p><a name="1270297"> </a>Specify <code>exgRegTypeID</code> to register to receive data with a specific MIME type. For example, if your application wants to receive "setext" text files, it could register like this:</p>

<div class="CodeRule"><hr></div><pre class="CodeBlock">
<code>ExgRegisterDatatype(myCreator, exgRegTypeID, 
"text/x-setext", NULL, 0);</code><a name="1270298"> </a>
</pre><div class="CodeRule"><hr></div>


<p><a name="1270300"> </a>Specify <code>exgRegCreatorID</code> to register to receive data targeted for a particular creator ID. For example, if your application wants to handle all data intended for the ToDo application, it could register like this:</p>

<div class="CodeRule"><hr></div><pre class="CodeBlock">
<code>char toDoCreatorStr[5];</code><a name="1270301"> </a>
<code>MemMove(toDoCreatorStr, sysFileCToDo, 4);</code><a name="1270302"> </a>
toDoCreatorStr[4] = chrNull;<a name="1270303"> </a>
<code>ExgRegisterDatatype(myCreator, exgRegCreatorID,
</code>  toDoCreatorStr<code>, NULL, 0);</code><a name="1270304"> </a>
</pre><div class="CodeRule"><hr></div>


<div><hr>
  <a name="1270305"> </a> <b>NOTE: </b> To override one application's receipt of data, you need to also set your application as the default for this creator ID. See <a href="HLC_ExgMgrRef.html#1270489"><code>ExgSetDefaultApplication()</code></a>. 
<hr>
</div>

<p><a name="1270310"> </a>Most exchange libraries will want to register for a unique URL scheme that identifies only that library, plus they should register for a more general scheme, such as the send scheme (<code>exgSendScheme</code>), which causes the library to be listed in the Send With dialog when the user performs the Send command. The registry ID constant for URL prefixes is <code>exgRegSchemeID</code>. </p>

<div class="CodeRule"><hr></div><pre class="CodeBlock">
<code>ExgRegisterDatatype(myLibCreator, 
</code>  <code>exgRegSchemeID, myScheme "\t" exgSendScheme, 
</code>  <code>NULL, 0);</code><a name="1270313"> </a>
</pre><div class="CodeRule"><hr></div>


<p><a name="1270316"> </a>Registrations are active until a hard reset or until the application or library is removed. The registration information is preserved across a soft reset. When an application is removed, its registry information is also automatically removed from the registry, so there is not normally a need to unregister. If you want to unregister, you can call <code>ExgRegisterDatatype()</code> with a <code>NULL</code> value for the <code>dataTypesP</code> parameter.</p>

<p><a name="1270317"> </a>Multiple applications can be registered to receive the same type of data. If this is the case, the application that is registered as the default (using <a href="HLC_ExgMgrRef.html#1270489"><code>ExgSetDefaultApplication()</code></a>) is the one that receives the data unless the exchange socket explicitly specifies another application should receive it. If there is no default specified, the Exchange Manager determines a default. </p>

<p><a name="1270322"> </a>Multiple libraries may also be registered to receive the same type of URL. In this case, if the URL begins with a question mark (?), the Exchange Manager displays a dialog so that the user can select which exchange library to use. If the URL does not begin with a question mark, the exchange library registered as the default is used. If there is no default specified, the Exchange Manager determines a default. </p>
<h4>
  <a name="1270331"> </a>See Also 
</h4>

<p><a name="1270341"> </a><a href="HLC_ExgMgrRef.html#1270353"><code>ExgRegisterData()</code></a>, <a href="HLC_ExgMgrRef.html#1269811"><code>ExgGetTargetApplication()</code></a>, <a href="HLC_ExgMgrRef.html#1270113"><code>ExgPut()</code></a>, <a href="HLC_ExgMgrRef.html#1269660"><code>ExgGetDefaultApplication()</code></a>, <a href="HLC_ExgMgrRef.html#1269717"><code>ExgGetRegisteredApplications()</code></a>, <a href="HLC_ExgMgrRef.html#1269768"><code>ExgGetRegisteredTypes()</code></a></p>

<h3 class="hbH3">
  <a name="1270353"> </a>ExgRegisterData Function <a href="#1322464"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="1270354"> </a>Purpose 
</h4>

<p><a name="1270355"> </a>Registers an application to receive a specific type of data. This function is deprecated and replaced with <a href="HLC_ExgMgrRef.html#1270252"><code>ExgRegisterDatatype()</code></a>. </p>
<h4>
  <a name="1270359"> </a>Declared In 
</h4>
<code>ExgMgr.h<a name="1270360"> </a></code><h4>
  <a name="1270361"> </a>Prototype 
</h4>
<pre class="proto"><a name="1270362"></a>status_t ExgRegisterData (
   uint32_t <code class="par">creatorID</code>,
   uint16_t <code class="par">id</code>,
   const char *<code class="par">dataTypesP</code>
)
</pre>
<h4>
  <a name="1270363"> </a>Parameters 
</h4>

<dl>
<dt><a name="1270364"> </a><code>&rarr;  <i><code>creatorID</code></i></code></dt>
<dd><a name="1283212"> </a>Creator ID of the registering application.</dd>

<dt><a name="1270365"> </a><code>&rarr;  <i><code>id</code></i></code></dt>
<dd><a name="1283218"> </a>Registry ID identifying the type of the items being registered. Specify <code>exgRegExtensionID</code> or <code>exgRegTypeID</code>.</dd>

<dt><a name="1270366"> </a><code>&rarr;  <i><code>dataTypesP</code></i></code></dt>
<dd><a name="1283224"> </a>Pointer to a tab-delimited, null-terminated string listing the items to register. (Use \t for the tab character.) These include file extensions or MIME types. To unregister, pass a <code>NULL</code> value.</dd>

</dl>
<h4>
  <a name="1270367"> </a>Returns 
</h4>

<p><a name="1270368"> </a>Returns <code>errNone</code> if successful, otherwise, one of the data manager error codes (<code>dmErr</code>...).</p>
<h4>
  <a name="1270369"> </a>Comments 
</h4>

<p><a name="1270370"> </a>Applications that wish to receive data from anything other than another Palm Powered<sup>&#8482;</sup> handheld running the same application must use this function to register for the kinds of data they can receive. Call this function when your application is loaded on the device.</p>

<h3 class="hbH3">
  <a name="1270381"> </a>ExgRequest Function <a href="#1322464"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="1270382"> </a>Purpose 
</h4>

<p><a name="1270383"> </a>Requests some data from an exchange library or an application using a URL. </p>
<h4>
  <a name="1270384"> </a>Declared In 
</h4>
<code>ExgMgr.h<a name="1270385"> </a></code><h4>
  <a name="1270386"> </a>Prototype 
</h4>
<pre class="proto"><a name="1270387"></a>status_t ExgRequest (
   ExgSocketType *<code class="par">socketP</code>
)
</pre>
<h4>
  <a name="1270388"> </a>Parameters 
</h4>

<dl>
<dt><a name="1270389"> </a><code>&rarr;  <i>socketP</i></code></dt>
<dd><a name="1283230"> </a>Pointer to the socket structure (see <a href="HLC_ExgMgrRef.html#1268710"><code>ExgSocketType</code></a>). Specify a URL in the <code>name</code> field. </dd>

</dl>
<h4>
  <a name="1270393"> </a>Returns 
</h4>

<p><a name="1270394"> </a>Returns one of the following error codes:</p>


<div class="tablediv"><table cellspacing="0" class="tTableNR">

  <tr valign="top">
    <td><p class="tt"><a name="1270397"> </a><code>errNone</code></p>
    </td>
    <td><p class="tt"><a name="1270399"> </a>Success</p>
    </td>
  </tr>
  <tr valign="top">
    <td><p class="tt"><a name="1270401"> </a><code>exgErrBadLibrary</code></p>
    </td>
    <td><p class="tt"><a name="1270403"> </a>Couldn't find default exchange library</p>
    </td>
  </tr>
  <tr valign="top">
    <td><p class="tt"><a name="1270405"> </a><code>exgErrNotEnoughPower</code> </p>
    </td>
    <td><p class="tt"><a name="1270407"> </a>The device does not have enough power to perform the operation </p>
    </td>
  </tr>
  <tr valign="top">
    <td><p class="tt"><a name="1270409"> </a><code>sysErrLibNotFound</code></p>
    </td>
    <td><p class="tt"><a name="1270411"> </a>Couldn't find library or application to respond to URL </p>
    </td>
  </tr>
</table>

</div>


<p><a name="1270413"> </a>Other error codes depend on the exchange library or application. </p>
<h4>
  <a name="1270414"> </a>Comments 
</h4>

<p><a name="1270418"> </a>The <code>ExgRequest()</code> function is similar to <a href="HLC_ExgMgrRef.html#1269590"><code>ExgGet()</code></a> in that both are used to request data. The difference is that the application that calls <code>ExgGet()</code> is always the application that receives the data. When you call <code>ExgRequest()</code>, the application that receives the data is the application that is registered to receive it. For example, using <code>ExgRequest()</code>, it is possible for one application to use the Exchange Manager to retrieve a vCard using any supported transport mechanism and have that data sent directly to the Address Book application instead of to the calling application. </p>

<p><a name="1270419"> </a>The <code>socketP</code> passed to this function identifies the exchange library using a URL in the <code>name</code> field. The application must know before-hand the proper URL prefix for the exchange library with which it wants to connect. See <a href="HLC_ExgMgrRef.html#1268943">Predefined URL Prefixes</a> for a list of URL prefixes that the Exchange Manager provides. </p>

<p><a name="1270423"> </a>If the provided URL begins with a question mark (?) and there are several exchange libraries registered for the specified URL scheme, the Exchange Manager displays a dialog from which the user selects the appropriate transport mechanism. </p>

<p><a name="1270424"> </a>If the Exchange Manager cannot find a library that is registered for the specified URL, it assumes that an application is registered to receive the URL, and it launches that application with the <a href="../Programming_Basics/CmnLaunchCodes.html#1003495"><code>sysAppLaunchCmdGoToURL</code></a> launch code. </p>
<h4>
  <a name="1270434"> </a>See Also 
</h4>

<p><a name="1270441"> </a><a href="HLC_ExgMgrRef.html#1269590"><code>ExgGet()</code></a>, <a href="HLC_ExgMgrRef.html#1270008"><code>ExgNotifyReceive()</code></a></p>

<h3 class="hbH3">
  <a name="1270444"> </a>ExgSend Function <a href="#1322464"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="1270445"> </a>Purpose 
</h4>

<p><a name="1270446"> </a>Sends data to the destination device.</p>
<h4>
  <a name="1270447"> </a>Declared In 
</h4>
<code>ExgMgr.h<a name="1270448"> </a></code><h4>
  <a name="1270449"> </a>Prototype 
</h4>
<pre class="proto"><a name="1270450"></a>uint32_t ExgSend (
   ExgSocketPtr <code class="par">socketP</code>,
   const void *<code class="par">bufP</code>,
   uint32_t <code class="par">bufLen</code>,
   status_t  *<code class="par">err</code>
)
</pre>
<h4>
  <a name="1270451"> </a>Parameters 
</h4>

<dl>
<dt><a name="1270452"> </a><code>&rarr;  <i><code>socketP</code></i></code></dt>
<dd><a name="1283236"> </a>A pointer to the socket structure (see <a href="HLC_ExgMgrRef.html#1268710"><code>ExgSocketType</code></a>). A value must be provided for the <code>name</code> field. The structure should also contain values for the <code>target</code> or <code>type</code> fields. </dd>

<dt><a name="1270456"> </a><code>&rarr;  <i><code>bufP</code></i></code></dt>
<dd><a name="1283238"> </a>A pointer to the data to send.</dd>

<dt><a name="1270457"> </a><code>&rarr;  <i><code>bufLen</code></i></code></dt>
<dd><a name="1283260"> </a>The number of bytes to send.</dd>

<dt><a name="1270458"> </a><code>&larr;  <i><code>err</code></i></code></dt>
<dd><a name="1283262"> </a>A pointer to an error code result.</dd>

</dl>
<h4>
  <a name="1270459"> </a>Returns 
</h4>

<p><a name="1270460"> </a>Returns either the same number of bytes as specified in <code>bufLen</code>, or 0 if nothing was sent. An error code is returned in the address indicated by <code>err</code>. The error code <code>exgErrUserCancel</code> is returned if the user cancels the operation.</p>
<h4>
  <a name="1270462"> </a>Comments 
</h4>

<p><a name="1270463"> </a>Call this function one or more times to send all the data, following a successful call to <a href="HLC_ExgMgrRef.html#1270113"><code>ExgPut()</code></a>. After sending the data, call <a href="HLC_ExgMgrRef.html#1269394"><code>ExgDisconnect()</code></a> to terminate the connection.</p>

<p><a name="1270472"> </a>The exchange library may break large amounts of data into multiple packets or assemble small send commands together into larger packets, but the application will not be aware of these transport level details.</p>

<p><a name="1270473"> </a>This function blocks the application until all the requested data is sent. However, the exchange library may provide its own user interface that is updated as necessary and allows the user to cancel the operation in progress.</p>
<h4>
  <a name="1270479"> </a>See Also 
</h4>

<p><a name="1270486"> </a><a href="HLC_ExgMgrRef.html#1270187"><code>ExgReceive()</code></a>, <a href="HLC_ExgMgrRef.html#1269590"><code>ExgGet()</code></a></p>

<h3 class="hbH3">
  <a name="1270489"> </a>ExgSetDefaultApplication Function <a href="#1322464"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="1270490"> </a>Purpose 
</h4>

<p><a name="1270491"> </a>Sets the application that receives a specified type of data by default. This function also sets the default exchange library that handles particular URL schemes. </p>
<h4>
  <a name="1270492"> </a>Declared In 
</h4>
<code>ExgMgr.h<a name="1270493"> </a></code><h4>
  <a name="1270494"> </a>Prototype 
</h4>
<pre class="proto"><a name="1270495"></a>status_t ExgSetDefaultApplication (
   uint32_t <code class="par">creatorID</code>,
   uint16_t <code class="par">id</code>,
   const char *<code class="par">dataTypeP</code>
)
</pre>
<h4>
  <a name="1270496"> </a>Parameters 
</h4>

<dl>
<dt><a name="1270497"> </a><code>&rarr;  <i><code>creatorID</code></i></code></dt>
<dd><a name="1283264"> </a>The creator ID of the application or library that should become the default for this type of data. </dd>

<dt><a name="1270498"> </a><code>&rarr;  <i><code>id</code></i></code></dt>
<dd><a name="1283286"> </a>A registry ID constant identifying the type of data in <code>dataTypeP</code>. See <a href="HLC_ExgMgrRef.html#1283812">Registry ID Constants</a>.</dd>

<dt><a name="1270502"> </a><code>&rarr;  <i><code>dataTypesP</code></i></code></dt>
<dd><a name="1283308"> </a>A pointer to a null-terminated string containing the desired type of data. </dd>

</dl>

<div><hr>
  <a name="1270503"> </a> <b>NOTE: </b> If specifying a file extension, do not include the period (.) that precedes the extension. If specifying a URL prefix, do not include the colon (:) at the end of the prefix. 
<hr>
</div>
<h4>
  <a name="1270504"> </a>Returns 
</h4>

<p><a name="1270506"> </a>Returns <code>errNone</code> upon success or <code>exgErrNoKnownTarget</code> if the specified application is not registered to receive the specified data type. </p>
<h4>
  <a name="1270507"> </a>Comments 
</h4>

<p><a name="1270508"> </a>This function sets the default application that receives data of a certain type when no target is specified; and it sets the default exchange library that handles URLs with a certain prefix. </p>

<p><a name="1300670"> </a>We strongly recommend that applications allow the user to determine which application should become the default recipient for a data type. To do so, an application can use <a href="HLC_ExgMgrRef.html#1269717"><code>ExgGetRegisteredApplications()</code></a> to get the list of applications registered for the same type of data as it is, and then display a dialog listing those applications and allow the user to select it. Then it should call <code>ExgSetDefaultApplication()</code> with the user-specified default. </p>

<p><a name="1300674"> </a>If you call <code>ExgSetDefaultApplication()</code> with an application or library that is already the default, this function has no effect. </p>

<p><a name="1270514"> </a>An application can become the default for its own creator ID even if it has not specifically registered to receive its own creator ID. That is, suppose several applications are registered to receive objects targeted for the ToDo application's creator ID. The ToDo application itself is not registered for its own creator ID, as it is not necessary to do so. However, an application can use code like the following to set the ToDo application as the default for its own creator ID. </p>

<div class="CodeRule"><hr></div><pre class="CodeBlock">
<code>char toDoCreatorStr[5];</code><a name="1270515"> </a>
<code>MemMove(toDoCreatorStr, sysFileCToDo, 4);</code><a name="1270516"> </a>
toDoCreatorStr[4] = chrNull;<a name="1270517"> </a>
ExgSetDefaultApplication(sysFileCToDo, <a name="1270518"> </a>
  exgRegCreatorID, <code>toDoCreatorStr</code>); <a name="1270519"> </a>
</pre><div class="CodeRule"><hr></div>

<h4>
  <a name="1270525"> </a>See Also 
</h4>

<p><a name="1270532"> </a><a href="HLC_ExgMgrRef.html#1269660"><code>ExgGetDefaultApplication()</code></a>, <a href="HLC_ExgMgrRef.html#1270252"><code>ExgRegisterDatatype()</code></a></p>

<h2 class="haH2">
  <a name="1270534"> </a>Application-Defined Functions <a href="#1322464"><span class="nav">^TOP^</span></a>
</h2>


<h3 class="hbH3">
  <a name="1270537"> </a>ExgDBDeleteProcPtr Function <a href="#1322464"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="1270538"> </a>Purpose 
</h4>

<p><a name="1270539"> </a>Handles the case where a database with an identical name already exists on the device. </p>
<h4>
  <a name="1270540"> </a>Declared In 
</h4>
<code>ExgMgr.h<a name="1270541"> </a></code><h4>
  <a name="1270542"> </a>Prototype 
</h4>
<pre class="proto"><a name="1270543"></a>Boolean (
   *ExgDBDeleteProcPtr
) (
   const char *<code class="par">nameP</code>,
   uint16_t <code class="par">version</code>,
   DatabaseID <code class="par">dbID</code>,
   void *<code class="par">userDataP</code>
)
</pre>
<h4>
  <a name="1270544"> </a>Parameters 
</h4>

<dl>
<dt><a name="1270545"> </a><code>&rarr;  <i><code>nameP</code></i></code></dt>
<dd><a name="1283326"> </a>A pointer to the name of the identical database.</dd>

<dt><a name="1270546"> </a><code>&rarr;  <i><code>version</code></i></code></dt>
<dd><a name="1283340"> </a>The version of the identical database.</dd>

<dt><a name="1270548"> </a><code>&rarr;  <i><code>dbID</code></i></code></dt>
<dd><a name="1283352"> </a>The database ID of the identical database.</dd>

<dt><a name="1270549"> </a><code>&rarr;  <i><code>userDataP</code></i></code></dt>
<dd><a name="1283358"> </a>The <code>userDataP</code> parameter you passed to <a href="HLC_ExgMgrRef.html#1269276"><code>ExgDBRead()</code></a>. If used, this parameter contains any application-specific data you find necessary. If the <a href="HLC_ExgMgrRef.html#1270565"><code>ExgDBReadProcPtr()</code></a> function is implemented using Exchange Manager calls, this often contains the <a href="HLC_ExgMgrRef.html#1268710"><code>ExgSocketType</code></a> structure. </dd>

</dl>
<h4>
  <a name="1270559"> </a>Returns 
</h4>

<p><a name="1270560"> </a>Return <code>true</code> to have the <code>ExgDBRead()</code> function continue to read the database. Use this return value if you have deleted or moved the existing database or if you want the database to be overwritten. Return <code>false</code> to have <code>ExgDBRead()</code> exit without reading the database.</p>
<h4>
  <a name="1270561"> </a>Comments 
</h4>

<p><a name="1270562"> </a>This function is called if the Data Manager can't create the incoming database because a database with the same name already exists. You should delete the existing database or take some other action, such as changing the database name. It is appropriate to prompt the user before choosing to delete or move the database. </p>

<h3 class="hbH3">
  <a name="1270565"> </a>ExgDBReadProcPtr Function <a href="#1322464"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="1270566"> </a>Purpose 
</h4>

<p><a name="1270571"> </a>Reads in the database and pass it to <a href="HLC_ExgMgrRef.html#1269276"><code>ExgDBRead()</code></a>.</p>
<h4>
  <a name="1270572"> </a>Declared In 
</h4>
<code>ExgMgr.h<a name="1270573"> </a></code><h4>
  <a name="1270574"> </a>Prototype 
</h4>
<pre class="proto"><a name="1270575"></a>status_t (
   *ExgDBReadProcPtr
) (
   void *<code class="par">dataP</code>,
   uint32_t *<code class="par">sizeP</code>,
   void *<code class="par">userDataP</code>
)
</pre>
<h4>
  <a name="1270576"> </a>Parameters 
</h4>

<dl>
<dt><a name="1270577"> </a><code>&larr;  <i><code>dataP</code></i></code></dt>
<dd><a name="1283364"> </a>A pointer to a buffer where this function should place the database data. This buffer is allocated in the dynamic heap by <code>ExgDBRead</code>; you don't need to use <a href="../Memory_Databases_Files/DataMgr.html#1007510"><code>DmWrite()</code></a> when filling it.</dd>

<dt><a name="1270581"> </a><code>&harr;  <i><code>sizeP</code></i></code></dt>
<dd><a name="1283370"> </a>The size of <code>dataP</code>. This value is set by <code>ExgDBRead()</code> to the number of bytes it expects to receive in <code>dataP</code>. You must set this value to the number of bytes you return in <code>dataP</code> (if it's not the same).</dd>

<dt><a name="1270582"> </a><code>&rarr;  <i><code>userDataP</code></i></code></dt>
<dd><a name="1283372"> </a>The <code>userDataP</code> parameter you passed to <code>ExgDBRead()</code>. Pass the <a href="HLC_ExgMgrRef.html#1268710"><code>ExgSocketType</code></a> structure if you implement this function using Exchange Manager calls. </dd>

</dl>
<h4>
  <a name="1270586"> </a>Returns 
</h4>

<p><a name="1270587"> </a>Return an error number, or <code>errNone</code> if there is no error. If this function returns an error, <code>ExgDBRead()</code> deletes the database it was creating, cleans up any memory it allocated, then exits, returning the error passed back from this function.</p>
<h4>
  <a name="1270588"> </a>Comments 
</h4>

<p><a name="1270589"> </a><code>ExgDBRead()</code> is commonly used to receive a database from a beam or from some other transport mechanism. In this case, an appropriate implementation of this callback function is to call <a href="HLC_ExgMgrRef.html#1270187"><code>ExgReceive()</code></a> as shown here: </p>

<div class="CodeRule"><hr></div><pre class="CodeBlock">
status_t MyReadDBProc (void *dataP, uint32_t *sizeP, <a name="1270594"> </a>
  void *userDataP) <a name="1270595"> </a>
{<a name="1270596"> </a>
  status_t err = errNone;<a name="1270597"> </a>
  //userDataP contains ExgSocketType pointer. <a name="1270598"> </a>
  *sizeP = <a name="1270599"> </a>
    ExgReceive((ExgSocketType *)userDataP, <a name="1270600"> </a>
      dataP, *sizeP, &amp;err);<a name="1270601"> </a>
  return err;<a name="1270602"> </a>
}<a name="1270603"> </a>
</pre><div class="CodeRule"><hr></div>


<h3 class="hbH3">
  <a name="1270606"> </a>ExgDBWriteProcPtr Function <a href="#1322464"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="1270607"> </a>Purpose 
</h4>

<p><a name="1270608"> </a>Writes out the database.</p>
<h4>
  <a name="1270609"> </a>Declared In 
</h4>
<code>ExgMgr.h<a name="1270610"> </a></code><h4>
  <a name="1270611"> </a>Prototype 
</h4>
<pre class="proto"><a name="1270612"></a>status_t (
   *ExgDBWriteProcPtr
) (
   const void *<code class="par">dataP</code>,
   uint32_t *<code class="par">sizeP</code>,
   void *<code class="par">userDataP</code>
)
</pre>
<h4>
  <a name="1270613"> </a>Parameters 
</h4>

<dl>
<dt><a name="1270614"> </a><code>&rarr;  <i><code>dataP</code></i></code></dt>
<dd><a name="1283374"> </a>A pointer to a buffer containing the database data, placed there by <a href="HLC_ExgMgrRef.html#1269343"><code>ExgDBWrite()</code></a>.</dd>

<dt><a name="1270618"> </a><code>&harr;  <i><code>sizeP</code></i></code></dt>
<dd><a name="1283376"> </a>The number of bytes placed in <code>dataP</code> by <code>ExgDBWrite()</code>. If you were unable to write out or send all of the data in this chunk, on exit, set <code>sizeP</code> to the number of bytes you did write.</dd>

<dt><a name="1270619"> </a><code>&rarr;  <i><code>userDataP</code></i></code></dt>
<dd><a name="1283378"> </a>The <code>userDataP</code> parameter you passed to <code>ExgDBWrite()</code>. You can use it for application-specific data. Pass the <a href="HLC_ExgMgrRef.html#1268710"><code>ExgSocketType</code></a> structure if you implement this function using Exchange Manager calls. </dd>

</dl>
<h4>
  <a name="1270623"> </a>Returns 
</h4>

<p><a name="1270624"> </a>Return an error number, or <code>errNone</code> if there is no error. If this function returns an error, <code>ExgDBWrite</code> closes the database it was reading, cleans up any memory it allocated, then exits, returning the error passed back from this function.</p>
<h4>
  <a name="1270625"> </a>Comments 
</h4>

<p><a name="1270626"> </a><code>ExgDBWrite()</code> is commonly used to write a database that is going to be beamed to another device (or sent through some other transport mechanism). In this case, an appropriate implementation of this callback function is to call <a href="HLC_ExgMgrRef.html#1270444"><code>ExgSend()</code></a> as shown here: </p>

<div class="CodeRule"><hr></div><pre class="CodeBlock">
status_t MyWriteDBProc (void *dataP, uint32_t *sizeP, <a name="1270631"> </a>
  void *userDataP) <a name="1270632"> </a>
{<a name="1270633"> </a>
  status_t err = errNone;<a name="1270634"> </a>
  //userDataP contains ExgSocketType pointer. <a name="1270635"> </a>
  *sizeP = <a name="1270636"> </a>
    ExgSend((ExgSocketType *)userDataP, <a name="1270637"> </a>
      dataP, *sizeP, &amp;err);<a name="1270638"> </a>
  return err;<a name="1270639"> </a>
}<a name="1270640"> </a>
</pre><div class="CodeRule"><hr></div>


<p><a name="1167466"> </a></p>
&nbsp;<br>
</div>
<!--END CONTENT-->

</td>
<td width="5">&nbsp;&nbsp;</td>
</tr>

</table>

<!-- BEGIN FOOTER -->
<table width="100%" border="0" cellspacing="0" cellpadding="0">
<tr>
<td width="7" rowspan="2"><img name="index_x" src="images/shim.gif" width="7" height="33" border="0" alt=""></td>
<td align="left"><img name="dashes" src="images/dashes.gif" width="744" height="3" border="0" alt=""></td>
<td width="10" rowspan="2"><img name="index_x" src="images/shim.gif" width="10" height="33" border="0" alt=""></td>
</tr>
<tr>
<td align="center">
<p class="footer">
Copyright © 1996&#8211;2004, PalmSource, Inc. and its affiliates. All rights reserved.<br>
<a href="http://www.palmsource.com/contact/">Write Us</a> | <a href="http://www.palmos.com/dev/training/">Training</a> | <a href="http://www.palmos.com/dev/support/kb/">Knowledge Base</a> | <a href="HLC_Front.html" target="_blank">Legal</a></p>
<br>
<!--BEGIN BOOK NAVIGATION-->
<p class="nav">
<A href="http://www.palmos.com/dev/support/docs/">Documentation</a>&nbsp;&nbsp;|&nbsp;&nbsp;
<a href="HLC_TOC.html">Table of Contents</a>&nbsp;&nbsp;
             |&nbsp;&nbsp;<a href="HLC_ExgMgrConcept.html">&lt;&nbsp;Previous</a>&nbsp;&nbsp;
             |&nbsp;&nbsp;<a href="HLC_PDIPart.html">Next&nbsp;&gt;</a>&nbsp;&nbsp;
             |&nbsp;&nbsp;<a href="HLC_IX.html">Index</a>
</p>
</td>
</tr>
</table>
<!-- END FOOTER -->

</body>
</html>