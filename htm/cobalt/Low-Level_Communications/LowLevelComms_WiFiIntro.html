<html>
<head>
<title>(Protein) Introduction to Wireless Networking | Low-Level Communications</title> 
<link href="psi_devpubs.css" rel="stylesheet" type="text/css">

<!-- BEGIN META DATA -->
<meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
<META NAME="PSITEMPLATE" CONTENT="1006-007 PalmSource_HTML_2003 20041101">
<META NAME="GENERATOR" CONTENT="Quadralay WebWorks AutoMap 2003 for FrameMaker 8.0.6.2138">
<META NAME="LASTUPDATED" CONTENT="11/22/04 11:14:19">
<!-- END META DATA -->
</head>

<body bgcolor="#ffffff" text="#000000" leftmargin="0" topmargin="0" marginwidth="0" marginheight="0">
<a name="608590"></a>

<!-- BEGIN TOPNAV -->
<table width="100%" border="0" cellspacing="0" cellpadding="0">
<tr>
<td><img src="images/shim.gif" width="7" height="75" border="0" alt=""></td>
<td align="left"><table border="0" cellpadding="0" cellspacing="0" width="744">
<tr>
<td><img name="index_r2_c1" src="images/shim.gif" width="25" height="75" border="0" alt=""></td>
<td valign="top"><table border="0" cellpadding="0" cellspacing="0" width="96">
<tr>
<td><img name="index_r2_c4" src="images/shim.gif" width="96" height="15" border="0" alt=""></td>
</tr>
<tr>
<td><a href="http://www.palmsource.com/"><img name="ps_logo" src="images/ps_logo.gif" width="96" height="54" border="0" alt=""></a></td>
</tr>

</table>
</td>

<td><table border="0" cellpadding="0" cellspacing="0" width="30">
<td><img name="index_x" src="images/shim.gif" width="30" height="75" border="0" alt=""></td>
</table></td>

<!--BEGIN MASTHEAD-->
<td><table border="0" cellpadding="0" cellspacing="0" width="96">
<tr>
<td><img name="index_x" src="images/shim.gif" width="615" height="5" border="0" alt=""></td>
</tr>
<tr>
<td>
<!--BEGIN BOOK NAVIGATION-->
<span class="nav">
<A href="http://www.palmos.com/dev/support/docs/">Documentation</a>&nbsp;&nbsp;|&nbsp;&nbsp;
<a href="LowLevelCommsTOC.html">Table of Contents</a>&nbsp;&nbsp;
             |&nbsp;&nbsp;<a href="LowLevelComms_WiFi_Pt.html">&lt;&nbsp;Previous</a>&nbsp;&nbsp;
             |&nbsp;&nbsp;<a href="LowLevelComms_WiFiRef.html">Next&nbsp;&gt;</a>&nbsp;&nbsp;
             |&nbsp;&nbsp;<a href="LowLevelCommsIX.html">Index</a>
</span>
<!--END BOOK NAVIGATION-->
</tr>
<tr>
<td>
<!--BEGIN PAGE TITLE-->
<h2 class="PageTitle">16 &nbsp;&nbsp;
Introduction to Wireless Networking</h2></td>
<!--END PAGE TITLE-->
</tr>
<tr>
<td>
<!--BEGIN BOOK TITLE-->
<p class="BookTitle">Low-Level Communications</p>
<p class="SubTitle">Exploring Palm OS&#174; </p>
<!--END BOOK TITLE-->
</td>
</tr>
<tr>
<td><img name="index_x" src="images/shim.gif" width="615" height="5" border="0" alt=""></td>
</tr>
</table>
</td>
<!--END MASTHEAD-->
</tr>
</table>
<img name="dashes" src="images/dashes.gif" width="744" height="3" border="0" alt=""></td>
</tr>
</table>
<!-- END TOPNAV -->

<table width="100%" border="0" cellspacing="0" cellpadding="0">
<tr>
<td valign="top" width="5"><img name="index_x" src="images/shim.gif" width="5" height="33" border="0" alt=""></td>

<!--BEGIN SIDETOC-->
<td valign="top" width="175">
<div id="sidetoc" valign="bottom">
<h1 class="SideTOC1-PartTab"><a href="LowLevelComms_WiFi_Pt.html">Part V: WiFi</a> </h1>
<h1 class="SideTOC1"><a href="LowLevelComms_WiFiIntro.html">16  Introduction to Wireless Networking</a></h1>

   <h2 class="SideTOC2"><a href="#993351">
   Overview</a></h2>

   <h2 class="SideTOC2"><a href="#994037">
   WiFi Concepts</a></h2>

   <h2 class="SideTOC2"><a href="#994133">
   Locating and Opening a WiFi Interface</a></h2>

   <h2 class="SideTOC2"><a href="#996119">
   Getting Information About the WiFi Interface</a></h2>

      <h3 class="SideTOC3"><a href="#996176">
      Determining Supported Encryption Modes</a></h3>

      <h3 class="SideTOC3"><a href="#996304">
      Getting the Interface Status</a></h3>

      <h3 class="SideTOC3"><a href="#996606">
      Identifying the Currently Connected Network</a></h3>

      <h3 class="SideTOC3"><a href="#996900">
      Determining Supported Channels and Transmission Rates</a></h3>

      <h3 class="SideTOC3"><a href="#996921">
      Getting the Signal Strength</a></h3>

   <h2 class="SideTOC2"><a href="#994167">
   Finding an Access Point or Ad-hoc Network</a></h2>

      <h3 class="SideTOC3"><a href="#994729">
      Active Scanning</a></h3>

      <h3 class="SideTOC3"><a href="#994746">
      Passive Scanning</a></h3>

      <h3 class="SideTOC3"><a href="#994868">
      Obtaining Scan Results</a></h3>

   <h2 class="SideTOC2"><a href="#995627">
   Configuring Encryption</a></h2>

   <h2 class="SideTOC2"><a href="#993995">
   Connecting To a Network</a></h2>

   <h2 class="SideTOC2"><a href="#994113">
   Managing a Wireless Connection</a></h2>

   <h2 class="SideTOC2"><a href="#994001">
   Disconnecting From a Network</a></h2>

   <h2 class="SideTOC2"><a href="#996059">
   Creating an Ad-hoc Network</a></h2>

</div>
</td>

<td width="5">&nbsp;&nbsp;</td>
<td width="2" background="images/index_r8_c10.gif"><img src="images/shim.gif" width="2" height="75" border="0" alt=""></td>
<td width="5">&nbsp;&nbsp;</td>

<!--END SIDETOC-->

<td valign="top">

<!--BEGIN CONTENT-->
<div id="content" valign="bottom">
<h2 class="haH2">
  <a name="993351"> </a>Overview <a href="#608590"><span class="nav">^TOP^</span></a>
</h2>


<p><a name="993988"> </a>Palm OS<sup>&#174;</sup> provides direct support for WiFi wireless networking through a set of <code>ioctl</code> commands that allow an application to find, connect to, and disconnect from wireless networks. Other commands allow applications to monitor the status of a wireless network, configure wireless security, and perform other standard management tasks necessary when using WiFi networking.</p>

<p><a name="993990"> </a>While the operating system includes the necessary user interface to manage WiFi connectivity, these <code>ioctl</code> commands are available for developers to provide custom solutions.</p>

<h2 class="haH2">
  <a name="994037"> </a>WiFi Concepts <a href="#608590"><span class="nav">^TOP^</span></a>
</h2>


<p><a name="994046"> </a>A WiFi network is identified by an <b>SSID</b>. The SSID is an ASCII string of up to 32 characters.</p>

<p><a name="994057"> </a>There are two types of WiFi networks. The typical network, operating in <b>infrastructure mode</b>, is formed by devices connecting wirelessly to an access <b>access point</b>, which is a dedicated device. This device is also sometimes referred to as a base station. Each access point is a <b>Basic Service Set</b> (BSS). An <b>Extended Service Set</b> (ESS) is a entwork of one or more access points that is referred to by a single SSID.</p>

<p><a name="994086"> </a>The other type of network, called an <b>ad-hoc network</b>, is created when one or more devices are connected together wirelessly without a dedicated access point.</p>

<h2 class="haH2">
  <a name="994133"> </a>Locating and Opening a WiFi Interface <a href="#608590"><span class="nav">^TOP^</span></a>
</h2>


<p><a name="994166"> </a>Before you can manage WiFi, you need to find and open the WiFi interface. This is done using <a href="IOSInstall_DUAttrRef.html#1051803"><code>IOSGetDriverNameByIndex()</code></a> and <a href="LowLevelComms_StdioRef.html#993320"><code>IOSOpen()</code></a>. See <a href="LowLevelComms_WiFiIntro.html#994188">Listing 16.1</a> for an example.</p>
<p class="CCodeCaption">
  <a name="994188"> </a><b>Listing 16.1&nbsp;&nbsp;Finding and opening the WiFi interface</b>
</p>

<div class="CodeRule"><hr></div><pre class="CodeBlock">
char name[64];<a name="994197"> </a>
uint16_t nameLen sizeof(name);<a name="994204"> </a>
status_t err;<a name="994216"> </a>
<a name="994209"> </a>
IOSGetDriverNameByIndex(iosDriverClassWifi, 0, (char *) name,<a name="994214"> </a>
			&amp;nameLen);<a name="994221"> </a>
int32 wifiDataFD = IOSOpen(name, 0, &amp;err);<a name="994215"> </a>
<a name="998019"> </a>
strcat(name, "_mgmt");<a name="998020"> </a>
int32 wifiMgmtFD = IOSOpen(name, 0, &amp;err);<a name="998021"> </a>
</pre><div class="CodeRule"><hr></div>


<p><a name="998022"> </a>To send data over WiFi, you simply open the interface using the name returned by <code>IOSGetDriverNameByIndex()</code>. If, however, you want to send ioctl commands to the WiFi interface, you need to append the string "_mgmt" to the returned name to access the management interface.</p>

<h2 class="haH2">
  <a name="996119"> </a>Getting Information About the WiFi Interface <a href="#608590"><span class="nav">^TOP^</span></a>
</h2>


<p><a name="996120"> </a>Before using the WiFi interface, your application may need to obtain information about the device's capabilities or status. For example, you may need to determine what forms of encryption it supports, whether or not it's already connected to a network, or what channels and transmission rates it supports.</p>
<h3 class="hbH3">
  <a name="996176"> </a>Determining Supported Encryption Modes <a href="#608590"><span class="nav">^TOP^</span></a>
</h3>


<p><a name="996177"> </a>To determine which encryption modes the interface supports, use the <a href="LowLevelComms_WiFiRef.html#995015"><code>WIOCGETSECCAPS</code></a> command, as demonstrated in <a href="LowLevelComms_WiFiIntro.html#996181">Listing 16.2</a>.</p>
<p class="CCodeCaption">
  <a name="996181"> </a><b>Listing 16.2&nbsp;&nbsp;Getting supported encryption modes</b>
</p>

<div class="CodeRule"><hr></div><pre class="CodeBlock">
WifiGetSecCapType modes;<a name="996207"> </a>
status_t err;<a name="996214"> </a>
<a name="996219"> </a>
IOSIoctl(wifiFD, WIOCGETSECCAPS, (int32_t) &amp;modes, &amp;err);<a name="996224"> </a>
<a name="996229"> </a>
if (modes.capabilities &amp; WifiSecOpen) {<a name="996245"> </a>
	/* Open System is supported */<a name="996246"> </a>
}<a name="996247"> </a>
<a name="996248"> </a>
if (modes.capabilities &amp; WifiSecWEP) {<a name="996249"> </a>
	/ * WEP is supported */<a name="996250"> </a>
}<a name="996251"> </a>
</pre><div class="CodeRule"><hr></div>

<h3 class="hbH3">
  <a name="996304"> </a>Getting the Interface Status <a href="#608590"><span class="nav">^TOP^</span></a>
</h3>


<p><a name="996332"> </a>You can obtain information about the current status of the WiFi interface using the <a href="LowLevelComms_WiFiRef.html#1003404"><code>WIOCGETSTATUS</code></a> <code>ioctl</code>. This is seen in <a href="LowLevelComms_WiFiIntro.html#996397">Listing 16.3</a>.</p>
<p class="CCodeCaption">
  <a name="996397"> </a><b>Listing 16.3&nbsp;&nbsp;Getting the current status of the WiFi interface</b>
</p>

<div class="CodeRule"><hr></div><pre class="CodeBlock">
uint32_t status;<a name="996414"> </a>
status_t err;<a name="996425"> </a>
<a name="996443"> </a>
IOSIoctl(wifiFD, WIOCGETSTATUS, (int32_t) &amp;status, &amp;err);<a name="996448"> </a>
</pre><div class="CodeRule"><hr></div>


<p><a name="996466"> </a>After <a href="LowLevelComms_StdioRef.html#996638"><code>IOSIoctl()</code></a> returns, <code>status</code> contains a value indicating the current state of the WiFi interface:</p>
<ul type="disc">
  <li><a name="996474"> </a><a href="LowLevelComms_WiFiRef.html#1003214"><code>WifiStatusDisconnected</code></a> indicates that the interface is not currently connected to a network.
  <li><a name="996480"> </a><a href="LowLevelComms_WiFiRef.html#1003218"><code>WifiStatusConnectedAccessPoint</code></a> indicates that the interface is connected to an access point.
  <li><a name="996503"> </a><a href="LowLevelComms_WiFiRef.html#1003220"><code>WifiStatusConnectedAdHoc</code></a> indicates that the interface is connected to an ad-hoc network.
  <li><a name="996522"> </a><a href="LowLevelComms_WiFiRef.html#1003222"><code>WifiStatusOutOfRange</code></a> indicates that the interface is currently connected, but that the network is not currently in range. The state will automatically return to <code>WifiStatusConnectedAccessPoint</code> or <code>WifiStatusConnectedAdHoc</code> when the network is in range again.
  <li><a name="996545"> </a><a href="LowLevelComms_WiFiRef.html#1003216"><code>WifiStatusConnecting</code></a> indicates that the interface is in the process of attempting to establish a connection.
  <li><a name="996566"> </a><a href="LowLevelComms_WiFiRef.html#1003224"><code>WifiStatusConnectionFailed</code></a> indicates that the most recent connection attempt failed.
  <li><a name="996590"> </a><a href="LowLevelComms_WiFiRef.html#1003212"><code>WifiStatusUndefined</code></a> indicates that for whatever reason, the interface's status could not be determined.
</ul>
<h3 class="hbH3">
  <a name="996606"> </a>Identifying the Currently Connected Network <a href="#608590"><span class="nav">^TOP^</span></a>
</h3>


<p><a name="996626"> </a>If you wish to determine the SSID or BSSID of the network to which the interface is connected, use the <a href="LowLevelComms_WiFiRef.html#998215"><code>WIOCGETSSID</code></a> or <a href="LowLevelComms_WiFiRef.html#998424"><code>WIOCGETBSSID</code></a> command.</p>
<p class="CCodeCaption">
  <a name="996627"> </a><b>Listing 16.4&nbsp;&nbsp;Getting the name and BSSID of the access point or ad-hoc network</b>
</p>

<div class="CodeRule"><hr></div><pre class="CodeBlock">
WifiSSIDType ssid;<a name="996721"> </a>
WifiBSSIDType bssid;<a name="996778"> </a>
status_t err;<a name="996741"> </a>
<a name="996773"> </a>
IOSIoctl(wifiFD, WIOCGETSSID, (int32_t) &amp;ssid, &amp;err);<a name="996751"> </a>
IOSIoctl(wifiFD, WIOCGETBSSID, (int32_t) &amp;bssid, &amp;err);<a name="996783"> </a>
</pre><div class="CodeRule"><hr></div>

<h3 class="hbH3">
  <a name="996900"> </a>Determining Supported Channels and Transmission Rates <a href="#608590"><span class="nav">^TOP^</span></a>
</h3>


<p><a name="996920"> </a>To determine which channels the WiFi interface supports, use the <a href="LowLevelComms_WiFiRef.html#1003474"><code>WIOCGETCHANNEL</code></a> command. This also reports the channel the interface is currently using.</p>
<p class="CCodeCaption">
  <a name="996956"> </a><b>Listing 16.5&nbsp;&nbsp;Determining supported channels</b>
</p>

<div class="CodeRule"><hr></div><pre class="CodeBlock">
status_t err;<a name="996962"> </a>
WifiChannelType channels;<a name="996963"> </a>
<a name="996964"> </a>
channels.current = 0;<a name="996982"> </a>
channels.supportedMask = 0;<a name="996991"> </a>
<a name="997000"> </a>
IOSIoctl(wifiFD, WIOCGETCHANNEL, (int32_t) &amp;channels, &amp;err);<a name="997005"> </a>
</pre><div class="CodeRule"><hr></div>


<p><a name="997079"> </a>After this code executes, <code>channels.current</code> is set to the channel on which the interface is currently communicating, and <code>channels.supportedMask</code> is a bit mask of all the channels the interface supports. See <a href="LowLevelComms_WiFiRef.html#999140">"Channel Constants"</a> for a list of the channel number flags.</p>

<p><a name="997247"> </a>The code in <a href="LowLevelComms_WiFiIntro.html#997098">Listing 16.6</a> determines the rates supported by the interface, which rates are preferred, and what rate is currently in use.</p>
<p class="CCodeCaption">
  <a name="997098"> </a><b>Listing 16.6&nbsp;&nbsp;Determining supported transmission rates</b>
</p>

<div class="CodeRule"><hr></div><pre class="CodeBlock">
WifiGetRatesType rates;<a name="997142"> </a>
status_t err;<a name="997155"> </a>
<a name="997186"> </a>
rates.preferred_rates = 0;<a name="997195"> </a>
rates.supported_rates = 0;<a name="997204"> </a>
rates.current_rate = 0;<a name="997213"> </a>
<a name="997214"> </a>
IOSIoctl(wifiFD, WIOCGETRATES, (int32_t) &amp;rates, &amp;err);<a name="997215"> </a>
</pre><div class="CodeRule"><hr></div>


<p><a name="997229"> </a>On return, <code>rates.current_rate</code> indicates the transmission rate currently in effect, <code>rates.supported_rates</code> is a bit mask of all the transmission rates the interface supports, and <code>rates.preferred_rates</code> is a bit mask of the rates the interface is best suited for. See <a href="LowLevelComms_WiFiRef.html#993700">"Transmission Rate Flags"</a> for the possible values.</p>

<div><hr>
  <a name="997930"> </a> <b>NOTE: </b> The preferred rates always default to the complete set of supported rates. You may change them if you wish, using the <a href="LowLevelComms_WiFiRef.html#993467"><code>WIOCSETRATES</code></a> ioctl.
<hr>
</div>
<h3 class="hbH3">
  <a name="996921"> </a>Getting the Signal Strength <a href="#608590"><span class="nav">^TOP^</span></a>
</h3>


<p><a name="997285"> </a>There are two ways to keep apprised of the current signal strength. You can manually poll the signal strength using the <a href="LowLevelComms_WiFiRef.html#996177"><code>WIOCGETCURRENTRSSI</code></a> command, or you can enable automatic signal strength update notification.</p>
<p class="CCodeCaption">
  <a name="997330"> </a><b>Listing 16.7&nbsp;&nbsp;Getting the current signal strength</b>
</p>

<div class="CodeRule"><hr></div><pre class="CodeBlock">
WifiGetRSSIType current;<a name="997331"> </a>
<a name="997339"> </a>
IOSIoctl(wifiFD, WIOCGETCURRENTRSSI, (int32_t) &amp;current,
					&amp;err);<a name="997340"> </a>
</pre><div class="CodeRule"><hr></div>


<p><a name="997384"> </a>After the code in <a href="LowLevelComms_WiFiIntro.html#997330">Listing 16.7</a> executes, <code>current.signal</code> contains the current signal strength, as a percentage between 0 and 100.</p>

<p><a name="997401"> </a>To receive periodic notification of changes to the signal strength, use the <a href="LowLevelComms_WiFiRef.html#995911"><code>WIOCSETRSSIUPDATE</code></a> command. With this command, you can choose to receive notification events whenever any change to signal strength occurs, whenever the signal strength changes by a given amount, or at a specific interval.</p>
<p class="CCodeCaption">
  <a name="997428"> </a><b>Listing 16.8&nbsp;&nbsp;Enabling automatic signal strength notifications</b>
</p>

<div class="CodeRule"><hr></div><pre class="CodeBlock">
WifiRSSIUpdateType update;<a name="997455"> </a>
status_t err;<a name="997472"> </a>
<a name="997495"> </a>
/* notify me when signal strength changes by +/- 2% */<a name="997508"> </a>
<a name="997521"> </a>
update.updateMode = WifiRSSIUpdateOnDelta;<a name="997534"> </a>
update.updateValue = 2;<a name="997542"> </a>
<a name="997547"> </a>
/* notify me every 1000 milliseconds */<a name="997552"> </a>
<a name="997566"> </a>
update.updateMode = WifiRSSIUpdatePeriodic;<a name="997567"> </a>
update.updateValue = 1000;<a name="997568"> </a>
<a name="997588"> </a>
/* notify me every time the signal strength changes */<a name="997593"> </a>
<a name="997594"> </a>
update.updateMode = WifiRSSIUpdateAlways;<a name="997595"> </a>
update.updateValue = 0;<a name="997596"> </a>
<a name="997597"> </a>
/* never notify me of signal strength changes */<a name="997598"> </a>
<a name="997618"> </a>
update.updateMode = WifiRSSIUpdateNever;<a name="997619"> </a>
update.updateValue = 0;<a name="997635"> </a>
<a name="997636"> </a>
IOSIoctl(wifiFD, WIOCSETRSSIUPDATE, (int32_t) &amp;update, &amp;err);<a name="997637"> </a>
</pre><div class="CodeRule"><hr></div>


<p><a name="997657"> </a>The example in <a href="LowLevelComms_WiFiIntro.html#997428">Listing 16.8</a> shows how to set up the <code>WifiRSSIUpdateType</code> structure for each of the four notification modes. Once the structure is prepared, call <a href="LowLevelComms_StdioRef.html#996638"><code>IOSIoctl()</code></a> to issue the request.</p>

<h2 class="haH2">
  <a name="994167"> </a>Finding an Access Point or Ad-hoc Network <a href="#608590"><span class="nav">^TOP^</span></a>
</h2>


<p><a name="994006"> </a>To locate an access point or ad-hoc network to which you can connect, you need to use the <a href="LowLevelComms_WiFiRef.html#999023"><code>WIOCSCAN</code></a> or <a href="LowLevelComms_WiFiRef.html#999579"><code>WIOCPASSIVESCAN</code></a> command.</p>
<h3 class="hbH3">
  <a name="994729"> </a>Active Scanning <a href="#608590"><span class="nav">^TOP^</span></a>
</h3>


<p><a name="994654"> </a>If you want to simply perform a one-time scan of the airwaves for available ad-hoc networks and access points, use <code>WIOCSCAN</code>. See <a href="LowLevelComms_WiFiIntro.html#994663">Listing 16.9</a>.</p>
<p class="CCodeCaption">
  <a name="994663"> </a><b>Listing 16.9&nbsp;&nbsp;Performing a one-shot scan for access points and ad-hoc networks</b>
</p>

<div class="CodeRule"><hr></div><pre class="CodeBlock">
WifiScanRequestType cmd;<a name="994669"> </a>
status_t err;<a name="994672"> </a>
<a name="994677"> </a>
memset(&amp;cmd, 0, sizeof(WifiScanRequestType));<a name="994678"> </a>
<a name="994679"> </a>
cmd.channels = WifiChannel_All;<a name="994684"> </a>
cmd.rates = WifiRate_All;<a name="994689"> </a>
cmd.timeout = 2000;<a name="994693"> </a>
cmd.blockTillCompletion = 0;<a name="997977"> </a>
IOSIoctl(wifiFD, WIOCSCAN, (int32_t) &amp;cmd, &amp;err);<a name="994699"> </a>
</pre><div class="CodeRule"><hr></div>


<p><a name="994712"> </a>The scan is performed asynchronously; the <code>IOSIoctl()</code> will return immediately. Your application's event loop will receive WiFi events with the scan results. See <a href="LowLevelComms_WiFiIntro.html#994868">"Obtaining Scan Results"</a> for details on how to parse the results.</p>

<p><a name="997968"> </a>The <code>blockTillCompletion</code> flag indicates whether or not you want the ioctl to block until the first scan result arrives. This example sets it to 0, indicating that we want to return immediately.</p>
<h3 class="hbH3">
  <a name="994746"> </a>Passive Scanning <a href="#608590"><span class="nav">^TOP^</span></a>
</h3>


<p><a name="994761"> </a>If you would prefer to constantly be kept informed of the available access points and ad-hoc networks, as they move in and out of range, or are turned on and off, you can enable passive scanning mode. While in passive scanning mode, your application's event loop will receive scan result events when appropriate. See <a href="LowLevelComms_WiFiIntro.html#994800">Listing 16.10</a> for an example of how to enable passive scanning.</p>
<p class="CCodeCaption">
  <a name="994800"> </a><b>Listing 16.10&nbsp;&nbsp;Enabling passive scanning</b>
</p>

<div class="CodeRule"><hr></div><pre class="CodeBlock">
WifiPassiveScanType scan;<a name="994809"> </a>
status_t err;<a name="994819"> </a>
<a name="994820"> </a>
memset(&amp;scan, 0, sizeof(WifiPassiveScanType));<a name="994821"> </a>
<a name="994822"> </a>
scan.enableScanning = true;<a name="994828"> </a>
scan.channelMask = WifiChannel_All;<a name="994829"> </a>
scan.rateMask = WifiRate_All;<a name="994830"> </a>
scan.interval = 1000;<a name="994831"> </a>
<a name="994826"> </a>
IOSIoctl(wifiFD, WIOCPASSIVESCAN, (int32_t) &amp;scan, &amp;err);<a name="994835"> </a>
</pre><div class="CodeRule"><hr></div>


<p><a name="994841"> </a>The example above enables scanning for access points or ad-hoc networks operating on any channel and at any transmission rate. Scan results will be delivered to the application every 1,000 milliseconds.</p>

<p><a name="994856"> </a>To disable passive scanning, issue the <a href="LowLevelComms_WiFiRef.html#999579"><code>WIOCPASSIVESCAN</code></a> command again, with the <code>enableScanning</code> field set to <code>false</code>.</p>
<h3 class="hbH3">
  <a name="994868"> </a>Obtaining Scan Results <a href="#608590"><span class="nav">^TOP^</span></a>
</h3>


<p><a name="995187"> </a>Normally, your application receives scan results as a <a href="LowLevelComms_WiFiRef.html#1004568"><code>wifiScanResults</code></a> event in its event loop. The event's <a href="LowLevelComms_WiFiRef.html#1004784"><code>WifiEventType</code></a> structure describes the detected access point in detail. Each time an access point or ad-hoc network is found, a <a href="LowLevelComms_WiFiRef.html#1004568"><code>wifiScanResults</code></a> event is delivered.</p>

<p><a name="995191"> </a>You can also manually fetch the scan results from the WiFi adapter by using the <a href="LowLevelComms_WiFiRef.html#999884"><code>WIOCGETSCANRESULTS</code></a> command. This command can be used in a loop to fetch all the scan results available, as seen in <a href="LowLevelComms_WiFiIntro.html#995293">Listing 16.11</a>.</p>
<p class="CCodeCaption">
  <a name="995293"> </a><b>Listing 16.11&nbsp;&nbsp;Using WIOCGETSCANRESULTS</b>
</p>

<div class="CodeRule"><hr></div><pre class="CodeBlock">
uint16_t index = 0;<a name="995312"> </a>
uint16_t last = 0;<a name="995348"> </a>
WifiGetScanResultsType scan;<a name="995362"> </a>
status_t err; <a name="995349"> </a>
<a name="995335"> </a>
do {<a name="995378"> </a>
	memset(&amp;scan, 0, sizeof(WifiGetScanResultsType));<a name="995379"> </a>
	scan.last = last;<a name="995380"> </a>
	scan.index = index;<a name="995381"> </a>
<a name="995382"> </a>
	IOSIoctl(m_fd, WIOCGETSCANRESULTS, (int32_t)&amp;scan, &amp;err);<a name="995384"> </a>
<a name="995386"> </a>
	if (err == P_OK) {<a name="995387"> </a>
		/* results received successfully in scan */<a name="995579"> </a>
	}<a name="995453"> </a>
	else {<a name="995454"> </a>
		/* error receiving scan results */<a name="995455"> </a>
	}<a name="995456"> </a>
	<a name="995457"> </a>
	last = scan.last;<a name="995458"> </a>
	index = scan.index;<a name="995459"> </a>
<a name="995460"> </a>
	index++;<a name="995461"> </a>
} while (index &lt;= last);<a name="995463"> </a>
</pre><div class="CodeRule"><hr></div>


<h2 class="haH2">
  <a name="995627"> </a>Configuring Encryption <a href="#608590"><span class="nav">^TOP^</span></a>
</h2>


<p><a name="995636"> </a>WiFi supports the concept of encryption to protect data security. There are two security modes currently supported by Palm OS: open system (unencrypted) and Wired Equivalent Privacy (WEP).</p>

<p><a name="995681"> </a>To use WEP encryption, an encryption key needs to be configured prior to connecting to the network. There are three steps required to accomplish this. First, it's necessary to store the key in the adapter. A WiFi adapter can store up to four encryption keys, which can then be selected among depending on which network is being accessed.</p>
<p class="CCodeCaption">
  <a name="995708"> </a><b>Listing 16.12&nbsp;&nbsp;Setting an encryption key</b>
</p>

<div class="CodeRule"><hr></div><pre class="CodeBlock">
WifiSetWEPKeyType arg;<a name="995735"> </a>
status_t err;<a name="995748"> </a>
<a name="995767"> </a>
arg.key = 0;                /* key number to set */<a name="995780"> </a>
<a name="995788"> </a>
memset(arg.data, 0, 16);<a name="995793"> </a>
arg.data_len = Ascii2Binary(arg.data, keyString, 16);<a name="995798"> </a>
<a name="995806"> </a>
IOSIoctl(wifiFD, WIOCSETKEY, (int32_t) &amp;arg, &amp;err);<a name="995807"> </a>
</pre><div class="CodeRule"><hr></div>


<p><a name="995808"> </a>The code in <a href="LowLevelComms_WiFiIntro.html#995708">Listing 16.12</a> sets key 0 to the string specified by <code>keyString</code>. See <a href="LowLevelComms_WiFiIntro.html#994441">Listing 16.17</a> for the code for the <code>Ascii2Binary()</code> function.</p>

<p><a name="995821"> </a>Once the key has been stored on the adapter, it must be selected using the <a href="LowLevelComms_WiFiRef.html#993852"><code>WIOCSETDEFAULTKEY</code></a> command. See <a href="LowLevelComms_WiFiIntro.html#995825">Listing 16.13</a>.</p>
<p class="CCodeCaption">
  <a name="995825"> </a><b>Listing 16.13&nbsp;&nbsp;Selecting the default key</b>
</p>

<div class="CodeRule"><hr></div><pre class="CodeBlock">
status_t err;<a name="995831"> </a>
<a name="995838"> </a>
IOSIoctl(wifiFD, WIOCSETDEFAULTKEY, (int32_t) 0, &amp;err);<a name="995839"> </a>
</pre><div class="CodeRule"><hr></div>


<p><a name="995858"> </a>Finally, once the key has been selected, it's possible to put the interface into WEP mode by using the <a href="LowLevelComms_WiFiRef.html#994870"><code>WIOCSETSECMODE</code></a> command, as seen in <a href="LowLevelComms_WiFiIntro.html#995865">Listing 16.14</a>.</p>
<p class="CCodeCaption">
  <a name="995865"> </a><b>Listing 16.14&nbsp;&nbsp;Enabling encryption</b>
</p>

<div class="CodeRule"><hr></div><pre class="CodeBlock">
status_t err;<a name="995866"> </a>
uint32_t mode = WifiSecWEP;<a name="995878"> </a>
<a name="995934"> </a>
IOSIoctl(wifiFD, WIOCSETSECMODE, (int32_t) &amp;mode, &amp;err);<a name="995943"> </a>
</pre><div class="CodeRule"><hr></div>


<p><a name="995960"> </a>To disable encryption, simply set the mode to <a href="LowLevelComms_WiFiRef.html#994917"><code>WifiSecOpen</code></a>.</p>

<h2 class="haH2">
  <a name="993995"> </a>Connecting To a Network <a href="#608590"><span class="nav">^TOP^</span></a>
</h2>


<p><a name="994105"> </a>Once you have found an access point or ad-hoc network to which you wish to connect, you can connect to that network using either the <a href="LowLevelComms_WiFiRef.html#996179"><code>WIOCCONNECT</code></a> or the <a href="LowLevelComms_WiFiRef.html#1004155"><code>WIOCJOIN</code></a> <code>ioctl</code>.</p>

<p><a name="994112"> </a>If you have the SSID of the network or ad-hoc network, you use the <a href="LowLevelComms_WiFiRef.html#996179"><code>WIOCCONNECT</code></a> command, as shown in <a href="LowLevelComms_WiFiIntro.html#994123">Listing 16.15</a>.</p>
<p class="CCodeCaption">
  <a name="994123"> </a><b>Listing 16.15&nbsp;&nbsp;Connecting to a wireless network using an SSID</b>
</p>

<div class="CodeRule"><hr></div><pre class="CodeBlock">
WifiConnectType arg;<a name="994124"> </a>
status_t err;<a name="994132"> </a>
<a name="994127"> </a>
strncpy(arg.ssid, theSSID, 32);<a name="994128"> </a>
arg.timeout = 3000;<a name="994129"> </a>
arg.blockTillCompletion = false;<a name="994130"> </a>
IOSIoctl(wifiFD, WIOCCONNECT, (int32_t) &amp;arg, &amp;err);<a name="994131"> </a>
</pre><div class="CodeRule"><hr></div>


<p><a name="994326"> </a>In this example, we choose to try for three seconds (3,000 milliseconds) before timing out. In addition, since the <code>blockTillCompletion</code> flag is set to false, the call will return at once. We must then check the status of the connection periodically to detect when the connection is actually opened (or if the connection fails to open).</p>

<p><a name="994918"> </a>Your event loop (using either a Pollbox or <a href="LowLevelComms_StdioRef.html#997909"><code>IOSPoll()</code></a>) will receive notifications as the status of the connection changes: <a href="LowLevelComms_WiFiRef.html#1004558"><code>wifiConnectAccessPoint</code></a> or <a href="LowLevelComms_WiFiRef.html#1004560"><code>wifiConnectAdHoc</code></a> when the connection is established, <a href="LowLevelComms_WiFiRef.html#1004556"><code>wifiConnecting</code></a> while connection is being attempted, <a href="LowLevelComms_WiFiRef.html#1004564"><code>wifiOutOfRange</code></a> if the access point is out of range but was opened anyway under the assumption that it will be eventually, <a href="LowLevelComms_WiFiRef.html#1004572"><code>wifiMediaUnavailable</code></a> if the 802.11 hardware is missing, or <a href="LowLevelComms_WiFiRef.html#1004562"><code>wifiConnectFailed</code></a> if the connection could not be established.</p>

<p><a name="994413"> </a>If you have the BSSID (MAC address) and channel number of a network to which you wish to connect, you can use the <a href="LowLevelComms_WiFiRef.html#1004155"><code>WIOCJOIN</code></a> command instead, as shown in <a href="LowLevelComms_WiFiIntro.html#994420">Listing 16.16</a>.</p>
<p class="CCodeCaption">
  <a name="994420"> </a><b>Listing 16.16&nbsp;&nbsp;Connecting to a wireless network using a BSSID and channel number</b>
</p>

<div class="CodeRule"><hr></div><pre class="CodeBlock">
WifiJoinType arg;<a name="994421"> </a>
status_t err;<a name="994424"> </a>
<a name="994425"> </a>
Ascii2Binary(arg.bssid, "FF:FF:FF:FF:FF", 6);<a name="994426"> </a>
arg.channel = theChannel;<a name="994427"> </a>
IOSIoctl(wifiFD, WIOCJOIN, (int32_t) &amp;arg, &amp;err);<a name="994428"> </a>
</pre><div class="CodeRule"><hr></div>


<p><a name="994431"> </a>This code uses a function called <code>Ascii2Binary()</code> to convert the MAC ID string into the proper format. <code>Ascii2Binary()</code> is shown in <a href="LowLevelComms_WiFiIntro.html#994441">Listing 16.17</a>.</p>
<p class="CCodeCaption">
  <a name="994441"> </a><b>Listing 16.17&nbsp;&nbsp;Converting a hex string into packed binary format</b>
</p>

<div class="CodeRule"><hr></div><pre class="CodeBlock">
int Ascii2Binary(uint8_t * buf, const char* p, size_t length) <a name="994446"> </a>
{<a name="994447"> </a>
	uint8_t nibble;<a name="994448"> </a>
	size_t i = 0;<a name="994449"> </a>
	static char map[22] = {'0', '1', '2', '3', '4', '5', '6', 
'7', '8', '9', 'A', 'B', 'C', 'D', 'E', 'F', 'a', 'b', 'c', 
'd', 'e', 'f'}; <a name="994450"> </a>
<a name="994451"> </a>
	while (*p != NULL &amp;&amp; i &lt; length) {<a name="994452"> </a>
	<a name="994453"> </a>
		// Skip over MAC octet separators<a name="994454"> </a>
		if (*p == ':') {<a name="994455"> </a>
			p++;<a name="994456"> </a>
			continue;	<a name="994457"> </a>
		}<a name="994458"> </a>
		nibble = 0;<a name="994459"> </a>
		for(int j = 0; j &lt; 22; j++) {<a name="994460"> </a>
			if (p[0] == map[j]) {<a name="994461"> </a>
				<a name="994462"> </a>
				if (j &gt;= 16)<a name="994463"> </a>
					nibble = j - 6;<a name="994464"> </a>
				else<a name="994465"> </a>
					nibble = j;<a name="994466"> </a>
				break;<a name="994467"> </a>
			}<a name="994468"> </a>
		}<a name="994469"> </a>
		<a name="994470"> </a>
		buf[i] |= nibble &lt;&lt; 4;<a name="994471"> </a>
		p++;<a name="994472"> </a>
		<a name="994473"> </a>
		if (*p == NULL)<a name="994474"> </a>
			break;<a name="994475"> </a>
		<a name="994476"> </a>
		nibble = 0;<a name="994477"> </a>
		for(int j = 0; j &lt; 22; j++) {<a name="994478"> </a>
			if (p[0] == map[j]) {<a name="994479"> </a>
				if (j &gt;= 16)<a name="994480"> </a>
					nibble = j - 6;<a name="994481"> </a>
				else<a name="994482"> </a>
					nibble = j;<a name="994483"> </a>
				break;<a name="994484"> </a>
			}<a name="994485"> </a>
		}<a name="994486"> </a>
		<a name="994487"> </a>
		buf[i] |= nibble;<a name="994488"> </a>
		i++;<a name="994489"> </a>
		p++;<a name="994490"> </a>
	}<a name="994491"> </a>
<a name="994492"> </a>
	return i;<a name="994493"> </a>
}<a name="994494"> </a>
</pre><div class="CodeRule"><hr></div>


<p><a name="994623"> </a>Once a connection has been established, the wireless network can be used just like any other network connection, using the Sockets API or IOS STDIO calls.</p>

<h2 class="haH2">
  <a name="994113"> </a>Managing a Wireless Connection <a href="#608590"><span class="nav">^TOP^</span></a>
</h2>


<p><a name="995973"> </a>Once the connection is established, your application's event loop will receive events on the WiFi management file descriptor, informing you of changes in the status of the connection, as well as results of specific requests you issue. Your event loop needs to either poll the file descriptor, or use a Pollbox. These concepts are covered in <a href="LowLevelComms_StdioUsing.html#993291">"Polling STREAMS File Descriptors"</a>.</p>

<p><a name="994575"> </a>WiFi events use the <a href="LowLevelComms_WiFiRef.html#1004784"><code>WifiEventType</code></a> structure to return data to your event handler. The possible events are listed in <a href="LowLevelComms_WiFiRef.html#1004550">"Event Type Constants"</a>.</p>

<h2 class="haH2">
  <a name="994001"> </a>Disconnecting From a Network <a href="#608590"><span class="nav">^TOP^</span></a>
</h2>


<p><a name="994411"> </a>To disconnect from a WiFi network, use the <a href="LowLevelComms_WiFiRef.html#996773"><code>WIOCDISCONNECT</code></a> command. See <a href="LowLevelComms_WiFiIntro.html#994594">Listing 16.18</a>.</p>
<p class="CCodeCaption">
  <a name="994594"> </a><b>Listing 16.18&nbsp;&nbsp;Disconnecting from a WiFi network</b>
</p>

<div class="CodeRule"><hr></div><pre class="CodeBlock">
status_t err;<a name="994604"> </a>
IOSIoctl(wifiFD, WIOCDISCONNECT, NULL, &amp;err);<a name="994606"> </a>
</pre><div class="CodeRule"><hr></div>


<h2 class="haH2">
  <a name="996059"> </a>Creating an Ad-hoc Network <a href="#608590"><span class="nav">^TOP^</span></a>
</h2>


<p><a name="996061"> </a>Palm OS devices can create an ad-hoc network using the <a href="LowLevelComms_WiFiRef.html#1003869"><code>WIOCCREATEIBSS</code></a> <code>ioctl</code>.</p>
<p class="CCodeCaption">
  <a name="996095"> </a><b>Listing 16.19&nbsp;&nbsp;Creating an ad-hoc network</b>
</p>

<div class="CodeRule"><hr></div><pre class="CodeBlock">
WifiCreateIBSSType ibss;<a name="996105"> </a>
status_t err;<a name="996107"> </a>
<a name="996108"> </a>
memset(&amp;ibss, 0, sizeof(WifiCreateIBSSType));<a name="996109"> </a>
strncpy(ibss.ssid, "MyAdhocNet", 32);<a name="996110"> </a>
ibss.channel = 8;<a name="996111"> </a>
<a name="996112"> </a>
IOSIoctl(wifiFD, WIOCCREATEIBSS, (int32_t) &amp;ibss, &amp;err);<a name="996113"> </a>
</pre><div class="CodeRule"><hr></div>


<p><a name="996114"> </a>The example in <a href="LowLevelComms_WiFiIntro.html#996095">Listing 16.19</a> creates a new ad-hoc network named "MyAdhocNet" operating on channel 8. If this is successful, other WiFi-enabled devices can then connect to the new ad-hoc network just like any other network.</p>
&nbsp;<br>
</div>
<!--END CONTENT-->

</td>
<td width="5">&nbsp;&nbsp;</td>
</tr>

</table>

<!-- BEGIN FOOTER -->
<table width="100%" border="0" cellspacing="0" cellpadding="0">
<tr>
<td width="7" rowspan="2"><img name="index_x" src="images/shim.gif" width="7" height="33" border="0" alt=""></td>
<td align="left"><img name="dashes" src="images/dashes.gif" width="744" height="3" border="0" alt=""></td>
<td width="10" rowspan="2"><img name="index_x" src="images/shim.gif" width="10" height="33" border="0" alt=""></td>
</tr>
<tr>
<td align="center">
<p class="footer">
Copyright © 2004, PalmSource, Inc. and its affiliates.  All rights reserved. <br>
<a href="http://www.palmsource.com/contact/">Write Us</a> | <a href="http://www.palmos.com/dev/training/">Training</a> | <a href="http://www.palmos.com/dev/support/kb/">Knowledge Base</a> | <a href="LowLevelComms_Front.html" target="_blank">Legal</a></p>
<br>
<!--BEGIN BOOK NAVIGATION-->
<p class="nav">
<A href="http://www.palmos.com/dev/support/docs/">Documentation</a>&nbsp;&nbsp;|&nbsp;&nbsp;
<a href="LowLevelCommsTOC.html">Table of Contents</a>&nbsp;&nbsp;
             |&nbsp;&nbsp;<a href="LowLevelComms_WiFi_Pt.html">&lt;&nbsp;Previous</a>&nbsp;&nbsp;
             |&nbsp;&nbsp;<a href="LowLevelComms_WiFiRef.html">Next&nbsp;&gt;</a>&nbsp;&nbsp;
             |&nbsp;&nbsp;<a href="LowLevelCommsIX.html">Index</a>
</p>
</td>
</tr>
</table>
<!-- END FOOTER -->

</body>
</html>