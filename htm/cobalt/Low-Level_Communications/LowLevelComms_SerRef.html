<html>
<head>
<title>(Protein) Serial Manager Reference | Low-Level Communications</title> 
<link href="psi_devpubs.css" rel="stylesheet" type="text/css">

<!-- BEGIN META DATA -->
<meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
<META NAME="PSITEMPLATE" CONTENT="1006-007 PalmSource_HTML_2003 20041101">
<META NAME="GENERATOR" CONTENT="Quadralay WebWorks AutoMap 2003 for FrameMaker 8.0.6.2138">
<META NAME="LASTUPDATED" CONTENT="11/22/04 11:13:56">
<!-- END META DATA -->
</head>

<body bgcolor="#ffffff" text="#000000" leftmargin="0" topmargin="0" marginwidth="0" marginheight="0">
<a name="608590"></a>

<!-- BEGIN TOPNAV -->
<table width="100%" border="0" cellspacing="0" cellpadding="0">
<tr>
<td><img src="images/shim.gif" width="7" height="75" border="0" alt=""></td>
<td align="left"><table border="0" cellpadding="0" cellspacing="0" width="744">
<tr>
<td><img name="index_r2_c1" src="images/shim.gif" width="25" height="75" border="0" alt=""></td>
<td valign="top"><table border="0" cellpadding="0" cellspacing="0" width="96">
<tr>
<td><img name="index_r2_c4" src="images/shim.gif" width="96" height="15" border="0" alt=""></td>
</tr>
<tr>
<td><a href="http://www.palmsource.com/"><img name="ps_logo" src="images/ps_logo.gif" width="96" height="54" border="0" alt=""></a></td>
</tr>

</table>
</td>

<td><table border="0" cellpadding="0" cellspacing="0" width="30">
<td><img name="index_x" src="images/shim.gif" width="30" height="75" border="0" alt=""></td>
</table></td>

<!--BEGIN MASTHEAD-->
<td><table border="0" cellpadding="0" cellspacing="0" width="96">
<tr>
<td><img name="index_x" src="images/shim.gif" width="615" height="5" border="0" alt=""></td>
</tr>
<tr>
<td>
<!--BEGIN BOOK NAVIGATION-->
<span class="nav">
<A href="http://www.palmos.com/dev/support/docs/">Documentation</a>&nbsp;&nbsp;|&nbsp;&nbsp;
<a href="LowLevelCommsTOC.html">Table of Contents</a>&nbsp;&nbsp;
             |&nbsp;&nbsp;<a href="LowLevelComms_SerLink.html">&lt;&nbsp;Previous</a>&nbsp;&nbsp;
             |&nbsp;&nbsp;<a href="LowLevelComms_SlkRef.html">Next&nbsp;&gt;</a>&nbsp;&nbsp;
             |&nbsp;&nbsp;<a href="LowLevelCommsIX.html">Index</a>
</span>
<!--END BOOK NAVIGATION-->
</tr>
<tr>
<td>
<!--BEGIN PAGE TITLE-->
<h2 class="PageTitle">4 &nbsp;&nbsp;
Serial Manager Reference</h2></td>
<!--END PAGE TITLE-->
</tr>
<tr>
<td>
<!--BEGIN BOOK TITLE-->
<p class="BookTitle">Low-Level Communications</p>
<p class="SubTitle">Exploring Palm OS&#174; </p>
<!--END BOOK TITLE-->
</td>
</tr>
<tr>
<td><img name="index_x" src="images/shim.gif" width="615" height="5" border="0" alt=""></td>
</tr>
</table>
</td>
<!--END MASTHEAD-->
</tr>
</table>
<img name="dashes" src="images/dashes.gif" width="744" height="3" border="0" alt=""></td>
</tr>
</table>
<!-- END TOPNAV -->

<table width="100%" border="0" cellspacing="0" cellpadding="0">
<tr>
<td valign="top" width="5"><img name="index_x" src="images/shim.gif" width="5" height="33" border="0" alt=""></td>

<!--BEGIN SIDETOC-->
<td valign="top" width="175">
<div id="sidetoc" valign="bottom">
<h1 class="SideTOC1-PartTab"><a href="LowLevelComms_Serial_Pt.html">Part I: Serial Communication</a> </h1>
<h1 class="SideTOC1"><a href="LowLevelComms_SerRef.html">4  Serial Manager Reference</a></h1>

   <h2 class="SideTOC2"><a href="#993230">
   Serial Manager Data Structures</a></h2>

      <h3 class="SideTOC3"><a href="#993232">
      DeviceInfoType</a></h3>

      <h3 class="SideTOC3"><a href="#993424">
      SrmOpenConfigType</a></h3>

      <h3 class="SideTOC3"><a href="#993482">
      SrmRfCommOpenParamsType</a></h3>

   <h2 class="SideTOC2"><a href="#993492">
   Serial Manager Constants</a></h2>

      <h3 class="SideTOC3"><a href="#993494">
      Port Constants</a></h3>

      <h3 class="SideTOC3"><a href="#993647">
      Serial Capabilities Constants</a></h3>

      <h3 class="SideTOC3"><a href="#1016597">
      Serial Settings Constants</a></h3>

      <h3 class="SideTOC3"><a href="#1017945">
      SrmCtlEnum</a></h3>

      <h3 class="SideTOC3"><a href="#1031256">
      Status Constants</a></h3>

      <h3 class="SideTOC3"><a href="#1041688">
      Line Error Constants</a></h3>

   <h2 class="SideTOC2"><a href="#1002427">
   Serial Manager Functions</a></h2>

      <h3 class="SideTOC3"><a href="#1002430">
      SrmClearErr</a></h3>

      <h3 class="SideTOC3"><a href="#1003382">
      SrmClose</a></h3>

      <h3 class="SideTOC3"><a href="#993980">
      SrmControl</a></h3>

      <h3 class="SideTOC3"><a href="#994192">
      SrmExtOpen</a></h3>

      <h3 class="SideTOC3"><a href="#994313">
      SrmGetDeviceCount</a></h3>

      <h3 class="SideTOC3"><a href="#994336">
      SrmGetDeviceInfo</a></h3>

      <h3 class="SideTOC3"><a href="#994376">
      SrmGetStatus</a></h3>

      <h3 class="SideTOC3"><a href="#994414">
      SrmOpen</a></h3>

      <h3 class="SideTOC3"><a href="#994504">
      SrmPrimeWakeupHandler</a></h3>

      <h3 class="SideTOC3"><a href="#994547">
      SrmReceive</a></h3>

      <h3 class="SideTOC3"><a href="#994602">
      SrmReceiveCheck</a></h3>

      <h3 class="SideTOC3"><a href="#994646">
      SrmReceiveFlush</a></h3>

      <h3 class="SideTOC3"><a href="#994690">
      SrmReceiveWait</a></h3>

      <h3 class="SideTOC3"><a href="#994754">
      SrmReceiveWindowClose</a></h3>

      <h3 class="SideTOC3"><a href="#994791">
      SrmReceiveWindowOpen</a></h3>

      <h3 class="SideTOC3"><a href="#994843">
      SrmSend</a></h3>

      <h3 class="SideTOC3"><a href="#994896">
      SrmSendCheck</a></h3>

      <h3 class="SideTOC3"><a href="#994940">
      SrmSendFlush</a></h3>

      <h3 class="SideTOC3"><a href="#994982">
      SrmSendWait</a></h3>

      <h3 class="SideTOC3"><a href="#995031">
      SrmSetReceiveBuffer</a></h3>

      <h3 class="SideTOC3"><a href="#995066">
      SrmSetWakeupHandler</a></h3>

   <h2 class="SideTOC2"><a href="#995114">
   Serial Manager Application-Defined Functions</a></h2>

      <h3 class="SideTOC3"><a href="#995117">
      WakeupHandlerProcPtr</a></h3>

</div>
</td>

<td width="5">&nbsp;&nbsp;</td>
<td width="2" background="images/index_r8_c10.gif"><img src="images/shim.gif" width="2" height="75" border="0" alt=""></td>
<td width="5">&nbsp;&nbsp;</td>

<!--END SIDETOC-->

<td valign="top">

<!--BEGIN CONTENT-->
<div id="content" valign="bottom">
<p><a name="993209"> </a>This chapter provides reference material for the Serial Manager API:</p>
<ul type="disc">
  <li><a name="993213"> </a><a href="LowLevelComms_SerRef.html#993230">Serial Manager Data Structures</a>
  <li><a name="993217"> </a><a href="LowLevelComms_SerRef.html#993492">Serial Manager Constants</a>
  <li><a name="993221"> </a><a href="LowLevelComms_SerRef.html#1002427">Serial Manager Functions</a>
  <li><a name="993225"> </a><a href="LowLevelComms_SerRef.html#995114">Serial Manager Application-Defined Functions</a>
</ul>

<p><a name="993227"> </a>The header file <code>SerialMgr.h</code> declares the Serial Manager API. The file <code>SystemResources.h</code> defines some serial port constants.</p>

<h2 class="haH2">
  <a name="993230"> </a>Serial Manager Data Structures <a href="#608590"><span class="nav">^TOP^</span></a>
</h2>


<h3 class="hbH3">
  <a name="993232"> </a>DeviceInfoType Typedef <a href="#608590"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="1014429"> </a>Purpose 
</h4>

<p><a name="993234"> </a>The <code>DeviceInfoType</code> structure defines information about a serial device. This structure is returned by the <a href="LowLevelComms_SerRef.html#994336"><code>SrmGetDeviceInfo()</code></a> function.</p>
<h4>
  <a name="1014451"> </a>Prototype 
</h4>
<pre class="proto"><a name="993239"></a>typedef struct DeviceInfoType {
   uint32_t serDevCreator; 
   uint32_t serDevFtrInfo; 
   uint32_t serDevMaxBaudRate; 
   uint32_t serDevHandshakeBaud; 
   char *serDevPortInfoStr; 
   uint8_t reserved[8];
} DeviceInfoType;
</pre>
<pre class="proto"><a name="993247"></a>typedef DeviceInfoType *DeviceInfoPtr;
</pre>
<h4>
  <a name="1014505"> </a>Fields 
</h4>

<dl>
<dt><a name="1014587"> </a><code>serDevCreator</code></dt>
<dd><a name="1014613"> </a>Four-character creator ID for serial driver.</dd>

<dt><a name="1014639"> </a><code>serDevFtrInfo</code></dt>
<dd><a name="1014668"> </a>Flags defining features of this serial hardware. See <a href="LowLevelComms_SerRef.html#993647">Serial Capabilities Constants</a> for a description of these flags.</dd>

<dt><a name="1014673"> </a><code>serDevMaxBaudRate</code></dt>
<dd><a name="1014678"> </a>Maximum baud rate for this device.</dd>

<dt><a name="1014683"> </a><code>serDevHandshakeBaud</code></dt>
<dd><a name="1014773"> </a>Hardware handshaking is recommended for baud rates over this rate.</dd>

<dt><a name="1014784"> </a><code>serDevPortInfoStr</code></dt>
<dd><a name="1014795"> </a>Description of serial hardware device or virtual device.</dd>

</dl>

<h3 class="hbH3">
  <a name="993424"> </a>SrmOpenConfigType Struct <a href="#608590"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="1018296"> </a>Purpose 
</h4>

<p><a name="993426"> </a>The <code>SrmOpenConfigType</code> structure specifies parameters for opening a serial port. This structure is passed as a parameter to <a href="LowLevelComms_SerRef.html#994192"><code>SrmExtOpen()</code></a>. </p>
<h4>
  <a name="1018566"> </a>Prototype 
</h4>
<pre class="proto"><a name="993430"></a>typedef struct SrmOpenConfigType {
   uint32_t baud;
   uint32_t function;
   MemPtr drvrDataP;
   uint16_t drvrDataSize;
   uint16_t sysReserved0;
   uint32_t sysReserved1;
   uint32_t sysReserved2; 
} SrmOpenConfigType;
</pre>
<h4>
  <a name="1020272"> </a>Fields 
</h4>

<dl>
<dt><a name="1020312"> </a><code>baud</code></dt>
<dd><a name="1020334"> </a>Baud rate at which to open the connection. Serial drivers that do not require baud rates ignore this field.</dd>

<dt><a name="1020873"> </a><code>function</code></dt>
<dd><a name="1024185"> </a>Reserved for system use.</dd>

<dt><a name="1020875"> </a><code>drvrDataP</code></dt>
<dd><a name="1020386"> </a>Pointer to a driver-specific data block.</dd>

<dt><a name="1020391"> </a><code>drvrDataSize</code></dt>
<dd><a name="1020396"> </a>The size of the data block pointed to by <code>drvrDataP</code>.</dd>

<dt><a name="1020401"> </a><code>sysReserved0</code></dt>
<dd><a name="1020406"> </a>Reserved for future use. </dd>

<dt><a name="1020411"> </a><code>sysReserved1</code></dt>
<dd><a name="1020416"> </a>Reserved for future use. </dd>

<dt><a name="1020421"> </a><code>sysReserved2</code></dt>
<dd><a name="1020426"> </a>Reserved for future use. </dd>

</dl>
<h4>
  <a name="1035021"> </a>Comments 
</h4>

<p><a name="1035039"> </a>The <code>function</code> field, which was used under Palm OS<sup>&#174;</sup> 5.x and earlier, is now reserved for system use.</p>

<h3 class="hbH3">
  <a name="993482"> </a>SrmRfCommOpenParamsType Struct <a href="#608590"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="1036896"> </a>Purpose 
</h4>

<p><a name="1036906"> </a>Specifies open parameters for opening an RFCOMM port.</p>
<h4>
  <a name="1036916"> </a>Prototype 
</h4>
<pre class="proto"><a name="1036956"></a>typedef struct SrmRfcommOpenParamsType {
   BtLibDeviceAddressType btAddr;
   uint16_t sysReserved0;
   char *serviceClassIDName;
} SrmRfcommOpenParamsType
</pre>
<h4>
  <a name="1037186"> </a>Fields 
</h4>

<dl>
<dt><a name="1037200"> </a><code>btAddr</code></dt>
<dd><a name="1037214"> </a>The address of the Bluetooth device to connect to. If a null address (00:00:00:00:00:00) is specified, a Bluetooth discovery operation is performed at connect time.</dd>

<dt><a name="1037255"> </a><code>sysReserved0</code></dt>
<dd><a name="1037271"> </a>Reserved for system use.</dd>

<dt><a name="1037272"> </a><code>serviceClassIDName</code></dt>
<dd><a name="1037273"> </a>A string describing the service class ID to connect to. This is usually set to "serial_port" for a standard RFCOMM connection.</dd>

</dl>

<div><hr>
  <a name="1037330"> </a> <b>NOTE: </b> This behavior has changed since Palm OS Garnet. 68K applications remain binary compatible, but source code compatibility is broken for newly-written applications. In addition, it is no longer possible to use the Serial Manager to open an RFCOMM port in server mode; use the IOS API instead.
<hr>
</div>

<h2 class="haH2">
  <a name="993492"> </a>Serial Manager Constants <a href="#608590"><span class="nav">^TOP^</span></a>
</h2>


<h3 class="hbH3">
  <a name="993494"> </a>Port Constants <a href="#608590"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="1025655"> </a>Purpose 
</h4>

<p><a name="1040553"> </a>When you specify the port to open in the <a href="LowLevelComms_SerRef.html#994414"><code>SrmOpen()</code></a> or <a href="LowLevelComms_SerRef.html#994192"><code>SrmExtOpen()</code></a> call, you can specify one of these ports to select a standard interface instead of using the Connection Manager to select the interface you want to use.</p>
<h4>
  <a name="1027254"> </a>Constants 
</h4>

<dl>
<dt><a name="1027328"> </a><code><code>serPortLocalHotSync</code> </code></dt>
<dd><a name="1027330"> </a>The physical HotSync<sup>&#174;</sup> port. The Serial Manager automatically detects whether this port is USB or RS-232. </dd>

<dt><a name="1027333"> </a><code><code>serPortCradlePort</code> </code></dt>
<dd><a name="1027335"> </a>Cradle port. The Serial Manager automatically detects whether this port is USB or RS-232. Most applications should specify this as the port. </dd>

<dt><a name="1027338"> </a><code><code>serPortIrPort</code> </code></dt>
<dd><a name="1027340"> </a>The IR port. This is a raw IrDA port with no protocol support. </dd>

<dt><a name="1027343"> </a><code><code>serPortConsolePort</code> </code></dt>
<dd><a name="1027345"> </a>The debug console port, either USB or RS-232. USB is preferred where both are available. </dd>

<dt><a name="1027348"> </a><code><code>serPortCradleRS232Port</code> </code></dt>
<dd><a name="1027350"> </a>Port for the RS-232 cradle. Specify this port if you want to ensure that your application uses RS-232 communications only. </dd>

<dt><a name="1027353"> </a><code><code>serPortCradleUSBPort</code> </code></dt>
<dd><a name="1027355"> </a>Port for the USB cradle. This port may only be used by the HotSync application.</dd>

<dt><a name="1027357"> </a><code><code>sysFileCVirtIrComm</code></code></dt>
<dd><a name="1027359"> </a>Serial communications over infrared (IrComm). Retained for compatibility with previous versions of Palm OS.</dd>

<dt><a name="1027361"> </a><code><code>sysFileCVirtRfComm</code></code></dt>
<dd><a name="1027363"> </a>Serial communications over Bluetooth (RFCOMM). Retained for compatibility with previous versions of Palm OS. This port must be used by calling <a href="LowLevelComms_SerRef.html#994192"><code>SrmExtOpen()</code></a>, with <code>drvrDataP</code> pointing to an <code>SrmRfcommOpenParamsType</code> structure.</dd>

</dl>

<h3 class="hbH3">
  <a name="993647"> </a>Serial Capabilities Constants <a href="#608590"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="1027577"> </a>Purpose 
</h4>

<p><a name="993649"> </a>The serial capabilities constant flags describe serial hardware capabilities. These flags are set in the <code>serDevFtrInfo</code> field of the <a href="LowLevelComms_SerRef.html#993232"><code>DeviceInfoType</code></a> structure.</p>
<h4>
  <a name="1027855"> </a>Constants 
</h4>

<dl>
<dt><a name="1027987"> </a><code><code>serDevCradlePort</code></code></dt>
<dd><a name="1027989"> </a>Serial hardware controls RS-232 serial from cradle connector of the device.</dd>

<dt><a name="1027992"> </a><code><code>serDevRS232Serial</code></code></dt>
<dd><a name="1027994"> </a>Serial hardware has RS-232 line drivers.</dd>

<dt><a name="1027997"> </a><code><code>serDevIRDACapable</code></code></dt>
<dd><a name="1027999"> </a>Serial hardware has IR line drivers and generates IrDA mode serial signals.</dd>

<dt><a name="1028012"> </a><code><code>serDevConsolePort </code></code></dt>
<dd><a name="1028014"> </a>Serial device is the default console port.</dd>

<dt><a name="1028017"> </a><code><code>serDevUSBCapable</code></code></dt>
<dd><a name="1028019"> </a>Serial hardware controls USB serial from cradle connector of the device.</dd>

<dt><a name="1029332"> </a><code><code>serDevHotsyncCapable</code></code></dt>
<dd><a name="1029334"> </a>Serial device can be used for HotSync.</dd>

</dl>

<h3 class="hbH3">
  <a name="1016597"> </a>Serial Settings Constants <a href="#608590"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="1029372"> </a>Purpose 
</h4>

<p><a name="1016599"> </a>The serial settings constants identify bit flags that correspond to various serial hardware settings. Use <a href="LowLevelComms_SerRef.html#993980"><code>SrmControl()</code></a> with the op code <code>srmCtlSetFlags</code> to control which settings are used. </p>
<h4>
  <a name="1029379"> </a>Constants 
</h4>

<dl>
<dt><a name="1029395"> </a><code><code>srmSettingsFlagStopBitsM</code> </code></dt>
<dd><a name="1029397"> </a>Mask for stop bits field</dd>

<dt><a name="1029400"> </a><code><code>srmSettingsFlagStopBits1</code> </code></dt>
<dd><a name="1029402"> </a>1 stop bit (default) </dd>

<dt><a name="1029405"> </a><code><code>srmSettingsFlagStopBits2</code> </code></dt>
<dd><a name="1029407"> </a>2 stop bits</dd>

<dt><a name="1029410"> </a><code><code>srmSettingsFlagParityOnM</code> </code></dt>
<dd><a name="1029412"> </a>Mask for parity on</dd>

<dt><a name="1029415"> </a><code><code>srmSettingsFlagParityEvenM</code> </code></dt>
<dd><a name="1029417"> </a>Mask for parity even</dd>

<dt><a name="1029420"> </a><code><code>srmSettingsFlagXonXoffM</code> </code></dt>
<dd><a name="1029422"> </a>Mask for Xon/Xoff flow control (not implemented)</dd>

<dt><a name="1029425"> </a><code><code>srmSettingsFlagRTSAutoM</code> </code></dt>
<dd><a name="1029427"> </a>Mask for RTS receive flow control. This is the default. </dd>

<dt><a name="1029430"> </a><code><code>srmSettingsFlagCTSAutoM</code> </code></dt>
<dd><a name="1029432"> </a>Mask for CTS transmit flow control</dd>

<dt><a name="1029435"> </a><code><code>srmSettingsFlagBitsPerCharM</code> </code></dt>
<dd><a name="1029437"> </a>Mask for bits per character</dd>

<dt><a name="1029440"> </a><code><code>srmSettingsFlagBitsPerChar5</code> </code></dt>
<dd><a name="1029442"> </a>5 bits per character</dd>

<dt><a name="1029445"> </a><code><code>srmSettingsFlagBitsPerChar6</code> </code></dt>
<dd><a name="1029447"> </a>6 bits per character</dd>

<dt><a name="1029450"> </a><code><code>srmSettingsFlagBitsPerChar7</code> </code></dt>
<dd><a name="1029452"> </a>7 bits per character</dd>

<dt><a name="1029455"> </a><code><code>srmSettingsFlagBitsPerChar8</code> </code></dt>
<dd><a name="1029457"> </a>8 bits per character (default) </dd>

<dt><a name="1029460"> </a><code><code>srmSettingsFlagFlowControlIn</code></code></dt>
<dd><a name="1029462"> </a>Protect the receive buffer from software overruns. When this flag and <code>srmSettingsFlagRTSAutoM</code> are set, which is the default case, it causes the Serial Manager to assert RTS to prevent the transmitting device from continuing to send data when the receive buffer is full. Once the application receives data from the buffer, RTS is de-asserted to allow data reception to resume.</dd>

<dd><a name="1029466"> </a>Note that this feature effectively prevents software overrun line errors but may also cause CTS timeouts on the transmitting device if the RTS line is asserted longer than the defined CTS timeout value.</dd>

</dl>

<h3 class="hbH3">
  <a name="1017945"> </a>SrmCtlEnum Enum <a href="#608590"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="1029604"> </a>Purpose 
</h4>

<p><a name="1017947"> </a>The <code>SrmCtlEnum</code> enumerated type specifies a serial control operation. Specify one of these enumerated types for the <code class="par">op</code> parameter to the <a href="LowLevelComms_SerRef.html#993980"><code>SrmControl()</code></a> call.</p>
<h4>
  <a name="1029695"> </a>Constants 
</h4>

<dl>
<dt><a name="1017982"> </a><code><code>srmCtlSetBaudRate </code></code></dt>
<dd><a name="1017984"> </a>Sets the current baud rate for the serial hardware.</dd>

<dt><a name="1017986"> </a><code><code>srmCtlGetBaudRate </code></code></dt>
<dd><a name="1017988"> </a>Gets the current baud rate for the serial hardware.</dd>

<dt><a name="1017990"> </a><code><code>srmCtlSetFlags </code></code></dt>
<dd><a name="1017992"> </a>Sets the current flag settings for the serial hardware. Specify flags from the set described in <a href="LowLevelComms_SerRef.html#1016597">Serial Settings Constants</a>.</dd>

<dt><a name="1017997"> </a><code><code>srmCtlGetFlags </code></code></dt>
<dd><a name="1017999"> </a>Gets the current flag settings for the serial hardware. </dd>

<dt><a name="1018001"> </a><code><code>srmCtlSetCtsTimeout</code></code></dt>
<dd><a name="1018003"> </a>Sets the current CTS timeout value for hardware handshaking.</dd>

<dt><a name="1018005"> </a><code><code>srmCtlGetCtsTimeout</code></code></dt>
<dd><a name="1018007"> </a>Gets the current CTS timeout value for hardware handshaking.</dd>

<dt><a name="1018009"> </a><code><code>srmCtlIrDAEnable</code></code></dt>
<dd><a name="1018011"> </a>Enable IrDA connection on this serial port.ioctl</dd>

<dt><a name="1018013"> </a><code><code>srmCtlIrDADisable</code></code></dt>
<dd><a name="1018015"> </a>Disable IrDA connection on this serial port.</dd>

<dt><a name="1018017"> </a><code><code>srmCtlRxEnable</code></code></dt>
<dd><a name="1018019"> </a>Enable receiver (for IrDA).</dd>

<dt><a name="1018021"> </a><code><code>srmCtlRxDisable</code></code></dt>
<dd><a name="1018023"> </a>Disable receiver (for IrDA).</dd>

<dt><a name="1018025"> </a><code><code>srmCtlEmuSetBlockingHook</code></code></dt>
<dd><a name="1018027"> </a>Set a blocking hook routine for emulation mode only. Not supported on the actual device.</dd>

<dt><a name="1018029"> </a><code><code>srmCtlSystemReserved</code></code></dt>
<dd><a name="1018031"> </a>Reserves op codes between 0x7000 and 0x8000 for system use. </dd>

</dl>

<div><hr>
  <a name="993821"> </a> <b>NOTE: </b> Palm OS Cobalt no longer supports custom opcodes. If you need the added flexibility, you should use <a href="LowLevelComms_Stdio_Pt.html#1000443">IOS STDIO</a> calls directly.
<hr>
</div>

<h3 class="hbH3">
  <a name="1031256"> </a>Status Constants <a href="#608590"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="1031299"> </a>Purpose 
</h4>

<p><a name="993823"> </a>The status constants identify bit flags that correspond to the status of serial signals. They can be returned by the <a href="LowLevelComms_SerRef.html#994376"><code>SrmGetStatus()</code></a> function.</p>
<h4>
  <a name="1045687"> </a>Constants 
</h4>

<dl>
<dt><a name="1031324"> </a><code><code>srmStatusCtsOn </code></code></dt>
<dd><a name="1031326"> </a>CTS line is active.</dd>

<dt><a name="1031329"> </a><code><code>srmStatusRtsOn </code></code></dt>
<dd><a name="1031331"> </a>RTS line is active.</dd>

<dt><a name="1031334"> </a><code><code>srmStatusDsrOn </code></code></dt>
<dd><a name="1031336"> </a>DSR line is active.</dd>

<dt><a name="1031339"> </a><code><code>srmStatusBreakSigOn </code></code></dt>
<dd><a name="1031341"> </a>Break signal is active.</dd>

<dt><a name="1031359"> </a><code><code>srmStatusDtrOn</code></code></dt>
<dd><a name="1031361"> </a>DTR is active.</dd>

<dt><a name="1031355"> </a><code><code>srmStatusDcdOn</code></code></dt>
<dd><a name="1031357"> </a>DCD is active.</dd>

<dt><a name="1031351"> </a><code><code>srmStatusRingOn</code></code></dt>
<dd><a name="1031353"> </a>Ring detected.</dd>

</dl>

<div><hr>
  <a name="993861"> </a> <b>NOTE: </b> You can set most of these signals by using <a href="LowLevelComms_StdioRef.html#996638"><code>IOSIoctl()</code></a> calls.
<hr>
</div>

<h3 class="hbH3">
  <a name="1041688"> </a>Line Error Constants <a href="#608590"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="1031385"> </a>Purpose 
</h4>

<p><a name="993862"> </a>The line error constants identify bit flags that correspond to the line errors that may occur on the port. They can be returned by the <a href="LowLevelComms_SerRef.html#994376"><code>SrmGetStatus()</code></a> function. </p>
<h4>
  <a name="1031431"> </a>Constants 
</h4>

<dl>
<dt><a name="1031394"> </a><code><code>serLineErrorParity</code></code></dt>
<dd><a name="1031396"> </a>Parity error</dd>

<dt><a name="1031399"> </a><code><code>serLineErrorHWOverrun</code></code></dt>
<dd><a name="1031401"> </a>Hardware overrun</dd>

<dt><a name="1031404"> </a><code><code>serLineErrorFraming</code></code></dt>
<dd><a name="1031406"> </a>Framing error</dd>

<dt><a name="1031409"> </a><code><code>serLineErrorBreak</code></code></dt>
<dd><a name="1031411"> </a>Break signal asserted</dd>

<dt><a name="1031414"> </a><code><code>serLineErrorHShake</code></code></dt>
<dd><a name="1031416"> </a>Line handshake error</dd>

<dt><a name="1031419"> </a><code><code>serLineErrorSWOverrun</code></code></dt>
<dd><a name="1031421"> </a>Software overrun</dd>

<dt><a name="1031424"> </a><code><code>serLineErrorCarrierLost</code></code></dt>
<dd><a name="1031426"> </a>Carrier detect signal dropped</dd>

</dl>

<h2 class="haH2">
  <a name="1002427"> </a>Serial Manager Functions <a href="#608590"><span class="nav">^TOP^</span></a>
</h2>


<h3 class="hbH3">
  <a name="1002430"> </a>SrmClearErr Function <a href="#608590"><span class="nav">^TOP^</span></a>
</h3>


<p><a name="993923"> </a>Clears the port of any line errors.</p>
<h4>
  <a name="993924"> </a>Declared In 
</h4>
<code>SerialMgr.h<a name="993925"> </a></code><h4>
  <a name="993926"> </a>Prototype 
</h4>
<pre class="proto"><a name="993927"></a>status_t SrmClearErr (
   uint16_t portId
)
</pre>
<h4>
  <a name="993928"> </a>Parameters 
</h4>

<dl>
<dt><a name="993932"> </a><code>&rarr;  <i>portID</i></code></dt>
<dd><a name="1001333"> </a>Port ID returned from <a href="LowLevelComms_SerRef.html#994414"><code>SrmOpen()</code></a> or <a href="LowLevelComms_SerRef.html#994192"><code>SrmExtOpen()</code></a>.</dd>

</dl>
<h4>
  <a name="993936"> </a>Returns 
</h4>

<p><a name="993937"> </a>This function returns the following error codes:</p>

<dl>
<dt><a name="993938"> </a><code><code>errNone</code></code></dt>
<dd><a name="1002695"> </a>No error. </dd>

<dt><a name="993939"> </a><code><code>serErrNotSupported</code></code></dt>
<dd><a name="1003379"> </a>The port is not the foreground port. </dd>

</dl>

<h3 class="hbH3">
  <a name="1003382"> </a>SrmClose Function <a href="#608590"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="1003383"> </a>Purpose 
</h4>

<p><a name="993949"> </a>Closes a serial port and makes it available to other applications, regardless of whether the port is a foreground or background port. </p>
<h4>
  <a name="993950"> </a>Declared In 
</h4>
<code>SerialMgr.h<a name="993951"> </a></code><h4>
  <a name="993952"> </a>Prototype 
</h4>
<pre class="proto"><a name="993953"></a>status_t SrmClose (
   uint16_t portId
)
</pre>
<h4>
  <a name="993954"> </a>Parameters 
</h4>

<dl>
<dt><a name="993955"> </a><code>&rarr;  <i>portId</i></code></dt>
<dd><a name="1001499"> </a>Port ID for port to be closed.</dd>

</dl>
<h4>
  <a name="993956"> </a>Returns 
</h4>

<p><a name="993957"> </a>This function returns the following error codes:</p>

<dl>
<dt><a name="993958"> </a><code><code>errNone</code></code></dt>
<dd><a name="1003469"> </a>No error.</dd>

<dt><a name="993959"> </a><code><code>serErrBadPort</code></code></dt>
<dd><a name="1003518"> </a>This port doesn't exist.</dd>

<dt><a name="993960"> </a><code><code>serErrNotOpen</code></code></dt>
<dd><a name="1003586"> </a>The serial port is not open. </dd>

<dt><a name="993961"> </a><code><code>serErrNoDevicesAvail</code></code></dt>
<dd><a name="1003643"> </a>No serial devices could be found. </dd>

</dl>
<h4>
  <a name="993962"> </a>Comments 
</h4>

<p><a name="993963"> </a>If a foreground port is being closed and a background port exists, the background will have access to the port as long as another foreground port is not opened.</p>

<p><a name="993964"> </a>If a foreground port is being closed and a yielded port exists, the yielded port will have access to the port as long as it does not yield to the opening of another foreground port. If there are both a yielded port and a background port for the foreground port being closed, the yielded port takes precedence over the background port. </p>
<h4>
  <a name="996514"> </a>See Also 
</h4>

<p><a name="996521"> </a><a href="LowLevelComms_SerRef.html#994414"><code>SrmOpen()</code></a></p>

<h3 class="hbH3">
  <a name="993980"> </a>SrmControl Function <a href="#608590"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="993981"> </a>Purpose 
</h4>

<p><a name="993982"> </a>Performs a serial control function.</p>
<h4>
  <a name="993983"> </a>Declared In 
</h4>
<code>SerialMgr.h<a name="993984"> </a></code><h4>
  <a name="993985"> </a>Prototype 
</h4>
<pre class="proto"><a name="993986"></a>status_t SrmControl (
   uint16_t portId,
   uint16_t op,
   void *valueP,
   uint16_t *valueLenP
)
</pre>
<h4>
  <a name="993987"> </a>Parameters 
</h4>

<dl>
<dt><a name="993991"> </a><code>&rarr;  <i>portID</i></code></dt>
<dd><a name="1001563"> </a>Port ID returned from <a href="LowLevelComms_SerRef.html#994414"><code>SrmOpen()</code></a> or <a href="LowLevelComms_SerRef.html#994192"><code>SrmExtOpen()</code></a>.</dd>

<dt><a name="993995"> </a><code>&rarr;  <i>op</i></code></dt>
<dd><a name="1001616"> </a>Control operation to perform. Specify one of the <a href="LowLevelComms_SerRef.html#1017945"><code>SrmCtlEnum</code></a> enumerated types.</dd>

<dt><a name="994000"> </a><code>&rarr;  <i>valueP</i></code></dt>
<dd><a name="1001605"> </a>Pointer to a value to use for the operation. See Comments for details.</dd>

<dt><a name="994001"> </a><code>&harr;  <i>valueLenP</i></code></dt>
<dd><a name="1001594"> </a>Pointer to the size of <code class="par">valueP</code>. See Comments for details.</dd>

</dl>
<h4>
  <a name="994002"> </a>Returns 
</h4>

<p><a name="994003"> </a>This function returns the following error codes:</p>

<dl>
<dt><a name="994004"> </a><code><code>errNone</code></code></dt>
<dd><a name="1003765"> </a>No error.</dd>

<dt><a name="994005"> </a><code><code>serErrBadParam</code></code></dt>
<dd><a name="1003916"> </a>An invalid op code was specified. </dd>

<dt><a name="994006"> </a><code><code>serErrBadPort</code></code></dt>
<dd><a name="1003917"> </a>This port doesn't exist.</dd>

<dt><a name="994007"> </a><code><code>serErrNotOpen</code></code></dt>
<dd><a name="1003963"> </a>The serial port is not open. </dd>

<dt><a name="994008"> </a><code><code>serErrNoDevicesAvail</code></code></dt>
<dd><a name="1003992"> </a>No serial devices could be found. </dd>

<dt><a name="994009"> </a><code><code>serErrNotSupported</code></code></dt>
<dd><a name="1004025"> </a>The specified op code is not supported in the current configuration. </dd>

</dl>
<h4>
  <a name="994010"> </a>Comments 
</h4>

<p><a name="994014"> </a><a href="LowLevelComms_SerRef.html#994024">Table 4.1</a> shows what to pass for the <code class="par">valueP</code> and <code class="par">valueLenP</code> parameters for each of the operation codes. Control codes not listed do not use these parameters. See <a href="LowLevelComms_SerRef.html#1017945"><code>SrmCtlEnum</code></a> for a complete list of control codes. </p>

<p class="caption"><a name="994024"> </a><b>Table 4.1  SrmControl Parameters </b></p>
<div class="tablediv"><table cellspacing="0" class="tTable">

  <tr valign="top">
    <th><p class="tt"><a name="994028"> </a><b>Operation Code</b></p>
    </th>
    <th><p class="tt"><a name="994030"> </a><b>Parameters</b></p>
    </th>
  </tr>
  <tr valign="top">
    <td colspan="1" rowspan="3"><p class="tt"><a name="994032"> </a><code>srmCtlSetBaudRate</code> </p>
    </td>
    <td colspan="1" rowspan="3"><p class="tt"><a name="994034"> </a>-&gt; <code class="par">valueP</code> = Pointer to <code>int32_t</code> (baud rate)</p>
<p class="tt"><a name="994035"> </a>-&gt; <code class="par">valueLenP</code> = Pointer to <code>sizeof(int32_t)</code></p>
    </td>
  </tr>
  <tr valign="top">
  </tr>
  <tr valign="top">
  </tr>
  <tr valign="top">
    <td colspan="1" rowspan="3"><p class="tt"><a name="994045"> </a><code>srmCtlGetBaudRate</code> </p>
    </td>
    <td colspan="1" rowspan="3"><p class="tt"><a name="994047"> </a>&lt;- <code class="par">valueP</code> = Pointer to <code>int32_t</code> (baud rate)</p>
<p class="tt"><a name="994048"> </a>&lt;- <code class="par">valueLenP</code> = Pointer to <code>int16_t</code></p>
    </td>
  </tr>
  <tr valign="top">
  </tr>
  <tr valign="top">
  </tr>
  <tr valign="top">
    <td colspan="1" rowspan="3"><p class="tt"><a name="994058"> </a><code>srmCtlSetFlags</code> </p>
    </td>
    <td colspan="1" rowspan="3"><p class="tt"><a name="994060"> </a>-&gt; <code class="par">valueP</code> = Pointer to <code>Uint32</code> (bitfield; see <a href="LowLevelComms_SerRef.html#1016597">Serial Settings Constants</a>)</p>
<p class="tt"><a name="994064"> </a>-&gt; <code class="par">valueLenP</code> = Pointer to <code>sizeof(uint32_t)</code></p>
    </td>
  </tr>
  <tr valign="top">
  </tr>
  <tr valign="top">
  </tr>
  <tr valign="top">
    <td colspan="1" rowspan="3"><p class="tt"><a name="994074"> </a><code>srmCtlGetFlags</code> </p>
    </td>
    <td colspan="1" rowspan="3"><p class="tt"><a name="994076"> </a>&lt;- <code class="par">valueP</code> = Pointer to <code>uint32_t</code> (bitfield)</p>
<p class="tt"><a name="994077"> </a>&lt;- <code class="par">valueLenP</code> = Pointer to <code>int16_t</code></p>
    </td>
  </tr>
  <tr valign="top">
  </tr>
  <tr valign="top">
  </tr>
  <tr valign="top">
    <td colspan="1" rowspan="3"><p class="tt"><a name="994087"> </a><code>srmCtlSetCtsTimeout</code> </p>
    </td>
    <td colspan="1" rowspan="3"><p class="tt"><a name="994089"> </a>-&gt; <code class="par">valueP</code> = Pointer to <code>int32_t</code> (timeout value)</p>
<p class="tt"><a name="994090"> </a>-&gt; <code class="par">valueLenP</code> = Pointer to <code>sizeof(int32_t)</code></p>
    </td>
  </tr>
  <tr valign="top">
  </tr>
  <tr valign="top">
  </tr>
  <tr valign="top">
    <td colspan="1" rowspan="3"><p class="tt"><a name="994100"> </a><code>srmCtlGetCtsTimeout</code> </p>
    </td>
    <td colspan="1" rowspan="3"><p class="tt"><a name="994102"> </a>&lt;- <code class="par">valueP</code> = Pointer to <code>int32_t</code> (timeout value)</p>
<p class="tt"><a name="994103"> </a>&lt;- <code class="par">valueLenP</code> = Pointer to <code>int16_t</code></p>
    </td>
  </tr>
  <tr valign="top">
  </tr>
  <tr valign="top">
  </tr>
  <tr valign="top">
    <td><p class="tt"><a name="994113"> </a><code>srmCtlUserDef</code> </p>
    </td>
    <td><p class="tt"><a name="994115"> </a>&lt;-&gt; <code class="par">valueP</code> = Pointer passed to the serial driver</p>
<p class="tt"><a name="994116"> </a>&lt;-&gt; <code class="par">valueLenP</code> = Pointer to <code>sizeof(int32_t)</code></p>
<p class="tt"><a name="994117"> </a>For a serial driver, these pointers are passed to the driver's control function and they contain that functions return values (if any) upon return.</p>
    </td>
  </tr>
  <tr valign="top">
    <td><p class="tt"><a name="994119"> </a><code>srmCtlGetOptimalTransmitSize</code> </p>
    </td>
    <td><p class="tt"><a name="994121"> </a>&lt;- <code class="par">valueP</code> = Pointer to <code>int32_t</code> </p>
<p class="tt"><a name="994122"> </a>&lt;- <code class="par">valueLenP</code> = Pointer to <code>sizeof(int32_t)</code></p>
<p class="tt"><a name="994123"> </a>If an error is returned by <code>SrmControl</code>, no buffering should be done. If <code>valueP</code> points to zero, buffering is requested, but the transmitting application cannot determine the buffer size. If <code class="par">valueP</code> points to a number &gt; 0, then try to send data in blocks of this number of bytes, as this is the most efficient block size for this particular device.</p>
    </td>
  </tr>
  <tr valign="top">
    <td><p class="tt"><a name="994125"> </a><code>srmCtlSetDTRAsserted</code></p>
    </td>
    <td><p class="tt"><a name="994127"> </a>-&gt; <code class="par">valueP</code> = Pointer to Boolean indicating whether to enable or disable DTR. </p>
<p class="tt"><a name="994128"> </a>-&gt; <code class="par">valueLenP</code> = Pointer to <code>sizeof(Boolean)</code> </p>
    </td>
  </tr>
  <tr valign="top">
    <td><p class="tt"><a name="994130"> </a><code>srmCtlGetDTRAsserted</code></p>
    </td>
    <td><p class="tt"><a name="994132"> </a>&lt;- <code class="par">valueP</code> = Pointer to Boolean indicating whether DTR is enabled. </p>
<p class="tt"><a name="994133"> </a>&lt;- <code class="par">valueLenP</code> = Pointer to <code>int16_t </code></p>
    </td>
  </tr>
</table>

</div>


<h3 class="hbH3">
  <a name="994192"> </a>SrmExtOpen Function <a href="#608590"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="994193"> </a>Purpose 
</h4>

<p><a name="994194"> </a>Opens a foreground port connection with the specified configuration.</p>
<h4>
  <a name="994195"> </a>Declared In 
</h4>
<code>SerialMgr.h<a name="994196"> </a></code><h4>
  <a name="994197"> </a>Prototype 
</h4>
<pre class="proto"><a name="994198"></a>status_t SrmExtOpen (
   uint32_t port,
   SrmOpenConfigType *configP,
   uint16_t configSize,
   uint16_t *newPortIdP
)
</pre>
<h4>
  <a name="994199"> </a>Parameters 
</h4>

<dl>
<dt><a name="994200"> </a><code>&rarr;  <i><code>port</code></i></code></dt>
<dd><a name="1004904"> </a>The four-character port name (such as 'ircm' or 'u328') or logical port number to be opened. (See <a href="LowLevelComms_SerRef.html#993494">Port Constants</a>.)</dd>

<dt><a name="994204"> </a><code>&rarr;  <i><code>configP</code></i></code></dt>
<dd><a name="1004911"> </a>Pointer to the configuration structure specifying the serial port's properties. See <a href="LowLevelComms_SerRef.html#993424"><code>SrmOpenConfigType</code></a>.</dd>

<dt><a name="994209"> </a><code>&rarr;  <i><code>configSize</code></i></code></dt>
<dd><a name="1004912"> </a>The size of the configuration structure pointed to by <code class="par">configP</code>. </dd>

<dt><a name="994210"> </a><code>&larr;  <i><code>newPortIdP</code></i></code></dt>
<dd><a name="1004913"> </a>Contains the port ID to be passed to other Serial Manager functions.</dd>

</dl>
<h4>
  <a name="994211"> </a>Returns 
</h4>

<p><a name="994212"> </a>This function returns the following error codes:</p>

<dl>
<dt><a name="994213"> </a><code><code>errNone</code></code></dt>
<dd><a name="1004914"> </a>No error. </dd>

<dt><a name="994214"> </a><code><code>serErrBadPort</code></code></dt>
<dd><a name="1004952"> </a>The <code class="par">port</code> parameter does not specify a valid port. </dd>

<dt><a name="994215"> </a><code><code>serErrBadParam</code></code></dt>
<dd><a name="1004985"> </a>The <code class="par">configP</code> parameter is <code>NULL</code>. </dd>

<dt><a name="994216"> </a><code><code>serErrAlreadyOpen</code></code></dt>
<dd><a name="1005002"> </a>The Serial Manager already has a port open. </dd>

<dt><a name="994217"> </a><code><code>memErrNotEnoughSpace</code></code></dt>
<dd><a name="1005023"> </a>There was not enough memory available to open the port.</dd>

</dl>
<h4>
  <a name="994218"> </a>Comments 
</h4>

<p><a name="994219"> </a>Do not keep the port open any longer than necessary. An open serial port consumes more energy from the device's batteries. </p>

<p><a name="994220"> </a>The values specified in the <code class="par">configP</code> parameter depend on the type of connection being made. For RS-232 connections, you specify the baud rate but not a purpose. For USB connections, you specify a purpose but not a baud rate.</p>

<p><a name="999768"> </a>When opening the RFCOMM (<code>'rfcm'</code>) port, you should specify in the <code class="par">configP</code><!-PS02-><span style="color: #000000;  font-family: Courier; font-style: normal; font-weight: normal; text-decoration: none; text-transform: none; vertical-align: baseline">-&gt;drvrDataP</span> field a pointer to an <code>SrmRfcommOpenParamsType</code> structure.</p>

<p><a name="994221"> </a>A newly opened port has its line errors cleared, the default CTS timeout set (specified by the constant <code>srmDefaultCTSTimeout</code>), a 512-byte receive queue allocated, 1 stop bit, 8 bits per character, RTS enabled, and flow control enabled. To increase the receive queue size, use <a href="LowLevelComms_SerRef.html#995031"><code>SrmSetReceiveBuffer()</code></a>. To change the other serial port settings, use <a href="LowLevelComms_SerRef.html#993980"><code>SrmControl()</code></a>. </p>
<h4>
  <a name="994242"> </a>See Also 
</h4>

<p><a name="994249"> </a><a href="LowLevelComms_SerRef.html#994414"><code>SrmOpen()</code></a></p>

<h3 class="hbH3">
  <a name="994313"> </a>SrmGetDeviceCount Function <a href="#608590"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="994314"> </a>Purpose 
</h4>

<p><a name="994315"> </a>Returns the number of available serial devices.</p>
<h4>
  <a name="994316"> </a>Declared In 
</h4>
<code>SerialMgr.h<a name="994317"> </a></code><h4>
  <a name="994318"> </a>Prototype 
</h4>
<pre class="proto"><a name="994319"></a>status_t SrmGetDeviceCount (
   uint16_t *numOfDevicesP
)
</pre>
<h4>
  <a name="994320"> </a>Parameters 
</h4>

<dl>
<dt><a name="994321"> </a><code>&larr;  <i><code>numOfDevicesP</code></i></code></dt>
<dd><a name="1005321"> </a>Pointer to address where the number of serial devices is returned.</dd>

</dl>
<h4>
  <a name="994322"> </a>Returns 
</h4>

<dl>
<dt><a name="994323"> </a><code><code>errNone</code></code></dt>
<dd><a name="1005330"> </a>No error. </dd>

</dl>
<h4>
  <a name="994329"> </a>See Also 
</h4>

<p><a name="994333"> </a><a href="LowLevelComms_SerRef.html#994336"><code>SrmGetDeviceInfo()</code></a></p>

<h3 class="hbH3">
  <a name="994336"> </a>SrmGetDeviceInfo Function <a href="#608590"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="994337"> </a>Purpose 
</h4>

<p><a name="994338"> </a>Returns information about a serial device.</p>
<h4>
  <a name="994339"> </a>Declared In 
</h4>
<code>SerialMgr.h<a name="994340"> </a></code><h4>
  <a name="994341"> </a>Prototype 
</h4>
<pre class="proto"><a name="994342"></a>status_t SrmGetDeviceInfo (
   uint32_t deviceID,
   DeviceInfoType *deviceInfoP
)
</pre>
<h4>
  <a name="1006275"> </a>Parameters 
</h4>

<dl>
<dt><a name="1006276"> </a><code>&rarr;  <i><code>deviceID</code></i></code></dt>
<dd><a name="1006351"> </a>ID of serial device to get information for. You can pass a zero-based index (0, 1, 2, ...), a valid port ID returned from <a href="LowLevelComms_SerRef.html#994414"><code>SrmOpen()</code></a> or <a href="LowLevelComms_SerRef.html#994192"><code>SrmExtOpen()</code></a>, or a 4-character port name (such as 'u328', 'u650', or 'ircm'). See <a href="LowLevelComms_SerRef.html#993494">Port Constants</a>.</dd>

<dt><a name="994358"> </a><code>&larr;  <i><code>deviceInfoP</code></i></code></dt>
<dd><a name="1007169"> </a>Pointer to a <a href="LowLevelComms_SerRef.html#993232"><code>DeviceInfoType</code></a> structure where information about the device is returned.</dd>

</dl>
<h4>
  <a name="994359"> </a>Returns 
</h4>

<p><a name="994360"> </a>This function returns the following error codes:</p>

<dl>
<dt><a name="994361"> </a><code><code>errNone</code></code></dt>
<dd><a name="1007170"> </a>No error. </dd>

<dt><a name="994362"> </a><code><code>serErrBadPort</code></code></dt>
<dd><a name="1007171"> </a>This port doesn't exist.</dd>

<dt><a name="994363"> </a><code><code>serErrNoDevicesAvail</code></code></dt>
<dd><a name="1007468"> </a>The Serial Manager cannot find any serial devices. </dd>

</dl>
<h4>
  <a name="994369"> </a>See Also 
</h4>

<p><a name="994373"> </a><a href="LowLevelComms_SerRef.html#994313"><code>SrmGetDeviceCount()</code></a></p>

<h3 class="hbH3">
  <a name="994376"> </a>SrmGetStatus Function <a href="#608590"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="994377"> </a>Purpose 
</h4>

<p><a name="994378"> </a>Returns status information about the serial hardware.</p>
<h4>
  <a name="994379"> </a>Declared In 
</h4>
<code>SerialMgr.h<a name="994380"> </a></code><h4>
  <a name="994381"> </a>Prototype 
</h4>
<pre class="proto"><a name="994382"></a>status_t SrmGetStatus (
   uint16_t portId,
   uint32_t *statusFieldP,
   uint16_t *lineErrsP
)
</pre>
<h4>
  <a name="994383"> </a>Parameters 
</h4>

<dl>
<dt><a name="994387"> </a><code>&rarr;  <i><code>portID</code></i></code></dt>
<dd><a name="1007820"> </a>Port ID returned from <a href="LowLevelComms_SerRef.html#994414"><code>SrmOpen()</code></a> or <a href="LowLevelComms_SerRef.html#994192"><code>SrmExtOpen()</code></a>.</dd>

<dt><a name="994391"> </a><code>&larr;  <i><code>statusFieldP</code></i></code></dt>
<dd><a name="1007821"> </a>Pointer to address where hardware status information for the port is returned. This is a 32-bit field using the flags described in <a href="LowLevelComms_SerRef.html#1031256">Status Constants</a>.</dd>

<dt><a name="994395"> </a><code>&larr;  <i><code>lineErrsP</code></i></code></dt>
<dd><a name="1008118"> </a>Pointer to address where the number of line errors for the port is returned. The line error flags are described in <a href="LowLevelComms_SerRef.html#1041688">Line Error Constants</a>.</dd>

</dl>
<h4>
  <a name="994399"> </a>Returns 
</h4>

<p><a name="994400"> </a>This function returns the following error codes:</p>

<dl>
<dt><a name="994401"> </a><code><code>errNone</code></code></dt>
<dd><a name="1008119"> </a>No error.</dd>

<dt><a name="994402"> </a><code><code>serErrBadPort</code></code></dt>
<dd><a name="1008120"> </a>This port doesn't exist.</dd>

<dt><a name="994403"> </a><code><code>serErrNotSupported</code></code></dt>
<dd><a name="1008121"> </a>The port is a yielded port. </dd>

<dt><a name="994404"> </a><code><code>serErrNoDevicesAvail</code></code></dt>
<dd><a name="1008122"> </a>No serial devices could be found. </dd>

</dl>
<h4>
  <a name="994405"> </a>Comments 
</h4>

<p><a name="994406"> </a>Typically, <code>SrmGetStatus()</code> is called to retrieve the line errors for the port if some of the send and receive functions return a <code>serErrLineErr</code> error code.</p>

<h3 class="hbH3">
  <a name="994414"> </a>SrmOpen Function <a href="#608590"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="994415"> </a>Purpose 
</h4>

<p><a name="994416"> </a>Opens a foreground port connection with the specified port name or logical port number.</p>
<h4>
  <a name="994417"> </a>Declared In 
</h4>
<code>SerialMgr.h<a name="994418"> </a></code><h4>
  <a name="994419"> </a>Prototype 
</h4>
<pre class="proto"><a name="994420"></a>status_t SrmOpen (
   uint32_t port,
   uint32_t baud,
   uint16_t *newPortIdP
)
</pre>
<h4>
  <a name="994421"> </a>Parameters 
</h4>

<dl>
<dt><a name="994422"> </a><code>&rarr;  <i><code>port</code></i></code></dt>
<dd><a name="1008124"> </a>The four-character port name or logical port number to be opened. See <a href="LowLevelComms_SerRef.html#993494">Port Constants</a> for more information. </dd>

<dt><a name="994426"> </a><code>&rarr;  <i><code>baud</code></i></code></dt>
<dd><a name="1008125"> </a>Initial baud rate of port.</dd>

<dt><a name="994427"> </a><code>&larr;  <i><code>newPortIdP</code></i></code></dt>
<dd><a name="1008126"> </a>Contains the port ID to be passed to other Serial Manager functions.</dd>

</dl>
<h4>
  <a name="994428"> </a>Returns 
</h4>

<p><a name="994429"> </a>This function returns the following error codes:</p>

<dl>
<dt><a name="994430"> </a><code><code>errNone</code></code></dt>
<dd><a name="1008218"> </a>No error.</dd>

<dt><a name="994431"> </a><code><code>serErrAlreadyOpen</code></code></dt>
<dd><a name="1008219"> </a>This port already has an installed foreground owner.</dd>

<dt><a name="994432"> </a><code><code>serErrBadPort</code></code></dt>
<dd><a name="1008220"> </a>This port doesn't exist.</dd>

<dt><a name="994433"> </a><code><code>memErrNotEnoughSpace</code></code></dt>
<dd><a name="1008221"> </a>There was not enough memory available to open the port.</dd>

</dl>
<h4>
  <a name="994434"> </a>Comments 
</h4>

<p><a name="994435"> </a>Only one application or task may have access to a particular serial port at any time.</p>

<p><a name="994436"> </a>Do not keep the port open any longer than necessary. An open serial port consumes more energy from the device's batteries. </p>

<h3 class="hbH3">
  <a name="994504"> </a>SrmPrimeWakeupHandler Function <a href="#608590"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="994505"> </a>Purpose 
</h4>

<p><a name="994506"> </a>Sets the number of received bytes that triggers a call to the wakeup handler function.</p>
<h4>
  <a name="994507"> </a>Declared In 
</h4>
<code>SerialMgr.h<a name="994508"> </a></code><h4>
  <a name="994509"> </a>Prototype 
</h4>
<pre class="proto"><a name="994510"></a>status_t SrmPrimeWakeupHandler (
   uint16_t portId,
   uint16_t minBytes
)
</pre>
<h4>
  <a name="994511"> </a>Parameters 
</h4>

<dl>
<dt><a name="994515"> </a><code>&rarr;  <i><code>portId</code></i></code></dt>
<dd><a name="1008767"> </a>Port ID returned from <a href="LowLevelComms_SerRef.html#994414"><code>SrmOpen()</code></a> or <a href="LowLevelComms_SerRef.html#994192"><code>SrmExtOpen()</code></a>.</dd>

<dt><a name="994519"> </a><code>&rarr;  <i><code>minBytes</code></i></code></dt>
<dd><a name="1008768"> </a>Number of bytes that must be received before wakeup handler is called. Typically, this is set to 1.</dd>

</dl>
<h4>
  <a name="994520"> </a>Returns 
</h4>

<p><a name="994521"> </a>This function returns the following error codes:</p>

<dl>
<dt><a name="994522"> </a><code><code>errNone</code></code></dt>
<dd><a name="1008769"> </a>No error.</dd>

<dt><a name="994523"> </a><code><code>serErrBadPort</code></code></dt>
<dd><a name="1008810"> </a>This port doesn't exist.</dd>

<dt><a name="994524"> </a><code><code>serErrNotOpen</code></code></dt>
<dd><a name="1008811"> </a>The port is not open. </dd>

<dt><a name="994525"> </a><code><code>serErrNoDevicesAvail</code></code></dt>
<dd><a name="1008812"> </a>No serial devices could be found. </dd>

</dl>
<h4>
  <a name="994526"> </a>Comments 
</h4>

<p><a name="994527"> </a>This function primes a wakeup handler installed by <a href="LowLevelComms_SerRef.html#995066"><code>SrmSetWakeupHandler()</code></a>.</p>
<h4>
  <a name="994537"> </a>See Also 
</h4>

<p><a name="994544"> </a><a href="LowLevelComms_SerRef.html#995066"><code>SrmSetWakeupHandler()</code></a>, <a href="LowLevelComms_SerRef.html#995117"><code>WakeupHandlerProcPtr()</code></a></p>

<h3 class="hbH3">
  <a name="994547"> </a>SrmReceive Function <a href="#608590"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="994548"> </a>Purpose 
</h4>

<p><a name="994549"> </a>Receives a specified number of bytes.</p>
<h4>
  <a name="994550"> </a>Declared In 
</h4>
<code>SerialMgr.h<a name="994551"> </a></code><h4>
  <a name="994552"> </a>Prototype 
</h4>
<pre class="proto"><a name="994553"></a>uint32_t SrmReceive (
   uint16_t portId,
   void *rcvBufP,
   uint32_t count,
   int32_t timeout,
   status_t *errP
)
</pre>
<h4>
  <a name="994554"> </a>Parameters 
</h4>

<dl>
<dt><a name="994558"> </a><code>&rarr;  <i><code>portID</code></i></code></dt>
<dd><a name="1008813"> </a>Port ID returned from <a href="LowLevelComms_SerRef.html#994414"><code>SrmOpen()</code></a> or <a href="LowLevelComms_SerRef.html#994192"><code>SrmExtOpen()</code></a>.</dd>

<dt><a name="994562"> </a><code>&larr;  <i><code>rcvBufP</code></i></code></dt>
<dd><a name="1008814"> </a>Pointer to buffer where received data is to be returned.</dd>

<dt><a name="994563"> </a><code>&rarr;  <i><code>count</code></i></code></dt>
<dd><a name="1008815"> </a>Length of data buffer (in bytes). This specifies the number of bytes to receive.</dd>

<dt><a name="994564"> </a><code>&rarr;  <i><code>timeout</code></i></code></dt>
<dd><a name="1008852"> </a>The amount of time (in milliseconds) that the Serial Manager waits to receive the requested block of data. At the end of the timeout, data received up to that time is returned.</dd>

<dt><a name="994565"> </a><code>&larr;  <i><code>errP</code></i></code></dt>
<dd><a name="1008933"> </a>Error code.</dd>

</dl>
<h4>
  <a name="994566"> </a>Returns 
</h4>

<p><a name="994567"> </a>Number of bytes of data actually received.</p>
<h4>
  <a name="994568"> </a>Comments 
</h4>

<div><hr>
  <a name="994569"> </a> <b>IMPORTANT: </b> Note that in versions of Palm OS prior to 6.0, the timeout was specified in ticks. It is now specified in milliseconds.
<hr>
</div>

<p><a name="995891"> </a>The following error codes can be returned in <code class="par">errP</code>:</p>

<dl>
<dt><a name="994570"> </a><code><code>errNone</code></code></dt>
<dd><a name="1009006"> </a>No error.</dd>

<dt><a name="994571"> </a><code><code>serErrBadPort</code></code></dt>
<dd><a name="1009079"> </a>This port doesn't exist.</dd>

<dt><a name="994572"> </a><code><code>serErrNotOpen</code></code></dt>
<dd><a name="1009080"> </a>The port is not open. </dd>

<dt><a name="994573"> </a><code><code>serErrTimeOut</code></code></dt>
<dd><a name="1009081"> </a>Unable to receive data within the specified timeout period.</dd>

<dt><a name="994574"> </a><code><code>serErrConfigurationFailed</code></code></dt>
<dd><a name="1009082"> </a>The port needs time to configure, and the configuration has failed. </dd>

<dt><a name="994575"> </a><code><code>serErrNotSupported</code></code></dt>
<dd><a name="1009083"> </a>The port is not the foreground port. </dd>

<dt><a name="994577"> </a><code><code>serErrConfigurationFailed</code></code></dt>
<dd><a name="1009084"> </a>The port could not configure itself. </dd>

<dt><a name="994578"> </a><code><code>serErrLineErr</code></code></dt>
<dd><a name="1009121"> </a>A line error occurred during the receipt of data. Use <a href="LowLevelComms_SerRef.html#994376"><code>SrmGetStatus()</code></a> to obtain the exact line error. </dd>

<dt><a name="994583"> </a><code><code>serErrNoDevicesAvail</code></code></dt>
<dd><a name="1009158"> </a>No serial devices could be found. </dd>

</dl>
<h4>
  <a name="994589"> </a>See Also 
</h4>

<p><a name="994599"> </a><a href="LowLevelComms_SerRef.html#994602"><code>SrmReceiveCheck()</code></a>, <a href="LowLevelComms_SerRef.html#994646"><code>SrmReceiveFlush()</code></a>, <a href="LowLevelComms_SerRef.html#994690"><code>SrmReceiveWait()</code></a></p>

<h3 class="hbH3">
  <a name="994602"> </a>SrmReceiveCheck Function <a href="#608590"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="994603"> </a>Purpose 
</h4>

<p><a name="994604"> </a>Checks the receive FIFO and returns the number of bytes in the serial receive queue.</p>
<h4>
  <a name="994605"> </a>Declared In 
</h4>
<code>SerialMgr.h<a name="994606"> </a></code><h4>
  <a name="994607"> </a>Prototype 
</h4>
<pre class="proto"><a name="994608"></a>status_t SrmReceiveCheck (
   uint16_t portId,
   uint32_t *numBytesP
)
</pre>
<h4>
  <a name="994609"> </a>Parameters 
</h4>

<dl>
<dt><a name="994613"> </a><code>&rarr;  <i><code>portID</code></i></code></dt>
<dd><a name="1009339"> </a>Port ID returned from <a href="LowLevelComms_SerRef.html#994414"><code>SrmOpen()</code></a> or <a href="LowLevelComms_SerRef.html#994192"><code>SrmExtOpen()</code></a>.</dd>

<dt><a name="994617"> </a><code>&larr;  <i><code>numBytesP</code></i></code></dt>
<dd><a name="1009400"> </a>Number of bytes in the receive queue.</dd>

</dl>
<h4>
  <a name="994618"> </a>Returns 
</h4>

<p><a name="994619"> </a>This function returns the following error codes:</p>

<dl>
<dt><a name="994620"> </a><code><code>errNone</code></code></dt>
<dd><a name="1009513"> </a>No error.</dd>

<dt><a name="994621"> </a><code><code>serErrBadPort</code></code></dt>
<dd><a name="1009570"> </a>This port doesn't exist.</dd>

<dt><a name="994622"> </a><code><code>serErrNotOpen</code></code></dt>
<dd><a name="1009627"> </a>The port is not open. </dd>

<dt><a name="994627"> </a><code><code>serErrLineErr</code></code></dt>
<dd><a name="1009676"> </a>A line error has occurred. Use <a href="LowLevelComms_SerRef.html#994376"><code>SrmGetStatus()</code></a> to obtain the exact line error. </dd>

</dl>
<h4>
  <a name="994633"> </a>See Also 
</h4>

<p><a name="994643"> </a><a href="LowLevelComms_SerRef.html#994547"><code>SrmReceive()</code></a>, <a href="LowLevelComms_SerRef.html#994646"><code>SrmReceiveFlush()</code></a>, <a href="LowLevelComms_SerRef.html#994690"><code>SrmReceiveWait()</code></a></p>

<h3 class="hbH3">
  <a name="994646"> </a>SrmReceiveFlush Function <a href="#608590"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="994647"> </a>Purpose 
</h4>

<p><a name="994648"> </a>Flushes the receive FIFOs.</p>
<h4>
  <a name="994649"> </a>Declared In 
</h4>
<code>SerialMgr.h<a name="994650"> </a></code><h4>
  <a name="994651"> </a>Prototype 
</h4>
<pre class="proto"><a name="994652"></a>status_t SrmReceiveFlush (
   uint16_t portId,
   int32_t timeout
)
</pre>
<h4>
  <a name="994653"> </a>Parameters 
</h4>

<dl>
<dt><a name="994657"> </a><code>&rarr;  <i>portId</i></code></dt>
<dd><a name="1009972"> </a>Port ID returned from <a href="LowLevelComms_SerRef.html#994414"><code>SrmOpen()</code></a> or <a href="LowLevelComms_SerRef.html#994192"><code>SrmExtOpen()</code></a>.</dd>

<dt><a name="994661"> </a><code>&rarr;  <i>timeout</i></code></dt>
<dd><a name="1047564"> </a>Timeout value, in milliseconds.</dd>

</dl>
<h4>
  <a name="994662"> </a>Returns 
</h4>

<p><a name="994663"> </a>This function returns the following error codes:</p>

<dl>
<dt><a name="994664"> </a><code><code>errNone</code></code></dt>
<dd><a name="1010057"> </a>No error.</dd>

<dt><a name="994665"> </a><code><code>serErrBadPort</code></code></dt>
<dd><a name="1010058"> </a>This port doesn't exist.</dd>

<dt><a name="994666"> </a><code><code>serErrNotOpen</code></code></dt>
<dd><a name="1010133"> </a>The port is not open. </dd>

<dt><a name="994667"> </a><code><code>serErrNotSupported</code></code></dt>
<dd><a name="1010182"> </a>The port is not the foreground port. </dd>

<dt><a name="994668"> </a><code><code>serErrNoDevicesAvail</code></code></dt>
<dd><a name="1010231"> </a>No serial devices could be found. </dd>

</dl>
<h4>
  <a name="994669"> </a>Comments 
</h4>

<div><hr>
  <a name="995997"> </a> <b>IMPORTANT: </b> Note that in versions of Palm OS prior to 6.0, the timeout was specified in ticks. It is now specified in milliseconds.
<hr>
</div>

<p><a name="995924"> </a>The <code class="par">timeout</code> value forces this function to wait a period of microseconds after flushing the port to see if more data shows up to be flushed. If more data arrives within the timeout period, the port is flushed again and the timeout counter is reset and waits again. The function only exits after no more bytes are received by the port for the full timeout period since the last flush of the port. To avoid this waiting behavior, specify 0 for the timeout period.</p>

<p><a name="994671"> </a>Any errors on the line are cleared before this function returns. </p>
<h4>
  <a name="994677"> </a>See Also 
</h4>

<p><a name="994687"> </a><a href="LowLevelComms_SerRef.html#994547"><code>SrmReceive</code></a>, <a href="LowLevelComms_SerRef.html#994602"><code>SrmReceiveCheck</code></a>, <a href="LowLevelComms_SerRef.html#994690"><code>SrmReceiveWait</code></a></p>

<h3 class="hbH3">
  <a name="994690"> </a>SrmReceiveWait Function <a href="#608590"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="994691"> </a>Purpose 
</h4>

<p><a name="994692"> </a>Waits until some number of bytes of data have arrived into the serial receive queue, then returns.</p>
<h4>
  <a name="994693"> </a>Declared In 
</h4>
<code>SerialMgr.h<a name="994694"> </a></code><h4>
  <a name="994695"> </a>Prototype 
</h4>
<pre class="proto"><a name="994696"></a>status_t SrmReceiveWait (
   uint16_t portId,
   uint32_t bytes,
   int32_t timeout
)
</pre>
<h4>
  <a name="994697"> </a>Parameters 
</h4>

<dl>
<dt><a name="994701"> </a><code>&rarr;  <i><code>portID</code></i></code></dt>
<dd><a name="1010399"> </a>Port ID returned from <a href="LowLevelComms_SerRef.html#994414"><code>SrmOpen()</code></a> or <a href="LowLevelComms_SerRef.html#994192"><code>SrmExtOpen()</code></a>.</dd>

<dt><a name="1010400"> </a><code>&rarr;  <i><code>bytes</code></i></code></dt>
<dd><a name="1010404"> </a>Number of bytes to wait for.</dd>

<dt><a name="1010401"> </a><code>&rarr;  <i><code>timeout</code></i></code></dt>
<dd><a name="1010405"> </a>Timeout value, in microseconds.</dd>

</dl>
<h4>
  <a name="994707"> </a>Returns 
</h4>

<p><a name="994708"> </a>This function returns the following error codes:</p>

<dl>
<dt><a name="994709"> </a><code><code>errNone</code></code></dt>
<dd><a name="1010434"> </a>No error.</dd>

<dt><a name="994710"> </a><code><code>serErrBadPort</code></code></dt>
<dd><a name="1010435"> </a>This port doesn't exist.</dd>

<dt><a name="994711"> </a><code><code>serErrNotOpen</code></code></dt>
<dd><a name="1010436"> </a>The port is not open.</dd>

<dt><a name="994712"> </a><code><code>serErrTimeOut</code></code></dt>
<dd><a name="1010437"> </a>Unable to receive data within the specified timeout period.</dd>

<dt><a name="994713"> </a><code><code>serErrNotSupported</code></code></dt>
<dd><a name="1010438"> </a>The port is not the foreground port. </dd>

<dt><a name="994714"> </a><code><code>serErrBadParam</code></code></dt>
<dd><a name="1010439"> </a>The bytes parameter exceeds the size of the receive queue. Use <a href="LowLevelComms_SerRef.html#995031"><code>SrmSetReceiveBuffer()</code></a> to increase the size of the receive queue. </dd>

<dt><a name="994719"> </a><code><code>serErrLineErr</code></code></dt>
<dd><a name="1010469"> </a>A line error occurred during the receipt of data. Use <a href="LowLevelComms_SerRef.html#994376"><code>SrmGetStatus()</code></a> to obtain the exact line error. </dd>

<dt><a name="994724"> </a><code><code>serErrNoDevicesAvail</code></code></dt>
<dd><a name="1010502"> </a>No serial devices could be found. </dd>

</dl>
<h4>
  <a name="994725"> </a>Comments 
</h4>

<div><hr>
  <a name="996151"> </a> <b>IMPORTANT: </b> Note that in versions of Palm OS prior to 6.0, the timeout was specified in ticks. It is now specified in milliseconds.
<hr>
</div>

<p><a name="996101"> </a>If this function returns no error, the application can either check the number of bytes currently in the receive queue (using <a href="LowLevelComms_SerRef.html#994602"><code>SrmReceiveCheck()</code></a>) or it can just specify a buffer and receive the data by calling <a href="LowLevelComms_SerRef.html#994547"><code>SrmReceive()</code></a>.</p>

<p><a name="994735"> </a>Do not call <code>SerReceiveWait()</code> from within a wakeup handler. If you do, the <code>serErrTimeOut</code> error is returned. </p>
<h4>
  <a name="994741"> </a>See Also 
</h4>

<p><a name="994751"> </a><a href="LowLevelComms_SerRef.html#994547"><code>SrmReceive()</code></a>, <a href="LowLevelComms_SerRef.html#994602"><code>SrmReceiveCheck()</code></a>, <a href="LowLevelComms_SerRef.html#994646"><code>SrmReceiveFlush()</code></a></p>

<h3 class="hbH3">
  <a name="994754"> </a>SrmReceiveWindowClose Function <a href="#608590"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="994755"> </a>Purpose 
</h4>

<p><a name="994756"> </a>Closes direct access to the Serial Manager's receive queue.</p>
<h4>
  <a name="994757"> </a>Declared In 
</h4>
<code>SerialMgr.h<a name="994758"> </a></code><h4>
  <a name="994759"> </a>Prototype 
</h4>
<pre class="proto"><a name="994760"></a>status_t SrmReceiveWindowClose (
   uint16_t portId,
   uint32_t bytesPulled
)
</pre>
<h4>
  <a name="994761"> </a>Parameters 
</h4>

<dl>
<dt><a name="994765"> </a><code>&rarr;  <i><code>portId</code></i></code></dt>
<dd><a name="1010576"> </a>Port ID returned from <a href="LowLevelComms_SerRef.html#994414"><code>SrmOpen()</code></a> or <a href="LowLevelComms_SerRef.html#994192"><code>SrmExtOpen()</code></a>.</dd>

<dt><a name="994769"> </a><code>&rarr;  <i><code>bytesPulled</code></i></code></dt>
<dd><a name="1010609"> </a>Number of bytes the application read from the receive queue.</dd>

</dl>
<h4>
  <a name="994770"> </a>Returns 
</h4>

<p><a name="994771"> </a>This function returns the following error codes:</p>

<dl>
<dt><a name="994772"> </a><code><code>errNone</code></code></dt>
<dd><a name="1010626"> </a>No error.</dd>

<dt><a name="994773"> </a><code><code>serErrBadPort</code></code></dt>
<dd><a name="1010672"> </a>This port doesn't exist.</dd>

<dt><a name="994774"> </a><code><code>serErrNotOpen</code></code></dt>
<dd><a name="1010673"> </a>The port is not open. </dd>

<dt><a name="994775"> </a><code><code>serErrNotSupported</code></code></dt>
<dd><a name="1010674"> </a>The port is not the foreground port. </dd>

<dt><a name="994776"> </a><code><code>serErrNoDevicesAvail</code></code></dt>
<dd><a name="1010675"> </a>No serial devices could be found. </dd>

</dl>
<h4>
  <a name="994777"> </a>Comments 
</h4>

<p><a name="994778"> </a>Call this function when the application has read as many bytes as it needs out of the receive queue or it has read all the available bytes.</p>
<h4>
  <a name="994784"> </a>See Also 
</h4>

<p><a name="994788"> </a><a href="LowLevelComms_SerRef.html#994791"><code>SrmReceiveWindowOpen()</code></a></p>

<h3 class="hbH3">
  <a name="994791"> </a>SrmReceiveWindowOpen Function <a href="#608590"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="994792"> </a>Purpose 
</h4>

<p><a name="994793"> </a>Provides direct access to the Serial Manager's receive queue.</p>
<h4>
  <a name="994794"> </a>Declared In 
</h4>
<code>SerialMgr.h<a name="994795"> </a></code><h4>
  <a name="994796"> </a>Prototype 
</h4>
<pre class="proto"><a name="994797"></a>status_t SrmReceiveWindowOpen (
   uint16_t portId,
   UInt8 **bufPP,
   uint32_t *sizeP
)
</pre>
<h4>
  <a name="994798"> </a>Parameters 
</h4>

<dl>
<dt><a name="994802"> </a><code>&rarr;  <i><code>portId</code></i></code></dt>
<dd><a name="1011239"> </a>Port ID returned from <a href="LowLevelComms_SerRef.html#994414"><code>SrmOpen()</code></a> or <a href="LowLevelComms_SerRef.html#994192"><code>SrmExtOpen()</code></a>.</dd>

<dt><a name="994806"> </a><code>&larr;  <i><code>bufPP</code></i></code></dt>
<dd><a name="1011240"> </a>Pointer to a pointer to the receive buffer.</dd>

<dt><a name="994807"> </a><code>&larr;  <i><code>sizeP</code></i></code></dt>
<dd><a name="1011241"> </a>Available bytes in buffer.</dd>

</dl>
<h4>
  <a name="994808"> </a>Returns 
</h4>

<p><a name="994809"> </a>This function returns the following error codes:</p>

<dl>
<dt><a name="994810"> </a><code><code>errNone</code></code></dt>
<dd><a name="1011279"> </a>No error.</dd>

<dt><a name="994811"> </a><code><code>serErrBadPort</code></code></dt>
<dd><a name="1011319"> </a>This port doesn't exist.</dd>

<dt><a name="994812"> </a><code><code>serErrNotOpen</code></code></dt>
<dd><a name="1011360"> </a>The port is not open. </dd>

<dt><a name="994813"> </a><code><code>serErrNotSupported</code></code></dt>
<dd><a name="1011421"> </a>The port is not the foreground port. </dd>

<dt><a name="994814"> </a><code><code>serErrLineErr</code></code></dt>
<dd><a name="1011454"> </a>The data in the queue contains line errors.</dd>

<dt><a name="994815"> </a><code><code>serErrNoDevicesAvail</code></code></dt>
<dd><a name="1011499"> </a>No serial devices could be found. </dd>

</dl>
<h4>
  <a name="994816"> </a>Comments 
</h4>

<p><a name="994817"> </a>This function lets applications directly access the Serial Manager's receive queue to eliminate buffer copying by the Serial Manager. This access is a "back door" route to the received data. After retrieving data from the buffer, the application must call <a href="LowLevelComms_SerRef.html#994754"><code>SrmReceiveWindowClose()</code></a>.</p>

<p><a name="994821"> </a>Applications that want to empty the receive buffer entirely should call the <code>SrmReceiveWindowOpen()</code> and <code>SrmReceiveWindowClose()</code> functions repeatedly until the buffer size returned is 0.</p>

<div><hr>
  <a name="994822"> </a> <b>IMPORTANT: </b> Once an application calls <code>SrmReceiveWindowOpen()</code>, it should not attempt to receive data via the normal method of calling <a href="LowLevelComms_SerRef.html#994547"><code>SrmReceive()</code></a> or <a href="LowLevelComms_SerRef.html#994690"><code>SrmReceiveWait()</code></a>, as these functions interfere with direct access to the receive queue.
<hr>
</div>
<h4>
  <a name="994836"> </a>See Also 
</h4>

<p><a name="994840"> </a><a href="LowLevelComms_SerRef.html#994754"><code>SrmReceiveWindowClose()</code></a></p>

<h3 class="hbH3">
  <a name="994843"> </a>SrmSend Function <a href="#608590"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="994844"> </a>Purpose 
</h4>

<p><a name="994845"> </a>Sends a block of data out the specified port.</p>
<h4>
  <a name="994846"> </a>Declared In 
</h4>
<code>SerialMgr.h<a name="994847"> </a></code><h4>
  <a name="994848"> </a>Prototype 
</h4>
<pre class="proto"><a name="994849"></a>uint32_t SrmSend (
   uint16_t portId,
   const void *bufP,
   uint32_t count,
   status_t *errP
)
</pre>
<h4>
  <a name="994850"> </a>Parameters 
</h4>

<dl>
<dt><a name="994854"> </a><code>&rarr;  <i><code>portID</code></i></code></dt>
<dd><a name="1011707"> </a>Port ID returned from <a href="LowLevelComms_SerRef.html#994414"><code>SrmOpen()</code></a> or <a href="LowLevelComms_SerRef.html#994192"><code>SrmExtOpen()</code></a>.</dd>

<dt><a name="994858"> </a><code>&rarr;  <i><code>bufp</code></i></code></dt>
<dd><a name="1011808"> </a>Pointer to data to send.</dd>

<dt><a name="994859"> </a><code>&rarr;  <i><code>count</code></i></code></dt>
<dd><a name="1011841"> </a>Length of data buffer, in bytes.</dd>

<dt><a name="994860"> </a><code>&larr;  <i><code>errP</code></i></code></dt>
<dd><a name="1011858"> </a>Error code. See the Comments section for details.</dd>

</dl>
<h4>
  <a name="994861"> </a>Returns 
</h4>

<p><a name="994862"> </a>Number of bytes of data actually sent.</p>
<h4>
  <a name="994863"> </a>Comments 
</h4>

<p><a name="994864"> </a>When <code>SrmSend()</code> returns, you should check the value returned in the <code class="par">errP</code> parameter. If <code>errNone</code>, then the entire data buffer was sent. If not <code>errNone</code>, then the result equals the number of bytes sent before the error occurred. The possible error values are: </p>

<dl>
<dt><a name="994866"> </a><code><code>errNone</code></code></dt>
<dd><a name="1011859"> </a>No error.</dd>

<dt><a name="994868"> </a><code><code>serErrBadPort</code></code></dt>
<dd><a name="1011860"> </a>This port doesn't exist.</dd>

<dt><a name="994870"> </a><code><code>serErrNotOpen</code></code></dt>
<dd><a name="1011861"> </a>The port is not open. </dd>

<dt><a name="994872"> </a><code><code>serErrTimeOut</code></code></dt>
<dd><a name="1011866"> </a>Unable to send data within the specified CTS timeout period.</dd>

<dt><a name="994873"> </a><code><code>serErrNoDevicesAvail</code></code></dt>
<dd><a name="1011883"> </a>No serial devices could be found. </dd>

<dt><a name="994875"> </a><code><code>serErrConfigurationFailed</code> </code></dt>
<dd><a name="1011904"> </a>The port configuration has failed. </dd>

<dt><a name="994877"> </a><code><code>serErrNotSupported</code> </code></dt>
<dd><a name="1011913"> </a>The specified port is not the foreground port. </dd>

</dl>
<h4>
  <a name="994883"> </a>See Also 
</h4>

<p><a name="994893"> </a><a href="LowLevelComms_SerRef.html#994896"><code>SrmSendCheck()</code></a>, <a href="LowLevelComms_SerRef.html#994940"><code>SrmSendFlush()</code></a>, <a href="LowLevelComms_SerRef.html#994982"><code>SrmSendWait()</code></a></p>

<h3 class="hbH3">
  <a name="994896"> </a>SrmSendCheck Function <a href="#608590"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="994897"> </a>Purpose 
</h4>

<p><a name="994898"> </a>Checks the transmit FIFO and returns the number of bytes left to be sent. </p>
<h4>
  <a name="994899"> </a>Declared In 
</h4>
<code>SerialMgr.h<a name="994900"> </a></code><h4>
  <a name="994901"> </a>Prototype 
</h4>
<pre class="proto"><a name="994902"></a>status_t SrmSendCheck (
   uint16_t portId,
   uint32_t *numBytesP
)
</pre>
<h4>
  <a name="994903"> </a>Parameters 
</h4>

<dl>
<dt><a name="994907"> </a><code>&rarr;  <i><code>portID</code></i></code></dt>
<dd><a name="1011939"> </a>Port ID returned from <a href="LowLevelComms_SerRef.html#994414"><code>SrmOpen()</code></a> or <a href="LowLevelComms_SerRef.html#994192"><code>SrmExtOpen()</code></a>.</dd>

<dt><a name="994911"> </a><code>&larr;  <i><code>numBytesP</code></i></code></dt>
<dd><a name="1011952"> </a>Number of bytes left in the FIFO queue.</dd>

</dl>
<h4>
  <a name="994912"> </a>Returns 
</h4>

<p><a name="994913"> </a>This function returns the following error codes:</p>

<dl>
<dt><a name="994914"> </a><code><code>errNone</code></code></dt>
<dd><a name="1011953"> </a>No error.</dd>

<dt><a name="994915"> </a><code><code>serErrBadPort</code></code></dt>
<dd><a name="1011954"> </a>This port doesn't exist.</dd>

<dt><a name="994917"> </a><code><code>serErrNotOpen</code></code></dt>
<dd><a name="1012022"> </a>The port is not open. </dd>

<dt><a name="994918"> </a><code><code>serErrNotSupported</code></code></dt>
<dd><a name="1012063"> </a>This feature not supported by the hardware.</dd>

<dt><a name="994919"> </a><code><code>serErrNoDevicesAvail</code></code></dt>
<dd><a name="1012124"> </a>No serial devices could be found. </dd>

</dl>
<h4>
  <a name="994920"> </a>Comments 
</h4>

<p><a name="994921"> </a>Not all serial devices support this feature.</p>
<h4>
  <a name="994927"> </a>See Also 
</h4>

<p><a name="994937"> </a><a href="LowLevelComms_SerRef.html#994843"><code>SrmSend()</code></a>, <a href="LowLevelComms_SerRef.html#994940"><code>SrmSendFlush()</code></a>, <a href="LowLevelComms_SerRef.html#994982"><code>SrmSendWait()</code></a></p>

<h3 class="hbH3">
  <a name="994940"> </a>SrmSendFlush Function <a href="#608590"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="994941"> </a>Purpose 
</h4>

<p><a name="994942"> </a>Flushes the transmit FIFO.</p>
<h4>
  <a name="994943"> </a>Declared In 
</h4>
<code>SerialMgr.h<a name="994944"> </a></code><h4>
  <a name="994945"> </a>Prototype 
</h4>
<pre class="proto"><a name="994946"></a>status_t SrmSendFlush (
   uint16_t portId
)
</pre>
<h4>
  <a name="994947"> </a>Parameters 
</h4>

<dl>
<dt><a name="994951"> </a><code>&rarr;  <i><code>portID</code></i></code></dt>
<dd><a name="1012246"> </a>Port ID returned from <a href="LowLevelComms_SerRef.html#994414"><code>SrmOpen()</code></a> or <a href="LowLevelComms_SerRef.html#994192"><code>SrmExtOpen()</code></a>.</dd>

</dl>
<h4>
  <a name="994955"> </a>Returns 
</h4>

<p><a name="994956"> </a>This function returns the following error codes:</p>

<dl>
<dt><a name="994957"> </a><code><code>errNone</code></code></dt>
<dd><a name="1012263"> </a>No error.</dd>

<dt><a name="994958"> </a><code><code>serErrBadPort</code></code></dt>
<dd><a name="1012272"> </a>This port doesn't exist.</dd>

<dt><a name="994960"> </a><code><code>serErrNotOpen</code></code></dt>
<dd><a name="1012350"> </a>The port is not open. </dd>

<dt><a name="994962"> </a><code><code>serErrNotSupported</code></code></dt>
<dd><a name="1012447"> </a>The port is not the foreground port. </dd>

<dt><a name="994963"> </a><code><code>serErrNoDevicesAvail</code></code></dt>
<dd><a name="1012544"> </a>No serial devices could be found. </dd>

</dl>
<h4>
  <a name="994969"> </a>See Also 
</h4>

<p><a name="994979"> </a><a href="LowLevelComms_SerRef.html#994843"><code>SrmSend()</code></a>, <a href="LowLevelComms_SerRef.html#994896"><code>SrmSendCheck()</code></a>, <a href="LowLevelComms_SerRef.html#994982"><code>SrmSendWait()</code></a></p>

<h3 class="hbH3">
  <a name="994982"> </a>SrmSendWait Function <a href="#608590"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="994983"> </a>Purpose 
</h4>

<p><a name="994984"> </a>Waits until all previous data has been sent from the transmit FIFO, then returns.</p>
<h4>
  <a name="994985"> </a>Declared In 
</h4>
<code>SerialMgr.h<a name="994986"> </a></code><h4>
  <a name="994987"> </a>Prototype 
</h4>
<pre class="proto"><a name="994988"></a>status_t SrmSendWait (
   uint16_t portId
)
</pre>
<h4>
  <a name="994989"> </a>Parameters 
</h4>

<dl>
<dt><a name="994993"> </a><code>&rarr;  <i><code>portID</code></i></code></dt>
<dd><a name="1012782"> </a>Port ID returned from <a href="LowLevelComms_SerRef.html#994414"><code>SrmOpen()</code></a> or <a href="LowLevelComms_SerRef.html#994192"><code>SrmExtOpen()</code></a>.</dd>

</dl>
<h4>
  <a name="994997"> </a>Returns 
</h4>

<p><a name="994998"> </a>This function returns the following error codes:</p>

<dl>
<dt><a name="994999"> </a><code><code>errNone</code></code></dt>
<dd><a name="1012831"> </a>No error.</dd>

<dt><a name="995000"> </a><code><code>serErrBadPort</code></code></dt>
<dd><a name="1012856"> </a>This port doesn't exist.</dd>

<dt><a name="995002"> </a><code><code>serErrNotOpen</code></code></dt>
<dd><a name="1012875"> </a>The port is not open. </dd>

<dt><a name="1012876"> </a><code><code>serErrTimeOut</code></code></dt>
<dd><a name="1012895"> </a>Unable to send data within the CTS timeout period.</dd>

<dt><a name="995005"> </a><code><code>serErrNotSupported</code></code></dt>
<dd><a name="1012908"> </a>The port is not the foreground port. </dd>

<dt><a name="995006"> </a><code><code>serErrNoDevicesAvail</code></code></dt>
<dd><a name="1012921"> </a>No serial devices could be found. </dd>

</dl>
<h4>
  <a name="995007"> </a>Comments 
</h4>

<p><a name="995008"> </a>Consider calling this function if your software needs to detect when all data has been transmitted by <a href="LowLevelComms_SerRef.html#994843"><code>SrmSend()</code></a>. The <code>SrmSend()</code> function blocks until all data has been transmitted or a timeout occurs. A subsequent call to <code>SrmSendWait()</code> blocks until all data queued up for transmission has been transmitted or until another CTS timeout occurs (if CTS handshaking is enabled). </p>
<h4>
  <a name="995018"> </a>See Also 
</h4>

<p><a name="995028"> </a><a href="LowLevelComms_SerRef.html#994843"><code>SrmSend()</code></a>, <a href="LowLevelComms_SerRef.html#994896"><code>SrmSendCheck()</code></a>, <a href="LowLevelComms_SerRef.html#994940"><code>SrmSendFlush()</code></a></p>

<h3 class="hbH3">
  <a name="995031"> </a>SrmSetReceiveBuffer Function <a href="#608590"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="995032"> </a>Purpose 
</h4>

<p><a name="995033"> </a>Installs a new buffer into the Serial Manager's receive queue.</p>
<h4>
  <a name="995034"> </a>Declared In 
</h4>
<code>SerialMgr.h<a name="995035"> </a></code><h4>
  <a name="995036"> </a>Prototype 
</h4>
<pre class="proto"><a name="995037"></a>status_t SrmSetReceiveBuffer (
   uint16_t portId,
   void *bufP,
   uint16_t bufSize
)
</pre>
<h4>
  <a name="995038"> </a>Parameters 
</h4>

<dl>
<dt><a name="995042"> </a><code>&rarr;  <i><code>portID</code></i></code></dt>
<dd><a name="1013007"> </a>Port ID returned from <a href="LowLevelComms_SerRef.html#994414"><code>SrmOpen()</code></a> or <a href="LowLevelComms_SerRef.html#994192"><code>SrmExtOpen()</code></a>.</dd>

<dt><a name="995046"> </a><code>&rarr;  <i><code>bufP</code></i></code></dt>
<dd><a name="1013008"> </a>Pointer to new receive buffer. Ignored if <code class="par">bufSize</code> is <code>NULL</code>.</dd>

<dt><a name="995047"> </a><code>&rarr;  <i><code>bufSize</code></i></code></dt>
<dd><a name="1013009"> </a>Size of new receive buffer in bytes. To remove this buffer and allocate a new default buffer (512 bytes), specify 0.</dd>

</dl>
<h4>
  <a name="995048"> </a>Returns 
</h4>

<p><a name="995049"> </a>This function returns the following error codes:</p>

<dl>
<dt><a name="995050"> </a><code><code>errNone</code></code></dt>
<dd><a name="1012884"> </a>No error.</dd>

<dt><a name="995051"> </a><code><code>serErrBadPort</code></code></dt>
<dd><a name="1013012"> </a>This port doesn't exist.</dd>

<dt><a name="995052"> </a><code><code>serErrNotOpen</code></code></dt>
<dd><a name="1013020"> </a>This port is not open.</dd>

<dt><a name="995053"> </a><code><code>memErrNotEnoughSpace</code></code></dt>
<dd><a name="1012880"> </a>Not enough memory to allocate default buffer.</dd>

<dt><a name="995054"> </a><code><code>serErrNoDevicesAvail</code></code></dt>
<dd><a name="1012881"> </a>No serial devices could be found. </dd>

</dl>


<h4>
  <a name="995056"> </a>Comments 
</h4>

<p><a name="995057"> </a>The buffer that you pass to this function must remain allocated while you have the serial port open. Before you close the serial port, you must restore the default queue by calling <code>SrmSetReceiveBuffer()</code> with <code>NULL</code> as the <code class="par">bufP</code> and 0 as the <code class="par">bufSize</code> parameter. </p>

<div><hr>
  <a name="995058"> </a> <b>IMPORTANT: </b> Applications must install the default buffer before closing the port (or disposing of the new receive queue).
<hr>
</div>

<h3 class="hbH3">
  <a name="995066"> </a>SrmSetWakeupHandler Function <a href="#608590"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="995067"> </a>Purpose 
</h4>

<p><a name="995068"> </a>Installs a wakeup handler.</p>
<h4>
  <a name="995069"> </a>Declared In 
</h4>
<code>SerialMgr.h<a name="995070"> </a></code><h4>
  <a name="995071"> </a>Prototype 
</h4>
<pre class="proto"><a name="995072"></a>status_t SrmSetWakeupHandler (
   uint16_t portId,
   WakeupHandlerProcPtr procP,
   uint32_t refCon
)
</pre>
<h4>
  <a name="995073"> </a>Parameters 
</h4>

<dl>
<dt><a name="995077"> </a><code>&rarr;  <i><code>portID</code></i></code></dt>
<dd><a name="1013026"> </a>Port ID returned from <a href="LowLevelComms_SerRef.html#994414"><code>SrmOpen()</code></a> or <a href="LowLevelComms_SerRef.html#994192"><code>SrmExtOpen()</code></a>.</dd>

<dt><a name="995085"> </a><code>&rarr;  <i><code>procP</code></i></code></dt>
<dd><a name="1013027"> </a>Pointer to a <a href="LowLevelComms_SerRef.html#995117"><code>WakeupHandlerProcPtr()</code></a> function. Specify <code>NULL</code> to remove a handler.</dd>

<dt><a name="995086"> </a><code>&rarr;  <i><code>refCon</code></i></code></dt>
<dd><a name="1013028"> </a>User-defined data that is passed to the wakeup handler function. This can any 32-bit value, including a pointer.</dd>

</dl>
<h4>
  <a name="995087"> </a>Returns 
</h4>

<p><a name="995088"> </a>This function returns the following error codes:</p>

<dl>
<dt><a name="995089"> </a><code><code>errNone</code></code></dt>
<dd><a name="1013031"> </a>No error.</dd>

<dt><a name="995090"> </a><code><code>serErrBadPort</code></code></dt>
<dd><a name="1013032"> </a>This port doesn't exist.</dd>

<dt><a name="995091"> </a><code><code>serErrNotOpen</code></code></dt>
<dd><a name="1013033"> </a>The port is not open. </dd>

<dt><a name="995092"> </a><code><code>serErrNoDevicesAvail</code></code></dt>
<dd><a name="1013034"> </a>No serial devices could be found. </dd>

</dl>
<h4>
  <a name="995093"> </a>Comments 
</h4>

<p><a name="995094"> </a>The wakeup handler is a function in your application that you want to be called whenever there is data ready to be received on the specified port. </p>

<p><a name="995095"> </a>The wakeup handler function will not become active until it is primed with a number of bytes that is greater than 0, by the <a href="LowLevelComms_SerRef.html#994504"><code>SrmPrimeWakeupHandler()</code></a> function. Every time a wakeup handler is called, it must be re-primed (using <code>SrmPrimeWakeupHandler()</code>) in order to be called again.</p>
<h4>
  <a name="995105"> </a>See Also 
</h4>

<p><a name="995112"> </a><a href="LowLevelComms_SerRef.html#994504"><code>SrmPrimeWakeupHandler()</code></a>, <a href="LowLevelComms_SerRef.html#995117"><code>WakeupHandlerProcPtr()</code></a></p>

<h2 class="haH2">
  <a name="995114"> </a>Serial Manager Application-Defined Functions <a href="#608590"><span class="nav">^TOP^</span></a>
</h2>


<h3 class="hbH3">
  <a name="995117"> </a>WakeupHandlerProcPtr Function <a href="#608590"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="995118"> </a>Purpose 
</h4>

<p><a name="995119"> </a>Called after some number of bytes are received by the Serial Manager's interrupt function.</p>
<h4>
  <a name="995120"> </a>Declared In 
</h4>
<code>SerialMgr.h<a name="995121"> </a></code><h4>
  <a name="995122"> </a>Prototype 
</h4>
<pre class="proto"><a name="995123"></a>void (
   *WakeupHandlerProcPtr
)(
   uint32_t refCon
)
</pre>
<h4>
  <a name="995124"> </a>Parameters 
</h4>

<dl>
<dt><a name="995125"> </a><code>&rarr;  <i><code>refCon</code></i></code></dt>
<dd><a name="1013042"> </a>User-defined data passed from the <a href="LowLevelComms_SerRef.html#995066"><code>SrmSetWakeupHandler()</code></a> function.</dd>

</dl>
<h4>
  <a name="995129"> </a>Returns 
</h4>

<p><a name="995130"> </a>Returns nothing.</p>
<h4>
  <a name="995131"> </a>Comments 
</h4>

<p><a name="995132"> </a>This handler function is installed by calling <a href="LowLevelComms_SerRef.html#995066"><code>SrmSetWakeupHandler()</code></a>. The number of bytes after which it is called is specified by <a href="LowLevelComms_SerRef.html#994504"><code>SrmPrimeWakeupHandler()</code></a>.</p>

<p><a name="1040489"> </a>Under Palm OS Cobalt, the wakeup handler is called from a thread in the application's process. Because of this, it's possible that the handler can be called while the application is already calling a Serial Manager function.</p>

<p><a name="1040490"> </a>If your application manages synchronization between the wakeup handler and its main thread, it can call Serial Manager functions within the wakeup handler. However, if your needs are complex, or you want to maximize performance, you may benefit from using the IOS API instead of the Serial Manager.</p>

<p><a name="995146"> </a>Two common implementations of wakeup handlers include: </p>
<ul type="disc">
  <li><a name="995151"> </a>Calling <a href="../Programming_Basics/Event.html#997155"><code>EvtWakeup()</code></a>, which causes any pending <code>EvtGetEvent</code> call to return and then sends a <code>nilEvent</code> to the current application. 
  <li><a name="995156"> </a>Using <a href="LowLevelComms_SerRef.html#994791"><code>SrmReceiveWindowOpen()</code></a> and <a href="LowLevelComms_SerRef.html#994754"><code>SrmReceiveWindowClose()</code></a> to gain direct access to the receive queue without blocking. 
</ul>
<h4>
  <a name="995166"> </a>See Also 
</h4>

<p><a name="995173"> </a><a href="LowLevelComms_SerRef.html#994504"><code>SrmPrimeWakeupHandler()</code></a>, <a href="LowLevelComms_SerRef.html#995066"><code>SrmSetWakeupHandler()</code></a></p>

<p><a name="995174"> </a></p>
&nbsp;<br>
</div>
<!--END CONTENT-->

</td>
<td width="5">&nbsp;&nbsp;</td>
</tr>

</table>

<!-- BEGIN FOOTER -->
<table width="100%" border="0" cellspacing="0" cellpadding="0">
<tr>
<td width="7" rowspan="2"><img name="index_x" src="images/shim.gif" width="7" height="33" border="0" alt=""></td>
<td align="left"><img name="dashes" src="images/dashes.gif" width="744" height="3" border="0" alt=""></td>
<td width="10" rowspan="2"><img name="index_x" src="images/shim.gif" width="10" height="33" border="0" alt=""></td>
</tr>
<tr>
<td align="center">
<p class="footer">
Copyright © 2004, PalmSource, Inc. and its affiliates.  All rights reserved. <br>
<a href="http://www.palmsource.com/contact/">Write Us</a> | <a href="http://www.palmos.com/dev/training/">Training</a> | <a href="http://www.palmos.com/dev/support/kb/">Knowledge Base</a> | <a href="LowLevelComms_Front.html" target="_blank">Legal</a></p>
<br>
<!--BEGIN BOOK NAVIGATION-->
<p class="nav">
<A href="http://www.palmos.com/dev/support/docs/">Documentation</a>&nbsp;&nbsp;|&nbsp;&nbsp;
<a href="LowLevelCommsTOC.html">Table of Contents</a>&nbsp;&nbsp;
             |&nbsp;&nbsp;<a href="LowLevelComms_SerLink.html">&lt;&nbsp;Previous</a>&nbsp;&nbsp;
             |&nbsp;&nbsp;<a href="LowLevelComms_SlkRef.html">Next&nbsp;&gt;</a>&nbsp;&nbsp;
             |&nbsp;&nbsp;<a href="LowLevelCommsIX.html">Index</a>
</p>
</td>
</tr>
</table>
<!-- END FOOTER -->

</body>
</html>