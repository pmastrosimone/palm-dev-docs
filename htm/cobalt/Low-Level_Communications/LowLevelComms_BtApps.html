<html>
<head>
<title>(Protein) Developing Bluetooth-enabled Applications | Low-Level Communications</title> 
<link href="psi_devpubs.css" rel="stylesheet" type="text/css">

<!-- BEGIN META DATA -->
<meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
<META NAME="PSITEMPLATE" CONTENT="1006-007 PalmSource_HTML_2003 20041101">
<META NAME="GENERATOR" CONTENT="Quadralay WebWorks AutoMap 2003 for FrameMaker 8.0.6.2138">
<META NAME="LASTUPDATED" CONTENT="11/22/04 11:14:06">
<!-- END META DATA -->
</head>

<body bgcolor="#ffffff" text="#000000" leftmargin="0" topmargin="0" marginwidth="0" marginheight="0">
<a name="608590"></a>

<!-- BEGIN TOPNAV -->
<table width="100%" border="0" cellspacing="0" cellpadding="0">
<tr>
<td><img src="images/shim.gif" width="7" height="75" border="0" alt=""></td>
<td align="left"><table border="0" cellpadding="0" cellspacing="0" width="744">
<tr>
<td><img name="index_r2_c1" src="images/shim.gif" width="25" height="75" border="0" alt=""></td>
<td valign="top"><table border="0" cellpadding="0" cellspacing="0" width="96">
<tr>
<td><img name="index_r2_c4" src="images/shim.gif" width="96" height="15" border="0" alt=""></td>
</tr>
<tr>
<td><a href="http://www.palmsource.com/"><img name="ps_logo" src="images/ps_logo.gif" width="96" height="54" border="0" alt=""></a></td>
</tr>

</table>
</td>

<td><table border="0" cellpadding="0" cellspacing="0" width="30">
<td><img name="index_x" src="images/shim.gif" width="30" height="75" border="0" alt=""></td>
</table></td>

<!--BEGIN MASTHEAD-->
<td><table border="0" cellpadding="0" cellspacing="0" width="96">
<tr>
<td><img name="index_x" src="images/shim.gif" width="615" height="5" border="0" alt=""></td>
</tr>
<tr>
<td>
<!--BEGIN BOOK NAVIGATION-->
<span class="nav">
<A href="http://www.palmos.com/dev/support/docs/">Documentation</a>&nbsp;&nbsp;|&nbsp;&nbsp;
<a href="LowLevelCommsTOC.html">Table of Contents</a>&nbsp;&nbsp;
             |&nbsp;&nbsp;<a href="LowLevelComms_BtSystem.html">&lt;&nbsp;Previous</a>&nbsp;&nbsp;
             |&nbsp;&nbsp;<a href="LowLevelComms_BtExg.html">Next&nbsp;&gt;</a>&nbsp;&nbsp;
             |&nbsp;&nbsp;<a href="LowLevelCommsIX.html">Index</a>
</span>
<!--END BOOK NAVIGATION-->
</tr>
<tr>
<td>
<!--BEGIN PAGE TITLE-->
<h2 class="PageTitle">11 &nbsp;&nbsp;
Developing Bluetooth-enabled Applications</h2></td>
<!--END PAGE TITLE-->
</tr>
<tr>
<td>
<!--BEGIN BOOK TITLE-->
<p class="BookTitle">Low-Level Communications</p>
<p class="SubTitle">Exploring Palm OS&#174; </p>
<!--END BOOK TITLE-->
</td>
</tr>
<tr>
<td><img name="index_x" src="images/shim.gif" width="615" height="5" border="0" alt=""></td>
</tr>
</table>
</td>
<!--END MASTHEAD-->
</tr>
</table>
<img name="dashes" src="images/dashes.gif" width="744" height="3" border="0" alt=""></td>
</tr>
</table>
<!-- END TOPNAV -->

<table width="100%" border="0" cellspacing="0" cellpadding="0">
<tr>
<td valign="top" width="5"><img name="index_x" src="images/shim.gif" width="5" height="33" border="0" alt=""></td>

<!--BEGIN SIDETOC-->
<td valign="top" width="175">
<div id="sidetoc" valign="bottom">
<h1 class="SideTOC1-PartTab"><a href="LowLevelComms_BT_Pt.html">Part III: Bluetooth</a> </h1>
<h1 class="SideTOC1"><a href="LowLevelComms_BtApps.html">11  Developing Bluetooth-enabled Applications</a></h1>

   <h2 class="SideTOC2"><a href="#993236">
   Overview of the Bluetooth Library</a></h2>

      <h3 class="SideTOC3"><a href="#993624">
      Compatibility</a></h3>

   <h2 class="SideTOC2"><a href="#993243">
   The Management Entity</a></h2>

      <h3 class="SideTOC3"><a href="#994062">
      Opening the Library</a></h3>

      <h3 class="SideTOC3"><a href="#993246">
      Polling for Management Entity Events</a></h3>

      <h3 class="SideTOC3"><a href="#993315">
      Finding Nearby Devices</a></h3>

      <h3 class="SideTOC3"><a href="#993353">
      Creating ACL Links</a></h3>

      <h3 class="SideTOC3"><a href="#993383">
      Working With Piconets</a></h3>

      <h3 class="SideTOC3"><a href="#994268">
      Closing the Management Entity</a></h3>

   <h2 class="SideTOC2"><a href="#993416">
   Bluetooth Sockets</a></h2>

      <h3 class="SideTOC3"><a href="#993436">
      L2CAP</a></h3>

      <h3 class="SideTOC3"><a href="#993509">
      RFCOMM</a></h3>

      <h3 class="SideTOC3"><a href="#994688">
      SCO</a></h3>

   <h2 class="SideTOC2"><a href="#994207">
   BSD Sockets</a></h2>

      <h3 class="SideTOC3"><a href="#995293">
      Creating a Socket</a></h3>

      <h3 class="SideTOC3"><a href="#995358">
      Restrictions</a></h3>

   <h2 class="SideTOC2"><a href="#994239">
   Service Discovery</a></h2>

      <h3 class="SideTOC3"><a href="#995553">
      Service Records</a></h3>

   <h2 class="SideTOC2"><a href="#995465">
   Creating Persistent Services</a></h2>

   <h2 class="SideTOC2"><a href="#994773">
   Dealing with Bluetooth Shutdown</a></h2>

</div>
</td>

<td width="5">&nbsp;&nbsp;</td>
<td width="2" background="images/index_r8_c10.gif"><img src="images/shim.gif" width="2" height="75" border="0" alt=""></td>
<td width="5">&nbsp;&nbsp;</td>

<!--END SIDETOC-->

<td valign="top">

<!--BEGIN CONTENT-->
<div id="content" valign="bottom">
<p><a name="993212"> </a>Palm OS<sup>&#174;</sup> exposes Bluetooth through multiple interfaces, allowing you to choose the interface that is best suited for the task at hand. Bluetooth development is supported through <a href="LowLevelComms_Stdio_Pt.html#1000443">IOS STDIO</a> calls. Object transfer is supported through the Exchange Manager using the Bluetooth Exchange Library, which is discussed in <a href="LowLevelComms_BtExg.html#608590">Chapter 12, "Bluetooth Exchange Library Support."</a> Finally, you can program directly with the Bluetooth Library APIs, which is the subject of this section.</p>

<p><a name="993220"> </a>Regardless of which approach you take, your applications should check if the Bluetooth system is running on the device before using any Bluetooth APIs. To do so, use the code shown in <a href="LowLevelComms_BtApps.html#993222">Listing 11.1</a>:</p>
<p class="CCodeCaption">
  <a name="993222"> </a><b>Listing 11.1&nbsp;&nbsp;Making sure the device has Bluetooth support</b>
</p>

<div class="CodeRule"><hr></div><pre class="CodeBlock">
UInt32 btVersion;<a name="994304"> </a>
<a name="993223"> </a>
// Make sure Bluetooth components are installed<a name="993224"> </a>
if (FtrGet(btLibFeatureCreator, btLibFeatureVersion,<a name="993226"> </a>
					&amp;btVersion) != errNone) {<a name="993227"> </a>
	// Alert the user if it's the active application<a name="993229"> </a>
	if ((launchFlags &amp; sysAppLaunchFlagNewGlobals) &amp;&amp;<a name="993230"> </a>
		(launchFlags &amp; sysAppLaunchFlagUIApp))<a name="993231"> </a>
		FrmAlert (MissingBtComponentsAlert);<a name="993232"> </a>
	return sysErrRomIncompatible;<a name="993233"> </a>
}<a name="993234"> </a>
</pre><div class="CodeRule"><hr></div>


<h2 class="haH2">
  <a name="993236"> </a>Overview of the Bluetooth Library <a href="#608590"><span class="nav">^TOP^</span></a>
</h2>


<p><a name="995177"> </a>From a programmer's perspective, the functions of the Bluetooth library fall into six areas: management entity, sockets, service discovery, security, persistent services, and utility.</p>
<ul type="disc">
  <li><a name="995178"> </a>The management entity functions deal with the radio, baseband, and link manager parts of the Bluetooth specification. You use them to find nearby devices and to establish ACL links.
  <li><a name="993239"> </a>The socket functions enable communication with L2CAP, RFCOMM, and SDP protocols, as well as with SCO links.
  <li><a name="995276"> </a>The service discovery functions manage the local service database and query remote devices' service databases.
  <li><a name="993240"> </a>The security functions manage a set of trusted devices&#8212;devices that do not have to authenticate when they create a secure connection with the Palm OS device.
  <li><a name="995279"> </a>The persistent service functions provide a means of installing applications that run in the background and respond to inbound connections from remote devices.
  <li><a name="993241"> </a>The utility functions perform useful data conversions.
</ul>
<h3 class="hbH3">
  <a name="993624"> </a>Compatibility <a href="#608590"><span class="nav">^TOP^</span></a>
</h3>


<p><a name="993625"> </a>The entire communications architecture has changed with Palm OS Cobalt. While existing applications will continue to run, using a compatibility library, applications written to the Palm OS Cobalt and later Bluetooth need to conform to a few modest changes to the API.</p>

<h4 class="hcH4">
  <a name="993676"> </a>Deprecated Functions
</h4>

<p><a name="993628"> </a>The functions <code>BtLibRegisterManagementNotification()</code> and <code>BtLibUnregisterManagementNotification()</code> no longer exist; instead, applications read events from the Management Entity device directly by polling its file descriptor.</p>

<p><a name="993629"> </a>The <code>BtLibServicesOpen()</code>, <code>BtLibServicesClose()</code>, and <code>BtLibServicesIndicateSessionStart()</code> functions have been removed as well. Services are no longer a special case.</p>

<p><a name="993635"> </a>Additionally, the <code>BtLibDiscoverSingleDevice()</code>, <code>BtLibDiscoverMultipleDevices()</code>, and <code>BtLibGetSelectedDevices()</code> functions have been replaced by one function: <a href="LowLevelComms_BtRef.html#1014452"><code>BtLibDiscoverDevices()</code></a>.</p>

<h4 class="hcH4">
  <a name="993677"> </a>Parameter Changes
</h4>

<p><a name="993634"> </a>Functions that used to take a Bluetooth library reference number as an input parameter now require a file descriptor to one of the Management Entity, L2CAP, RFCOMM, or SDP device, depending on the specific function.</p>

<p><a name="993645"> </a>The <a href="LowLevelComms_BtRef.html#1014742"><code>BtLibOpen()</code></a> function now returns an IOS file descriptor to the Management Entity device, and <a href="LowLevelComms_BtRef.html#1098867"><code>BtLibClose()</code></a> closes that file descriptor. <code>BtLibOpen()</code> also no longer necessarily causes a radio state event; applications should not wait for a radio state event after calling <a href="LowLevelComms_BtRef.html#1014742"><code>BtLibOpen()</code></a>. If the hardware is not available, the call to <code>BtLibOpen()</code> will simply fail. Likewise, <code>BtLibOpen()</code> will no longer necessarily cause an accessibility event; if the application needs to know the accessibility state, it should call <a href="LowLevelComms_BtRef.html#1014488"><code>BtLibGetGeneralPreference()</code></a>.</p>

<p><a name="993678"> </a><a href="LowLevelComms_BtRef.html#1016661"><code>BtLibSocketCreate()</code></a> no longer has callback procedure and callback context parameters. The function now returns a file descriptor opened to an L2CAP, RFCOMM, or SDP device. <a href="LowLevelComms_BtRef.html#1016623"><code>BtLibSocketClose()</code></a> closes the file descriptor.</p>

<p><a name="993679"> </a>The <a href="LowLevelComms_BtRef.html#993850"><code>BtLibSocketRef</code></a> type is now a 32-bit value. It is a file descriptor to the underlying STREAMS device.</p>

<h4 class="hcH4">
  <a name="994083"> </a>New Functions
</h4>

<p><a name="994088"> </a>There are several new functions:</p>
<ul type="disc">
  <li><a name="994093"> </a><a href="LowLevelComms_BtRef.html#1014534"><code>BtLibGetRemoteDeviceNameSynchronous()</code></a>
  <li><a name="994098"> </a><a href="LowLevelComms_BtRef.html#1014724"><code>BtLibMEEventName()</code></a>
  <li><a name="994099"> </a><a href="LowLevelComms_BtRef.html#1016681"><code>BtLibSocketEventName()</code></a>
  <li><a name="994109"> </a><a href="LowLevelComms_BtRef.html#1014838"><code>BtLibRegisterService()</code></a>
</ul>

<h4 class="hcH4">
  <a name="993680"> </a>Events
</h4>

<p><a name="993681"> </a>Applications now obtain events by polling IOS file descriptors, instead of through a callback function. See <a href="LowLevelComms_BtApps.html#993246">"Polling for Management Entity Events"</a>.</p>

<h2 class="haH2">
  <a name="993243"> </a>The Management Entity <a href="#608590"><span class="nav">^TOP^</span></a>
</h2>


<p><a name="993244"> </a>Three basic management tasks common among Bluetooth applications are finding the Bluetooth devices in range, establishing ACL links, and working with piconets. However, in order for your code to use any of the functions that do these operations, you need to poll for events on the STREAMS devices for the relevant protocols.</p>
<h3 class="hbH3">
  <a name="994062"> </a>Opening the Library <a href="#608590"><span class="nav">^TOP^</span></a>
</h3>


<p><a name="994067"> </a>To open the Bluetooth library, use the <a href="LowLevelComms_BtRef.html#1014742"><code>BtLibOpen()</code></a> function. If this returns without error, the Bluetooth Management Entity device is open and ready to go.</p>

<p><a name="994175"> </a><code>BtLibOpen()</code> returns a file descriptor to the Management Entity. Every Management Entity file descriptor sees the same Management Entity; every program monitoring ME events receives the same events.</p>
<h3 class="hbH3">
  <a name="993246"> </a>Polling for Management Entity Events <a href="#608590"><span class="nav">^TOP^</span></a>
</h3>


<p><a name="993247"> </a>Most management calls are asynchronous. In other words, they start an operation and return before the operation actually completes. When the operation completes, the Bluetooth Library notifies the application by way of events posted on the Management Entity's event queue.</p>

<p><a name="993249"> </a>In some cases, a management function fails before starting the asynchronous operation. In this case, an event does not get sent. You can tell whether or not to expect to receive an event as a result of the call by looking at the management function's return code:</p>

<dl>
<dt><a name="993251"> </a><code>btLibErrNoError	</code></dt>
<dd><a name="993897"> </a>The operation has completed and no event will be sent.</dd>

<dt><a name="993252"> </a><code>btLibErrPending</code></dt>
<dd><a name="993898"> </a>The operation has started successfully and an appropriate event will be sent,</dd>

<dt><a name="993253"> </a><code>any other error code</code></dt>
<dd><a name="993899"> </a>The operation failed and no event will be sent.</dd>

</dl>

<p><a name="993760"> </a>You can poll for these events either by calling <a href="LowLevelComms_StdioRef.html#997909"><code>IOSPoll()</code></a> directly, or by using a PollBox. See <a href="LowLevelComms_StdioUsing.html#993291">Chapter 18, "Polling STREAMS File Descriptors,"</a> for an introduction to event polling.</p>

<p><a name="993902"> </a>As a simple example, consider the task of finding nearby devices, discussed in the next section. The callback function must respond to four events: <code>btLibManagementEventInquiryResult</code>, <code>btLibManagementEventInquiryComplete</code>, <code>btLibManagementEventInquiryCanceled</code>, and <code>btLibManagementEventRadioState</code>. The code in <a href="LowLevelComms_BtApps.html#993994">Listing 11.2</a> is a skeleton of the PollBox callback you need.</p>
<p class="CCodeCaption">
  <a name="993994"> </a><b>Listing 11.2&nbsp;&nbsp;Polling for Management Entity events using a PollBox</b>
</p>

<div class="CodeRule"><hr></div><pre class="CodeBlock">
void HandlePbxMEEvent( struct PollBox *pbx, struct pollfd *pollFd, void * ) {<a name="993912"> </a>
	status_t error;<a name="993913"> </a>
	int32_t flags;<a name="993914"> </a>
<a name="993915"> </a>
	static BtLibManagementEventType	mEvent;<a name="993916"> </a>
	static char mData[sizeof(BtLibFriendlyNameType)];<a name="993917"> </a>
	static struct strbuf ctlBuf = { sizeof(mEvent), 0, (char*)&amp;mEvent };<a name="993918"> </a>
	static struct strbuf datBuf = { sizeof(mData),  0, (char*)&amp;mData[0] };<a name="993919"> </a>
<a name="993920"> </a>
	// We must be here for a reason...<a name="993921"> </a>
<a name="993990"> </a>
	ErrFatalErrorIf(!(pollFd-&gt;revents &amp; (POLLIN|POLLERR|POLLHUP|POLLNVAL)),<a name="993922"> </a>
					"no event flag" );<a name="993985"> </a>
<a name="993923"> </a>
	// We must have the Management Entity file descriptor.<a name="993924"> </a>
	ErrFatalErrorIf( pollFd-&gt;fd != gFdME, "not the ME fd" );<a name="993925"> </a>
	ErrFatalErrorIf( pollFd-&gt;fd &lt; 0, "ME fd closed" );<a name="993926"> </a>
<a name="993927"> </a>
	// Check for error/eof from poll, read the event message.<a name="993928"> </a>
	flags = 0;<a name="993929"> </a>
	if ((pollFd-&gt;revents &amp; (POLLERR|POLLHUP|POLLNVAL)) || <a name="993930"> </a>
		IOSGetmsg(pollFd-&gt;fd, &amp;ctlBuf, &amp;datBuf, &amp;flags, &amp;error) != 0) {<a name="993931"> </a>
		PbxRemoveFd(pbx, pollFd-&gt;fd);<a name="993933"> </a>
		BtLibClose(pollFd-&gt;fd);<a name="993934"> </a>
		gFdME = -1;<a name="993935"> </a>
		return;<a name="993936"> </a>
	}<a name="993937"> </a>
<a name="993938"> </a>
	// We must have an event struct in the control part.<a name="993939"> </a>
	ErrFatalErrorIf(ctlBuf.len != sizeof(BtLibManagementEventType),<a name="993940"> </a>
					"no event struct");<a name="993986"> </a>
<a name="993941"> </a>
	// Decode the event.<a name="993942"> </a>
	<a name="993943"> </a>
	switch (mEvent.event) {<a name="993944"> </a>
		case btLibManagementEventRadioState:<a name="993945"> </a>
			// The radio state has changed.<a name="993946"> </a>
			break;<a name="993947"> </a>
	<a name="993948"> </a>
		case btLibManagementEventInquiryResult:<a name="993949"> </a>
			// A device has been found.  Save it in a list.<a name="993950"> </a>
			break;<a name="993951"> </a>
	<a name="993952"> </a>
		case btLibManagementEventInquiryComplete:<a name="993953"> </a>
			// The inquiry is finished.<a name="993954"> </a>
			break;<a name="993955"> </a>
	<a name="993956"> </a>
		case btLibManagementEventInquiryCanceled:<a name="993957"> </a>
			// The inquiry has been canceled.<a name="993958"> </a>
			break;<a name="993959"> </a>
	}<a name="993960"> </a>
}<a name="993961"> </a>
</pre><div class="CodeRule"><hr></div>


<p><a name="993288"> </a>This example includes some simple error condition checks for the PollBox callback being called with events that aren't Management Entity events.</p>

<p><a name="993999"> </a>To install this PollBox event handler, you would use code similar to that shown in <a href="LowLevelComms_BtApps.html#994000">Listing 11.3</a>.</p>
<p class="CCodeCaption">
  <a name="994000"> </a><b>Listing 11.3&nbsp;&nbsp;Installing the Management Event handler PollBox callback</b>
</p>

<div class="CodeRule"><hr></div><pre class="CodeBlock">
int32_t gFdME;<a name="994014"> </a>
<a name="994015"> </a>
error = BtLibOpen(&amp;gFdME);<a name="994016"> </a>
if (error) {<a name="994017"> </a>
	// Unable to open the Bluetooth Library.<a name="994018"> </a>
} else {<a name="994019"> </a>
	PbxAddFd(gPollBox, gFdME, POLLIN, HandlePbxMEEvent, 0);<a name="994020"> </a>
}<a name="994021"> </a>
</pre><div class="CodeRule"><hr></div>


<p><a name="993991"> </a>For a list of management events, see <a href="LowLevelComms_BtRef.html#995311">"BtLibManagementEventEnum"</a> in <a href="LowLevelComms_BtRef.html#1008891">Chapter 13, "Bluetooth Reference."</a></p>
<h3 class="hbH3">
  <a name="993315"> </a>Finding Nearby Devices <a href="#608590"><span class="nav">^TOP^</span></a>
</h3>


<p><a name="993316"> </a>There are two ways to find Bluetooth devices that are within range:</p>
<ul type="disc">
  <li><a name="993321"> </a>Use the <a href="LowLevelComms_BtRef.html#1014452"><code>BtLibDiscoverDevices()</code></a> function to find nearby devices. These functions bring up a user interface that allows the user to choose one or more devices.
  <li><a name="993330"> </a>Perform a device inquiry using <a href="LowLevelComms_BtRef.html#1016785"><code>BtLibStartInquiry()</code></a>. This is more difficult to do than using the discovery function, but provides more flexibility.
</ul>

<p><a name="993335"> </a>When you call <a href="LowLevelComms_BtRef.html#1016785"><code>BtLibStartInquiry()</code></a>, the Bluetooth Library searches for all devices in range. Whenever it finds a device, it generates a <a href="LowLevelComms_BtRef.html#995320"><code>btLibManagementEventInquiryResult</code></a> event. When the inquiry has completed, a <a href="LowLevelComms_BtRef.html#995322"><code>btLibManagementEventInquiryComplete</code></a> event is generated. To cancel the inquiry, call <a href="LowLevelComms_BtRef.html#1014416"><code>BtLibCancelInquiry()</code></a>. The <a href="LowLevelComms_BtRef.html#995324"><code>btLibManagementEventInquiryCanceled</code></a> event is generated when the cancellation succeeds.</p>
<h3 class="hbH3">
  <a name="993353"> </a>Creating ACL Links <a href="#608590"><span class="nav">^TOP^</span></a>
</h3>


<p><a name="993354"> </a>Once you have the device address of a remote device, you can attempt to create an ACL link to it using the <a href="LowLevelComms_BtRef.html#1014632"><code>BtLibLinkConnect()</code></a> function. This causes the <a href="LowLevelComms_BtRef.html#995330"><code>btLibManagementEventACLConnectOutbound</code></a> event to be generated, and the status code within that event indicates whether or not the link was successfully established.</p>

<p><a name="993368"> </a>To disconnect a link, use the <a href="LowLevelComms_BtRef.html#1014652"><code>BtLibLinkDisconnect()</code></a> function. This causes the <a href="LowLevelComms_BtRef.html#995326"><code>btLibManagementEventACLDisconnect</code></a> event to be generated. Note that the same event is generated when the remote device initiates the disconnection; the status code will indicate why the connection was terminated.</p>

<p><a name="993373"> </a>Your program must also respond to <a href="LowLevelComms_BtRef.html#995328"><code>btLibManagementEventACLConnectInbound</code></a> events that indicate that a remote device has established a link with the handheld. You can disconnect an inbound link with the <a href="LowLevelComms_BtRef.html#1014652"><code>BtLibLinkDisconnect()</code></a> function.</p>
<h3 class="hbH3">
  <a name="993383"> </a>Working With Piconets <a href="#608590"><span class="nav">^TOP^</span></a>
</h3>


<p><a name="993384"> </a>Bluetooth supports up to seven slaves in a piconet. The Bluetooth Library provides simplified APIs to create and destroy piconets.</p>

<p><a name="993385"> </a>Note that the Bluetooth 1.1 specification suggests that the upper software layers place slaves in hold or park mode while new connections are established. This isn't well&#8211;defined in the specification, and is difficult to do because of timing. The Bluetooth Library expects the radio baseband to handle piconet timing.</p>

<p><a name="993391"> </a>To create a piconet, the "master" calls <a href="LowLevelComms_BtRef.html#1014760"><code>BtLibPiconetCreate()</code></a>. Slaves can then discover the master and join the piconet, or the master can discover and connect to the slaves. The master stops advertising once the limit of seven slaves has been reached. Note that any device should be capable of acting as a slave.</p>

<p><a name="993392"> </a>The piconet can be locked to prevent additional slaves from joining. The master can still discover and add slaves, however. With the piconet locked, there is a bandwidth improvement of approximately 10%.</p>

<p><a name="993393"> </a>In the Bluetooth Library, the following functions support the management of piconets:</p>
<ul type="disc">
  <li><a name="993398"> </a><a href="LowLevelComms_BtRef.html#1014760"><code>BtLibPiconetCreate()</code></a>: create a piconet or reconfigure an existing piconet so the local device is the master.
  <li><a name="993403"> </a><a href="LowLevelComms_BtRef.html#1014782"><code>BtLibPiconetDestroy()</code></a>: destroy the piconet by disconnecting links to all devices and removing all restrictions on whether the local device is a master or a slave.
  <li><a name="993408"> </a><a href="LowLevelComms_BtRef.html#1014800"><code>BtLibPiconetLockInbound()</code></a>: prevent remote devices from creating ACL links into the piconet.
  <li><a name="993413"> </a><a href="LowLevelComms_BtRef.html#1014818"><code>BtLibPiconetUnlockInbound()</code></a>: allow additional slaves to create ACL links into the piconet.
</ul>

<p><a name="993414"> </a>Remember the following limitations of piconets: Slave-to-slave communication is not permitted. The master cannot "broadcast" to slaves.</p>
<h3 class="hbH3">
  <a name="994268"> </a>Closing the Management Entity <a href="#608590"><span class="nav">^TOP^</span></a>
</h3>


<p><a name="994269"> </a>When you're finished using the Bluetooth Library, you should call <a href="LowLevelComms_BtRef.html#1098867"><code>BtLibClose()</code></a>, passing the Management Entity's file descriptor. When you do this, and there are no longer any open ME file descriptors or open and connected L2CAP or RFCOMM file descriptors, any remaining ACL links will be disconnected.</p>

<h2 class="haH2">
  <a name="993416"> </a>Bluetooth Sockets <a href="#608590"><span class="nav">^TOP^</span></a>
</h2>


<p><a name="994635"> </a>The Bluetooth Library uses the concept of sockets to manage communication between Bluetooth devices. A socket represents a bidirectional packet-based link to a remote device. Sockets run over ACL connections. The Bluetooth library can accommodate up to 16 simultaneous sockets.</p>

<p><a name="994637"> </a>Five types of sockets are supported by the Bluetooth Library. L2CAP and RFCOMM sockets establish data channels and send and receive arbitrary data over those channels. SDP sockets allow you to query remote devices about the services those devices provide.</p>

<p><a name="993421"> </a>To send a packet of data over an L2CAP or RFCOMM socket, use the <a href="LowLevelComms_BtRef.html#1016763"><code>BtLibSocketSend()</code></a> function.</p>

<p><a name="994664"> </a>SCO links are seen as a new socket type in BtLib. You can use <a href="LowLevelComms_BtRef.html#1016661"><code>BtLibSocketCreate()</code></a> and <a href="LowLevelComms_BtRef.html#1016623"><code>BtLibSocketClose()</code></a> to establish and break SCO links; however, once they're established, all data transfer is managed in hardware, so there is nothing further for software to do with them.</p>

<p><a name="994641"> </a>BNEP sockets are only used within the Bluetooth system and are generally not useful to developers. Sending data over a BNEP socket using <code>BtLibSocketSend()</code> must involve sending valid ethernet frames containing a 14-byte ethernet header followed by data.</p>

<div><hr>
  <a name="993780"> </a> <b>NOTE: </b> Versions of Palm OS prior to 6.0 required that the data buffer remain unchanged until the <a href="LowLevelComms_BtRef.html#995410"><code>btLibSocketEventSendComplete</code></a> event arrives. This is no longer the case; you can immediately release or reuse the buffer after <a href="LowLevelComms_BtRef.html#1016763"><code>BtLibSocketSend()</code></a><span style="color: #000000;  font-style: normal; font-weight: normal; text-decoration: none; text-transform: none; vertical-align: baseline"> returns.</span>
<hr>
</div>

<p><a name="993434"> </a>When incoming data arrives, the <a href="LowLevelComms_StdioRef.html#995453"><code>IOSGetmsg()</code></a> function returns a message with no control part and a data part containing the received data.</p>
<h3 class="hbH3">
  <a name="993436"> </a>L2CAP <a href="#608590"><span class="nav">^TOP^</span></a>
</h3>


<p><a name="993437"> </a>L2CAP sockets don't allow for flow control.</p>

<h4 class="hcH4">
  <a name="993439"> </a>Establishing Inbound L2CAP Connections
</h4>

<p><a name="993440"> </a>To set up for inbound L2CAP connections, you call the following:</p>
<ol type="1">
  <li value="1"><a name="993445"> </a><a href="LowLevelComms_BtRef.html#1016661"><code>BtLibSocketCreate()</code></a>: create an L2CAP socket.
  <li value="2"><a name="993450"> </a><a href="LowLevelComms_BtRef.html#1016723"><code>BtLibSocketListen()</code></a>: set up an L2CAP socket as a listener.
  <li value="3"><a name="993455"> </a><a href="LowLevelComms_BtRef.html#1015130"><code>BtLibSdpServiceRecordCreate()</code></a>: allocate a memory chunk that represents an SDP service record.
  <li value="4"><a name="993460"> </a><a href="LowLevelComms_BtRef.html#1015374"><code>BtLibSdpServiceRecordSetAttributesForSocket()</code></a>: initialize an SDP memory record so it can represent the newly-created L2CAP listener socket as a service
  <li value="5"><a name="993465"> </a><a href="LowLevelComms_BtRef.html#1015452"><code>BtLibSdpServiceRecordStartAdvertising()</code></a>: make an SDP memory record representing a local SDP service record visible to remote devices.
</ol>

<p><a name="993470"> </a>When you get a <a href="LowLevelComms_BtRef.html#995400"><code>btLibSocketEventConnectRequest</code></a> event, you need to respond with a call to <a href="LowLevelComms_BtRef.html#1016743"><code>BtLibSocketRespondToConnection()</code></a>. You then receive a <a href="LowLevelComms_BtRef.html#995404"><code>btLibSocketEventConnectedInbound</code></a> event with an inbound socket with which you can send and receive data.</p>

<p><a name="993479"> </a>The listening socket remains open and will notify you of further connection attempts. In other words, you can use a single L2CAP listening socket to spawn several inbound sockets. You cannot close the listening socket until after you close its inbound sockets.</p>

<h4 class="hcH4">
  <a name="993481"> </a>Establishing Outbound L2CAP Connections
</h4>

<p><a name="993482"> </a>To establish an outbound L2CAP connection, you first establish an ACL link to the remote device. Then you call:</p>
<ol type="1">
  <li value="1"><a name="993487"> </a><a href="LowLevelComms_BtRef.html#1016661"><code>BtLibSocketCreate()</code></a>: create an SDP socket.
  <li value="2"><a name="993492"> </a><a href="LowLevelComms_BtRef.html#1014950"><code>BtLibSdpGetPsmByUuid()</code></a>: get an available L2CAP PSM using SDP.
  <li value="3"><a name="993497"> </a><a href="LowLevelComms_BtRef.html#1016623"><code>BtLibSocketClose()</code></a>: close the SDP socket.
  <li value="4"><a name="993502"> </a><a href="LowLevelComms_BtRef.html#1016661"><code>BtLibSocketCreate()</code></a>: create an L2CAP socket.
  <li value="5"><a name="993507"> </a><a href="LowLevelComms_BtRef.html#1016641"><code>BtLibSocketConnect()</code></a>: create an outbound L2CAP connection.
</ol>
<h3 class="hbH3">
  <a name="993509"> </a>RFCOMM <a href="#608590"><span class="nav">^TOP^</span></a>
</h3>


<p><a name="993510"> </a>RFCOMM emulates a serial connection. It is used when using the Serial Manager API to perform Bluetooth communications, as well as by the Bluetooth Exchange Library.</p>

<p><a name="993511"> </a>When using RFCOMM, you can only have one inbound connection per listener socket. Flow control uses a "credit" system: you need to advance a credit to the far end before you can receive a data packet.</p>

<p><a name="993512"> </a>RFCOMM defines the notions of <b>server</b> and <b>client</b>. A server uses SDP to advertise its existence and listens for inbound connections. A client creates an outbound RFCOMM connection to a server.</p>

<h4 class="hcH4">
  <a name="993514"> </a>Establishing Inbound RFCOMM Connections
</h4>

<p><a name="993515"> </a>To set up for inbound RFCOMM connections, call the following:</p>
<ol type="1">
  <li value="1"><a name="993520"> </a><a href="LowLevelComms_BtRef.html#1016661"><code>BtLibSocketCreate()</code></a>: create an RFCOMM socket.
  <li value="2"><a name="993525"> </a><a href="LowLevelComms_BtRef.html#1016723"><code>BtLibSocketListen()</code></a>: set up the RFCOMM socket as a listener.
  <li value="3"><a name="993530"> </a><a href="LowLevelComms_BtRef.html#1015130"><code>BtLibSdpServiceRecordCreate()</code></a>: allocate a memory chunk that represents an SDP service record.
  <li value="4"><a name="993535"> </a><a href="LowLevelComms_BtRef.html#1015374"><code>BtLibSdpServiceRecordSetAttributesForSocket()</code></a>: initialize an SDP memory record so it can represent the newly-created RFCOMM listener socket as a service
  <li value="5"><a name="993540"> </a><a href="LowLevelComms_BtRef.html#1015452"><code>BtLibSdpServiceRecordStartAdvertising()</code></a>: make the SDP memory record representing your local SDP service record visible to remote devices.
</ol>

<p><a name="993545"> </a>When you get a <a href="LowLevelComms_BtRef.html#995400"><code>btLibSocketEventConnectRequest</code></a> event, you need to respond with a call to <a href="LowLevelComms_BtRef.html#1016743"><code>BtLibSocketRespondToConnection()</code></a>. You then receive a <a href="LowLevelComms_BtRef.html#995404"><code>btLibSocketEventConnectedInbound</code></a> event with an inbound socket with which you can send and receive data. To send data, use the <a href="LowLevelComms_BtRef.html#1016763"><code>BtLibSocketSend()</code></a> function. When incoming data arrives, the <a href="LowLevelComms_StdioRef.html#995453"><code>IOSGetmsg()</code></a> function returns a message with no control part and a data part containing the received data.</p>

<p><a name="993562"> </a>The listening socket will not notify you of further connection attempts. In other words, a single RFCOMM listening socket can only spawn a single inbound RFCOMM socket. You cannot close the listening socket until after you close its inbound socket.</p>

<h4 class="hcH4">
  <a name="993564"> </a>Establishing Outbound RFCOMM Connections
</h4>

<p><a name="993565"> </a>To establish an outbound RFCOMM connection, you first establish an ACL link to the remote device. Then you call:</p>
<ol type="1">
  <li value="1"><a name="993570"> </a><a href="LowLevelComms_BtRef.html#1016661"><code>BtLibSocketCreate()</code></a>: create an SDP socket.
  <li value="2"><a name="993575"> </a><a href="LowLevelComms_BtRef.html#1015010"><code>BtLibSdpGetServerChannelByUuid()</code></a>: get an available RFCOMM server channel using SDP.
  <li value="3"><a name="993580"> </a><a href="LowLevelComms_BtRef.html#1016661"><code>BtLibSocketCreate()</code></a>: create an RFCOMM socket.
  <li value="4"><a name="993585"> </a><a href="LowLevelComms_BtRef.html#1016641"><code>BtLibSocketConnect()</code></a>: Create an outbound RFCOMM connection.
</ol>

<h4 class="hcH4">
  <a name="994151"> </a>Using Serial-on-L2CAP and Serial-on-RFCOMM
</h4>

<p><a name="994152"> </a>The Serial-on-L2CAP and Serial-on-RFCOMM modules, whose names are <code>btModSerL2cName</code> and <code>btModSerRfcName</code> in <code>BtLibTypes.h</code>, are STREAMS modules that can be pushed onto an L2CAP or RFCOMM file descriptor.</p>

<p><a name="994161"> </a>These modules can be pushed onto the file descriptor either before or after connecting the socket. If pushed before connecting, <code>BtLibSocketXXX()</code> functions and events will be transparent to the module until the connection is established. In particular, the connection event will be visible to the application.</p>

<p><a name="994162"> </a>Once the socket is connected, or if the module is pushed after establishing the connection, then only pure data can be read or written by the application; the module handles things like flow control for you.</p>

<p><a name="994163"> </a>A disconnect event appears as an error condition from <a href="LowLevelComms_StdioRef.html#994787"><code>IOSRead()</code></a> or <a href="LowLevelComms_StdioRef.html#994296"><code>IOSWrite()</code></a>. Closing the file descriptor will disconnect the socket if it's connected.</p>
<h3 class="hbH3">
  <a name="994688"> </a>SCO <a href="#608590"><span class="nav">^TOP^</span></a>
</h3>


<p><a name="994697"> </a>SCO sockets are used to transmit audio between a Palm OS smart phone and a hands-free kit or headset. The only operations that can be performed on SCO sockets are to create, connect, and close them. Everything else is done in hardware.</p>

<h2 class="haH2">
  <a name="994207"> </a>BSD Sockets <a href="#608590"><span class="nav">^TOP^</span></a>
</h2>


<p><a name="994232"> </a>You can use the standard BSD Sockets API to perform Bluetooth communications using the RFCOMM protocol. Use the <a href="LowLevelComms_BtRef.html#993897"><code>sockaddr_bth</code></a> structure to define a Bluetooth device address when using the BSD Sockets API.</p>
<h3 class="hbH3">
  <a name="995293"> </a>Creating a Socket <a href="#608590"><span class="nav">^TOP^</span></a>
</h3>


<p><a name="995302"> </a>You obtain a Bluetooth RFCOMM sotcket by specifying the address family <code>AF_BTH</code>, the socket type <code>SOCK_STREAM</code>, and the protocol <code>BTHPROTO_RFCOMM</code> when calling <code>socket()</code>:</p>

<div class="CodeRule"><hr></div><pre class="CodeBlock">
myBtSocket = socket( AF_BTH, SOCK_STREAM, BTHPROTO_RFCOMM );<a name="995331"> </a>
</pre><div class="CodeRule"><hr></div>

<h3 class="hbH3">
  <a name="995358"> </a>Restrictions <a href="#608590"><span class="nav">^TOP^</span></a>
</h3>


<p><a name="995362"> </a>A listening socket can have no backlog, and can only accept a single incoming connection, after which it becomes dead (meaning that it doesn't listen for incoming connections anymore). In addition, once <code>accept()</code> has been called and has returned a newly connected socket, the listening socket must not be closed until the accepted connection is closed first.</p>
<p class="CCodeCaption">
  <a name="995373"> </a><b>Listing 11.4&nbsp;&nbsp;Listening for an incoming connection</b>
</p>

<div class="CodeRule"><hr></div><pre class="CodeBlock">
listenerSocket = socket();<a name="995385"> </a>
bind(listenerSocket);<a name="995386"> </a>
listen(listenerSocket);<a name="995387"> </a>
select(listenerSocket);<a name="995388"> </a>
dataSocket = accept(listenerSocket);<a name="995389"> </a>
...<a name="995390"> </a>
close(dataSocket);<a name="995391"> </a>
close(listenerSocket);<a name="995376"> </a>
</pre><div class="CodeRule"><hr></div>


<p><a name="995454"> </a>If the application wishes to listen for further connections, it needs to explicitly start listening again by calling <code>listen()</code>.</p>

<p><a name="995292"> </a>For more information about Palm OS support for the BSD Sockets API, see <a href="LowLevelComms_Sockets_Pt.html#1000443">Part IV, "Networking and Sockets." </a></p>

<h2 class="haH2">
  <a name="994239"> </a>Service Discovery <a href="#608590"><span class="nav">^TOP^</span></a>
</h2>


<p><a name="995467"> </a>The service discovery functions are used to create and advertise service records to remote devices, and to discover services available on remote devices.</p>

<div><hr>
  <a name="995662"> </a> <b>NOTE: </b> While Palm OS Cobalt, version 6.1 supports service discovery, it does not support the full Service Discovery Application Profile, since there is no service browser provided.
<hr>
</div>
<h3 class="hbH3">
  <a name="995553"> </a>Service Records <a href="#608590"><span class="nav">^TOP^</span></a>
</h3>


<p><a name="995484"> </a>A service record is a sequence of service attributes. A service attribute consists of two components: an attribute ID and an attribute value.</p>

<p><a name="995504"> </a>Universal attributes are those service attributes whose definitions are common to all service records. Among them is the ServiceClassIDList, which is a list of <b>service class</b> identifiers. Every service record must have a ServiceClassIDList.</p>

<p><a name="995524"> </a>An attribute ID is a 16-bit unsigned integer that distinguishes each service attribute from other service attributes within a service record. The attribute ID also identifies the semantics of the associated attribute value.</p>

<p><a name="995535"> </a>An attribute value is a data element whose meaning is determined by the corresponding attribute ID and the service class of the service record in which the attribute is contained.</p>

<p><a name="995536"> </a>A data element is a typed data representation consisting of two fields: a header field and a data field. The header field, in turn, is composed of two parts: a type descriptor and a size descriptor. The data is a sequence of bytes whose length is specified by the size descriptor and whose meaning is partially specified by the type descriptor.</p>

<p><a name="995483"> </a>To fully understand SDP service records, how they are encoded, interpreted, and so forth, see the Service Discovery Protocol section in Volume 1 of the <i>Bluetooth Specification</i>, version 1.2.</p>

<div><hr>
  <a name="995473"> </a> <b>NOTE: </b> Only one outstanding query at a time is allowed per SDP socket.
<hr>
</div>

<h2 class="haH2">
  <a name="995465"> </a>Creating Persistent Services <a href="#608590"><span class="nav">^TOP^</span></a>
</h2>


<p><a name="994711"> </a>Applications that support Bluetooth can register themselves as persistent Bluetooth services, that are automatically started in a thread in the System Process when other Bluetooth enabled devices connect to them.</p>

<div><hr>
  <a name="994974"> </a> <b>NOTE: </b> For examples of Bluetooth persistent service applications, see the <code>samples/Bluetooth/BtHeadset</code> and <code>samples/Bluetooth/BtHandsfree</code> directories in the SDK. The code snippets shown here are adapted from these examples, but the complete source code is a valuable resource you should review.
<hr>
</div>

<h4 class="hcH4">
  <a name="994765"> </a>Registering a Persistent Service
</h4>

<p><a name="994719"> </a>To register as a persistent service, an application must register the service at boot and system reset time, as shown in <a href="LowLevelComms_BtApps.html#994722">Listing 11.5</a>.</p>
<p class="CCodeCaption">
  <a name="994722"> </a><b>Listing 11.5&nbsp;&nbsp;Registering a persistent service</b>
</p>

<div class="CodeRule"><hr></div><pre class="CodeBlock">
uint32_t PilotMain(uint16_t cmd, MemPtr cmdPBP, uint16_t launchFlags) {<a name="994723"> </a>
	BtLibServiceRegistrationParamsType params;<a name="994741"> </a>
	status_t error = errNone;<a name="994742"> </a>
	...<a name="994731"> </a>
	switch(cmd) {<a name="994732"> </a>
		case sysLaunchCmdBoot:<a name="994733"> </a>
		case sysLaunchCmdSystemReset:<a name="994734"> </a>
			params.appCodeRscId = sysResIDDefault;<a name="994740"> </a>
			params.appType = myAppRscType;<a name="994745"> </a>
			params.appCreator = myAppCreator;<a name="994750"> </a>
			params.stackSize = 5000;<a name="994755"> </a>
			params.protocol = btLibRfCommProtocol;<a name="994756"> </a>
			params.pushSerialModule = false;<a name="994757"> </a>
			params.execAsNormalApp = false;<a name="994758"> </a>
			error = BtLibRegisterService(&amp;params);<a name="994759"> </a>
			break;<a name="994735"> </a>
		...<a name="994736"> </a>
	}<a name="994737"> </a>
	return error;<a name="994738"> </a>
}<a name="994739"> </a>
</pre><div class="CodeRule"><hr></div>


<h4 class="hcH4">
  <a name="994764"> </a>Describing a Persistent Service
</h4>

<p><a name="994772"> </a>The Bluetooth system may shut down or reinitialize itself at any time for a variety of reasons: the on/auto/off preference may be set to "off,", the device may be powered off, the radio hardware may be physically detached, or some application may close its last Bluetooth file descriptor that had been used to communicate with remote devices. To support this, the service application needs to implement the <a href="LowLevelComms_BtRef.html#1396067"><code>sysBtLaunchCmdDescribeService</code></a> launch code to fill out a <a href="LowLevelComms_BtRef.html#993627"><code>BtLibServiceDescriptionType</code></a> structure. This is demonstrated in <a href="LowLevelComms_BtApps.html#994782">Listing 11.6</a>.</p>
<p class="CCodeCaption">
  <a name="994782"> </a><b>Listing 11.6&nbsp;&nbsp;Describing a Bluetooth persistent service</b>
</p>

<div class="CodeRule"><hr></div><pre class="CodeBlock">
		case sysBtLaunchCmdDescribeService:<a name="994783"> </a>
			int size;<a name="994791"> </a>
			MemHandle theResHdl;<a name="994792"> </a>
			MemPtr theResPtr;<a name="994793"> </a>
			<a name="994794"> </a>
			// Describe our service for the Bluetooth panel services view.<a name="994795"> </a>
			((BtLibServiceDescriptionType*)cmdPBP)-&gt;flags = 0;<a name="994796"> </a>
<a name="994797"> </a>
			// Get the profile service name str<a name="994798"> </a>
			theResHdl = DmGetResource(myDmOpenRef, (DmResourceType) strRsc,<a name="994799"> </a>
						infoNameStrRscId);<a name="994866"> </a>
			theResPtr = MemHandleLock(theResHdl);<a name="994800"> </a>
			size = strlen(theResPtr) + 1;<a name="994801"> </a>
			if ((((BtLibServiceDescriptionType*)cmdPBP)-&gt;nameP = MemPtrNew(size))<a name="994802"> </a>
						== NULL ) {<a name="994868"> </a>
				return btLibErrOutOfMemory;<a name="994803"> </a>
			}<a name="994804"> </a>
			MemMove(((BtLibServiceDescriptionType*)cmdPBP)-&gt;nameP, theResPtr,<a name="994805"> </a>
						size );<a name="994869"> </a>
			MemHandleUnlock(theResHdl);<a name="994806"> </a>
			DmReleaseResource(theResHdl);<a name="994807"> </a>
			<a name="994808"> </a>
			// Get the profile service description str<a name="994809"> </a>
			theResHdl = DmGetResource(myDmOpenRef, (DmResourceType) strRsc,<a name="994810"> </a>
						infoDescStrRscId);<a name="994872"> </a>
			theResPtr = MemHandleLock(theResHdl);<a name="994811"> </a>
			size = strlen(theResPtr) + 1;<a name="994812"> </a>
			if ((((BtLibServiceDescriptionType*)cmdPBP)-&gt;descriptionP =<a name="994813"> </a>
						MemPtrNew( size )) == NULL ) {<a name="994874"> </a>
				return btLibErrOutOfMemory;<a name="994814"> </a>
			}<a name="994815"> </a>
			MemMove(((BtLibServiceDescriptionType*)cmdPBP)-&gt;descriptionP,<a name="994816"> </a>
						theResPtr, size);<a name="994875"> </a>
			MemHandleUnlock(theResHdl);<a name="994817"> </a>
			DmReleaseResource(theResHdl);<a name="994818"> </a>
			break;<a name="994786"> </a>
</pre><div class="CodeRule"><hr></div>


<p><a name="994877"> </a>The example loads the strings from resources, copies them into the <a href="LowLevelComms_BtRef.html#993627"><code>BtLibServiceDescriptionType</code></a> structure, and releases the resources.</p>

<h4 class="hcH4">
  <a name="994895"> </a>Providing Advanced Configuration Options
</h4>

<p><a name="994896"> </a>If the persistent service needs to provide the ability for the user to configure it, it should implement the <a href="LowLevelComms_BtRef.html#1384553"><code>sysBtLaunchCmdDoServiceUI</code></a> launch code, which is sent when the user clicks the "Advanced" button in the Bluetooth services view. In response to this launch code, the application can present user interface to configure the service.</p>

<h4 class="hcH4">
  <a name="994900"> </a>Preparing the Service to Listen for Incoming Connections
</h4>

<p><a name="994903"> </a>When the system is ready for the service application to begin listening for incoming connections, it sends the application the <a href="LowLevelComms_BtRef.html#1384572"><code>sysBtLaunchCmdPrepareService</code></a> launch code with a <a href="LowLevelComms_BtRef.html#993641"><code>BtLibServicePreparationParamsType</code></a> structure as input.</p>

<p><a name="994910"> </a>This structure includes a handle to an empty SDP service record, which the service application needs to fill out to describe the offered serice, as well as the file descriptor for the socket on which the service application should listen for incoming connections.</p>
<p class="CCodeCaption">
  <a name="994911"> </a><b>Listing 11.7&nbsp;&nbsp;Preparing the service</b>
</p>

<div class="CodeRule"><hr></div><pre class="CodeBlock">
		BtLibServicePreparationParamsType *params =<a name="994948"> </a>
					(BtLibServicePreparationParamsType *) cmdPBP;<a name="994972"> </a>
		BtLibSdpUuidType gGWSdpUUIDList[3];<a name="994950"> </a>
		status_t error;<a name="994951"> </a>
		...<a name="994961"> </a>
		case sysBtLaunchCmdPrepareService:<a name="994912"> </a>
			BtLibSdpUuidInitialize(gGWSdpUUIDList[0],<a name="994973"> </a>
					btLibSdpUUID_SC_HEADSET_AUDIO_GATEWAY, btLibUuidSize16);<a name="994975"> </a>
			BtLibSdpUuidInitialize(gGWSdpUUIDList[1],<a name="994977"> </a>
					btLibSdpUUID_SC_GENERIC_AUDIO, btLibUuidSize16);<a name="994978"> </a>
<a name="994979"> </a>
			error = BtLibSdpServiceRecordSetAttributesForSocket(<a name="994980"> </a>
						params-&gt;fdListener,<a name="994981"> </a>
						gGWSdpUUIDList,<a name="994982"> </a>
						2,<a name="994983"> </a>
						HEADSET_GW_SERVICE_NAME,<a name="994984"> </a>
						strlen(HEADSET_GW_SERVICE_NAME);<a name="994985"> </a>
						params-&gt;serviceRecH<a name="994986"> </a>
						);<a name="994987"> </a>
			break;<a name="994919"> </a>
</pre><div class="CodeRule"><hr></div>


<p><a name="994988"> </a>The code snippet in <a href="LowLevelComms_BtApps.html#994911">Listing 11.7</a> comes from the BtHeadset sample program. It supports the audio gateway and generic audio services, for which it builds UUIDs using the <a href="LowLevelComms_BtRef.html#995467"><code>BtLibSdpUuidInitialize()</code></a> macro and inserts them into an array. It then sets the attributes on the listener socket to watch for attempts to connect to those particular services, and sets the name of the service, by calling <a href="LowLevelComms_BtRef.html#1015374"><code>BtLibSdpServiceRecordSetAttributesForSocket()</code></a>.</p>

<h4 class="hcH4">
  <a name="995016"> </a>Executing the Service
</h4>

<p><a name="995017"> </a>When a connection attempt arrives at the listener socket, Palm OS sends the <a href="LowLevelComms_BtRef.html#1394969"><code>sysBtLaunchCmdExecuteService</code></a> launch code to the service application. This sublaunch occurs in a thread within the System Process, and the application should not exit until the service finishes the transaction.</p>
<p class="CCodeCaption">
  <a name="995025"> </a><b>Listing 11.8&nbsp;&nbsp;Processing the service transaction</b>
</p>

<div class="CodeRule"><hr></div><pre class="CodeBlock">
	BtLibServiceExecutionParamsType *params;<a name="995030"> </a>
	...<a name="995051"> </a>
		case sysBtLaunchCmdExecuteService:<a name="995068"> </a>
			params = (BtLibServiceExecutionParamsType *) cmdPBP;<a name="995082"> </a>
			if (AppStart() == errNone) {<a name="995083"> </a>
				...<a name="995101"> </a>
				/* perform the transaction */<a name="995107"> </a>
				...<a name="995108"> </a>
			}<a name="995106"> </a>
			AppStop();<a name="995105"> </a>
			break;<a name="995073"> </a>
	...<a name="995078"> </a>
</pre><div class="CodeRule"><hr></div>


<p><a name="995084"> </a>When the service begins running, it needs to initialize itself by opening its database, creating a PollBox to process events, open the Bluetooth Management Entity file descriptor, and so forth. In this example, this is all done by the <code>AppStart()</code> function.</p>

<p><a name="995114"> </a>Then the application can run an event loop to process incoming data and respond to that data, as well as to provide progress user interface and so forth.</p>

<p><a name="995109"> </a>Once the transaction is finished, the service application must close the data socket, which is specified by the <code>fdData</code> field in the <a href="LowLevelComms_BtRef.html#1391829"><code>BtLibServiceExecutionParamsType</code></a> structure, before exiting.</p>

<h2 class="haH2">
  <a name="994773"> </a>Dealing with Bluetooth Shutdown <a href="#608590"><span class="nav">^TOP^</span></a>
</h2>


<p><a name="994209"> </a>The Bluetooth system shuts down when the user changes the on/off preference or the radio hardware is physically detached. When this happens, all opened Bluetooth file descriptors start to produce errors.</p>

<p><a name="994213"> </a>When an application detects <code>M_ERROR</code> on any Bluetooth file descriptor, it must immediately close all its Bluetooth file descriptors.</p>
&nbsp;<br>
</div>
<!--END CONTENT-->

</td>
<td width="5">&nbsp;&nbsp;</td>
</tr>

</table>

<!-- BEGIN FOOTER -->
<table width="100%" border="0" cellspacing="0" cellpadding="0">
<tr>
<td width="7" rowspan="2"><img name="index_x" src="images/shim.gif" width="7" height="33" border="0" alt=""></td>
<td align="left"><img name="dashes" src="images/dashes.gif" width="744" height="3" border="0" alt=""></td>
<td width="10" rowspan="2"><img name="index_x" src="images/shim.gif" width="10" height="33" border="0" alt=""></td>
</tr>
<tr>
<td align="center">
<p class="footer">
Copyright  2004, PalmSource, Inc. and its affiliates.  All rights reserved. <br>
<a href="http://www.palmsource.com/contact/">Write Us</a> | <a href="http://www.palmos.com/dev/training/">Training</a> | <a href="http://www.palmos.com/dev/support/kb/">Knowledge Base</a> | <a href="LowLevelComms_Front.html" target="_blank">Legal</a></p>
<br>
<!--BEGIN BOOK NAVIGATION-->
<p class="nav">
<A href="http://www.palmos.com/dev/support/docs/">Documentation</a>&nbsp;&nbsp;|&nbsp;&nbsp;
<a href="LowLevelCommsTOC.html">Table of Contents</a>&nbsp;&nbsp;
             |&nbsp;&nbsp;<a href="LowLevelComms_BtSystem.html">&lt;&nbsp;Previous</a>&nbsp;&nbsp;
             |&nbsp;&nbsp;<a href="LowLevelComms_BtExg.html">Next&nbsp;&gt;</a>&nbsp;&nbsp;
             |&nbsp;&nbsp;<a href="LowLevelCommsIX.html">Index</a>
</p>
</td>
</tr>
</table>
<!-- END FOOTER -->

</body>
</html>