<html>
<head>
<title>(Protein) Sockets &amp; Network Support Reference | Low-Level Communications</title> 
<link href="psi_devpubs.css" rel="stylesheet" type="text/css">

<!-- BEGIN META DATA -->
<meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
<META NAME="PSITEMPLATE" CONTENT="1006-007 PalmSource_HTML_2003 20041101">
<META NAME="GENERATOR" CONTENT="Quadralay WebWorks AutoMap 2003 for FrameMaker 8.0.6.2138">
<META NAME="LASTUPDATED" CONTENT="11/22/04 11:14:17">
<!-- END META DATA -->
</head>

<body bgcolor="#ffffff" text="#000000" leftmargin="0" topmargin="0" marginwidth="0" marginheight="0">
<a name="608590"></a>

<!-- BEGIN TOPNAV -->
<table width="100%" border="0" cellspacing="0" cellpadding="0">
<tr>
<td><img src="images/shim.gif" width="7" height="75" border="0" alt=""></td>
<td align="left"><table border="0" cellpadding="0" cellspacing="0" width="744">
<tr>
<td><img name="index_r2_c1" src="images/shim.gif" width="25" height="75" border="0" alt=""></td>
<td valign="top"><table border="0" cellpadding="0" cellspacing="0" width="96">
<tr>
<td><img name="index_r2_c4" src="images/shim.gif" width="96" height="15" border="0" alt=""></td>
</tr>
<tr>
<td><a href="http://www.palmsource.com/"><img name="ps_logo" src="images/ps_logo.gif" width="96" height="54" border="0" alt=""></a></td>
</tr>

</table>
</td>

<td><table border="0" cellpadding="0" cellspacing="0" width="30">
<td><img name="index_x" src="images/shim.gif" width="30" height="75" border="0" alt=""></td>
</table></td>

<!--BEGIN MASTHEAD-->
<td><table border="0" cellpadding="0" cellspacing="0" width="96">
<tr>
<td><img name="index_x" src="images/shim.gif" width="615" height="5" border="0" alt=""></td>
</tr>
<tr>
<td>
<!--BEGIN BOOK NAVIGATION-->
<span class="nav">
<A href="http://www.palmos.com/dev/support/docs/">Documentation</a>&nbsp;&nbsp;|&nbsp;&nbsp;
<a href="LowLevelCommsTOC.html">Table of Contents</a>&nbsp;&nbsp;
             |&nbsp;&nbsp;<a href="LowLevelComms_SockIntro.html">&lt;&nbsp;Previous</a>&nbsp;&nbsp;
             |&nbsp;&nbsp;<a href="LowLevelComms_WiFi_Pt.html">Next&nbsp;&gt;</a>&nbsp;&nbsp;
             |&nbsp;&nbsp;<a href="LowLevelCommsIX.html">Index</a>
</span>
<!--END BOOK NAVIGATION-->
</tr>
<tr>
<td>
<!--BEGIN PAGE TITLE-->
<h2 class="PageTitle">15 &nbsp;&nbsp;
Sockets &amp; Network Support Reference</h2></td>
<!--END PAGE TITLE-->
</tr>
<tr>
<td>
<!--BEGIN BOOK TITLE-->
<p class="BookTitle">Low-Level Communications</p>
<p class="SubTitle">Exploring Palm OS&#174; </p>
<!--END BOOK TITLE-->
</td>
</tr>
<tr>
<td><img name="index_x" src="images/shim.gif" width="615" height="5" border="0" alt=""></td>
</tr>
</table>
</td>
<!--END MASTHEAD-->
</tr>
</table>
<img name="dashes" src="images/dashes.gif" width="744" height="3" border="0" alt=""></td>
</tr>
</table>
<!-- END TOPNAV -->

<table width="100%" border="0" cellspacing="0" cellpadding="0">
<tr>
<td valign="top" width="5"><img name="index_x" src="images/shim.gif" width="5" height="33" border="0" alt=""></td>

<!--BEGIN SIDETOC-->
<td valign="top" width="175">
<div id="sidetoc" valign="bottom">
<h1 class="SideTOC1-PartTab"><a href="LowLevelComms_Sockets_Pt.html">Part IV: Networking and Sockets</a> </h1>
<h1 class="SideTOC1"><a href="LowLevelComms_SockRef.html">15  Sockets &amp; Network Support Reference</a></h1>

   <h2 class="SideTOC2"><a href="#994959">
   Overview</a></h2>

   <h2 class="SideTOC2"><a href="#993208">
   Structures and Types</a></h2>

      <h3 class="SideTOC3"><a href="#997693">
      addrinfo</a></h3>

      <h3 class="SideTOC3"><a href="#997725">
      hostent</a></h3>

      <h3 class="SideTOC3"><a href="#997751">
      netent</a></h3>

      <h3 class="SideTOC3"><a href="#997775">
      protoent</a></h3>

      <h3 class="SideTOC3"><a href="#997797">
      servent</a></h3>

      <h3 class="SideTOC3"><a href="#993321">
      sockaddr</a></h3>

      <h3 class="SideTOC3"><a href="#995128">
      sockaddr_in</a></h3>

      <h3 class="SideTOC3"><a href="#993390">
      socklen_t</a></h3>

   <h2 class="SideTOC2"><a href="#993404">
   Functions and Macros</a></h2>

      <h3 class="SideTOC3"><a href="#993407">
      accept</a></h3>

      <h3 class="SideTOC3"><a href="#993450">
      bind</a></h3>

      <h3 class="SideTOC3"><a href="#993490">
      connect</a></h3>

      <h3 class="SideTOC3"><a href="#998170">
      endhostent</a></h3>

      <h3 class="SideTOC3"><a href="#998198">
      endnetent</a></h3>

      <h3 class="SideTOC3"><a href="#998226">
      endprotoent</a></h3>

      <h3 class="SideTOC3"><a href="#998254">
      endservent</a></h3>

      <h3 class="SideTOC3"><a href="#998282">
      freeaddrinfo</a></h3>

      <h3 class="SideTOC3"><a href="#998306">
      freehostent</a></h3>

      <h3 class="SideTOC3"><a href="#998340">
      gai_strerror</a></h3>

      <h3 class="SideTOC3"><a href="#998363">
      getaddrinfo</a></h3>

      <h3 class="SideTOC3"><a href="#998400">
      gethostbyaddr</a></h3>

      <h3 class="SideTOC3"><a href="#998428">
      gethostbyname</a></h3>

      <h3 class="SideTOC3"><a href="#998452">
      gethostbyname2</a></h3>

      <h3 class="SideTOC3"><a href="#998478">
      gethostent</a></h3>

      <h3 class="SideTOC3"><a href="#998506">
      getipnodebyaddr</a></h3>

      <h3 class="SideTOC3"><a href="#998544">
      getipnodebyname</a></h3>

      <h3 class="SideTOC3"><a href="#998582">
      getnameinfo</a></h3>

      <h3 class="SideTOC3"><a href="#998619">
      getnetbyaddr</a></h3>

      <h3 class="SideTOC3"><a href="#998645">
      getnetbyname</a></h3>

      <h3 class="SideTOC3"><a href="#998669">
      getnetent</a></h3>

      <h3 class="SideTOC3"><a href="#993533">
      getpeername</a></h3>

      <h3 class="SideTOC3"><a href="#993573">
      getsockname</a></h3>

      <h3 class="SideTOC3"><a href="#999729">
      getprotobyname</a></h3>

      <h3 class="SideTOC3"><a href="#999753">
      getprotobynumber</a></h3>

      <h3 class="SideTOC3"><a href="#999777">
      getprotoent</a></h3>

      <h3 class="SideTOC3"><a href="#999805">
      getservbyname</a></h3>

      <h3 class="SideTOC3"><a href="#999831">
      getservbyport</a></h3>

      <h3 class="SideTOC3"><a href="#999857">
      getservent</a></h3>

      <h3 class="SideTOC3"><a href="#993607">
      getsockopt</a></h3>

      <h3 class="SideTOC3"><a href="#1000283">
      hstrerror</a></h3>

      <h3 class="SideTOC3"><a href="#995179">
      htonl</a></h3>

      <h3 class="SideTOC3"><a href="#995209">
      htons</a></h3>

      <h3 class="SideTOC3"><a href="#997103">
      inet_addr</a></h3>

      <h3 class="SideTOC3"><a href="#997131">
      inet_aton</a></h3>

      <h3 class="SideTOC3"><a href="#997158">
      inet_lnaof</a></h3>

      <h3 class="SideTOC3"><a href="#997186">
      inet_makeaddr</a></h3>

      <h3 class="SideTOC3"><a href="#997213">
      inet_netof</a></h3>

      <h3 class="SideTOC3"><a href="#997241">
      inet_network</a></h3>

      <h3 class="SideTOC3"><a href="#997269">
      inet_ntoa</a></h3>

      <h3 class="SideTOC3"><a href="#997293">
      inet_ntop</a></h3>

      <h3 class="SideTOC3"><a href="#997323">
      inet_pton</a></h3>

      <h3 class="SideTOC3"><a href="#997674">
      listen</a></h3>

      <h3 class="SideTOC3"><a href="#996637">
      ntohl</a></h3>

      <h3 class="SideTOC3"><a href="#996667">
      ntohs</a></h3>

      <h3 class="SideTOC3"><a href="#996633">
      recv</a></h3>

      <h3 class="SideTOC3"><a href="#993723">
      recvfrom</a></h3>

      <h3 class="SideTOC3"><a href="#993766">
      recvmsg</a></h3>

      <h3 class="SideTOC3"><a href="#1020910">
      select</a></h3>

      <h3 class="SideTOC3"><a href="#993803">
      send</a></h3>

      <h3 class="SideTOC3"><a href="#993842">
      sendmsg</a></h3>

      <h3 class="SideTOC3"><a href="#993879">
      sendto</a></h3>

      <h3 class="SideTOC3"><a href="#1000366">
      sethostent</a></h3>

      <h3 class="SideTOC3"><a href="#1000399">
      setnetent</a></h3>

      <h3 class="SideTOC3"><a href="#1000430">
      setprotoent</a></h3>

      <h3 class="SideTOC3"><a href="#1000460">
      setservent</a></h3>

      <h3 class="SideTOC3"><a href="#993920">
      setsockopt</a></h3>

      <h3 class="SideTOC3"><a href="#993967">
      shutdown</a></h3>

      <h3 class="SideTOC3"><a href="#993999">
      socket</a></h3>

</div>
</td>

<td width="5">&nbsp;&nbsp;</td>
<td width="2" background="images/index_r8_c10.gif"><img src="images/shim.gif" width="2" height="75" border="0" alt=""></td>
<td width="5">&nbsp;&nbsp;</td>

<!--END SIDETOC-->

<td valign="top">

<!--BEGIN CONTENT-->
<div id="content" valign="bottom">
<h2 class="haH2">
  <a name="994959"> </a>Overview <a href="#608590"><span class="nav">^TOP^</span></a>
</h2>


<p><a name="995077"> </a>The structures, types, and functions described in this chapter are provided in several header files, including:</p>

<dl>
<dt><a name="994960"> </a><code><code>sys/socket.h</code></code></dt>
<dd><a name="995087"> </a>Defines functions and types for sending and receiving data using sockets, as well as for listening for and opening connections to remote devices.</dd>

<dt><a name="994961"> </a><code><code>posix/arpa/inet.h</code></code></dt>
<dd><a name="995093"> </a>Defines functions used for manipulating Internet addresses.</dd>

<dt><a name="994962"> </a><code><code>posix/netinet/in.h</code></code></dt>
<dd><a name="995094"> </a>Defines structures and functions used for converting between host and network addresses.</dd>

<dt><a name="995100"> </a><code>posix/netdb.h</code></dt>
<dd><a name="995105"> </a>Defines structures and functions used for performing network database operations, particularly Domain Name Resolution operations.</dd>

<dt><a name="1031885"> </a><code>posix/sys/select.h</code></dt>
<dd><a name="1031898"> </a>Provides the <a href="LowLevelComms_SockRef.html#1020910"><code>select()</code></a> function, which provides a means of detecting the readiness state of file desriptors.</dd>

</dl>

<p><a name="994963"> </a>Each structure, type, or function indicates the header file in which it is defined.</p>

<h2 class="haH2">
  <a name="993208"> </a>Structures and Types <a href="#608590"><span class="nav">^TOP^</span></a>
</h2>


<h3 class="hbH3">
  <a name="997693"> </a>addrinfo Struct <a href="#608590"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="997695"> </a>Purpose 
</h4>

<p><a name="997696"> </a>This structure contains the information obtained from the address.</p>
<h4>
  <a name="997697"> </a>Declared In 
</h4>
<code>posix/netdb.h<a name="997698"> </a></code><h4>
  <a name="997699"> </a>Prototype 
</h4>
<pre class="proto"><a name="997700"></a>struct addrinfo {
   int ai_flags;
   int ai_family;
   int ai_socktype;
   int ai_protocol;
   size_t ai_addrlen;
   char *ai_canonname;
   struct sockaddr *ai_addr;
   struct addrinfo *ai_next;
}
</pre>
<h4>
  <a name="997701"> </a>Fields 
</h4>

<dl>
<dt><a name="997702"> </a><code>ai_flags</code></dt>
<dd><a name="997703"> </a><code>AI_PASSIVE</code>, <code>AI_CANONNAME</code>, <code>AI_NUMERICHOST</code>.</dd>

<dt><a name="997704"> </a><code>ai_family</code></dt>
<dd><a name="997705"> </a><code>PF_xxx</code>.</dd>

<dt><a name="997706"> </a><code>ai_socktype</code></dt>
<dd><a name="997707"> </a><code>SOCK_xxx</code>.</dd>

<dt><a name="997708"> </a><code>ai_protocol</code></dt>
<dd><a name="997709"> </a>0 or <code>IPPROTO_xxx</code> for IPv4 and IPv6.</dd>

<dt><a name="997710"> </a><code>ai_addrlen</code></dt>
<dd><a name="997711"> </a>The length of <code>ai_addr</code>.</dd>

<dt><a name="997712"> </a><code>ai_canonname</code></dt>
<dd><a name="997713"> </a>Canonical name for hostname.</dd>

<dt><a name="997714"> </a><code>ai_addr</code></dt>
<dd><a name="997715"> </a>Binary address.</dd>

<dt><a name="997716"> </a><code>ai_next</code></dt>
<dd><a name="997717"> </a>Next structure in linked list.</dd>

</dl>
<h4>
  <a name="997718"> </a>Comments 
</h4>

<p><a name="997719"> </a>All addresses are supplied in host order and returned in network order (suitable for use in system calls).</p>

<h3 class="hbH3">
  <a name="997725"> </a>hostent Struct <a href="#608590"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="997727"> </a>Purpose 
</h4>

<p><a name="997728"> </a>This structure contains either the information obtained from the name server or database entries supplied by the system.</p>
<h4>
  <a name="997729"> </a>Declared In 
</h4>
<code>posix/netdb.h<a name="997730"> </a></code><h4>
  <a name="997731"> </a>Prototype 
</h4>
<pre class="proto"><a name="997732"></a>struct hostent {
   char *h_name;
   char **h_aliases;
   int h_addrtype;
   int h_length;
   char **h_addr_list;
}
</pre>
<h4>
  <a name="997733"> </a>Fields 
</h4>

<dl>
<dt><a name="997734"> </a><code>h_name</code></dt>
<dd><a name="997735"> </a>Official name of the host.</dd>

<dt><a name="997736"> </a><code>h_aliases</code></dt>
<dd><a name="997737"> </a>A list of alternative names for the host.</dd>

<dt><a name="997738"> </a><code>h_addrtype</code></dt>
<dd><a name="997739"> </a>Host address type.</dd>

<dt><a name="997740"> </a><code>h_length</code></dt>
<dd><a name="997741"> </a>The length, in bytes, of the address.</dd>

<dt><a name="997742"> </a><code>h_addr_list</code></dt>
<dd><a name="997743"> </a>List of addresses from name server.</dd>

</dl>
<h4>
  <a name="997744"> </a>Comments 
</h4>

<p><a name="997745"> </a>All addresses are supplied in host order and returned in network order (suitable for use in system calls).</p>

<h3 class="hbH3">
  <a name="997751"> </a>netent Struct <a href="#608590"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="997753"> </a>Purpose 
</h4>

<p><a name="997754"> </a>This structure contains the information obtained from the network.</p>
<h4>
  <a name="997755"> </a>Declared In 
</h4>
<code>posix/netdb.h<a name="997756"> </a></code><h4>
  <a name="997757"> </a>Prototype 
</h4>
<pre class="proto"><a name="997758"></a>struct netent {
   char *n_name;
   char **n_aliases;
   int n_addrtype;
   unsigned long n_net;
}
</pre>
<h4>
  <a name="997759"> </a>Fields 
</h4>

<dl>
<dt><a name="997760"> </a><code>n_name</code></dt>
<dd><a name="997761"> </a>Official name of the network.</dd>

<dt><a name="997762"> </a><code>n_aliases</code></dt>
<dd><a name="997763"> </a>A list of alternative names for the network.</dd>

<dt><a name="997764"> </a><code>n_addrtype</code></dt>
<dd><a name="997765"> </a>Network address type.</dd>

<dt><a name="997766"> </a><code>n_net</code></dt>
<dd><a name="997767"> </a>The network number.</dd>

</dl>
<h4>
  <a name="997768"> </a>Comments 
</h4>

<p><a name="997769"> </a>All addresses are supplied in host order and returned in network order (suitable for use in system calls).</p>

<h3 class="hbH3">
  <a name="997775"> </a>protoent Struct <a href="#608590"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="997777"> </a>Purpose 
</h4>

<p><a name="997778"> </a>This structure contains the information obtained from the protocol.</p>
<h4>
  <a name="997779"> </a>Declared In 
</h4>
<code>posix/netdb.h<a name="997780"> </a></code><h4>
  <a name="997781"> </a>Prototype 
</h4>
<pre class="proto"><a name="997782"></a>struct protoent {
   char *p_name;
   char **p_aliases;
   int p_proto;
}
</pre>
<h4>
  <a name="997783"> </a>Fields 
</h4>

<dl>
<dt><a name="997784"> </a><code>p_name</code></dt>
<dd><a name="997785"> </a>Official name of the protocol.</dd>

<dt><a name="997786"> </a><code>p_aliases</code></dt>
<dd><a name="997787"> </a>A list of alternative names for the protocol.</dd>

<dt><a name="997788"> </a><code>p_proto</code></dt>
<dd><a name="997789"> </a>The protocol number.</dd>

</dl>
<h4>
  <a name="997790"> </a>Comments 
</h4>

<p><a name="997791"> </a>All addresses are supplied in host order and returned in network order (suitable for use in system calls).</p>

<h3 class="hbH3">
  <a name="997797"> </a>servent Struct <a href="#608590"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="997799"> </a>Purpose 
</h4>

<p><a name="997800"> </a>This structure contains the information obtained from the service.</p>
<h4>
  <a name="997801"> </a>Declared In 
</h4>
<code>posix/netdb.h<a name="997802"> </a></code><h4>
  <a name="997803"> </a>Prototype 
</h4>
<pre class="proto"><a name="997804"></a>struct servent {
   char *s_name;
   char **s_aliases;
   int s_port;
   char *s_proto;
}
</pre>
<h4>
  <a name="997805"> </a>Fields 
</h4>

<dl>
<dt><a name="997806"> </a><code>s_name</code></dt>
<dd><a name="997807"> </a>Official name of the service.</dd>

<dt><a name="997808"> </a><code>s_aliases</code></dt>
<dd><a name="997809"> </a>A list of alternative names for the service.</dd>

<dt><a name="997810"> </a><code>s_port</code></dt>
<dd><a name="997811"> </a>The port number.</dd>

<dt><a name="997812"> </a><code>s_proto</code></dt>
<dd><a name="997813"> </a>The protocol to use.</dd>

</dl>
<h4>
  <a name="997814"> </a>Comments 
</h4>

<p><a name="997815"> </a>All addresses are supplied in host order and returned in network order (suitable for use in system calls).</p>

<h3 class="hbH3">
  <a name="993321"> </a>sockaddr Struct <a href="#608590"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="993323"> </a>Purpose 
</h4>

<p><a name="993324"> </a>Defines a structure used by the kernel to store most addresses.</p>
<h4>
  <a name="993325"> </a>Declared In 
</h4>
<code>posix/sys/socket.h<a name="993326"> </a></code><h4>
  <a name="993327"> </a>Prototype 
</h4>
<pre class="proto"><a name="993328"></a>struct sockaddr {
   sa_family_t sa_family;
   char sa_data[14];
}
</pre>
<h4>
  <a name="993329"> </a>Fields 
</h4>

<dl>
<dt><a name="993330"> </a><code>sa_family</code></dt>
<dd><a name="993331"> </a>The address family.</dd>

<dt><a name="993332"> </a><code>sa_data</code></dt>
<dd><a name="993333"> </a>The address value.</dd>

</dl>

<h3 class="hbH3">
  <a name="995128"> </a>sockaddr_in Struct <a href="#608590"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="995130"> </a>Purpose 
</h4>

<p><a name="995131"> </a>Defines a structure used to store Internet addresses.</p>
<h4>
  <a name="995132"> </a>Declared In 
</h4>
<code>posix/netinet/in.h<a name="995133"> </a></code><h4>
  <a name="995134"> </a>Prototype 
</h4>
<pre class="proto"><a name="995135"></a>struct sockaddr_in {
</pre>
<pre class="proto"><a name="995136"></a>   sa_family_t sin_family;
   in_port_t sin_port;
   struct in_addr sin_addr;
   uint8_t sin_zero[8];
}
</pre>
<h4>
  <a name="995137"> </a>Fields 
</h4>

<dl>
<dt><a name="995138"> </a><code>sin_family</code></dt>
<dd><a name="995139"> </a><code>AF_INET</code>. </dd>

<dt><a name="995140"> </a><code>sin_port</code></dt>
<dd><a name="995141"> </a>The port number.</dd>

<dt><a name="995142"> </a><code>sin_addr</code></dt>
<dd><a name="995143"> </a>The IP address.</dd>

<dt><a name="995144"> </a><code>sin_zero</code></dt>
<dd><a name="995145"> </a>The address value; must be initialized to zero.</dd>

</dl>

<h3 class="hbH3">
  <a name="993390"> </a>socklen_t Typedef <a href="#608590"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="993392"> </a>Purpose 
</h4>

<p><a name="993393"> </a>A data type used to represent the size in bytes of socket related data.</p>
<h4>
  <a name="993394"> </a>Declared In 
</h4>
<code>posix/sys/socket.h<a name="993395"> </a></code><h4>
  <a name="993396"> </a>Prototype 
</h4>
<pre class="proto"><a name="993397"></a>typedef unsigned int socklen_t


</pre>

<h2 class="haH2">
  <a name="993404"> </a>Functions and Macros <a href="#608590"><span class="nav">^TOP^</span></a>
</h2>


<h3 class="hbH3">
  <a name="993407"> </a>accept Function <a href="#608590"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="993409"> </a>Purpose 
</h4>

<p><a name="993411"> </a>Accepts a connection on a socket by extracting the first connection request on the queue of pending connections, creating a new socket with the same properties of <code class="par">sock</code> and allocating a new file descriptor for the socket.</p>
<h4>
  <a name="993412"> </a>Declared In 
</h4>
<code>posix/sys/socket.h<a name="993413"> </a></code><h4>
  <a name="993414"> </a>Prototype 
</h4>
<pre class="proto"><a name="993415"></a>int accept (
   int <code class="par">sock</code>,
   struct sockaddr *<code class="par">addr</code>,
   socklen_t *<code class="par">addrlen</code>
)
</pre>
<h4>
  <a name="993416"> </a>Parameters 
</h4>

<dl>
<dt><a name="993417"> </a><code>&rarr;  <i>sock</i></code></dt>
<dd><a name="993418"> </a>A socket that has been created with <code>socket()</code>, bound to an address with <code>bind()</code>, and listening for connections after a <code>listen()</code>.</dd>

<dt><a name="993419"> </a><code>&larr;  <i>addr</i></code></dt>
<dd><a name="993420"> </a>A result parameter that is filled in with the source address of the connecting entity, as known to the communications layer.</dd>

<dt><a name="993421"> </a><code>&harr;  <i>addrlen</i></code></dt>
<dd><a name="993422"> </a>Initially contains the amount of space pointed to by <code class="par">addr</code>; on return, it contains the actual length (in bytes) of the address returned.</dd>

</dl>
<h4>
  <a name="993423"> </a>Returns 
</h4>

<p><a name="993424"> </a>Returns a non-negative integer that is a descriptor for the accepted socket. Otherwise, -1 is returned and the global variable <code>errno</code> is set to indicate the error.</p>
<h4>
  <a name="1020903"> </a>Comments 
</h4>

<p><a name="1020904"> </a>This function is used to accept a connection when a remote system attempts to connect to a socket on which you have previously called <code>listen()</code>.</p>
<h4>
  <a name="993431"> </a>See Also 
</h4>

<p><a name="993447"> </a><a href="LowLevelComms_SockRef.html#993450"><code>bind()</code></a>, <a href="LowLevelComms_SockRef.html#993490"><code>connect()</code></a>, <a href="LowLevelComms_SockRef.html#997674"><code>listen()</code></a>, <a href="LowLevelComms_SockRef.html#1020910"><code>select()</code></a>, <a href="LowLevelComms_SockRef.html#993999"><code>socket()</code></a></p>

<h3 class="hbH3">
  <a name="993450"> </a>bind Function <a href="#608590"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="993452"> </a>Purpose 
</h4>

<p><a name="993454"> </a>Assigns a name to an unnamed socket.</p>
<h4>
  <a name="993455"> </a>Declared In 
</h4>
<code>posix/sys/socket.h<a name="993456"> </a></code><h4>
  <a name="993457"> </a>Prototype 
</h4>
<pre class="proto"><a name="993458"></a>int bind (
   int <code class="par">sock</code>,
   const struct sockaddr *<code class="par">addr</code>,
   socklen_t <code class="par">addrlen</code>
)
</pre>
<h4>
  <a name="993459"> </a>Parameters 
</h4>

<dl>
<dt><a name="993460"> </a><code>&rarr;  <i>sock</i></code></dt>
<dd><a name="993461"> </a>A socket that has been created with <code>socket()</code> that exists in a namespace but has no name defined.</dd>

<dt><a name="993462"> </a><code>&larr;  <i>addr</i></code></dt>
<dd><a name="993463"> </a>A result parameter that is filled in with the source address of the connecting entity, as known to the communications layer.</dd>

<dt><a name="993464"> </a><code>&harr;  <i>addrlen</i></code></dt>
<dd><a name="993465"> </a>Initially contains the amount of space pointed to by <code class="par">addr</code>; on return, it contains the actual length (in bytes) of the address returned.</dd>

</dl>
<h4>
  <a name="993466"> </a>Returns 
</h4>

<p><a name="993467"> </a>Returns zero (0) if the bind is successful. Otherwise, -1 is returned and the global variable <code>errno</code> is set to indicate the error.</p>
<h4>
  <a name="993474"> </a>See Also 
</h4>

<p><a name="993487"> </a><a href="LowLevelComms_SockRef.html#993490"><code>connect()</code></a>, <a href="LowLevelComms_SockRef.html#993573"><code>getsockname()</code></a>, <a href="LowLevelComms_SockRef.html#997674"><code>listen()</code></a>, <a href="LowLevelComms_SockRef.html#993999"><code>socket()</code></a></p>

<h3 class="hbH3">
  <a name="993490"> </a>connect Function <a href="#608590"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="993492"> </a>Purpose 
</h4>

<p><a name="993494"> </a>Initiates a connection on a socket.</p>
<h4>
  <a name="993495"> </a>Declared In 
</h4>
<code>posix/sys/socket.h<a name="993496"> </a></code><h4>
  <a name="993497"> </a>Prototype 
</h4>
<pre class="proto"><a name="993498"></a>int connect (
   int <code class="par">sock</code>,
   const struct sockaddr *<code class="par">addr</code>,
   socklen_t <code class="par">addrlen</code>
)
</pre>
<h4>
  <a name="993499"> </a>Parameters 
</h4>

<dl>
<dt><a name="993500"> </a><code>&rarr;  <i>sock</i></code></dt>
<dd><a name="993501"> </a>A socket.</dd>

<dt><a name="993502"> </a><code>&larr;  <i>addr</i></code></dt>
<dd><a name="993503"> </a>A result parameter that is filled in with the source address of the connecting entity, as known to the communications layer.</dd>

<dt><a name="993504"> </a><code>&harr;  <i>addrlen</i></code></dt>
<dd><a name="993505"> </a>Initially contains the amount of space pointed to by <code class="par">addr</code>; on return, it contains the actual length (in bytes) of the address returned.</dd>

</dl>
<h4>
  <a name="993506"> </a>Returns 
</h4>

<p><a name="993507"> </a>Returns zero (0) if the connection or binding is successful. Otherwise, -1 is returned and the global variable <code>errno</code> is set to indicate the error.</p>
<h4>
  <a name="993514"> </a>See Also 
</h4>

<p><a name="993527"> </a><a href="LowLevelComms_SockRef.html#993407"><code>accept()</code></a>, <a href="LowLevelComms_SockRef.html#993573"><code>getsockname()</code></a>, <a href="LowLevelComms_SockRef.html#993607"><code>getsockopt()</code></a>, <a href="LowLevelComms_SockRef.html#1020910"><code>select()</code></a>, <a href="LowLevelComms_SockRef.html#993999"><code>socket()</code></a></p>

<h3 class="hbH3">
  <a name="998170"> </a>endhostent Function <a href="#608590"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="998172"> </a>Purpose 
</h4>

<p><a name="998174"> </a>Closes the TCP connection.</p>
<h4>
  <a name="998175"> </a>Declared In 
</h4>
<code>posix/netdb.h<a name="998176"> </a></code><h4>
  <a name="998177"> </a>Prototype 
</h4>
<pre class="proto"><a name="998178"></a>void endhostent (
   void
)
</pre>
<h4>
  <a name="1021094"> </a>Parameters 
</h4>

<p><a name="1021101"> </a>None.</p>
<h4>
  <a name="1021102"> </a>Returns 
</h4>

<p><a name="1023665"> </a>Nothing.</p>

<h3 class="hbH3">
  <a name="998198"> </a>endnetent Function <a href="#608590"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="998200"> </a>Purpose 
</h4>

<p><a name="998202"> </a>Closes the connection to the database, releasing any open file descriptor.</p>
<h4>
  <a name="998203"> </a>Declared In 
</h4>
<code>posix/netdb.h<a name="998204"> </a></code><h4>
  <a name="998205"> </a>Prototype 
</h4>
<pre class="proto"><a name="998206"></a>void endnetent (
   void
)
</pre>
<h4>
  <a name="1024009"> </a>Parameters 
</h4>

<p><a name="1024010"> </a>None.</p>
<h4>
  <a name="1024011"> </a>Returns 
</h4>

<p><a name="1024012"> </a>Nothing.</p>

<h3 class="hbH3">
  <a name="998226"> </a>endprotoent Function <a href="#608590"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="998228"> </a>Purpose 
</h4>

<p><a name="998230"> </a>Closes the connection to the database, releasing any open file descriptor.</p>
<h4>
  <a name="998231"> </a>Declared In 
</h4>
<code>posix/netdb.h<a name="998232"> </a></code><h4>
  <a name="998233"> </a>Prototype 
</h4>
<pre class="proto"><a name="998234"></a>void endprotoent (
   void
)
</pre>
<h4>
  <a name="1024027"> </a>Parameters 
</h4>

<p><a name="1024028"> </a>None.</p>
<h4>
  <a name="1024029"> </a>Returns 
</h4>

<p><a name="1024030"> </a>Nothing.</p>

<h3 class="hbH3">
  <a name="998254"> </a>endservent Function <a href="#608590"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="998256"> </a>Purpose 
</h4>

<p><a name="998258"> </a>Closes the connection to the database, releasing any open file descriptor.</p>
<h4>
  <a name="998259"> </a>Declared In 
</h4>
<code>posix/netdb.h<a name="998260"> </a></code><h4>
  <a name="998261"> </a>Prototype 
</h4>
<pre class="proto"><a name="998262"></a>void endservent (
   void
)
</pre>
<h4>
  <a name="1024042"> </a>Parameters 
</h4>

<p><a name="1024043"> </a>None.</p>
<h4>
  <a name="1024044"> </a>Returns 
</h4>

<p><a name="1024045"> </a>Nothing.</p>

<h3 class="hbH3">
  <a name="998282"> </a>freeaddrinfo Function <a href="#608590"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="998284"> </a>Purpose 
</h4>

<p><a name="998286"> </a>Returns the socket address structures and canonical node name strings pointed to by the <code>addrinfo</code> structures.</p>
<h4>
  <a name="998287"> </a>Declared In 
</h4>
<code>posix/netdb.h<a name="998288"> </a></code><h4>
  <a name="998289"> </a>Prototype 
</h4>
<pre class="proto"><a name="998290"></a>void freeaddrinfo (
   struct addrinfo *<code class="par">ai</code>
)
</pre>
<h4>
  <a name="998291"> </a>Parameters 
</h4>

<dl>
<dt><a name="998292"> </a><code>&rarr;  <i>ai</i></code></dt>
<dd><a name="998293"> </a>The <code>addrinfo</code> structure pointed to by the <code class="par">ai</code> argument is freed, along with any dynamic storage pointed to by the structure. This operation is repeated until a <code>NULL</code> <code>ai_next</code> pointer is encountered.</dd>

</dl>
<h4>
  <a name="1024060"> </a>Returns 
</h4>

<p><a name="1024061"> </a>Nothing.</p>

<h3 class="hbH3">
  <a name="998306"> </a>freehostent Function <a href="#608590"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="998308"> </a>Purpose 
</h4>

<p><a name="998310"> </a>Releases the dynamically allocated memory of the <code>hostent</code> structure.</p>
<h4>
  <a name="998320"> </a>Declared In 
</h4>
<code>posix/netdb.h<a name="998321"> </a></code><h4>
  <a name="998322"> </a>Prototype 
</h4>
<pre class="proto"><a name="998323"></a>void freehostent (
   struct hostent *<code class="par">ip</code>
)
</pre>
<h4>
  <a name="998324"> </a>Parameters 
</h4>

<dl>
<dt><a name="998325"> </a><code>&rarr;  <i>ip</i></code></dt>
<dd><a name="998326"> </a>A pointer to an object of the <code>hostent</code> structure.</dd>

</dl>
<h4>
  <a name="1013343"> </a>Returns 
</h4>

<p><a name="1013344"> </a>Returns a pointer to an object of the <code>hostent</code> structure.</p>
<h4>
  <a name="998331"> </a>Compatibility 
</h4>

<p><a name="998333"> </a>This function is a Palm OS extension (not present in C99 or Unix).</p>

<h3 class="hbH3">
  <a name="998340"> </a>gai_strerror Function <a href="#608590"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="998342"> </a>Purpose 
</h4>

<p><a name="998343"> </a>Aids applications in printing error messages based on the <code>EAI_xxx</code> codes.</p>
<h4>
  <a name="998344"> </a>Declared In 
</h4>
<code>posix/netdb.h<a name="998345"> </a></code><h4>
  <a name="998346"> </a>Prototype 
</h4>
<pre class="proto"><a name="998347"></a>const char *gai_strerror (
   int <code class="par">ecode</code>
)
</pre>
<h4>
  <a name="998348"> </a>Parameters 
</h4>

<dl>
<dt><a name="998349"> </a><code>&rarr;  <i>ecode</i></code></dt>
<dd><a name="998350"> </a>An <code>EAI_xxx</code> code, such as <code>EAI_ADDRFAMILY</code>.</dd>

</dl>
<h4>
  <a name="998351"> </a>Returns 
</h4>

<p><a name="998352"> </a>Returns a pointer to a string whose contents indicate an unknown error.</p>

<h3 class="hbH3">
  <a name="998363"> </a>getaddrinfo Function <a href="#608590"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="998365"> </a>Purpose 
</h4>

<p><a name="998367"> </a>Protocol-independent nodename-to-address translation.</p>
<h4>
  <a name="998368"> </a>Declared In 
</h4>
<code>posix/netdb.h<a name="998369"> </a></code><h4>
  <a name="998370"> </a>Prototype 
</h4>
<pre class="proto"><a name="998371"></a>int getaddrinfo (
   const char *<code class="par">nodename</code>,
   const char *<code class="par">servname</code>,
   const struct addrinfo *<code class="par">hints</code>,
   struct addrinfo **<code class="par">res</code>
)
</pre>
<h4>
  <a name="998372"> </a>Parameters 
</h4>

<dl>
<dt><a name="998373"> </a><code>&rarr;  <i>nodename</i></code></dt>
<dd><a name="998374"> </a>A pointer to null-terminated strings or <code>NULL</code>.</dd>

<dt><a name="998375"> </a><code>&rarr;  <i>servname</i></code></dt>
<dd><a name="998376"> </a>A pointer to null-terminated strings or <code>NULL</code>.</dd>

<dt><a name="998377"> </a><code>&rarr;  <i>hints</i></code></dt>
<dd><a name="998378"> </a>Hints concerning the type of socket that the caller supports.</dd>

<dt><a name="998379"> </a><code>&larr;  <i>res</i></code></dt>
<dd><a name="998380"> </a>A pointer to a linked list of one or more <code>addrinfo</code> structures.</dd>

</dl>
<h4>
  <a name="998381"> </a>Returns 
</h4>

<p><a name="998382"> </a>Returns a set of socket addresses and associated information to be used in creating a socket with which to address the specified service.</p>
<h4>
  <a name="998383"> </a>Comments 
</h4>

<p><a name="998384"> </a>One or both of the <code class="par">nodename</code> and <code class="par">servname</code> parameters must be a non-<code>NULL</code> pointer.</p>

<p><a name="998385"> </a>If <code class="par">nodename</code> is not <code>NULL</code>, the requested service location is named by <code class="par">nodename</code>; otherwise, the requested service location is local to the caller. If <code class="par">servname</code> is <code>NULL</code>, the call returns network-level addresses for the specified <code class="par">nodename</code>. If <code class="par">servname</code> is not <code>NULL</code>, it is a null-terminated character string identifying the requested service.</p>
<h4>
  <a name="998390"> </a>See Also 
</h4>

<p><a name="998397"> </a><a href="LowLevelComms_SockRef.html#998428"><code>gethostbyname()</code></a>, <a href="LowLevelComms_SockRef.html#999805"><code>getservbyname()</code></a></p>

<h3 class="hbH3">
  <a name="998400"> </a>gethostbyaddr Function <a href="#608590"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="998402"> </a>Purpose 
</h4>

<p><a name="998404"> </a>Searches for the specified host in the current domain and its parents unless the name ends in a dot.</p>
<h4>
  <a name="998405"> </a>Declared In 
</h4>
<code>posix/netdb.h<a name="998406"> </a></code><h4>
  <a name="998407"> </a>Prototype 
</h4>
<pre class="proto"><a name="998408"></a>struct hostent *gethostbyaddr (
   const char *<code class="par">addr</code>,
   int <code class="par">len</code>,
   int <code class="par">type</code>
)
</pre>
<h4>
  <a name="998409"> </a>Parameters 
</h4>

<dl>
<dt><a name="998410"> </a><code>&rarr;  <i>addr</i></code></dt>
<dd><a name="998411"> </a>Host address type.</dd>

<dt><a name="998412"> </a><code>&rarr;  <i>len</i></code></dt>
<dd><a name="998413"> </a>The length, in bytes, of the address.</dd>

<dt><a name="998414"> </a><code>&rarr;  <i>type</i></code></dt>
<dd><a name="998415"> </a>A named constant that indicates the naming scheme under which the lookup is performed. Must be specified as <code>AF_INET</code>.</dd>

</dl>
<h4>
  <a name="998416"> </a>Returns 
</h4>

<p><a name="998417"> </a>Returns a pointer to an object of the <code>hostent</code> structure, describing an Internet host referenced by address.</p>

<h3 class="hbH3">
  <a name="998428"> </a>gethostbyname Function <a href="#608590"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="998430"> </a>Purpose 
</h4>

<p><a name="998432"> </a>Searches for the specified host in the current domain and its parents unless the name ends in a dot.</p>
<h4>
  <a name="998433"> </a>Declared In 
</h4>
<code>posix/netdb.h<a name="998434"> </a></code><h4>
  <a name="998435"> </a>Prototype 
</h4>
<pre class="proto"><a name="998436"></a>struct hostent *gethostbyname (
   const char *<code class="par">name</code>
)
</pre>
<h4>
  <a name="998437"> </a>Parameters 
</h4>

<dl>
<dt><a name="998438"> </a><code>&rarr;  <i>name</i></code></dt>
<dd><a name="998439"> </a>Official name of the host.</dd>

</dl>
<h4>
  <a name="998440"> </a>Returns 
</h4>

<p><a name="998441"> </a>Returns a pointer to an object of the <code>hostent</code> structure, describing an Internet host referenced by name.</p>

<h3 class="hbH3">
  <a name="998452"> </a>gethostbyname2 Function <a href="#608590"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="998454"> </a>Purpose 
</h4>

<p><a name="998455"> </a>An evolution of <code>gethostbyname()</code> that allows lookups in address families other than <code>AF_INET</code>.</p>
<h4>
  <a name="998456"> </a>Declared In 
</h4>
<code>posix/netdb.h<a name="998457"> </a></code><h4>
  <a name="998458"> </a>Prototype 
</h4>
<pre class="proto"><a name="998459"></a>struct hostent *gethostbyname2 (
   const char *<code class="par">name</code>,
   int <code class="par">af</code>
)
</pre>
<h4>
  <a name="998460"> </a>Parameters 
</h4>

<dl>
<dt><a name="998461"> </a><code>&rarr;  <i>name</i></code></dt>
<dd><a name="998462"> </a>Official name of the host.</dd>

<dt><a name="998463"> </a><code>&rarr;  <i>af</i></code></dt>
<dd><a name="998464"> </a>Must be specified as <code>AF_INET</code> or <code>AF_INET6</code>.</dd>

</dl>
<h4>
  <a name="998465"> </a>Returns 
</h4>

<p><a name="998466"> </a>Returns a pointer to an object of the <code>hostent</code> structure, describing an Internet host referenced by name.</p>
<h4>
  <a name="998469"> </a>Compatibility 
</h4>

<p><a name="998471"> </a>This function is a Palm OS extension (not present in C99 or Unix).</p>

<h3 class="hbH3">
  <a name="998478"> </a>gethostent Function <a href="#608590"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="998480"> </a>Purpose 
</h4>

<p><a name="998482"> </a>Reads the next entry in the database, opening and closing a connection to the database as necessary.</p>
<h4>
  <a name="998483"> </a>Declared In 
</h4>
<code>posix/netdb.h<a name="998484"> </a></code><h4>
  <a name="998485"> </a>Prototype 
</h4>
<pre class="proto"><a name="998486"></a>struct hostent *gethostent (
   void
)
</pre>
<h4>
  <a name="1016370"> </a>Parameters 
</h4>

<p><a name="1016371"> </a>None.</p>
<h4>
  <a name="998494"> </a>Returns 
</h4>

<p><a name="998495"> </a>Returns a pointer to an object of the <code>hostent</code> structure.</p>

<h3 class="hbH3">
  <a name="998506"> </a>getipnodebyaddr Function <a href="#608590"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="998508"> </a>Purpose 
</h4>

<p><a name="998510"> </a>Returns the address of a network host.</p>
<h4>
  <a name="998511"> </a>Declared In 
</h4>
<code>posix/netdb.h<a name="998512"> </a></code><h4>
  <a name="998513"> </a>Prototype 
</h4>
<pre class="proto"><a name="998514"></a>struct hostent *getipnodebyaddr (
   const void *<code class="par">src</code>,
   size_t <code class="par">len</code>,
   int <code class="par">af</code>,
   int *<code class="par">error_num</code>
)
</pre>
<h4>
  <a name="998515"> </a>Parameters 
</h4>

<dl>
<dt><a name="998516"> </a><code>&rarr;  <i>src</i></code></dt>
<dd><a name="998517"> </a>The name of the host whose network address to look up.</dd>

<dt><a name="998518"> </a><code>&rarr;  <i>len</i></code></dt>
<dd><a name="998519"> </a>The length, in bytes, of the address.</dd>

<dt><a name="998520"> </a><code>&rarr;  <i>af</i></code></dt>
<dd><a name="998521"> </a>Must be specified as <code>AF_INET</code> or <code>AF_INET6</code>.</dd>

<dt><a name="998522"> </a><code>&larr;  <i>error_num</i></code></dt>
<dd><a name="998523"> </a>A <code>NULL</code> pointer is returned if an error occurred, and <code class="par">error_num</code> contains an error code from the following list: <code>HOST_NOT_FOUND</code>, <code>NO_ADDRESS</code>, <code>NO_RECOVERY</code>, or <code>TRY_AGAIN</code>.</dd>

</dl>
<h4>
  <a name="998531"> </a>Returns 
</h4>

<p><a name="998532"> </a>Returns a pointer to an object of the <code>hostent</code> structure, describing an Internet host referenced by address.</p>
<h4>
  <a name="998535"> </a>Compatibility 
</h4>

<p><a name="998537"> </a>This function is a Palm OS extension (not present in C99 or Unix).</p>

<h3 class="hbH3">
  <a name="998544"> </a>getipnodebyname Function <a href="#608590"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="998546"> </a>Purpose 
</h4>

<p><a name="998548"> </a>Returns the name of a network host.</p>
<h4>
  <a name="998549"> </a>Declared In 
</h4>
<code>posix/netdb.h<a name="998550"> </a></code><h4>
  <a name="998551"> </a>Prototype 
</h4>
<pre class="proto"><a name="998552"></a>struct hostent *getipnodebyname (
   const char *<code class="par">name</code>,
   int <code class="par">af</code>,
   int <code class="par">flags</code>,
   int *<code class="par">error_num</code>
)
</pre>
<h4>
  <a name="998553"> </a>Parameters 
</h4>

<dl>
<dt><a name="998554"> </a><code>&rarr;  <i>name</i></code></dt>
<dd><a name="998555"> </a>Official name of the host.</dd>

<dt><a name="998556"> </a><code>&rarr;  <i>af</i></code></dt>
<dd><a name="998557"> </a>Must be specified as <code>AF_INET</code> or <code>AF_INET6</code>.</dd>

<dt><a name="998558"> </a><code>&rarr;  <i>flags</i></code></dt>
<dd><a name="998559"> </a>Specifies additional options: <code>AI_V4MAPPED</code>, <code>AI_ALL</code>, or <code>AI_ADDRCONFIG</code>. More than one option can be specified by logically ORing them together. <code class="par">flags</code> should be set to zero (0) if no options are desired.</dd>

<dt><a name="998560"> </a><code>&larr;  <i>error_num</i></code></dt>
<dd><a name="998561"> </a>A <code>NULL</code> pointer is returned if an error occurred, and <code class="par">error_num</code> contains an error code from the following list: <code>HOST_NOT_FOUND</code>, <code>NO_ADDRESS</code>, <code>NO_RECOVERY</code>, or <code>TRY_AGAIN</code>.</dd>

</dl>
<h4>
  <a name="998569"> </a>Returns 
</h4>

<p><a name="998570"> </a>Returns a pointer to an object of the <code>hostent</code> structure, describing an Internet host referenced by name.</p>
<h4>
  <a name="998573"> </a>Compatibility 
</h4>

<p><a name="998575"> </a>This function is a Palm OS extension (not present in C99 or Unix).</p>

<h3 class="hbH3">
  <a name="998582"> </a>getnameinfo Function <a href="#608590"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="998584"> </a>Purpose 
</h4>

<p><a name="998586"> </a>Translates address-to-nodename in a protocol-independent manner.</p>
<h4>
  <a name="998587"> </a>Declared In 
</h4>
<code>posix/netdb.h<a name="998588"> </a></code><h4>
  <a name="998589"> </a>Prototype 
</h4>
<pre class="proto"><a name="998590"></a>int getnameinfo (
   const struct sockaddr *<code class="par">sa</code>,
   size_t <code class="par">salen</code>,
   char *<code class="par">host</code>,
   size_t <code class="par">hostlen</code>,
   char *<code class="par">serv</code>,
   size_t <code class="par">servlen</code>,
   int <code class="par">flags</code>
)
</pre>
<h4>
  <a name="998592"> </a>Parameters 
</h4>

<dl>
<dt><a name="998593"> </a><code>&rarr;  <i>sa</i></code></dt>
<dd><a name="998594"> </a>A <code>sockaddr</code> structure.</dd>

<dt><a name="998595"> </a><code>&rarr;  <i>salen</i></code></dt>
<dd><a name="998596"> </a>The length, in bytes, of the <code>sockaddr</code> structure.</dd>

<dt><a name="998597"> </a><code>&rarr;  <i>host</i></code></dt>
<dd><a name="998598"> </a>The buffer that holds the IP address.</dd>

<dt><a name="998599"> </a><code>&rarr;  <i>hostlen</i></code></dt>
<dd><a name="998600"> </a>The length, in bytes, of the IP address buffer.</dd>

<dt><a name="998601"> </a><code>&rarr;  <i>serv</i></code></dt>
<dd><a name="998602"> </a>The buffer that holds the port number.</dd>

<dt><a name="998603"> </a><code>&rarr;  <i>servlen</i></code></dt>
<dd><a name="998604"> </a>The length, in bytes, of the port number buffer.</dd>

<dt><a name="998605"> </a><code>&rarr;  <i>flags</i></code></dt>
<dd><a name="998606"> </a>Changes the default actions of this function.</dd>

</dl>
<h4>
  <a name="998607"> </a>Returns 
</h4>

<p><a name="998608"> </a>Returns text strings for the IP address and port number in user-provided buffers.</p>

<h3 class="hbH3">
  <a name="998619"> </a>getnetbyaddr Function <a href="#608590"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="998621"> </a>Purpose 
</h4>

<p><a name="998623"> </a>Searches from the beginning of the file until a matching network address is found, or until EOF is encountered.</p>
<h4>
  <a name="998624"> </a>Declared In 
</h4>
<code>posix/netdb.h<a name="998625"> </a></code><h4>
  <a name="998626"> </a>Prototype 
</h4>
<pre class="proto"><a name="998627"></a>struct netent *getnetbyaddr (
   unsigned long <code class="par">net</code>,
   int <code class="par">type</code>
)
</pre>
<h4>
  <a name="998628"> </a>Parameters 
</h4>

<dl>
<dt><a name="998629"> </a><code>&rarr;  <i>net</i></code></dt>
<dd><a name="998630"> </a>The network number.</dd>

<dt><a name="998631"> </a><code>&rarr;  <i>type</i></code></dt>
<dd><a name="998632"> </a>Network address type.</dd>

</dl>
<h4>
  <a name="998633"> </a>Returns 
</h4>

<p><a name="998634"> </a>Returns a pointer to an object of the <code>netent</code> structure, describing the network database.</p>

<h3 class="hbH3">
  <a name="998645"> </a>getnetbyname Function <a href="#608590"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="998647"> </a>Purpose 
</h4>

<p><a name="998649"> </a>Searches from the beginning of the file until a matching network name is found, or until EOF is encountered.</p>
<h4>
  <a name="998650"> </a>Declared In 
</h4>
<code>posix/netdb.h<a name="998651"> </a></code><h4>
  <a name="998652"> </a>Prototype 
</h4>
<pre class="proto"><a name="998653"></a>struct netent *getnetbyname (
   const char *<code class="par">name</code>
)
</pre>
<h4>
  <a name="998654"> </a>Parameters 
</h4>

<dl>
<dt><a name="998655"> </a><code>&rarr;  <i>name</i></code></dt>
<dd><a name="998656"> </a>Official name of the network.</dd>

</dl>
<h4>
  <a name="998657"> </a>Returns 
</h4>

<p><a name="998658"> </a>Returns a pointer to an object of the <code>netent</code> structure, describing the network database.</p>

<h3 class="hbH3">
  <a name="998669"> </a>getnetent Function <a href="#608590"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="998671"> </a>Purpose 
</h4>

<p><a name="998673"> </a>Reads the next line of the file, opening the file if necessary.</p>
<h4>
  <a name="998674"> </a>Declared In 
</h4>
<code>posix/netdb.h<a name="998675"> </a></code><h4>
  <a name="998676"> </a>Prototype 
</h4>
<pre class="proto"><a name="998677"></a>struct netent *getnetent (
   void
)
</pre>
<h4>
  <a name="1018758"> </a>Parameters 
</h4>

<p><a name="1018759"> </a>None.</p>
<h4>
  <a name="998685"> </a>Returns 
</h4>

<p><a name="998686"> </a>Returns a pointer to an object of the <code>netent</code> structure, describing the network database.</p>

<h3 class="hbH3">
  <a name="993533"> </a>getpeername Function <a href="#608590"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="993535"> </a>Purpose 
</h4>

<p><a name="993537"> </a>Gets the name of the connected peer.</p>
<h4>
  <a name="993538"> </a>Declared In 
</h4>
<code>posix/sys/socket.h<a name="993539"> </a></code><h4>
  <a name="993540"> </a>Prototype 
</h4>
<pre class="proto"><a name="993541"></a>int getpeername (
   int <code class="par">sock</code>,
   struct sockaddr *<code class="par">addr</code>,
   socklen_t <code class="par">addrlen</code>
)
</pre>
<h4>
  <a name="993542"> </a>Parameters 
</h4>

<dl>
<dt><a name="993543"> </a><code>&rarr;  <i>sock</i></code></dt>
<dd><a name="993544"> </a>A socket.</dd>

<dt><a name="993545"> </a><code>&larr;  <i>addr</i></code></dt>
<dd><a name="993546"> </a>A result parameter that is filled in with the source address of the connecting entity, as known to the communications layer.</dd>

<dt><a name="993547"> </a><code>&harr;  <i>addrlen</i></code></dt>
<dd><a name="993548"> </a>Initially contains the amount of space pointed to by <code class="par">addr</code>; on return, it contains the actual length (in bytes) of the address returned.</dd>

</dl>
<h4>
  <a name="993549"> </a>Returns 
</h4>

<p><a name="993550"> </a>Returns the name of the peer connected to the specified socket.</p>
<h4>
  <a name="993557"> </a>See Also 
</h4>

<p><a name="993570"> </a><a href="LowLevelComms_SockRef.html#993407"><code>accept()</code></a>, <a href="LowLevelComms_SockRef.html#993450"><code>bind()</code></a>, <a href="LowLevelComms_SockRef.html#993573"><code>getsockname()</code></a>, <a href="LowLevelComms_SockRef.html#993999"><code>socket()</code></a></p>

<h3 class="hbH3">
  <a name="993573"> </a>getsockname Function <a href="#608590"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="993575"> </a>Purpose 
</h4>

<p><a name="993577"> </a>Gets the socket name.</p>
<h4>
  <a name="993578"> </a>Declared In 
</h4>
<code>posix/sys/socket.h<a name="993579"> </a></code><h4>
  <a name="993580"> </a>Prototype 
</h4>
<pre class="proto"><a name="993581"></a>int getsockname (
   int <code class="par">sock</code>,
   struct sockaddr *<code class="par">addr</code>,
   socklen_t <code class="par">addrlen</code>
)
</pre>
<h4>
  <a name="993582"> </a>Parameters 
</h4>

<dl>
<dt><a name="993583"> </a><code>&rarr;  <i>sock</i></code></dt>
<dd><a name="993584"> </a>A socket.</dd>

<dt><a name="993585"> </a><code>&larr;  <i>addr</i></code></dt>
<dd><a name="993586"> </a>A result parameter that is filled in with the source address of the connecting entity, as known to the communications layer.</dd>

<dt><a name="993587"> </a><code>&harr;  <i>addrlen</i></code></dt>
<dd><a name="993588"> </a>Initially contains the amount of space pointed to by <code class="par">addr</code>; on return, it contains the actual length (in bytes) of the address returned.</dd>

</dl>
<h4>
  <a name="993589"> </a>Returns 
</h4>

<p><a name="993590"> </a>Returns the current name for the specified socket.</p>
<h4>
  <a name="993597"> </a>See Also 
</h4>

<p><a name="993604"> </a><a href="LowLevelComms_SockRef.html#993450"><code>bind()</code></a>, <a href="LowLevelComms_SockRef.html#993999"><code>socket()</code></a></p>

<h3 class="hbH3">
  <a name="999729"> </a>getprotobyname Function <a href="#608590"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="999731"> </a>Purpose 
</h4>

<p><a name="999733"> </a>Sequentially searches from the beginning of the file until a matching protocol name is found, or until EOF is encountered.</p>
<h4>
  <a name="999734"> </a>Declared In 
</h4>
<code>posix/netdb.h<a name="999735"> </a></code><h4>
  <a name="999736"> </a>Prototype 
</h4>
<pre class="proto"><a name="999737"></a>struct protoent *getprotobyname (
   const char *<code class="par">name</code>
)
</pre>
<h4>
  <a name="999738"> </a>Parameters 
</h4>

<dl>
<dt><a name="999739"> </a><code>&rarr;  <i>name</i></code></dt>
<dd><a name="999740"> </a>Official name of the protocol.</dd>

</dl>
<h4>
  <a name="999741"> </a>Returns 
</h4>

<p><a name="999742"> </a>Returns a pointer to an object of the <code>protoent</code> structure, describing the network database.</p>

<h3 class="hbH3">
  <a name="999753"> </a>getprotobynumber Function <a href="#608590"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="999755"> </a>Purpose 
</h4>

<p><a name="999757"> </a>Sequentially searches from the beginning of the file until a matching protocol number is found, or until EOF is encountered.</p>
<h4>
  <a name="999758"> </a>Declared In 
</h4>
<code>posix/netdb.h<a name="999759"> </a></code><h4>
  <a name="999760"> </a>Prototype 
</h4>
<pre class="proto"><a name="999761"></a>struct protoent *getprotobynumber (
   int <code class="par">proto</code>
)
</pre>
<h4>
  <a name="999762"> </a>Parameters 
</h4>

<dl>
<dt><a name="999763"> </a><code>&rarr;  <i>proto</i></code></dt>
<dd><a name="999764"> </a>Official name of the protocol.</dd>

</dl>
<h4>
  <a name="999765"> </a>Returns 
</h4>

<p><a name="999766"> </a>Returns a pointer to an object of the <code>protoent</code> structure, describing the network database.</p>

<h3 class="hbH3">
  <a name="999777"> </a>getprotoent Function <a href="#608590"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="999779"> </a>Purpose 
</h4>

<p><a name="999781"> </a>Reads the next line of the file, opening the file if necessary.</p>
<h4>
  <a name="999782"> </a>Declared In 
</h4>
<code>posix/netdb.h<a name="999783"> </a></code><h4>
  <a name="999784"> </a>Prototype 
</h4>
<pre class="proto"><a name="999785"></a>struct protoent *getprotoent (
   void
)
</pre>
<h4>
  <a name="1018882"> </a>Parameters 
</h4>

<p><a name="1018887"> </a>None.</p>
<h4>
  <a name="999793"> </a>Returns 
</h4>

<p><a name="999794"> </a>Returns a pointer to an object of the <code>protoent</code> structure, describing the network database.</p>

<h3 class="hbH3">
  <a name="999805"> </a>getservbyname Function <a href="#608590"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="999807"> </a>Purpose 
</h4>

<p><a name="999809"> </a>Searches from the beginning of the file until a matching protocol name is found, or until EOF is encountered.</p>
<h4>
  <a name="999810"> </a>Declared In 
</h4>
<code>posix/netdb.h<a name="999811"> </a></code><h4>
  <a name="999812"> </a>Prototype 
</h4>
<pre class="proto"><a name="999813"></a>struct servent *getservbyname (
   const char *<code class="par">name</code>,
   const char *<code class="par">proto</code>
)
</pre>
<h4>
  <a name="999814"> </a>Parameters 
</h4>

<dl>
<dt><a name="999815"> </a><code>&rarr;  <i>name</i></code></dt>
<dd><a name="999816"> </a>Official name of the network.</dd>

<dt><a name="999817"> </a><code>&rarr;  <i>proto</i></code></dt>
<dd><a name="999818"> </a>The protocol.</dd>

</dl>
<h4>
  <a name="999819"> </a>Returns 
</h4>

<p><a name="999820"> </a>Returns a pointer to an object of the <code>servent</code> structure, describing the network services database.</p>

<h3 class="hbH3">
  <a name="999831"> </a>getservbyport Function <a href="#608590"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="999833"> </a>Purpose 
</h4>

<p><a name="999835"> </a>Searches from the beginning of the file until a matching port number is found, or until EOF is encountered.</p>
<h4>
  <a name="999836"> </a>Declared In 
</h4>
<code>posix/netdb.h<a name="999837"> </a></code><h4>
  <a name="999838"> </a>Prototype 
</h4>
<pre class="proto"><a name="999839"></a>struct servent *getservbyport (
   int <code class="par">port</code>,
   const char *<code class="par">proto</code>
)
</pre>
<h4>
  <a name="999840"> </a>Parameters 
</h4>

<dl>
<dt><a name="999841"> </a><code>&rarr;  <i>port</i></code></dt>
<dd><a name="999842"> </a>The port number.</dd>

<dt><a name="999843"> </a><code>&rarr;  <i>proto</i></code></dt>
<dd><a name="999844"> </a>The protocol to use</dd>

</dl>
<h4>
  <a name="999845"> </a>Returns 
</h4>

<p><a name="999846"> </a>Returns a pointer to an object of the <code>servent</code> structure, describing the network services database.</p>

<h3 class="hbH3">
  <a name="999857"> </a>getservent Function <a href="#608590"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="999859"> </a>Purpose 
</h4>

<p><a name="999861"> </a>Reads the next line of the file, opening the file if necessary.</p>
<h4>
  <a name="999862"> </a>Declared In 
</h4>
<code>posix/netdb.h<a name="999863"> </a></code><h4>
  <a name="999864"> </a>Prototype 
</h4>
<pre class="proto"><a name="999865"></a>struct servent *getservent (
   void
)
</pre>
<h4>
  <a name="1019882"> </a>Parameters 
</h4>

<p><a name="1019915"> </a>None.</p>
<h4>
  <a name="999873"> </a>Returns 
</h4>

<p><a name="999874"> </a>Returns a pointer to an object of the <code>servent</code> structure, describing the network services database.</p>

<h3 class="hbH3">
  <a name="993607"> </a>getsockopt Function <a href="#608590"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="993609"> </a>Purpose 
</h4>

<p><a name="993611"> </a>Gets the options on sockets.</p>
<h4>
  <a name="993612"> </a>Declared In 
</h4>
<code>posix/sys/socket.h<a name="993613"> </a></code><h4>
  <a name="993614"> </a>Prototype 
</h4>
<pre class="proto"><a name="993615"></a>int getsockopt (
   int <code class="par">sock</code>,
   int <code class="par">level</code>,
   int <code class="par">option</code>,
   void *<code class="par">optval</code>,
   socklen_t *<code class="par">optlen</code>
)
</pre>
<h4>
  <a name="993616"> </a>Parameters 
</h4>

<dl>
<dt><a name="993617"> </a><code>&rarr;  <i>sock</i></code></dt>
<dd><a name="993618"> </a>A socket.</dd>

<dt><a name="993619"> </a><code>&rarr;  <i>level</i></code></dt>
<dd><a name="993620"> </a>To manipulate options at the socket level, <code class="par">level</code> is specified as <code>SOL_SOCKET</code>.</dd>

<dt><a name="993621"> </a><code>&rarr;  <i>option</i></code></dt>
<dd><a name="993622"> </a><code class="par">option</code> and any specified options are passed uninterpreted to the appropriate protocol module for interpretation.</dd>

</dl>
<h4>
  <a name="993623"> </a>Returns 
</h4>

<p><a name="993624"> </a>Returns zero (0) if the connection or binding is successful. Otherwise, -1 is returned and the global variable <code>errno</code> is set to indicate the error.</p>
<h4>
  <a name="993631"> </a>See Also 
</h4>

<p><a name="993644"> </a><a href="LowLevelComms_SockRef.html#999777"><code>getprotoent()</code></a>, <a href="LowLevelComms_SockRef.html#1020910"><code>select()</code></a>, <a href="LowLevelComms_SockRef.html#993999"><code>socket()</code></a>, <a href="LowLevelComms_SockRef.html#993920"><code>setsockopt()</code></a></p>

<h3 class="hbH3">
  <a name="1000283"> </a>hstrerror Function <a href="#608590"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="1000285"> </a>Purpose 
</h4>

<p><a name="1000286"> </a>Returns a string that is the message text corresponding to the value of the <code class="par">err</code> parameter.</p>
<h4>
  <a name="1000287"> </a>Declared In 
</h4>
<code>posix/netdb.h<a name="1000288"> </a></code><h4>
  <a name="1000289"> </a>Prototype 
</h4>
<pre class="proto"><a name="1000290"></a>const char *hstrerror (
   int <code class="par">err</code>
)
</pre>
<h4>
  <a name="1000291"> </a>Parameters 
</h4>

<dl>
<dt><a name="1000292"> </a><code>&rarr;  <i>err</i></code></dt>
<dd><a name="1000293"> </a>The error.</dd>

</dl>
<h4>
  <a name="1000294"> </a>Returns 
</h4>

<p><a name="1000295"> </a>Returns a string that is the message text corresponding to the value of the <code class="par">err</code> parameter.</p>
<h4>
  <a name="1000298"> </a>Compatibility 
</h4>

<p><a name="1000300"> </a>This function is a Palm OS extension (not present in C99 or Unix).</p>

<h3 class="hbH3">
  <a name="995179"> </a>htonl Function <a href="#608590"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="995181"> </a>Purpose 
</h4>

<p><a name="995183"> </a>Converts 32-bit values between host byte order and network byte order.</p>
<h4>
  <a name="995184"> </a>Declared In 
</h4>
<code>posix/netinet/in.h<a name="995185"> </a></code><h4>
  <a name="995186"> </a>Prototype 
</h4>
<pre class="proto"><a name="995187"></a>uint32_t htonl (
   uint32_t <code class="par">host32</code>
)
</pre>
<h4>
  <a name="995188"> </a>Parameters 
</h4>

<dl>
<dt><a name="995189"> </a><code>&rarr;  <i>host32</i></code></dt>
<dd><a name="995190"> </a>The value being converted.</dd>

</dl>
<h4>
  <a name="995191"> </a>Returns 
</h4>

<p><a name="995192"> </a>Returns an unsigned integer.</p>
<h4>
  <a name="995199"> </a>See Also 
</h4>

<p><a name="995206"> </a><a href="LowLevelComms_SockRef.html#998428"><code>gethostbyname()</code></a><span style="color: #000000;  font-style: normal; font-weight: normal; text-decoration: none; text-transform: none; vertical-align: baseline">, </span><a href="LowLevelComms_SockRef.html#999857"><code>getservent()</code></a></p>

<h3 class="hbH3">
  <a name="995209"> </a>htons Function <a href="#608590"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="995211"> </a>Purpose 
</h4>

<p><a name="995213"> </a>Converts 16-bit values between host byte order and network byte order.</p>
<h4>
  <a name="995214"> </a>Declared In 
</h4>
<code>posix/netinet/in.h<a name="995215"> </a></code><h4>
  <a name="995216"> </a>Prototype 
</h4>
<pre class="proto"><a name="995217"></a>uint16_t htons (
   uint16_t <code class="par">host16</code>
)
</pre>
<h4>
  <a name="995218"> </a>Parameters 
</h4>

<dl>
<dt><a name="995219"> </a><code>&rarr;  <i>host16</i></code></dt>
<dd><a name="995220"> </a>The value being converted.</dd>

</dl>
<h4>
  <a name="995221"> </a>Returns 
</h4>

<p><a name="995222"> </a>Returns an unsigned short integer.</p>
<h4>
  <a name="995229"> </a>See Also 
</h4>

<p><a name="995236"> </a><a href="LowLevelComms_SockRef.html#998428"><code>gethostbyname()</code></a><span style="color: #000000;  font-style: normal; font-weight: normal; text-decoration: none; text-transform: none; vertical-align: baseline">, </span><a href="LowLevelComms_SockRef.html#999857"><code>getservent()</code></a></p>

<h3 class="hbH3">
  <a name="997103"> </a>inet_addr Function <a href="#608590"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="997105"> </a>Purpose 
</h4>

<p><a name="997106"> </a>Interprets the specified character string (the name of a computer on the Internet) and returns a number suitable for use as an Internet address.</p>
<h4>
  <a name="997108"> </a>Declared In 
</h4>
<code>posix/arpa/inet.h<a name="997109"> </a></code><h4>
  <a name="997110"> </a>Prototype 
</h4>
<pre class="proto"><a name="997111"></a>in_addr_t inet_addr (
   const char *<code class="par">cp</code>
)
</pre>
<h4>
  <a name="997112"> </a>Parameters 
</h4>

<dl>
<dt><a name="997113"> </a><code>&rarr;  <i>cp</i></code></dt>
<dd><a name="997114"> </a>A character string indicating the name of a computer on the Internet.</dd>

</dl>
<h4>
  <a name="997115"> </a>Returns 
</h4>

<p><a name="997116"> </a>Returns a number suitable for use as an Internet address.</p>
<h4>
  <a name="997117"> </a>Comments 
</h4>

<p><a name="1003772"> </a>The string <code class="par">cp</code> should be a name such as "palmsource.com" or "foo.bar.com".</p>
<h4>
  <a name="1003776"> </a>See Also 
</h4>

<p><a name="1003780"> </a><a href="LowLevelComms_SockRef.html#997241"><code>inet_network()</code></a></p>

<h3 class="hbH3">
  <a name="997131"> </a>inet_aton Function <a href="#608590"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="997133"> </a>Purpose 
</h4>

<p><a name="997135"> </a>Interprets the specified character string as an Internet address, placing the address into the structure provided.</p>
<h4>
  <a name="997136"> </a>Declared In 
</h4>
<code>posix/arpa/inet.h<a name="997137"> </a></code><h4>
  <a name="997138"> </a>Prototype 
</h4>
<pre class="proto"><a name="997139"></a>int inet_aton (
   const char *<code class="par">cp</code>,
   struct in_addr *<code class="par">addr</code>
)
</pre>
<h4>
  <a name="997140"> </a>Parameters 
</h4>

<dl>
<dt><a name="997141"> </a><code>&rarr;  <i>cp</i></code></dt>
<dd><a name="997142"> </a>A character string. In order for this function to work successfully, the string must be a standard dotted-quad format IP address, such as "127.0.0.1".</dd>

<dt><a name="997143"> </a><code>&rarr;  <i>addr</i></code></dt>
<dd><a name="997144"> </a>An Internet address.</dd>

</dl>
<h4>
  <a name="997145"> </a>Returns 
</h4>

<p><a name="997146"> </a>Returns 1 if the string was successfully interpreted, or zero (0) if the string is invalid.</p>
<h4>
  <a name="997149"> </a>Compatibility 
</h4>

<p><a name="997151"> </a>This function is a Palm OS extension (not present in C99 or Unix).</p>

<h3 class="hbH3">
  <a name="997158"> </a>inet_lnaof Function <a href="#608590"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="997160"> </a>Purpose 
</h4>

<p><a name="997162"> </a>Breaks apart the specified Internet host address and returns the local network address part (in host order).</p>
<h4>
  <a name="997163"> </a>Declared In 
</h4>
<code>posix/arpa/inet.h<a name="997164"> </a></code><h4>
  <a name="997165"> </a>Prototype 
</h4>
<pre class="proto"><a name="997166"></a>in_addr_t inet_lnaof (
   struct in_addr <code class="par">in</code>
)
</pre>
<h4>
  <a name="997167"> </a>Parameters 
</h4>

<dl>
<dt><a name="997168"> </a><code>&rarr;  <i>in</i></code></dt>
<dd><a name="997169"> </a>An Internet address.</dd>

</dl>
<h4>
  <a name="997170"> </a>Returns 
</h4>

<p><a name="997171"> </a>Returns the local network address (in host order).</p>
<h4>
  <a name="997174"> </a>Compatibility 
</h4>

<p><a name="997176"> </a>This function is a Palm OS extension (not present in C99 or Unix).</p>
<h4>
  <a name="997179"> </a>See Also 
</h4>

<p><a name="997183"> </a><a href="LowLevelComms_SockRef.html#997213"><code>inet_netof()</code></a></p>

<h3 class="hbH3">
  <a name="997186"> </a>inet_makeaddr Function <a href="#608590"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="997188"> </a>Purpose 
</h4>

<p><a name="997189"> </a>Takes an Internet network number and a local network address (both in host order) and constructs an Internet address from it.</p>
<h4>
  <a name="997191"> </a>Declared In 
</h4>
<code>posix/arpa/inet.h<a name="997192"> </a></code><h4>
  <a name="997193"> </a>Prototype 
</h4>
<pre class="proto"><a name="997194"></a>struct in_addr inet_makeaddr (
   int <code class="par">net</code>,
   int <code class="par">lna</code>
)
</pre>
<h4>
  <a name="997195"> </a>Parameters 
</h4>

<dl>
<dt><a name="997196"> </a><code>&rarr;  <i>net</i></code></dt>
<dd><a name="997197"> </a>An Internet network number.</dd>

<dt><a name="997198"> </a><code>&rarr;  <i>lna</i></code></dt>
<dd><a name="997199"> </a>A local network address.</dd>

</dl>
<h4>
  <a name="997200"> </a>Returns 
</h4>

<p><a name="997201"> </a>Returns an Internet address.</p>
<h4>
  <a name="997204"> </a>Compatibility 
</h4>

<p><a name="997206"> </a>This function is a Palm OS extension (not present in C99 or Unix).</p>

<h3 class="hbH3">
  <a name="997213"> </a>inet_netof Function <a href="#608590"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="997215"> </a>Purpose 
</h4>

<p><a name="997217"> </a>Breaks apart the specified Internet host address and returns the network number part (in host order).</p>
<h4>
  <a name="997218"> </a>Declared In 
</h4>
<code>posix/arpa/inet.h<a name="997219"> </a></code><h4>
  <a name="997220"> </a>Prototype 
</h4>
<pre class="proto"><a name="997221"></a>in_addr_t inet_netof (
   struct in_addr <code class="par">in</code>
)
</pre>
<h4>
  <a name="997222"> </a>Parameters 
</h4>

<dl>
<dt><a name="997223"> </a><code>&rarr;  <i>in</i></code></dt>
<dd><a name="997224"> </a>An Internet address.</dd>

</dl>
<h4>
  <a name="997225"> </a>Returns 
</h4>

<p><a name="997226"> </a>Returns the network number (in host order).</p>
<h4>
  <a name="997229"> </a>Compatibility 
</h4>

<p><a name="997231"> </a>This function is a Palm OS extension (not present in C99 or Unix).</p>
<h4>
  <a name="997234"> </a>See Also 
</h4>

<p><a name="997238"> </a><a href="LowLevelComms_SockRef.html#997158"><code>inet_lnaof()</code></a></p>

<h3 class="hbH3">
  <a name="997241"> </a>inet_network Function <a href="#608590"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="997243"> </a>Purpose 
</h4>

<p><a name="997245"> </a>Interprets the specified character string and returns a number suitable for use as an Internet network number.</p>
<h4>
  <a name="997246"> </a>Declared In 
</h4>
<code>posix/arpa/inet.h<a name="997247"> </a></code><h4>
  <a name="997248"> </a>Prototype 
</h4>
<pre class="proto"><a name="997249"></a>in_addr_t inet_network (
   const char *<code class="par">cp</code>
)
</pre>
<h4>
  <a name="997250"> </a>Parameters 
</h4>

<dl>
<dt><a name="997251"> </a><code>&rarr;  <i>cp</i></code></dt>
<dd><a name="997252"> </a>A character string.</dd>

</dl>
<h4>
  <a name="997253"> </a>Returns 
</h4>

<p><a name="997254"> </a>Returns a number suitable for use as an Internet network number.</p>
<h4>
  <a name="997257"> </a>Compatibility 
</h4>

<p><a name="997259"> </a>This function is a Palm OS extension (not present in C99 or Unix).</p>
<h4>
  <a name="997262"> </a>See Also 
</h4>

<p><a name="997266"> </a><a href="LowLevelComms_SockRef.html#997103"><code>inet_addr()</code></a></p>

<h3 class="hbH3">
  <a name="997269"> </a>inet_ntoa Function <a href="#608590"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="997271"> </a>Purpose 
</h4>

<p><a name="997273"> </a>Takes an Internet address and returns an ASCII string representing the address.</p>
<h4>
  <a name="997274"> </a>Declared In 
</h4>
<code>posix/arpa/inet.h<a name="997275"> </a></code><h4>
  <a name="997276"> </a>Prototype 
</h4>
<pre class="proto"><a name="997277"></a>const char *inet_ntoa (
   struct in_addr <code class="par">in</code>
)
</pre>
<h4>
  <a name="997278"> </a>Parameters 
</h4>

<dl>
<dt><a name="997279"> </a><code>&rarr;  <i>in</i></code></dt>
<dd><a name="997280"> </a>An Internet address.</dd>

</dl>
<h4>
  <a name="997281"> </a>Returns 
</h4>

<p><a name="1004113"> </a>Returns a pointer to an ASCII string representing the address.</p>

<h3 class="hbH3">
  <a name="997293"> </a>inet_ntop Function <a href="#608590"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="997295"> </a>Purpose 
</h4>

<p><a name="997297"> </a>Converts a network format address to presentation format.</p>
<h4>
  <a name="997298"> </a>Declared In 
</h4>
<code>posix/arpa/inet.h<a name="997299"> </a></code><h4>
  <a name="997300"> </a>Prototype 
</h4>
<pre class="proto"><a name="997301"></a>const char *inet_ntop (
   int <code class="par">af</code>,
   const void *<code class="par">src</code>,
   char *<code class="par">dst</code>,
   size_t <code class="par">size</code>
)
</pre>
<h4>
  <a name="997302"> </a>Parameters 
</h4>

<dl>
<dt><a name="997303"> </a><code>&rarr;  <i>af</i></code></dt>
<dd><a name="997304"> </a>The address family.</dd>

<dt><a name="997305"> </a><code>&rarr;  <i>src</i></code></dt>
<dd><a name="997306"> </a>The source buffer.</dd>

<dt><a name="997307"> </a><code>&rarr;  <i>dst</i></code></dt>
<dd><a name="997308"> </a>The destination buffer.</dd>

<dt><a name="997309"> </a><code>&rarr;  <i>size</i></code></dt>
<dd><a name="997310"> </a>The size of the destination buffer.</dd>

</dl>
<h4>
  <a name="997311"> </a>Returns 
</h4>

<p><a name="997312"> </a>Returns a pointer to the destination buffer. Otherwise, <code>NULL</code> is returned if a system error occurs and the global variable <code>errno</code> is set to indicate the error.</p>

<h3 class="hbH3">
  <a name="997323"> </a>inet_pton Function <a href="#608590"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="997325"> </a>Purpose 
</h4>

<p><a name="997327"> </a>Converts a presentation format address to network format.</p>
<h4>
  <a name="997328"> </a>Declared In 
</h4>
<code>posix/arpa/inet.h<a name="997329"> </a></code><h4>
  <a name="997330"> </a>Prototype 
</h4>
<pre class="proto"><a name="997331"></a>int inet_pton (
   int <code class="par">af</code>,
   const char *<code class="par">src</code>,
   void *<code class="par">dst</code>
)
</pre>
<h4>
  <a name="997332"> </a>Parameters 
</h4>

<dl>
<dt><a name="997333"> </a><code>&rarr;  <i>af</i></code></dt>
<dd><a name="997334"> </a>The address family.</dd>

<dt><a name="997335"> </a><code>&rarr;  <i>src</i></code></dt>
<dd><a name="997336"> </a>The printable form as specified in a character string.</dd>

<dt><a name="997337"> </a><code>&rarr;  <i>dst</i></code></dt>
<dd><a name="997338"> </a>The destination string.</dd>

</dl>
<h4>
  <a name="997339"> </a>Returns 
</h4>

<p><a name="997340"> </a>Returns 1 if the address was valid for the specified address family, or zero (0) if the address was not parseable in the specified address family, or -1 if some system error occurred (in which case the global variable <code>errno</code> is set to indicate the error).</p>

<h3 class="hbH3">
  <a name="997674"> </a>listen Function <a href="#608590"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="993652"> </a>Purpose 
</h4>

<p><a name="993654"> </a>Listens for connections on a socket.</p>
<h4>
  <a name="993655"> </a>Declared In 
</h4>
<code>posix/sys/socket.h<a name="993656"> </a></code><h4>
  <a name="993657"> </a>Prototype 
</h4>
<pre class="proto"><a name="993658"></a>int listen (
   int <code class="par">sock</code>,
   int <code class="par">backlog</code>
)
</pre>
<h4>
  <a name="993659"> </a>Parameters 
</h4>

<dl>
<dt><a name="993660"> </a><code>&rarr;  <i>sock</i></code></dt>
<dd><a name="993661"> </a>The socket on which to listen for incoming connection attempts.</dd>

<dt><a name="993662"> </a><code>&rarr;  <i>backlog</i></code></dt>
<dd><a name="993663"> </a>The maximum length the queue of pending connections may grow to.</dd>

</dl>
<h4>
  <a name="993664"> </a>Returns 
</h4>

<p><a name="993665"> </a>Returns zero (0) if the connection or binding is successful. Otherwise, -1 is returned and the global variable <code>errno</code> is set to indicate the error.</p>
<h4>
  <a name="993672"> </a>See Also 
</h4>

<p><a name="993682"> </a><a href="LowLevelComms_SockRef.html#993407"><code>accept()</code></a>, <a href="LowLevelComms_SockRef.html#993490"><code>connect()</code></a>, <a href="LowLevelComms_SockRef.html#993999"><code>socket()</code></a></p>

<h3 class="hbH3">
  <a name="996637"> </a>ntohl Function <a href="#608590"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="996639"> </a>Purpose 
</h4>

<p><a name="996641"> </a>Converts 32-bit values between network byte order and host byte order.</p>
<h4>
  <a name="996642"> </a>Declared In 
</h4>
<code>posix/netinet/in.h<a name="996643"> </a></code><h4>
  <a name="996644"> </a>Prototype 
</h4>
<pre class="proto"><a name="996645"></a>uint32_t ntohl (
   uint32_t <code class="par">net32</code>
)
</pre>
<h4>
  <a name="996646"> </a>Parameters 
</h4>

<dl>
<dt><a name="996647"> </a><code>&rarr;  <i>net32</i></code></dt>
<dd><a name="996648"> </a>The value being converted.</dd>

</dl>
<h4>
  <a name="996649"> </a>Returns 
</h4>

<p><a name="996650"> </a>Returns an unsigned integer.</p>
<h4>
  <a name="996657"> </a>See Also 
</h4>

<p><a name="996664"> </a><a href="LowLevelComms_SockRef.html#998428"><code>gethostbyname()</code></a><span style="color: #000000;  font-style: normal; font-weight: normal; text-decoration: none; text-transform: none; vertical-align: baseline">, </span><a href="LowLevelComms_SockRef.html#999857"><code>getservent()</code></a></p>

<h3 class="hbH3">
  <a name="996667"> </a>ntohs Function <a href="#608590"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="996669"> </a>Purpose 
</h4>

<p><a name="996671"> </a>Converts 16-bit values between network byte order and host byte order.</p>
<h4>
  <a name="996672"> </a>Declared In 
</h4>
<code>posix/netinet/in.h<a name="996673"> </a></code><h4>
  <a name="996674"> </a>Prototype 
</h4>
<pre class="proto"><a name="996675"></a>uint16_t ntohs (
   uint16_t <code class="par">net16</code>
)
</pre>
<h4>
  <a name="996676"> </a>Parameters 
</h4>

<dl>
<dt><a name="996677"> </a><code>&rarr;  <i>net16</i></code></dt>
<dd><a name="996678"> </a>The value being converted.</dd>

</dl>
<h4>
  <a name="996679"> </a>Returns 
</h4>

<p><a name="996680"> </a>Returns an unsigned short integer.</p>
<h4>
  <a name="996687"> </a>See Also 
</h4>

<p><a name="996694"> </a><a href="LowLevelComms_SockRef.html#998428"><code>gethostbyname()</code></a><span style="color: #000000;  font-style: normal; font-weight: normal; text-decoration: none; text-transform: none; vertical-align: baseline">, </span><a href="LowLevelComms_SockRef.html#999857"><code>getservent()</code></a></p>

<h3 class="hbH3">
  <a name="996633"> </a>recv Function <a href="#608590"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="993687"> </a>Purpose 
</h4>

<p><a name="993688"> </a>Normally used only on a connected socket and is identical to <code>recvfrom()</code> with a <code>NULL</code> <code class="par">addr</code> parameter.</p>
<h4>
  <a name="993689"> </a>Declared In 
</h4>
<code>posix/sys/socket.h<a name="993690"> </a></code><h4>
  <a name="993691"> </a>Prototype 
</h4>
<pre class="proto"><a name="993692"></a>ssize_t recv (
   int <code class="par">sock</code>,
   void *<code class="par">data</code>,
   size_t <code class="par">datalen</code>,
   int <code class="par">flags</code>
)
</pre>
<h4>
  <a name="993693"> </a>Parameters 
</h4>

<dl>
<dt><a name="993694"> </a><code>&rarr;  <i>sock</i></code></dt>
<dd><a name="993695"> </a>A socket.</dd>

<dt><a name="993696"> </a><code>&rarr;  <i>data</i></code></dt>
<dd><a name="993697"> </a>The message.</dd>

<dt><a name="993698"> </a><code>&rarr;  <i>datalen</i></code></dt>
<dd><a name="993699"> </a>The length of the message.</dd>

<dt><a name="993700"> </a><code>&rarr;  <i>flags</i></code></dt>
<dd><a name="993701"> </a>ORs together one or more of the values: <code>MSG_OOB</code>, <code>MSG_PEEK</code>, <code>MSG_WAITALL</code>.</dd>

</dl>
<h4>
  <a name="993702"> </a>Returns 
</h4>

<p><a name="993703"> </a>Returns the length of the message upon successful completion. Otherwise, -1 is returned and the global variable <code>errno</code> is set to indicate the error. If a message is too long to fit in the supplied buffer, excess bytes may be discarded depending on the type of socket the message is received from.</p>
<h4>
  <a name="993710"> </a>See Also 
</h4>

<p><a name="993720"> </a><a href="LowLevelComms_SockRef.html#993490"><code>connect()</code></a>, <a href="LowLevelComms_SockRef.html#993723"><code>recvfrom()</code></a>, <a href="LowLevelComms_SockRef.html#993766"><code>recvmsg()</code></a></p>

<h3 class="hbH3">
  <a name="993723"> </a>recvfrom Function <a href="#608590"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="993725"> </a>Purpose 
</h4>

<p><a name="993727"> </a>Receives messages from a socket, and may be used to receive data on a socket whether or not it is connection-oriented.</p>
<h4>
  <a name="993728"> </a>Declared In 
</h4>
<code>posix/sys/socket.h<a name="993729"> </a></code><h4>
  <a name="993730"> </a>Prototype 
</h4>
<pre class="proto"><a name="993731"></a>ssize_t recvfrom (
   int <code class="par">sock</code>,
   void *<code class="par">data</code>,
   size_t <code class="par">datalen</code>,
   int <code class="par">flags</code>,
   struct sockaddr *<code class="par">addr</code>,
   socklen_t *<code class="par">addrlen</code>
)
</pre>
<h4>
  <a name="993732"> </a>Parameters 
</h4>

<dl>
<dt><a name="993733"> </a><code>&rarr;  <i>sock</i></code></dt>
<dd><a name="993734"> </a>A socket.</dd>

<dt><a name="993735"> </a><code>&rarr;  <i>data</i></code></dt>
<dd><a name="993736"> </a>The message.</dd>

<dt><a name="993737"> </a><code>&rarr;  <i>datalen</i></code></dt>
<dd><a name="993738"> </a>The length of the message.</dd>

<dt><a name="993739"> </a><code>&rarr;  <i>flags</i></code></dt>
<dd><a name="993740"> </a>ORs together one or more of the values: <code>MSG_OOB</code>, <code>MSG_PEEK</code>, <code>MSG_WAITALL</code>.</dd>

<dt><a name="993741"> </a><code>&rarr;  <i>addr</i></code></dt>
<dd><a name="993742"> </a>If <code class="par">addr</code> is non-<code>NULL</code>, and the socket is not connection-oriented, the source address of the message is filled in.</dd>

<dt><a name="993743"> </a><code>&larr;  <i>addrlen</i></code></dt>
<dd><a name="993744"> </a>Initially contains the amount of space pointed to by <code class="par">addr</code>; on return, it contains the actual length (in bytes) of the address stored there.</dd>

</dl>
<h4>
  <a name="993745"> </a>Returns 
</h4>

<p><a name="993746"> </a>Returns the length of the message upon successful completion. Otherwise, -1 is returned and the global variable <code>errno</code> is set to indicate the error. If a message is too long to fit in the supplied buffer, excess bytes may be discarded depending on the type of socket the message is received from.</p>
<h4>
  <a name="993753"> </a>See Also 
</h4>

<p><a name="993763"> </a><a href="LowLevelComms_SockRef.html#993490"><code>connect()</code></a>, <a href="LowLevelComms_SockRef.html#996633"><code>recv()</code></a>, <a href="LowLevelComms_SockRef.html#993766"><code>recvmsg()</code></a></p>

<h3 class="hbH3">
  <a name="993766"> </a>recvmsg Function <a href="#608590"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="993768"> </a>Purpose 
</h4>

<p><a name="993770"> </a>Receives messages from a socket, and may be used to receive data on a socket whether or not it is connection-oriented.</p>
<h4>
  <a name="993771"> </a>Declared In 
</h4>
<code>posix/sys/socket.h<a name="993772"> </a></code><h4>
  <a name="993773"> </a>Prototype 
</h4>
<pre class="proto"><a name="993774"></a>ssize_t recvmsg (
   int <code class="par">sd</code>,
   struct msghdr *<code class="par">msg</code>,
   int <code class="par">flags</code>
)
</pre>
<h4>
  <a name="993775"> </a>Parameters 
</h4>

<dl>
<dt><a name="993776"> </a><code>&rarr;  <i>sd</i></code></dt>
<dd><a name="993777"> </a>A socket.</dd>

<dt><a name="993778"> </a><code>&rarr;  <i>msg</i></code></dt>
<dd><a name="993779"> </a>The message.</dd>

<dt><a name="993780"> </a><code>&rarr;  <i>flags</i></code></dt>
<dd><a name="993781"> </a>ORs together one or more of the values: <code>MSG_OOB</code>, <code>MSG_PEEK</code>, <code>MSG_WAITALL</code>.</dd>

</dl>
<h4>
  <a name="993782"> </a>Returns 
</h4>

<p><a name="993783"> </a>Returns the length of the message upon successful completion. Otherwise, -1 is returned and the global variable <code>errno</code> is set to indicate the error. If a message is too long to fit in the supplied buffer, excess bytes may be discarded depending on the type of socket the message is received from.</p>
<h4>
  <a name="993790"> </a>See Also 
</h4>

<p><a name="993800"> </a><a href="LowLevelComms_SockRef.html#993490"><code>connect()</code></a>, <a href="LowLevelComms_SockRef.html#996633"><code>recv()</code></a>, <a href="LowLevelComms_SockRef.html#993723"><code>recvfrom()</code></a></p>

<h3 class="hbH3">
  <a name="1020910"> </a>select Function <a href="#608590"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="1020912"> </a>Purpose 
</h4>

<p><a name="1020914"> </a>Examines the I/O descriptor sets whose addresses are passed in to see if some of their descriptors are ready.</p>
<h4>
  <a name="1020915"> </a>Declared In 
</h4>
<code>posix/sys/select.h<a name="1020916"> </a></code><h4>
  <a name="1020917"> </a>Prototype 
</h4>
<pre class="proto"><a name="1020918"></a>int select (
   int <code class="par">fd</code>,
   fd_set *<code class="par">rfds</code>,
   fd_set *<code class="par">wfds</code>,
   fd_set *<code class="par">efds</code>,
   struct timeval *<code class="par">timeout</code>
)
</pre>
<h4>
  <a name="1020919"> </a>Parameters 
</h4>

<dl>
<dt><a name="1020920"> </a><code>&rarr;  <i>fd</i></code></dt>
<dd><a name="1020921"> </a>The descriptors are checked in each set; that is, the descriptors from zero (0) through <code class="par">fd</code> - 1 in the descriptor sets are examined.</dd>

<dt><a name="1020922"> </a><code>&rarr;  <i>rfds</i></code></dt>
<dd><a name="1020923"> </a>The descriptors are checked to see if some of them are ready for reading.</dd>

<dt><a name="1020924"> </a><code>&rarr;  <i>wfds</i></code></dt>
<dd><a name="1020925"> </a>The descriptors are checked to see if some of them are ready for writing.</dd>

<dt><a name="1020926"> </a><code>&rarr;  <i>efds</i></code></dt>
<dd><a name="1020927"> </a>The descriptors are checked to see if some of them have an exceptional condition pending.</dd>

<dt><a name="1020928"> </a><code>&rarr;  <i>timeout</i></code></dt>
<dd><a name="1020929"> </a>If <code class="par">timeout</code> is a non-<code>NULL</code> pointer, it specifies a maximum interval to wait for the selection to complete. If <code class="par">timeout</code> is a <code>NULL</code> pointer, then <code>select()</code> blocks indefinitely. To affect a poll, the <code class="par">timeout</code> argument should be non-<code>NULL</code>, pointing to a zero-valued <code>timeval</code> structure.</dd>

</dl>
<h4>
  <a name="1020930"> </a>Returns 
</h4>

<p><a name="1020931"> </a>Returns the number of ready descriptors that are contained in the descriptor sets. Otherwise, -1 is returned and the global variable <code>errno</code> is set to indicate the error. If the time limit expires, <code>select()</code> returns zero (0). If <code>select()</code> returns with an error, including one due to an interrupted call, the descriptor sets are unmodified.</p>
<h4>
  <a name="1020938"> </a>See Also 
</h4>

<p><a name="1020957"> </a><a href="LowLevelComms_SockRef.html#993407"><code>accept()</code></a>, <a href="LowLevelComms_SockRef.html#993490"><code>connect()</code></a>, <a href="LowLevelComms_SockRef.html#996633"><code>recv()</code></a>, <a href="LowLevelComms_SockRef.html#993803"><code>send()</code></a></p>

<h3 class="hbH3">
  <a name="993803"> </a>send Function <a href="#608590"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="993805"> </a>Purpose 
</h4>

<p><a name="993807"> </a>Sends a message from a socket.</p>
<h4>
  <a name="993808"> </a>Declared In 
</h4>
<code>posix/sys/socket.h<a name="993809"> </a></code><h4>
  <a name="993810"> </a>Prototype 
</h4>
<pre class="proto"><a name="993811"></a>ssize_t send (
   int <code class="par">sock</code>,
   const void *<code class="par">data</code>,
   size_t <code class="par">datalen</code>,
   int <code class="par">flags</code>
)
</pre>
<h4>
  <a name="993812"> </a>Parameters 
</h4>

<dl>
<dt><a name="993813"> </a><code>&rarr;  <i>sock</i></code></dt>
<dd><a name="993814"> </a>A socket.</dd>

<dt><a name="993815"> </a><code>&rarr;  <i>data</i></code></dt>
<dd><a name="993816"> </a>The message.</dd>

<dt><a name="993817"> </a><code>&rarr;  <i>datalen</i></code></dt>
<dd><a name="993818"> </a>The length of the message.</dd>

<dt><a name="993819"> </a><code>&rarr;  <i>flags</i></code></dt>
<dd><a name="993820"> </a>ORs together one or more of the values: <code>MSG_OOB</code>, <code>MSG_DONTROUTE</code>.</dd>

</dl>
<h4>
  <a name="993821"> </a>Returns 
</h4>

<p><a name="993822"> </a>Returns the number of characters sent. Otherwise, -1 is returned and the global variable <code>errno</code> is set to indicate the error.</p>
<h4>
  <a name="993823"> </a>Comments 
</h4>

<p><a name="993824"> </a>May be used only when the socket is in a connected state.</p>
<h4>
  <a name="1004557"> </a>See Also 
</h4>

<p><a name="993839"> </a><a href="LowLevelComms_SockRef.html#1020910"><code>select()</code></a>, <a href="LowLevelComms_SockRef.html#993842"><code>sendmsg()</code></a>, <a href="LowLevelComms_SockRef.html#993879"><code>sendto()</code></a></p>

<h3 class="hbH3">
  <a name="993842"> </a>sendmsg Function <a href="#608590"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="993844"> </a>Purpose 
</h4>

<p><a name="993846"> </a>Sends a message from a socket.</p>
<h4>
  <a name="993847"> </a>Declared In 
</h4>
<code>posix/sys/socket.h<a name="993848"> </a></code><h4>
  <a name="993849"> </a>Prototype 
</h4>
<pre class="proto"><a name="993850"></a>ssize_t sendmsg (
   int <code class="par">sd</code>,
   const struct msghdr *<code class="par">msg</code>,
   int <code class="par">flags</code>
)
</pre>
<h4>
  <a name="993851"> </a>Parameters 
</h4>

<dl>
<dt><a name="993852"> </a><code>&rarr;  <i>sd</i></code></dt>
<dd><a name="993853"> </a>A socket.</dd>

<dt><a name="993854"> </a><code>&rarr;  <i>msg</i></code></dt>
<dd><a name="993855"> </a>The message.</dd>

<dt><a name="993856"> </a><code>&rarr;  <i>flags</i></code></dt>
<dd><a name="993857"> </a>ORs together one or more of the values: <code>MSG_OOB</code>, <code>MSG_DONTROUTE</code>.</dd>

</dl>
<h4>
  <a name="993858"> </a>Returns 
</h4>

<p><a name="993859"> </a>Returns the number of characters sent. Otherwise, -1 is returned and the global variable <code>errno</code> is set to indicate the error.</p>
<h4>
  <a name="993866"> </a>See Also 
</h4>

<p><a name="993876"> </a><a href="LowLevelComms_SockRef.html#1020910"><code>select()</code></a>, <a href="LowLevelComms_SockRef.html#993803"><code>send()</code></a>, <a href="LowLevelComms_SockRef.html#993879"><code>sendto()</code></a></p>

<h3 class="hbH3">
  <a name="993879"> </a>sendto Function <a href="#608590"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="993881"> </a>Purpose 
</h4>

<p><a name="993883"> </a>Sends a message from a socket.</p>
<h4>
  <a name="993884"> </a>Declared In 
</h4>
<code>posix/sys/socket.h<a name="993885"> </a></code><h4>
  <a name="993886"> </a>Prototype 
</h4>
<pre class="proto"><a name="993887"></a>ssize_t sendto (
   int <code class="par">sock</code>,
   const void *<code class="par">data</code>,
   size_t <code class="par">datalen</code>,
   int <code class="par">flags</code>,
   const struct sockaddr *<code class="par">addr</code>,
   socklen_t <code class="par">addrlen</code>
)
</pre>
<h4>
  <a name="993888"> </a>Parameters 
</h4>

<dl>
<dt><a name="993889"> </a><code>&rarr;  <i>sock</i></code></dt>
<dd><a name="993890"> </a>A socket.</dd>

<dt><a name="993891"> </a><code>&rarr;  <i>data</i></code></dt>
<dd><a name="993892"> </a>The message.</dd>

<dt><a name="993893"> </a><code>&rarr;  <i>datalen</i></code></dt>
<dd><a name="993894"> </a>The length of the message.</dd>

<dt><a name="993895"> </a><code>&rarr;  <i>flags</i></code></dt>
<dd><a name="993896"> </a>ORs together one or more of the values: <code>MSG_OOB</code>, <code>MSG_DONTROUTE</code>.</dd>

<dt><a name="993897"> </a><code>&rarr;  <i>addr</i></code></dt>
<dd><a name="993898"> </a>If <code class="par">addr</code> is non-<code>NULL</code>, and the socket is not connection-oriented, the source address of the message is filled in.</dd>

<dt><a name="993899"> </a><code>&larr;  <i>addrlen</i></code></dt>
<dd><a name="993900"> </a>Initially contains the amount of space pointed to by <code class="par">addr</code>; on return, it contains the actual length (in bytes) of the address stored there.</dd>

</dl>
<h4>
  <a name="993901"> </a>Returns 
</h4>

<p><a name="993902"> </a>Returns the number of characters sent. Otherwise, -1 is returned and the global variable <code>errno</code> is set to indicate the error.</p>
<h4>
  <a name="993907"> </a>See Also 
</h4>

<p><a name="993917"> </a><a href="LowLevelComms_SockRef.html#1020910"><code>select()</code></a>, <a href="LowLevelComms_SockRef.html#993803"><code>send()</code></a>, <a href="LowLevelComms_SockRef.html#993842"><code>sendmsg()</code></a></p>

<h3 class="hbH3">
  <a name="1000366"> </a>sethostent Function <a href="#608590"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="1000368"> </a>Purpose 
</h4>

<p><a name="1000370"> </a>Requests the use of a connected TCP socket for queries.</p>
<h4>
  <a name="1000371"> </a>Declared In 
</h4>
<code>posix/netdb.h<a name="1000372"> </a></code><h4>
  <a name="1000373"> </a>Prototype 
</h4>
<pre class="proto"><a name="1000374"></a>void sethostent (
   int <code class="par">stayopen</code>
)
</pre>
<h4>
  <a name="1000375"> </a>Parameters 
</h4>

<dl>
<dt><a name="1000376"> </a><code>&rarr;  <i>stayopen</i></code></dt>
<dd><a name="1000377"> </a>If the <code class="par">stayopen</code> flag is non-zero, sets the option to send all queries to the name server using TCP and to retain the connection after each call to <code>gethostbyname()</code>, <code>gethostbyname2()</code>, or <code>gethostbyaddr()</code>. Otherwise, queries are performed using UDP datagrams.</dd>

</dl>
<h4>
  <a name="1000386"> </a>See Also 
</h4>

<p><a name="1000396"> </a><a href="LowLevelComms_SockRef.html#998400"><code>gethostbyaddr()</code></a>, <a href="LowLevelComms_SockRef.html#998428"><code>gethostbyname()</code></a>, <a href="LowLevelComms_SockRef.html#998452"><code>gethostbyname2()</code></a></p>

<h3 class="hbH3">
  <a name="1000399"> </a>setnetent Function <a href="#608590"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="1000401"> </a>Purpose 
</h4>

<p><a name="1000404"> </a>Opens and rewinds a file.</p>
<h4>
  <a name="1000405"> </a>Declared In 
</h4>
<code>posix/netdb.h<a name="1000406"> </a></code><h4>
  <a name="1000407"> </a>Prototype 
</h4>
<pre class="proto"><a name="1000408"></a>void setnetent (
   int <code class="par">stayopen</code>
)
</pre>
<h4>
  <a name="1000409"> </a>Parameters 
</h4>

<dl>
<dt><a name="1000410"> </a><code>&rarr;  <i>stayopen</i></code></dt>
<dd><a name="1000411"> </a>If non-zero, the network database is not closed after each call to <code>getnetbyname()</code> or <code>getnetbyaddr()</code>.</dd>

</dl>
<h4>
  <a name="1000420"> </a>See Also 
</h4>

<p><a name="1000427"> </a><a href="LowLevelComms_SockRef.html#998619"><code>getnetbyaddr()</code></a>, <a href="LowLevelComms_SockRef.html#998645"><code>getnetbyname()</code></a></p>

<h3 class="hbH3">
  <a name="1000430"> </a>setprotoent Function <a href="#608590"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="1000432"> </a>Purpose 
</h4>

<p><a name="1000434"> </a>Opens and rewinds a file.</p>
<h4>
  <a name="1000435"> </a>Declared In 
</h4>
<code>posix/netdb.h<a name="1000436"> </a></code><h4>
  <a name="1000437"> </a>Prototype 
</h4>
<pre class="proto"><a name="1000438"></a>void setprotoent (
   int <code class="par">stayopen</code>
)
</pre>
<h4>
  <a name="1000439"> </a>Parameters 
</h4>

<dl>
<dt><a name="1000440"> </a><code>&rarr;  <i>stayopen</i></code></dt>
<dd><a name="1000441"> </a>If non-zero, the network database is not closed after each call to <code>getprotobyname()</code> or <code>getprotobynumber()</code>.</dd>

</dl>
<h4>
  <a name="1000450"> </a>See Also 
</h4>

<p><a name="1000457"> </a><a href="LowLevelComms_SockRef.html#999729"><code>getprotobyname()</code></a>, <a href="LowLevelComms_SockRef.html#999753"><code>getprotobynumber()</code></a></p>

<h3 class="hbH3">
  <a name="1000460"> </a>setservent Function <a href="#608590"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="1000462"> </a>Purpose 
</h4>

<p><a name="1000464"> </a>Opens and rewinds a file.</p>
<h4>
  <a name="1000465"> </a>Declared In 
</h4>
<code>posix/netdb.h<a name="1000466"> </a></code><h4>
  <a name="1000467"> </a>Prototype 
</h4>
<pre class="proto"><a name="1000468"></a>void setservent (
   int <code class="par">stayopen</code>
)
</pre>
<h4>
  <a name="1000469"> </a>Parameters 
</h4>

<dl>
<dt><a name="1000470"> </a><code>&rarr;  <i>stayopen</i></code></dt>
<dd><a name="1000471"> </a>If non-zero, the network database is not closed after each call to <code>getservbyname()</code> or <code>getservbyport()</code>.</dd>

</dl>
<h4>
  <a name="1000480"> </a>See Also 
</h4>

<p><a name="1000487"> </a><a href="LowLevelComms_SockRef.html#999805"><code>getservbyname()</code></a>, <a href="LowLevelComms_SockRef.html#999831"><code>getservbyport()</code></a></p>

<h3 class="hbH3">
  <a name="993920"> </a>setsockopt Function <a href="#608590"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="993922"> </a>Purpose 
</h4>

<p><a name="993924"> </a>Sets options on sockets.</p>
<h4>
  <a name="993925"> </a>Declared In 
</h4>
<code>posix/sys/socket.h<a name="993926"> </a></code><h4>
  <a name="993927"> </a>Prototype 
</h4>
<pre class="proto"><a name="993928"></a>int setsockopt (
   int <code class="par">sock</code>,
   int <code class="par">level</code>,
   int <code class="par">option</code>,
   const void *<code class="par">optval</code>,
   socklen_t <code class="par">optlen</code>
)
</pre>
<h4>
  <a name="993929"> </a>Parameters 
</h4>

<dl>
<dt><a name="993930"> </a><code>&rarr;  <i>sock</i></code></dt>
<dd><a name="993931"> </a>A socket.</dd>

<dt><a name="993932"> </a><code>&rarr;  <i>level</i></code></dt>
<dd><a name="993933"> </a>To manipulate options at the socket level, <code class="par">level</code> is specified as <code>SOL_SOCKET</code>.</dd>

<dt><a name="993934"> </a><code>&rarr;  <i>option</i></code></dt>
<dd><a name="993935"> </a>Any specified option(s) passed uninterpreted to the appropriate protocol module for interpretation.</dd>

<dt><a name="993936"> </a><code>&rarr;  <i>optval</i></code></dt>
<dd><a name="993937"> </a>Used to access option values. Identifies a buffer in which the value for the requested option is returned.</dd>

<dt><a name="993938"> </a><code>&rarr;  <i>optlen</i></code></dt>
<dd><a name="993939"> </a>Used to access option values. Identifies a buffer in which the length for the requested option is returned.</dd>

</dl>
<h4>
  <a name="993940"> </a>Returns 
</h4>

<p><a name="993941"> </a>Returns zero (0) if the connection or binding is successful. Otherwise, -1 is returned and the global variable <code>errno</code> is set to indicate the error.</p>
<h4>
  <a name="993948"> </a>See Also 
</h4>

<p><a name="993961"> </a><a href="LowLevelComms_SockRef.html#999777"><code>getprotoent()</code></a>, <a href="LowLevelComms_SockRef.html#993607"><code>getsockopt()</code></a>, <a href="LowLevelComms_SockRef.html#1020910"><code>select()</code></a>, <a href="LowLevelComms_SockRef.html#993999"><code>socket()</code></a></p>

<h3 class="hbH3">
  <a name="993967"> </a>shutdown Function <a href="#608590"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="993969"> </a>Purpose 
</h4>

<p><a name="993971"> </a>Disables subsequent send and/or receive operations on a socket.</p>
<h4>
  <a name="993972"> </a>Declared In 
</h4>
<code>posix/sys/socket.h<a name="993973"> </a></code><h4>
  <a name="993974"> </a>Prototype 
</h4>
<pre class="proto"><a name="993975"></a>int shutdown (
   int <code class="par">sock</code>,
   int <code class="par">direction</code>
)
</pre>
<h4>
  <a name="993976"> </a>Parameters 
</h4>

<dl>
<dt><a name="993977"> </a><code>&rarr;  <i>sock</i></code></dt>
<dd><a name="993978"> </a>A socket.</dd>

<dt><a name="993979"> </a><code>&rarr;  <i>direction</i></code></dt>
<dd><a name="993980"> </a>Specifies the type of shutdown. The values are as follows:</dd>

<dd><a name="993981"> </a><code>SHUT_RD</code></dd>

<dd><a name="993982"> </a>	Disables further receive operations.</dd>

<dd><a name="993983"> </a><code>SHUT_WR</code></dd>

<dd><a name="993984"> </a>	Disables further send operations.</dd>

<dd><a name="993985"> </a><code>SHUT_RDWR</code></dd>

<dd><a name="993986"> </a>	Disables further send and receive operations.</dd>

</dl>
<h4>
  <a name="993987"> </a>Returns 
</h4>

<p><a name="993988"> </a>Returns zero (0) upon successful completion. Otherwise, 1 is returned and the global variable <code>errno</code> is set to indicate the error.</p>

<h3 class="hbH3">
  <a name="993999"> </a>socket Function <a href="#608590"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="994001"> </a>Purpose 
</h4>

<p><a name="994003"> </a>Creates an endpoint for communication.</p>
<h4>
  <a name="994004"> </a>Declared In 
</h4>
<code>posix/sys/socket.h<a name="994005"> </a></code><h4>
  <a name="994006"> </a>Prototype 
</h4>
<pre class="proto"><a name="994007"></a>int socket (
   int <code class="par">family</code>,
   int <code class="par">type</code>,
   int <code class="par">proto</code>
)
</pre>
<h4>
  <a name="994008"> </a>Parameters 
</h4>

<dl>
<dt><a name="994009"> </a><code>&rarr;  <i>family</i></code></dt>
<dd><a name="994010"> </a>A communications domain within which communication takes place; this selects the protocol family that should be used.</dd>

<dt><a name="994011"> </a><code>&rarr;  <i>type</i></code></dt>
<dd><a name="994012"> </a>The semantics of communication.</dd>

<dt><a name="994013"> </a><code>&rarr;  <i>proto</i></code></dt>
<dd><a name="994014"> </a>A particular protocol to be used with the socket.</dd>

</dl>
<h4>
  <a name="994015"> </a>Returns 
</h4>

<p><a name="994016"> </a>Returns a descriptor referencing the socket. Otherwise, -1 is returned and the global variable <code>errno</code> is set to indicate the error.</p>
<h4>
  <a name="994023"> </a>See Also 
</h4>

<p><a name="994027"> </a><a href="LowLevelComms_SockRef.html#993607"><code>getsockopt()</code></a></p>

<p><a name="994028"> </a></p>
&nbsp;<br>
</div>
<!--END CONTENT-->

</td>
<td width="5">&nbsp;&nbsp;</td>
</tr>

</table>

<!-- BEGIN FOOTER -->
<table width="100%" border="0" cellspacing="0" cellpadding="0">
<tr>
<td width="7" rowspan="2"><img name="index_x" src="images/shim.gif" width="7" height="33" border="0" alt=""></td>
<td align="left"><img name="dashes" src="images/dashes.gif" width="744" height="3" border="0" alt=""></td>
<td width="10" rowspan="2"><img name="index_x" src="images/shim.gif" width="10" height="33" border="0" alt=""></td>
</tr>
<tr>
<td align="center">
<p class="footer">
Copyright © 2004, PalmSource, Inc. and its affiliates.  All rights reserved. <br>
<a href="http://www.palmsource.com/contact/">Write Us</a> | <a href="http://www.palmos.com/dev/training/">Training</a> | <a href="http://www.palmos.com/dev/support/kb/">Knowledge Base</a> | <a href="LowLevelComms_Front.html" target="_blank">Legal</a></p>
<br>
<!--BEGIN BOOK NAVIGATION-->
<p class="nav">
<A href="http://www.palmos.com/dev/support/docs/">Documentation</a>&nbsp;&nbsp;|&nbsp;&nbsp;
<a href="LowLevelCommsTOC.html">Table of Contents</a>&nbsp;&nbsp;
             |&nbsp;&nbsp;<a href="LowLevelComms_SockIntro.html">&lt;&nbsp;Previous</a>&nbsp;&nbsp;
             |&nbsp;&nbsp;<a href="LowLevelComms_WiFi_Pt.html">Next&nbsp;&gt;</a>&nbsp;&nbsp;
             |&nbsp;&nbsp;<a href="LowLevelCommsIX.html">Index</a>
</p>
</td>
</tr>
</table>
<!-- END FOOTER -->

</body>
</html>