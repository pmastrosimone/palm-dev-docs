<html>
<head>
<title>(Protein) Using the IrDA Protocols | Low-Level Communications</title> 
<link href="psi_devpubs.css" rel="stylesheet" type="text/css">

<!-- BEGIN META DATA -->
<meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
<META NAME="PSITEMPLATE" CONTENT="1006-007 PalmSource_HTML_2003 20041101">
<META NAME="GENERATOR" CONTENT="Quadralay WebWorks AutoMap 2003 for FrameMaker 8.0.6.2138">
<META NAME="LASTUPDATED" CONTENT="11/22/04 11:14:02">
<!-- END META DATA -->
</head>

<body bgcolor="#ffffff" text="#000000" leftmargin="0" topmargin="0" marginwidth="0" marginheight="0">
<a name="608590"></a>

<!-- BEGIN TOPNAV -->
<table width="100%" border="0" cellspacing="0" cellpadding="0">
<tr>
<td><img src="images/shim.gif" width="7" height="75" border="0" alt=""></td>
<td align="left"><table border="0" cellpadding="0" cellspacing="0" width="744">
<tr>
<td><img name="index_r2_c1" src="images/shim.gif" width="25" height="75" border="0" alt=""></td>
<td valign="top"><table border="0" cellpadding="0" cellspacing="0" width="96">
<tr>
<td><img name="index_r2_c4" src="images/shim.gif" width="96" height="15" border="0" alt=""></td>
</tr>
<tr>
<td><a href="http://www.palmsource.com/"><img name="ps_logo" src="images/ps_logo.gif" width="96" height="54" border="0" alt=""></a></td>
</tr>

</table>
</td>

<td><table border="0" cellpadding="0" cellspacing="0" width="30">
<td><img name="index_x" src="images/shim.gif" width="30" height="75" border="0" alt=""></td>
</table></td>

<!--BEGIN MASTHEAD-->
<td><table border="0" cellpadding="0" cellspacing="0" width="96">
<tr>
<td><img name="index_x" src="images/shim.gif" width="615" height="5" border="0" alt=""></td>
</tr>
<tr>
<td>
<!--BEGIN BOOK NAVIGATION-->
<span class="nav">
<A href="http://www.palmos.com/dev/support/docs/">Documentation</a>&nbsp;&nbsp;|&nbsp;&nbsp;
<a href="LowLevelCommsTOC.html">Table of Contents</a>&nbsp;&nbsp;
             |&nbsp;&nbsp;<a href="LowLevelComms_IrStack.html">&lt;&nbsp;Previous</a>&nbsp;&nbsp;
             |&nbsp;&nbsp;<a href="LowLevelComms_IrRef.html">Next&nbsp;&gt;</a>&nbsp;&nbsp;
             |&nbsp;&nbsp;<a href="LowLevelCommsIX.html">Index</a>
</span>
<!--END BOOK NAVIGATION-->
</tr>
<tr>
<td>
<!--BEGIN PAGE TITLE-->
<h2 class="PageTitle">8 &nbsp;&nbsp;
Using the IrDA Protocols</h2></td>
<!--END PAGE TITLE-->
</tr>
<tr>
<td>
<!--BEGIN BOOK TITLE-->
<p class="BookTitle">Low-Level Communications</p>
<p class="SubTitle">Exploring Palm OS&#174; </p>
<!--END BOOK TITLE-->
</td>
</tr>
<tr>
<td><img name="index_x" src="images/shim.gif" width="615" height="5" border="0" alt=""></td>
</tr>
</table>
</td>
<!--END MASTHEAD-->
</tr>
</table>
<img name="dashes" src="images/dashes.gif" width="744" height="3" border="0" alt=""></td>
</tr>
</table>
<!-- END TOPNAV -->

<table width="100%" border="0" cellspacing="0" cellpadding="0">
<tr>
<td valign="top" width="5"><img name="index_x" src="images/shim.gif" width="5" height="33" border="0" alt=""></td>

<!--BEGIN SIDETOC-->
<td valign="top" width="175">
<div id="sidetoc" valign="bottom">
<h1 class="SideTOC1-PartTab"><a href="LowLevelComms_IR_Pt.html">Part II: Infrared Communication (Beaming)</a> </h1>
<h1 class="SideTOC1"><a href="LowLevelComms_IrProtocols.html">8  Using the IrDA Protocols</a></h1>

   <h2 class="SideTOC2"><a href="#993050">
   The IrLAP Protocol Layer</a></h2>

   <h2 class="SideTOC2"><a href="#993212">
   The IrLMP Protocol Layer</a></h2>

      <h3 class="SideTOC3"><a href="#993359">
      The IrLMP Sequenced Packet Interface</a></h3>

      <h3 class="SideTOC3"><a href="#993228">
      The IrLMP Datagram Interface</a></h3>

      <h3 class="SideTOC3"><a href="#993253">
      Discovering IrDA Devices</a></h3>

   <h2 class="SideTOC2"><a href="#993240">
   The TinyTP Protocol Layer</a></h2>

      <h3 class="SideTOC3"><a href="#993249">
      The TinyTP Sequenced Packet Interface</a></h3>

      <h3 class="SideTOC3"><a href="#993246">
      The TinyTP Stream Interface</a></h3>

   <h2 class="SideTOC2"><a href="#993883">
   Getting and Providing Information About IrDA Services</a></h2>

      <h3 class="SideTOC3"><a href="#993892">
      Structure of the IAS Database</a></h3>

      <h3 class="SideTOC3"><a href="#993960">
      Getting Information about IrDA Services</a></h3>

      <h3 class="SideTOC3"><a href="#993946">
      Providing Information About Offered IrDA Services</a></h3>

</div>
</td>

<td width="5">&nbsp;&nbsp;</td>
<td width="2" background="images/index_r8_c10.gif"><img src="images/shim.gif" width="2" height="75" border="0" alt=""></td>
<td width="5">&nbsp;&nbsp;</td>

<!--END SIDETOC-->

<td valign="top">

<!--BEGIN CONTENT-->
<div id="content" valign="bottom">
<h2 class="haH2">
  <a name="993050"> </a>The IrLAP Protocol Layer <a href="#608590"><span class="nav">^TOP^</span></a>
</h2>


<p><a name="993203"> </a>IrLAP, the <b>Infrared Link Access Protocol</b>, lies at the bottom of the IrDA protocol stack. It provides a reliable, sequenced exchange of frames between two IrDA-capable devices, as well as a process for detecting (or "discovering") other nearby IrDA devices.</p>

<p><a name="993211"> </a>Palm OS<sup>&#174;</sup> Cobaltdoes not allow applications to directly interface with the IrLAP protocol layer. IrLAP connections and discoveries are managed entirely by the IrLMP protocol.</p>

<h2 class="haH2">
  <a name="993212"> </a>The IrLMP Protocol Layer <a href="#608590"><span class="nav">^TOP^</span></a>
</h2>


<p><a name="993214"> </a>The IrLMP (<b>Infrared Link Management Protocol</b>) layer sits just above IrLAP in the IrDA protocol stack. It serves as a multiplexer on an IrLAP connection, allowing multiple concurrent "conversations" between a pair of connected devices. Each conversation consists of a sequenced stream of reliably-delivered messages; the messages are guaranteed to be delivered to applications in the same order in which they were sent. Message boundaries are preserved.</p>

<p><a name="993351"> </a>In addition, IrLMP provides an exclusive mode, in which a single conversation can take full control of the underlying IrLAP connection, locking out all others. This is useful for applications that require a reduced-latency connection. Exclusive mode can be controlled using the <code>SO_IREXCLUSIVE</code> <code>setsockopt()</code> command.</p>
<h3 class="hbH3">
  <a name="993359"> </a>The IrLMP Sequenced Packet Interface <a href="#608590"><span class="nav">^TOP^</span></a>
</h3>


<p><a name="993344"> </a>The IrLMP sequenced packet interface does not provide any segmentation or reassembly of large messages, so the maximum size of incoming and outgoing messages is limited to the data sizes negotiated during the establishment of the IrLAP connection. IrLMP also provides no end-to-end flow control; when data is sent through an IrLMP socket faster than it can be consumed at the other end, messages will be discarded by the receiver's IrLMP protocol, thereby being lost to the receiving application.</p>

<p><a name="993475"> </a><a href="LowLevelComms_IrProtocols.html#993360">Listing 8.1</a> demonstrates how to create and use IrDA socket connections. This example creates a socket and listens for an incoming connection. Once a connection is initiated, the code creates a new socket for sending data to the remote device. Once that's been done, the code makes the first socket idle by calling <code>setsockopt()</code> with the <code>SO_IRIDLE</code> command, gives the new socket exclusive control with the <code>SO_IREXCLUSIVE</code> command, and transmits data.</p>

<p><a name="993530"> </a>Once the data has been transmitted, the data transfer socket is closed and the control socket is reactivated.</p>
<p class="CCodeCaption">
  <a name="993360"> </a><b>Listing 8.1&nbsp;&nbsp;Creating and using IrDA socket connections</b>
</p>

<div class="CodeRule"><hr></div><pre class="CodeBlock">
int s1, s2, s3;<a name="993370"> </a>
struct sockaddr_irda addr;<a name="993371"> </a>
int mtu, len;<a name="993372"> </a>
char *buf;<a name="993373"> </a>
int zero = 0;<a name="993374"> </a>
int one = 1;<a name="993375"> </a>
<a name="993376"> </a>
// create an IrLMP socket, and wait for someone to call us<a name="993377"> </a>
s1 = socket(AF_IRDA, SOCK_SEQPACKET, IRPROTO_LMP);<a name="993378"> </a>
<a name="993379"> </a>
memset(&amp;addr, 0, sizeof(addr));<a name="993380"> </a>
addr.sir_family = AF_IRDA;<a name="993381"> </a>
addr.sir_lsap = 0x69;<a name="993382"> </a>
<a name="993383"> </a>
bind(s1, (struct sockaddr *)&amp;addr, sizeof(addr));<a name="993384"> </a>
listen(s1, 1);<a name="993385"> </a>
s2 = accept(s1, NULL, NULL);<a name="993386"> </a>
<a name="993387"> </a>
// initiate another IrLMP socket connection to our caller<a name="993388"> </a>
s3 = socket(AF_IRDA, SOCK_SEQPACKET, IRPROTO_LMP);<a name="993389"> </a>
<a name="993390"> </a>
addr.sir_lsap = 0x12;<a name="993391"> </a>
addr.sir_addr = IRADDR_ANY;<a name="993392"> </a>
connect(s3, (struct sockaddr *)&amp;addr, sizeof(addr));<a name="993393"> </a>
<a name="993394"> </a>
// mark first connection idle<a name="993395"> </a>
setsockopt(s2, SOL_SOCKET, SO_IRIDLE, (const char *)&amp;one, sizeof(one));<a name="993396"> </a>
<a name="993397"> </a>
// take exclusive control of IrLAP connection<a name="993398"> </a>
setsockopt(s3, SOL_SOCKET, SO_IREXCLUSIVE, (const char *)&amp;one, sizeof(one));<a name="993399"> </a>
<a name="993400"> </a>
// send a maximum-sized message<a name="993401"> </a>
len = sizeof(mtu);<a name="993402"> </a>
getsockopt(s3, SOL_SOCKET, SO_IRMTU, (const char *)&amp;mtu, &amp;len);<a name="993403"> </a>
buf = malloc(mtu);<a name="993404"> </a>
memset(buf, 0xff, mtu);<a name="993405"> </a>
send(s3, buf, mtu, 0);<a name="993406"> </a>
<a name="993407"> </a>
// close second connection, thereby relinquishing exclusive control<a name="993408"> </a>
close(s3);<a name="993409"> </a>
<a name="993410"> </a>
// the first connection can now become active<a name="993411"> </a>
setsockopt(s2, SOL_SOCKET, SO_IRIDLE, (const char *)&amp;zero, sizeof(zero));<a name="993412"> </a>
</pre><div class="CodeRule"><hr></div>

<h3 class="hbH3">
  <a name="993228"> </a>The IrLMP Datagram Interface <a href="#608590"><span class="nav">^TOP^</span></a>
</h3>


<p><a name="993229"> </a>IrLMP provides a datagram interface for connectionless data exchange. Datagram messages are sent unreliably; it is not possible for the sending application to be certain that any other device has received a sent message. Additionally, datagram messages are always broadcast, so they may be received by any and all IrDA-capable devices within range of the sending device.</p>

<p><a name="993659"> </a><a href="LowLevelComms_IrProtocols.html#993552">Listing 8.2</a> demonstrates how to broadcast a datagram and wait for a reply.</p>
<p class="CCodeCaption">
  <a name="993552"> </a><b>Listing 8.2&nbsp;&nbsp;Broadcasting a datagram message</b>
</p>

<div class="CodeRule"><hr></div><pre class="CodeBlock">
int s;<a name="993569"> </a>
sockaddr_irda addr;<a name="993570"> </a>
char buf[40];<a name="993571"> </a>
int len;<a name="993572"> </a>
<a name="993573"> </a>
// create IrLMP datagram socket<a name="993574"> </a>
s = socket(AF_IRDA, SOCK_DGRAM, 0);<a name="993575"> </a>
<a name="993576"> </a>
// bind to IrLMP's connectionless SAP<a name="993577"> </a>
memset(&amp;addr, 0, sizeof(addr));<a name="993578"> </a>
addr.sir_family = AF_IRDA;<a name="993579"> </a>
addr.sir_lsap = irLsapUnitdata;<a name="993580"> </a>
if (bind(s, (struct sockaddr *)&amp;addr, sizeof(addr)) != 0) {<a name="993581"> </a>
	// another application beat us to it<a name="993582"> </a>
	return;<a name="993583"> </a>
}<a name="993584"> </a>
<a name="993585"> </a>
// broadcast datagram<a name="993586"> </a>
memset(&amp;buf, 0x69, sizeof(buf));<a name="993587"> </a>
addr.sir_addr = IRADDR_BROADCAST;<a name="993588"> </a>
sendto(s, buf, sizeof(buf), 0, (struct sockaddr *)&amp;addr, sizeof(addr));<a name="993589"> </a>
<a name="993590"> </a>
// listen for response<a name="993591"> </a>
len = sizeof(addr);<a name="993592"> </a>
recvfrom(s, buf, sizeof(buf), 0, (struct sockaddr *)&amp;addr, &amp;len);<a name="993593"> </a>
</pre><div class="CodeRule"><hr></div>

<h3 class="hbH3">
  <a name="993253"> </a>Discovering IrDA Devices <a href="#608590"><span class="nav">^TOP^</span></a>
</h3>


<p><a name="993258"> </a>Before you can establish a connection to an IrDA device, you have to find it. This is done by discovering the available devices via the <a href="LowLevelComms_IrRef.html#1006240"><code>IrDADiscoverDevices()</code></a> function in the IrDALib shared library. The sample code in <a href="LowLevelComms_IrProtocols.html#993261">Listing 8.3</a> demonstrates this process.</p>
<p class="CCodeCaption">
  <a name="993261"> </a><b>Listing 8.3&nbsp;&nbsp;Discovery of IrDA devices</b>
</p>

<div class="CodeRule"><hr></div><pre class="CodeBlock">
	int s;<a name="993262"> </a>
	uint32_t nLogs;<a name="993263"> </a>
	IrLmpDeviceInfoType logs[2];<a name="993264"> </a>
	Boolean cached;<a name="993265"> </a>
	int i, j;<a name="993266"> </a>
	struct sockaddr_irda addr;<a name="993267"> </a>
<a name="993268"> </a>
	// perform discovery<a name="993269"> </a>
	nLogs = 2;<a name="993270"> </a>
	IrDADiscoverDevices(&amp;nLogs, logs, &amp;cached));<a name="993271"> </a>
<a name="993272"> </a>
	printf("discovery found %d %sdevices:\n", nLogs, (cached ? "cached " : ""));<a name="993273"> </a>
	for (i = 0; i &lt; nLogs; i++) {<a name="993274"> </a>
		printf("   %08x ", logs[i].deviceAddr);<a name="993275"> </a>
		switch (logs[i].method) {<a name="993276"> </a>
		case kIirLmpSniffing:<a name="993277"> </a>
			printf("sniffed");<a name="993278"> </a>
			break;<a name="993279"> </a>
		<a name="993280"> </a>
		case kIirLmpActiveDiscovery:<a name="993281"> </a>
			printf("discovered");<a name="993282"> </a>
			break;<a name="993283"> </a>
		<a name="993284"> </a>
		case kIirLmpPassiveDiscovery:<a name="993285"> </a>
			printf("found us");<a name="993286"> </a>
			break;<a name="993287"> </a>
		}<a name="993288"> </a>
<a name="993289"> </a>
		printf(" %d bytes of device info: ", logs[i].infoLen);<a name="993290"> </a>
		for (j = 0; j &lt; logs[i].infoLen; j++)<a name="993291"> </a>
			printf("%c", logs[i].deviceInfo[j]);<a name="993292"> </a>
		printf("\n");<a name="993293"> </a>
	}<a name="993294"> </a>
<a name="993295"> </a>
	if (nLogs == 0) {<a name="993296"> </a>
		printf("found no devices - aborting test\n");<a name="993297"> </a>
		return;<a name="993298"> </a>
	}<a name="993299"> </a>
<a name="993300"> </a>
	// open irlmp socket<a name="993301"> </a>
	s = socket(AF_IRDA, SOCK_STREAM, 0);<a name="993302"> </a>
	<a name="993303"> </a>
	// connect to first device discovered<a name="993304"> </a>
	memset(&amp;addr, 0, sizeof(addr));<a name="993305"> </a>
	addr.sir_family = AF_IRDA;<a name="993306"> </a>
	strcpy(addr.sir_name, "OBEX");<a name="994300"> </a>
	addr.sir_addr = logs[0].deviceAddr;<a name="993307"> </a>
<a name="993309"> </a>
	connect(s, (struct sockaddr *)&amp;addr, sizeof(addr));<a name="993310"> </a>
</pre><div class="CodeRule"><hr></div>


<p><a name="993337"> </a>This code discovers the available devices, printing out information about them, then connects to the first device discovered by creating a new socket and connecting to the socket using OBEX on a STREAM based socket.</p>

<h2 class="haH2">
  <a name="993240"> </a>The TinyTP Protocol Layer <a href="#608590"><span class="nav">^TOP^</span></a>
</h2>

<h3 class="hbH3">
  <a name="993249"> </a>The TinyTP Sequenced Packet Interface <a href="#608590"><span class="nav">^TOP^</span></a>
</h3>


<p><a name="993242"> </a>The <b>Tiny Transport Protocol</b> (TinyTP) sits on top of IrLMP in the IrDA protocol stack. It builds upon the functionality of the IrLMP sequenced packet interface by providing segmentation and reassembly of large messages, as well as end-to-end flow control for individual IrLMP connections.</p>

<p><a name="993782"> </a>The code in <a href="LowLevelComms_IrProtocols.html#993664">Listing 8.4</a> shows how to create a socket to listen for a sequenced TinyTP connection, enable automatic reassembly of incoming messages, determine the connection's MTU, and mark the control socket as idle. Once this code is done executing, it's time to transfer data as seen in <a href="LowLevelComms_IrProtocols.html#993360">Listing 8.1</a>.</p>
<p class="CCodeCaption">
  <a name="993664"> </a><b>Listing 8.4&nbsp;&nbsp;Setting up a TinyTP sequenced packet connection</b>
</p>

<div class="CodeRule"><hr></div><pre class="CodeBlock">
int s1, s2;<a name="993694"> </a>
struct sockaddr_irda addr;<a name="993695"> </a>
int mru, mtu, len;<a name="993696"> </a>
int one = 1;<a name="993697"> </a>
<a name="993698"> </a>
// create sequenced TTP socket<a name="993699"> </a>
s1 = socket(AF_IRDA, SOCK_SEQPACKET, 0);<a name="993700"> </a>
<a name="993701"> </a>
// bind to well-known lsap<a name="993702"> </a>
memset(&amp;addr, 0, sizeof(addr));<a name="993703"> </a>
addr.sir_family = AF_IRDA;<a name="993704"> </a>
addr.sir_lsap = irLsapAny;<a name="993705"> </a>
strncpy(addr.sir_name, "IrTest", sizeof(addr.sir_name));<a name="993706"> </a>
bind(s1, (struct sockaddr *)&amp;addr, sizeof(addr));<a name="993707"> </a>
<a name="993708"> </a>
// enable automatic re-assembly of incoming messages<a name="993709"> </a>
mru = 2345;<a name="993710"> </a>
setsockopt(s1, SO_IRMRU, (const char *)&amp;mru, sizeof(mru));<a name="993711"> </a>
<a name="993712"> </a>
// wait for someone to connect to us<a name="993713"> </a>
listen(s1, 1);<a name="993714"> </a>
s2 = accept(s1, NULL, NULL);<a name="993715"> </a>
<a name="993716"> </a>
// retrieve connection MTU<a name="993717"> </a>
len = sizeof(mtu);<a name="993718"> </a>
getsockopt(s2, SOL_SOCKET, SO_IRMTU, (const char *)&amp;mtu, &amp;len);<a name="993719"> </a>
<a name="993720"> </a>
// mark connection idle<a name="993721"> </a>
setsockopt(s2, SOL_SOCKET, SO_IRIDLE, (const char *)&amp;one, sizeof(one));<a name="993722"> </a>
</pre><div class="CodeRule"><hr></div>

<h3 class="hbH3">
  <a name="993246"> </a>The TinyTP Stream Interface <a href="#608590"><span class="nav">^TOP^</span></a>
</h3>


<p><a name="993250"> </a>In addition to the sequenced packet interface, TinyTP provides a stream interface, in which it manages all aspects of segmentation and reassembly for the application. Applications can ignore the TinyTP MTU negotiated for the connection and send messages of any length. The TinyTP stream interface will take care of segmenting them as necessary, so attempting to send a message larger than the MTU will not result in failure.</p>

<div><hr>
  <a name="993251"> </a> <b>NOTE: </b> When using the TinyTP stream interface, message boundaries are not preserved end-to-end. The TinyTP protocol module may break messages into multiple pieces, or combine multiple small messages into a single larger message.
<hr>
</div>

<p><a name="993878"> </a>This is the easiest way to send data, as you can see from <a href="LowLevelComms_IrProtocols.html#993252">Listing 8.5</a>. All you do is open the connection and send and receive data on it. No worrying about packet sizes or sequencing; it just works.</p>
<p class="CCodeCaption">
  <a name="993252"> </a><b>Listing 8.5&nbsp;&nbsp;Sending and receiving data using a TinyTP stream</b>
</p>

<div class="CodeRule"><hr></div><pre class="CodeBlock">
int s;<a name="993809"> </a>
struct sockaddr_irda addr;<a name="993810"> </a>
int mtu, len;<a name="993811"> </a>
char *buf;<a name="993812"> </a>
int i;<a name="993813"> </a>
char c;<a name="993814"> </a>
<a name="993815"> </a>
// create TinyTP stream socket<a name="993816"> </a>
s = socket(AF_IRDA, SOCK_STREAM, IRPROTO_TTP);<a name="993817"> </a>
<a name="993818"> </a>
// connect to anyone<a name="993819"> </a>
memset(&amp;addr, 0, sizeof(addr));<a name="993820"> </a>
addr.sir_family = AF_IRDA;<a name="993821"> </a>
strncpy(addr.sir_name, "IrTest", sizeof(addr.sir_name));<a name="993823"> </a>
addr.sir_addr = IRADDR_BROADCAST;<a name="993824"> </a>
connect(s, (struct sockaddr *)&amp;addr, sizeof(addr));<a name="993825"> </a>
<a name="993826"> </a>
// retrieve connection MTU<a name="993827"> </a>
len = sizeof(mtu);<a name="993828"> </a>
getsockopt(s, SOL_SOCKET, SO_IRMTU, (const char *)&amp;mtu, &amp;len);<a name="993829"> </a>
<a name="993830"> </a>
// send lots of data<a name="993831"> </a>
buf = malloc(mtu * 2);<a name="993832"> </a>
memset(buf, 0x69, mtu * 2);<a name="993833"> </a>
send(s, buf, mtu * 2, 0);<a name="993834"> </a>
<a name="993835"> </a>
// read response<a name="993836"> </a>
for (i = 0; i &lt; 200; i++)<a name="993837"> </a>
	recv(s, &amp;c, sizeof(c), 0);<a name="993838"> </a>
</pre><div class="CodeRule"><hr></div>


<h2 class="haH2">
  <a name="993883"> </a>Getting and Providing Information About IrDA Services <a href="#608590"><span class="nav">^TOP^</span></a>
</h2>


<p><a name="993890"> </a>Every device with an IrDA protocol stack includes the <b>Information Access Service</b> (IAS), which consists of a directory listing all of the IrDA services that the device offers, as well as server software that allows other devices to access this directory. The IAS query interface provides a method for discovering services offered by a remote device, by querying its IAS directory server.</p>
<h3 class="hbH3">
  <a name="993892"> </a>Structure of the IAS Database <a href="#608590"><span class="nav">^TOP^</span></a>
</h3>


<p><a name="993893"> </a>Entries in the IAS database consist of IAS objects, each of which describes a single service offered by the device. These objects consist of sets of attributes, typed name-value pairs containing specific information about the service. Additionally, each object contains a class name, which is a string that describes the object's type. The type indicates what attributes the object includes.</p>
<h3 class="hbH3">
  <a name="993960"> </a>Getting Information about IrDA Services <a href="#608590"><span class="nav">^TOP^</span></a>
</h3>


<p><a name="993894"> </a>The <a href="LowLevelComms_IrRef.html#1006244"><code>IASGetValueByClass()</code></a> function lets an application ask a remote device for attribute values with a given name belonging to a given class. The <code>connect()</code> and <code>bind()</code> functions automatically handle some aspects of IAS and provide a simplified interface to it, as shown in <a href="LowLevelComms_IrProtocols.html#993212">"The IrLMP Protocol Layer"</a>.</p>
<p class="CCodeCaption">
  <a name="993899"> </a><b>Listing 8.6&nbsp;&nbsp;Querying IAS</b>
</p>

<div class="CodeRule"><hr></div><pre class="CodeBlock">
IASQueryType query;<a name="993905"> </a>
uint8_t buffer[256];<a name="993906"> </a>
<a name="993907"> </a>
// look for an IrOBEX server on any remote device (the class and attribute<a name="993908"> </a>
// names are well-known, specified by the IrOBEX standard document)<a name="993909"> </a>
query.addr = IRADDR_BROADCAST;<a name="993910"> </a>
query.className = "OBEX";<a name="993911"> </a>
query.attribName = "IrDA:TinyTP:LsapSel";<a name="993912"> </a>
query.resultBuf = buffer;<a name="993913"> </a>
query.resultBufLen = sizeof(buffer);<a name="993914"> </a>
if (IASQueryValueByClass(&amp;query) == errNone &amp;&amp;<a name="993915"> </a>
    query.attribCount &gt; 0 &amp;&amp;<a name="993916"> </a>
    query.attribValues[0]-&gt;attribType == kIASiasAttribIntegerAttrib)<a name="993917"> </a>
{<a name="993918"> </a>
	printf("Found IrOBEX server on device %08lx, at LSAP %04x\n",<a name="993919"> </a>
			query.addr, query.attribValues[0]-&gt;value.integer);<a name="993920"> </a>
}<a name="993921"> </a>
</pre><div class="CodeRule"><hr></div>

<h3 class="hbH3">
  <a name="993946"> </a>Providing Information About Offered IrDA Services <a href="#608590"><span class="nav">^TOP^</span></a>
</h3>


<p><a name="993961"> </a>To advertise the existence of an IrDA service, an application needs to add the service to its IAS directory. This can be done using the <code>bind()</code> function, which automatically creates the IAS entry, or manually as shown in <a href="LowLevelComms_IrProtocols.html#993962">Listing 8.7</a>.</p>

<p><a name="994039"> </a>The <a href="LowLevelComms_IrRef.html#1007517"><code>IASRegisterObject()</code></a> function associates an IAS service entry with an IrDA socket. This is generally used by a server application to inform remote devices of the location and type of services the application offers. The function returns an object ID that uniquely identifies the object. This object ID can be used to unregister the service later through a call to <a href="LowLevelComms_IrRef.html#1008348"><code>IASUnregisterObject()</code></a>.</p>

<p><a name="994048"> </a>An easier method of associating a service name with a server socket is provided by the <a href="LowLevelComms_IrRef.html#1008111"><code>IASRegisterService()</code></a> function. This function creates an IAS entry of a service class specified when calling it, containing a single entry specifying the LSAP address of the specified socket. This attribute's name will correctly reflect the type of socket. For example, if a TinyTP socket is specified, the attribute's name will be "<code>IrDA:TinyTP:LsapSel</code>".</p>

<p><a name="994047"> </a>Once registered, a service entry remains in the device's IAS database until either the socket with which it is associated is unbound, or the <code>IASUnregisterObject()</code> function is called with its ID.</p>
<p class="CCodeCaption">
  <a name="993962"> </a><b>Listing 8.7&nbsp;&nbsp;Registering a service with IAS</b>
</p>

<div class="CodeRule"><hr></div><pre class="CodeBlock">
#define N_ATTRIBS 2<a name="993968"> </a>
IASObjectType obj;<a name="993969"> </a>
const char *names[N_ATTRIBS]  = {<a name="993970"> </a>
	"IrDA:IrLMP:InstanceName",<a name="993971"> </a>
	"IrDA:IrLMP:LsapSel"<a name="993972"> </a>
};<a name="993973"> </a>
IASAttribValueType *values[N_ATTRIBS];<a name="993974"> </a>
uint8_t buf1[10], buf2[20];<a name="993975"> </a>
<a name="993976"> </a>
// fill out attribute values<a name="993977"> </a>
values[0] = (IASAttribValueType *)buf1;<a name="993978"> </a>
values[0]-&gt;attribType = iasAttribInteger;<a name="993979"> </a>
values[0]-&gt;value.integer = &lt;listener socket's LSAP&gt;;<a name="993980"> </a>
<a name="993981"> </a>
values[1] = (IASAttribValueType *)buf2;<a name="993982"> </a>
values[1]-&gt;attribType = kIASiasAttribUserStringAttrib;<a name="993983"> </a>
values[1]-&gt;value.userString.charSet = iasAttribUserString;<a name="993984"> </a>
strcpy(values[1]-&gt;value.userString.chars, "Bar");<a name="993985"> </a>
<a name="993986"> </a>
// advertise service on our listener socket<a name="993987"> </a>
obj.className = "Foo";<a name="993988"> </a>
obj.attribCount = N_ATTRIBS;<a name="993989"> </a>
obj.attribNames = names;<a name="993990"> </a>
obj.attribValues = values;<a name="993991"> </a>
if (IASRegisterObject(&lt;listener socket&gt;, &amp;obj, false) == errNone) {<a name="993992"> </a>
	// our object is now in this device's IAS information base, and will<a name="993993"> </a>
	// remain there until &lt;listener socket&gt; is closed<a name="993994"> </a>
}<a name="993964"> </a>
</pre><div class="CodeRule"><hr></div>


<p><a name="994006"> </a>This code creates an array of IAS attribute structures (of type <a href="LowLevelComms_IrRef.html#1002174"><code>IASAttribValueType</code></a>) and fills each of them out with information describing the attribute. It then sets up an IAS object (of type <a href="LowLevelComms_IrRef.html#1004559"><code>IASObjectType</code></a>) and calls <a href="LowLevelComms_IrRef.html#1007517"><code>IASRegisterObject()</code></a> to register the service.</p>
&nbsp;<br>
</div>
<!--END CONTENT-->

</td>
<td width="5">&nbsp;&nbsp;</td>
</tr>

</table>

<!-- BEGIN FOOTER -->
<table width="100%" border="0" cellspacing="0" cellpadding="0">
<tr>
<td width="7" rowspan="2"><img name="index_x" src="images/shim.gif" width="7" height="33" border="0" alt=""></td>
<td align="left"><img name="dashes" src="images/dashes.gif" width="744" height="3" border="0" alt=""></td>
<td width="10" rowspan="2"><img name="index_x" src="images/shim.gif" width="10" height="33" border="0" alt=""></td>
</tr>
<tr>
<td align="center">
<p class="footer">
Copyright © 2004, PalmSource, Inc. and its affiliates.  All rights reserved. <br>
<a href="http://www.palmsource.com/contact/">Write Us</a> | <a href="http://www.palmos.com/dev/training/">Training</a> | <a href="http://www.palmos.com/dev/support/kb/">Knowledge Base</a> | <a href="LowLevelComms_Front.html" target="_blank">Legal</a></p>
<br>
<!--BEGIN BOOK NAVIGATION-->
<p class="nav">
<A href="http://www.palmos.com/dev/support/docs/">Documentation</a>&nbsp;&nbsp;|&nbsp;&nbsp;
<a href="LowLevelCommsTOC.html">Table of Contents</a>&nbsp;&nbsp;
             |&nbsp;&nbsp;<a href="LowLevelComms_IrStack.html">&lt;&nbsp;Previous</a>&nbsp;&nbsp;
             |&nbsp;&nbsp;<a href="LowLevelComms_IrRef.html">Next&nbsp;&gt;</a>&nbsp;&nbsp;
             |&nbsp;&nbsp;<a href="LowLevelCommsIX.html">Index</a>
</p>
</td>
</tr>
</table>
<!-- END FOOTER -->

</body>
</html>