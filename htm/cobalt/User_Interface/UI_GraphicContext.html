<html>
<head>
<title>(Protein) Graphics Context Reference | User Interface </title> 
<link href="psi_devpubs.css" rel="stylesheet" type="text/css">

<!-- BEGIN META DATA -->
<meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
<META NAME="PSITEMPLATE" CONTENT="1006-007 PalmSource_HTML_2003 20041101">
<META NAME="GENERATOR" CONTENT="Quadralay WebWorks AutoMap 2003 for FrameMaker 8.0.6.2138">
<META NAME="LASTUPDATED" CONTENT="11/22/04 12:08:03">
<!-- END META DATA -->
</head>

<body bgcolor="#ffffff" text="#000000" leftmargin="0" topmargin="0" marginwidth="0" marginheight="0">
<a name="608590"></a>

<!-- BEGIN TOPNAV -->
<table width="100%" border="0" cellspacing="0" cellpadding="0">
<tr>
<td><img src="images/shim.gif" width="7" height="75" border="0" alt=""></td>
<td align="left"><table border="0" cellpadding="0" cellspacing="0" width="744">
<tr>
<td><img name="index_r2_c1" src="images/shim.gif" width="25" height="75" border="0" alt=""></td>
<td valign="top"><table border="0" cellpadding="0" cellspacing="0" width="96">
<tr>
<td><img name="index_r2_c4" src="images/shim.gif" width="96" height="15" border="0" alt=""></td>
</tr>
<tr>
<td><a href="http://www.palmsource.com/"><img name="ps_logo" src="images/ps_logo.gif" width="96" height="54" border="0" alt=""></a></td>
</tr>

</table>
</td>

<td><table border="0" cellpadding="0" cellspacing="0" width="30">
<td><img name="index_x" src="images/shim.gif" width="30" height="75" border="0" alt=""></td>
</table></td>

<!--BEGIN MASTHEAD-->
<td><table border="0" cellpadding="0" cellspacing="0" width="96">
<tr>
<td><img name="index_x" src="images/shim.gif" width="615" height="5" border="0" alt=""></td>
</tr>
<tr>
<td>
<!--BEGIN BOOK NAVIGATION-->
<span class="nav">
<A href="http://www.palmos.com/dev/support/docs/">Documentation</a>&nbsp;&nbsp;|&nbsp;&nbsp;
<a href="UI_TOC.html">Table of Contents</a>&nbsp;&nbsp;
             |&nbsp;&nbsp;<a href="UI_Form.html">&lt;&nbsp;Previous</a>&nbsp;&nbsp;
             |&nbsp;&nbsp;<a href="UI_List.html">Next&nbsp;&gt;</a>&nbsp;&nbsp;
             |&nbsp;&nbsp;<a href="UI_IX.html">Index</a>
</span>
<!--END BOOK NAVIGATION-->
</tr>
<tr>
<td>
<!--BEGIN PAGE TITLE-->
<h2 class="PageTitle">21 &nbsp;&nbsp;
Graphics Context Reference</h2></td>
<!--END PAGE TITLE-->
</tr>
<tr>
<td>
<!--BEGIN BOOK TITLE-->
<p class="BookTitle">User Interface </p>
<p class="SubTitle">Exploring Palm OS&#174; </p>
<!--END BOOK TITLE-->
</td>
</tr>
<tr>
<td><img name="index_x" src="images/shim.gif" width="615" height="5" border="0" alt=""></td>
</tr>
</table>
</td>
<!--END MASTHEAD-->
</tr>
</table>
<img name="dashes" src="images/dashes.gif" width="744" height="3" border="0" alt=""></td>
</tr>
</table>
<!-- END TOPNAV -->

<table width="100%" border="0" cellspacing="0" cellpadding="0">
<tr>
<td valign="top" width="5"><img name="index_x" src="images/shim.gif" width="5" height="33" border="0" alt=""></td>

<!--BEGIN SIDETOC-->
<td valign="top" width="175">
<div id="sidetoc" valign="bottom">
<h1 class="SideTOC1-PartTab"><a href="UI_PartRef.html">Part II: Reference</a> </h1>
<h1 class="SideTOC1"><a href="UI_GraphicContext.html">21  Graphics Context Reference</a></h1>

   <h2 class="SideTOC2"><a href="#986245">
   Graphics Context Data Structures and Types</a></h2>

      <h3 class="SideTOC3"><a href="#1169790">
      GcBitmapHandle</a></h3>

      <h3 class="SideTOC3"><a href="#1169803">
      GcBitmapType</a></h3>

      <h3 class="SideTOC3"><a href="#1034953">
      GcColorType</a></h3>

      <h3 class="SideTOC3"><a href="#1170178">
      GcContextType</a></h3>

      <h3 class="SideTOC3"><a href="#993718">
      GcHandle</a></h3>

      <h3 class="SideTOC3"><a href="#992989">
      GcGradientType</a></h3>

   <h2 class="SideTOC2"><a href="#992896">
   Graphics Context Constants</a></h2>

      <h3 class="SideTOC3"><a href="#1198199">
      Bitmap Loading </a></h3>

      <h3 class="SideTOC3"><a href="#1016649">
      GcCapTag</a></h3>

      <h3 class="SideTOC3"><a href="#1017054">
      GcJoinTag</a></h3>

      <h3 class="SideTOC3"><a href="#1183201">
      Transform Indexes</a></h3>

   <h2 class="SideTOC2"><a href="#1017666">
   Graphics Context Functions</a></h2>

      <h3 class="SideTOC3"><a href="#1103458">
      GcArc</a></h3>

      <h3 class="SideTOC3"><a href="#1103512">
      GcArcTo</a></h3>

      <h3 class="SideTOC3"><a href="#1104793">
      GcBeginClip</a></h3>

      <h3 class="SideTOC3"><a href="#1106848">
      GcBezierTo</a></h3>

      <h3 class="SideTOC3"><a href="#1108164">
      GcClosePath</a></h3>

      <h3 class="SideTOC3"><a href="#1017667">
      GcCommit</a></h3>

      <h3 class="SideTOC3"><a href="#994782">
      GcCreateBitmapContext</a></h3>

      <h3 class="SideTOC3"><a href="#1170306">
      GcDrawBitmapAt</a></h3>

      <h3 class="SideTOC3"><a href="#1170627">
      GcDrawRawBitmapAt</a></h3>

      <h3 class="SideTOC3"><a href="#1196638">
      GcDrawTextAt</a></h3>

      <h3 class="SideTOC3"><a href="#1112161">
      GcEndClip</a></h3>

      <h3 class="SideTOC3"><a href="#1115387">
      GcFlush</a></h3>

      <h3 class="SideTOC3"><a href="#1198394">
      GcGetBitmapDensity</a></h3>

      <h3 class="SideTOC3"><a href="#1198411">
      GcGetBitmapDepth</a></h3>

      <h3 class="SideTOC3"><a href="#1198428">
      GcGetBitmapHeight</a></h3>

      <h3 class="SideTOC3"><a href="#1198445">
      GcGetBitmapWidth</a></h3>

      <h3 class="SideTOC3"><a href="#1114107">
      GcGetCurrentContext</a></h3>

      <h3 class="SideTOC3"><a href="#1116573">
      GcInitGradient</a></h3>

      <h3 class="SideTOC3"><a href="#1198683">
      GcIsBitmapAlphaOnly</a></h3>

      <h3 class="SideTOC3"><a href="#1118074">
      GcLineTo</a></h3>

      <h3 class="SideTOC3"><a href="#1170870">
      GcLoadBitmap</a></h3>

      <h3 class="SideTOC3"><a href="#1118101">
      GcMoveTo</a></h3>

      <h3 class="SideTOC3"><a href="#1120151">
      GcPaint</a></h3>

      <h3 class="SideTOC3"><a href="#1120182">
      GcPaintBitmap</a></h3>

      <h3 class="SideTOC3"><a href="#1121283">
      GcPopState</a></h3>

      <h3 class="SideTOC3"><a href="#1121303">
      GcPushState</a></h3>

      <h3 class="SideTOC3"><a href="#1122410">
      GcRect</a></h3>

      <h3 class="SideTOC3"><a href="#1188193">
      GcRectI</a></h3>

      <h3 class="SideTOC3"><a href="#1123136">
      GcReflect</a></h3>

      <h3 class="SideTOC3"><a href="#1171079">
      GcReleaseBitmap</a></h3>

      <h3 class="SideTOC3"><a href="#994064">
      GcReleaseContext</a></h3>

      <h3 class="SideTOC3"><a href="#1123487">
      GcRotate</a></h3>

      <h3 class="SideTOC3"><a href="#994936">
      GcRoundRect</a></h3>

      <h3 class="SideTOC3"><a href="#1124400">
      GcScale</a></h3>

      <h3 class="SideTOC3"><a href="#1147963">
      GcSetAntialiasing</a></h3>

      <h3 class="SideTOC3"><a href="#1124840">
      GcSetCaps</a></h3>

      <h3 class="SideTOC3"><a href="#1124873">
      GcSetColor</a></h3>

      <h3 class="SideTOC3"><a href="#1124904">
      GcSetCoordinateSystem</a></h3>

      <h3 class="SideTOC3"><a href="#1125325">
      GcSetFont</a></h3>

      <h3 class="SideTOC3"><a href="#1125766">
      GcSetGradient</a></h3>

      <h3 class="SideTOC3"><a href="#1125797">
      GcSetJoin</a></h3>

      <h3 class="SideTOC3"><a href="#1125827">
      GcSetPenSize</a></h3>

      <h3 class="SideTOC3"><a href="#1188452">
      GcShear</a></h3>

      <h3 class="SideTOC3"><a href="#994955">
      GcStroke</a></h3>

      <h3 class="SideTOC3"><a href="#1171204">
      GcTransform</a></h3>

      <h3 class="SideTOC3"><a href="#995590">
      GcTranslate</a></h3>

</div>
</td>

<td width="5">&nbsp;&nbsp;</td>
<td width="2" background="images/index_r8_c10.gif"><img src="images/shim.gif" width="2" height="75" border="0" alt=""></td>
<td width="5">&nbsp;&nbsp;</td>

<!--END SIDETOC-->

<td valign="top">

<!--BEGIN CONTENT-->
<div id="content" valign="bottom">
<p><a name="1083536"> </a>This chapter describes the graphics context API declared in the header file <code>GcRender.h</code>. It discusses the following topics: </p>
   <blockquote class = "bq"><a name="1083624"> </a><a href="UI_GraphicContext.html#986245">Graphics Context Data Structures and Types</a></blockquote>
   <blockquote class = "bq"><a name="1083641"> </a><a href="UI_GraphicContext.html#992896">Graphics Context Constants</a></blockquote>
   <blockquote class = "bq"><a name="1083646"> </a><a href="UI_GraphicContext.html#1017666">Graphics Context Functions</a></blockquote>

<p><a name="1083652"> </a>For more information on how to work with the graphics context, see <a href="UI_Drawing.html#1083817">Chapter 8, "Drawing,"</a> and <a href="UI_BitmapConcept.html#1005083">Chapter 9, "Working with Bitmaps."</a></p>

<h2 class="haH2">
  <a name="986245"> </a>Graphics Context Data Structures and Types <a href="#608590"><span class="nav">^TOP^</span></a>
</h2>


<h3 class="hbH3">
  <a name="1169790"> </a>GcBitmapHandle Struct <a href="#608590"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="1169792"> </a>Purpose 
</h4>

<p><a name="1178004"> </a>The handle to an internal structure that represents the bitmap. </p>
<h4>
  <a name="1169794"> </a>Declared In 
</h4>
<code>GcRender.h<a name="1169795"> </a></code><h4>
  <a name="1169796"> </a>Prototype 
</h4>
<pre class="proto"><a name="1169797"></a>typedef struct GcBitmapType *GcBitmapHandle
</pre>
<h4>
  <a name="1169798"> </a>Fields 
</h4>

<p><a name="1169799"> </a>None.</p>
<h4>
  <a name="1169800"> </a>See Also 
</h4>

<p><a name="1169801"> </a><a href="UI_GraphicContext.html#1170306"><code>GcDrawBitmapAt()</code></a>, <a href="UI_GraphicContext.html#1170627"><code>GcDrawRawBitmapAt()</code></a>, <a href="UI_GraphicContext.html#1120182"><code>GcPaintBitmap()</code></a>, <a href="UI_GraphicContext.html#1170870"><code>GcLoadBitmap()</code></a>, <a href="UI_GraphicContext.html#1171079"><code>GcReleaseBitmap()</code></a>, <a href="UI_Form.html#1329509"><code>FrmGetBitmapHandle()</code></a></p>

<h3 class="hbH3">
  <a name="1169803"> </a>GcBitmapType Struct <a href="#608590"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="1169805"> </a>Purpose 
</h4>

<p><a name="1177343"> </a>Internal structure that stores bitmap data in a format that is most efficient for the rendering system to display on screen. </p>
<h4>
  <a name="1169807"> </a>Declared In 
</h4>
<code>GcRender.h<a name="1169808"> </a></code><h4>
  <a name="1169809"> </a>Prototype 
</h4>
<pre class="proto"><a name="1169810"></a>struct GcBitmapType
</pre>
<h4>
  <a name="1169811"> </a>Fields 
</h4>

<p><a name="1169812"> </a>None.</p>
<h4>
  <a name="1169813"> </a>See Also 
</h4>

<p><a name="1177675"> </a><a href="UI_GraphicContext.html#1170870"><code>GcLoadBitmap()</code></a>, <a href="UI_GraphicContext.html#1169790"><code>GcBitmapHandle</code></a></p>

<h3 class="hbH3">
  <a name="1034953"> </a>GcColorType Struct <a href="#608590"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="1035027"> </a>Purpose 
</h4>

<p><a name="1035054"> </a>Represents a color. </p>
<h4>
  <a name="1035075"> </a>Declared In 
</h4>
<code>GcRender.h<a name="1035098"> </a></code><h4>
  <a name="1035111"> </a>Prototype 
</h4>
<pre class="proto"><a name="993261"></a>typedef struct {
   uint8_t red;
   uint8_t green;
   uint8_t blue;
   uint8_t alpha;
} GcColorType
</pre>
<h4>
  <a name="1035146"> </a>Fields 
</h4>

<dl>
<dt><a name="1035173"> </a><code>red</code></dt>
<dd><a name="1035178"> </a>The red value. </dd>

<dt><a name="1035179"> </a><code>green</code></dt>
<dd><a name="1035180"> </a>The green value.</dd>

<dt><a name="1035181"> </a><code>blue</code></dt>
<dd><a name="1035215"> </a>The blue value.</dd>

<dt><a name="1035216"> </a><code>alpha</code></dt>
<dd><a name="1035217"> </a>The level of transparency, with 0 being transparent and 255 being fully opaque. </dd>

</dl>
<h4>
  <a name="1067453"> </a>See Also 
</h4>

<p><a name="1067640"> </a><a href="UI_GraphicContext.html#1116573"><code>GcInitGradient()</code></a>, <a href="UI_Bitmap.html#1004052"><code>RGBColorType</code></a></p>

<h3 class="hbH3">
  <a name="1170178"> </a>GcContextType Struct <a href="#608590"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="1170180"> </a>Purpose 
</h4>

<p><a name="1170181"> </a>Internal structure that keeps track of the current rendering state. </p>
<h4>
  <a name="1170182"> </a>Declared In 
</h4>
<code>GcRender.h<a name="1170183"> </a></code><h4>
  <a name="1170184"> </a>Prototype 
</h4>
<pre class="proto"><a name="1170185"></a>struct GcContextType
</pre>
<h4>
  <a name="1170186"> </a>Fields 
</h4>

<p><a name="1170187"> </a>None.</p>
<h4>
  <a name="1170188"> </a>See Also 
</h4>

<p><a name="1172193"> </a><a href="UI_GraphicContext.html#993718"><code>GcHandle</code></a></p>

<h3 class="hbH3">
  <a name="993718"> </a>GcHandle Typedef <a href="#608590"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="1002260"> </a>Purpose 
</h4>

<p><a name="1002263"> </a>The handle of a graphics context. </p>
<h4>
  <a name="1002264"> </a>Declared In 
</h4>
<code>GcRender.h<a name="1002455"> </a></code><h4>
  <a name="1002456"> </a>Prototype 
</h4>
<pre class="proto"><a name="1170249"></a>typedef struct GcContextType *GcHandle
</pre>
<h4>
  <a name="1170264"> </a>Fields 
</h4>

<p><a name="1170277"> </a>None.</p>
<h4>
  <a name="1002612"> </a>Comments 
</h4>

<p><a name="1002613"> </a>The graphics context keeps track of a current rendering state. You obtain a <code>GcHandle</code> to the graphics context using <a href="UI_GraphicContext.html#1114107"><code>GcGetCurrentContext()</code></a>, perform drawing, and then release it using <a href="UI_GraphicContext.html#994064"><code>GcReleaseContext()</code></a> when you are finished. </p>
<h4>
  <a name="1002475"> </a>See Also 
</h4>

<p><a name="1002536"> </a><a href="UI_GraphicContext.html#994782"><code>GcCreateBitmapContext()</code></a></p>

<h3 class="hbH3">
  <a name="992989"> </a>GcGradientType Struct <a href="#608590"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="1020811"> </a>Purpose 
</h4>

<p><a name="1020886"> </a>Represents a color gradient. </p>
<h4>
  <a name="1020891"> </a>Declared In 
</h4>
<code>GcRender.h<a name="1020904"> </a></code><h4>
  <a name="1020915"> </a>Prototype 
</h4>
<pre class="proto"><a name="1020601"></a>typedef struct {
   float Rdx;
   float Gdx;
   float Bdx;
   float Adx;
   float Rdy;
   float Gdy;
   float Bdy;
   float Ady;
   float R;
   float G;
   float B;
   float A;
   uint32_t _reserved;
} GcGradientType
</pre>
<h4>
  <a name="1020965"> </a>Fields 
</h4>

<dl>
<dt><a name="1026055"> </a><code>Rdx </code></dt>
<dd><a name="1021792"> </a>Change in red per unit step in the horizontal direction.</dd>

<dt><a name="1026057"> </a><code>Gdx </code></dt>
<dd><a name="1027961"> </a>Change in green per unit step in the horizontal direction.</dd>

<dt><a name="1026059"> </a><code>Bdx </code></dt>
<dd><a name="1027967"> </a>Change in blue per unit step in the horizontal direction.</dd>

<dt><a name="1026061"> </a><code>Adx </code></dt>
<dd><a name="1027973"> </a>Change in the alpha transparency value per unit step in the horizontal direction.</dd>

<dt><a name="1026063"> </a><code>Rdy </code></dt>
<dd><a name="1027979"> </a>Change in red per unit step in the vertical direction.</dd>

<dt><a name="1026065"> </a><code>Gdy </code></dt>
<dd><a name="1027985"> </a>Change in green per unit step in the vertical direction.</dd>

<dt><a name="1026067"> </a><code>Bdy </code></dt>
<dd><a name="1027991"> </a>Change in blue per unit step in the vertical direction.</dd>

<dt><a name="1026069"> </a><code>Ady </code></dt>
<dd><a name="1027997"> </a>Change in the alpha transparency value per unit step in the vertical direction.</dd>

<dt><a name="1026071"> </a><code>R </code></dt>
<dd><a name="1024511"> </a>Initial red value.</dd>

<dt><a name="1090540"> </a><code>G </code></dt>
<dd><a name="1090541"> </a>Initial green value.</dd>

<dt><a name="1090542"> </a><code>B </code></dt>
<dd><a name="1028033"> </a>Initial blue value.</dd>

<dt><a name="1026077"> </a><code>A </code></dt>
<dd><a name="1028063"> </a>Initial alpha transparency value.</dd>

<dt><a name="1021203"> </a><code>_reserved </code></dt>
<dd><a name="1025911"> </a>Reserved for future use. Always set to 0. </dd>

</dl>
<h4>
  <a name="1028456"> </a>See Also 
</h4>

<p><a name="1029506"> </a><a href="UI_GraphicContext.html#1125766"><code>GcSetGradient()</code></a>, <a href="UI_GraphicContext.html#1116573"><code>GcInitGradient()</code></a></p>

<h2 class="haH2">
  <a name="992896"> </a>Graphics Context Constants <a href="#608590"><span class="nav">^TOP^</span></a>
</h2>


<h3 class="hbH3">
  <a name="1198199"> </a>Bitmap Loading  Enum <a href="#608590"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="1198201"> </a>Purpose 
</h4>

<p><a name="1198202"> </a>Flags to pass to <a href="UI_GraphicContext.html#1170870"><code>GcLoadBitmap()</code></a>, <a href="UI_GraphicContext.html#1170627"><code>GcDrawRawBitmapAt()</code></a>, and <a href="UI_Form.html#1329509"><code>FrmGetBitmapHandle()</code></a> to specify how the bitmap should be converted when it is loaded. </p>
<h4>
  <a name="1198203"> </a>Declared In 
</h4>
<code>GcRender.h<a name="1198204"> </a></code><h4>
  <a name="1198205"> </a>Constants 
</h4>

<dl>
<dt><a name="1198206"> </a><code>kLoadBitmapUnscaled = 0x00000001</code></dt>
<dd><a name="1198207"> </a>Do not scale the bitmap if its density does not match the screen density. </dd>

<dd><a name="1206626"> </a>Note that this is different from using <a href="UI_Window.html#1704064"><code>WinSetScalingMode()</code></a> with <code>kBitmapScalingOff</code>. <code>kBitmapScalingOff</code> means use the low-density member of a bitmap family and do not scale it. <code>kLoadBitmapUnscaled</code> simply means do not scale the bitmap but does not affect which bitmap is selected from a bitmap family. </dd>

<dt><a name="1198208"> </a><code>kLoadBitmapMask = 0x00000001</code></dt>
<dd><a name="1198209"> </a>Mask of available flags for loading bitmaps. </dd>

</dl>

<h3 class="hbH3">
  <a name="1016649"> </a>GcCapTag Enum <a href="#608590"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="1016916"> </a>Purpose 
</h4>

<p><a name="1016919"> </a>Specifies what a line ending looks like. </p>
<h4>
  <a name="1016920"> </a>Declared In 
</h4>
<code>GcRender.h<a name="1016923"> </a></code><h4>
  <a name="1016924"> </a>Constants 
</h4>

<dl>
<dt><a name="1016927"> </a><code>kButtCap   = 0</code></dt>
<dd><a name="1016932"> </a>There is no special line ending. This is the default. </dd>

<dt><a name="1016933"> </a><code>kRoundCap = 1</code></dt>
<dd><a name="1016938"> </a>The line end is rounded. </dd>

<dt><a name="1016939"> </a><code>kSquareCap = 2</code></dt>
<dd><a name="1016944"> </a>The line end is squared off. </dd>

<dt><a name="1016945"> </a><code>kArrowCap = 3</code></dt>
<dd><a name="1078843"> </a>The line end has an arrow head. </dd>

</dl>
<h4>
  <a name="1016950"> </a>Comments 
</h4>

<p><a name="1076421"> </a><a href="UI_GraphicContext.html#1076429">Figure 21.1</a> shows the possible line cap endings. To help you better understand the differences between the line endings, the endings are shown for a very thick pen width with the actual line traced in white. As you can see, <code>kButtCap</code> draws the line with no special ending, <code>kRoundCap</code> adds a cap with rounded edges, and <code>kSquareCap</code> adds a cap with squared edges. Caps are drawn outside the bounds of the line.</p>

<p class="FFigureCaption">
  <a name="1076429"> </a><b>Figure 21.1&nbsp;&nbsp;Line cap styles</b>
</p>
<div align="left"><img src="images/Caps.jpg" height="191" width="480" border="0" hspace="0" vspace="0">
</div>

<h3 class="hbH3">
  <a name="1017054"> </a>GcJoinTag Enum <a href="#608590"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="1017204"> </a>Purpose 
</h4>

<p><a name="1017255"> </a>Specify what the corner looks like when two lines in a path connect (see <a href="UI_GraphicContext.html#1074037">Figure 21.2</a>). </p>
<h4>
  <a name="1017260"> </a>Declared In 
</h4>
<code>GcRender.h<a name="1017273"> </a></code><h4>
  <a name="1017284"> </a>Constants 
</h4>

<dl>
<dt><a name="993576"> </a><code>kMiterJoin = 0</code></dt>
<dd><a name="1017379"> </a>The two lines are joined with a square corner as shown on the left side of <a href="UI_GraphicContext.html#1074037">Figure 21.2</a>. This type of join requires more processing than <code>kBevelJoin</code> and thus should be avoided if unnecessary. </dd>

<dt><a name="1017404"> </a><code>kRoundJoin = 1</code></dt>
<dd><a name="1017453"> </a>The corner is rounded as shown in the center of <a href="UI_GraphicContext.html#1074037">Figure 21.2</a>. Do not use this if you are drawing curved lines (for example, if you are using <a href="UI_GraphicContext.html#1103458"><code>GcArc()</code></a> or <a href="UI_GraphicContext.html#1106848"><code>GcBezierTo()</code></a>).</dd>

<dt><a name="1017454"> </a><code>kBevelJoin = 2</code></dt>
<dd><a name="1017455"> </a>The corner is angled as shown on the right side of <a href="UI_GraphicContext.html#1074037">Figure 21.2</a>. This is the default. </dd>

</dl>
<h4>
  <a name="1072757"> </a>Comments 
</h4>

<p><a name="1072975"> </a>These constants are part of the rendering state, but they only affect the <a href="UI_GraphicContext.html#1120151"><code>GcPaint()</code></a> operation if <a href="UI_GraphicContext.html#994955"><code>GcStroke()</code></a> has been called first. </p>

<p class="FFigureCaption">
  <a name="1074037"> </a><b>Figure 21.2&nbsp;&nbsp;Line joins</b>
</p>
<div align="left"><img src="images/Joins2.jpg" height="75" width="480" border="0" hspace="0" vspace="0">
</div>
<h4>
  <a name="1072861"> </a>See Also 
</h4>

<p><a name="1072944"> </a><a href="UI_GraphicContext.html#1125797"><code>GcSetJoin()</code></a></p>

<h3 class="hbH3">
  <a name="1183201"> </a>Transform Indexes Enum <a href="#608590"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="1183203"> </a>Purpose 
</h4>

<p><a name="1183204"> </a>Index values to use for the matrix array that you pass as a parameter to <a href="UI_GraphicContext.html#1171204"><code>GcTransform()</code></a>.</p>
<h4>
  <a name="1183205"> </a>Declared In 
</h4>
<code>GcRender.h<a name="1183206"> </a></code><h4>
  <a name="1183207"> </a>Constants 
</h4>

<dl>
<dt><a name="1183208"> </a><code>kGcXX = 0</code></dt>
<dd><a name="1189175"> </a>The top left coordinate in the matrix. </dd>

<dt><a name="1188932"> </a><code>kGcYX = 1</code></dt>
<dd><a name="1189179"> </a>The leftmost coordinate in the middle row of the matrix. </dd>

<dt><a name="1183210"> </a><code>kGcXY = 2</code></dt>
<dd><a name="1189183"> </a>The middle coordinate in the top row of the matrix. </dd>

<dt><a name="1188951"> </a><code>kGcYY = 3</code></dt>
<dd><a name="1189187"> </a>The middle coordinate in the second row of the matrix. </dd>

<dt><a name="1183212"> </a><code>kGcXT = 4</code></dt>
<dd><a name="1189191"> </a>The rightmost coordinate in the top row of the matrix. </dd>

<dt><a name="1183218"> </a><code>kGcYT = 5</code></dt>
<dd><a name="1189195"> </a>The rightmost coordinate in the middle row of the matrix. </dd>

</dl>
<h4>
  <a name="1189560"> </a>Comments 
</h4>

<p><a name="1189659"> </a>These constants define coordinates in the general transformation matrix shown in <a href="UI_GraphicContext.html#1197844">Figure 21.3</a>. </p>

<p class="FFigureCaption">
  <a name="1197844"> </a><b>Figure 21.3&nbsp;&nbsp;Transformation matrix</b>
</p>
<div align="left"><img src="images/UI_GraphicContext3.jpg" height="92" width="479" border="0" hspace="0" vspace="0">
</div>

<p><a name="1189792"> </a>The coordinates in this matrix are applied to each point in the current path according to the following equations: </p>
<pre class="sl"><!-PS02-><span style="color: #000000;  font-style: italic; font-weight: normal; text-decoration: none; text-transform: none; vertical-align: baseline">newX</span> = (kGcXX * <!-PS02-><span style="color: #000000;  font-style: italic; font-weight: normal; text-decoration: none; text-transform: none; vertical-align: baseline">currentX</span>) + (kGcXY * <!-PS02-><span style="color: #000000;  font-style: italic; font-weight: normal; text-decoration: none; text-transform: none; vertical-align: baseline">currentY</span>) + 
kGcXT</pre>
<pre class="sl"><!-PS02-><span style="color: #000000;  font-style: italic; font-weight: normal; text-decoration: none; text-transform: none; vertical-align: baseline">newY</span> = <code class="par">(</code>kGcYX * <!-PS02-><span style="color: #000000;  font-style: italic; font-weight: normal; text-decoration: none; text-transform: none; vertical-align: baseline">currentX</span>) + (kGcYY * <!-PS02-><span style="color: #000000;  font-style: italic; font-weight: normal; text-decoration: none; text-transform: none; vertical-align: baseline">currentY</span>) + 
kGcYT</pre>

<p><a name="1189661"> </a>where (<i>currentX</i>, <i>currentY</i>) represents a point on the path and (<i>newX</i>, <i>newY</i>) represents that point after the transformation has been applied. </p>

<h2 class="haH2">
  <a name="1017666"> </a>Graphics Context Functions <a href="#608590"><span class="nav">^TOP^</span></a>
</h2>


<h3 class="hbH3">
  <a name="1103458"> </a>GcArc Function <a href="#608590"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="1103460"> </a>Purpose 
</h4>

<p><a name="1103461"> </a>Adds an arc to the current path. </p>
<h4>
  <a name="1103462"> </a>Declared In 
</h4>
<code>GcRender.h<a name="1103463"> </a></code><h4>
  <a name="1103464"> </a>Prototype 
</h4>
<pre class="proto"><a name="1103465"></a>void GcArc (
   GcHandle <code class="par">ctxt</code>,
   fcoord_t <code class="par">centerX</code>,
   fcoord_t <code class="par">centerY</code>,
   fcoord_t <code class="par">radx</code>,
   fcoord_t <code class="par">rady</code>,
   float <code class="par">startAngle</code>,
   float <code class="par">arcLen</code>,
   Boolean <code class="par">connected</code>
)
</pre>
<h4>
  <a name="1103466"> </a>Parameters 
</h4>

<dl>
<dt><a name="1103467"> </a><code>&rarr;  <i><code class="par">ctxt</code></i></code></dt>
<dd><a name="1103468"> </a>The graphics context. </dd>

<dt><a name="1103469"> </a><code>&rarr;  <i><code class="par">centerX</code></i></code></dt>
<dd><a name="1103470"> </a>The x coordinate of the arc's center.</dd>

<dt><a name="1103471"> </a><code>&rarr;  <i><code class="par">centerY</code></i></code></dt>
<dd><a name="1103472"> </a>The y coordinate of the arc's center. </dd>

<dt><a name="1103473"> </a><code>&rarr;  <i><code class="par">radx</code></i></code></dt>
<dd><a name="1103474"> </a>The horizontal radius. </dd>

<dt><a name="1103475"> </a><code>&rarr;  <i><code class="par">rady</code></i></code></dt>
<dd><a name="1103476"> </a>The vertical radius. </dd>

<dt><a name="1103477"> </a><code>&rarr;  <i><code class="par">startAngle</code></i></code></dt>
<dd><a name="1103478"> </a>The angle (in radians) from the horizontal radius to the beginning of the arc. </dd>

<dt><a name="1103479"> </a><code>&rarr;  <i><code class="par">arcLen</code></i></code></dt>
<dd><a name="1103480"> </a>The angle (in radians) of the arc itself. This angle must be a positive value. </dd>

<dt><a name="1103481"> </a><code>&rarr;  <i><code class="par">connected</code></i></code></dt>
<dd><a name="1103482"> </a>If <code>true</code>, a line is drawn from the center point to the arc. If <code>false</code>, the arc is drawn without connecting to the center point. </dd>

</dl>
<h4>
  <a name="1103483"> </a>Returns 
</h4>

<p><a name="1103484"> </a>Nothing.</p>
<h4>
  <a name="1103485"> </a>Comments 
</h4>

<p><a name="1103489"> </a><a href="UI_GraphicContext.html#1103491">Figure 21.4</a> illustrates how the rendering system computes where to draw the arc. It constructs a template ellipse whose horizontal radius is <code class="par">radx</code> and vertical radius is <code class="par">rady</code>. The starting point of the arc is determine by the <code class="par">startAngle</code>, and the ending point is determined by the <code class="par">arcLen</code> angle. The endpoint of the arc becomes the current point. </p>

<p class="FFigureCaption">
  <a name="1103491"> </a><b>Figure 21.4&nbsp;&nbsp;GcArc example</b>
</p>
<div align="left"><img src="images/Arc4.jpg" height="148" width="480" border="0" hspace="0" vspace="0">
</div>

<p><a name="1103496"> </a>If <code class="par">connected</code> is <code>true</code>, a straight line is drawn from the current point to the center point and then another straight line is drawn from the center point to the beginning of the arc. If <code class="par">connected</code> is <code>false</code>, a straight line is drawn from the current point to the beginning of the arc unless the current point is the same as the center point. If you don't want the arc connected to any previous drawing, call <a href="UI_GraphicContext.html#1118101"><code>GcMoveTo()</code></a> with <code class="par">centerX</code> and <code class="par">centerY</code> before calling this function. </p>

<p><a name="1103500"> </a>The arc is actually constructed as a series of connected Bezier curves. If you are drawing a stroked path (that is, you want to draw the outline of a shape instead of filling it), do not use <code>kRoundJoin </code>as the line join. Leave the line join setting at the default. </p>

<p><a name="1103501"> </a>This function adds to the current path in the rendering state; it does not draw to the screen. To draw the current path to the screen, call <a href="UI_GraphicContext.html#1120151"><code>GcPaint()</code></a>. </p>
<h4>
  <a name="1216413"> </a>Compatibility 
</h4>

<p><a name="1216414"> </a>Palm OS<sup>&#174;</sup> Cobalt version 6.0 always draws arcs clockwise (as you are looking at the screen). There is no way to draw a counterclockwise arc; however, one may be added in the future. </p>
<h4>
  <a name="1103505"> </a>See Also 
</h4>

<p><a name="1103509"> </a><a href="UI_GraphicContext.html#1103512"><code>GcArcTo()</code></a></p>

<h3 class="hbH3">
  <a name="1103512"> </a>GcArcTo Function <a href="#608590"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="1103514"> </a>Purpose 
</h4>

<p><a name="1103515"> </a>Computes an arc using a radius and two tangent lines and adds the arc to the current path. </p>
<h4>
  <a name="1103516"> </a>Declared In 
</h4>
<code>GcRender.h<a name="1103517"> </a></code><h4>
  <a name="1103518"> </a>Prototype 
</h4>
<pre class="proto"><a name="1103519"></a>void GcArcTo (
   GcHandle <code class="par">ctxt</code>,
   fcoord_t <code class="par">p1x</code>,
   fcoord_t <code class="par">p1y</code>,
   fcoord_t <code class="par">p2x</code>,
   fcoord_t <code class="par">p2y</code>,
   float <code class="par">radius</code>
)
</pre>
<h4>
  <a name="1103520"> </a>Parameters 
</h4>

<dl>
<dt><a name="1103521"> </a><code>&rarr;  <i><code class="par">ctxt</code></i></code></dt>
<dd><a name="1103522"> </a>The graphics context. </dd>

<dt><a name="1103523"> </a><code>&rarr;  <i><code class="par">p1x, p1y</code></i></code></dt>
<dd><a name="1103524"> </a>The point where the two tangent lines intersect. The first tangent is from the path's current point to this point. </dd>

<dt><a name="1103525"> </a><code>&rarr;  <i><code class="par">p2x, p2y</code></i></code></dt>
<dd><a name="1103526"> </a>The end point of the second tangent line. The second tangent line goes from (<code class="par">p1x</code>, <code class="par">p1y</code>) to (<code class="par">p2x</code>, <code class="par">p2y</code>). </dd>

<dt><a name="1103527"> </a><code>&rarr;  <i><code class="par">radius</code></i></code></dt>
<dd><a name="1103528"> </a>The length in coordinates of the arc's radius. Use &#8211;1 for this value if you want the arc to be drawn from the current point to (<code class="par">p2x</code>, <code class="par">p2y</code>). Note that in this case, the (<code class="par">p1x</code>, <code class="par">p1y</code>) coordinate must be equidistant from the current point and (<code class="par">p2x</code>, <code class="par">p2y</code>). </dd>

</dl>
<h4>
  <a name="1103529"> </a>Returns 
</h4>

<p><a name="1103530"> </a>Nothing.</p>
<h4>
  <a name="1103531"> </a>Comments 
</h4>

<p><a name="1103532"> </a>This function is generally useful for drawing boxes with rounded corners; however, the convenience function <a href="UI_GraphicContext.html#994936"><code>GcRoundRect()</code></a> is more efficient. </p>

<p><a name="1103539"> </a>As shown in <a href="UI_GraphicContext.html#1103541">Figure 21.5</a>, this function constructs an arc using two tangent lines and the specified radius. The first tangent line goes from the current point to (<code class="par">p1x</code>, <code class="par">p1y</code>). The second line goes from (<code class="par">p1x</code>, <code class="par">p1y</code>) to (<code class="par">p2y</code>, <code class="par">p2y</code>). Next, the center of the arc is computed by finding the point that is <code class="par">radius</code> distance from the two tangents at a perpendicular angle. Finally, this function adds a path that is a straight line from the current point to the arc's beginning, then the curved arc, and then a straight line from the end of the arc to (<code class="par">p2x</code>, <code class="par">p2y</code>). (<code class="par">p2x</code>, <code class="par">p2y</code>) becomes the current point. </p>

<p class="FFigureCaption">
  <a name="1103541"> </a><b>Figure 21.5&nbsp;&nbsp;GcArcTo() example</b>
</p>
<div align="left"><img src="images/ArcTo5.jpg" height="208" width="480" border="0" hspace="0" vspace="0">
</div>

<p><a name="1103546"> </a>Notice that if the radius is very large, the arc may be drawn off screen. </p>

<p><a name="1103547"> </a>The arc is actually constructed as a series of connected Bezier curves. If you are drawing a stroked path (that is, you want to draw the outline of a shape instead of filling it), do not use <code>kRoundJoin </code>as the line join. Leave the line join setting at the default. </p>

<p><a name="1103548"> </a>This function adds to the current path in the rendering state; it does not draw to the screen. To draw the current path to the screen, call <a href="UI_GraphicContext.html#1120151"><code>GcPaint()</code></a>. </p>
<h4>
  <a name="1216209"> </a>Compatibility 
</h4>

<p><a name="1216210"> </a>Palm OS Cobalt version 6.0 always draws arcs clockwise (as you are looking at the screen). There is no way to draw a counterclockwise arc; however, one may be added in the future. </p>
<h4>
  <a name="1103552"> </a>See Also 
</h4>

<p><a name="1103559"> </a><a href="UI_GraphicContext.html#1103458"><code>GcArc()</code></a>, <a href="UI_GraphicContext.html#1118074"><code>GcLineTo()</code></a></p>

<h3 class="hbH3">
  <a name="1104793"> </a>GcBeginClip Function <a href="#608590"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="1104795"> </a>Purpose 
</h4>

<p><a name="1104796"> </a>Begins a block of code that specifies a clipping region. </p>
<h4>
  <a name="1104797"> </a>Declared In 
</h4>
<code>GcRender.h<a name="1104798"> </a></code><h4>
  <a name="1104799"> </a>Prototype 
</h4>
<pre class="proto"><a name="1104800"></a>void GcBeginClip (
   GcHandle <code class="par">ctxt</code>,
   Boolean <code class="par">inverse</code>
)
</pre>
<h4>
  <a name="1104801"> </a>Parameters 
</h4>

<dl>
<dt><a name="1104802"> </a><code>&rarr;  <i>ctxt</i></code></dt>
<dd><a name="1104803"> </a>The graphics context.</dd>

<dt><a name="1104804"> </a><code>&rarr;  <i><code class="par">inverse</code></i></code></dt>
<dd><a name="1104805"> </a>If <code>true</code>, the region that you define will be the inverse of the clipping region. If <code>false</code>, the region you define will be the clipping region. </dd>

</dl>
<h4>
  <a name="1104806"> </a>Returns 
</h4>

<p><a name="1104807"> </a>Nothing.</p>
<h4>
  <a name="1104808"> </a>Comments 
</h4>

<p><a name="1128820"> </a>To specify a clipping region, do the following: </p>
<ol type="1">
  <li value="1"><a name="1128824"> </a>Call <a href="UI_GraphicContext.html#1121303"><code>GcPushState()</code></a>. 
  <li value="2"><a name="1128828"> </a>Call <a href="UI_GraphicContext.html#1104793"><code>GcBeginClip()</code></a>.
  <li value="3"><a name="1128829"> </a>Call one or more of the path definition functions to specify the clipping region. 
  <li value="4"><a name="1128833"> </a>Call <a href="UI_GraphicContext.html#1120151"><code>GcPaint()</code></a>, which fills the specified region with white. 
  <li value="5"><a name="1128837"> </a>Call <a href="UI_GraphicContext.html#1112161"><code>GcEndClip()</code></a>. 
</ol>

<p><a name="1129611"> </a>After the <code>GcEndClip()</code> call, all drawing is constrained to the region that you defined using this procedure. (If you passed <code>true</code> for the <code class="par">inverse</code> parameter, all drawing is constrained to the region that lies outside of the region you've defined.) The antialiasing value is ignored when the clipping region is specified. </p>

<p><a name="1129618"> </a>To clear the clipping region, call <a href="UI_GraphicContext.html#1121283"><code>GcPopState()</code></a>. Nested clipping regions are not allowed; that is, you cannot call <a href="UI_GraphicContext.html#1104793"><code>GcBeginClip()</code></a> twice without calling <a href="UI_GraphicContext.html#1112161"><code>GcEndClip()</code></a>. You can, however, define two separate clipping regions in the current rendering state. If you do, the second clipping region is constrained by the first so that the resulting region becomes the intersection of the two regions. </p>

<h3 class="hbH3">
  <a name="1106848"> </a>GcBezierTo Function <a href="#608590"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="1106850"> </a>Purpose 
</h4>

<p><a name="1106851"> </a>Add a Bezier curve to the path. </p>
<h4>
  <a name="1106852"> </a>Declared In 
</h4>
<code>GcRender.h<a name="1106853"> </a></code><h4>
  <a name="1106854"> </a>Prototype 
</h4>
<pre class="proto"><a name="1106855"></a>void GcBezierTo (
   GcHandle <code class="par">ctxt</code>,
   fcoord_t <code class="par">p1x</code>,
   fcoord_t <code class="par">p1y</code>,
   fcoord_t <code class="par">p2x</code>,
   fcoord_t <code class="par">p2y</code>,
   fcoord_t <code class="par">p3x</code>,
   fcoord_t <code class="par">p3y</code>
)
</pre>
<h4>
  <a name="1106856"> </a>Parameters 
</h4>

<dl>
<dt><a name="1106857"> </a><code>&rarr;  <i>ctxt</i></code></dt>
<dd><a name="1106858"> </a>The current graphics context. </dd>

<dt><a name="1106859"> </a><code>&rarr;  <i><code class="par">p1x, p1y</code></i></code></dt>
<dd><a name="1106860"> </a>The point that controls the angle and direction of the first curve. </dd>

<dt><a name="1106861"> </a><code>&rarr;  <i><code class="par">p2x, p2y</code></i></code></dt>
<dd><a name="1106862"> </a>The point that controls the angle and direction of the second curve. </dd>

<dt><a name="1106863"> </a><code>&rarr;  <i><code class="par">p3x, p3y</code></i></code></dt>
<dd><a name="1106864"> </a>The end point of the line. </dd>

</dl>
<h4>
  <a name="1106865"> </a>Returns 
</h4>

<p><a name="1106866"> </a>Nothing. </p>
<h4>
  <a name="1106867"> </a>Comments 
</h4>

<p><a name="1148084"> </a>As shown in <a href="UI_GraphicContext.html#1148087">Figure 21.6</a>, this function constructs a template consisting of straight lines from the current point to (<code class="par">p1x</code>, <code class="par">p1y</code>) and from (<code class="par">p2x</code>, <code class="par">p2y</code>) to (<code class="par">p3x</code>, <code class="par">p3y</code>). The path it constructs begins at the current point, is tangent to the line that starts at the point, and goes in the direction of (<code class="par">p1x</code>, <code class="par">p1y</code>). The end of the path is at (<code class="par">p3x</code>, <code class="par">p3y</code>). The ending part of the path is tangent to the line from (<code class="par">p2x</code>, <code class="par">p2y</code>) to (<code class="par">p3x</code>, <code class="par">p3y</code>) and heads in the direction of (<code class="par">p2x</code>, <code class="par">p2y</code>). (<code class="par">p3x</code>, <code class="par">p3y</code>) becomes the current point. </p>

<p class="FFigureCaption">
  <a name="1148087"> </a><b>Figure 21.6&nbsp;&nbsp;Bezier curve</b>
</p>
<div align="left"><img src="images/Bezier6.jpg" height="172" width="480" border="0" hspace="0" vspace="0">
</div>

<p><a name="1106879"> </a>If you are drawing a stroked path (that is, you want to draw the outline of the shape instead of filling it), do not use <code>kRoundJoin </code>as the line join. Leave the line join setting at the default. </p>

<p><a name="1106880"> </a>This function adds to the current path in the rendering state; it does not draw to the screen. To draw the current path to the screen, call <a href="UI_GraphicContext.html#1120151"><code>GcPaint()</code></a>. </p>
<h4>
  <a name="1106884"> </a>See Also 
</h4>

<p><a name="1106891"> </a><a href="UI_GraphicContext.html#1103458"><code>GcArc()</code></a>, <a href="UI_GraphicContext.html#1103512"><code>GcArcTo()</code></a></p>

<h3 class="hbH3">
  <a name="1108164"> </a>GcClosePath Function <a href="#608590"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="1108166"> </a>Purpose 
</h4>

<p><a name="1108167"> </a>Closes the current subpath using a straight line. </p>
<h4>
  <a name="1108168"> </a>Declared In 
</h4>
<code>GcRender.h<a name="1108169"> </a></code><h4>
  <a name="1108170"> </a>Prototype 
</h4>
<pre class="proto"><a name="1108171"></a>void GcClosePath (
   GcHandle <code class="par">ctxt</code>
)
</pre>
<h4>
  <a name="1108172"> </a>Parameters 
</h4>

<dl>
<dt><a name="1108173"> </a><code>&rarr;  <i>ctxt</i></code></dt>
<dd><a name="1108174"> </a>The rendering context containing the path to close.</dd>

</dl>
<h4>
  <a name="1108175"> </a>Returns 
</h4>

<p><a name="1108176"> </a>Nothing. </p>
<h4>
  <a name="1108177"> </a>Comments 
</h4>

<p><a name="1108178"> </a>This function draws a straight line from the current point to the point specified by the most recent <a href="UI_GraphicContext.html#1118101"><code>GcMoveTo()</code></a> call in the current path. This starting point becomes the current point. </p>

<p><a name="1108182"> </a>This function adds to the current path in the rendering state; it does not draw to the screen. To draw the current path to the screen, call <a href="UI_GraphicContext.html#1120151"><code>GcPaint()</code></a>. </p>

<h3 class="hbH3">
  <a name="1017667"> </a>GcCommit Function <a href="#608590"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="994748"> </a>Purpose 
</h4>

<p><a name="994749"> </a>Blocks until all pending drawing operations are completed.</p>
<h4>
  <a name="994750"> </a>Declared In 
</h4>
<code>GcRender.h<a name="994751"> </a></code><h4>
  <a name="994752"> </a>Prototype 
</h4>
<pre class="proto"><a name="994070"></a>void GcCommit (
   GcHandle <code class="par">ctxt</code>
)
</pre>
<h4>
  <a name="1006108"> </a>Parameters 
</h4>

<dl>
<dt><a name="1006199"> </a><code>&rarr;  <i>ctxt</i></code></dt>
<dd><a name="1006240"> </a>The rendering context to commit. </dd>

</dl>
<h4>
  <a name="1006261"> </a>Returns 
</h4>

<p><a name="1006368"> </a>Nothing. </p>
<h4>
  <a name="1006369"> </a>Comments 
</h4>

<p><a name="1006372"> </a>Use this function in the rare circumstances where you need to wait for the rendering system to finish before your application continues. </p>

<p><a name="1036895"> </a>The rendering system runs in a different process than the application. To avoid IPC overhead, drawing operations are buffered and sent to the rendering system in batches. Because of this, rendering is likely to have not finished, or even started, when a drawing function returns. <code>GcCommit()</code> causes all buffered operations to be sent immediately and then waits for drawing to be completed before it returns. </p>

<p><a name="1036876"> </a>This function is a performance drain and should be used rarely, only when absolutely necessary. </p>

<p><a name="1038968"> </a>Note that you do not need to use <code>GcCommit()</code> when drawing to a local bitmap. All drawing to local bitmaps is performed immediately. </p>
<h4>
  <a name="1006373"> </a>See Also 
</h4>

<p><a name="993014"> </a><a href="UI_GraphicContext.html#1115387"><code>GcFlush()</code></a></p>

<h3 class="hbH3">
  <a name="994782"> </a>GcCreateBitmapContext Function <a href="#608590"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="994784"> </a>Purpose 
</h4>

<p><a name="994785"> </a>Create a rendering context in a given bitmap. </p>
<h4>
  <a name="994786"> </a>Declared In 
</h4>
<code>GcRender.h<a name="994787"> </a></code><h4>
  <a name="994788"> </a>Prototype 
</h4>
<pre class="proto"><a name="994074"></a>GcHandle GcCreateBitmapContext (
   const BitmapType *<code class="par">bitmapP</code>
)
</pre>
<h4>
  <a name="1001854"> </a>Parameters 
</h4>

<dl>
<dt><a name="1001857"> </a><code>&rarr;  <i>bitmapP</i></code></dt>
<dd><a name="1001890"> </a>The bitmap to use when creating the context. </dd>

</dl>
<h4>
  <a name="1001911"> </a>Returns 
</h4>

<p><a name="1002000"> </a>A handle to the newly created graphics context or <code>NULL</code> if one cannot be created. See <a href="UI_GraphicContext.html#993718"><code>GcHandle</code></a>. </p>
<h4>
  <a name="1002021"> </a>Comments 
</h4>

<p><a name="1031644"> </a>Use this function if you want to modify a bitmap. </p>

<p><a name="1039805"> </a>You pass the <a href="UI_GraphicContext.html#993718"><code>GcHandle</code></a> returned by this function to the drawing operations such as <a href="UI_GraphicContext.html#1106848"><code>GcBezierTo()</code></a> and <a href="UI_GraphicContext.html#1118074"><code>GcLineTo()</code></a>. When you are finished, you call <a href="UI_GraphicContext.html#1120151"><code>GcPaint()</code></a> and then <a href="UI_GraphicContext.html#994064"><code>GcReleaseContext()</code></a>. </p>

<p><a name="1139362"> </a>It is strongly recommended that you never define a color table for bitmaps. Drawing to a bitmap with a color table is much slower than drawing to a bitmap that uses the default color table. If you must define a color table for your bitmap, when you are ready to draw it to the screen, use <a href="UI_Window.html#1530544"><code>WinPalette()</code></a> to change the screen's color table to match your bitmap's color table before you call point the bitmap to the screen. Drawing a bitmap whose color table does not match the color table of the destination is much slower. </p>

<p><a name="1182844"> </a>Note that the <a href="UI_Bitmap.html#998464"><code>BmpCreate()</code></a> function creates a single-density bitmap, but the default coordinate system for the context created by <code>GcCreateBitmapContext()</code> is native screen density. </p>
<h4>
  <a name="1040259"> </a>Example 
</h4>

<p><a name="1039835"> </a>The following example creates a small high-density bitmap containing a red triangle. </p>

<div class="CodeRule"><hr></div><pre class="CodeBlock">
BitmapTypeV3 *bmpP;<a name="1039836"> </a>
GcHandle bitmapContext;<a name="1039979"> </a>
<a name="1039980"> </a>
bmpP = BmpCreate(12, 12, 16, NULL, &amp;error);<a name="1039974"> </a>
bmpP = BmpCreateBitmapV3(bmpP, kDensityDouble, <a name="1197587"> </a>
       BmpGetBits(bmpP), NULL); <a name="1197612"> </a>
if (bmpP) {<a name="1040043"> </a>
   bitmapContext = GcCreateBitmapContext(bmpP);<a name="1040092"> </a>
   if (bitmapContext) {<a name="1090329"> </a>
      GcSetColor(bitmapContext, 255, 0, 0, 255);<a name="1040246"> </a>
      GcMoveTo(bitmapContext, 2, 2);<a name="1040174"> </a>
      GcLineTo(bitmapContext, 2, 10);<a name="1040180"> </a>
      GcLineTo(bitmapContext, 10, 10);<a name="1040189"> </a>
      GcClosePath(bitmapContext);<a name="1040194"> </a>
      GcPaint(bitmapContext);<a name="1042046"> </a>
      GcReleaseContext(bitmapContext);<a name="1050934"> </a>
   }<a name="1090374"> </a>
}<a name="1040147"> </a>
</pre><div class="CodeRule"><hr></div>

<h4>
  <a name="1002102"> </a>See Also 
</h4>

<p><a name="1002158"> </a><a href="UI_GraphicContext.html#994064"><code>GcReleaseContext()</code></a></p>

<h3 class="hbH3">
  <a name="1170306"> </a>GcDrawBitmapAt Function <a href="#608590"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="1170308"> </a>Purpose 
</h4>

<p><a name="1170309"> </a>Paints the bitmap at the specified coordinates. </p>
<h4>
  <a name="1170310"> </a>Declared In 
</h4>
<code>GcRender.h<a name="1170311"> </a></code><h4>
  <a name="1170312"> </a>Prototype 
</h4>
<pre class="proto"><a name="1170313"></a>void GcDrawBitmapAt (
   GcHandle <code class="par">ctxt</code>,
   GcBitmapHandle <code class="par">bitmapHandle</code>,
   const FAbsRectType <code class="par">*srcRect</code>,
   fcoord_t <code class="par">x</code>,
   fcoord_t <code class="par">y</code>
)
</pre>
<h4>
  <a name="1170314"> </a>Parameters 
</h4>

<dl>
<dt><a name="1170315"> </a><code>&rarr;  <i>ctxt</i></code></dt>
<dd><a name="1170316"> </a>The graphics context. </dd>

<dt><a name="1170317"> </a><code>&rarr;  <i>bitmapHandle</i></code></dt>
<dd><a name="1206615"> </a>The bitmap. Use <a href="UI_Form.html#1329509"><code>FrmGetBitmapHandle()</code></a> or <a href="UI_GraphicContext.html#1170870"><code>GcLoadBitmap()</code></a> to obtain a <code>GcBitmapHandle</code> to a bitmap.</dd>

<dt><a name="1196376"> </a><code>&rarr;  <i>srcRect</i></code></dt>
<dd><a name="1197184"> </a>Rectangle (see <a href="UI_GcFont.html#993294"><code>FAbsRectType</code></a>) that specifies the portion of the bitmap to be drawn to the screen. Pass <code>NULL</code> to draw the entire bitmap. The rectangle must be less than or equal to the bitmap's dimensions and must be expressed in terms of the coordinate system used by the bitmap (that is, the bitmap's density). If you pass a larger rectangle, the bitmap is not tiled. </dd>

<dt><a name="1170319"> </a><code>&rarr;  <i>x, y</i></code></dt>
<dd><a name="1170320"> </a>Top-left corner of where the bitmap should be drawn. </dd>

</dl>
<h4>
  <a name="1170323"> </a>Returns 
</h4>

<p><a name="1170324"> </a>Nothing. </p>
<h4>
  <a name="1170325"> </a>Comments 
</h4>

<p><a name="1170326"> </a>This function defines the path into where the bitmap should be drawn, paints the bitmap, and then clears the current path but no other aspect of the rendering state. Most of the rendering state does not affect this call. </p>
<h4>
  <a name="1170327"> </a>See Also 
</h4>

<p><a name="1170328"> </a><a href="UI_GraphicContext.html#1170627"><code>GcDrawRawBitmapAt()</code></a></p>

<h3 class="hbH3">
  <a name="1170627"> </a>GcDrawRawBitmapAt Function <a href="#608590"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="1170629"> </a>Purpose 
</h4>

<p><a name="1170630"> </a>Paints a bitmap at the specified coordinates. </p>
<h4>
  <a name="1170631"> </a>Declared In 
</h4>
<code>GcRender.h<a name="1170632"> </a></code><h4>
  <a name="1170633"> </a>Prototype 
</h4>
<pre class="proto"><a name="1170634"></a>void GcDrawRawBitmapAt (
   GcHandle <code class="par">ctxt</code>,
   const BitmapType <code class="par">*bitmapP</code>,
   const FAbsRectType <code class="par">*srcRect</code>,
   fcoord_t <code class="par">x</code>,
   fcoord_t <code class="par">y</code>,
   uint32_t <code class="par">load_flags</code>
)
</pre>
<h4>
  <a name="1170635"> </a>Parameters 
</h4>

<dl>
<dt><a name="1170636"> </a><code>&rarr;  <i>ctxt</i></code></dt>
<dd><a name="1175584"> </a>The graphics context. </dd>

<dt><a name="1170638"> </a><code>&rarr;  <i>bitmapP</i></code></dt>
<dd><a name="1170639"> </a>The bitmap to draw. See <a href="UI_Bitmap.html#1003681"><code>BitmapType</code></a>. </dd>

<dt><a name="1196439"> </a><code>&rarr;  <i>srcRect</i></code></dt>
<dd><a name="1197088"> </a>Rectangle (see <a href="UI_GcFont.html#993294"><code>FAbsRectType</code></a>) that specifies the portion of the bitmap to be drawn to the screen. Pass <code>NULL</code> to draw the entire bitmap. The rectangle must be less than or equal to the bitmap's dimensions and must be expressed in terms of the coordinate system used by the bitmap (that is, the bitmap's density). If you pass a larger rectangle, the bitmap is not tiled. </dd>

<dt><a name="1170640"> </a><code>&rarr;  <i>x, y</i></code></dt>
<dd><a name="1170641"> </a>Top-left corner of where the bitmap should be drawn. </dd>

<dt><a name="1198388"> </a><code>&rarr;  <i>load_flags</i></code></dt>
<dd><a name="1198389"> </a>One of the <a href="UI_GraphicContext.html#1198199">Bitmap Loading</a> constants, which specify whether the bitmap should be scaled. </dd>

</dl>
<h4>
  <a name="1170644"> </a>Returns 
</h4>

<p><a name="1170645"> </a>Nothing. </p>
<h4>
  <a name="1170646"> </a>Comments 
</h4>

<p><a name="1206933"> </a>This function creates a <a href="UI_GraphicContext.html#1169790"><code>GcBitmapHandle</code></a> for <code class="par">bitmapP</code>, draws it to the screen, and then releases the bitmap handle. You are responsible for loading <code class="par">bitmapP</code> from the database and releasing it when you are done. </p>
<h4>
  <a name="1207016"> </a>See Also 
</h4>

<p><a name="1207029"> </a><a href="UI_GraphicContext.html#1170870"><code>GcLoadBitmap()</code></a>, <a href="UI_GraphicContext.html#1170306"><code>GcDrawBitmapAt()</code></a></p>

<h3 class="hbH3">
  <a name="1196638"> </a>GcDrawTextAt Function <a href="#608590"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="1196640"> </a>Purpose 
</h4>

<p><a name="1196644"> </a>Draws text to the screen using the font specified by <a href="UI_GraphicContext.html#1125325"><code>GcSetFont()</code></a>. </p>
<h4>
  <a name="1196645"> </a>Declared In 
</h4>
<code>GcRender.h<a name="1196646"> </a></code><h4>
  <a name="1196647"> </a>Prototype 
</h4>
<pre class="proto"><a name="1196648"></a>void GcDrawTextAt (
   GcHandle <code class="par">ctxt</code>,
   fcoord_t <code class="par">x</code>,
   fcoord_t <code class="par">y</code>,
   const char *<code class="par">text</code>,
   int32_t <code class="par">length</code>
)
</pre>
<h4>
  <a name="1196649"> </a>Parameters 
</h4>

<dl>
<dt><a name="1196650"> </a><code>&rarr;  <i>ctxt</i></code></dt>
<dd><a name="1196651"> </a>The graphics context. </dd>

<dt><a name="1196652"> </a><code>&rarr;  <i>x</i></code></dt>
<dd><a name="1196653"> </a>The x coordinate where the text should begin. </dd>

<dt><a name="1196654"> </a><code>&rarr;  <i>y</i></code></dt>
<dd><a name="1196655"> </a>The y coordinate where the baseline of the text should be. (Letters with descenders will draw below this line.)</dd>

<dt><a name="1196656"> </a><code>&rarr;  <i>text</i></code></dt>
<dd><a name="1196657"> </a>The text to draw to the screen.</dd>

<dt><a name="1196658"> </a><code>&rarr;  <i>length</i></code></dt>
<dd><a name="1196659"> </a>The size in bytes of the <code class="par">text</code> string. You can use &#8211;1 for this value if <code class="par">text</code> is a null-terminated string. </dd>

</dl>
<h4>
  <a name="1196660"> </a>Returns 
</h4>

<p><a name="1196661"> </a>Nothing. </p>
<h4>
  <a name="1196662"> </a>Comments 
</h4>

<p><a name="1196663"> </a>This function generates a path from the supplied text, fills that path, and then clears it. Because this function clears the current path, you must either call <a href="UI_GraphicContext.html#1120151"><code>GcPaint()</code></a> to draw any path that you have defined before you add text, or you can call <a href="UI_GraphicContext.html#1121303"><code>GcPushState()</code></a> to preserve the drawing and continue after you add the text. </p>
<h4>
  <a name="1196670"> </a>See Also 
</h4>

<p><a name="1196674"> </a><a href="UI_GraphicContext.html#1125325"><code>GcSetFont()</code></a></p>

<h3 class="hbH3">
  <a name="1112161"> </a>GcEndClip Function <a href="#608590"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="1112163"> </a>Purpose 
</h4>

<p><a name="1112164"> </a>Ends the specification of a clipping region. </p>
<h4>
  <a name="1112165"> </a>Declared In 
</h4>
<code>GcRender.h<a name="1112166"> </a></code><h4>
  <a name="1112167"> </a>Prototype 
</h4>
<pre class="proto"><a name="1112168"></a>void GcEndClip (
   GcHandle <code class="par">ctxt</code>
)
</pre>
<h4>
  <a name="1112169"> </a>Parameters 
</h4>

<dl>
<dt><a name="1112170"> </a><code>&rarr;  <i>ctxt</i></code></dt>
<dd><a name="1112171"> </a>The graphics context. </dd>

</dl>
<h4>
  <a name="1112172"> </a>Returns 
</h4>

<p><a name="1112173"> </a>Nothing. </p>
<h4>
  <a name="1112174"> </a>Comments 
</h4>

<p><a name="1112193"> </a>After this call, all drawing is constrained to the region that you defined using this procedure. (If you passed <code>true</code> for <a href="UI_GraphicContext.html#1104793"><code>GcBeginClip()</code></a>'s <code class="par">inverse</code> parameter, all drawing is constrained to the region that lies outside of the region you've defined.) </p>

<p><a name="1114096"> </a>To clear the clipping region, call <a href="UI_GraphicContext.html#1121283"><code>GcPopState()</code></a>. Nested clipping regions are not allowed; that is, you cannot call <a href="UI_GraphicContext.html#1104793"><code>GcBeginClip()</code></a> twice without calling <a href="UI_GraphicContext.html#1112161"><code>GcEndClip()</code></a>. You can, however, define two separate clipping regions in the current rendering state. If you do, the second clipping region is constrained by the first so that the resulting region becomes the intersection of the two regions. </p>

<h3 class="hbH3">
  <a name="1115387"> </a>GcFlush Function <a href="#608590"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="1115389"> </a>Purpose 
</h4>

<p><a name="1115390"> </a>Blocks until all pending drawing operations have been sent. </p>
<h4>
  <a name="1115391"> </a>Declared In 
</h4>
<code>GcRender.h<a name="1115392"> </a></code><h4>
  <a name="1115393"> </a>Prototype 
</h4>
<pre class="proto"><a name="1115394"></a>void GcFlush (
   GcHandle <code class="par">ctxt</code>
)
</pre>
<h4>
  <a name="1115395"> </a>Parameters 
</h4>

<dl>
<dt><a name="1115396"> </a><code>&rarr;  <i>ctxt</i></code></dt>
<dd><a name="1115397"> </a>The rendering context to flush. </dd>

</dl>
<h4>
  <a name="1115398"> </a>Returns 
</h4>

<p><a name="1115399"> </a>Nothing. </p>
<h4>
  <a name="1115400"> </a>Comments 
</h4>

<p><a name="1115401"> </a>Use this function in the rare circumstances where you need to wait for the drawing buffer to be empty before your application continues. </p>

<p><a name="1115402"> </a>The rendering system runs in a different process than the application. To avoid IPC overhead, drawing operations are buffered and sent to the rendering system in batches. Because of this, rendering is likely to have not finished, or even started, when a drawing function returns. <code>GcFlush()</code> causes all buffered operations to be sent immediately and then it returns. </p>

<p><a name="1115403"> </a>Drawing may not have completed when <code>GcFlush()</code> returns; it simply makes sure all drawing commands have been sent. If you need to make sure that drawing completes before you continue, use <a href="UI_GraphicContext.html#1017667"><code>GcCommit()</code></a> instead of <code>GcFlush()</code>. </p>

<p><a name="1115408"> </a>This function is a performance drain and should be used rarely, only when absolutely necessary. </p>

<p><a name="1115409"> </a>Note that you do not need to use <code>GcFlush()</code> when drawing to a local bitmap. All drawing to local bitmaps is performed immediately. </p>

<h3 class="hbH3">
  <a name="1198394"> </a>GcGetBitmapDensity Function <a href="#608590"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="1198396"> </a>Purpose 
</h4>

<p><a name="1198397"> </a>Returns the density of a bitmap. </p>
<h4>
  <a name="1198398"> </a>Declared In 
</h4>
<code>GcRender.h<a name="1198399"> </a></code><h4>
  <a name="1198400"> </a>Prototype 
</h4>
<pre class="proto"><a name="1198401"></a>uint16_t GcGetBitmapDensity (
   GcBitmapHandle <code class="par">bitmapHandle</code>
)
</pre>
<h4>
  <a name="1198402"> </a>Parameters 
</h4>

<dl>
<dt><a name="1200657"> </a><code>&rarr;  <i>bitmapHandle</i></code></dt>
<dd><a name="1200661"> </a>The bitmap. Use <a href="UI_Form.html#1329509"><code>FrmGetBitmapHandle()</code></a> or <a href="UI_GraphicContext.html#1170870"><code>GcLoadBitmap()</code></a> to obtain a <code>GcBitmapHandle</code> to a bitmap. </dd>

</dl>
<h4>
  <a name="1198404"> </a>Returns 
</h4>

<p><a name="1198405"> </a>One of the <a href="UI_Bitmap.html#1004149"><code>DensityType</code></a> constants, specifying the density of the bitmap. </p>
<h4>
  <a name="1210924"> </a>Comments 
</h4>

<p><a name="1211006"> </a>Because the bitmap is scaled when it is loaded into a <code>GcBitmapHandle</code>, the density returned by this function may not be the density set in the bitmap resource. For example, if you have a low-density bitmap and you are drawing to a high-density display, the bitmap is scaled to high density. <code>GcGetBitmapDensity()</code> returns <code>kDensityDouble</code>. </p>

<h3 class="hbH3">
  <a name="1198411"> </a>GcGetBitmapDepth Function <a href="#608590"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="1198413"> </a>Purpose 
</h4>

<p><a name="1198414"> </a>Retrieves the depth of a bitmap. </p>
<h4>
  <a name="1198415"> </a>Declared In 
</h4>
<code>GcRender.h<a name="1198416"> </a></code><h4>
  <a name="1198417"> </a>Prototype 
</h4>
<pre class="proto"><a name="1198418"></a>uint32_t GcGetBitmapDepth (
   GcBitmapHandle <code class="par">bitmapHandle</code>
)
</pre>
<h4>
  <a name="1198419"> </a>Parameters 
</h4>

<dl>
<dt><a name="1198420"> </a><code>&rarr;  <i><code class="par">bitmapHandle</code></i></code></dt>
<dd><a name="1201725"> </a>The bitmap. Use <a href="UI_Form.html#1329509"><code>FrmGetBitmapHandle()</code></a> or <a href="UI_GraphicContext.html#1170870"><code>GcLoadBitmap()</code></a> to obtain a <code>GcBitmapHandle</code> to a bitmap.</dd>

</dl>
<h4>
  <a name="1198421"> </a>Returns 
</h4>

<p><a name="1198422"> </a>The bit depth of a bitmap. </p>

<h3 class="hbH3">
  <a name="1198428"> </a>GcGetBitmapHeight Function <a href="#608590"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="1198430"> </a>Purpose 
</h4>

<p><a name="1198431"> </a>Returns the height of a bitmap. </p>
<h4>
  <a name="1198432"> </a>Declared In 
</h4>
<code>GcRender.h<a name="1198433"> </a></code><h4>
  <a name="1198434"> </a>Prototype 
</h4>
<pre class="proto"><a name="1198435"></a>uint32_t GcGetBitmapHeight (
   GcBitmapHandle <code class="par">bitmapHandle</code>
)
</pre>
<h4>
  <a name="1198436"> </a>Parameters 
</h4>

<dl>
<dt><a name="1202490"> </a><code>&rarr;  <i><code class="par">bitmapHandle</code></i></code></dt>
<dd><a name="1202495"> </a>The bitmap. Use <a href="UI_Form.html#1329509"><code>FrmGetBitmapHandle()</code></a> or <a href="UI_GraphicContext.html#1170870"><code>GcLoadBitmap()</code></a> to obtain a <code>GcBitmapHandle</code> to a bitmap.</dd>

</dl>
<h4>
  <a name="1198438"> </a>Returns 
</h4>

<p><a name="1198439"> </a>Returns the bitmap's height in the bitmap's native coordinates.</p>
<h4>
  <a name="1209481"> </a>Comments 
</h4>

<p><a name="1210279"> </a>You can use <a href="UI_GraphicContext.html#1198394"><code>GcGetBitmapDensity()</code></a> to determine the bitmap's native density and then convert the value returned by <code>GcGetBitmapHeight()</code> to whatever coordinate system you want with the <a href="UI_Window.html#1710064"><code>WinConvertCoord()</code></a> function. </p>

<p><a name="1210472"> </a>Note that the bitmap is scaled when it is loaded into a <code>GcBitmapHandle</code>, so the density returned by <a href="UI_GraphicContext.html#1198394"><code>GcGetBitmapDensity()</code></a> may not be the density set in the bitmap resource. For example, if you have a low-density bitmap of 16 <span style="color: #000000;  font-style: normal; font-weight: normal; text-decoration: none; text-transform: none; vertical-align: baseline">X</span> 16 pixels and you are drawing to a high-density display, the bitmap is scaled to high density. <code>GcGetBitmapDensity()</code> returns <code>kDensityDouble</code>, and <code>GcGetBitmapHeight()</code> returns 32. </p>

<h3 class="hbH3">
  <a name="1198445"> </a>GcGetBitmapWidth Function <a href="#608590"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="1198447"> </a>Purpose 
</h4>

<p><a name="1198448"> </a>Returns the width of the bitmap. </p>
<h4>
  <a name="1198449"> </a>Declared In 
</h4>
<code>GcRender.h<a name="1198450"> </a></code><h4>
  <a name="1198451"> </a>Prototype 
</h4>
<pre class="proto"><a name="1198452"></a>uint32_t GcGetBitmapWidth (
   GcBitmapHandle <code class="par">bitmapHandle</code>
)
</pre>
<h4>
  <a name="1198453"> </a>Parameters 
</h4>

<dl>
<dt><a name="1203320"> </a><code>&rarr;  <i><code class="par">bitmapHandle</code></i></code></dt>
<dd><a name="1203325"> </a>The bitmap. Use <a href="UI_Form.html#1329509"><code>FrmGetBitmapHandle()</code></a> or <a href="UI_GraphicContext.html#1170870"><code>GcLoadBitmap()</code></a> to obtain a <code>GcBitmapHandle</code> to a bitmap.</dd>

</dl>
<h4>
  <a name="1198455"> </a>Returns 
</h4>

<p><a name="1203498"> </a>Returns the bitmap's width in the bitmap's native coordinates. </p>
<h4>
  <a name="1211128"> </a>Comments 
</h4>

<p><a name="1211132"> </a>You can use <a href="UI_GraphicContext.html#1198394"><code>GcGetBitmapDensity()</code></a> to determine the bitmap's native density and then convert the value returned by <code>GcGetBitmapWidth()</code> to whatever coordinate system you want with the <a href="UI_Window.html#1710064"><code>WinConvertCoord()</code></a> function. </p>

<p><a name="1211136"> </a>Note that the bitmap is scaled when it is loaded into a <code>GcBitmapHandle</code>, so the density returned by <a href="UI_GraphicContext.html#1198394"><code>GcGetBitmapDensity()</code></a> may not be the density set in the bitmap resource. For example, if you have a low-density bitmap of 16 <span style="color: #000000;  font-style: normal; font-weight: normal; text-decoration: none; text-transform: none; vertical-align: baseline">X</span> 16 pixels and you are drawing to a high-density display, the bitmap is scaled to high density. <code>GcGetBitmapDensity()</code> returns <code>kDensityDouble</code>, and <code>GcGetBitmapWidth()</code> returns 32. </p>

<h3 class="hbH3">
  <a name="1114107"> </a>GcGetCurrentContext Function <a href="#608590"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="1044356"> </a>Purpose 
</h4>

<p><a name="1044357"> </a>Creates the graphics context for the current draw window. </p>
<h4>
  <a name="1044358"> </a>Declared In 
</h4>
<code>GcRender.h<a name="994803"> </a></code><h4>
  <a name="994804"> </a>Prototype 
</h4>
<pre class="proto"><a name="993017"></a>GcHandle GcGetCurrentContext (
   void
)
</pre>
<h4>
  <a name="1002757"> </a>Parameters 
</h4>

<p><a name="1002772"> </a>None.</p>
<h4>
  <a name="1002777"> </a>Returns 
</h4>

<p><a name="1002788"> </a>A handle to the current context (see <a href="UI_GraphicContext.html#993718"><code>GcHandle</code></a>) or <code>NULL</code> if the graphics context could not be created.</p>
<h4>
  <a name="1002793"> </a>Comments 
</h4>

<p><a name="1045169"> </a>Use this function to obtain the <a href="UI_GraphicContext.html#993718"><code>GcHandle</code></a> that you pass to all other drawing functions. </p>

<p><a name="1131168"> </a>If you are drawing to an on-screen window, call this function in response to a <a href="UI_Form.html#1089359"><code>frmUpdateEvent</code></a>. If the draw window is an update-based window, this function returns <code>NULL</code> unless called in response to an update event. If the draw window is a transitional window, you can obtain a graphics handle at any time after the first <a href="UI_Window.html#1357625"><code>winResizedEvent</code></a> is posted; however, it is still a good idea to only draw in response to an update event. </p>

<div><hr>
  <a name="1213102"> </a> <span class="warning">WARNING! </span> Check the return value from this function before passing it to any other drawing functions. Drawing into a <code>NULL</code> graphics context causes the application to crash. 
<hr>
</div>

<p><a name="1099914"> </a>To draw to an off-screen window, create the window first and then call <a href="UI_Window.html#1542343"><code>WinSetDrawWindow()</code></a> before calling <code>GcGetCurrentContext()</code>. </p>

<p><a name="1045314"> </a>To draw into a bitmap, use <a href="UI_GraphicContext.html#994782"><code>GcCreateBitmapContext()</code></a> instead of this function. </p>

<p><a name="1090712"> </a>You must call <a href="UI_GraphicContext.html#994064"><code>GcReleaseContext()</code></a> when you are finished drawing. </p>
<h4>
  <a name="1044644"> </a>See Also 
</h4>

<p><a name="1150368"> </a><a href="UI_Window.html#1486637"><code>WinGetActiveWindow()</code></a></p>

<h3 class="hbH3">
  <a name="1116573"> </a>GcInitGradient Function <a href="#608590"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="1116575"> </a>Purpose 
</h4>

<p><a name="1116579"> </a>Creates a gradient for later use with the <a href="UI_GraphicContext.html#1125766"><code>GcSetGradient()</code></a> function. </p>
<h4>
  <a name="1116580"> </a>Declared In 
</h4>
<code>GcRender.h<a name="1116581"> </a></code><h4>
  <a name="1116582"> </a>Prototype 
</h4>
<pre class="proto"><a name="1116583"></a>status_t GcInitGradient (
   GcGradientType *<code class="par">gradient</code>,
   const GcPointType *<code class="par">points</code>,
   const GcColorType *<code class="par">colors</code>,
   uint32_t <code class="par">num</code>
)
</pre>
<h4>
  <a name="1116584"> </a>Parameters 
</h4>

<dl>
<dt><a name="1116585"> </a><code>&larr;  <i>gradient</i></code></dt>
<dd><a name="1116589"> </a>Contains the gradient upon return. See <a href="UI_GraphicContext.html#992989"><code>GcGradientType</code></a>. </dd>

<dt><a name="1116590"> </a><code>&rarr;  <i>points</i></code></dt>
<dd><a name="1116594"> </a>An array of points (see <a href="UI_GcFont.html#1025979"><code>GcPointType</code></a>). The number of points is specified in <code class="par">num</code>. </dd>

<dt><a name="1116595"> </a><code>&rarr;  <i>colors</i></code></dt>
<dd><a name="1116599"> </a>An array of colors (see <a href="UI_GraphicContext.html#1034953"><code>GcColorType</code></a>). The number of colors is specified in <code class="par">num</code>. </dd>

<dt><a name="1116600"> </a><code>&rarr;  <i>num</i></code></dt>
<dd><a name="1116601"> </a>The number of points and colors. Must be either 2 or 3. </dd>

</dl>
<h4>
  <a name="1116602"> </a>Returns 
</h4>

<p><a name="1116603"> </a>Returns <code>errNone</code> upon success or &#8211;1 if the <code class="par">num</code> parameter is invalid. </p>
<h4>
  <a name="1116604"> </a>Comments 
</h4>

<p><a name="1116605"> </a>This function creates a gradient using the values specified. If you've specified two points and two colors, this function creates a gradient that begins at the first point with the first color and ends at the second point with the color gradually becoming the ending color. </p>

<p><a name="1116606"> </a>If three values are specified, the gradient works in a triangular fashion with each color starting at its corresponding point and gradually blending into the next color as it approaches that point. </p>

<p><a name="1116607"> </a>You generally specify a gradient that represents the entire screen and then use a clipping region to constrain the drawing of the gradient to a particular area. </p>
<h4>
  <a name="1116608"> </a>See Also 
</h4>

<p><a name="1116615"> </a><a href="UI_GraphicContext.html#1125766"><code>GcSetGradient()</code></a>, <a href="UI_GraphicContext.html#1104793"><code>GcBeginClip()</code></a></p>

<h3 class="hbH3">
  <a name="1198683"> </a>GcIsBitmapAlphaOnly Function <a href="#608590"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="1198685"> </a>Purpose 
</h4>

<p><a name="1198686"> </a>Returns whether the bitmap contains only an alpha channel. </p>
<h4>
  <a name="1198687"> </a>Declared In 
</h4>
<code>GcRender.h<a name="1198688"> </a></code><h4>
  <a name="1198689"> </a>Prototype 
</h4>
<pre class="proto"><a name="1198690"></a>Boolean GcIsBitmapAlphaOnly (
   GcBitmapHandle <code class="par">bitmapHandle</code>
)
</pre>
<h4>
  <a name="1198691"> </a>Parameters 
</h4>

<dl>
<dt><a name="1198692"> </a><code>&rarr;  <i>bitmapHandle</i></code></dt>
<dd><a name="1204172"> </a>The bitmap. Use <a href="UI_Form.html#1329509"><code>FrmGetBitmapHandle()</code></a> or <a href="UI_GraphicContext.html#1170870"><code>GcLoadBitmap()</code></a> to obtain a <code>GcBitmapHandle</code> to a bitmap.</dd>

</dl>
<h4>
  <a name="1198694"> </a>Returns 
</h4>

<p><a name="1198695"> </a><code>true</code> if the bitmap contains only an alpha channel, or <code>false</code> otherwise. </p>
<h4>
  <a name="1198696"> </a>Comments 
</h4>

<p><a name="1198697"> </a>Bitmaps containing only an alpha channel are drawn using the current color (set by <a href="UI_GraphicContext.html#1124873"><code>GcSetColor()</code></a>) and blended with the destination per the alpha channel. </p>

<h3 class="hbH3">
  <a name="1118074"> </a>GcLineTo Function <a href="#608590"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="1118076"> </a>Purpose 
</h4>

<p><a name="1118077"> </a>Adds a straight line to the path. The line goes from the current point to the specified point. </p>
<h4>
  <a name="1118078"> </a>Declared In 
</h4>
<code>GcRender.h<a name="1118079"> </a></code><h4>
  <a name="1118080"> </a>Prototype 
</h4>
<pre class="proto"><a name="1118081"></a>void GcLineTo (
   GcHandle <code class="par">ctxt</code>,
   fcoord_t <code class="par">x</code>,
   fcoord_t y
)
</pre>
<h4>
  <a name="1118082"> </a>Parameters 
</h4>

<dl>
<dt><a name="1118083"> </a><code>&rarr;  <i>ctxt</i></code></dt>
<dd><a name="1118084"> </a>The graphics context. </dd>

<dt><a name="1118085"> </a><code>&rarr;  <i>x, y</i></code></dt>
<dd><a name="1118086"> </a>Ending point of the line to draw. This point becomes the current point. </dd>

</dl>
<h4>
  <a name="1118087"> </a>Returns 
</h4>

<p><a name="1118088"> </a>Nothing. </p>
<h4>
  <a name="1118089"> </a>Comments 
</h4>

<p><a name="1118090"> </a>This function adds to the current path in the rendering state; it does not draw to the screen. To draw the current path to the screen, call <a href="UI_GraphicContext.html#1120151"><code>GcPaint()</code></a>.</p>
<h4>
  <a name="1118094"> </a>See Also 
</h4>

<p><a name="1118098"> </a><a href="UI_GraphicContext.html#1108164"><code>GcClosePath()</code></a></p>

<h3 class="hbH3">
  <a name="1170870"> </a>GcLoadBitmap Function <a href="#608590"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="1170872"> </a>Purpose 
</h4>

<p><a name="1170873"> </a>Converts a bitmap into a format that is most efficient for the rendering system to display on screen. </p>
<h4>
  <a name="1170874"> </a>Declared In 
</h4>
<code>GcRender.h<a name="1170875"> </a></code><h4>
  <a name="1170876"> </a>Prototype 
</h4>
<pre class="proto"><a name="1198816"></a>GcBitmapHandle GcLoadBitmap (
   WinHandle <code class="par">win</code>,
   const void <code class="par">*bitmapFileP</code>,
   size_t <code class="par">size</code>,
   uint32_t <code class="par">flags</code>
)
</pre>
<h4>
  <a name="1170878"> </a>Parameters 
</h4>

<dl>
<dt><a name="1170879"> </a><code>&rarr;  <i>win</i></code></dt>
<dd><a name="1198819"> </a>A handle to the form's window. </dd>

<dt><a name="1222533"> </a><code>&rarr;  <i><code class="par">bitmapFileP</code></i></code></dt>
<dd><a name="1222537"> </a>A pointer to a <a href="UI_Bitmap.html#1003681"><code>BitmapType</code></a> structure or a PNG as loaded from a resource file. </dd>

<dt><a name="1198889"> </a><code>&rarr;  <i>size</i></code></dt>
<dd><a name="1198890"> </a>The size of the <code class="par">bitmapFileP</code> parameter. </dd>

<dt><a name="1198891"> </a><code>&rarr;  <i>flags</i></code></dt>
<dd><a name="1198904"> </a>One of the <a href="UI_GraphicContext.html#1198199">Bitmap Loading</a> constants, which specifies how the bitmap is scaled when it is drawn. </dd>

</dl>
<h4>
  <a name="1170883"> </a>Returns 
</h4>

<p><a name="1170884"> </a>A <code>GcBitmapHandle</code> in the closest match to the screen density and bit depth. </p>
<h4>
  <a name="1170885"> </a>Comments 
</h4>

<p><a name="1206554"> </a>You generally don't use this function directly. Instead, use <a href="UI_Form.html#1329509"><code>FrmGetBitmapHandle()</code></a>. </p>

<p><a name="1170886"> </a>For backward compatibility, the <a href="UI_Bitmap.html#1003681"><code>BitmapType</code></a> stores a bitmap's data in big-endian format. This function converts a bitmap into the little-endian format that is used in Palm OS<sup>&#174;</sup> Cobalt and performs any other conversions that might make it more efficient to draw this bitmap to the screen. </p>

<p><a name="1173862"> </a>This function makes a copy of the data, so the original bitmap can be deallocated any time after this function is called. </p>

<p><a name="1173881"> </a>If the bitmap has multiple depths (is a bitmap family), the closest match less than or equal to the current draw window depth is selected from that family and converted. If such a bitmap does not exist, the bitmap with the closest match greater than the draw window depth is used. </p>

<p><a name="1173962"> </a>Call <a href="UI_GraphicContext.html#1171079"><code>GcReleaseBitmap()</code></a> when you are finished with the bitmap. </p>
<h4>
  <a name="1170887"> </a>See Also 
</h4>

<p><a name="1170888"> </a><a href="UI_GraphicContext.html#1170306"><code>GcDrawBitmapAt()</code></a>, <a href="UI_GraphicContext.html#1170627"><code>GcDrawRawBitmapAt()</code></a></p>

<h3 class="hbH3">
  <a name="1118101"> </a>GcMoveTo Function <a href="#608590"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="1118103"> </a>Purpose 
</h4>

<p><a name="1118104"> </a>Moves the current point to the coordinates specified. </p>
<h4>
  <a name="1118105"> </a>Declared In 
</h4>
<code>GcRender.h<a name="1118106"> </a></code><h4>
  <a name="1118107"> </a>Prototype 
</h4>
<pre class="proto"><a name="1118108"></a>void GcMoveTo (
   GcHandle <code class="par">ctxt</code>,
   fcoord_t <code class="par">x</code>,
   fcoord_t <code class="par">y</code>
)
</pre>
<h4>
  <a name="1118109"> </a>Parameters 
</h4>

<dl>
<dt><a name="1118110"> </a><code>&rarr;  <i>ctxt</i></code></dt>
<dd><a name="1118111"> </a>The graphics context.</dd>

<dt><a name="1118112"> </a><code>&rarr;  <i>x, y</i></code></dt>
<dd><a name="1118113"> </a>The point that should become the current point. </dd>

</dl>
<h4>
  <a name="1118114"> </a>Returns 
</h4>

<p><a name="1118115"> </a>Nothing. </p>
<h4>
  <a name="1118116"> </a>Comments 
</h4>

<p><a name="1118117"> </a>This function starts a new subpath by moving the current point to the location specified without adding anything to the current path other than this point. </p>

<p><a name="1118118"> </a>You can think of this function as lifting your pencil and moving it to the specified coordinates. All future drawing starts from this point. </p>

<h3 class="hbH3">
  <a name="1120151"> </a>GcPaint Function <a href="#608590"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="1120153"> </a>Purpose 
</h4>

<p><a name="1120154"> </a>Paints the current path onto the screen. </p>
<h4>
  <a name="1120155"> </a>Declared In 
</h4>
<code>GcRender.h<a name="1120156"> </a></code><h4>
  <a name="1120157"> </a>Prototype 
</h4>
<pre class="proto"><a name="1120158"></a>void GcPaint (
   GcHandle <code class="par">ctxt</code>
)
</pre>
<h4>
  <a name="1120159"> </a>Parameters 
</h4>

<dl>
<dt><a name="1120160"> </a><code>&rarr;  <i>ctxt</i></code></dt>
<dd><a name="1120161"> </a>The graphics context. </dd>

</dl>
<h4>
  <a name="1120162"> </a>Returns 
</h4>

<p><a name="1120163"> </a>Nothing. </p>
<h4>
  <a name="1120164"> </a>Comments 
</h4>

<p><a name="1143342"> </a>This function draws the path as specified by the current rendering state and constrained by the current clipping region. Then it clears the current path. It does not clear any other aspect of the rendering state. </p>

<p><a name="1143343"> </a><code>GcPaint()</code> fills the current path with the current color. If you've defined a non-closed path and you call <code>GcPaint()</code>, the result is undefined. To paint just the outline of the path, call <a href="UI_GraphicContext.html#994955"><code>GcStroke()</code></a> before calling <code>GcPaint()</code>. When you call <code>GcStroke()</code>, <code>GcPaint()</code> paints the outline of the current path using the current pen size, cap styles, and line join styles. </p>

<p><a name="1120170"> </a><code>GcPaint()</code> is also used to specify the clipping region. If <code>GcPaint() </code>is called in between calls to <a href="UI_GraphicContext.html#1104793"><code>GcBeginClip()</code></a> and <a href="UI_GraphicContext.html#1112161"><code>GcEndClip()</code></a>, it fills the specified region with white and all subsequent calls to <code>GcPaint()</code> up to the next <a href="UI_GraphicContext.html#1121283"><code>GcPopState()</code></a> are constrained to the points within that region. </p>

<h3 class="hbH3">
  <a name="1120182"> </a>GcPaintBitmap Function <a href="#608590"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="1120184"> </a>Purpose 
</h4>

<p><a name="1120185"> </a>Fills the current path with the specified bitmap. </p>
<h4>
  <a name="1120186"> </a>Declared In 
</h4>
<code>GcRender.h<a name="1120187"> </a></code><h4>
  <a name="1120188"> </a>Prototype 
</h4>
<pre class="proto"><a name="1120189"></a>void GcPaintBitmap (
   GcHandle <code class="par">ctxt</code>,
   GcBitmapHandle <code class="par">bitmapHandle</code>
)
</pre>
<h4>
  <a name="1120190"> </a>Parameters 
</h4>

<dl>
<dt><a name="1120191"> </a><code>&rarr;  <i>ctxt</i></code></dt>
<dd><a name="1120192"> </a>The graphics context.</dd>

<dt><a name="1120193"> </a><code>&rarr;  <i>bitmapHandle</i></code></dt>
<dd><a name="1120194"> </a>The bitmap to draw to the screen. Use <a href="UI_GraphicContext.html#1170870"><code>GcLoadBitmap()</code></a> to obtain a <code>GcBitmapHandle</code> to a bitmap. </dd>

</dl>
<h4>
  <a name="1120195"> </a>Returns 
</h4>

<p><a name="1120196"> </a>Nothing.</p>
<h4>
  <a name="1120197"> </a>Comments 
</h4>

<p><a name="1180097"> </a>Think of this function as painting with a bitmap instead of with the current color. It fills the current path with the bitmap, tiling the bitmap if necessary. This function clears the current path but no other aspect of the rendering state. Most of the rendering state does not affect this call. </p>
<h4>
  <a name="1120215"> </a>See Also 
</h4>

<p><a name="1120219"> </a><a href="UI_GraphicContext.html#994782"><code>GcCreateBitmapContext()</code></a>, <a href="UI_GraphicContext.html#1170306"><code>GcDrawBitmapAt()</code></a>, <a href="UI_GraphicContext.html#1170627"><code>GcDrawRawBitmapAt()</code></a>, <a href="UI_GraphicContext.html#1170870"><code>GcLoadBitmap()</code></a></p>

<h3 class="hbH3">
  <a name="1121283"> </a>GcPopState Function <a href="#608590"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="1121285"> </a>Purpose 
</h4>

<p><a name="1121286"> </a>Restores the previous rendering state. </p>
<h4>
  <a name="1121287"> </a>Declared In 
</h4>
<code>GcRender.h<a name="1121288"> </a></code><h4>
  <a name="1121289"> </a>Prototype 
</h4>
<pre class="proto"><a name="1121290"></a>void GcPopState (
   GcHandle <code class="par">ctxt</code>
)
</pre>
<h4>
  <a name="1121291"> </a>Parameters 
</h4>

<dl>
<dt><a name="1121292"> </a><code>&rarr;  <i>ctxt</i></code></dt>
<dd><a name="1121293"> </a>The graphics context.</dd>

</dl>
<h4>
  <a name="1121294"> </a>Returns 
</h4>

<p><a name="1121295"> </a>Nothing.</p>
<h4>
  <a name="1121296"> </a>See Also 
</h4>

<p><a name="1121300"> </a><a href="UI_GraphicContext.html#1121303"><code>GcPushState()</code></a></p>

<h3 class="hbH3">
  <a name="1121303"> </a>GcPushState Function <a href="#608590"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="1121305"> </a>Purpose 
</h4>

<p><a name="1121306"> </a>Saves the current rendering state. </p>
<h4>
  <a name="1121307"> </a>Declared In 
</h4>
<code>GcRender.h<a name="1121308"> </a></code><h4>
  <a name="1121309"> </a>Prototype 
</h4>
<pre class="proto"><a name="1121310"></a>void GcPushState (
   GcHandle <code class="par">ctxt</code>
)
</pre>
<h4>
  <a name="1121311"> </a>Parameters 
</h4>

<dl>
<dt><a name="1121312"> </a><code>&rarr;  <i>ctxt</i></code></dt>
<dd><a name="1121313"> </a>The graphics context.</dd>

</dl>
<h4>
  <a name="1121314"> </a>Returns 
</h4>

<p><a name="1121315"> </a>Nothing.</p>
<h4>
  <a name="1121316"> </a>Comments 
</h4>

<p><a name="1121317"> </a>The rendering state is specified by calls to most of the other functions in <code>GcRender.h</code>. </p>

<p><a name="1121318"> </a>The state includes the clipping region and the current path. <code>GcPushState()</code> is often used to preserve the current path before making some other change. </p>
<h4>
  <a name="1121319"> </a>See Also 
</h4>

<p><a name="1121323"> </a><a href="UI_GraphicContext.html#1121283"><code>GcPopState()</code></a></p>

<h3 class="hbH3">
  <a name="1122410"> </a>GcRect Function <a href="#608590"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="1197617"> </a>Purpose 
</h4>

<p><a name="1197618"> </a>Adds a rectangle to the path. </p>
<h4>
  <a name="1197619"> </a>Declared In 
</h4>
<code>GcRender.h<a name="1122415"> </a></code><h4>
  <a name="1122416"> </a>Prototype 
</h4>
<pre class="proto"><a name="1122417"></a>void GcRect (
   GcHandle <code class="par">ctxt</code>,
   fcoord_t <code class="par">left</code>,
   fcoord_t <code class="par">top</code>,
   fcoord_t <code class="par">right</code>,
   fcoord_t <code class="par">bottom</code>
)
</pre>
<h4>
  <a name="1122418"> </a>Parameters 
</h4>

<dl>
<dt><a name="1122419"> </a><code>&rarr;  <i><code class="par">ctxt</code></i></code></dt>
<dd><a name="1122420"> </a>The graphics context. </dd>

<dt><a name="1122421"> </a><code>&rarr;  <i><code class="par">left</code></i></code></dt>
<dd><a name="1122422"> </a>x coordinate of the left side of the rectangle. </dd>

<dt><a name="1122423"> </a><code>&rarr;  <i><code class="par">top</code></i></code></dt>
<dd><a name="1122424"> </a>y coordinate of the top of the rectangle. </dd>

<dt><a name="1122425"> </a><code>&rarr;  <i><code class="par">right</code></i></code></dt>
<dd><a name="1122426"> </a>x coordinate of the right side of the rectangle. </dd>

<dt><a name="1122427"> </a><code>&rarr;  <i><code class="par">bottom</code></i></code></dt>
<dd><a name="1122428"> </a>y coordinate of the bottom of the rectangle. </dd>

</dl>
<h4>
  <a name="1122429"> </a>Returns 
</h4>

<p><a name="1122430"> </a>Nothing.</p>
<h4>
  <a name="1122431"> </a>Comments 
</h4>

<p><a name="1122432"> </a>The current point is moved to the top-left corner before the rectangle is added to the path. The rectangle is drawn clockwise from the top left corner, resulting in a current point that is the top left corner of the rectangle. </p>

<p><a name="1122433"> </a><code>GcRect()</code> is optimized for speed; always use it when you want to draw a square or rectangular region. </p>

<p><a name="1122434"> </a>This function adds to the current path in the rendering state; it does not draw to the screen. To draw the current path to the screen, call <a href="UI_GraphicContext.html#1120151"><code>GcPaint()</code></a>.</p>
<h4>
  <a name="1122438"> </a>See Also 
</h4>

<p><a name="1122442"> </a><a href="UI_GraphicContext.html#994936"><code>GcRoundRect()</code></a>, <a href="UI_GraphicContext.html#1188193"><code>GcRectI()</code></a></p>

<h3 class="hbH3">
  <a name="1188193"> </a>GcRectI Function <a href="#608590"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="1188195"> </a>Purpose 
</h4>

<p><a name="1193702"> </a>Adds a rectangle to the path using integer coordinates to define the rectangle. </p>
<h4>
  <a name="1188197"> </a>Declared In 
</h4>
<code>GcRender.h<a name="1188198"> </a></code><h4>
  <a name="1188199"> </a>Prototype 
</h4>
<pre class="proto"><a name="1188200"></a>void GcRectI (
   GcHandle <code class="par">ctxt</code>,
   int32_t <code class="par">left</code>,
   int32_t <code class="par">top</code>,
   int32_t <code class="par">right</code>,
   int32_t <code class="par">bottom</code>
)
</pre>
<h4>
  <a name="1188201"> </a>Parameters 
</h4>

<dl>
<dt><a name="1188202"> </a><code>&rarr;  <i>ctxt</i></code></dt>
<dd><a name="1193746"> </a>The graphics context. </dd>

<dt><a name="1188204"> </a><code>&rarr;  <i>left</i></code></dt>
<dd><a name="1193790"> </a>y coordinate of the top of the rectangle. </dd>

<dt><a name="1188206"> </a><code>&rarr;  <i>top</i></code></dt>
<dd><a name="1193834"> </a>y coordinate of the top of the rectangle. </dd>

<dt><a name="1188208"> </a><code>&rarr;  <i>right</i></code></dt>
<dd><a name="1193878"> </a>x coordinate of the right side of the rectangle. </dd>

<dt><a name="1188210"> </a><code>&rarr;  <i>bottom</i></code></dt>
<dd><a name="1193922"> </a>y coordinate of the bottom of the rectangle. </dd>

</dl>
<h4>
  <a name="1188212"> </a>Returns 
</h4>

<p><a name="1193966"> </a>Nothing.</p>
<h4>
  <a name="1188214"> </a>Comments 
</h4>

<p><a name="1188215"> </a>This function differs from <a href="UI_GraphicContext.html#1122410"><code>GcRect()</code></a> in that it takes integer coordinates rather than floating-point coordinates. </p>

<h3 class="hbH3">
  <a name="1123136"> </a>GcReflect Function <a href="#608590"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="1123138"> </a>Purpose 
</h4>

<p><a name="1123139"> </a>Flips the coordinate system at the specified radius. </p>
<h4>
  <a name="1123140"> </a>Declared In 
</h4>
<code>GcRender.h<a name="1123141"> </a></code><h4>
  <a name="1123142"> </a>Prototype 
</h4>
<pre class="proto"><a name="1123143"></a>void GcReflect (
   GcHandle <code class="par">ctxt</code>,
   fcoord_t <code class="par">rad</code>
)
</pre>
<h4>
  <a name="1123144"> </a>Parameters 
</h4>

<dl>
<dt><a name="1123145"> </a><code>&rarr;  <i>ctxt</i></code></dt>
<dd><a name="1123146"> </a>The graphics context.</dd>

<dt><a name="1123147"> </a><code>&rarr;  <i>rad</i></code></dt>
<dd><a name="1123148"> </a>The angle of the axis of symmetry. </dd>

</dl>
<h4>
  <a name="1123149"> </a>Returns 
</h4>

<p><a name="1123150"> </a>Nothing.</p>
<h4>
  <a name="1123151"> </a>Comments 
</h4>

<p><a name="1123152"> </a>A two-dimensional transformation affects only the drawing functions called after it. If you call this function in the middle of a path definition, it applies only to those points in the path defined after this function is called. If you are creating a stroked path, call this and all other two-dimensional transformations before calling <a href="UI_GraphicContext.html#994955"><code>GcStroke()</code></a>. </p>

<p><a name="1220741"> </a>The axis of symmetry runs through the origin of the screen, which may cause some of the path to be drawn off screen. If you want to reflect the path along an axis that runs through the center of the screen, use <a href="UI_GraphicContext.html#995590"><code>GcTranslate()</code></a> to translate the origin of the screen to the center before calling this function. See <a href="UI_GraphicContext.html#1123487"><code>GcRotate()</code></a> for sample code. </p>
<h4>
  <a name="1123156"> </a>See Also 
</h4>

<p><a name="1123163"> </a><a href="UI_GraphicContext.html#1124400"><code>GcScale()</code></a>, <a href="UI_GraphicContext.html#1171204"><code>GcTransform()</code></a></p>

<h3 class="hbH3">
  <a name="1171079"> </a>GcReleaseBitmap Function <a href="#608590"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="1171081"> </a>Purpose 
</h4>

<p><a name="1171082"> </a>Releases the memory associated with the bitmap handle. </p>
<h4>
  <a name="1171083"> </a>Declared In 
</h4>
<code>GcRender.h<a name="1171084"> </a></code><h4>
  <a name="1171085"> </a>Prototype 
</h4>
<pre class="proto"><a name="1171086"></a>status_t GcReleaseBitmap (
   GcBitmapHandle <code class="par">bitmapHandle</code>
)
</pre>
<h4>
  <a name="1171087"> </a>Parameters 
</h4>

<dl>
<dt><a name="1171088"> </a><code>&rarr;  <i>bitmapHandle</i></code></dt>
<dd><a name="1171089"> </a>The bitmap to release. </dd>

</dl>
<h4>
  <a name="1171090"> </a>Returns 
</h4>

<p><a name="1171091"> </a>Always returns <code>errNone</code>. </p>
<h4>
  <a name="1171092"> </a>Comments 
</h4>

<p><a name="1171093"> </a>Memory is not actually deallocated until all pending drawing operations are complete. </p>

<p><a name="1177209"> </a>This function does <i>not</i> release a bitmap context. If you've used <a href="UI_GraphicContext.html#994782"><code>GcCreateBitmapContext()</code></a> to create a bitmap that receives drawing operations, use <a href="UI_GraphicContext.html#994064"><code>GcReleaseContext()</code></a> to release it. </p>
<h4>
  <a name="1171094"> </a>See Also 
</h4>

<p><a name="1171095"> </a><a href="UI_GraphicContext.html#1170870"><code>GcLoadBitmap()</code></a></p>

<h3 class="hbH3">
  <a name="994064"> </a>GcReleaseContext Function <a href="#608590"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="994652"> </a>Purpose 
</h4>

<p><a name="994663"> </a>Releases a rendering context.</p>
<h4>
  <a name="994687"> </a>Declared In 
</h4>
<code>GcRender.h<a name="994698"> </a></code><h4>
  <a name="994703"> </a>Prototype 
</h4>
<pre class="proto"><a name="993020"></a>void GcReleaseContext (
   GcHandle <code class="par">ctxt</code>
)
</pre>
<h4>
  <a name="1000908"> </a>Parameters 
</h4>

<dl>
<dt><a name="1001008"> </a><code>&rarr;  <i>ctxt</i></code></dt>
<dd><a name="1001229"> </a>The rendering context to release. </dd>

</dl>
<h4>
  <a name="1001258"> </a>Returns 
</h4>

<p><a name="1001304"> </a>Nothing.</p>
<h4>
  <a name="1001424"> </a>Comments 
</h4>

<p><a name="1048814"> </a>Call this function when you are finished drawing. It pops the current rendering state and releases the memory associated with the graphics context. </p>

<p><a name="1089919"> </a>If you do not release the graphics context, the user interface will eventually freeze. </p>
<h4>
  <a name="1001566"> </a>See Also 
</h4>

<p><a name="1001592"> </a><a href="UI_GraphicContext.html#994782"><code>GcCreateBitmapContext()</code></a>, <a href="UI_GraphicContext.html#1114107"><code>GcGetCurrentContext()</code></a></p>

<h3 class="hbH3">
  <a name="1123487"> </a>GcRotate Function <a href="#608590"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="1123489"> </a>Purpose 
</h4>

<p><a name="1123490"> </a>Rotates the coordinate system the number of radians. </p>
<h4>
  <a name="1123491"> </a>Declared In 
</h4>
<code>GcRender.h<a name="1123492"> </a></code><h4>
  <a name="1123493"> </a>Prototype 
</h4>
<pre class="proto"><a name="1123494"></a>void GcRotate (
   GcHandle <code class="par">ctxt</code>,
   fcoord_t <code class="par">rad</code>
)
</pre>
<h4>
  <a name="1123495"> </a>Parameters 
</h4>

<dl>
<dt><a name="1123496"> </a><code>&rarr;  <i>ctxt</i></code></dt>
<dd><a name="1123497"> </a>The graphics context.</dd>

<dt><a name="1123498"> </a><code>&rarr;  <i>rad</i></code></dt>
<dd><a name="1123499"> </a>The number of radians by which to rotate the path. </dd>

</dl>
<h4>
  <a name="1123500"> </a>Returns 
</h4>

<p><a name="1123501"> </a>Nothing.</p>
<h4>
  <a name="1123502"> </a>Comments 
</h4>

<p><a name="1123503"> </a>A two-dimensional transformation affects only the drawing functions called after it. If you call this function in the middle of a path definition, it applies only to those points in the path defined after this function is called. If you are creating a stroked path, call this and all other two-dimensional transformations before calling <a href="UI_GraphicContext.html#994955"><code>GcStroke()</code></a>. </p>

<p><a name="1213538"> </a>This function rotates the path around the origin (top-left corner) of the screen. If you want to rotate around some other point, use <a href="UI_GraphicContext.html#995590"><code>GcTranslate()</code></a> to move the origin before you call this function. </p>
<h4>
  <a name="1216971"> </a>Example 
</h4>

<p><a name="1216996"> </a>The following code draws a square in the center of the screen and rotates it 45 degrees around the center of the screen. </p>

<div class="CodeRule"><hr></div><pre class="CodeBlock">
#define DegreesToRadians(x) (fcoord_t)(x * 3.14159/180)<a name="1217407"> </a>
<a name="1217042"> </a>
void RotateExample(FormType *pForm)<a name="1217447"> </a>
{<a name="1217043"> </a>
   GcHandle gc = GcGetCurrentContext();<a name="1217044"> </a>
   fcoord_t centerX, centerY, radius;<a name="1217045"> </a>
   fcoord_t extentX = kExtent, extentY = kExtent;<a name="1217046"> </a>
   fcoord_t startX, startY;<a name="1217047"> </a>
   RectangleType winBounds;<a name="1217049"> </a>
<a name="1217051"> </a>
   if (!gc) return;<a name="1217052"> </a>
<a name="1217053"> </a>
   // Compute bounds of window to decide how to center the <a name="1220572"> </a>
   // square. <a name="1220573"> </a>
   WinGetWindowBounds(&amp;winBounds);<a name="1217055"> </a>
   if (winBounds.extent.x) {<a name="1217056"> </a>
      centerX = ((fcoord_t)(winBounds.extent.x - <a name="1217057"> </a>
         winBounds.topLeft.x)) / 2;<a name="1217485"> </a>
      centerY = ((fcoord_t)(winBounds.extent.y - <a name="1217058"> </a>
         winBounds.topLeft.y)) / 2;<a name="1217486"> </a>
      startX = centerX - extentX/2;<a name="1217059"> </a>
      startY = centerY - extentY/2;<a name="1217060"> </a>
   } else {<a name="1217070"> </a>
      return;<a name="1218781"> </a>
   }<a name="1218782"> </a>
<a name="1217074"> </a>
   // Translate the origin of the screen to the center point <a name="1218302"> </a>
   // so that the rest of the transformation is applied from <a name="1218780"> </a>
   // the center rather than the screen's origin. <a name="1218405"> </a>
   GcTranslate(gc, centerX, centerY);<a name="1217097"> </a>
   // Now you need to adjust the starting coordinates <a name="1217098"> </a>
   // accordingly. <a name="1218779"> </a>
   startX -= centerX;<a name="1217099"> </a>
   startY -= centerY;<a name="1217100"> </a>
   // Set up transformation. <a name="1218801"> </a>
   GcRotate(gc, DegreesToRadians(45));<a name="1217109"> </a>
<a name="1217118"> </a>
   //Draw the shape and paint it. <a name="1217119"> </a>
   GcRect(gc, startX, startY, startX + extentX, startY + <a name="1217130"> </a>
      extentY);<a name="1219472"> </a>
   GcPaint(gc);<a name="1219460"> </a>
<a name="1219896"> </a>
   GcReleaseContext(gc);<a name="1219865"> </a>
   return;<a name="1217150"> </a>
}<a name="1217151"> </a>
</pre><div class="CodeRule"><hr></div>

<h4>
  <a name="1123507"> </a>See Also 
</h4>

<p><a name="1123514"> </a><a href="UI_GraphicContext.html#1123136"><code>GcReflect()</code></a>, <a href="UI_GraphicContext.html#1124400"><code>GcScale()</code></a>, <a href="UI_GraphicContext.html#1171204"><code>GcTransform()</code></a></p>

<h3 class="hbH3">
  <a name="994936"> </a>GcRoundRect Function <a href="#608590"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="994938"> </a>Purpose 
</h4>

<p><a name="994939"> </a>Creates a rectangle path with rounded corners. </p>
<h4>
  <a name="994940"> </a>Declared In 
</h4>
<code>GcRender.h<a name="994941"> </a></code><h4>
  <a name="994942"> </a>Prototype 
</h4>
<pre class="proto"><a name="993067"></a>void GcRoundRect (
   GcHandle <code class="par">ctxt</code>,
   fcoord_t <code class="par">left</code>,
   fcoord_t <code class="par">top</code>,
   fcoord_t <code class="par">right</code>,
   fcoord_t <code class="par">bottom</code>,
   fcoord_t <code class="par">radx</code>,
   fcoord_t <code class="par">rady</code>
)
</pre>
<h4>
  <a name="1004223"> </a>Parameters 
</h4>

<dl>
<dt><a name="1004224"> </a><code>&rarr;  <i><code class="par">ctxt</code></i></code></dt>
<dd><a name="1012439"> </a>The graphics context. </dd>

<dt><a name="1012441"> </a><code>&rarr;  <i><code class="par">left</code></i></code></dt>
<dd><a name="1100173"> </a>x coordinate of the left side of the rectangle. </dd>

<dt><a name="1100174"> </a><code>&rarr;  <i><code class="par">top</code></i></code></dt>
<dd><a name="1100175"> </a>y coordinate of the top of the rectangle. </dd>

<dt><a name="1100176"> </a><code>&rarr;  <i><code class="par">right</code></i></code></dt>
<dd><a name="1100177"> </a>x coordinate of the right side of the rectangle. </dd>

<dt><a name="1100178"> </a><code>&rarr;  <i><code class="par">bottom</code></i></code></dt>
<dd><a name="1100179"> </a>y coordinate of the bottom of the rectangle. </dd>

<dt><a name="1012656"> </a><code>&rarr;  <i><code class="par">radx</code></i></code></dt>
<dd><a name="1012657"> </a>The horizontal radius of each corner. </dd>

<dt><a name="1012796"> </a><code>&rarr;  <i><code class="par">rady</code></i></code></dt>
<dd><a name="1012797"> </a>The vertical radius of each corner. </dd>

</dl>
<h4>
  <a name="1004225"> </a>Returns 
</h4>

<p><a name="1004226"> </a>Nothing. </p>
<h4>
  <a name="1004227"> </a>Comments 
</h4>

<p><a name="1100183"> </a>The current point is moved to the top-left corner before the rectangle is added to the path. The rectangle is drawn clockwise from the top left corner, resulting in a current point that is the top left corner of the rectangle. </p>

<p><a name="1087127"> </a>The corners are constructed using the same algorithm that <a href="UI_GraphicContext.html#1103512"><code>GcArcTo()</code></a> uses. </p>

<p><a name="1100228"> </a>This function adds to the current path in the rendering state; it does not draw to the screen. To draw the current path to the screen, call <a href="UI_GraphicContext.html#1120151"><code>GcPaint()</code></a>.</p>
<h4>
  <a name="1100232"> </a>See Also 
</h4>

<p><a name="1124397"> </a><a href="UI_GraphicContext.html#1122410"><code>GcRect()</code></a>, <a href="UI_GraphicContext.html#1188193"><code>GcRectI()</code></a></p>

<h3 class="hbH3">
  <a name="1124400"> </a>GcScale Function <a href="#608590"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="1124287"> </a>Purpose 
</h4>

<p><a name="1124288"> </a>Scales the coordinate system. </p>
<h4>
  <a name="1124289"> </a>Declared In 
</h4>
<code>GcRender.h<a name="1124290"> </a></code><h4>
  <a name="1124291"> </a>Prototype 
</h4>
<pre class="proto"><a name="1124292"></a>void GcScale (
   GcHandle <code class="par">ctxt</code>,
   fcoord_t <code class="par">sx</code>,
   fcoord_t <code class="par">sy</code>
)
</pre>
<h4>
  <a name="1124293"> </a>Parameters 
</h4>

<dl>
<dt><a name="1124294"> </a><code>&rarr;  <i>ctxt</i></code></dt>
<dd><a name="1124295"> </a>The graphics context.</dd>

<dt><a name="1124296"> </a><code>&rarr;  <i>sx</i></code></dt>
<dd><a name="1124297"> </a>Horizontal scaling factor. This must be a positive value. </dd>

<dt><a name="1124298"> </a><code>&rarr;  <i>sy</i></code></dt>
<dd><a name="1124299"> </a>Vertical scaling factor. This must be a positive value. </dd>

</dl>
<h4>
  <a name="1124300"> </a>Returns 
</h4>

<p><a name="1124301"> </a>Nothing.</p>
<h4>
  <a name="1124302"> </a>Comments 
</h4>

<p><a name="1219898"> </a>A two-dimensional transformation affects only the drawing functions called after it. If you call this function in the middle of a path definition, it applies only to those points in the path defined after this function is called. If you are creating a stroked path, call this and all other two-dimensional transformations before calling <a href="UI_GraphicContext.html#994955"><code>GcStroke()</code></a>. </p>

<p><a name="1221495"> </a>Scaling occurs starting from the origin of the screen. If you want to scale a path with respect to its center, use <a href="UI_GraphicContext.html#995590"><code>GcTranslate()</code></a> to translate the origin to the path's center before scaling. See <a href="UI_GraphicContext.html#1123487"><code>GcRotate()</code></a> for sample code. </p>
<h4>
  <a name="1221502"> </a>See Also 
</h4>

<p><a name="1221512"> </a><a href="UI_GraphicContext.html#1123136"><code>GcReflect()</code></a>, <a href="UI_GraphicContext.html#1188452"><code>GcShear()</code></a>, <a href="UI_GraphicContext.html#1171204"><code>GcTransform()</code></a></p>

<h3 class="hbH3">
  <a name="1147963"> </a>GcSetAntialiasing Function <a href="#608590"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="1147965"> </a>Purpose 
</h4>

<p><a name="1147966"> </a>Specifies whether the rendering system uses antialiasing when drawing. </p>
<h4>
  <a name="1147967"> </a>Declared In 
</h4>
<code>GcRender.h<a name="1147968"> </a></code><h4>
  <a name="1147969"> </a>Prototype 
</h4>
<pre class="proto"><a name="1147970"></a>void GcSetAntialiasing (
   GcHandle <code class="par">ctxt</code>,
   uint32_t <code class="par">value</code>
)
</pre>
<h4>
  <a name="1147971"> </a>Parameters 
</h4>

<dl>
<dt><a name="1147972"> </a><code>&rarr;  <i>ctxt</i></code></dt>
<dd><a name="1147973"> </a>The graphics context.</dd>

<dt><a name="1147974"> </a><code>&rarr;  <i>value</i></code></dt>
<dd><a name="1147978"> </a>One of the <a href="UI_GcFont.html#997049"><code>GcAliasingTag</code></a> constants.</dd>

</dl>
<h4>
  <a name="1147979"> </a>Returns 
</h4>

<p><a name="1147980"> </a>Nothing.</p>
<h4>
  <a name="1147981"> </a>Comments 
</h4>

<p><a name="1147982"> </a>You rarely need to use this function. Do so only if you are creating a drawing application and want more control over the quality of the rendered image. The default value for antialiasing suffices in most cases. </p>

<p><a name="1147983"> </a>If the system does not support antialiasing, this setting is ignored.</p>
<h4>
  <a name="1195261"> </a>See Also 
</h4>

<p><a name="1195265"> </a><a href="UI_GcFont.html#995872"><code>GcSetFontAntialiasing()</code></a></p>

<h3 class="hbH3">
  <a name="1124840"> </a>GcSetCaps Function <a href="#608590"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="1124842"> </a>Purpose 
</h4>

<p><a name="1124843"> </a>Specifies what the line end points look like in a stroked path. </p>
<h4>
  <a name="1124844"> </a>Declared In 
</h4>
<code>GcRender.h<a name="1124845"> </a></code><h4>
  <a name="1124846"> </a>Prototype 
</h4>
<pre class="proto"><a name="1124847"></a>void GcSetCaps (
   GcHandle <code class="par">ctxt</code>,
   int32_t <code class="par">start_cap</code>,
   int32_t <code class="par">end_cap</code>
)
</pre>
<h4>
  <a name="1124848"> </a>Parameters 
</h4>

<dl>
<dt><a name="1124849"> </a><code>&rarr;  <i>ctxt</i></code></dt>
<dd><a name="1124850"> </a>The graphics context.</dd>

<dt><a name="1124851"> </a><code>&rarr;  <i><code class="par">start_cap</code></i></code></dt>
<dd><a name="1124855"> </a>A <a href="UI_GraphicContext.html#1016649"><code>GcCapTag</code></a> value that specifies how the start of each subpath will look. </dd>

<dt><a name="1124856"> </a><code>&rarr;  <i><code class="par">end_cap</code></i></code></dt>
<dd><a name="1124860"> </a>A <a href="UI_GraphicContext.html#1016649"><code>GcCapTag</code></a> value that specifies how the end of each subpath will look. </dd>

</dl>
<h4>
  <a name="1124861"> </a>Returns 
</h4>

<p><a name="1124862"> </a>Nothing.</p>
<h4>
  <a name="1124863"> </a>Comments 
</h4>

<p><a name="1124867"> </a>This function only affects paths where <a href="UI_GraphicContext.html#994955"><code>GcStroke()</code></a> is called before <a href="UI_GraphicContext.html#1120151"><code>GcPaint()</code></a>. </p>

<h3 class="hbH3">
  <a name="1124873"> </a>GcSetColor Function <a href="#608590"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="1124875"> </a>Purpose 
</h4>

<p><a name="1124879"> </a>Sets the color used with <a href="UI_GraphicContext.html#1120151"><code>GcPaint()</code></a>.</p>
<h4>
  <a name="1124880"> </a>Declared In 
</h4>
<code>GcRender.h<a name="1124881"> </a></code><h4>
  <a name="1124882"> </a>Prototype 
</h4>
<pre class="proto"><a name="1124883"></a>void GcSetColor (
   GcHandle <code class="par">ctxt</code>,
   uint8_t <code class="par">r</code>,
   uint8_t <code class="par">g</code>,
   uint8_t <code class="par">b</code>,
   uint8_t <code class="par">a</code>
)
</pre>
<h4>
  <a name="1124884"> </a>Parameters 
</h4>

<dl>
<dt><a name="1124885"> </a><code>&rarr;  <i>ctxt</i></code></dt>
<dd><a name="1124886"> </a>The graphics context.</dd>

<dt><a name="1124887"> </a><code>&rarr;  <i>r</i></code></dt>
<dd><a name="1124888"> </a>The red value.</dd>

<dt><a name="1124889"> </a><code>&rarr;  <i>g</i></code></dt>
<dd><a name="1124890"> </a>The green value.</dd>

<dt><a name="1124891"> </a><code>&rarr;  <i>b</i></code></dt>
<dd><a name="1124892"> </a>The blue value. </dd>

<dt><a name="1124893"> </a><code>&rarr;  <i>a</i></code></dt>
<dd><a name="1124894"> </a>The level of opacity where 255 is fully opaque. </dd>

</dl>
<h4>
  <a name="1124895"> </a>Returns 
</h4>

<p><a name="1124896"> </a>Nothing. </p>
<h4>
  <a name="1140681"> </a>Comments 
</h4>

<p><a name="1140694"> </a>Palm OS supports up to 16-bit direct color displays, which typically uses 5 bits for red, 6 bits for green, and 5 bits for blue. If you specify larger red, green, or blue values, the rendering system converts them before they are drawn to the screen. </p>
<h4>
  <a name="1124897"> </a>See Also 
</h4>

<p><a name="1124901"> </a><a href="UI_GraphicContext.html#1125766"><code>GcSetGradient()</code></a></p>

<h3 class="hbH3">
  <a name="1124904"> </a>GcSetCoordinateSystem Function <a href="#608590"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="1124906"> </a>Purpose 
</h4>

<p><a name="1124907"> </a>Sets the coordinate system used by subsequent drawing operations. </p>
<h4>
  <a name="1124908"> </a>Declared In 
</h4>
<code>GcRender.h<a name="1124909"> </a></code><h4>
  <a name="1124910"> </a>Prototype 
</h4>
<pre class="proto"><a name="1124911"></a>void GcSetCoordinateSystem (
   GcHandle <code class="par">ctxt</code>,
   uint32_t <code class="par">coordinateSystem</code>
)
</pre>
<h4>
  <a name="1124912"> </a>Parameters 
</h4>

<dl>
<dt><a name="1124913"> </a><code>&rarr;  <i>ctxt</i></code></dt>
<dd><a name="1124914"> </a>The graphics context.</dd>

<dt><a name="1153339"> </a><code>&rarr;  <i>coordinateSystem</i></code></dt>
<dd><a name="1153345"> </a>One of the <a href="UI_Window.html#1687709">Coordinate System Constants</a>. The default coordinate system for all graphics context drawing is the native screen format. </dd>

</dl>
<h4>
  <a name="1124920"> </a>Returns 
</h4>

<p><a name="1124921"> </a>Nothing.</p>
<h4>
  <a name="1124922"> </a>Comments 
</h4>

<p><a name="1124923"> </a>It is best to set the coordinate system before any drawing is done. Suppose the current coordinate system is native, and you do something like that shown below on a double-density device: </p>

<div class="CodeRule"><hr></div><pre class="CodeBlock">
GcHandle ctxt = GcGetCurrentContext();<a name="1124924"> </a>
<a name="1124925"> </a>
//Draw a line<a name="1124926"> </a>
GcMoveTo(ctxt, 0, 10);<a name="1124927"> </a>
GcDrawLine(ctxt, 0, 160);<a name="1124928"> </a>
<a name="1143968"> </a>
//Draw another line <a name="1124930"> </a>
GcMoveTo(ctxt, 0, 20);<a name="1124931"> </a>
GcDrawLine(ctxt, 0, 160);<a name="1124932"> </a>
GcMoveTo(ctxt, 0, 40);<a name="1124933"> </a>
<a name="1124934"> </a>
//BAD Code! Applies only to the next line. <a name="1124935"> </a>
GcSetCoordinateSystem(ctxt, kCoordinatesStandard);<a name="1124936"> </a>
GcLineTo(ctxt, 0, 160);<a name="1124937"> </a>
<a name="1124938"> </a>
GcStroke(ctxt);<a name="1124939"> </a>
GcPaint(ctxt);<a name="1124940"> </a>
GcReleaseContext(ctxt);<a name="1124941"> </a>
</pre><div class="CodeRule"><hr></div>


<p><a name="1124942"> </a>The last line will be twice as long as the other two because the coordinate system switched to standard before its bounds were computed. </p>

<p><a name="1195558"> </a>The default coordinate system for the graphics context is the coordinate system used by the current draw window. </p>

<p><a name="1124946"> </a>Be careful not to confuse <a href="UI_Window.html#1002873"><code>WinSetCoordinateSystem()</code></a> and this function. If you call <code>GcSetCoordinateSystem()</code>, it changes only the coordinate system used by the graphics context, not by the Window Manager. It is a good idea to always make both calls so that you can be certain both coordinate systems are the same. </p>

<h3 class="hbH3">
  <a name="1125325"> </a>GcSetFont Function <a href="#608590"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="1125327"> </a>Purpose 
</h4>

<p><a name="1125331"> </a>Sets the font used by <a href="UI_GraphicContext.html#1196638"><code>GcDrawTextAt()</code></a>. </p>
<h4>
  <a name="1125332"> </a>Declared In 
</h4>
<code>GcRender.h<a name="1125333"> </a></code><h4>
  <a name="1125334"> </a>Prototype 
</h4>
<pre class="proto"><a name="1125335"></a>void GcSetFont (
   GcHandle <code class="par">ctxt</code>,
   GcFontHandle <code class="par">font</code>
)
</pre>
<h4>
  <a name="1125336"> </a>Parameters 
</h4>

<dl>
<dt><a name="1125337"> </a><code>&rarr;  <i>ctxt</i></code></dt>
<dd><a name="1125338"> </a>The graphics context.</dd>

<dt><a name="1125339"> </a><code>&rarr;  <i>font</i></code></dt>
<dd><a name="1125340"> </a>The scalable font to use. </dd>

</dl>
<h4>
  <a name="1125341"> </a>Returns 
</h4>

<p><a name="1125342"> </a>Nothing. </p>
<h4>
  <a name="1195279"> </a>See Also 
</h4>

<p><a name="1195374"> </a><a href="UI_GcFont.html#993944"><code>GcCreateFont()</code></a>, <a href="UI_GcFont.html#994270"><code>GcCreateFontFromFamily()</code></a>, <a href="UI_GcFont.html#994312"><code>GcCreateFontFromID()</code></a></p>

<h3 class="hbH3">
  <a name="1125766"> </a>GcSetGradient Function <a href="#608590"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="1125768"> </a>Purpose 
</h4>

<p><a name="1125772"> </a>Sets the gradient used with <a href="UI_GraphicContext.html#1120151"><code>GcPaint()</code></a>.</p>
<h4>
  <a name="1125773"> </a>Declared In 
</h4>
<code>GcRender.h<a name="1125774"> </a></code><h4>
  <a name="1125775"> </a>Prototype 
</h4>
<pre class="proto"><a name="1125776"></a>void GcSetGradient (
   GcHandle <code class="par">ctxt</code>,
   const GcGradientType *<code class="par">gradient</code>
)
</pre>
<h4>
  <a name="1125777"> </a>Parameters 
</h4>

<dl>
<dt><a name="1125778"> </a><code>&rarr;  <i>ctxt</i></code></dt>
<dd><a name="1125779"> </a>The graphics context.</dd>

<dt><a name="1125780"> </a><code>&rarr;  <i>gradient</i></code></dt>
<dd><a name="1125784"> </a>A <a href="UI_GraphicContext.html#992989"><code>GcGradientType</code></a> structure defining the gradations to use. </dd>

</dl>
<h4>
  <a name="1125785"> </a>Returns 
</h4>

<p><a name="1125786"> </a>Nothing.</p>
<h4>
  <a name="1221569"> </a>Comments 
</h4>

<p><a name="1221618"> </a>Any two-dimensional transformations that are set before this call are applied to the gradient when drawing takes place. If you don't want the transformation applied to the gradient, call <code>GcSetGradient() </code>first, and then set the transformations. </p>
<h4>
  <a name="1125787"> </a>See Also 
</h4>

<p><a name="1125794"> </a><a href="UI_GraphicContext.html#1124873"><code>GcSetColor()</code></a>, <a href="UI_GraphicContext.html#1116573"><code>GcInitGradient()</code></a></p>

<h3 class="hbH3">
  <a name="1125797"> </a>GcSetJoin Function <a href="#608590"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="1125799"> </a>Purpose 
</h4>

<p><a name="1125800"> </a>Specifies what the intersection of two lines looks like in a stroked (outlined) path. </p>
<h4>
  <a name="1125801"> </a>Declared In 
</h4>
<code>GcRender.h<a name="1125802"> </a></code><h4>
  <a name="1125803"> </a>Prototype 
</h4>
<pre class="proto"><a name="1125804"></a>void GcSetJoin (
   GcHandle <code class="par">ctxt</code>,
   int32_t <code class="par">join</code>,
   float <code class="par">miter_limit</code>
)
</pre>
<h4>
  <a name="1125805"> </a>Parameters 
</h4>

<dl>
<dt><a name="1125806"> </a><code>&rarr;  <i>ctxt</i></code></dt>
<dd><a name="1125807"> </a>The graphics context.</dd>

<dt><a name="1125808"> </a><code>&rarr;  <i><code class="par">join</code></i></code></dt>
<dd><a name="1125812"> </a>One of the <a href="UI_GraphicContext.html#1017054"><code>GcJoinTag</code></a> values. </dd>

<dt><a name="1125813"> </a><code>&rarr;  <i><code class="par">miter_limit</code></i></code></dt>
<dd><a name="1125814"> </a>Controls when the rendering system switches from a miter join to a bevel join. When the length of the point reaches <code class="par">miter_limit</code> times the stroke weight, the rendering system switches from a miter join to a bevel join. This only applies to the miter join, not to any of the other join styles.</dd>

</dl>
<h4>
  <a name="1125815"> </a>Returns 
</h4>

<p><a name="1125816"> </a>Nothing.</p>
<h4>
  <a name="1125817"> </a>Comments 
</h4>

<p><a name="1125821"> </a>This function only has affect for paths where <a href="UI_GraphicContext.html#994955"><code>GcStroke()</code></a> is called before <a href="UI_GraphicContext.html#1120151"><code>GcPaint()</code></a>. </p>

<h3 class="hbH3">
  <a name="1125827"> </a>GcSetPenSize Function <a href="#608590"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="1125829"> </a>Purpose 
</h4>

<p><a name="1125830"> </a>Sets the border width used to draw stroked paths. </p>
<h4>
  <a name="1125831"> </a>Declared In 
</h4>
<code>GcRender.h<a name="1125832"> </a></code><h4>
  <a name="1125833"> </a>Prototype 
</h4>
<pre class="proto"><a name="1125834"></a>void GcSetPenSize (
   GcHandle <code class="par">ctxt</code>,
   fcoord_t <code class="par">penWidth</code>
)
</pre>
<h4>
  <a name="1125835"> </a>Parameters 
</h4>

<dl>
<dt><a name="1125836"> </a><code>&rarr;  <i>ctxt</i></code></dt>
<dd><a name="1125837"> </a>The graphics context.</dd>

<dt><a name="1125838"> </a><code>&rarr;  <i>penWidth</i></code></dt>
<dd><a name="1125839"> </a>The pen width given in coordinates. </dd>

</dl>
<h4>
  <a name="1125840"> </a>Returns 
</h4>

<p><a name="1125841"> </a>Nothing.</p>
<h4>
  <a name="1125842"> </a>Comments 
</h4>

<p><a name="1125846"> </a>This function only has affect for paths where <a href="UI_GraphicContext.html#994955"><code>GcStroke()</code></a> is called before <a href="UI_GraphicContext.html#1120151"><code>GcPaint()</code></a>. </p>

<p><a name="1125850"> </a>When the path is drawn, rendering system ensures that the path is in the middle of the pen. A path is always assumed to have no width. For example, if you give a path that consists of one vertical line drawn from (1, 0) to (1, 160) and a pen width of 2, <code>GcPaint()</code> colors all pixels in the 0 column and all pixels in the 1 column. </p>

<h3 class="hbH3">
  <a name="1188452"> </a>GcShear Function <a href="#608590"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="1188454"> </a>Purpose 
</h4>

<p><a name="1188455"> </a>Applies the shear transformation to the coordinate system. </p>
<h4>
  <a name="1188456"> </a>Declared In 
</h4>
<code>GcRender.h<a name="1188457"> </a></code><h4>
  <a name="1188458"> </a>Prototype 
</h4>
<pre class="proto"><a name="1188459"></a>void GcShear (
   GcHandle <code class="par">ctxt</code>,
   fcoord_t <code class="par">x</code>,
   fcoord_t <code class="par">y</code>
)
</pre>
<h4>
  <a name="1188460"> </a>Parameters 
</h4>

<dl>
<dt><a name="1188461"> </a><code>&rarr;  <i>ctxt</i></code></dt>
<dd><a name="1188462"> </a>The graphics context. </dd>

<dt><a name="1188463"> </a><code>&rarr;  <i>x</i></code></dt>
<dd><a name="1188464"> </a>The amount of shear in the horizontal direction. </dd>

<dt><a name="1188465"> </a><code>&rarr;  <i>y</i></code></dt>
<dd><a name="1194190"> </a>The amount of shear in the vertical direction. </dd>

</dl>
<h4>
  <a name="1188467"> </a>Returns 
</h4>

<p><a name="1188468"> </a>Nothing. </p>
<h4>
  <a name="1188469"> </a>Comments 
</h4>

<p><a name="1188470"> </a>The shear transformation angles and stretches a shape. It is most commonly used to convert a font to italics or to convert a rectangle into a parallelogram. </p>

<p><a name="1220008"> </a>A two-dimensional transformation affects only the drawing functions called after it. If you call this function in the middle of a path definition, it applies only to those points in the path defined after this function is called. If you are creating a stroked path, call this and all other two-dimensional transformations before calling <a href="UI_GraphicContext.html#994955"><code>GcStroke()</code></a>. </p>

<p><a name="1220610"> </a>The shear transformation is applied starting from the origin of the screen. If you want to angle and stretch a shape but have it appear in the same general location on the screen, use <a href="UI_GraphicContext.html#995590"><code>GcTranslate()</code></a> to translate the origin to the center of the screen before calling this function. See <a href="UI_GraphicContext.html#1123487"><code>GcRotate()</code></a> for sample code. </p>
<h4>
  <a name="1188471"> </a>See Also 
</h4>

<p><a name="1188472"> </a><a href="UI_GraphicContext.html#1123136"><code>GcReflect()</code></a>, <a href="UI_GraphicContext.html#1124400"><code>GcScale()</code></a>, <a href="UI_GraphicContext.html#995590"><code>GcTranslate()</code></a>, <a href="UI_GraphicContext.html#1171204"><code>GcTransform()</code></a></p>

<h3 class="hbH3">
  <a name="994955"> </a>GcStroke Function <a href="#608590"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="994957"> </a>Purpose 
</h4>

<p><a name="994958"> </a>Changes the current path to the outline of an object rather than a filled object. </p>
<h4>
  <a name="994959"> </a>Declared In 
</h4>
<code>GcRender.h<a name="994960"> </a></code><h4>
  <a name="994961"> </a>Prototype 
</h4>
<pre class="proto"><a name="993072"></a>void GcStroke (
   GcHandle <code class="par">ctxt</code>
)
</pre>
<h4>
  <a name="1004310"> </a>Parameters 
</h4>

<dl>
<dt><a name="1004311"> </a><code>&rarr;  <i>ctxt</i></code></dt>
<dd><a name="1056704"> </a>The graphics context. </dd>

</dl>
<h4>
  <a name="1004312"> </a>Returns 
</h4>

<p><a name="1004313"> </a>Nothing.</p>
<h4>
  <a name="1004314"> </a>Comments 
</h4>

<p><a name="1004315"> </a>Use this function if you want <a href="UI_GraphicContext.html#1120151"><code>GcPaint()</code></a> to trace the outline of the path rather than filling the path. </p>

<p><a name="1060813"> </a>The pen size, join, and cap style portions of the rendering state apply if you call this function. Pen size, join, and cap style do not affect fill operations. </p>

<p><a name="1060854"> </a>The current two-dimensional transformation also affects the stroke. Do not change the two-dimensional transformation in between calls to this function and <code>GcPaint()</code>.</p>
<h4>
  <a name="1096762"> </a>See Also 
</h4>

<p><a name="1096988"> </a><a href="UI_GraphicContext.html#1123136"><code>GcReflect()</code></a>, <a href="UI_GraphicContext.html#1123487"><code>GcRotate()</code></a>, <a href="UI_GraphicContext.html#1124400"><code>GcScale()</code></a>, <a href="UI_GraphicContext.html#1124840"><code>GcSetCaps()</code></a>, <a href="UI_GraphicContext.html#1125797"><code>GcSetJoin()</code></a>, <a href="UI_GraphicContext.html#1125827"><code>GcSetPenSize()</code></a>, <a href="UI_GraphicContext.html#995590"><code>GcTranslate()</code></a></p>

<h3 class="hbH3">
  <a name="1171204"> </a>GcTransform Function <a href="#608590"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="1171206"> </a>Purpose 
</h4>

<p><a name="1171207"> </a>Applies a general two-dimensional transformation matrix. </p>
<h4>
  <a name="1171208"> </a>Declared In 
</h4>
<code>GcRender.h<a name="1171209"> </a></code><h4>
  <a name="1171210"> </a>Prototype 
</h4>
<pre class="proto"><a name="1188622"></a>void GcTransform (
   GcHandle <code class="par">ctxt</code>,
   const fcoord_t <code class="par">*matrix</code>
)
</pre>
<h4>
  <a name="1171212"> </a>Parameters 
</h4>

<dl>
<dt><a name="1171213"> </a><code>&rarr;  <i>ctxt</i></code></dt>
<dd><a name="1172406"> </a>The graphics context. </dd>

<dt><a name="1171215"> </a><code>&rarr;  <i>matrix</i></code></dt>
<dd><a name="1188663"> </a>The transformation matrix to be applied.</dd>

</dl>
<h4>
  <a name="1171227"> </a>Returns 
</h4>

<p><a name="1171228"> </a>Nothing. </p>
<h4>
  <a name="1171229"> </a>Comments 
</h4>

<p><a name="1171230"> </a>This function applies a general two-dimensional transformation like that in the Postscript language. The transformation is described by the matrix shown in <a href="UI_GraphicContext.html#1197809">Figure 21.7</a>. </p>

<p class="FFigureCaption">
  <a name="1197809"> </a><b>Figure 21.7&nbsp;&nbsp;Transformation matrix</b>
</p>
<div align="left"><img src="images/UI_GraphicContext7.jpg" height="92" width="479" border="0" hspace="0" vspace="0">
</div>

<p><a name="1172511"> </a>The coordinates in this matrix are applied to each point in the current path according to the following equations: </p>
<pre class="sl"><!-PS02-><span style="color: #000000;  font-style: italic; font-weight: normal; text-decoration: none; text-transform: none; vertical-align: baseline">newX</span> = (matrix[0] * <!-PS02-><span style="color: #000000;  font-style: italic; font-weight: normal; text-decoration: none; text-transform: none; vertical-align: baseline">currentX</span>) + (matrix[2] * 
<!-PS02-><span style="color: #000000;  font-style: italic; font-weight: normal; text-decoration: none; text-transform: none; vertical-align: baseline">currentY</span>) + matrix[4]</pre>
<pre class="sl"><!-PS02-><span style="color: #000000;  font-style: italic; font-weight: normal; text-decoration: none; text-transform: none; vertical-align: baseline">newY</span> = <code class="par">(</code>matrix[1] * <!-PS02-><span style="color: #000000;  font-style: italic; font-weight: normal; text-decoration: none; text-transform: none; vertical-align: baseline">currentX</span>) + (matrix[3] * 
<!-PS02-><span style="color: #000000;  font-style: italic; font-weight: normal; text-decoration: none; text-transform: none; vertical-align: baseline">currentY</span>) + matrix[5]</pre>

<p><a name="1172719"> </a>where (<i>currentX</i>, <i>currentY</i>) represents a point on the path and (<i>newX</i>, <i>newY</i>) represents that point after the transformation has been applied. </p>
<h4>
  <a name="1171231"> </a>See Also 
</h4>

<p><a name="1171232"> </a><a href="UI_GraphicContext.html#995590"><code>GcTranslate()</code></a>, <a href="UI_GraphicContext.html#1124400"><code>GcScale()</code></a>, <a href="UI_GraphicContext.html#1123487"><code>GcRotate()</code></a>, <a href="UI_GraphicContext.html#1123136"><code>GcReflect()</code></a>, <a href="UI_GcFont.html#996878"><code>GcSetFontTransform()</code></a></p>

<h3 class="hbH3">
  <a name="995590"> </a>GcTranslate Function <a href="#608590"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="995592"> </a>Purpose 
</h4>

<p><a name="995593"> </a>Translates the coordinate system by moving the origin to the specified coordinates. </p>
<h4>
  <a name="995594"> </a>Declared In 
</h4>
<code>GcRender.h<a name="995595"> </a></code><h4>
  <a name="995596"> </a>Prototype 
</h4>
<pre class="proto"><a name="993143"></a>void GcTranslate (
   GcHandle <code class="par">ctxt</code>,
   fcoord_t <code class="par">x</code>,
   fcoord_t <code class="par">y</code>
)
</pre>
<h4>
  <a name="1005623"> </a>Parameters 
</h4>

<dl>
<dt><a name="1029737"> </a><code>&rarr;  <i>ctxt</i></code></dt>
<dd><a name="1029738"> </a>The graphics context.</dd>

<dt><a name="1100462"> </a><code>&rarr;  <i>x </i></code></dt>
<dd><a name="1100463"> </a>The horizontal amount to move. </dd>

<dt><a name="1100464"> </a><code>&rarr;  <i>y</i></code></dt>
<dd><a name="1029753"> </a>The vertical amount to move. </dd>

</dl>
<h4>
  <a name="1005625"> </a>Returns 
</h4>

<p><a name="1005626"> </a>Nothing.</p>
<h4>
  <a name="1005627"> </a>Comments 
</h4>

<p><a name="1005628"> </a>If you are creating a stroked path, call this and all other two-dimensional transformations before calling <a href="UI_GraphicContext.html#994955"><code>GcStroke()</code></a>. Typically, you specify the transformation before you do any drawing. </p>

<p><a name="1220706"> </a>This function is often used in conjunction with other transformations to ensure that the transformed path still appears on the screen. See <a href="UI_GraphicContext.html#1123487"><code>GcRotate()</code></a> for sample code. </p>
<h4>
  <a name="1005629"> </a>See Also 
</h4>

<p><a name="1198958"> </a><a href="UI_GraphicContext.html#1123136"><code>GcReflect()</code></a>, <a href="UI_GraphicContext.html#1188452"><code>GcShear()</code></a>, <a href="UI_GraphicContext.html#1171204"><code>GcTransform()</code></a></p>

<p><a name="992901"> </a></p>
&nbsp;<br>
</div>
<!--END CONTENT-->

</td>
<td width="5">&nbsp;&nbsp;</td>
</tr>

</table>

<!-- BEGIN FOOTER -->
<table width="100%" border="0" cellspacing="0" cellpadding="0">
<tr>
<td width="7" rowspan="2"><img name="index_x" src="images/shim.gif" width="7" height="33" border="0" alt=""></td>
<td align="left"><img name="dashes" src="images/dashes.gif" width="744" height="3" border="0" alt=""></td>
<td width="10" rowspan="2"><img name="index_x" src="images/shim.gif" width="10" height="33" border="0" alt=""></td>
</tr>
<tr>
<td align="center">
<p class="footer">
Copyright © 2003&#8211;2004, PalmSource, Inc. and its affiliates. All rights reserved.<br>
<a href="http://www.palmsource.com/contact/">Write Us</a> | <a href="http://www.palmos.com/dev/training/">Training</a> | <a href="http://www.palmos.com/dev/support/kb/">Knowledge Base</a> | <a href="UI_Front.html" target="_blank">Legal</a></p>
<br>
<!--BEGIN BOOK NAVIGATION-->
<p class="nav">
<A href="http://www.palmos.com/dev/support/docs/">Documentation</a>&nbsp;&nbsp;|&nbsp;&nbsp;
<a href="UI_TOC.html">Table of Contents</a>&nbsp;&nbsp;
             |&nbsp;&nbsp;<a href="UI_Form.html">&lt;&nbsp;Previous</a>&nbsp;&nbsp;
             |&nbsp;&nbsp;<a href="UI_List.html">Next&nbsp;&gt;</a>&nbsp;&nbsp;
             |&nbsp;&nbsp;<a href="UI_IX.html">Index</a>
</p>
</td>
</tr>
</table>
<!-- END FOOTER -->

</body>
</html>