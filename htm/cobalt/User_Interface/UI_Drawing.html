<html>
<head>
<title>(Protein) Drawing | User Interface </title> 
<link href="psi_devpubs.css" rel="stylesheet" type="text/css">

<!-- BEGIN META DATA -->
<meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
<META NAME="PSITEMPLATE" CONTENT="1006-007 PalmSource_HTML_2003 20041101">
<META NAME="GENERATOR" CONTENT="Quadralay WebWorks AutoMap 2003 for FrameMaker 8.0.6.2138">
<META NAME="LASTUPDATED" CONTENT="11/22/04 11:54:20">
<!-- END META DATA -->
</head>

<body bgcolor="#ffffff" text="#000000" leftmargin="0" topmargin="0" marginwidth="0" marginheight="0">
<a name="1083817"></a>

<!-- BEGIN TOPNAV -->
<table width="100%" border="0" cellspacing="0" cellpadding="0">
<tr>
<td><img src="images/shim.gif" width="7" height="75" border="0" alt=""></td>
<td align="left"><table border="0" cellpadding="0" cellspacing="0" width="744">
<tr>
<td><img name="index_r2_c1" src="images/shim.gif" width="25" height="75" border="0" alt=""></td>
<td valign="top"><table border="0" cellpadding="0" cellspacing="0" width="96">
<tr>
<td><img name="index_r2_c4" src="images/shim.gif" width="96" height="15" border="0" alt=""></td>
</tr>
<tr>
<td><a href="http://www.palmsource.com/"><img name="ps_logo" src="images/ps_logo.gif" width="96" height="54" border="0" alt=""></a></td>
</tr>

</table>
</td>

<td><table border="0" cellpadding="0" cellspacing="0" width="30">
<td><img name="index_x" src="images/shim.gif" width="30" height="75" border="0" alt=""></td>
</table></td>

<!--BEGIN MASTHEAD-->
<td><table border="0" cellpadding="0" cellspacing="0" width="96">
<tr>
<td><img name="index_x" src="images/shim.gif" width="615" height="5" border="0" alt=""></td>
</tr>
<tr>
<td>
<!--BEGIN BOOK NAVIGATION-->
<span class="nav">
<A href="http://www.palmos.com/dev/support/docs/">Documentation</a>&nbsp;&nbsp;|&nbsp;&nbsp;
<a href="UI_TOC.html">Table of Contents</a>&nbsp;&nbsp;
             |&nbsp;&nbsp;<a href="UI_GadgetConcept.html">&lt;&nbsp;Previous</a>&nbsp;&nbsp;
             |&nbsp;&nbsp;<a href="UI_BitmapConcept.html">Next&nbsp;&gt;</a>&nbsp;&nbsp;
             |&nbsp;&nbsp;<a href="UI_IX.html">Index</a>
</span>
<!--END BOOK NAVIGATION-->
</tr>
<tr>
<td>
<!--BEGIN PAGE TITLE-->
<h2 class="PageTitle">8 &nbsp;&nbsp;
Drawing</h2></td>
<!--END PAGE TITLE-->
</tr>
<tr>
<td>
<!--BEGIN BOOK TITLE-->
<p class="BookTitle">User Interface </p>
<p class="SubTitle">Exploring Palm OS&#174; </p>
<!--END BOOK TITLE-->
</td>
</tr>
<tr>
<td><img name="index_x" src="images/shim.gif" width="615" height="5" border="0" alt=""></td>
</tr>
</table>
</td>
<!--END MASTHEAD-->
</tr>
</table>
<img name="dashes" src="images/dashes.gif" width="744" height="3" border="0" alt=""></td>
</tr>
</table>
<!-- END TOPNAV -->

<table width="100%" border="0" cellspacing="0" cellpadding="0">
<tr>
<td valign="top" width="5"><img name="index_x" src="images/shim.gif" width="5" height="33" border="0" alt=""></td>

<!--BEGIN SIDETOC-->
<td valign="top" width="175">
<div id="sidetoc" valign="bottom">
<h1 class="SideTOC1-PartTab"><a href="UI_PartConcept.html">Part I: Concepts</a> </h1>
<h1 class="SideTOC1"><a href="UI_Drawing.html">8  Drawing</a></h1>

   <h2 class="SideTOC2"><a href="#1078005">
   Conceptual Overview</a></h2>

      <h3 class="SideTOC3"><a href="#1078818">
      Graphics Context</a></h3>

      <h3 class="SideTOC3"><a href="#1078106">
      Path-Based Drawing</a></h3>

      <h3 class="SideTOC3"><a href="#1079435">
      Alpha Blending</a></h3>

      <h3 class="SideTOC3"><a href="#1080064">
      Striking Rule</a></h3>

   <h2 class="SideTOC2"><a href="#1058484">
   Basic Drawing Steps</a></h2>

      <h3 class="SideTOC3"><a href="#1072079">
      Setting the Rendering State </a></h3>

      <h3 class="SideTOC3"><a href="#1069703">
      Defining a Path</a></h3>

      <h3 class="SideTOC3"><a href="#1070153">
      Painting the Path</a></h3>

      <h3 class="SideTOC3"><a href="#1082379">
      Specifying Clipping Regions</a></h3>

   <h2 class="SideTOC2"><a href="#1060349">
   Where and When to Draw</a></h2>

      <h3 class="SideTOC3"><a href="#1060355">
      On-Screen Windows</a></h3>

      <h3 class="SideTOC3"><a href="#1088700">
      Off-Screen Windows</a></h3>

      <h3 class="SideTOC3"><a href="#1088765">
      Bitmaps</a></h3>

   <h2 class="SideTOC2"><a href="#1056136">
   Compatibility with the Old Drawing System</a></h2>

      <h3 class="SideTOC3"><a href="#1075147">
      Making Library Calls</a></h3>

      <h3 class="SideTOC3"><a href="#1081359">
      Color Table Compatibility</a></h3>

   <h2 class="SideTOC2"><a href="#1081484">
   Drawing Tips</a></h2>

      <h3 class="SideTOC3"><a href="#1080751">
      Draw to Exact Pixel Boundaries</a></h3>

      <h3 class="SideTOC3"><a href="#1077599">
      Reuse the Current Path</a></h3>

      <h3 class="SideTOC3"><a href="#1077498">
      Take Advantage of Winding Rule</a></h3>

      <h3 class="SideTOC3"><a href="#1092285">
      Avoid Antialiasing </a></h3>

      <h3 class="SideTOC3"><a href="#1082207">
      Avoid Alpha Blending</a></h3>

      <h3 class="SideTOC3"><a href="#1082211">
      Efficient Cap and Join Modes</a></h3>

      <h3 class="SideTOC3"><a href="#1082213">
      Avoid Transformations </a></h3>

      <h3 class="SideTOC3"><a href="#1077557">
      Avoid Flushing the Buffer</a></h3>

   <h2 class="SideTOC2"><a href="#1056221">
   Summary of Drawing Functions</a></h2>

</div>
</td>

<td width="5">&nbsp;&nbsp;</td>
<td width="2" background="images/index_r8_c10.gif"><img src="images/shim.gif" width="2" height="75" border="0" alt=""></td>
<td width="5">&nbsp;&nbsp;</td>

<!--END SIDETOC-->

<td valign="top">

<!--BEGIN CONTENT-->
<div id="content" valign="bottom">
<p><a name="1083823"> </a>The Palm OS<sup>&#174;</sup> Cobalt rendering model includes support for complex path and shape construction, arbitrary two-dimensional transformations, a state stack, color gradients, alpha blending, and anti-aliasing. You interact with this new drawing model using the Graphics Context functions. </p>

<p><a name="1059795"> </a>Previous versions of Palm OS had a more simplistic drawing model with a substantially different idea of the drawing state. The functions for this old drawing model are supported in Palm OS Cobalt and work as before. This chapter focuses first on the new drawing model and how to work with it. Later, it describes some compatibility issues that you might find when porting an older application to Palm OS Cobalt. </p>

<p><a name="1082452"> </a>The topics covered are: </p>
   <blockquote class = "bq"><a name="1082453"> </a><a href="UI_Drawing.html#1078005">Conceptual Overview</a></blockquote>
   <blockquote class = "bq"><a name="1082469"> </a><a href="UI_Drawing.html#1058484">Basic Drawing Steps</a></blockquote>
   <blockquote class = "bq"><a name="1082474"> </a><a href="UI_Drawing.html#1060349">Where and When to Draw</a></blockquote>
   <blockquote class = "bq"><a name="1082496"> </a><a href="UI_Drawing.html#1056136">Compatibility with the Old Drawing System</a></blockquote>
   <blockquote class = "bq"><a name="1082501"> </a><a href="UI_Drawing.html#1081484">Drawing Tips</a></blockquote>

<p><a name="1088178"> </a>Drawing bitmaps to the screen and creating bitmaps programmatically are closely related topics that are not covered in this chapter. See <a href="UI_BitmapConcept.html#1005083">Chapter 9, "Working with Bitmaps."</a></p>

<h2 class="haH2">
  <a name="1078005"> </a>Conceptual Overview <a href="#1083817"><span class="nav">^TOP^</span></a>
</h2>


<p><a name="1078090"> </a>This section introduces you to the features of the new drawing model. It covers: </p>
   <blockquote class = "bq"><a name="1082531"> </a><a href="UI_Drawing.html#1078818">Graphics Context</a></blockquote>
   <blockquote class = "bq"><a name="1082535"> </a><a href="UI_Drawing.html#1078106">Path-Based Drawing</a></blockquote>
   <blockquote class = "bq"><a name="1082540"> </a><a href="UI_Drawing.html#1079435">Alpha Blending</a></blockquote>
   <blockquote class = "bq"><a name="1082561"> </a><a href="UI_Drawing.html#1080064">Striking Rule</a></blockquote>
<h3 class="hbH3">
  <a name="1078818"> </a>Graphics Context <a href="#1083817"><span class="nav">^TOP^</span></a>
</h3>


<p><a name="1078927"> </a>The new drawing API does not draw directly to a window on the screen. Instead, it draws to a <b>graphics context</b>, which stores the current rendering state. </p>

<p><a name="1088194"> </a>The Palm OS Cobalt rendering system has more control over the size and placement of windows and thus when to draw into them. When the rendering system needs to refresh the screen, it creates graphics contexts, tells all of the windows on the screen to update themselves, and then destroys the graphics contexts when all drawing is finished. Your application sees this request to draw as a <a href="UI_Form.html#1089359"><code>frmUpdateEvent</code></a>. Thus, to guarantee that your window has a graphics context that is ready to accept drawing, your application should only draw in response to an <a href="UI_Form.html#1089359"><code>frmUpdateEvent</code></a>. </p>

<p><a name="1079129"> </a>For performance reasons, none of the Graphics Context functions perform any error checking on the parameters you pass. (Error checking is performed by the rendering system.) You must verify that you have a graphics context when you try to acquire one.</p>

<div><hr>
  <a name="1090612"> </a> <span class="warning">WARNING! </span> Drawing to a <code>NULL</code> graphics context causes an application crash. 
<hr>
</div>

<p><a name="1079075"> </a>The rendering system runs in a different process than the application. To avoid IPC overhead, drawing operations are buffered and sent to the rendering system in batches. The rendering system sends its buffered commands at the end of each event loop. Because of this, drawing is likely not to have finished when a drawing function returns. In the rare cases where you need to wait for the IPC to complete before your application continues, there are two functions, <a href="UI_GraphicContext.html#1115387"><code>GcFlush()</code></a> and <a href="UI_GraphicContext.html#1017667"><code>GcCommit()</code></a>, that allow you to do so; however, they are slow and should be used only for debugging. </p>
<h3 class="hbH3">
  <a name="1078106"> </a>Path-Based Drawing <a href="#1083817"><span class="nav">^TOP^</span></a>
</h3>


<p><a name="1078062"> </a>The new Graphics Context drawing functions behave very much like the Postscript language. Instead of drawing simple shapes directly to a window, you define a complex path and then paint it onto the screen. A <b>path</b> consists of shapes made out of lines, arcs, and curves. A single path can have numerous disjointed shapes in it. Each shape is called a <b>subpath</b>. </p>

<p><a name="1078063"> </a>Think of drawing with these functions as painting a portrait. First you sketch lightly in pencil what you want to paint. Then you fill the sketch with paint. </p>

<p><a name="1078507"> </a>The path has a notion of a <b>current point</b>. All drawing functions draw from the current point to the points you specify in the function. </p>

<p><a name="1078511"> </a>To begin a path, you generally use <a href="UI_GraphicContext.html#1118101"><code>GcMoveTo()</code></a> to define the starting point. All drawing functions that you call from then on connect to the end point of the previous call until you call <code>GcMoveTo()</code> again. The<code> GcMoveTo()</code> function is like lifting the pencil and moving it to the location you specify. </p>

<p><a name="1078702"> </a>When you have defined the path and are ready to paint it onto the screen, you call <a href="UI_GraphicContext.html#1120151"><code>GcPaint()</code></a>. <code>GcPaint()</code> fills the shapes contained in the path onto the screen and then clears the path from the rendering state. It does not clear any other aspect of the rendering state. </p>

<p><a name="1078707"> </a>By default, <code>GcPaint()</code> expects to fill the current path. If you want <code>GcPaint()</code> to trace the path, you should call <a href="UI_GraphicContext.html#994955"><code>GcStroke()</code></a> first. <code>GcStroke()</code> turns the path definition into the outline of the shape rather than the shape itself. (This is called a <b>stroked path</b>.) </p>
<h3 class="hbH3">
  <a name="1079435"> </a>Alpha Blending <a href="#1083817"><span class="nav">^TOP^</span></a>
</h3>


<p><a name="1079575"> </a>When you set the color in the rendering state, you may specify an alpha transparency level. An alpha level of 0 is fully transparent, and an alpha level of 255 is fully opaque. </p>

<p><a name="1079443"> </a>If you specify an alpha level somewhere between fully transparent and fully opaque, the rendering system composites pixels in the path with the current value of those pixels on the screen using standard alpha blending. This is a change from earlier Palm OS releases, where any current drawing simply overwrote any previous drawing. </p>
<h3 class="hbH3">
  <a name="1080064"> </a>Striking Rule <a href="#1083817"><span class="nav">^TOP^</span></a>
</h3>


<p><a name="1089053"> </a>The <b>striking rule</b> controls how the system determines which pixels get painted. The coordinate system and antialiasing both affect the striking rule. </p>

<p><a name="1080359"> </a>You define a path in terms of coordinates. The coordinates you specify are floating-point values, allowing you to specify sub-coordinate boundaries. The border of a path is always interpreted to have 0 width. The rendering system draws the path using the coordinates you've specified, and then it looks at which pixels are covered by the path. For stroked paths, it takes the pen width into consideration. The pen width is drawn such that 50% of the width is on one side of the path and 50% is on the other side of the path. </p>

<p><a name="1090021"> </a>As described in <a href="UI_Screen.html#995096">Chapter 1, "The Display,"</a> the <b>coordinate system</b> specifies how the values that you pass to the path definition functions are interpreted. The rendering model uses the current draw window's coordinate system by default, so you can set it to use standard coordinates, native coordinates, or a specific screen density. </p>

<p><a name="1090028"> </a><a href="UI_Drawing.html#1079702">Figure 8.1</a> shows the result of executing the code in <a href="UI_Drawing.html#1083878">Listing 8.1</a> for both standard coordinates and native coordinates on a single-density and a double-density display.</p>
<p class="CCodeCaption">
  <a name="1083878"> </a><b>Listing 8.1&nbsp;&nbsp;Drawing a triangle</b>
</p>

<div class="CodeRule"><hr></div><pre class="CodeBlock">
GcMoveTo(gc, 1.0, 1.0);<a name="1084039"> </a>
GcLineTo(gc, 1.0, 5.0);<a name="1084056"> </a>
GcLineTo(gc, 6.0, 5.0);<a name="1084073"> </a>
GcClosePath(gc);<a name="1084174"> </a>
GcPaint(gc);<a name="1084191"> </a>
</pre><div class="CodeRule"><hr></div>


<p class="FFigureCaption">
  <a name="1079702"> </a><b>Figure 8.1&nbsp;&nbsp;Standard and native coordinate systems</b>
</p>
<div align="left"><img src="images/HighResAndLowResLine.jpg" height="352" width="481" border="0" hspace="0" vspace="0">
</div>

<div><hr>
  <a name="1079459"> </a> <b>TIP: </b> It is acceptable to specify coordinates that lie outside of screen boundaries. Any drawing outside of the current draw window's boundaries is simply clipped. 
<hr>
</div>

<p><a name="1090553"> </a><b>Antialiasing</b> specifies whether the rendering system tries to smooth out rough lines. When antialiasing is off, the system decides whether to paint a pixel as follows: If the center point of the pixel falls within the line or shape being drawn, that pixel is painted with the current color. When antialiasing is on, each pixel that contains part of the shape gets a color, whether that pixel's center point is in the shape or not. The alpha is determined by how much of the shape is in the pixel. If only 10% of the shape is in the pixel, then the pixel gets a value equal to 10% of the color, and so on. This has the effect of making curved lines appear smoother (see <a href="UI_Drawing.html#1079463">Figure 8.2</a>). </p>

<p class="FFigureCaption">
  <a name="1079463"> </a><b>Figure 8.2&nbsp;&nbsp;Antialiasing</b>
</p>
<div align="left"><img src="images/AntiAliasing2.jpg" height="184" width="480" border="0" hspace="0" vspace="0">
</div>

<h2 class="haH2">
  <a name="1058484"> </a>Basic Drawing Steps <a href="#1083817"><span class="nav">^TOP^</span></a>
</h2>


<p><a name="1069796"> </a>This section introduces you to the basic things you need to know to work with the new Graphics Context API. Read it to get started. </p>

<p><a name="1082838"> </a><a href="UI_Drawing.html#1082840">Listing 8.2</a> shows a simple drawing example. </p>
<p class="CCodeCaption">
  <a name="1082840"> </a><b>Listing 8.2&nbsp;&nbsp;Drawing a button frame</b>
</p>

<div class="CodeRule"><hr></div><pre class="CodeBlock">
GcHandle gc;<a name="1082841"> </a>
case frmUpdateEvent:<a name="1084309"> </a>
   gc = GcGetCurrentContext();<a name="1082842"> </a>
   if (gc) {<a name="1082843"> </a>
      GcSetColor(gc, 0, 0, 0, 255);<a name="1089106"> </a>
      GcRoundRect(gc, 0, 0, 50, 15, 3, 3);<a name="1089107"> </a>
      GcPaint(gc);<a name="1089108"> </a>
<a name="1089109"> </a>
      GcReleaseContext(gc);<a name="1082849"> </a>
   }<a name="1082850"> </a>
break;<a name="1082851"> </a>
</pre><div class="CodeRule"><hr></div>


<p><a name="1069566"> </a>The basic steps for drawing with the new functions are: </p>
<ol type="1">
  <li value="1"><a name="1069569"> </a>Call <a href="UI_GraphicContext.html#1114107"><code>GcGetCurrentContext()</code></a>.
   <p><a name="1070253"> </a>This function obtains a handle to the graphics context that you pass to the rest of the functions. </p>
  <li value="2"><a name="1072335"> </a>Set the rendering state. 
  <li value="3"><a name="1069628"> </a>Define the path.
  <li value="4"><a name="1069629"> </a>Paint the path onto the screen. 
  <li value="5"><a name="1069598"> </a>Call <a href="UI_GraphicContext.html#994064"><code>GcReleaseContext()</code></a>. 
   <p><a name="1070290"> </a>This function signals that you are done drawing and the graphics context memory can be freed. If you do not release the graphics context, your user interface will eventually freeze. </p>
</ol>

<div><hr>
  <a name="1069338"> </a> <b>IMPORTANT: </b> Do not change the draw window in between calls to <code>GcGetCurrentContext()</code> and <code>GcReleaseContext()</code>. 
<hr>
</div>

<p><a name="1071093"> </a>The next several sections discuss these steps in more detail. </p>
<h3 class="hbH3">
  <a name="1072079"> </a>Setting the Rendering State  <a href="#1083817"><span class="nav">^TOP^</span></a>
</h3>


<p><a name="1072080"> </a>The rendering state contains the attributes listed in <a href="UI_Drawing.html#1081746">Table 8.1</a>. </p>



<p class="caption"><a name="1081746"> </a><b>Table 8.1&nbsp;&nbsp;Rendering State </b></p>
<div class="tablediv"><table cellspacing="0" class="tTable">

  <tr valign="top">
    <th><p class="tt"><a name="1081752"> </a><b>State</b></p>
    </th>
    <th><p class="tt"><a name="1081754"> </a><b>How to Change</b></p>
    </th>
    <th><p class="tt"><a name="1081756"> </a><b>Description</b></p>
    </th>
  </tr>
  <tr valign="top">
    <td><p class="tt"><a name="1081758"> </a>Color</p>
    </td>
    <td><p class="tt"><a name="1081763"> </a><a href="UI_GraphicContext.html#1124873"><code>GcSetColor()</code></a></p>
    </td>
    <td><p class="tt"><a name="1081768"> </a>The color <a href="UI_GraphicContext.html#1120151"><code>GcPaint()</code></a> uses when stroking or filling. The default is black. </p>
    </td>
  </tr>
  <tr valign="top">
    <td><p class="tt"><a name="1081770"> </a>Coordinate system</p>
    </td>
    <td><p class="tt"><a name="1081775"> </a><a href="UI_GraphicContext.html#1124904"><code>GcSetCoordinateSystem()</code></a></p>
    </td>
    <td><p class="tt"><a name="1081777"> </a>Determines how the coordinates you pass to the path definition functions are converted to pixels. The default is the current draw window's coordinate system. </p>
    </td>
  </tr>
  <tr valign="top">
    <td><p class="tt"><a name="1081782"> </a>Pen width</p>
    </td>
    <td><p class="tt"><a name="1081787"> </a><a href="UI_GraphicContext.html#1125827"><code>GcSetPenSize()</code></a></p>
    </td>
    <td><p class="tt"><a name="1081789"> </a>For stroked paths only, the width of each line drawn. The default is 1 coordinate. </p>
    </td>
  </tr>
  <tr valign="top">
    <td><p class="tt"><a name="1081791"> </a>Line cap</p>
    </td>
    <td><p class="tt"><a name="1081796"> </a><a href="UI_GraphicContext.html#1124840"><code>GcSetCaps()</code></a></p>
    </td>
    <td><p class="tt"><a name="1081798"> </a>For stroked paths only, specifies what the ends of lines look like. The default is <code>kButtCap</code>. </p>
    </td>
  </tr>
  <tr valign="top">
    <td><p class="tt"><a name="1081800"> </a>Join style</p>
    </td>
    <td><p class="tt"><a name="1081805"> </a><a href="UI_GraphicContext.html#1125797"><code>GcSetJoin()</code></a></p>
    </td>
    <td><p class="tt"><a name="1081807"> </a>For stroked paths only, specifies what the connection between two lines looks like. The default is a bevel join (<code>kBevelJoin</code>). </p>
    </td>
  </tr>
  <tr valign="top">
    <td><p class="tt"><a name="1081809"> </a>Font</p>
    </td>
    <td><p class="tt"><a name="1081814"> </a><a href="UI_GraphicContext.html#1125325"><code>GcSetFont()</code></a></p>
    </td>
    <td><p class="tt"><a name="1081816"> </a>For text paths only, the font in which the text is drawn. The default is the Palm OS plain scalable font. </p>
    </td>
  </tr>
  <tr valign="top">
    <td><p class="tt"><a name="1081818"> </a>Transfor-mations</p>
    </td>
    <td><p class="tt"><a name="1081826"> </a><a href="UI_GraphicContext.html#1123136"><code>GcReflect()</code></a>, <a href="UI_GraphicContext.html#1123487"><code>GcRotate()</code></a>, <a href="UI_GraphicContext.html#1124400"><code>GcScale()</code></a>, <a href="UI_GraphicContext.html#1188452"><code>GcShear()</code></a>, <a href="UI_GraphicContext.html#995590"><code>GcTranslate()</code></a>, <a href="UI_GraphicContext.html#1171204"><code>GcTransform()</code></a></p>
    </td>
    <td><p class="tt"><a name="1081834"> </a>Specify changes to the coordinate system that affect subsequent path definitions. The default is no transformation. </p>
    </td>
  </tr>
  <tr valign="top">
    <td><p class="tt"><a name="1081836"> </a>Anti-<br>aliasing</p>
    </td>
    <td><p class="tt"><a name="1081840"> </a><a href="UI_GraphicContext.html#1147963"><code>GcSetAntialiasing()</code></a> </p>
    </td>
    <td><p class="tt"><a name="1081843"> </a>Specifies whether antialiasing is on or off. The default is off. </p>
    </td>
  </tr>
  <tr valign="top">
    <td><p class="tt"><a name="1089478"> </a>Text anti-<br>aliasing</p>
    </td>
    <td><p class="tt"><a name="1089480"> </a><a href="UI_GcFont.html#995872"><code>GcSetFontAntialiasing()</code></a></p>
    </td>
    <td><p class="tt"><a name="1089482"> </a>Specifies whether antialiasing is on or off for text. The default is on. </p>
    </td>
  </tr>
  <tr valign="top">
    <td><p class="tt"><a name="1089495"> </a>Text hinting</p>
    </td>
    <td><p class="tt"><a name="1089497"> </a><a href="UI_GcFont.html#996196"><code>GcSetFontHinting()</code></a></p>
    </td>
    <td><p class="tt"><a name="1089499"> </a>If enabled, characters are always drawn to exact pixel boundaries. The default is on. </p>
    </td>
  </tr>
  <tr valign="top">
    <td><p class="tt"><a name="1089506"> </a>Text transfor-mation</p>
    </td>
    <td><p class="tt"><a name="1089508"> </a><a href="UI_GcFont.html#996878"><code>GcSetFontTransform()</code></a></p>
    </td>
    <td><p class="tt"><a name="1089510"> </a>Specify changes to the text definition. The default is no transformation. </p>
    </td>
  </tr>
  <tr valign="top">
    <td><p class="tt"><a name="1081878"> </a>Gradient</p>
    </td>
    <td><p class="tt"><a name="1081885"> </a><a href="UI_GraphicContext.html#1116573"><code>GcInitGradient()</code></a>, <a href="UI_GraphicContext.html#1125766"><code>GcSetGradient()</code></a></p>
    </td>
    <td>
<p><a name="1081888"> </a>Specifies a gradient. The default is no gradient. </p>
    </td>
  </tr>
</table>

</div>


<p><a name="1081991"> </a>Before changing the state, it is a good idea to preserve the current state with <a href="UI_GraphicContext.html#1121303"><code>GcPushState()</code></a>. Remember that the path is part of the current state, so when you call <a href="UI_GraphicContext.html#1121283"><code>GcPopState()</code></a> to restore the previous state, you'll clear any path definition you've just performed. </p>

<p><a name="1081998"> </a>For performance reasons, you should specify the rendering state first, then define the path. Don't change the state in the middle of the path unless you are applying one of the transformations. The transformation is the only part of the state that should apply to individual points and not the path as a whole. It is best to leave most state settings alone unless you know that your application absolutely must have a specific value. </p>

<p><a name="1082143"> </a>However, you should also be aware that some of the functions that draw standard user interface elements to the screen change the coordinate system and other aspects of the draw state. Therefore, it is a good idea to preserve the state before drawing standard user interface elements and pop it afterwards.</p>
<h3 class="hbH3">
  <a name="1069703"> </a>Defining a Path <a href="#1083817"><span class="nav">^TOP^</span></a>
</h3>


<p><a name="1069846"> </a>As stated previously, a path is a series of connected or disconnected lines or shapes. </p>

<p><a name="1069708"> </a>The following functions are path definition primitives: </p>
<ul type="disc">
  <li><a name="1069712"> </a><a href="UI_GraphicContext.html#1118101"><code>GcMoveTo()</code></a> &#8212; Move the current point to the location. 
  <li><a name="1069716"> </a><a href="UI_GraphicContext.html#1118074"><code>GcLineTo()</code></a> &#8212; Draw a straight line from the current point. 
  <li><a name="1069720"> </a><a href="UI_GraphicContext.html#1108164"><code>GcClosePath()</code></a> &#8212; Draw a straight line from the current point to the start of the most recent subpath. This function is most often used to close the path so that it is a shape that can be filled. 
  <li><a name="1069724"> </a><a href="UI_GraphicContext.html#1106848"><code>GcBezierTo()</code></a> &#8212; Draw a Bezier curve from the current point. 
</ul>

<p><a name="1089359"> </a>In addition, the graphics context defines the following convenience functions built from the primitives. Always use the convenience functions where possible. They are optimized for performance. </p>
<ul type="disc">
  <li><a name="1089364"> </a><a href="UI_GraphicContext.html#1122410"><code>GcRect()</code></a> &#8212; Draws a rectangle. 
  <li><a name="1089369"> </a><a href="UI_GraphicContext.html#994936"><code>GcRoundRect()</code></a> &#8212; Draws a rectangle with rounded corners. 
  <li><a name="1089380"> </a><a href="UI_GraphicContext.html#1188193"><code>GcRectI()</code></a>&#8212; Draws a rectangle using integer coordinates. 
  <li><a name="1069737"> </a><a href="UI_GraphicContext.html#1103512"><code>GcArcTo()</code></a> &#8212; Draws an arc connected to the current point. 
  <li><a name="1069741"> </a><a href="UI_GraphicContext.html#1103458"><code>GcArc()</code></a> &#8212; Draws an arc connected to the current point. 
</ul>
<h3 class="hbH3">
  <a name="1070153"> </a>Painting the Path <a href="#1083817"><span class="nav">^TOP^</span></a>
</h3>


<p><a name="1070154"> </a>When you have defined the path and are ready to paint it onto the screen, you call <a href="UI_GraphicContext.html#1120151"><code>GcPaint()</code></a>. </p>

<p><a name="1070158"> </a>By default, <code>GcPaint()</code> expects to fill the current path with the current color. If you want to draw the outline of the path, you should call <a href="UI_GraphicContext.html#994955"><code>GcStroke()</code></a> first. <code>GcStroke()</code> turns the path definition into the outline of the shape rather than the shape itself. </p>

<p><a name="1084347"> </a>You must only paint closed paths. If you've defined an open path such as two lines connected to each other, use <a href="UI_GraphicContext.html#994955"><code>GcStroke()</code></a> to specify that these two lines are what you want filled. The results are undefined if the graphics context tries to fill an open path. </p>

<p><a name="1070166"> </a>There are two special cases of painting paths to the screen: text and bitmaps. </p>

<p><a name="1070167"> </a>If you want to paint text to the screen, you specify the path and paint it to the screen in a single function: <a href="UI_GraphicContext.html#1196638"><code>GcDrawTextAt()</code></a>. This function clears any other path that you had defined previously, so it is best to call this outside of any other path definition. </p>

<p><a name="1070171"> </a><a href="UI_BitmapConcept.html#1008025">"Displaying a Bitmap on the Screen"</a> describes how to paint a bitmap to the screen. </p>
<h3 class="hbH3">
  <a name="1082379"> </a>Specifying Clipping Regions <a href="#1083817"><span class="nav">^TOP^</span></a>
</h3>


<p><a name="1084361"> </a>The rendering system allows you to create a <b>clipping region</b>. When a clipping region is defined, <a href="UI_GraphicContext.html#1120151"><code>GcPaint()</code></a> is constrained to painting only into that region. Any portions of the path outside of that region are discarded. </p>

<p><a name="1084365"> </a>To specify a clipping region, do the following: </p>
<ol type="1">
  <li value="1"><a name="1082388"> </a>Call <a href="UI_GraphicContext.html#1114107"><code>GcGetCurrentContext()</code></a>. 
  <li value="2"><a name="1082396"> </a>Call <a href="UI_GraphicContext.html#1104793"><code>GcBeginClip()</code></a>.
  <li value="3"><a name="1082398"> </a>Call one or more of the path definition functions to specify the clipping region. 
  <li value="4"><a name="1082402"> </a>Call <a href="UI_GraphicContext.html#1120151"><code>GcPaint()</code></a>, which fills the specified region with white. 
  <li value="5"><a name="1082406"> </a>Call <a href="UI_GraphicContext.html#1112161"><code>GcEndClip()</code></a>. 
  <li value="6"><a name="1082408"> </a>Call the path definition functions to create the path you want to draw. 
  <li value="7"><a name="1082412"> </a>Call <a href="UI_GraphicContext.html#1120151"><code>GcPaint()</code></a>.This call to <code>GcPaint()</code> only paints the areas of the path that are contained in the region you defined in Step <a href="UI_Drawing.html#1082398">3.</a>
  <li value="8"><a name="1090202"> </a>Call <a href="UI_GraphicContext.html#994064"><code>GcReleaseContext()</code></a>. 
</ol>

<p><a name="1084827"> </a><a href="UI_Drawing.html#1084517">Figure 8.3</a> shows an example of specifying a diamond shaped clipping region and then drawing a pattern that is constrained to the screen. </p>

<p class="FFigureCaption">
  <a name="1084517"> </a><b>Figure 8.3&nbsp;&nbsp;Clipping region</b>
</p>
<div align="left"><img src="images/Clipping23.jpg" height="352" width="480" border="0" hspace="0" vspace="0">
</div>

<p><a name="1084775"> </a>The clipping region remains in effect until you call <a href="UI_GraphicContext.html#1121283"><code>GcPopState()</code></a>. If you define a new clipping region before calling <code>GcPopState()</code>, all painting is constrained to the intersection of those clipping regions. If you want to paint to two disjointed areas of the screen, include them both in the path before calling <code>GcEndClip()</code>.</p>

<p><a name="1082420"> </a>Clipping regions are usually rectangular, but they do not have to be. Although you can specify any complex shape as the clipping region, you should use a simple rectangle whenever possible. Doing so allows the system to perform some optimizations when rendering. Note that clipping regions are never antialiased. </p>

<h2 class="haH2">
  <a name="1060349"> </a>Where and When to Draw <a href="#1083817"><span class="nav">^TOP^</span></a>
</h2>


<p><a name="1061413"> </a>The <b>draw window</b> is the window that receives the painted pixels. Drawing may be performed into on-screen windows, off-screen windows, or bitmaps. </p>
<h3 class="hbH3">
  <a name="1060355"> </a>On-Screen Windows <a href="#1083817"><span class="nav">^TOP^</span></a>
</h3>


<p><a name="1088695"> </a>As described in <a href="UI_FormConcept.html#1012179">"Window Type"</a>, an on-screen window may be either an update-based window, a transitional window, or a legacy window. If you are drawing to an update-based window, you may only draw in response to a <a href="UI_Form.html#1089359"><code>frmUpdateEvent</code></a> because that is the only time you are guaranteed to have a graphics context. For transitional windows, drawing only in response to update events is not a requirement, but it is a good idea to still try to follow this rule. </p>
<h3 class="hbH3">
  <a name="1088700"> </a>Off-Screen Windows <a href="#1083817"><span class="nav">^TOP^</span></a>
</h3>


<p><a name="1088702"> </a>To perform double-buffering, you can create an <b>off-screen window</b> and draw to it. You may draw to off-screen windows at any time without producing an error. </p>

<p><a name="1061559"> </a>Size can be an issue with off-screen windows. They allocate a region of memory proportional to the size of the window. You should ensure that the window's dimensions are only as large as necessary. For example, if all you want to do is draw a 10-pixel long horizontal black line, you can create a window with the width of 10, the height of 1, and the bit depth of 1. </p>

<p><a name="1061705"> </a>After you create the off-screen window, set the draw window to be the off-screen window, and then obtain the graphics context and perform the drawing operations. See <a href="UI_Drawing.html#1061088">Listing 8.3</a>.</p>
<p class="CCodeCaption">
  <a name="1061088"> </a><b>Listing 8.3&nbsp;&nbsp;Creating an off-screen window</b>
</p>

<div class="CodeRule"><hr></div><pre class="CodeBlock">
WinHandle win;<a name="1061104"> </a>
GcHandle gc;<a name="1062102"> </a>
uint32_t depth = 16;<a name="1083657"> </a>
<a name="1062103"> </a>
WinPushDrawState();<a name="1062087"> </a>
//Set the bit depth. <a name="1071154"> </a>
WinScreenMode(winScreenModeSet, NULL, NULL, &amp;depth, NULL);<a name="1061130"> </a>
<a name="1071157"> </a>
// Create off-screen window using native format. <a name="1071158"> </a>
WinSetCoordinateSystem(kCoordinatesNative);<a name="1061179"> </a>
win = WinCreateOffscreenWindow(width, height, nativeFormat, <a name="1061129"> </a>
   &amp;error);<a name="1061107"> </a>
<a name="1071159"> </a>
//Set the draw window, get the graphics context, and draw.<a name="1071169"> </a>
WinSetDrawWindow(win);<a name="1061132"> </a>
gc = GcGetCurrentContext();<a name="1061199"> </a>
if (gc) {<a name="1061200"> </a>
   //draw<a name="1062204"> </a>
   GcReleaseContext(gc);<a name="1062205"> </a>
}<a name="1062176"> </a>
WinPopDrawState();<a name="1082914"> </a>
</pre><div class="CodeRule"><hr></div>

<h3 class="hbH3">
  <a name="1088765"> </a>Bitmaps <a href="#1083817"><span class="nav">^TOP^</span></a>
</h3>


<p><a name="1088766"> </a>You can programmatically create a bitmap, draw into it, and then later paint it onto the screen or store it in a database for future use. See <a href="UI_BitmapConcept.html#1005083">Chapter 9, "Working with Bitmaps,"</a> for more information. </p>

<h2 class="haH2">
  <a name="1056136"> </a>Compatibility with the Old Drawing System <a href="#1083817"><span class="nav">^TOP^</span></a>
</h2>


<p><a name="1075005"> </a>If you are porting a 68K-based application that does drawing, it probably uses the <code>WinDraw.</code>.. or <code>WinPaint</code>... functions (such as <a href="UI_Window.html#1028506"><code>WinDrawLine()</code></a> or <a href="UI_Window.html#999872"><code>WinPaintLine()</code></a>). </p>

<p><a name="1075046"> </a>The old window drawing functions are still supported for backward compatibility and work as you would expect. </p>

<p><a name="1075070"> </a>The Graphics Context functions and the Window Manager drawing functions live in two separate worlds. They have separate notions of the drawing state. Do not mix the two. Do not use the functions described in <a href="UI_Window.html#1474314">"Window Drawing Functions and Macros"</a> in between calls to <a href="UI_GraphicContext.html#1114107"><code>GcGetCurrentContext()</code></a> and <a href="UI_GraphicContext.html#994064"><code>GcReleaseContext()</code></a>. Do not expect the Window Manager functions that set the draw state to affect the Graphics Context (see <a href="UI_Drawing.html#1075093">Listing 8.4</a>). </p>
<p class="CCodeCaption">
  <a name="1075093"> </a><b>Listing 8.4&nbsp;&nbsp;Do not mix Window drawing and Graphics Context drawing</b>
</p>

<div class="CodeRule"><hr></div><pre class="CodeBlock">
GcHandle gc;
RGBColorType *textColor, *oldTextColor;<a name="1075106"> </a>
<a name="1089306"> </a>
textColor-&gt;r = 255;<a name="1089307"> </a>
textColor-&gt;g = textColor-&gt;b = 0;<a name="1089308"> </a>
<a name="1075118"> </a>
// CAUTION! WinSetTextColoRGB() does not affect <a name="1089837"> </a>
// GcDrawTextAt(). <a name="1089894"> </a>
WinSetTextColorRGB(textColor, oldTextColor);<a name="1075117"> </a>
gc = GetCurrentContext();<a name="1075116"> </a>
if (gc) {<a name="1075121"> </a>
   GcDrawTextAt(gc, 200, 200, "I am not red.", 15);<a name="1089331"> </a>
}<a name="1075148"> </a>
</pre><div class="CodeRule"><hr></div>


<p><a name="1090051"> </a>In particular, be careful not to confuse <a href="UI_Window.html#1002873"><code>WinSetCoordinateSystem()</code></a> and <a href="UI_GraphicContext.html#1124904"><code>GcSetCoordinateSystem()</code></a>. If you call <code>GcSetCoordinateSystem()</code>, it changes only the coordinate system used by the graphics context, not by the Window Manager. It is a good idea to always make both calls to be sure that the window's coordinate system is the same coordinate system used by the graphics context. </p>

<p><a name="1090303"> </a>Note that it is perfectly acceptable to call Window Manager functions that do not set or depend on the draw state; for example, Window Manager functions that convert a set of coordinates from one system to another, such as <a href="UI_Window.html#1710112"><code>WinConvertRectangle()</code></a>, are acceptable. </p>
<h3 class="hbH3">
  <a name="1075147"> </a>Making Library Calls <a href="#1083817"><span class="nav">^TOP^</span></a>
</h3>


<p><a name="1081358"> </a>Sometimes, you may unintentionally mix the two drawing systems. For example, if you make a call to a library, you might not know how that library draws to the screen or even if it does. If you need to make a library call while you have the graphics context, preserve your state before you do so, and pop the state upon return. See <a href="UI_Drawing.html#1075170">Listing 8.5</a>.</p>
<p class="CCodeCaption">
  <a name="1075170"> </a><b>Listing 8.5&nbsp;&nbsp;Making a library call</b>
</p>

<div class="CodeRule"><hr></div><pre class="CodeBlock">
GcHandle gc = GetCurrentContext();<a name="1075197"> </a>
if (gc) {<a name="1075201"> </a>
   GcSetColor(gc, 50, 50, 50, 255);<a name="1075202"> </a>
   GcSetCoordinates(gc, kCoordinatesStandard);<a name="1075243"> </a>
   GcRect(gc, 10, 10, 10, 10);<a name="1075233"> </a>
   GcPushState(gc); // preserves path and state. <a name="1075238"> </a>
   // Call to library goes here. <a name="1075249"> </a>
   GcPopState(gc);<a name="1075250"> </a>
   // more drawing<a name="1075761"> </a>
   GcReleaseContext(gc);<a name="1075762"> </a>
}<a name="1075204"> </a>
</pre><div class="CodeRule"><hr></div>


<p><a name="1075259"> </a>If you are calling Palm OS user interface functions, it is also a good idea to preserve the state before the call and pop it after the call. Some Palm OS functions change the graphics context state, in particular the coordinate system. </p>
<h3 class="hbH3">
  <a name="1081359"> </a>Color Table Compatibility <a href="#1083817"><span class="nav">^TOP^</span></a>
</h3>


<p><a name="1081251"> </a>In earlier releases of Palm OS, the system supported screens that had <b>color tables</b> or <b>palettes</b>. Each entry in the color table specified a color that the screen could display. </p>

<p><a name="1081252"> </a>All Palm OS Cobalt displays are direct color displays. <b>Direct color displays</b> do not rely on a color lookup table because the value stored into each pixel location specifies the amount of red, green, and blue components directly. For example, a 16-bit direct color display could have 5 bits of each pixel assigned as the red component, 6 bits as the green component, and 5 bits as the blue component. With this type of display, the application is no longer limited to drawing with a color that is in the color lookup table.</p>

<p><a name="1081253"> </a>When the screen is a direct color display, the color lookup table for the screen is present only for compatibility with the old indexed mode color calls. The lookup table has no effect on the display hardware, since the hardware derives the color from the red, green, and blue bits stored in each pixel location of the frame buffer.</p>

<p><a name="1081366"> </a>You can still change the color table used by the current draw windows with the <a href="UI_Window.html#1530544"><code>WinPalette()</code></a> function. However, <code>WinPalette()</code> no longer affects what is already drawn onto the screen. It only affects future drawing. </p>

<h2 class="haH2">
  <a name="1081484"> </a>Drawing Tips <a href="#1083817"><span class="nav">^TOP^</span></a>
</h2>


<p><a name="1081501"> </a>This section provides the following tips for efficient use of the Graphics Context API:</p>
   <blockquote class = "bq"><a name="1083451"> </a><a href="UI_Drawing.html#1080751">Draw to Exact Pixel Boundaries</a></blockquote>
   <blockquote class = "bq"><a name="1083468"> </a><a href="UI_Drawing.html#1077599">Reuse the Current Path</a></blockquote>
   <blockquote class = "bq"><a name="1092446"> </a><a href="UI_Drawing.html#1077498">Take Advantage of Winding Rule</a></blockquote>
   <blockquote class = "bq"><a name="1083485"> </a><a href="UI_Drawing.html#1092285">Avoid Antialiasing</a></blockquote>
   <blockquote class = "bq"><a name="1083490"> </a><a href="UI_Drawing.html#1082207">Avoid Alpha Blending</a></blockquote>
   <blockquote class = "bq"><a name="1083495"> </a><a href="UI_Drawing.html#1082211">Efficient Cap and Join Modes</a></blockquote>
   <blockquote class = "bq"><a name="1083500"> </a><a href="UI_Drawing.html#1082213">Avoid Transformations</a></blockquote>
   <blockquote class = "bq"><a name="1083529"> </a><a href="UI_Drawing.html#1077557">Avoid Flushing the Buffer</a></blockquote>
<h3 class="hbH3">
  <a name="1080751"> </a>Draw to Exact Pixel Boundaries <a href="#1083817"><span class="nav">^TOP^</span></a>
</h3>


<p><a name="1080754"> </a>If you are drawing user interface items, your drawing will look better if it takes up entire pixels rather than partial pixels. Generally, using whole integer coordinates helps limit the number of partial pixels for filled paths. For stroked paths, you must take the pen width into account and make sure that the majority of the pen is on whole pixel boundaries. Remember that 50% of the pen width lies on one side of your path and 50% on the other side. If the pen width is odd (for example 1 pixel), then you should specify coordinates that end in 0.5. If the pen width is even, you can use whole integer coordinates. </p>

<p><a name="1083224"> </a>Suppose you have the code shown in <a href="UI_Drawing.html#1083102">Listing 8.6</a> to draw a rectangle frame. This may result in a frame that is one pixel off from where you expect, as shown in the top two rectangles in <a href="UI_Drawing.html#1080757">Figure 8.4</a>. The rendering system paints whichever pixels have their center points covered. The hardware determines which exact pixels are chosen, the ones on the left side of your path or the ones on the right. If antialiasing is turned on, the effect is even worse. None of the pixels are wholly part of the path, so they all get only a percentage of the color. </p>
<p class="CCodeCaption">
  <a name="1083102"> </a><b>Listing 8.6&nbsp;&nbsp;Drawing to exact pixel boundaries (incorrect)</b>
</p>

<div class="CodeRule"><hr></div><pre class="CodeBlock">
GcHandle gc = GetCurrentContext();<a name="1083123"> </a>
if (gc) {<a name="1083124"> </a>
   GcSetColor(gc, 255, 255, 255, 255);<a name="1083125"> </a>
   GcSetPenSize(gc, 1.0);<a name="1083126"> </a>
   GcSetJoin(gc, kMiterJoin, 1);<a name="1083169"> </a>
   //BAD CODE! This may result in a rect one pixel off<a name="1083188"> </a>
   // from where you expect<a name="1083197"> </a>
   GcRect(gc, 4.0, 2.0, 10.0, 7.0);<a name="1083127"> </a>
   GcStroke(gc);<a name="1083206"> </a>
   GcPaint(gc);<a name="1083215"> </a>
   GcReleaseContext(gc);<a name="1083132"> </a>
}<a name="1083133"> </a>
</pre><div class="CodeRule"><hr></div>


<p class="FFigureCaption">
  <a name="1080757"> </a><b>Figure 8.4&nbsp;&nbsp;Stroked paths with odd pen width</b>
</p>
<div align="left"><img src="images/AntiAliasing24.jpg" height="244" width="624" border="0" hspace="0" vspace="0">
</div>

<p><a name="1083372"> </a>If you change your rectangle coordinates so that they all end in 0.5 as shown in <a href="UI_Drawing.html#1083409">Listing 8.7</a>, the pen draws on exact pixel boundaries, and you'll get the desired rectangle regardless of the antialiasing setting, as shown in the bottom two rectangles of <a href="UI_Drawing.html#1080757">Figure 8.4</a>. </p>
<p class="CCodeCaption">
  <a name="1083409"> </a><b>Listing 8.7&nbsp;&nbsp;Drawing to exact pixel boundaries (correct)</b>
</p>

<div class="CodeRule"><hr></div><pre class="CodeBlock">
GcHandle gc = GetCurrentContext();<a name="1083410"> </a>
if (gc) {<a name="1083411"> </a>
   GcSetColor(gc, 255, 255, 255, 255);<a name="1083412"> </a>
   GcSetPenSize(gc, 1.0);<a name="1083413"> </a>
   GcSetJoin(gc, kMiterJoin, 1);<a name="1083414"> </a>
   GcRect(gc, 4.5, 8.5, 10.5, 13.5);<a name="1083417"> </a>
   GcStroke(gc);<a name="1083418"> </a>
   GcPaint(gc);<a name="1083419"> </a>
   GcReleaseContext(gc);<a name="1083420"> </a>
}<a name="1083421"> </a>
</pre><div class="CodeRule"><hr></div>


<p><a name="1085036"> </a>If the pen width is even, however, it is better to specify whole integer coordinates. Then the system paints all of the pixels on the left side of your path and all of the pixels on the right side of your path as shown in the top two rectangles of <a href="UI_Drawing.html#1085045">Figure 8.5</a>. When the pen width is even, the path looks bad when you specify sub-pixel coordinates. </p>

<p class="FFigureCaption">
  <a name="1085045"> </a><b>Figure 8.5&nbsp;&nbsp;Stroked paths with even pen width</b>
</p>
<div align="left"><img src="images/AntiAliasing35.jpg" height="226" width="624" border="0" hspace="0" vspace="0">
</div>
<h3 class="hbH3">
  <a name="1077599"> </a>Reuse the Current Path <a href="#1083817"><span class="nav">^TOP^</span></a>
</h3>


<p><a name="1077433"> </a>The current path is stored as part of your drawing state and is cleared by <a href="UI_GraphicContext.html#1120151"><code>GcPaint()</code></a>. You can take advantage of this to perform multiple operations on this path without having to redefine it each time. For example, <a href="UI_Drawing.html#1081644">Listing 8.8</a> shows an efficient way to fill and then outline a rounded rectangle. </p>
<p class="CCodeCaption">
  <a name="1081644"> </a><b>Listing 8.8&nbsp;&nbsp;Reusing the path </b>
</p>

<div class="CodeRule"><hr></div><pre class="CodeBlock">
void DrawOutlinedRoundRect(GcHandle ctxt)<a name="1077434"> </a>
{<a name="1077435"> </a>
   // First fill the rectangle, pushing it on the state<a name="1077436"> </a>
   // stack so we can recover it after painting.<a name="1077437"> </a>
   GcSetAntialiasing(ctxt, kEnableAntialiasing);<a name="1089343"> </a>
   GcSetColor(ctxt, 255, 0, 0, 255);<a name="1077438"> </a>
   GcRoundRect(ctxt, 0, 0, 10, 10, 3, 3);<a name="1077439"> </a>
   GcPushState(ctxt);<a name="1077440"> </a>
   // For even more efficient code, turn off antialiasing. <a name="1083599"> </a>
   GcSetAntialiasing(ctxt, kDisableAntialiasing);<a name="1083589"> </a>
   GcPaint(ctxt);<a name="1077441"> </a>
<a name="1077442"> </a>
   // Now restore the previous rectangle, stroke to make<a name="1077443"> </a>
   // its outline and paint that path.<a name="1077444"> </a>
   GcPopState(ctxt);<a name="1077445"> </a>
   GcSetColor(0, 255, 0, 255);<a name="1081653"> </a>
   GcStroke(ctxt);<a name="1077446"> </a>
   GcPaint(ctxt);<a name="1077448"> </a>
}<a name="1077449"> </a>
</pre><div class="CodeRule"><hr></div>

<h3 class="hbH3">
  <a name="1077498"> </a>Take Advantage of Winding Rule <a href="#1083817"><span class="nav">^TOP^</span></a>
</h3>


<p><a name="1091789"> </a>Palm OS Cobalt version 6.0 uses the odd winding rule. It is more efficient to take advantage of the winding rule than it is to define complex clipping regions. In addition, the winding rule supports antialiasing, and the clipping region does not. </p>

<p><a name="1091816"> </a>The <b>winding rule</b> determines which points are part of the result when some parts of the path enclose other parts of it. Each point is assigned a <b>winding number </b>based on its location in relation to the the parts of the path. On Palm OS, you draw counterclockwise to decrease the winding number, and draw clockwise to increase it. </p>

<p><a name="1091737"> </a>The odd winding rule specifies that only points with an odd winding number are considered part of the result. All other points are not part of the result. </p>

<p><a name="1091772"> </a><a href="UI_Drawing.html#1092061">Figure 8.6</a> shows a path that is affected by the winding rule. A triangle drawn counter clockwise is partially intersected by a square drawn clockwise, which wholly contains a a circle that is also drawn clockwise. </p>

<p class="FFigureCaption">
  <a name="1092061"> </a><b>Figure 8.6&nbsp;&nbsp;Winding rule effects</b>
</p>
<div align="left"><img src="images/UI_Drawing6.jpg" height="130" width="480" border="0" hspace="0" vspace="0">
</div>

<p><a name="1092137"> </a>Winding numbers are determined starting from the top-left corner moving toward the bottom right. Because the triangle is drawn counterclockwise, it decrements the winding number so that points only within the triangle have a winding number of &#8211;1. Because the square is drawn clockwise, it increments the winding number. Therefore, the intersection of the square and the triangle has a winding number of 0 and points only within the square have a winding number of 1. Points within the circle are either 1 or 2. </p>

<p><a name="1091983"> </a>The odd winding rule specifies that all points with an odd winding number are part of the result and should be painted. As you can see in <a href="UI_Drawing.html#1092061">Figure 8.6</a>, those portions with a 0 or 2 winding number are not painted. </p>

<p><a name="1092213"> </a><a href="UI_Drawing.html#1091990">Figure 8.7</a> shows a path that is a series of squares and circles that enclose one another. All squares are drawn counterclockwise, and all circles are drawn clockwise. Because of this, all points that are <i>not</i> part of the intersection of a square and its immediately enclosed circle have a winding number of &#8211;1, but all points that are part of the the circle have a winding number of 0. </p>

<p class="FFigureCaption">
  <a name="1091990"> </a><b>Figure 8.7&nbsp;&nbsp;Winding rule effects</b>
</p>
<div align="left"><img src="images/UI_Drawing7.jpg" height="130" width="480" border="0" hspace="0" vspace="0">
</div>

<p><a name="1092282"> </a>If you intend to take advantage of the winding rule to draw complex shapes, you should note the following:</p>
<ul type="disc">
  <li><a name="1092283"> </a>All <a href="UI_GraphicContext.html#1122410"><code>GcRect()</code></a> functions draw clockwise. If you want to draw a rectangle counterclockwise, use <a href="UI_GraphicContext.html#1118074"><code>GcLineTo()</code></a> to construct it. 
  <li><a name="1092295"> </a><a href="UI_GraphicContext.html#1103458"><code>GcArc()</code></a> always draws clockwise. There is currently no way to draw a counterclockwise arc. 
  <li><a name="1093116"> </a>Stroked paths are drawn clockwise. If a stroked path intersects with itself, the intersection has an even winding number and is therefore not painted. 
  <li><a name="1092303"> </a>In the discussions and figures above, the terms "clockwise" and "counterclockwise" are from your point of view <i>as you are drawing to or looking at the screen</i>. Mathematically speaking, drawing clockwise first increases the y value as you move from the origin and counterclockwise drawing decreases the y value. On Palm OS screens, the origin is in the top-left corner, and the y value increases downward. Therefore, drawing that looks counterclockwise to you is actually clockwise. 
   <p><a name="1092413"> </a>If you're familiar with the OpenGL or PostScript languages, you may know that the winding number is increased on a counterclockwise path and decreased on a clockwise one. Palm OS follows this same rule if you use the mathematical definitions of clockwise and counterclockwise. </p>
   <p><a name="1092434"> </a>To avoid confusion, you can do a reflection and translation transformation to move the origin to the lower-left corner of the screen before doing any drawing that is affected by the winding rule. </p>
</ul>
<h3 class="hbH3">
  <a name="1092285"> </a>Avoid Antialiasing  <a href="#1083817"><span class="nav">^TOP^</span></a>
</h3>


<p><a name="1081637"> </a>Because antialiasing is a significant performance drain, you should disable it if you know you are not going to need it. </p>

<p><a name="1081660"> </a>For example, <a href="UI_Drawing.html#1081644">Listing 8.8</a> fills and then outlines a rectangle. It turns off antialiasing for the first path. The outline will cover the edges of the filled path, so there is no need to antialias the filled path. </p>
<h3 class="hbH3">
  <a name="1082207"> </a>Avoid Alpha Blending <a href="#1083817"><span class="nav">^TOP^</span></a>
</h3>


<p><a name="1082252"> </a>To perform alpha blending, the rendering system must first read the value of the destination pixels and then blend with the requested color. This can be expensive. Use opaque figures where possible. Note that antialiasing generally uses alpha blending. </p>
<h3 class="hbH3">
  <a name="1082211"> </a>Efficient Cap and Join Modes <a href="#1083817"><span class="nav">^TOP^</span></a>
</h3>


<p><a name="1082212"> </a>You should use <code>kBevelJoin</code> and <code>kButtCap</code> when drawing lines for which you don't have a particular preference about the join and cap styles. When using these styles, the system can optimize the stroking of simple figures to avoid full stroking calculations.</p>
<h3 class="hbH3">
  <a name="1082213"> </a>Avoid Transformations  <a href="#1083817"><span class="nav">^TOP^</span></a>
</h3>


<p><a name="1082214"> </a>Simple translation transformations are significantly more efficient than general transformations; scaling (with or without translation) transformations are not as efficient but still allow many internal optimizations to occur. In general, the more complicated the transformation (translation being the least complicated, then scaling, and rotation being the most complicated), the more the system will have to go through the full general drawing model instead of being able to use a more optimized code path.</p>
<h3 class="hbH3">
  <a name="1077557"> </a>Avoid Flushing the Buffer <a href="#1083817"><span class="nav">^TOP^</span></a>
</h3>


<p><a name="1077558"> </a>As stated in <a href="UI_Drawing.html#1078818">"Graphics Context,"</a> the rendering system runs in a different process than the application. To reduce IPC overhead, drawing operations are buffered and sent to the rendering system in batches. The rendering system sends its buffered commands at the end of each event loop. </p>

<p><a name="1082049"> </a>The functions <a href="UI_GraphicContext.html#1017667"><code>GcCommit()</code></a> and <a href="UI_GraphicContext.html#1115387"><code>GcFlush()</code></a> break this buffering, causing all currently buffered commands to be sent immediately. In addition, <code>GcCommit()</code> waits for those commands to finish drawing. <code>GcCommit()</code> and <code>GcFlush()</code> can be extremely slow, so it is best to avoid calling them. </p>

<p><a name="1088981"> </a>Most applications should flush the buffer only during debugging. Remove these calls before you release the application. </p>

<p><a name="1088984"> </a>You might also flush the buffer if you know that your application is about to perform a lengthy operation that might delay it from reaching the end of the event loop. </p>

<p><a name="1082064"> </a>Remember that all drawing to off-screen windows or to bitmaps is performed immediately, so there is no need to call <code>GcCommit()</code> and <code>GcFlush()</code> in those cases. </p>

<h2 class="haH2">
  <a name="1056221"> </a>Summary of Drawing Functions <a href="#1083817"><span class="nav">^TOP^</span></a>
</h2>



<div class="tablediv"><table cellspacing="0" class="tTable">

  <tr valign="top">
    <th><p class="tt"><a name="1086778"> </a><b><span style="color: #000000;  font-style: normal; font-weight: bold; text-decoration: none; text-transform: none; vertical-align: baseline">Graphic Context Functions</span></b></p>
    </th>
    <th><p class="tt"><a name="1086780"> </a><b></b></p>
    </th>
  </tr>
  <tr valign="top">
    <td>
<h4 class="hcH4">
  <a name="1086940"> </a>Obtaining a context
</h4>
    </td>
    <td><p class="tt"><a name="1086942"> </a></p>
    </td>
  </tr>
  <tr valign="top">
    <td>
<h4 class="hcH4">
  <a name="1086950"> </a><a href="UI_GraphicContext.html#1114107"><code>GcGetCurrentContext()</code></a><span style="color: #000000;  font-style: normal; font-weight: normal; text-decoration: none; text-transform: none; vertical-align: baseline"><br></span><a href="UI_GraphicContext.html#994782"><code>GcCreateBitmapContext()</code></a>
</h4>
    </td>
    <td><p class="tt"><a name="1086952"> </a><br><a href="UI_GraphicContext.html#994064"><code>GcReleaseContext()</code></a></p>
    </td>
  </tr>
  <tr valign="top">
    <td>
<h4 class="hcH4">
  <a name="1087032"> </a>Setting the State
</h4>
    </td>
    <td><p class="tt"><a name="1087034"> </a></p>
    </td>
  </tr>
  <tr valign="top">
    <td>
<h4 class="hcH4">
  <a name="1087048"> </a><a href="UI_GraphicContext.html#1121283"><code>GcPopState()</code></a><span style="color: #000000;  font-style: normal; font-weight: normal; text-decoration: none; text-transform: none; vertical-align: baseline"><br></span><a href="UI_GraphicContext.html#1147963"><code>GcSetAntialiasing()</code></a><span style="color: #000000;  font-style: normal; font-weight: normal; text-decoration: none; text-transform: none; vertical-align: baseline"><br></span><a href="UI_GraphicContext.html#1124840"><code>GcSetCaps()</code></a><span style="color: #000000;  font-style: normal; font-weight: normal; text-decoration: none; text-transform: none; vertical-align: baseline"><br></span><a href="UI_GraphicContext.html#1124904"><code>GcSetCoordinateSystem()</code></a><span style="color: #000000;  font-style: normal; font-weight: normal; text-decoration: none; text-transform: none; vertical-align: baseline"><br></span><a href="UI_GraphicContext.html#1125797"><code>GcSetJoin()</code></a><span style="color: #000000;  font-style: normal; font-weight: normal; text-decoration: none; text-transform: none; vertical-align: baseline"><br></span><a href="UI_GraphicContext.html#1125827"><code>GcSetPenSize()</code></a>
</h4>
    </td>
    <td><p class="tt"><a name="1087050"> </a><a href="UI_GraphicContext.html#1121303"><code>GcPushState()</code></a><br><a href="UI_GraphicContext.html#1116573"><code>GcInitGradient()</code></a><br><a href="UI_GraphicContext.html#1125766"><code>GcSetGradient()</code></a><br><a href="UI_GraphicContext.html#1124873"><code>GcSetColor()</code></a><br><a href="UI_GraphicContext.html#1125325"><code>GcSetFont()</code></a></p>
    </td>
  </tr>
  <tr valign="top">
    <td>
<h4 class="hcH4">
  <a name="1086782"> </a>Path Construction
</h4>
    </td>
    <td><p class="tt"><a name="1086784"> </a></p>
    </td>
  </tr>
  <tr valign="top">
    <td><p class="tt"><a name="1086786"> </a><a href="UI_GraphicContext.html#1103458"><code>GcArc()</code></a><br><a href="UI_GraphicContext.html#1106848"><code>GcBezierTo()</code></a><br><a href="UI_GraphicContext.html#1118074"><code>GcLineTo()</code></a><br><a href="UI_GraphicContext.html#1122410"><code>GcRect()</code></a><br><a href="UI_GraphicContext.html#994955"><code>GcStroke()</code></a></p>
    </td>
    <td><p class="tt"><a name="1086788"> </a><a href="UI_GraphicContext.html#1103512"><code>GcArcTo()</code></a><br><a href="UI_GraphicContext.html#1108164"><code>GcClosePath()</code></a><br><a href="UI_GraphicContext.html#1118101"><code>GcMoveTo()</code></a><br><a href="UI_GraphicContext.html#994936"><code>GcRoundRect()</code></a><br><a href="UI_GraphicContext.html#1188193"><code>GcRectI()</code></a></p>
    </td>
  </tr>
  <tr valign="top">
    <td><p class="tt"><a name="1087126"> </a><b>Painting the path </b></p>
    </td>
    <td><p class="tt"><a name="1087128"> </a></p>
    </td>
  </tr>
  <tr valign="top">
    <td><p class="tt"><a name="1087134"> </a><b><a href="UI_GraphicContext.html#1120151"><code>GcPaint()</code></a><span style="color: #000000;  font-style: normal; font-weight: normal; text-decoration: none; text-transform: none; vertical-align: baseline"><br></span><a href="UI_GraphicContext.html#1196638"><code>GcDrawTextAt()</code></a></b></p>
    </td>
    <td><p class="tt"><a name="1087136"> </a></p>
    </td>
  </tr>
  <tr valign="top">
    <td><p class="tt"><a name="1088934"> </a><b>Painting bitmaps</b></p>
    </td>
    <td><p class="tt"><a name="1088936"> </a></p>
    </td>
  </tr>
  <tr valign="top">
    <td><p class="tt"><a name="1088942"> </a><b><a href="UI_GraphicContext.html#1170306"><code>GcDrawBitmapAt()</code></a><span style="color: #000000;  font-style: normal; font-weight: normal; text-decoration: none; text-transform: none; vertical-align: baseline"><br></span><a href="UI_GraphicContext.html#1170627"><code>GcDrawRawBitmapAt()</code></a></b></p>
    </td>
    <td><p class="tt"><a name="1088944"> </a><a href="UI_GraphicContext.html#1120182"><code>GcPaintBitmap()</code></a><br><a href="UI_GraphicContext.html#1171079"><code>GcReleaseBitmap()</code></a></p>
    </td>
  </tr>
  <tr valign="top">
    <td><p class="tt"><a name="1087226"> </a><b>Transformations</b></p>
    </td>
    <td><p class="tt"><a name="1087228"> </a></p>
    </td>
  </tr>
  <tr valign="top">
    <td><p class="tt"><a name="1087234"> </a><b><a href="UI_GraphicContext.html#1123136"><code>GcReflect()</code></a><span style="color: #000000;  font-style: normal; font-weight: normal; text-decoration: none; text-transform: none; vertical-align: baseline"><br></span><a href="UI_GraphicContext.html#1124400"><code>GcScale()</code></a><span style="color: #000000;  font-style: normal; font-weight: normal; text-decoration: none; text-transform: none; vertical-align: baseline"><br></span><a href="UI_GraphicContext.html#1171204"><code>GcTransform()</code></a></b></p>
    </td>
    <td><p class="tt"><a name="1087236"> </a><a href="UI_GraphicContext.html#1123487"><code>GcRotate()</code></a><br><a href="UI_GraphicContext.html#995590"><code>GcTranslate()</code></a><br><a href="UI_GraphicContext.html#1188452"><code>GcShear()</code></a></p>
    </td>
  </tr>
  <tr valign="top">
    <td colspan="2" rowspan="1">
<h4 class="hcH4">
  <a name="1086820"> </a>Setting the Clipping Rectangle
</h4>
    </td>
  </tr>
  <tr valign="top">
    <td>
<h4 class="hcH4">
  <a name="1086828"> </a><a href="UI_GraphicContext.html#1104793"><code>GcBeginClip()</code></a>
</h4>
    </td>
    <td><p class="tt"><a name="1086830"> </a><a href="UI_GraphicContext.html#1112161"><code>GcEndClip()</code></a></p>
    </td>
  </tr>
  <tr valign="top">
    <td>
<h4 class="hcH4">
  <a name="1086897"> </a>Flushing the buffer
</h4>
    </td>
    <td><p class="tt"><a name="1086899"> </a></p>
    </td>
  </tr>
  <tr valign="top">
    <td>
<h4 class="hcH4">
  <a name="1086905"> </a><a href="UI_GraphicContext.html#1017667"><code>GcCommit()</code></a>
</h4>
    </td>
    <td><p class="tt"><a name="1086907"> </a><a href="UI_GraphicContext.html#1115387"><code>GcFlush()</code></a></p>
    </td>
  </tr>
</table>

</div>


<p><a name="1086643"> </a></p>
&nbsp;<br>
</div>
<!--END CONTENT-->

</td>
<td width="5">&nbsp;&nbsp;</td>
</tr>

</table>

<!-- BEGIN FOOTER -->
<table width="100%" border="0" cellspacing="0" cellpadding="0">
<tr>
<td width="7" rowspan="2"><img name="index_x" src="images/shim.gif" width="7" height="33" border="0" alt=""></td>
<td align="left"><img name="dashes" src="images/dashes.gif" width="744" height="3" border="0" alt=""></td>
<td width="10" rowspan="2"><img name="index_x" src="images/shim.gif" width="10" height="33" border="0" alt=""></td>
</tr>
<tr>
<td align="center">
<p class="footer">
Copyright © 2003&#8211;2004, PalmSource, Inc. and its affiliates. All rights reserved.<br>
<a href="http://www.palmsource.com/contact/">Write Us</a> | <a href="http://www.palmos.com/dev/training/">Training</a> | <a href="http://www.palmos.com/dev/support/kb/">Knowledge Base</a> | <a href="UI_Front.html" target="_blank">Legal</a></p>
<br>
<!--BEGIN BOOK NAVIGATION-->
<p class="nav">
<A href="http://www.palmos.com/dev/support/docs/">Documentation</a>&nbsp;&nbsp;|&nbsp;&nbsp;
<a href="UI_TOC.html">Table of Contents</a>&nbsp;&nbsp;
             |&nbsp;&nbsp;<a href="UI_GadgetConcept.html">&lt;&nbsp;Previous</a>&nbsp;&nbsp;
             |&nbsp;&nbsp;<a href="UI_BitmapConcept.html">Next&nbsp;&gt;</a>&nbsp;&nbsp;
             |&nbsp;&nbsp;<a href="UI_IX.html">Index</a>
</p>
</td>
</tr>
</table>
<!-- END FOOTER -->

</body>
</html>