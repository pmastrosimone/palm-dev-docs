<html>
<head>
<title>(Protein) Window Reference | User Interface </title> 
<link href="psi_devpubs.css" rel="stylesheet" type="text/css">

<!-- BEGIN META DATA -->
<meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
<META NAME="PSITEMPLATE" CONTENT="1006-007 PalmSource_HTML_2003 20041101">
<META NAME="GENERATOR" CONTENT="Quadralay WebWorks AutoMap 2003 for FrameMaker 8.0.6.2138">
<META NAME="LASTUPDATED" CONTENT="11/22/04 12:25:04">
<!-- END META DATA -->
</head>

<body bgcolor="#ffffff" text="#000000" leftmargin="0" topmargin="0" marginwidth="0" marginheight="0">
<a name="1160850"></a>

<!-- BEGIN TOPNAV -->
<table width="100%" border="0" cellspacing="0" cellpadding="0">
<tr>
<td><img src="images/shim.gif" width="7" height="75" border="0" alt=""></td>
<td align="left"><table border="0" cellpadding="0" cellspacing="0" width="744">
<tr>
<td><img name="index_r2_c1" src="images/shim.gif" width="25" height="75" border="0" alt=""></td>
<td valign="top"><table border="0" cellpadding="0" cellspacing="0" width="96">
<tr>
<td><img name="index_r2_c4" src="images/shim.gif" width="96" height="15" border="0" alt=""></td>
</tr>
<tr>
<td><a href="http://www.palmsource.com/"><img name="ps_logo" src="images/ps_logo.gif" width="96" height="54" border="0" alt=""></a></td>
</tr>

</table>
</td>

<td><table border="0" cellpadding="0" cellspacing="0" width="30">
<td><img name="index_x" src="images/shim.gif" width="30" height="75" border="0" alt=""></td>
</table></td>

<!--BEGIN MASTHEAD-->
<td><table border="0" cellpadding="0" cellspacing="0" width="96">
<tr>
<td><img name="index_x" src="images/shim.gif" width="615" height="5" border="0" alt=""></td>
</tr>
<tr>
<td>
<!--BEGIN BOOK NAVIGATION-->
<span class="nav">
<A href="http://www.palmos.com/dev/support/docs/">Documentation</a>&nbsp;&nbsp;|&nbsp;&nbsp;
<a href="UI_TOC.html">Table of Contents</a>&nbsp;&nbsp;
             |&nbsp;&nbsp;<a href="UI_Color.html">&lt;&nbsp;Previous</a>&nbsp;&nbsp;
             |&nbsp;&nbsp;<a href="UI_IX.html">Next&nbsp;&gt;</a>&nbsp;&nbsp;
             |&nbsp;&nbsp;<a href="UI_IX.html">Index</a>
</span>
<!--END BOOK NAVIGATION-->
</tr>
<tr>
<td>
<!--BEGIN PAGE TITLE-->
<h2 class="PageTitle">36 &nbsp;&nbsp;
Window Reference</h2></td>
<!--END PAGE TITLE-->
</tr>
<tr>
<td>
<!--BEGIN BOOK TITLE-->
<p class="BookTitle">User Interface </p>
<p class="SubTitle">Exploring Palm OS&#174; </p>
<!--END BOOK TITLE-->
</td>
</tr>
<tr>
<td><img name="index_x" src="images/shim.gif" width="615" height="5" border="0" alt=""></td>
</tr>
</table>
</td>
<!--END MASTHEAD-->
</tr>
</table>
<img name="dashes" src="images/dashes.gif" width="744" height="3" border="0" alt=""></td>
</tr>
</table>
<!-- END TOPNAV -->

<table width="100%" border="0" cellspacing="0" cellpadding="0">
<tr>
<td valign="top" width="5"><img name="index_x" src="images/shim.gif" width="5" height="33" border="0" alt=""></td>

<!--BEGIN SIDETOC-->
<td valign="top" width="175">
<div id="sidetoc" valign="bottom">
<h1 class="SideTOC1-PartTab"><a href="UI_PartRef.html">Part II: Reference</a> </h1>
<h1 class="SideTOC1"><a href="UI_Window.html">36  Window Reference</a></h1>

   <h2 class="SideTOC2"><a href="#1600489">
   Window Structures and Types</a></h2>

      <h3 class="SideTOC3"><a href="#1093797">
      CustomPatternType</a></h3>

      <h3 class="SideTOC3"><a href="#1005035">
      FrameBitsType</a></h3>

      <h3 class="SideTOC3"><a href="#1407675">
      IndexedColorType</a></h3>

      <h3 class="SideTOC3"><a href="#1617194">
      WinConstraintsType</a></h3>

      <h3 class="SideTOC3"><a href="#1414441">
      WinHandle</a></h3>

      <h3 class="SideTOC3"><a href="#1005120">
      WinLineType</a></h3>

   <h2 class="SideTOC2"><a href="#993685">
   Window Constants</a></h2>

      <h3 class="SideTOC3"><a href="#1432255">
      Constraint Constants</a></h3>

      <h3 class="SideTOC3"><a href="#1687709">
      Coordinate System Constants</a></h3>

      <h3 class="SideTOC3"><a href="#1610364">
      FrameType</a></h3>

      <h3 class="SideTOC3"><a href="#1098738">
      PatternType</a></h3>

      <h3 class="SideTOC3"><a href="#1112442">
      Other Patterns</a></h3>

      <h3 class="SideTOC3"><a href="#1679132">
      Scaling Mode Constants</a></h3>

      <h3 class="SideTOC3"><a href="#1428400">
      UnderlineModeType</a></h3>

      <h3 class="SideTOC3"><a href="#1658585">
      WinDirectionType</a></h3>

      <h3 class="SideTOC3"><a href="#1094199">
      WinDrawOperation</a></h3>

      <h3 class="SideTOC3"><a href="#994040">
      WinFlagsType</a></h3>

      <h3 class="SideTOC3"><a href="#1430421">
      WindowFormatType</a></h3>

      <h3 class="SideTOC3"><a href="#1134992">
      Miscellaneous Constants</a></h3>

   <h2 class="SideTOC2"><a href="#1659213">
   Window Events</a></h2>

      <h3 class="SideTOC3"><a href="#1746226">
      sysClearUIEvent</a></h3>

      <h3 class="SideTOC3"><a href="#1659238">
      winEnterEvent</a></h3>

      <h3 class="SideTOC3"><a href="#1659056">
      winExitEvent</a></h3>

      <h3 class="SideTOC3"><a href="#1356631">
      winFocusGainedEvent</a></h3>

      <h3 class="SideTOC3"><a href="#1357484">
      winFocusLostEvent</a></h3>

      <h3 class="SideTOC3"><a href="#1357625">
      winResizedEvent</a></h3>

      <h3 class="SideTOC3"><a href="#1357696">
      winUpdateEvent</a></h3>

      <h3 class="SideTOC3"><a href="#1711570">
      winVisibilityChangedEvent</a></h3>

   <h2 class="SideTOC2"><a href="#1712746">
   Window Manager Notifications</a></h2>

      <h3 class="SideTOC3"><a href="#1643915">
      sysNotifyDisplayChangeEvent</a></h3>

   <h2 class="SideTOC2"><a href="#1643881">
   Window Management Functions and Macros</a></h2>

      <h3 class="SideTOC3"><a href="#1021473">
      ECWinValidateHandle</a></h3>

      <h3 class="SideTOC3"><a href="#1710064">
      WinConvertCoord</a></h3>

      <h3 class="SideTOC3"><a href="#1710088">
      WinConvertPoint</a></h3>

      <h3 class="SideTOC3"><a href="#1710112">
      WinConvertRectangle</a></h3>

      <h3 class="SideTOC3"><a href="#1480636">
      WinCreateBitmapWindow</a></h3>

      <h3 class="SideTOC3"><a href="#1480700">
      WinCreateOffscreenWindow</a></h3>

      <h3 class="SideTOC3"><a href="#1480763">
      WinCreateWindow</a></h3>

      <h3 class="SideTOC3"><a href="#1480817">
      WinCreateWindowWithConstraints</a></h3>

      <h3 class="SideTOC3"><a href="#1480894">
      WinDeleteWindow</a></h3>

      <h3 class="SideTOC3"><a href="#1480922">
      WinDisplayToWindowPt</a></h3>

      <h3 class="SideTOC3"><a href="#1617340">
      WinFinishThreadUI</a></h3>

      <h3 class="SideTOC3"><a href="#1486624">
      WinFlush</a></h3>

      <h3 class="SideTOC3"><a href="#1486637">
      WinGetActiveWindow</a></h3>

      <h3 class="SideTOC3"><a href="#1486665">
      WinGetBitmap</a></h3>

      <h3 class="SideTOC3"><a href="#1486681">
      WinGetBitmapDimensions</a></h3>

      <h3 class="SideTOC3"><a href="#1486704">
      WinGetBounds</a></h3>

      <h3 class="SideTOC3"><a href="#1497100">
      WinGetDisplayExtent</a></h3>

      <h3 class="SideTOC3"><a href="#1497116">
      WinGetDisplayWindow</a></h3>

      <h3 class="SideTOC3"><a href="#1497142">
      WinGetDrawWindow</a></h3>

      <h3 class="SideTOC3"><a href="#1497166">
      WinGetDrawWindowBounds</a></h3>

      <h3 class="SideTOC3"><a href="#1497210">
      WinGetFrameType</a></h3>

      <h3 class="SideTOC3"><a href="#1497232">
      WinGetFramesRectangle</a></h3>

      <h3 class="SideTOC3"><a href="#1526656">
      WinGetPixel</a></h3>

      <h3 class="SideTOC3"><a href="#1526682">
      WinGetPixelRGB</a></h3>

      <h3 class="SideTOC3"><a href="#1517915">
      WinGetSupportedDensity</a></h3>

      <h3 class="SideTOC3"><a href="#1517946">
      WinGetWindowBounds</a></h3>

      <h3 class="SideTOC3"><a href="#1517963">
      WinGetWindowExtent</a></h3>

      <h3 class="SideTOC3"><a href="#1517987">
      WinGetWindowFlags</a></h3>

      <h3 class="SideTOC3"><a href="#1518009">
      WinGetWindowFrameRect</a></h3>

      <h3 class="SideTOC3"><a href="#1522308">
      WinIndexToRGB</a></h3>

      <h3 class="SideTOC3"><a href="#1522335">
      WinInvalidateRect</a></h3>

      <h3 class="SideTOC3"><a href="#1522368">
      WinInvalidateRectFunc</a></h3>

      <h3 class="SideTOC3"><a href="#1522408">
      WinInvalidateWindow</a></h3>

      <h3 class="SideTOC3"><a href="#1527698">
      WinModal</a></h3>

      <h3 class="SideTOC3"><a href="#1530544">
      WinPalette</a></h3>

      <h3 class="SideTOC3"><a href="#1532369">
      WinRequestFocus</a></h3>

      <h3 class="SideTOC3"><a href="#1535827">
      WinRGBToIndex</a></h3>

      <h3 class="SideTOC3"><a href="#1535889">
      WinScaleCoord</a></h3>

      <h3 class="SideTOC3"><a href="#1663801">
      WinScaleCoordNativeToActive</a></h3>

      <h3 class="SideTOC3"><a href="#1535921">
      WinScalePoint</a></h3>

      <h3 class="SideTOC3"><a href="#1535955">
      WinScaleRectangle</a></h3>

      <h3 class="SideTOC3"><a href="#1535987">
      WinScreenGetAttribute</a></h3>

      <h3 class="SideTOC3"><a href="#1536041">
      WinScreenLock</a></h3>

      <h3 class="SideTOC3"><a href="#1536068">
      WinScreenMode</a></h3>

      <h3 class="SideTOC3"><a href="#1536268">
      WinScreenUnlock</a></h3>

      <h3 class="SideTOC3"><a href="#1536290">
      WinScrollRectangle</a></h3>

      <h3 class="SideTOC3"><a href="#1570060">
      WinScrollRectangleAsync</a></h3>

      <h3 class="SideTOC3"><a href="#1536351">
      WinSetActiveWindow</a></h3>

      <h3 class="SideTOC3"><a href="#1538337">
      WinSetBounds</a></h3>

      <h3 class="SideTOC3"><a href="#1677658">
      WinSetConstraints</a></h3>

      <h3 class="SideTOC3"><a href="#1542343">
      WinSetDrawWindow</a></h3>

      <h3 class="SideTOC3"><a href="#1543355">
      WinSetWindowBounds</a></h3>

      <h3 class="SideTOC3"><a href="#1617695">
      WinStartThreadUI</a></h3>

      <h3 class="SideTOC3"><a href="#1543404">
      WinUnscaleCoord</a></h3>

      <h3 class="SideTOC3"><a href="#1543435">
      WinUnscalePoint</a></h3>

      <h3 class="SideTOC3"><a href="#1543466">
      WinUnscaleRectangle</a></h3>

      <h3 class="SideTOC3"><a href="#1604893">
      WinValidateHandle</a></h3>

      <h3 class="SideTOC3"><a href="#1543519">
      WinWindowToDisplayPt</a></h3>

   <h2 class="SideTOC2"><a href="#1474314">
   Window Drawing Functions and Macros</a></h2>

      <h3 class="SideTOC3"><a href="#1021501">
      WinClipRectangle</a></h3>

      <h3 class="SideTOC3"><a href="#1021540">
      WinCopyRectangle</a></h3>

      <h3 class="SideTOC3"><a href="#1026915">
      WinDrawBitmap</a></h3>

      <h3 class="SideTOC3"><a href="#1709837">
      WinDrawBitmapHandle</a></h3>

      <h3 class="SideTOC3"><a href="#1026950">
      WinDrawChar</a></h3>

      <h3 class="SideTOC3"><a href="#1027460">
      WinDrawChars</a></h3>

      <h3 class="SideTOC3"><a href="#1027898">
      WinDrawGrayLine</a></h3>

      <h3 class="SideTOC3"><a href="#1027939">
      WinDrawGrayRectangleFrame</a></h3>

      <h3 class="SideTOC3"><a href="#1028455">
      WinDrawInvertedChars</a></h3>

      <h3 class="SideTOC3"><a href="#1028506">
      WinDrawLine</a></h3>

      <h3 class="SideTOC3"><a href="#1028592">
      WinDrawPixel</a></h3>

      <h3 class="SideTOC3"><a href="#1028621">
      WinDrawRectangle</a></h3>

      <h3 class="SideTOC3"><a href="#1570711">
      WinDrawRectangleFrame</a></h3>

      <h3 class="SideTOC3"><a href="#1029074">
      WinDrawTruncChars</a></h3>

      <h3 class="SideTOC3"><a href="#1029680">
      WinEraseChars</a></h3>

      <h3 class="SideTOC3"><a href="#1029727">
      WinEraseLine</a></h3>

      <h3 class="SideTOC3"><a href="#1029808">
      WinErasePixel</a></h3>

      <h3 class="SideTOC3"><a href="#1029842">
      WinEraseRectangle</a></h3>

      <h3 class="SideTOC3"><a href="#1029878">
      WinEraseRectangleFrame</a></h3>

      <h3 class="SideTOC3"><a href="#1029913">
      WinEraseWindow</a></h3>

      <h3 class="SideTOC3"><a href="#1145105">
      WinFillLine</a></h3>

      <h3 class="SideTOC3"><a href="#1029991">
      WinFillRectangle</a></h3>

      <h3 class="SideTOC3"><a href="#1492237">
      WinGetClip</a></h3>

      <h3 class="SideTOC3"><a href="#1492257">
      WinGetCoordinateSystem</a></h3>

      <h3 class="SideTOC3"><a href="#1500947">
      WinGetPattern</a></h3>

      <h3 class="SideTOC3"><a href="#1505993">
      WinGetPatternType</a></h3>

      <h3 class="SideTOC3"><a href="#1699863">
      WinGetScalingMode</a></h3>

      <h3 class="SideTOC3"><a href="#999081">
      WinInvertChars</a></h3>

      <h3 class="SideTOC3"><a href="#999137">
      WinInvertLine</a></h3>

      <h3 class="SideTOC3"><a href="#999210">
      WinInvertPixel</a></h3>

      <h3 class="SideTOC3"><a href="#999254">
      WinInvertRectangle</a></h3>

      <h3 class="SideTOC3"><a href="#999326">
      WinInvertRectangleFrame</a></h3>

      <h3 class="SideTOC3"><a href="#999434">
      WinPaintBitmap</a></h3>

      <h3 class="SideTOC3"><a href="#999742">
      WinPaintChar</a></h3>

      <h3 class="SideTOC3"><a href="#999796">
      WinPaintChars</a></h3>

      <h3 class="SideTOC3"><a href="#999872">
      WinPaintLine</a></h3>

      <h3 class="SideTOC3"><a href="#999945">
      WinPaintLines</a></h3>

      <h3 class="SideTOC3"><a href="#999989">
      WinPaintPixel</a></h3>

      <h3 class="SideTOC3"><a href="#1000033">
      WinPaintPixels</a></h3>

      <h3 class="SideTOC3"><a href="#1000081">
      WinPaintRectangle</a></h3>

      <h3 class="SideTOC3"><a href="#1000125">
      WinPaintRectangleFrame</a></h3>

      <h3 class="SideTOC3"><a href="#1000377">
      WinPaintRoundedRectangleFrame</a></h3>

      <h3 class="SideTOC3"><a href="#1000472">
      WinPaintTiledBitmap</a></h3>

      <h3 class="SideTOC3"><a href="#1655765">
      WinPaintThinLine</a></h3>

      <h3 class="SideTOC3"><a href="#1000540">
      WinPaintTruncChars</a></h3>

      <h3 class="SideTOC3"><a href="#1144225">
      WinPopDrawState</a></h3>

      <h3 class="SideTOC3"><a href="#1000758">
      WinPushDrawState</a></h3>

      <h3 class="SideTOC3"><a href="#1000947">
      WinResetClip</a></h3>

      <h3 class="SideTOC3"><a href="#1002597">
      WinSetBackColor</a></h3>

      <h3 class="SideTOC3"><a href="#1002637">
      WinSetBackColorRGB</a></h3>

      <h3 class="SideTOC3"><a href="#1539836">
      WinSetClip</a></h3>

      <h3 class="SideTOC3"><a href="#1539865">
      WinSetColors</a></h3>

      <h3 class="SideTOC3"><a href="#1002873">
      WinSetCoordinateSystem</a></h3>

      <h3 class="SideTOC3"><a href="#1002952">
      WinSetDrawMode</a></h3>

      <h3 class="SideTOC3"><a href="#1003040">
      WinSetForeColor</a></h3>

      <h3 class="SideTOC3"><a href="#1003354">
      WinSetForeColorRGB</a></h3>

      <h3 class="SideTOC3"><a href="#1003398">
      WinSetFrameType</a></h3>

      <h3 class="SideTOC3"><a href="#1003650">
      WinSetPattern</a></h3>

      <h3 class="SideTOC3"><a href="#1003690">
      WinSetPatternType</a></h3>

      <h3 class="SideTOC3"><a href="#1704064">
      WinSetScalingMode</a></h3>

      <h3 class="SideTOC3"><a href="#1004002">
      WinSetTextColor</a></h3>

      <h3 class="SideTOC3"><a href="#1004042">
      WinSetTextColorRGB</a></h3>

      <h3 class="SideTOC3"><a href="#1004170">
      WinSetUnderlineMode</a></h3>

   <h2 class="SideTOC2"><a href="#1004771">
   Application-Defined Functions</a></h2>

      <h3 class="SideTOC3"><a href="#1004784">
      winInvalidateFunc</a></h3>

</div>
</td>

<td width="5">&nbsp;&nbsp;</td>
<td width="2" background="images/index_r8_c10.gif"><img src="images/shim.gif" width="2" height="75" border="0" alt=""></td>
<td width="5">&nbsp;&nbsp;</td>

<!--END SIDETOC-->

<td valign="top">

<!--BEGIN CONTENT-->
<div id="content" valign="bottom">
<p><a name="1075335"> </a>This chapter provides information about windows by discussing these topics: </p>
   <blockquote class = "bq"><a name="1075339"> </a><a href="UI_Window.html#1600489">Window Structures and Types</a></blockquote>
   <blockquote class = "bq"><a name="1638197"> </a><a href="UI_Window.html#993685">Window Constants</a></blockquote>
   <blockquote class = "bq"><a name="1383897"> </a><a href="UI_Window.html#1659213">Window Events</a></blockquote>
   <blockquote class = "bq"><a name="1645071"> </a><a href="UI_Window.html#1712746">Window Manager Notifications</a></blockquote>
   <blockquote class = "bq"><a name="1487605"> </a><a href="UI_Window.html#1643881">Window Management Functions and Macros</a></blockquote>
   <blockquote class = "bq"><a name="1487697"> </a><a href="UI_Window.html#1474314">Window Drawing Functions and Macros</a></blockquote>
   <blockquote class = "bq"><a name="1127613"> </a><a href="UI_Window.html#1004771">Application-Defined Functions</a></blockquote>

<p><a name="1600487"> </a>The header files <code>Window.h</code> and <code>CmnDrawingTypes.h</code> declare the API that this chapter describes. <a href="UI_Screen.html#995096">Chapter 1, "The Display,"</a> <a href="UI_FormConcept.html#608590">Chapter 2, "Working with Forms and Dialogs,"</a> and <a href="UI_Drawing.html#1083817">Chapter 8, "Drawing,"</a> describe some window-related concepts. </p>

<h2 class="haH2">
  <a name="1600489"> </a>Window Structures and Types <a href="#1160850"><span class="nav">^TOP^</span></a>
</h2>


<h3 class="hbH3">
  <a name="1093797"> </a>CustomPatternType Typedef <a href="#1160850"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="1093946"> </a>Purpose 
</h4>

<p><a name="1093977"> </a>Defines a pattern. </p>
<h4>
  <a name="1094006"> </a>Declared In 
</h4>
<code>CmnDrawingTypes.h<a name="1094037"> </a></code><h4>
  <a name="1094062"> </a>Prototype 
</h4>
<pre class="proto"><a name="1355903"></a>typedef uint8_t CustomPatternType[8];
</pre>
<h4>
  <a name="1355904"> </a>Comments 
</h4>

<p><a name="1355905"> </a><code>CustomPatternType</code> holds an 8-by-8 bit pattern that is one bit deep. Each byte specifies a row of the pattern. When drawing, a pattern is tiled to fill a specified region. </p>
<h4>
  <a name="1355906"> </a>See Also 
</h4>

<p><a name="1355916"> </a><a href="UI_Window.html#1145105"><code>WinFillLine()</code></a>, <a href="UI_Window.html#1029991"><code>WinFillRectangle()</code></a>, <a href="UI_Window.html#1098738"><code>PatternType</code></a></p>

<h3 class="hbH3">
  <a name="1005035"> </a>FrameBitsType Struct <a href="#1160850"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="1005037"> </a>Purpose 
</h4>

<p><a name="1005038"> </a>Specifies attributes of a window's frame. </p>
<h4>
  <a name="1005039"> </a>Declared In 
</h4>
<code>Window.h <a name="1005040"> </a></code><h4>
  <a name="1005041"> </a>Prototype 
</h4>
<pre class="proto"><a name="1005042"></a>typedef union FrameBitsType {
struct oldBitsTag {
      uint16_t cornerDiam : 8;
      uint16_t reserved_3 : 3;
      uint16_t threeD : 1;
      uint16_t shadowWidth : 2;
      uint16_t width : 2;
   } bits;
   uint16_t word;
} FrameBitsType
</pre>
<h4>
  <a name="1005052"> </a>Fields 
</h4>

<dl>
<dt><a name="1005053"> </a><code>cornerDiam</code></dt>
<dd><a name="1005054"> </a>The corner radius of frame; maximum is 38. </dd>

<dt><a name="1005055"> </a><code>reserved_3</code></dt>
<dd><a name="1005056"> </a>Reserved.</dd>

<dt><a name="1005057"> </a><code>threeD</code></dt>
<dd><a name="1005058"> </a>Set this bit to draw a 3D button. This feature is not currently supported. </dd>

<dt><a name="1005059"> </a><code>shadowWidth</code></dt>
<dd><a name="1005060"> </a>The width of the shadow.</dd>

<dt><a name="1005061"> </a><code>width</code></dt>
<dd><a name="1005062"> </a>The frame width.</dd>

<dt><a name="1005063"> </a><code>word</code></dt>
<dd><a name="1005064"> </a>Reserved.</dd>

</dl>
<h4>
  <a name="1126428"> </a>See Also 
</h4>

<p><a name="1409638"> </a><a href="UI_Window.html#1610364"><code>FrameType</code></a></p>

<h3 class="hbH3">
  <a name="1407675"> </a>IndexedColorType Typedef <a href="#1160850"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="1126722"> </a>Purpose 
</h4>

<p><a name="1126718"> </a>Specifies a color by its index value; that is, by its location in a color table. </p>
<h4>
  <a name="1126727"> </a>Declared In 
</h4>
<code>CmnDrawingTypes.h<a name="1126730"> </a></code><h4>
  <a name="1126836"> </a>Prototype 
</h4>
<pre class="proto"><a name="1126837"></a>typedef uint8_t IndexedColorType;
</pre>
<h4>
  <a name="1126847"> </a>Comments 
</h4>

<p><a name="1617190"> </a>Color tables are defined by the <a href="UI_Bitmap.html#1004026"><code>ColorTableType</code></a> structure, which is declared in <code>CmnBitmapTypes.h</code>. The <code>IndexedColorType</code> can hold a 1, 2, 4, or 8-bit index. </p>

<h3 class="hbH3">
  <a name="1617194"> </a>WinConstraintsType Struct <a href="#1160850"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="1005077"> </a>Purpose 
</h4>

<p><a name="1005078"> </a>Specifies a window's position and sizing requirements. </p>
<h4>
  <a name="1005079"> </a>Declared In 
</h4>
<code>Window.h <a name="1005080"> </a></code><h4>
  <a name="1005081"> </a>Prototype 
</h4>
<pre class="proto"><a name="1005082"></a>typedef struct WinConstraintsType {
   uint32_t x_flags;
   int16_t x_pos;
   int16_t x_min;
   int16_t x_pref;
   int16_t x_max;
   uint32_t y_flags;
   int16_t y_pos;
   int16_t y_min;
   int16_t y_pref;
   int16_t y_max;
} WinConstraintsType
</pre>
<h4>
  <a name="1005094"> </a>Fields 
</h4>

<dl>
<dt><a name="1005095"> </a><code>x_flags</code></dt>
<dd><a name="1005096"> </a>Currently unused. Set this to 0. </dd>

<dt><a name="1005097"> </a><code>x_pos</code></dt>
<dd><a name="1005098"> </a>The position, given in standard coordinates, of the left side of the window. Use the <code>winUndefConstraint</code> constant for this value to have the system place the window. </dd>

<dt><a name="1005099"> </a><code>x_min</code></dt>
<dd><a name="1005100"> </a>The minimum possible width of the window in standard coordinates. </dd>

<dt><a name="1005101"> </a><code>x_pref</code></dt>
<dd><a name="1005102"> </a>The preferred width of the window in standard coordinates. </dd>

<dt><a name="1005103"> </a><code>x_max</code></dt>
<dd><a name="1005104"> </a>The maximum width of the window in standard coordinates. </dd>

<dt><a name="1005105"> </a><code>y_flags</code></dt>
<dd><a name="1304583"> </a>Currently unused. Set this to 0. </dd>

<dt><a name="1005107"> </a><code>y_pos</code></dt>
<dd><a name="1005108"> </a>The position of the top of the window in standard coordinates. Use the <code>winUndefConstraint</code> constant for this value to have the system place the window. </dd>

<dt><a name="1005109"> </a><code>y_min</code></dt>
<dd><a name="1005110"> </a>The minimum height that the window should ever be made in standard coordinates. </dd>

<dt><a name="1005111"> </a><code>y_pref</code></dt>
<dd><a name="1005112"> </a>The preferred height for this window in standard coordinates. </dd>

<dt><a name="1005113"> </a><code>y_max</code></dt>
<dd><a name="1005114"> </a>The maximum height for the window in standard coordinates. </dd>

</dl>
<h4>
  <a name="1005115"> </a>Comments 
</h4>

<p><a name="1005116"> </a>You set a window's size constraints when you add a <code>WINDOW_CONSTRAINTS_RESOURCE</code> to a form or when you programmatically create a window using <a href="UI_Window.html#1480817"><code>WinCreateWindowWithConstraints()</code></a>. The actual size of the window is negotiated at run time taking into account the size requirements for the active pinlet in the input area, the status bar, and any other panel that is being displayed.</p>

<p><a name="1411139"> </a>These constraints should specify a window's ideal sizes independent of the screen's actual size. It's the Window Manager's job to take the screen size into consideration when actually sizing the window. </p>

<p><a name="1414438"> </a>For example, consider a window showing a scrolling list of text. This window should report its minimum height as being the smallest size it can be while still being usable. For many applications, the minimum height is 160, which is also the default for legacy-mode windows. The window's preferred size should be the height required to display all of the text it contains. The maximum height could be one of two possibilities. If the text is not editable, it should be the same as the preferred height. If the text is editable, it will probably be the constant <code>winMaxConstraint</code>, which means make the window as large as possible because the user can use that extra space for editing. </p>
<h4>
  <a name="1552762"> </a>See Also 
</h4>

<p><a name="1552815"> </a><a href="UI_Window.html#1677658"><code>WinSetConstraints()</code></a>, <a href="UI_Window.html#1432255">"Constraint Constants"</a></p>

<h3 class="hbH3">
  <a name="1414441"> </a>WinHandle Typedef <a href="#1160850"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="993153"> </a>Purpose 
</h4>

<p><a name="1085807"> </a>Provides the handle to a window. </p>
<h4>
  <a name="993158"> </a>Declared In 
</h4>
<code>Window.h<a name="993161"> </a></code><h4>
  <a name="993163"> </a>Prototype 
</h4>
<pre class="proto"><a name="993166"></a>struct WindowType


</pre>
<pre class="proto"><a name="1637262"></a>typedef struct WindowType *WinHandle;
</pre>
<h4>
  <a name="1414517"> </a>Comments 
</h4>

<p><a name="1414586"> </a>A window is an abstract drawing region. Typically, you don't work with windows directly. You work with forms instead. You might work with windows if your application needs custom drawing. </p>
<h4>
  <a name="1623566"> </a>Compatibility 
</h4>

<p><a name="1623655"> </a>The <code>WindowType</code> structure is no longer public and has changed significantly from its definition in earlier releases. Do not attempt to access the <code>WindowType</code> structure. </p>
<h4>
  <a name="1127974"> </a>See Also 
</h4>

<p><a name="1128066"> </a><a href="UI_Form.html#1000479"><code>FrmGetWindowHandle()</code></a>, <a href="UI_Window.html#1486637"><code>WinGetActiveWindow()</code></a>, <a href="UI_Window.html#1497142"><code>WinGetDrawWindow()</code></a></p>

<h3 class="hbH3">
  <a name="1005120"> </a>WinLineType Struct <a href="#1160850"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="1005122"> </a>Purpose 
</h4>

<p><a name="1005123"> </a>Defines a line.</p>
<h4>
  <a name="1005124"> </a>Declared In 
</h4>
<code>Window.h <a name="1005125"> </a></code><h4>
  <a name="1005126"> </a>Prototype 
</h4>
<pre class="proto"><a name="1005127"></a>typedef struct WinLineType {
   Coord x1;
   Coord y1;
   Coord x2;
   Coord y2;
} WinLineType
</pre>
<h4>
  <a name="1005133"> </a>Fields 
</h4>

<dl>
<dt><a name="1005134"> </a><code>x1, y1</code></dt>
<dd><a name="1005135"> </a>The starting point of the line.</dd>

<dt><a name="1005138"> </a><code>x2, y2</code></dt>
<dd><a name="1005139"> </a>The endpoint of the line.</dd>

</dl>
<h4>
  <a name="1592635"> </a>See Also 
</h4>

<p><a name="1592637"> </a><a href="UI_Window.html#999945"><code>WinPaintLines()</code></a></p>

<h2 class="haH2">
  <a name="993685"> </a>Window Constants <a href="#1160850"><span class="nav">^TOP^</span></a>
</h2>


<h3 class="hbH3">
  <a name="1432255"> </a>Constraint Constants <a href="#1160850"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="1432256"> </a>Purpose 
</h4>

<p><a name="1432257"> </a>Special values for the fields in <a href="UI_Window.html#1617194"><code>WinConstraintsType</code></a>. </p>
<h4>
  <a name="1432261"> </a>Declared In 
</h4>
<code>Window.h <a name="1432262"> </a></code><h4>
  <a name="1432263"> </a>Constants 
</h4>

<dl>
<dt><a name="1432264"> </a><code>#define winUndefConstraint SHRT_MIN //&#8211;32768</code></dt>
<dd><a name="1432265"> </a>Specifies an undefined constraint. The system decides the value of this constraint. Undefined constraints are most commonly used for the position values so that the Window Manager positions the window at the preferred location. </dd>

<dt><a name="1432266"> </a><code>#define winMaxConstraint SHRT_MAX // 32767</code></dt>
<dd><a name="1610361"> </a>Specifies a value that means "as large as possible." </dd>

</dl>

<h3 class="hbH3">
  <a name="1687709"> </a>Coordinate System Constants <a href="#1160850"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="1687710"> </a>Purpose 
</h4>

<p><a name="1687711"> </a>Specifies the coordinate system to be used when drawing with a given window. </p>
<h4>
  <a name="1687712"> </a>Declared In 
</h4>
<code>Window.h <a name="1687713"> </a></code><h4>
  <a name="1687714"> </a>Constants 
</h4>

<dl>
<dt><a name="1687716"> </a><code>#define kCoordinatesNative 0</code></dt>
<dd><a name="1687717"> </a>Use the bitmap's or screen's native coordinate system; this enables a 1-to-1 correspondence between coordinates and pixels.</dd>

</dl>

<dl>
<dd><a name="1687718"> </a>If you use the native coordinate system, keep in mind that Palm Powered<sup>&#8482;</sup> devices come in a variety of screen densities. Do not assume that native coordinates always means double-density. </dd>

</dl>

<dl>
<dt><a name="1687720"> </a><code>#define kCoordinatesStandard 72</code></dt>
<dd><a name="1687721"> </a>On a single-density handheld (that contains a 160 <span style="color: #000000;  font-style: normal; font-weight: normal; text-decoration: none; text-transform: none; vertical-align: baseline">X </span>160 screen), there is one screen pixel per standard coordinate. On a high-density screen, there is more than one screen pixel per standard coordinate. </dd>

<dt><a name="1687723"> </a><code>#define kCoordinatesOneAndAHalf 108</code></dt>
<dd><a name="1687724"> </a>One and a half times the standard coordinate system.</dd>

<dt><a name="1687726"> </a><code>#define kCoordinatesDouble 144</code></dt>
<dd><a name="1687727"> </a>Twice the standard coordinate system.</dd>

<dt><a name="1687729"> </a><code>#define kCoordinatesTriple 216</code></dt>
<dd><a name="1687730"> </a>Three times the standard coordinate system.</dd>

<dt><a name="1687732"> </a><code>#define kCoordinatesQuadruple 288</code></dt>
<dd><a name="1687733"> </a>Four times the standard coordinate system.</dd>

</dl>
<h4>
  <a name="1687734"> </a>See Also 
</h4>

<p><a name="1687741"> </a><a href="UI_Window.html#1002873"><code>WinSetCoordinateSystem()</code></a>, <a href="UI_Window.html#1492257"><code>WinGetCoordinateSystem()</code></a>, <a href="UI_GraphicContext.html#1124904"><code>GcSetCoordinateSystem()</code></a></p>

<h3 class="hbH3">
  <a name="1610364"> </a>FrameType Typedef <a href="#1160850"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="1005188"> </a>Purpose 
</h4>

<p><a name="1005189"> </a>Specifies a window frame style. </p>
<h4>
  <a name="1005190"> </a>Declared In 
</h4>
<code>Window.h<a name="1005191"> </a></code><h4>
  <a name="1005192"> </a>Prototype 
</h4>
<pre class="proto"><a name="1005193"></a>typedef UInt16 FrameType;
</pre>
<h4>
  <a name="1005194"> </a>Constants 
</h4>

<dl>
<dt><a name="1005195"> </a><code>#define noFrame 0x0000</code></dt>
<dd><a name="1005196"> </a>No frame.</dd>

<dt><a name="1005197"> </a><code>#define simpleFrame 0x0001</code></dt>
<dd><a name="1005198"> </a>A plain rectangular frame.</dd>

<dt><a name="1005199"> </a><code>#define rectangleFrame simpleFrame</code></dt>
<dd><a name="1005200"> </a>A plain rectangular frame.</dd>

<dt><a name="1005201"> </a><code>#define simple3DFrame 0x0012</code></dt>
<dd><a name="1005202"> </a>3D frame with width of 2. This frame type is not supported.</dd>

<dt><a name="1005203"> </a><code>#define roundFrame 0x0401</code></dt>
<dd><a name="1005204"> </a>A round frame with width of 1.</dd>

<dt><a name="1005205"> </a><code>#define boldRoundFrame 0x0702</code></dt>
<dd><a name="1005206"> </a>A round frame with width of 2.</dd>

<dt><a name="1005207"> </a><code>#define popupFrame 0x0205</code></dt>
<dd><a name="1005208"> </a>Pop-up frame style with slight corner roundness, width of 1 and shadow of 1.</dd>

<dt><a name="1005209"> </a><code>#define dialogFrame 0x0302</code></dt>
<dd><a name="1005210"> </a>Dialog frame style with slight corner roundness and width of 2.</dd>

<dt><a name="1005211"> </a><code>#define menuFrame popupFrame</code></dt>
<dd><a name="1005213"> </a>Same as <code>popupFrame.</code></dd>

</dl>
<h4>
  <a name="1183597"> </a>Comments 
</h4>

<p><a name="1183598"> </a>The <code>FrameType</code> can be set to one of the defined frame types listed here or to a custom frame type as defined by a <a href="UI_Window.html#1005035"><code>FrameBitsType</code></a> structure.</p>
<h4>
  <a name="1415356"> </a>See Also 
</h4>

<p><a name="1415422"> </a><a href="UI_Window.html#1497210"><code>WinGetFrameType()</code></a>, <a href="UI_Window.html#1003398"><code>WinSetFrameType()</code></a></p>

<h3 class="hbH3">
  <a name="1098738"> </a>PatternType Enum <a href="#1160850"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="1098740"> </a>Purpose 
</h4>

<p><a name="1098743"> </a>Specifies a pattern for drawing. </p>
<h4>
  <a name="1098764"> </a>Declared In 
</h4>
<code>CmnDrawingTypes.h<a name="1098801"> </a></code><h4>
  <a name="1098822"> </a>Constants 
</h4>

<dl>
<dt><a name="1099756"> </a><code>blackPattern </code></dt>
<dd><a name="1099757"> </a>All bits on.</dd>

<dt><a name="1099758"> </a><code>whitePattern </code></dt>
<dd><a name="1099759"> </a>All bits off.</dd>

<dt><a name="1099760"> </a><code>grayPattern </code></dt>
<dd><a name="1099761"> </a>Alternating on and off bits.</dd>

<dt><a name="1099762"> </a><code>customPattern </code></dt>
<dd><a name="1099766"> </a>Custom pattern specified by <a href="UI_Window.html#1093797"><code>CustomPatternType</code></a>.</dd>

<dt><a name="1099767"> </a><code>lightGrayPattern</code></dt>
<dd><a name="1099768"> </a>One out of four bits in each row turned on. </dd>

<dt><a name="1099772"> </a><code>darkGrayPattern</code></dt>
<dd><a name="1099773"> </a>One out of four bits in each row turned off. </dd>

</dl>
<h4>
  <a name="1105314"> </a>Comments 
</h4>

<p><a name="1112311"> </a>These patterns all operate with current foreground and background color instead of black and white. In effect, <code>blackPattern</code> is only black if the current foreground color is black. <code>whitePattern</code> uses the current background color. <code>grayPattern</code> and <code>customPattern</code> uses a combination of background and foreground colors.</p>

<p><a name="1112312"> </a>Patterns are expanded to the destination bit depth when drawing patterned lines and filled rectangles.</p>

<p><a name="1112313"> </a>The three standard gray patterns&#8212;<code>grayPattern</code>, <code>lightGrayPattern</code>, and <code>darkGrayPattern</code>&#8212;are always drawn using the screen density to improve the appearance of gray fills. Custom patterns, however, are stretched as appropriate based on the destination density.</p>
<h4>
  <a name="1111582"> </a>See Also 
</h4>

<p><a name="1112424"> </a><a href="UI_Window.html#1505993"><code>WinGetPatternType()</code></a>, <a href="UI_Window.html#1003690"><code>WinSetPatternType()</code></a></p>

<h3 class="hbH3">
  <a name="1112442"> </a>Other Patterns <a href="#1160850"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="1112575"> </a>Purpose 
</h4>

<p><a name="1112578"> </a>Specifies special patterns. </p>
<h4>
  <a name="1112579"> </a>Declared In 
</h4>
<code>CmnDrawingTypes.h<a name="1112582"> </a></code><h4>
  <a name="1112722"> </a>Constants 
</h4>

<dl>
<dt><a name="1112781"> </a><code>#define noPattern blackPattern</code></dt>
<dd><a name="1113011"> </a>The shape is filled with no special pattern. Only the current color. </dd>

<dt><a name="1112782"> </a><code>#define grayHLinePattern 0xAA</code></dt>
<dd><a name="1113012"> </a>The system uses this to draw a gray diagonal line. </dd>

<dt><a name="1112783"> </a><code>#define grayHLinePatternOdd 0x55</code></dt>
<dd><a name="1113026"> </a>The system uses this to draw a gray diagonal line. </dd>

</dl>

<h3 class="hbH3">
  <a name="1679132"> </a>Scaling Mode Constants <a href="#1160850"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="1679271"> </a>Purpose 
</h4>

<p><a name="1679319"> </a>Constants used to construct a scaling mode that is passed to <a href="UI_Window.html#1704064"><code>WinSetScalingMode()</code></a>. </p>
<h4>
  <a name="1679355"> </a>Declared In 
</h4>
<code>Window.h<a name="1679358"> </a></code><h4>
  <a name="1679359"> </a>Constants 
</h4>

<dl>
<dt><a name="1679412"> </a><code>#define kBitmapScalingOff 1</code></dt>
<dd><a name="1679413"> </a>Turns bitmap scaling off, which causes the rendering system to draw the low-density bitmap family member, unscaled, when the application calls one of the bitmap drawing functions (even if the bitmap family contains a bitmap whose density matches the window's). This causes your bitmaps to be drawn smaller, as if they were being viewed from a distance. </dd>

<dt><a name="1680282"> </a><code>#define kTextScalingOff 2</code></dt>
<dd><a name="1680283"> </a>Turns text scaling off, which causes the rendering system to render text using the low-density family member of the appropriate font, unscaled, when the application subsequently draws text (even if the font family contains a font whose density matches the window's). This results in smaller-sized text being drawn on the screen.</dd>

<dt><a name="1680291"> </a><code>#define kTextPaddingOff 4</code></dt>
<dd><a name="1680292"> </a>Turns off text padding. When text padding is turned off, the rendering system does not insert pixels between glyphs in order to align glyphs on standard coordinates. (Text padding is on by default.) By setting the <code>kTextPaddingOff</code> bit, an application can lay out text using high density coordinates and preserve the native font's internal kerning. This unpadded mode provides the best appearance of text, but requires the application to use the high-density coordinate system.</dd>

<dd><a name="1736353"> </a>Currently, setting <code>kTextPaddingOff</code> has no effect. </dd>

</dl>
<h4>
  <a name="1689034"> </a>See Also 
</h4>

<p><a name="1689458"> </a><a href="UI_Window.html#1699863"><code>WinGetScalingMode()</code></a></p>

<h3 class="hbH3">
  <a name="1428400"> </a>UnderlineModeType Enum <a href="#1160850"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="1428402"> </a>Purpose 
</h4>

<p><a name="1428403"> </a>Specifies possible values for the underline mode stored in the drawing state. </p>
<h4>
  <a name="1428404"> </a>Declared In 
</h4>
<code>CmnDrawingTypes.h<a name="1428405"> </a></code><h4>
  <a name="1428406"> </a>Constants 
</h4>

<dl>
<dt><a name="1428407"> </a><code>noUnderline </code></dt>
<dd><a name="1428408"> </a>No underline. </dd>

<dt><a name="1428409"> </a><code>grayUnderline </code></dt>
<dd><a name="1428410"> </a>A dotted line in the current foreground color. </dd>

<dt><a name="1428411"> </a><code>solidUnderline </code></dt>
<dd><a name="1428412"> </a>A solid line in the foreground color. </dd>

<dt><a name="1428413"> </a><code>colorUnderline </code></dt>
<dd><a name="1428414"> </a>A solid line in the foreground color. </dd>

<dt><a name="1645274"> </a><code>thinUnderline </code></dt>
<dd><a name="1645291"> </a>A thin single-pixel solid line in the foreground color. </dd>

</dl>

<h3 class="hbH3">
  <a name="1658585"> </a>WinDirectionType Typedef <a href="#1160850"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="1658675"> </a>Purpose 
</h4>

<p><a name="1658702"> </a>Specifies a scrolling direction. </p>
<h4>
  <a name="1658715"> </a>Declared In 
</h4>
<code>Window.h<a name="1658738"> </a></code><h4>
  <a name="1658743"> </a>Prototype 
</h4>
<pre class="proto"><a name="1658758"></a>typedef Enum8 WinDirectionType;
</pre>
<h4>
  <a name="1658763"> </a>Constants 
</h4>

<dl>
<dt><a name="1658774"> </a><code>winUp = 0</code></dt>
<dd><a name="1658775"> </a>Scroll up. </dd>

<dt><a name="1658776"> </a><code>winDown</code></dt>
<dd><a name="1658827"> </a>Scroll down. </dd>

<dt><a name="1658860"> </a><code>winLeft</code></dt>
<dd><a name="1658861"> </a>Scroll left.</dd>

<dt><a name="1658862"> </a><code>winRight</code></dt>
<dd><a name="1658882"> </a>Scroll right. </dd>

</dl>
<h4>
  <a name="1658883"> </a>See Also 
</h4>

<p><a name="1658902"> </a><a href="UI_Window.html#1536290"><code>WinScrollRectangle()</code></a>, <a href="UI_Field.html#997889"><code>FldScrollable()</code></a>, <a href="UI_Field.html#997935"><code>FldScrollField()</code></a>, <a href="UI_List.html#995134"><code>LstScrollList()</code></a></p>

<h3 class="hbH3">
  <a name="1094199"> </a>WinDrawOperation Enum <a href="#1160850"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="1094209"> </a>Purpose 
</h4>

<p><a name="1094240"> </a>Specifies the transfer mode for color drawing. </p>
<h4>
  <a name="1094385"> </a>Declared In 
</h4>
<code>CmnDrawingTypes.h<a name="1095116"> </a></code><h4>
  <a name="1095261"> </a>Constants 
</h4>

<dl>
<dt><a name="1096128"> </a><code>winPaint</code></dt>
<dd><a name="1096846"> </a>Write color-matched source pixels to the destination. If a bitmap's <code>bmpFlagsHasTransparency</code> flag is set, <code>winPaint</code> behaves like <code>winOverlay</code> instead.</dd>

<dt><a name="1355988"> </a><code>winErase</code></dt>
<dd><a name="1355989"> </a>Write using the background color if the source pixel is transparent.</dd>

<dt><a name="1355990"> </a><code>winMask</code></dt>
<dd><a name="1355991"> </a>Write using the background color if the source pixel is not transparent.</dd>

<dt><a name="1096131"> </a><code>winInvert</code></dt>
<dd><a name="1096906"> </a>Bitwise XOR the color-matched source pixel onto the destination. This mode does not honor the transparent color in any way. </dd>

<dt><a name="1096132"> </a><code>winOverlay</code></dt>
<dd><a name="1096990"> </a>Write color-matched source pixel to the destination if the source pixel is not transparent. Transparent pixels are skipped. For a 1-bit display, the "off" bits are considered to be the transparent color. </dd>

<dt><a name="1096133"> </a><code>winPaintInverse</code></dt>
<dd><a name="1097179"> </a>Invert the source pixel color and then proceed as with <code>winPaint</code>. </dd>

<dt><a name="1096134"> </a><code>winSwap</code></dt>
<dd><a name="1097204"> </a>Swap the background color and foreground color destination colors if the source is a pattern (the type of pattern is disregarded). If the source is a bitmap, then the bitmap is transferred using <code>winPaint</code> mode instead. </dd>

</dl>
<h4>
  <a name="1097263"> </a>Comments 
</h4>

<p><a name="1097279"> </a>Note that 2-bit, 4-bit, and 8-bit source bitmaps that don't have a color table inherit the system default color table for their given depth. 1-bit sources (bitmap, text, and patterns) that don't have a color table are given a color table where entry 0 is the background color and entry 1 is the foreground color (text color for text).</p>

<p><a name="1097291"> </a><code>winSwap</code> is not a color invert operation, although a pair of <code>winSwap</code> operations will restore the original graphics data. This mode is used by the OS to select and deselect areas of the screen. It changes destination pixels matching the foreground color to the background color, and changes destination pixels matching the background color to the foreground color. It is a mode available for rectangles, lines, and pixels, but not text or bitmaps. This mode ignores the current pattern.</p>

<h4 class="hcH4">
  <a name="1097294"> </a>The Transparent Color
</h4>

<p><a name="1097295"> </a>Bitmaps have a <code>bmpFlagsHasTransparency</code> flag and may designate a transparent color:</p>
<ul type="disc">
  <li><a name="1097296"> </a>Bitmaps that don't specify any transparent color (text, patterns, and version 0 bitmaps) are assumed to have a transparent color of index 0 and the <code>bmpFlagsHasTransparency</code> bit is assumed to be <code>false</code>.
  <li><a name="1097297"> </a>When the <code>bmpFlagsHasTransparency</code> flag is set and the transfer mode is <code>winPaint</code>, only the non-transparent pixels are copied to the destination. With text and patterns, Palm OS<sup>&#174;</sup> assumes that the "off" bits are the ones designated as transparent and acts as if the <code>bmpFlagsHasTransparency</code> flag is always <code>false</code>. This assumption retains backwards compatibility and unifies the use of transparency across all source data.
</ul>
<h4>
  <a name="1604568"> </a>Compatibility 
</h4>

<p><a name="1604570"> </a><code>winInvert</code>, <code>winErase</code>, <code>winMask</code>, <code>winPaintInverse</code>, and <code>winSwap</code> are deprecated in Palm OS Cobalt. <code>winInvert</code> and <code>winSwap</code> do not work when drawing text, drawing unfilled rectangles, or drawing to update-based windows. When you try to use them in these instances, nothing is drawn to the screen. </p>
<h4>
  <a name="1098086"> </a>See Also 
</h4>

<p><a name="1098597"> </a><a href="UI_Window.html#1021540"><code>WinCopyRectangle()</code></a>, <a href="UI_Window.html#1002952"><code>WinSetDrawMode()</code></a></p>

<h3 class="hbH3">
  <a name="994040"> </a>WinFlagsType Enum <a href="#1160850"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="994043"> </a>Purpose 
</h4>

<p><a name="994046"> </a>Specifies how the window looks and behaves. These flags are passed as arguments to <a href="UI_Window.html#1480817"><code>WinCreateWindowWithConstraints()</code></a> when creating a window. </p>
<h4>
  <a name="994048"> </a>Declared In 
</h4>
<code>Window.h<a name="994051"> </a></code><h4>
  <a name="994053"> </a>Constants 
</h4>

<dl>
<dt><a name="994056"> </a><code>winFlagModal = 0x00000001</code></dt>
<dd><a name="1093546"> </a>The window is modal. When a modal window is the topmost window, it receives the pen down events and keystrokes for the window that it obscures, even when it is not the same size as that window. </dd>

<dt><a name="994060"> </a><code>winFlagNonFocusable = 0x00000002</code></dt>
<dd><a name="1289922"> </a>The window cannot become the active window.</dd>

<dt><a name="994064"> </a><code>winFlagBackBuffer = 0x00000004</code></dt>
<dd><a name="1093540"> </a>The window is back-buffered. A back-buffered window draws into a memory region. The system does not update the screen until the application returns to its event loop or it calls <a href="UI_Window.html#1486624"><code>WinFlush()</code></a>. Legacy windows and transitional windows are back-buffered. </dd>

<dt><a name="1709970"> </a><code>winFlagVisibilityEvents = 0x00000008</code></dt>
<dd><a name="1709971"> </a>The window receives the <a href="UI_Window.html#1711570"><code>winVisibilityChangedEvent</code></a> when anything obscures the window or when a previously obscured window is revealed. </dd>

<dt><a name="1290105"> </a><code>winLayerMask = 0x000000f0</code></dt>
<dd><a name="1093532"> </a>A mask value defining all of the layer constants. </dd>

<dt><a name="994072"> </a><code>winLayerNormal = 0x00000000</code></dt>
<dd><a name="1093519"> </a>Used for application windows. </dd>

<dt><a name="994080"> </a><code>winLayerPriority = 0x00000010</code></dt>
<dd><a name="1093498"> </a>Used for system dialogs. </dd>

<dt><a name="1706674"> </a><code>winLayerSlip = 0x00000040</code></dt>
<dd><a name="1706675"> </a>Used for the slip windows created by the status bar. </dd>

<dt><a name="1688655"> </a><code>winLayerSecurity = 0x00000050</code></dt>
<dd><a name="1688656"> </a>Used for password dialogs and other security-related dialogs. </dd>

<dt><a name="994084"> </a><code>winLayerSystem = 0x00000020</code></dt>
<dd><a name="1093477"> </a>Used for the dynamic input area, the status bar, and catastrophic system messages such as the low battery alert dialog </dd>

<dt><a name="994088"> </a><code>winLayerMenu = 0x00000030</code></dt>
<dd><a name="1093460"> </a>Used for menus. </dd>

</dl>
<h4>
  <a name="1093571"> </a>See Also 
</h4>

<p><a name="1093572"> </a><a href="UI_Window.html#1517987"><code>WinGetWindowFlags()</code></a></p>

<h3 class="hbH3">
  <a name="1430421"> </a>WindowFormatType Enum <a href="#1160850"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="1430423"> </a>Purpose 
</h4>

<p><a name="1430424"> </a>Specifies the window format when creating an off-screen window with the <a href="UI_Window.html#1480700"><code>WinCreateOffscreenWindow()</code></a> function. </p>
<h4>
  <a name="1430428"> </a>Declared In 
</h4>
<code>Window.h <a name="1430429"> </a></code><h4>
  <a name="1430430"> </a>Constants 
</h4>

<dl>
<dt><a name="1430431"> </a><code>screenFormat = 0</code></dt>
<dd><a name="1430432"> </a>The window's bitmap is allocated using the hardware screen's depth, but for backward compatibility the bitmap associated with the off-screen window is always low density, and the window always uses a coordinate system that directly maps off-screen pixels to coordinates.</dd>

<dt><a name="1430433"> </a><code>genericFormat</code></dt>
<dd><a name="1430434"> </a>Like <code>screenFormat</code>.</dd>

<dt><a name="1430435"> </a><code>nativeFormat</code></dt>
<dd><a name="1430436"> </a>Reflects the actual hardware screen format in all ways, including screen depth, density, and pixel format. Applications must always use the APIs when drawing to a <code>nativeFormat</code> off-screen window: directly accessing off-screen pixels will produce undefined results. When using this format, the width and height arguments must be specified using the active coordinate system. </dd>

</dl>

<h3 class="hbH3">
  <a name="1134992"> </a>Miscellaneous Constants <a href="#1160850"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="1134993"> </a>Purpose 
</h4>

<p><a name="1134994"> </a>Other Window Manager constants. </p>
<h4>
  <a name="1134995"> </a>Declared In 
</h4>
<code>Window.h <a name="1134996"> </a></code><h4>
  <a name="1134997"> </a>Constants 
</h4>

<dl>
<dt><a name="1134998"> </a><code>#define DrawStateStackSize 7</code></dt>
<dd><a name="1134999"> </a>The maximum size of the draw state stack that is grown with <a href="UI_Window.html#1000758"><code>WinPushDrawState()</code></a> and shrunk with <a href="UI_Window.html#1144225"><code>WinPopDrawState()</code></a>. </dd>

<dt><a name="1135000"> </a><code>#define invalidWindowHandle 0</code></dt>
<dd><a name="1135001"> </a>Specifies an invalid window handle. </dd>

<dt><a name="1135002"> </a><code>#define kWinVersion 10</code></dt>
<dd><a name="1135003"> </a>The current version of the Window Manager. The feature constant <code>sysFtrNumWinVersion</code> is set to this value. </dd>

</dl>

<h2 class="haH2">
  <a name="1659213"> </a>Window Events <a href="#1160850"><span class="nav">^TOP^</span></a>
</h2>


<h3 class="hbH3">
  <a name="1746226"> </a>sysClearUIEvent <a href="#1160850"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="1746274"> </a>Purpose 
</h4>

<p><a name="1746288"> </a>Sent to all threads outside of the application's main UI thread to indicate that the application is about to be exited. This event allows background threads to close dialogs or remove any other user interface that they display. </p>
<h4>
  <a name="1746296"> </a>Declared In 
</h4>
<code>Event.h<a name="1746310"> </a></code><h4>
  <a name="1746316"> </a>Prototype 
</h4>

<p><a name="1746327"> </a>None. </p>
<h4>
  <a name="1746455"> </a>Comments 
</h4>

<p><a name="1747055"> </a><code>SysHandleEvent()</code> handles the <code>sysClearUIEvent</code> for you by transforming it into an <code>appStopEvent</code> in any threads that are displaying a user interface but are not the main UI thread. </p>

<p><a name="1747265"> </a>Most applications do not need to respond to this event. You only should do so if your application displays a dialog from a background thread and you don't want that dialog erased with the rest of the application's user interface. In that case, you should intercept the <code>sysClearUIEvent</code> before the call <code>SysHandleEvent()</code> and ignore it. </p>

<h3 class="hbH3">
  <a name="1659238"> </a>winEnterEvent <a href="#1160850"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="1659239"> </a>Purpose 
</h4>

<p><a name="1358142"> </a>Sent when a window becomes the active window. This can happen in two ways: a call to <a href="UI_Window.html#1536351"><code>WinSetActiveWindow()</code></a> is issued (<a href="UI_Form.html#1002714"><code>FrmSetActiveForm()</code></a> does this), or the user taps within the bounds of a window (such as a menu window) that is visible but not active. </p>

<p><a name="1677320"> </a>For this event, the <a href="../Programming_Basics/Event.html#992950"><code>EventType</code></a> <code>data</code> field contains the structure shown in the Prototype section, below. </p>
<h4>
  <a name="1677321"> </a>Declared In 
</h4>
<code>Event.h<a name="1677322"> </a></code><h4>
  <a name="1358565"> </a>Prototype 
</h4>
<pre class="proto"><a name="1358583"></a>struct _WinEnterEventType {
   WinHandle enterWindow;
   WinHandle exitWindow;
}
</pre>
<h4>
  <a name="1358550"> </a>Fields 
</h4>

<dl>
<dt><a name="1359021"> </a><code>enterWindow</code></dt>
<dd><a name="1359070"> </a>The handle to the window being entered. This may be the window for a form, a menu, or some other type of window. </dd>

<dt><a name="1359175"> </a><code>exitWindow</code></dt>
<dd><a name="1359220"> </a>The handle to the window being exited if there is currently an active window, or 0 if there is no active window. </dd>

</dl>
<h4>
  <a name="1360099"> </a>Comments 
</h4>

<p><a name="1659049"> </a><code>winEnterEvent</code> and <a href="UI_Window.html#1659056"><code>winExitEvent</code></a> are only sent for windows created using the UI Library. If the user taps the status bar, for example, the application receives only the <a href="UI_Window.html#1357484"><code>winFocusLostEvent</code></a>, not the <code>winExitEvent</code>. </p>

<p><a name="1659430"> </a><code>winEnterEvent</code> and <code>winExitEvent</code> are typically received when the active window within a thread changes. For example, when the user displays the menu, the application receives a <code>winExitEvent</code> for the current form's window and a <code>winEnterEvent</code> for the menu's window. When the menu is dismissed, the application receives the <code>winExitEvent</code> for the menu's window followed by the <code>winEnterEvent</code> for the form's window. </p>

<h3 class="hbH3">
  <a name="1659056"> </a>winExitEvent <a href="#1160850"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="1360325"> </a>Purpose 
</h4>

<p><a name="1366327"> </a>Sent when a window is deactivated. A window is deactivated when another window becomes the active window. </p>

<p><a name="1677335"> </a>For this event, the <a href="../Programming_Basics/Event.html#992950"><code>EventType</code></a> <code>data</code> field contains the structure shown in the Prototype section, below. </p>
<h4>
  <a name="1677336"> </a>Declared In 
</h4>
<code>Event.h<a name="1677337"> </a></code><h4>
  <a name="1367184"> </a>Prototype 
</h4>
<pre class="proto"><a name="1367402"></a>struct _WinExitEventType {
   WinHandle enterWindow;
   WinHandle exitWindow;
}
</pre>
<h4>
  <a name="1367683"> </a>Fields 
</h4>

<dl>
<dt><a name="1367746"> </a><code>enterWindow</code></dt>
<dd><a name="1368007"> </a>The handle to the window being entered. This may be the window for a form, a menu, or some other type of window. </dd>

<dt><a name="1368004"> </a><code>exitWindow</code></dt>
<dd><a name="1558061"> </a>The handle to the window being exited.</dd>

</dl>
<h4>
  <a name="1659731"> </a>Comments 
</h4>

<p><a name="1659740"> </a>The <code>winExitEvent</code>, like all events, is sent to the active form's event handler. Because <code>winExitEvent</code> is often posted to the event queue as a result of a <a href="UI_Form.html#1002714"><code>FrmSetActiveForm()</code></a> call, it is sent to the event handler for the form that has just been made active, not to the event handler for the form whose window is being exited. </p>
<h4>
  <a name="1659414"> </a>See Also 
</h4>

<p><a name="1659418"> </a><a href="UI_Window.html#1659238"><code>winEnterEvent</code></a></p>

<h3 class="hbH3">
  <a name="1356631"> </a>winFocusGainedEvent <a href="#1160850"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="1368621"> </a>Purpose 
</h4>

<p><a name="1368622"> </a>Sent when a new window gains the input focus. </p>

<p><a name="1677379"> </a>For this event, the <a href="../Programming_Basics/Event.html#992950"><code>EventType</code></a> <code>data</code> field contains the structure shown in the Prototype section, below. </p>
<h4>
  <a name="1677380"> </a>Declared In 
</h4>
<code>Event.h<a name="1677381"> </a></code><h4>
  <a name="1368624"> </a>Prototype 
</h4>
<pre class="proto"><a name="1369381"></a>struct _WinFocusGainedEventType {
   WinHandle window;
   uint32_t flags;
}
</pre>
<h4>
  <a name="1368625"> </a>Fields 
</h4>

<dl>
<dt><a name="1369454"> </a><code>window</code></dt>
<dd><a name="1369467"> </a>The handle to the window that's gained the focus. </dd>

<dt><a name="1369480"> </a><code>flags</code></dt>
<dd><a name="1369489"> </a>Currently unused. </dd>

</dl>
<h4>
  <a name="1372791"> </a>Comments 
</h4>

<p><a name="1659761"> </a>The input focus determines which thread is sent <code>keyDownEvent</code>s. This event is sent to the event handler for the window that will now receive <code>keyDownEvent</code>s. For example, if the user is currently working in a slip window and then taps in your application's form, the form's window receives the input focus. The form's event handler receives the <code>winFocusGainedEvent</code>. </p>

<p><a name="1660614"> </a>This event is only sent regarding focusable windows. Menus, pop-up lists, and the input area all use nonfocusable windows. Entering and exiting these windows do not generate <code>winFocusGainedEvent</code> or <code>winFocusLostEvent</code>. </p>

<p><a name="1377965"> </a><a href="UI_Form.html#1000647"><code>FrmHandleEvent()</code></a> responds to this event by assigning the focus to a field within that form if necessary. That is, if a text field or table previously had the input focus when the form lost focus, it is assigned the input focus when the form regains focus. </p>

<p><a name="1662972"> </a>Applications typically do not respond to this event. Games might want to do so to resume activity after receiving the input focus. </p>

<h3 class="hbH3">
  <a name="1357484"> </a>winFocusLostEvent <a href="#1160850"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="1368593"> </a>Purpose 
</h4>

<p><a name="1378715"> </a>Sent when a new window gains input focus. </p>

<p><a name="1677407"> </a>For this event, the <a href="../Programming_Basics/Event.html#992950"><code>EventType</code></a> <code>data</code> field contains the structure shown in the Prototype section, below. </p>
<h4>
  <a name="1677408"> </a>Declared In 
</h4>
<code>Event.h<a name="1677409"> </a></code><h4>
  <a name="1368596"> </a>Prototype 
</h4>
<pre class="proto"><a name="1369571"></a>struct _WinFocusLostEventType {
   WinHandle window;
   uint32_t flags;
};
</pre>
<h4>
  <a name="1368597"> </a>Fields 
</h4>

<dl>
<dt><a name="1369630"> </a><code>window</code></dt>
<dd><a name="1369869"> </a>The handle to the window that's lost the focus. </dd>

<dt><a name="1369870"> </a><code>flags</code></dt>
<dd><a name="1369924"> </a>Currently unused. </dd>

</dl>
<h4>
  <a name="1378762"> </a>Comments 
</h4>

<p><a name="1378764"> </a>This event is sent to the event handler for the window that currently has the input focus and is about to lose it. For example, if a form within your application currently has input focus and the user taps the status bar, your form's event handler receives the <code>winFocusLostEvent</code>. </p>

<p><a name="1661166"> </a>Note the difference between this event and the <code>winExitEvent</code>. If your application has the input focus and the user switches to another form in the same application: </p>
<ul type="disc">
  <li><a name="1661169"> </a>The first form receives <code>winFocusLostEvent</code>. 
  <li><a name="1661235"> </a>The second form receives a <code>winExitEvent</code> about the first form's window. 
  <li><a name="1661236"> </a>The second form receives a <code>winEnterEvent</code> about its own window.
  <li><a name="1661239"> </a>If the second form is granted input focus, it receives the <code>winFocusGainedEvent</code> as well. It is not guaranteed to receive this event because another window in a different thread might request the input focus at the same time. 
</ul>

<p><a name="1662958"> </a>This event is only sent regarding focusable windows. Menus, pop-up lists, and the input area all use nonfocusable windows. Entering and exiting these windows do not generate <code>winFocusGainedEvent</code> or <code>winFocusLostEvent</code>. </p>

<p><a name="1661035"> </a><a href="UI_Form.html#1000647"><code>FrmHandleEvent()</code></a> responds to this event by releasing any focus assigned to a field within the form that's losing focus. </p>

<p><a name="1662974"> </a>Applications typically do not respond to this event. Games might want to do so to suspend activity upon losing the input focus. </p>
<h4>
  <a name="1436555"> </a>See Also 
</h4>

<p><a name="1436661"> </a><a href="UI_Window.html#1536351"><code>WinSetActiveWindow()</code></a></p>

<h3 class="hbH3">
  <a name="1357625"> </a>winResizedEvent <a href="#1160850"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="1368434"> </a>Purpose 
</h4>

<p><a name="1368435"> </a>Sent when a window's size or position changes. </p>

<p><a name="1677418"> </a>For this event, the <a href="../Programming_Basics/Event.html#992950"><code>EventType</code></a> <code>data</code> field contains the structure shown in the Prototype section, below. </p>
<h4>
  <a name="1677419"> </a>Declared In 
</h4>
<code>Event.h<a name="1677420"> </a></code><h4>
  <a name="1368437"> </a>Prototype 
</h4>
<pre class="proto"><a name="1370625"></a>struct _WinResizedEventType {
   WinHandle window;
   RectangleType newBounds;
};
</pre>
<h4>
  <a name="1368438"> </a>Fields 
</h4>

<dl>
<dt><a name="1370808"> </a><code>window</code></dt>
<dd><a name="1370830"> </a>The handle to the window that needs to be resized. </dd>

<dt><a name="1370841"> </a><code>newBounds</code></dt>
<dd><a name="1370850"> </a>A rectangle specifying the new bounds for the window. See <a href="UI_Rectangle.html#994219"><code>RectangleType</code></a>.</dd>

</dl>
<h4>
  <a name="1599139"> </a>Comments 
</h4>

<p><a name="1599144"> </a>Applications should respond to this event by rearranging the controls in the form as necessary. You can set up the form so that this is handled for you. Call <a href="UI_Form.html#1081506"><code>FrmInitLayout()</code></a> when the form is loaded and specify what should happen for each element in the form when the form is resized (whether that element should move or it should resize). After you make this call, <a href="UI_Form.html#1000647"><code>FrmHandleEvent()</code></a> calls <a href="UI_Form.html#1081958"><code>FrmPerformLayout()</code></a> in response to the <code>winResizedEvent</code>. <code>FrmPerformLayout()</code> uses the resizing rules you specify to rearrange the elements in the form. </p>

<p><a name="1622836"> </a>If you need more control over the layout of one or more elements on the form, handle <code>winResizedEvent</code>. Call <code>FrmPerformLayout()</code> and then tweak the positions or sizes of the elements you need to control. Optionally, you can handle all elements in the form yourself. </p>

<p><a name="1622718"> </a>Do not draw the controls until you receive a <a href="UI_Form.html#1089359"><code>frmUpdateEvent</code></a>. </p>

<p><a name="1599487"> </a><code>winResizedEvent</code> is not sent for legacy windows; legacy windows do not resize.</p>

<h3 class="hbH3">
  <a name="1357696"> </a>winUpdateEvent <a href="#1160850"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="1368382"> </a>Purpose 
</h4>

<p><a name="1368383"> </a>Sent when all or a portion of a window needs to be redrawn. This includes when the window is first created, when it is resized, and as a result of the functions <a href="UI_Window.html#1522335"><code>WinInvalidateRect()</code></a> or <a href="UI_Window.html#1522408"><code>WinInvalidateWindow()</code></a>. </p>

<p><a name="1677471"> </a>For this event, the <a href="../Programming_Basics/Event.html#992950"><code>EventType</code></a> <code>data</code> field contains the structure shown in the Prototype section, below. </p>
<h4>
  <a name="1677472"> </a>Declared In 
</h4>
<code>Event.h<a name="1677473"> </a></code><h4>
  <a name="1368385"> </a>Prototype 
</h4>
<pre class="proto"><a name="1369930"></a>struct _WinUpdateEventType {
   WinHandle window;
   RectangleType dirtyRect;
   void *prv;
};
</pre>
<h4>
  <a name="1368386"> </a>Fields 
</h4>

<dl>
<dt><a name="1369993"> </a><code>window</code></dt>
<dd><a name="1370003"> </a>The handle to the window that needs to be redrawn. </dd>

<dt><a name="1370008"> </a><code>dirtyRect</code></dt>
<dd><a name="1370103"> </a>The portion of the window that needs to be redrawn. See <a href="UI_Rectangle.html#994219"><code>RectangleType</code></a>.</dd>

<dt><a name="1462866"> </a><code>prv</code></dt>
<dd><a name="1462867"> </a>System use only. </dd>

</dl>
<h4>
  <a name="1462868"> </a>Comments 
</h4>

<p><a name="1551366"> </a>This event is sent for any type of window other than legacy windows. A window may either represent a form, a menu, or a pinlet. </p>

<p><a name="1599599"> </a><code>winUpdateEvent</code> is a signal that the rendering system has created a graphics context for the window and is ready for the application to draw to the window. </p>

<p><a name="1552006"> </a>When the window represents a form, no action is required for this event. If it is not handled, the system posts a <a href="UI_Form.html#1089359"><code>frmUpdateEvent</code></a>. <a href="UI_Form.html#1000647"><code>FrmHandleEvent()</code></a> responds to the <a href="UI_Form.html#1089359"><code>frmUpdateEvent</code></a> by calling <a href="UI_Form.html#997203"><code>FrmDrawForm()</code></a> and then applications can perform any custom drawing. </p>

<p><a name="1552219"> </a>The system handles updating the windows for menus and other user interface items, so no action is typically required from an application if <code class="par">window</code> represents a menu. </p>

<div><hr>
  <a name="1599641"> </a> <b>IMPORTANT: </b> Never post a <code>winUpdateEvent</code> or a <a href="UI_Form.html#1089359"><code>frmUpdateEvent</code></a> explicitly. Instead, use one of the functions <a href="UI_Window.html#1522335"><code>WinInvalidateRect()</code></a>, <a href="UI_Window.html#1522368"><code>WinInvalidateRectFunc()</code></a>, or <a href="UI_Window.html#1522408"><code>WinInvalidateWindow()</code></a>.
<hr>
</div>

<h3 class="hbH3">
  <a name="1711570"> </a>winVisibilityChangedEvent <a href="#1160850"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="1711635"> </a>Purpose 
</h4>

<p><a name="1711652"> </a>Sent to specially marked windows when another window obscures a portion of it. </p>

<p><a name="1721038"> </a>For this event, the <a href="../Programming_Basics/Event.html#992950"><code>EventType</code></a> <code>data</code> field contains the structure shown in the Prototype section, below. </p>
<h4>
  <a name="1711666"> </a>Declared In 
</h4>
<code>Event.h<a name="1711668"> </a></code><h4>
  <a name="1712743"> </a>Prototype 
</h4>
<pre class="proto"><a name="1719798"></a>struct winVisibilityChanged {
   WinHandle window;
   uint32_t visibility;
} winVisibilityChanged;
</pre>
<h4>
  <a name="1712744"> </a>Fields 
</h4>

<dl>
<dt><a name="1721327"> </a><code>window</code></dt>
<dd><a name="1721365"> </a>The handle to the window that has been obscured. </dd>

<dt><a name="1721398"> </a><code>visibility</code></dt>
<dd><a name="1721423"> </a>One of the following:</dd>

<dl>
<dt><a name="1721448"> </a><code>windowFullyHidden</code></dt>
<dd><a name="1721449"> </a>The window is completely obscured. </dd>

<dt><a name="1721487"> </a><code>windowPartiallyVisible</code></dt>
<dd><a name="1721500"> </a>A portion of the window is visible. </dd>

<dt><a name="1721509"> </a><code>windowFullyVisible</code></dt>
<dd><a name="1721518"> </a>The window is completely visible. </dd>

</dl>
</dl>
<h4>
  <a name="1721527"> </a>Comments 
</h4>

<p><a name="1721570"> </a>Only windows that have the <span style="color: #000000;  font-family: Courier; font-style: normal; font-weight: normal; text-decoration: none; text-transform: none; vertical-align: baseline">winFlagVisibilityEvents</span> flag set in the constraints resource receive this event. You should only set the flag on windows that display time-sensitive information that can become meaningless if obscured. For example, games may want to set the flag for their windows so that they can delay the game if the user launches a slip window or if any other window obscures the game. </p>

<p><a name="1721753"> </a>Most applications should not care if another window obscures the application's windows. When the window is redrawn, drawing is always clipped to the visible region. </p>

<h2 class="haH2">
  <a name="1712746"> </a>Window Manager Notifications <a href="#1160850"><span class="nav">^TOP^</span></a>
</h2>


<h3 class="hbH3">
  <a name="1643915"> </a>sysNotifyDisplayChangeEvent <a href="#1160850"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="1643975"> </a>Purpose 
</h4>

<p><a name="1644015"> </a>Broadcast whenever the display mode changes. That is, either the color table has been set to use a specific palette using the <a href="UI_Window.html#1530544"><code>WinPalette()</code></a> function or the bit depth has changed using the <a href="UI_Window.html#1536068"><code>WinScreenMode()</code></a> function. </p>
<h4>
  <a name="1644203"> </a>Declared In 
</h4>
<code>NotifyMgr.h<a name="1644233"> </a></code><h4>
  <a name="1644263"> </a>Parameters 
</h4>

<p><a name="1644285"> </a><code>notifyDetailsP</code> points to a <a href="../Programming_Basics/NotifyMgr.html#994737"><code>SysNotifyDisplayChangeDetailsType</code></a> structure</p>
<h4>
  <a name="1644421"> </a>Comments 
</h4>

<p><a name="1644542"> </a>The <code>notifyDetailsP</code> parameter indicates how the bit depth changed. If the two values in the struct are equal, it means that the color palette has changed instead of the bit depth. </p>
<h4>
  <a name="1657126"> </a>See Also 
</h4>

<p><a name="1657133"> </a><a href="../Programming_Basics/NotifyMgr.html#992934">"Notification Manager"</a> in <i>Exploring Palm OS: Programming Basics</i></p>

<h2 class="haH2">
  <a name="1643881"> </a>Window Management Functions and Macros <a href="#1160850"><span class="nav">^TOP^</span></a>
</h2>


<p><a name="1474108"> </a>This section lists and describes the Window Manager functions that involve the creation, deletion, and manipulation of windows as abstract regions. </p>

<h3 class="hbH3">
  <a name="1021473"> </a>ECWinValidateHandle Macro <a href="#1160850"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="1021475"> </a>Purpose 
</h4>

<p><a name="1021476"> </a>Calls <a href="UI_Window.html#1604893"><code>WinValidateHandle()</code></a>. </p>
<h4>
  <a name="1021477"> </a>Declared In 
</h4>
<code>Window.h <a name="1021478"> </a></code><h4>
  <a name="1021479"> </a>Prototype 
</h4>
<pre class="proto"><a name="1021480"></a>#define ECWinValidateHandle (
   winHandle
)
</pre>
<h4>
  <a name="1021481"> </a>Parameters 
</h4>

<dl>
<dt><a name="1021482"> </a><code>&rarr;  <i>winHandle</i></code></dt>
<dd><a name="1021483"> </a>The <a href="UI_Window.html#1414441"><code>WinHandle</code></a> to validate. </dd>

</dl>
<h4>
  <a name="1021484"> </a>Returns 
</h4>

<p><a name="1355811"> </a>Nothing.</p>
<h4>
  <a name="1355819"> </a>Comments 
</h4>

<p><a name="1643868"> </a>On debug ROMs, displays a fatal error message if the window handle is invalid. On release ROMs, this macro has no effect. </p>

<p><a name="1643874"> </a>Do not use this macro in production code. It is for debugging purposes only. </p>

<h3 class="hbH3">
  <a name="1710064"> </a>WinConvertCoord Function <a href="#1160850"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="1710066"> </a>Purpose 
</h4>

<p><a name="1710067"> </a>Converts a coordinate from one screen density to another. </p>
<h4>
  <a name="1710068"> </a>Declared In 
</h4>
<code>Window.h<a name="1710069"> </a></code><h4>
  <a name="1710070"> </a>Prototype 
</h4>
<pre class="proto"><a name="1710071"></a>Coord WinConvertCoord (
   uint16_t <code class="par">currentDensity</code>,
   uint16_t <code class="par">newDensity</code>,
   Coord <code class="par">coord</code>,
   Boolean <code class="par">ceiling</code>
)
</pre>
<h4>
  <a name="1710072"> </a>Parameters 
</h4>

<dl>
<dt><a name="1710073"> </a><code>&rarr;  <i>currentDensity</i></code></dt>
<dd><a name="1710074"> </a>The current density for the specified coordinate. </dd>

<dt><a name="1710075"> </a><code>&rarr;  <i>newDensity</i></code></dt>
<dd><a name="1710076"> </a>The density to which to scale the coordinate. </dd>

<dt><a name="1710077"> </a><code>&rarr;  <i>coord</i></code></dt>
<dd><a name="1710078"> </a>Coordinate in the <code class="par">currentDensity</code>. </dd>

<dt><a name="1721911"> </a><code>&rarr;  <i>ceiling</i></code></dt>
<dd><a name="1721912"> </a><code>true</code> to round up or <code>false</code> to round down. </dd>

</dl>
<h4>
  <a name="1721913"> </a>Returns 
</h4>

<p><a name="1710082"> </a>Coordinate in <code class="par">newDensity</code> that provides the same location as <code class="par">coord</code>. </p>
<h4>
  <a name="1768285"> </a>Comments 
</h4>

<p><a name="1768290"> </a>This function converts a coordinate by multiplying it by the coordinate scaling factor, which is computed from the current and new densities. What happens next depends upon the value of <code class="par">ceiling</code>:</p>

<p><a name="1768291"> </a>if <code class="par">ceiling</code> == true {</p>

<p><a name="1768292"> </a>   use <code>lfloorf()</code> function when scaleFactor &gt; 1</p>

<p><a name="1768293"> </a>   use <code>lceilf()</code> function when scaleFactor &lt; 1</p>

<p><a name="1768294"> </a>else</p>

<p><a name="1768295"> </a>   use <code>lceilf()</code> function when scaleFactor &gt; 1</p>

<p><a name="1768296"> </a>   use <code>lfloorf()</code> function when scaleFactor &lt; 1</p>

<p><a name="1768297"> </a>}</p>

<p><a name="1768298"> </a>The objective of this algorithm is to ensure that for any <code>Coord</code>, <code>Point</code>, or <code>Rectangle</code> "x", x = unscaled(scaled(x)). </p>
<h4>
  <a name="1722552"> </a>See Also 
</h4>

<p><a name="1722690"> </a><a href="UI_Window.html#1535889"><code>WinScaleCoord()</code></a>, <a href="UI_Window.html#1663801"><code>WinScaleCoordNativeToActive()</code></a>, <a href="UI_Window.html#1535987"><code>WinScreenGetAttribute()</code></a></p>

<h3 class="hbH3">
  <a name="1710088"> </a>WinConvertPoint Function <a href="#1160850"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="1710090"> </a>Purpose 
</h4>

<p><a name="1710091"> </a>Converts a point from one screen density to another. </p>
<h4>
  <a name="1710092"> </a>Declared In 
</h4>
<code>Window.h<a name="1710093"> </a></code><h4>
  <a name="1710094"> </a>Prototype 
</h4>
<pre class="proto"><a name="1710095"></a>void WinConvertPoint (
   uint16_t <code class="par">currentDensity</code>,
   uint16_t <code class="par">newDensity</code>,
   PointType <code class="par">*pointP</code>,
   Boolean <code class="par">ceiling</code>
)
</pre>
<h4>
  <a name="1710096"> </a>Parameters 
</h4>

<dl>
<dt><a name="1710097"> </a><code>&rarr;  <i>currentDensity</i></code></dt>
<dd><a name="1721981"> </a>The current density for the specified point. </dd>

<dt><a name="1710099"> </a><code>&rarr;  <i>newDensity</i></code></dt>
<dd><a name="1722015"> </a>The density to which to scale the point. </dd>

<dt><a name="1710101"> </a><code>&harr;  <i>pointP</i></code></dt>
<dd><a name="1710102"> </a>A point in the <code class="par">currentDensity</code>. Upon return, a point in <code class="par">newDensity</code> that represents the same location. </dd>

<dt><a name="1710103"> </a><code>&rarr;  <i>ceiling</i></code></dt>
<dd><a name="1722041"> </a><code>true</code> to round up or <code>false</code> to round down. </dd>

</dl>
<h4>
  <a name="1710105"> </a>Returns 
</h4>

<p><a name="1710106"> </a>Nothing. </p>
<h4>
  <a name="1769429"> </a>Comments 
</h4>

<p><a name="1768610"> </a>This function converts a point by multiplying its x and y coordinates by the coordinate scaling factor., which is computed from the current and new densities What happens next depends upon the value of <code class="par">ceiling</code>:</p>

<p><a name="1768611"> </a>if <code class="par">ceiling</code> == true {</p>

<p><a name="1768612"> </a>   use <code>lfloorf()</code> function when scaleFactor &gt; 1</p>

<p><a name="1768613"> </a>   use <code>lceilf()</code> function when scaleFactor &lt; 1</p>

<p><a name="1768614"> </a>else</p>

<p><a name="1768615"> </a>   use <code>lceilf()</code> function when scaleFactor &gt; 1</p>

<p><a name="1768616"> </a>   use <code>lfloorf()</code> function when scaleFactor &lt; 1</p>

<p><a name="1768617"> </a>}</p>

<p><a name="1768618"> </a>The objective of this algorithm is to ensure that for any <code>Coord</code>, <code>Point</code>, or <code>Rectangle</code> "x", x = unscaled(scaled(x)). </p>
<h4>
  <a name="1723212"> </a>See Also 
</h4>

<p><a name="1723747"> </a><a href="UI_Window.html#1535921"><code>WinScalePoint()</code></a>, <a href="UI_Window.html#1535987"><code>WinScreenGetAttribute()</code></a></p>

<h3 class="hbH3">
  <a name="1710112"> </a>WinConvertRectangle Function <a href="#1160850"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="1710114"> </a>Purpose 
</h4>

<p><a name="1722517"> </a>Converts a rectangle from one screen density to another. </p>
<h4>
  <a name="1710116"> </a>Declared In 
</h4>
<code>Window.h<a name="1710117"> </a></code><h4>
  <a name="1710118"> </a>Prototype 
</h4>
<pre class="proto"><a name="1710119"></a>void WinConvertRectangle (
   uint16_t <code class="par">currentDensity</code>,
   uint16_t <code class="par">newDensity</code>,
   RectangleType <code class="par">*rectP</code>
)
</pre>
<h4>
  <a name="1710120"> </a>Parameters 
</h4>

<dl>
<dt><a name="1710121"> </a><code>&rarr;  <i>currentDensity</i></code></dt>
<dd><a name="1722523"> </a>The current density for the specified rectangle. </dd>

<dt><a name="1710123"> </a><code>&rarr;  <i>newDensity</i></code></dt>
<dd><a name="1722529"> </a>The density to which to scale the rectangle. </dd>

<dt><a name="1710125"> </a><code>&harr;  <i>rectP</i></code></dt>
<dd><a name="1710126"> </a>A rectangle in the <code class="par">currentDensity</code>. Upon return, the same rectangle with the same location and dimensions but given in <code class="par">newDensity</code>. </dd>

</dl>
<h4>
  <a name="1710127"> </a>Returns 
</h4>

<p><a name="1710128"> </a>Nothing. </p>
<h4>
  <a name="1710131"> </a>See Also 
</h4>

<p><a name="1710132"> </a><a href="UI_Window.html#1535955"><code>WinScaleRectangle()</code></a>, <a href="UI_Window.html#1535987"><code>WinScreenGetAttribute()</code></a></p>

<h3 class="hbH3">
  <a name="1480636"> </a>WinCreateBitmapWindow Function <a href="#1160850"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="1480638"> </a>Purpose 
</h4>

<p><a name="1480639"> </a>Creates a new off-screen window. </p>
<h4>
  <a name="1480640"> </a>Declared In 
</h4>
<code>Window.h <a name="1480641"> </a></code><h4>
  <a name="1480642"> </a>Prototype 
</h4>
<pre class="proto"><a name="1480643"></a>WinHandle WinCreateBitmapWindow (
   BitmapType *<code class="par">bitmapP</code>,
   status_t *<code class="par">error</code>
)
</pre>
<h4>
  <a name="1480644"> </a>Parameters 
</h4>

<dl>
<dt><a name="1480645"> </a><code>&rarr;  <i>bitmapP</i></code></dt>
<dd><a name="1480646"> </a>A pointer to a bitmap to associate with the window. (See <a href="UI_Bitmap.html#1003681"><code>BitmapType</code></a>.)</dd>

<dt><a name="1480650"> </a><code>&larr;  <i>error</i></code></dt>
<dd><a name="1480651"> </a>A pointer to any error this function encounters.</dd>

</dl>
<h4>
  <a name="1480652"> </a>Returns 
</h4>

<p><a name="1480653"> </a>The handle of the new window upon success, or <code>NULL</code> if an error occurs. The <code class="par">error</code> parameter contains one of the following:</p>

<dl>
<dt><a name="1480654"> </a><code>errNone</code></dt>
<dd><a name="1480655"> </a>No error.</dd>

<dt><a name="1480656"> </a><code>sysErrParamErr</code></dt>
<dd><a name="1480657"> </a>The <code class="par">bitmapP</code> parameter is invalid. The bitmap must be uncompressed and it must have a valid pixel size (1, 2, 4, 8, or 16). It must not be the screen bitmap. </dd>

<dt><a name="1480658"> </a><code>sysErrNoFreeResource</code></dt>
<dd><a name="1480659"> </a>There is not enough memory to allocate a new window structure. </dd>

</dl>
<h4>
  <a name="1480660"> </a>Comments 
</h4>

<p><a name="1480661"> </a>Use <code>WinCreateBitmapWindow()</code> if you want to draw into a previously created bitmap, such as a bitmap created using <a href="UI_Bitmap.html#998464"><code>BmpCreate()</code></a>. </p>

<p><a name="1480665"> </a>This function generates a window wrapper for the specified bitmap. The newly created window is off-screen and uses the generic format (for device independence). Use <a href="UI_Window.html#1542343"><code>WinSetDrawWindow()</code></a> to make it the draw window, and then use the window drawing functions to modify the bitmap. </p>

<p><a name="1480669"> </a>When you use this function to create a window and then delete the window with <a href="UI_Window.html#1480894"><code>WinDeleteWindow()</code></a>, the bitmap is <b>not</b> freed when the window is freed. </p>

<p><a name="1577147"> </a><a href="UI_Window.html#1480700"><code>WinCreateOffscreenWindow()</code></a> uses this function to create its off-screen window. If you call <code>WinCreateOffscreenWindow()</code> instead of using this function, the bitmap is freed when <code>WinDeleteWindow()</code> is called.</p>
<h4>
  <a name="1480686"> </a>Compatibility 
</h4>

<p><a name="1480687"> </a>This function exists for compatibility purposes only. Use <a href="UI_GraphicContext.html#994782"><code>GcCreateBitmapContext()</code></a> instead. </p>
<h4>
  <a name="1480691"> </a>See Also 
</h4>

<p><a name="1480698"> </a><a href="UI_Window.html#1480763"><code>WinCreateWindow()</code></a>, <a href="UI_Window.html#1480700"><code>WinCreateOffscreenWindow()</code></a></p>

<h3 class="hbH3">
  <a name="1480700"> </a>WinCreateOffscreenWindow Function <a href="#1160850"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="1480702"> </a>Purpose 
</h4>

<p><a name="1480704"> </a>Creates a new off-screen window. </p>
<h4>
  <a name="1480705"> </a>Declared In 
</h4>
<code>Window.h <a name="1480706"> </a></code><h4>
  <a name="1480707"> </a>Prototype 
</h4>
<pre class="proto"><a name="1480708"></a>WinHandle WinCreateOffscreenWindow (
   Coord <code class="par">width</code>,
   Coord <code class="par">height</code>,
   WindowFormatType <code class="par">format</code>,
   status_t *<code class="par">error</code>
)
</pre>
<h4>
  <a name="1480709"> </a>Parameters 
</h4>

<dl>
<dt><a name="1480710"> </a><code>&rarr;  <i>width</i></code></dt>
<dd><a name="1480711"> </a>The width of the window in pixels. The coordinate system you use for this parameter depends upon the value of <code class="par">format</code>.</dd>

<dt><a name="1480712"> </a><code>&rarr;  <i>height</i></code></dt>
<dd><a name="1480713"> </a>The height of the window in pixels. The coordinate system you use for this parameter depends upon the value of <code class="par">format</code>.</dd>

<dt><a name="1480714"> </a><code>&rarr;  <i>format</i></code></dt>
<dd><a name="1480718"> </a>One of the window formats defined by <a href="UI_Window.html#1430421"><code>WindowFormatType</code></a>.</dd>

<dt><a name="1480719"> </a><code>&larr;  <i>error</i></code></dt>
<dd><a name="1480720"> </a>A pointer to any error this function encounters.</dd>

</dl>
<h4>
  <a name="1480721"> </a>Returns 
</h4>

<p><a name="1480722"> </a>The handle of the new window upon success, or <code>NULL</code> if an error occurs. The <code class="par">error</code> parameter contains one of the following:</p>

<dl>
<dt><a name="1480723"> </a><code>errNone</code></dt>
<dd><a name="1480724"> </a>No error.</dd>

<dt><a name="1480725"> </a><code>sysErrParamErr</code></dt>
<dd><a name="1480726"> </a>The <code class="par">width</code> or <code class="par">height</code> parameter is <code>NULL</code> or the current color table is invalid. </dd>

<dt><a name="1480727"> </a><code>sysErrNoFreeResource</code></dt>
<dd><a name="1480728"> </a>There is not enough memory to complete the function.</dd>

</dl>
<h4>
  <a name="1480730"> </a>Comments 
</h4>

<p><a name="1480731"> </a>Windows created with this routine draw to a memory buffer instead of the display. Use this function for temporary drawing operations such as double-buffering or save-behind operations. </p>

<p><a name="1480732"> </a>The memory buffer has two formats: screen format and generic format. Screen format is the native format of the video system; windows in this format can be copied to the display faster. The generic format is device-independent. </p>

<p><a name="1480736"> </a>This function differs from <a href="UI_Window.html#1480636"><code>WinCreateBitmapWindow()</code></a> in the following ways: </p>
<ul type="disc">
  <li><a name="1480737"> </a><code>WinCreateOffscreenWindow()</code> creates a new bitmap in the same depth as the current screen. <code>WinCreateBitmapWindow()</code> uses the bitmap you pass in, which may or may not be in the same depth as the current screen. 
  <li><a name="1480739"> </a><code>WinCreateOffscreenWindow()</code> uses the screen format you specify. <code>WinCreateBitmapWindow()</code> always uses <code>genericFormat</code> for the format argument.
  <li><a name="1480741"> </a>When you delete the window created with <code>WinCreateOffscreenWindow()</code>, its bitmap is freed along with the window. The bitmap used in the <code>WinCreateBitmapWindow()</code> is not freed when the window is freed.
</ul>

<p><a name="1480743"> </a>Note that if you aren't directly accessing the bits of an off-screen window's bitmap but are just using the APIs, you can always pass <code>nativeFormat</code> for the screen format and things will work as expected. If you need direct access to the bits of the off-screen window's bitmap, however, call <a href="UI_Bitmap.html#998464"><code>BmpCreate()</code></a> and then call <code>WinCreateBitmapWindow()</code>. Because you created the bitmap, you know its format and thus can safely manipulate its bits. Calling <code>WinCreateOffscreenWindow()</code> with a <code class="par">format</code> argument of <code>nativeFormat</code> can result in a bitmap with an unexpected format: the endianness, number of bits per pixel, and so on would match the screen and therefore be fastest to draw, but your application wouldn't be able to manipulate the pixels directly.</p>

<p><a name="1480750"> </a>The bitmap data will not be blitted properly if the depth of the screen is changed using <a href="UI_Window.html#1536068"><code>WinScreenMode()</code></a> and the new window uses a bitmap that does not define the bitmap's color table. See <a href="UI_Window.html#1536068"><code>WinScreenMode()</code></a> for information on how to work around this limitation.</p>
<h4>
  <a name="1480757"> </a>See Also 
</h4>

<p><a name="1480761"> </a><a href="UI_Window.html#1480763"><code>WinCreateWindow()</code></a> </p>

<h3 class="hbH3">
  <a name="1480763"> </a>WinCreateWindow Function <a href="#1160850"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="1480765"> </a>Purpose 
</h4>

<p><a name="1480766"> </a>Creates a new legacy-mode window.</p>
<h4>
  <a name="1480767"> </a>Declared In 
</h4>
<code>Window.h <a name="1480768"> </a></code><h4>
  <a name="1480769"> </a>Prototype 
</h4>
<pre class="proto"><a name="1480770"></a>WinHandle WinCreateWindow (
   const RectangleType *<code class="par">bounds</code>,
   FrameType <code class="par">frame</code>,
   Boolean <code class="par">modal</code>,
   Boolean <code class="par">focusable</code>,
   status_t *<code class="par">error</code>
)
</pre>
<h4>
  <a name="1480771"> </a>Parameters 
</h4>

<dl>
<dt><a name="1480772"> </a><code>&rarr;  <i>bounds</i></code></dt>
<dd><a name="1480773"> </a>The display-relative bounds of the window. See <a href="UI_Rectangle.html#994219"><code>RectangleType</code></a>.</dd>

<dt><a name="1480774"> </a><code>&rarr;  <i>frame</i></code></dt>
<dd><a name="1480778"> </a>The type of frame around the window (see <a href="UI_Window.html#1610364"><code>FrameType</code></a>).</dd>

<dt><a name="1480779"> </a><code>&rarr;  <i>modal</i></code></dt>
<dd><a name="1480781"> </a><code>true</code> if the window is modal.</dd>

<dt><a name="1480782"> </a><code>&rarr;  <i>focusable</i></code></dt>
<dd><a name="1480784"> </a><code>true</code> if the window can be the active window.</dd>

<dt><a name="1480785"> </a><code>&larr;  <i>error</i></code></dt>
<dd><a name="1480786"> </a>A pointer to any error encountered by this function.</dd>

</dl>
<h4>
  <a name="1480787"> </a>Returns 
</h4>

<p><a name="1480788"> </a>The handle of the new window upon success, or <code>NULL</code> if an error occurs. The <code class="par">error</code> parameter contains one of the following:</p>

<dl>
<dt><a name="1480789"> </a><code>errNone</code></dt>
<dd><a name="1480790"> </a>No error.</dd>

<dt><a name="1480791"> </a><code>sysErrNoFreeResource</code></dt>
<dd><a name="1480792"> </a>There is not enough memory to complete the operation.</dd>

</dl>
<h4>
  <a name="1480793"> </a>Comments 
</h4>

<p><a name="1480803"> </a>The window created with this function is a legacy-mode window, meaning that it does not receive events such as <a href="UI_Window.html#1357696"><code>winUpdateEvent</code></a> or <a href="UI_Window.html#1357625"><code>winResizedEvent</code></a>. </p>

<p><a name="1480810"> </a>You can only call this function within the main UI thread. </p>
<h4>
  <a name="1480811"> </a>See Also 
</h4>

<p><a name="1480815"> </a><a href="UI_Window.html#1480894"><code>WinDeleteWindow()</code></a>, <a href="UI_Window.html#1480817"><code>WinCreateWindowWithConstraints()</code></a></p>

<h3 class="hbH3">
  <a name="1480817"> </a>WinCreateWindowWithConstraints Function <a href="#1160850"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="1480819"> </a>Purpose 
</h4>

<p><a name="1480820"> </a>Creates a new update-based or transitional window with the specified size constraints.</p>
<h4>
  <a name="1480821"> </a>Declared In 
</h4>
<code>Window.h <a name="1480822"> </a></code><h4>
  <a name="1480823"> </a>Prototype 
</h4>
<pre class="proto"><a name="1480824"></a>WinHandle WinCreateWindowWithConstraints (
   FrameType <code class="par">frame</code>,
   WinFlagsType <code class="par">flags</code>,
   const WinConstraintsType *<code class="par">constraints</code>,
   status_t *<code class="par">error</code>
)
</pre>
<h4>
  <a name="1480825"> </a>Parameters 
</h4>

<dl>
<dt><a name="1480826"> </a><code>&rarr;  <i>frame</i></code></dt>
<dd><a name="1480830"> </a>The type of frame around the window (see <a href="UI_Window.html#1610364"><code>FrameType</code></a>).</dd>

<dt><a name="1480831"> </a><code>&rarr;  <i>flags</i></code></dt>
<dd><a name="1480835"> </a>Window creation flags (see <a href="UI_Window.html#994040"><code>WinFlagsType</code></a>).</dd>

<dt><a name="1480836"> </a><code>&rarr;  <i>constraints</i></code></dt>
<dd><a name="1480840"> </a>The size constraints (see <a href="UI_Window.html#1617194"><code>WinConstraintsType</code></a>). </dd>

<dt><a name="1480841"> </a><code>&larr;  <i>error</i></code></dt>
<dd><a name="1480842"> </a>A pointer to any error encountered by this function.</dd>

</dl>
<h4>
  <a name="1480843"> </a>Returns 
</h4>

<p><a name="1480844"> </a>The handle of the new window upon success, or <code>NULL</code> if an error occurs. The <code class="par">error</code> parameter contains one of the following:</p>

<dl>
<dt><a name="1480845"> </a><code>errNone</code></dt>
<dd><a name="1480846"> </a>No error.</dd>

<dt><a name="1480847"> </a><code>sysErrNoFreeResource</code></dt>
<dd><a name="1480848"> </a>There is not enough memory to complete the operation.</dd>

</dl>
<h4>
  <a name="1480849"> </a>Comments 
</h4>

<p><a name="1480850"> </a>Windows created by this routine draw to the display. See <a href="UI_Window.html#1480700"><code>WinCreateOffscreenWindow()</code></a> for information on drawing off screen.</p>

<p><a name="1480854"> </a>You typically don't call this function directly. Instead, you use <a href="UI_Form.html#1001135"><code>FrmInitForm()</code></a> to create form windows from a resource. Forms are much more flexible and have better system support. All forms are windows, but not all windows are forms. </p>

<p><a name="1480858"> </a>The window is created with the size constraints and frame type that you specify. See <a href="UI_Window.html#1617194"><code>WinConstraintsType</code></a> for an explanation of how to set the size constraints. </p>

<p><a name="1480862"> </a>Newly created windows are disabled and invisible. You must specifically enable the window before the window can accept input. You can do so with <a href="UI_Window.html#1536351"><code>WinSetActiveWindow()</code></a>. </p>

<p><a name="1480867"> </a>In Palm OS Cobalt, there are three types of windows that may be created: </p>
<ul type="disc">
  <li><a name="1480868"> </a><b>Legacy windows</b>. These windows are created by <a href="UI_Window.html#1480763"><code>WinCreateWindow()</code></a> or they are created if you don't specify a <code>WINDOW_CONSTRAINTS_RESOURCE</code> for a form. You can draw to a legacy window whenever you want, not just in an update event. Legacy windows do not receive the new events (such as <a href="UI_Window.html#1357696"><code>winUpdateEvent</code></a> or <a href="UI_Window.html#1357625"><code>winResizedEvent</code></a>). 
  <li><a name="1480878"> </a><b>Update-based windows</b>. These windows are created by calling <span style="color: #000000;  font-family: Courier; font-style: normal; font-weight: normal; text-decoration: none; text-transform: none; vertical-align: baseline">WinCreateWindowWithConstraints</span><code>()</code> or by adding a <code>WINDOW_CONSTRAINTS_RESOURCE</code> to a form. Drawing to an update-based window is asynchronous and should only be performed when the system requests you to do so (by posting a <a href="UI_Window.html#1357696"><code>winUpdateEvent</code></a>).
  <li><a name="1637960"> </a><b>Transitional windows</b>. These windows are created by calling <code>WinCreateWindowWithConstraints()</code> and specifying <code>winFlagBackBuffer</code> in the <code class="par">flags</code> parameter or by adding to a form a <code>WINDOW_CONSTRAINTS_RESOURCE</code> with the <code>winFlagBackBuffer</code> bit set. You must wait for an initial <code>winResizedEvent</code> before you draw to a transitional window. After the initial event, you can draw to a transitional window any time you like.
</ul>

<p><a name="1480889"> </a>Use this function instead of calling <a href="UI_Window.html#1480763"><code>WinCreateWindow()</code></a> followed by <a href="UI_Window.html#1677658"><code>WinSetConstraints()</code></a> because it avoids the intermediate state of the window. </p>

<h3 class="hbH3">
  <a name="1480894"> </a>WinDeleteWindow Function <a href="#1160850"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="1480896"> </a>Purpose 
</h4>

<p><a name="1480897"> </a>Destroys the record for the window. The <code>WinHandle</code> is no longer valid after calling this function. </p>
<h4>
  <a name="1480898"> </a>Declared In 
</h4>
<code>Window.h <a name="1480899"> </a></code><h4>
  <a name="1480900"> </a>Prototype 
</h4>
<pre class="proto"><a name="1480901"></a>void WinDeleteWindow (
   WinHandle <code class="par">winHandle</code>,
   Boolean <code class="par">eraseIt</code>
)
</pre>
<h4>
  <a name="1480902"> </a>Parameters 
</h4>

<dl>
<dt><a name="1480903"> </a><code>&rarr;  <i>winHandle</i></code></dt>
<dd><a name="1480904"> </a>The handle of the window to delete.</dd>

<dt><a name="1480905"> </a><code>&rarr;  <i>eraseIt</i></code></dt>
<dd><a name="1480906"> </a>If <code>true</code>, the window is erased before it is deleted. If <code>false</code>, the window is not erased. </dd>

</dl>
<h4>
  <a name="1480907"> </a>Returns 
</h4>

<p><a name="1480908"> </a>Nothing.</p>
<h4>
  <a name="1593030"> </a>Comments 
</h4>

<p><a name="1593031"> </a>This function frees all memory associated with the window that was allocated by the system. Windows created using <a href="UI_Window.html#1480700"><code>WinCreateOffscreenWindow()</code></a> have their bitmaps freed; windows created using <a href="UI_Window.html#1480763"><code>WinCreateWindow()</code></a> or <a href="UI_Window.html#1480636"><code>WinCreateBitmapWindow()</code></a> do not. </p>

<p><a name="1480920"> </a>The <code class="par">eraseIt</code> parameter affects on-screen transitional or legacy windows only; off-screen windows are never erased. As a performance optimization, you might set <code class="par">eraseIt</code> to <code>false</code> for an on-screen window if you know that you are going to immediately redraw the area anyway. </p>

<h3 class="hbH3">
  <a name="1480922"> </a>WinDisplayToWindowPt Function <a href="#1160850"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="1480924"> </a>Purpose 
</h4>

<p><a name="1480926"> </a>Converts a screen-relative coordinate to a window-relative coordinate. The coordinate returned is relative to the display window.</p>
<h4>
  <a name="1480927"> </a>Declared In 
</h4>
<code>Window.h <a name="1480928"> </a></code><h4>
  <a name="1480929"> </a>Prototype 
</h4>
<pre class="proto"><a name="1480930"></a>void WinDisplayToWindowPt (
   Coord *<code class="par">x</code>,
   Coord *<code class="par">y</code>
)
</pre>
<h4>
  <a name="1480931"> </a>Parameters 
</h4>

<dl>
<dt><a name="1480932"> </a><code>&harr;  <i>x</i></code></dt>
<dd><a name="1480933"> </a>A pointer to x coordinate to convert.</dd>

<dt><a name="1480934"> </a><code>&harr;  <i>y</i></code></dt>
<dd><a name="1480935"> </a>A pointer to y coordinate to convert.</dd>

</dl>
<h4>
  <a name="1480936"> </a>Returns 
</h4>

<p><a name="1480937"> </a>Nothing.</p>
<h4>
  <a name="1480938"> </a>See Also 
</h4>

<p><a name="1480942"> </a><a href="UI_Window.html#1543519"><code>WinWindowToDisplayPt()</code></a></p>

<h3 class="hbH3">
  <a name="1617340"> </a>WinFinishThreadUI Function <a href="#1160850"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="1617342"> </a>Purpose 
</h4>

<p><a name="1617343"> </a>Delete the user interface context for a thread. </p>
<h4>
  <a name="1617344"> </a>Declared In 
</h4>
<code>Window.h<a name="1617345"> </a></code><h4>
  <a name="1617346"> </a>Prototype 
</h4>
<pre class="proto"><a name="1617347"></a>status_t WinFinishThreadUI (
   void
)
</pre>
<h4>
  <a name="1617348"> </a>Parameters 
</h4>

<p><a name="1617349"> </a>None.</p>
<h4>
  <a name="1617350"> </a>Returns 
</h4>

<p><a name="1617351"> </a>Always returns <code>errNone</code>. </p>
<h4>
  <a name="1617352"> </a>Comments 
</h4>

<p><a name="1617353"> </a>This function decrements the reference count for the UI context in this thread. If the reference count becomes zero, it then deletes the reference context and all windows that have been created in the thread. </p>
<h4>
  <a name="1617354"> </a>See Also 
</h4>

<p><a name="1617355"> </a><a href="UI_Window.html#1617695"><code>WinStartThreadUI()</code></a></p>

<h3 class="hbH3">
  <a name="1486624"> </a>WinFlush Function <a href="#1160850"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="1486626"> </a>Purpose 
</h4>

<p><a name="1486627"> </a>Refreshes the screen for transitional windows. </p>
<h4>
  <a name="1486628"> </a>Declared In 
</h4>
<code>Window.h <a name="1486629"> </a></code><h4>
  <a name="1486630"> </a>Prototype 
</h4>
<pre class="proto"><a name="1486631"></a>void WinFlush (
   void
)
</pre>
<h4>
  <a name="1486632"> </a>Parameters 
</h4>

<p><a name="1486633"> </a>None.</p>
<h4>
  <a name="1486634"> </a>Returns 
</h4>

<p><a name="1486635"> </a>Nothing. </p>

<h3 class="hbH3">
  <a name="1486637"> </a>WinGetActiveWindow Function <a href="#1160850"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="1486639"> </a>Purpose 
</h4>

<p><a name="1486640"> </a>Returns the window handle of the active window.</p>
<h4>
  <a name="1486641"> </a>Declared In 
</h4>
<code>Window.h <a name="1486642"> </a></code><h4>
  <a name="1486643"> </a>Prototype 
</h4>
<pre class="proto"><a name="1486644"></a>WinHandle WinGetActiveWindow (
   void
)
</pre>
<h4>
  <a name="1486645"> </a>Parameters 
</h4>

<p><a name="1486646"> </a>None.</p>
<h4>
  <a name="1486647"> </a>Returns 
</h4>

<p><a name="1486648"> </a>The handle of the active window. All user input is directed to the active window. </p>
<h4>
  <a name="1486649"> </a>See Also 
</h4>

<p><a name="1486656"> </a><a href="UI_Window.html#1536351"><code>WinSetActiveWindow()</code></a>, <a href="UI_Window.html#1497116"><code>WinGetDisplayWindow()</code></a>, <a href="UI_Window.html#1497142"><code>WinGetDrawWindow()</code></a> </p>

<h3 class="hbH3">
  <a name="1486665"> </a>WinGetBitmap Function <a href="#1160850"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="1486667"> </a>Purpose 
</h4>

<p><a name="1486668"> </a>Returns a pointer to a window's bitmap, which holds the window contents. </p>
<h4>
  <a name="1486669"> </a>Declared In 
</h4>
<code>Window.h <a name="1486670"> </a></code><h4>
  <a name="1486671"> </a>Prototype 
</h4>
<pre class="proto"><a name="1486672"></a>BitmapType *WinGetBitmap (
   WinHandle <code class="par">winHandle</code>
)
</pre>
<h4>
  <a name="1486673"> </a>Parameters 
</h4>

<dl>
<dt><a name="1486674"> </a><code>&rarr;  <i>winHandle</i></code></dt>
<dd><a name="1486675"> </a>The handle of window from which to get the bitmap.</dd>

</dl>
<h4>
  <a name="1486676"> </a>Returns 
</h4>

<p><a name="1486677"> </a>A pointer to the bitmap or <code>NULL</code> if <code class="par">winHandle</code> is invalid.</p>
<h4>
  <a name="1486678"> </a>Comments 
</h4>

<p><a name="1486679"> </a>For on-screen windows, the bitmap returned always represents the whole screen. Thus, the top-left corner of the returned bitmap may not be the top-left corner of the window. </p>
<h4>
  <a name="1578334"> </a>Compatibility 
</h4>

<p><a name="1486680"> </a>For update-based windows, this function works but the returned structure does not contain any bitmap data. If you try to write to or access the bitmap data, your application will crash. It is acceptable to access the other fields of the <a href="UI_Bitmap.html#1003681"><code>BitmapType</code></a>. </p>

<h3 class="hbH3">
  <a name="1486681"> </a>WinGetBitmapDimensions Function <a href="#1160850"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="1486683"> </a>Purpose 
</h4>

<p><a name="1486684"> </a>Returns a bitmap's dimensions using the draw window's active coordinate system. </p>
<h4>
  <a name="1486685"> </a>Declared In 
</h4>
<code>Window.h <a name="1486686"> </a></code><h4>
  <a name="1486687"> </a>Prototype 
</h4>
<pre class="proto"><a name="1486688"></a>void WinGetBitmapDimensions (
   const BitmapType *<code class="par">bmP</code>,
   Coord *<code class="par">widthP</code>,
   Coord *<code class="par">heightP</code>
)
</pre>
<h4>
  <a name="1486689"> </a>Parameters 
</h4>

<dl>
<dt><a name="1486690"> </a><code>&rarr;  <i>bmP</i></code></dt>
<dd><a name="1486691"> </a>A pointer to the bitmap (see <a href="UI_Bitmap.html#1003681"><code>BitmapType</code></a>). </dd>

<dt><a name="1486692"> </a><code>&larr;  <i>widthP</i></code></dt>
<dd><a name="1486693"> </a>The width of the bitmap. </dd>

<dt><a name="1486694"> </a><code>&larr;  <i>heightP</i></code></dt>
<dd><a name="1486695"> </a>The height of the bitmap. </dd>

</dl>
<h4>
  <a name="1486696"> </a>Returns 
</h4>

<p><a name="1486697"> </a>Nothing. </p>
<h4>
  <a name="1486698"> </a>See Also 
</h4>

<p><a name="1486702"> </a><a href="UI_Bitmap.html#995044"><code>BmpGetDimensions()</code></a></p>

<h3 class="hbH3">
  <a name="1486704"> </a>WinGetBounds Function <a href="#1160850"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="1486706"> </a>Purpose 
</h4>

<p><a name="1486707"> </a>Returns the bounds of the current draw window in display-relative coordinates.</p>
<h4>
  <a name="1486708"> </a>Declared In 
</h4>
<code>Window.h <a name="1486709"> </a></code><h4>
  <a name="1486710"> </a>Prototype 
</h4>
<pre class="proto"><a name="1486711"></a>void WinGetBounds (
   WinHandle <code class="par">winH</code>,
   RectangleType *<code class="par">rP</code>
)
</pre>
<h4>
  <a name="1486712"> </a>Parameters 
</h4>

<dl>
<dt><a name="1486713"> </a><code>&rarr;  <i>winH</i></code></dt>
<dd><a name="1486714"> </a>The handle to a window.</dd>

<dt><a name="1486715"> </a><code>&larr;  <i>rP</i></code></dt>
<dd><a name="1486716"> </a>A pointer to a <a href="UI_Rectangle.html#994219"><code>RectangleType</code></a> structure.</dd>

</dl>
<h4>
  <a name="1486717"> </a>Returns 
</h4>

<p><a name="1486718"> </a>Nothing.</p>
<h4>
  <a name="1486719"> </a>Comments 
</h4>

<p><a name="1544162"> </a>This function returns in <code class="par">rP</code> the bounds of the window represented by <code class="par">winH</code>. This corresponds to the convention used by <a href="UI_Window.html#1538337"><code>WinSetBounds()</code></a>, because it takes a window handle as an argument.</p>
<h4>
  <a name="1544166"> </a>Compatibility 
</h4>

<p><a name="1544167"> </a>For update-based or transitional windows, this function returns incorrect results until the <a href="UI_Window.html#1357625"><code>winResizedEvent</code></a> is received. It is acceptable to call this function in response to a <a href="UI_Form.html#1089359"><code>frmUpdateEvent</code></a> or <code>winUpdateEvent</code> because <code>winResizedEvent</code> is sent before <code>winUpdateEvent</code>. </p>
<h4>
  <a name="1486728"> </a>See Also 
</h4>

<p><a name="1486735"> </a><a href="UI_Window.html#1517963"><code>WinGetWindowExtent()</code></a>, <a href="UI_Window.html#1497166"><code>WinGetDrawWindowBounds()</code></a></p>

<h3 class="hbH3">
  <a name="1497100"> </a>WinGetDisplayExtent Function <a href="#1160850"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="1497102"> </a>Purpose 
</h4>

<p><a name="1497103"> </a>Returns the width and height of the application area of the screen.</p>
<h4>
  <a name="1497104"> </a>Declared In 
</h4>
<code>Window.h <a name="1497105"> </a></code><h4>
  <a name="1497106"> </a>Prototype 
</h4>
<pre class="proto"><a name="1497107"></a>void WinGetDisplayExtent (
   Coord *<code class="par">extentX</code>,
   Coord *<code class="par">extentY</code>
)
</pre>
<h4>
  <a name="1497108"> </a>Parameters 
</h4>

<dl>
<dt><a name="1497109"> </a><code>&larr;  <i>extentX</i></code></dt>
<dd><a name="1497110"> </a>A pointer to the width of the display in pixels.</dd>

<dt><a name="1497111"> </a><code>&larr;  <i>extentY</i></code></dt>
<dd><a name="1497112"> </a>A pointer to the height of the display in pixels.</dd>

</dl>
<h4>
  <a name="1497113"> </a>Returns 
</h4>

<p><a name="1497114"> </a>Nothing.</p>
<h4>
  <a name="1593172"> </a>Comments 
</h4>

<p><a name="1593175"> </a>This function returns the dimensions of the portion of the screen that is not used by the dynamic input area or the status bar. To find out the actual screen size, call <a href="UI_Window.html#1535987"><code>WinScreenGetAttribute()</code></a>.</p>

<h3 class="hbH3">
  <a name="1497116"> </a>WinGetDisplayWindow Function <a href="#1160850"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="1497118"> </a>Purpose 
</h4>

<p><a name="1497119"> </a>Returns the window handle of the display (screen) window.</p>
<h4>
  <a name="1497120"> </a>Declared In 
</h4>
<code>Window.h <a name="1497121"> </a></code><h4>
  <a name="1497122"> </a>Prototype 
</h4>
<pre class="proto"><a name="1497123"></a>WinHandle WinGetDisplayWindow (
   void
)
</pre>
<h4>
  <a name="1497124"> </a>Parameters 
</h4>

<p><a name="1497125"> </a>None.</p>
<h4>
  <a name="1497126"> </a>Returns 
</h4>

<p><a name="1497127"> </a>The handle of display window.</p>
<h4>
  <a name="1497128"> </a>Comments 
</h4>

<p><a name="1497129"> </a>The display window is created by the system at start-up; it has the same size as the Palm OS drawable area of the physical display (screen). </p>
<h4>
  <a name="1497130"> </a>See Also 
</h4>

<p><a name="1497137"> </a><a href="UI_Window.html#1497100"><code>WinGetDisplayExtent()</code></a>, <a href="UI_Window.html#1486637"><code>WinGetActiveWindow()</code></a>, <a href="UI_Window.html#1497142"><code>WinGetDrawWindow()</code></a></p>

<h3 class="hbH3">
  <a name="1497142"> </a>WinGetDrawWindow Function <a href="#1160850"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="1497144"> </a>Purpose 
</h4>

<p><a name="1497145"> </a>Returns the window handle of the current draw window.</p>
<h4>
  <a name="1497146"> </a>Declared In 
</h4>
<code>Window.h <a name="1497147"> </a></code><h4>
  <a name="1497148"> </a>Prototype 
</h4>
<pre class="proto"><a name="1497149"></a>WinHandle WinGetDrawWindow (
   void
)
</pre>
<h4>
  <a name="1497150"> </a>Parameters 
</h4>

<p><a name="1497151"> </a>None.</p>
<h4>
  <a name="1497152"> </a>Returns 
</h4>

<p><a name="1497153"> </a>The handle of the draw window.</p>
<h4>
  <a name="1497154"> </a>See Also 
</h4>

<p><a name="1497161"> </a><a href="UI_Window.html#1497116"><code>WinGetDisplayWindow()</code></a>, <a href="UI_Window.html#1486637"><code>WinGetActiveWindow()</code></a>, <a href="UI_Window.html#1542343"><code>WinSetDrawWindow()</code></a></p>

<h3 class="hbH3">
  <a name="1497166"> </a>WinGetDrawWindowBounds Function <a href="#1160850"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="1497168"> </a>Purpose 
</h4>

<p><a name="1497169"> </a>Returns the bounds of the draw window.</p>
<h4>
  <a name="1497170"> </a>Declared In 
</h4>
<code>Window.h <a name="1497171"> </a></code><h4>
  <a name="1497172"> </a>Prototype 
</h4>
<pre class="proto"><a name="1497173"></a>void WinGetDrawWindowBounds (
   RectangleType *<code class="par">rP</code>
)
</pre>
<h4>
  <a name="1497174"> </a>Parameters 
</h4>

<dl>
<dt><a name="1497175"> </a><code>&larr;  <i>rP</i></code></dt>
<dd><a name="1497176"> </a>A pointer to a <a href="UI_Rectangle.html#994219"><code>RectangleType</code></a> structure specifying the window bounds.</dd>

</dl>
<h4>
  <a name="1497177"> </a>Returns 
</h4>

<p><a name="1497178"> </a>Nothing.</p>
<h4>
  <a name="1497179"> </a>Comments 
</h4>

<p><a name="1497183"> </a>This function is equivalent to <a href="UI_Window.html#1486704"><code>WinGetBounds()</code></a>. </p>
<h4>
  <a name="1592445"> </a>Compatibility 
</h4>

<p><a name="1592446"> </a>For update-based or transitional windows, this function returns incorrect results until the <a href="UI_Window.html#1357625"><code>winResizedEvent</code></a> is received. It is acceptable to call this function in response to a <a href="UI_Form.html#1089359"><code>frmUpdateEvent</code></a> or <code>winUpdateEvent</code> because <code>winResizedEvent</code> is sent before <code>winUpdateEvent</code>. </p>

<h3 class="hbH3">
  <a name="1497210"> </a>WinGetFrameType Function <a href="#1160850"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="1497212"> </a>Purpose 
</h4>

<p><a name="1497213"> </a>Gets the frame type for a specified window. </p>
<h4>
  <a name="1497214"> </a>Declared In 
</h4>
<code>Window.h <a name="1497215"> </a></code><h4>
  <a name="1497216"> </a>Prototype 
</h4>
<pre class="proto"><a name="1497217"></a>FrameType WinGetFrameType (
   const WinHandle <code class="par">winH</code>
)
</pre>
<h4>
  <a name="1497218"> </a>Parameters 
</h4>

<dl>
<dt><a name="1497219"> </a><code>&rarr;  <i>winH</i></code></dt>
<dd><a name="1497220"> </a>The window's handle. </dd>

</dl>
<h4>
  <a name="1497221"> </a>Returns 
</h4>

<p><a name="1497225"> </a>A <a href="UI_Window.html#1610364"><code>FrameType</code></a> value indicating the window's frame style.</p>
<h4>
  <a name="1497226"> </a>See Also 
</h4>

<p><a name="1497230"> </a><a href="UI_Window.html#1003398"><code>WinSetFrameType()</code></a></p>

<h3 class="hbH3">
  <a name="1497232"> </a>WinGetFramesRectangle Function <a href="#1160850"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="1497234"> </a>Purpose 
</h4>

<p><a name="1497235"> </a>Returns the rectangle that includes a rectangle together with the specified frame around it.</p>
<h4>
  <a name="1497236"> </a>Declared In 
</h4>
<code>Window.h <a name="1497237"> </a></code><h4>
  <a name="1497238"> </a>Prototype 
</h4>
<pre class="proto"><a name="1497239"></a>void WinGetFramesRectangle (
   FrameType <code class="par">frame</code>,
   const RectangleType *<code class="par">rP</code>,
   RectangleType *<code class="par">obscuredRect</code>
)
</pre>
<h4>
  <a name="1497240"> </a>Parameters 
</h4>

<dl>
<dt><a name="1497241"> </a><code>&rarr;  <i>frame</i></code></dt>
<dd><a name="1497245"> </a>The type of rectangle frame (see <a href="UI_Window.html#1610364"><code>FrameType</code></a>).</dd>

<dt><a name="1497246"> </a><code>&rarr;  <i>rP</i></code></dt>
<dd><a name="1497247"> </a>A pointer to the rectangle to frame (see <a href="UI_Rectangle.html#994219"><code>RectangleType</code></a>). </dd>

<dt><a name="1497248"> </a><code>&larr;  <i>obscuredRect</i></code></dt>
<dd><a name="1497249"> </a>A pointer to the rectangle that includes both the specified rectangle and its frame.</dd>

</dl>
<h4>
  <a name="1497250"> </a>Returns 
</h4>

<p><a name="1497251"> </a>Nothing.</p>
<h4>
  <a name="1497252"> </a>Comments 
</h4>

<p><a name="1497253"> </a>Frames are always drawn around (outside) a rectangle.</p>
<h4>
  <a name="1497254"> </a>See Also 
</h4>

<p><a name="1497261"> </a><a href="UI_Window.html#1518009"><code>WinGetWindowFrameRect()</code></a>, <a href="UI_Window.html#1486704"><code>WinGetBounds()</code></a></p>

<h3 class="hbH3">
  <a name="1526656"> </a>WinGetPixel Function <a href="#1160850"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="1526658"> </a>Purpose 
</h4>

<p><a name="1526659"> </a>Returns the color value of a pixel in the current draw window.</p>
<h4>
  <a name="1526660"> </a>Declared In 
</h4>
<code>Window.h <a name="1526661"> </a></code><h4>
  <a name="1526662"> </a>Prototype 
</h4>
<pre class="proto"><a name="1526663"></a>IndexedColorType WinGetPixel (
   Coord <code class="par">x</code>,
   Coord <code class="par">y</code>
)
</pre>
<h4>
  <a name="1526664"> </a>Parameters 
</h4>

<dl>
<dt><a name="1526665"> </a><code>&rarr;  <i>x</i></code></dt>
<dd><a name="1526666"> </a>A pointer to the x coordinate of a pixel.</dd>

<dt><a name="1526667"> </a><code>&rarr;  <i>y</i></code></dt>
<dd><a name="1526668"> </a>A pointer to the y coordinate of a pixel.</dd>

</dl>
<h4>
  <a name="1526669"> </a>Returns 
</h4>

<p><a name="1526673"> </a>The indexed color value of the pixel. See <a href="UI_Window.html#1407675"><code>IndexedColorType</code></a>. A return value of 0 means that the window is on-screen, that the coordinates do not lie in the current draw window, or that they do and the color of that pixel is index 0 (typically white). </p>
<h4>
  <a name="1526674"> </a>Compatibility 
</h4>

<p><a name="1544245"> </a>This function only works if the active window is off-screen, is a legacy window, or is a transitional window. </p>
<h4>
  <a name="1544246"> </a>See Also 
</h4>

<p><a name="1526680"> </a><a href="UI_Window.html#1522308"><code>WinIndexToRGB()</code></a> </p>

<h3 class="hbH3">
  <a name="1526682"> </a>WinGetPixelRGB Function <a href="#1160850"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="1526684"> </a>Purpose 
</h4>

<p><a name="1526685"> </a>Returns the RGB color values of a pixel in the current draw window.</p>
<h4>
  <a name="1526686"> </a>Declared In 
</h4>
<code>Window.h <a name="1526687"> </a></code><h4>
  <a name="1526688"> </a>Prototype 
</h4>
<pre class="proto"><a name="1526689"></a>status_t WinGetPixelRGB (
   Coord <code class="par">x</code>,
   Coord <code class="par">y</code>,
   RGBColorType *<code class="par">rgpP</code>
)
</pre>
<h4>
  <a name="1526690"> </a>Parameters 
</h4>

<dl>
<dt><a name="1526691"> </a><code>&rarr;  <i>x</i></code></dt>
<dd><a name="1526692"> </a>A pointer to the x coordinate of a pixel.</dd>

<dt><a name="1526693"> </a><code>&rarr;  <i>y</i></code></dt>
<dd><a name="1526694"> </a>A pointer to the y coordinate of a pixel.</dd>

<dt><a name="1526695"> </a><code>&larr;  <i>rgbP</i></code></dt>
<dd><a name="1526696"> </a>The RGB color components of the pixel.</dd>

</dl>
<h4>
  <a name="1526697"> </a>Returns 
</h4>

<p><a name="1526698"> </a>One of the following:</p>

<dl>
<dt><a name="1526699"> </a><code><code>errNone</code> </code></dt>
<dd><a name="1526700"> </a>Success.</dd>

<dt><a name="1526701"> </a><code><code>sysErrParamErr</code></code></dt>
<dd><a name="1526702"> </a>When the draw window is on-screen, when the <code class="par">x</code> or <code class="par">y</code> arguments are &lt; 0, or when they are outside the bounds of the draw window.</dd>

</dl>
<h4>
  <a name="1526703"> </a>Comments 
</h4>

<p><a name="1526704"> </a>This function only works if the draw window is off-screen. </p>

<p><a name="1526705"> </a>The RGB color values of the pixel are returned as an <a href="UI_Bitmap.html#1004052"><code>RGBColorType</code></a>. This function can be used with both indexed or direct color modes. A return value of <code>sysErrParamErr</code> means that the coordinates do not lie within the current draw window.</p>

<h3 class="hbH3">
  <a name="1517915"> </a>WinGetSupportedDensity Function <a href="#1160850"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="1517917"> </a>Purpose 
</h4>

<p><a name="1517918"> </a>Enumerates the various display densities supported by the rendering system.</p>
<h4>
  <a name="1517919"> </a>Declared In 
</h4>
<code>Window.h <a name="1517920"> </a></code><h4>
  <a name="1517921"> </a>Prototype 
</h4>
<pre class="proto"><a name="1517922"></a>status_t WinGetSupportedDensity (
   uint16_t *<code class="par">densityP</code>
)
</pre>
<h4>
  <a name="1517923"> </a>Parameters 
</h4>

<dl>
<dt><a name="1517924"> </a><code>&harr;  <i>densityP</i></code></dt>
<dd><a name="1517925"> </a>A pointer to a supported density value. Set this value to zero before calling this function for the first time. Subsequent calls cause this value to be set to one of the display densities supported by the handheld.</dd>

</dl>
<h4>
  <a name="1517926"> </a>Returns 
</h4>

<p><a name="1517927"> </a>One of the following:</p>

<dl>
<dt><a name="1517928"> </a><code><code>errNone</code> </code></dt>
<dd><a name="1517929"> </a>Success.</dd>

<dt><a name="1517930"> </a><code>sysErrParamErr</code></dt>
<dd><a name="1517931"> </a>The value you supplied in <code>*</code><code class="par">densityP</code> isn't a supported density and isn't zero. </dd>

</dl>
<h4>
  <a name="1517932"> </a>Comments 
</h4>

<p><a name="1517933"> </a>Initialize <code>*</code><code class="par">densityP</code> to zero before your application calls this function for the first time. Repeated calls to <code>WinGetSupportedDensity()</code> will cause the value pointed to by <code class="par">densityP</code> to change; these values represent the supported display densities, in order from low to high density. After the last supported density value, this function sets <code>*</code><code class="par">densityP</code> back to zero.</p>

<div><hr>
  <a name="1517934"> </a> <b>NOTE: </b> The densities reported by this function are those that are supported by the rendering system. These densities are not necessarily supported by the underlying hardware. A device with a low-density screen that is able to scale high-density bitmaps will report that it can handle both high and low density bitmaps. Use <a href="UI_Window.html#1535987"><code>WinScreenGetAttribute()</code></a> to determine the density of the handheld's screen.
<hr>
</div>

<p><a name="1517942"> </a>Density values are defined in <code>CmnBitmapTypes.h</code>; see the <a href="UI_Bitmap.html#1004149"><code>DensityType</code></a> enum. Only those values supported by a given device will be returned by <code>WinGetSupportedDensity()</code>. For example, on a device with a double-density display this function returns <code>kDensityLow</code>, followed by <code>kDensityDouble</code>, followed by 0. For each supported density, the inverse scaling factor is supported. In this example, the rendering system supports pixel-doubling low-density data for a double-density destination, and the rendering system supports pixel-halving high-density data for a low-density destination.</p>

<p><a name="1517945"> </a>The value pointed to by <code class="par">densityP</code> should only be zero or one of the density values supported by the handheld. If it has any other value when you call <code>WinGetSupportedDensity()</code>, this function will simply return <code>sysErrParamErr</code>.</p>

<h3 class="hbH3">
  <a name="1517946"> </a>WinGetWindowBounds Macro <a href="#1160850"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="1517948"> </a>Purpose 
</h4>

<p><a name="1517952"> </a>Calls <a href="UI_Window.html#1497166"><code>WinGetDrawWindowBounds()</code></a>.</p>
<h4>
  <a name="1517953"> </a>Declared In 
</h4>
<code>Window.h <a name="1517954"> </a></code><h4>
  <a name="1517955"> </a>Prototype 
</h4>
<pre class="proto"><a name="1517956"></a>#define WinGetWindowBounds (
   rP
)
</pre>
<h4>
  <a name="1517957"> </a>Parameters 
</h4>

<dl>
<dt><a name="1517958"> </a><code>&larr;  <i>rP</i></code></dt>
<dd><a name="1517959"> </a>A pointer to a <a href="UI_Rectangle.html#994219"><code>RectangleType</code></a> structure specifying the window bounds.</dd>

</dl>
<h4>
  <a name="1517960"> </a>Returns 
</h4>

<p><a name="1517961"> </a>Nothing.</p>

<h3 class="hbH3">
  <a name="1517963"> </a>WinGetWindowExtent Function <a href="#1160850"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="1517965"> </a>Purpose 
</h4>

<p><a name="1517966"> </a>Returns the width and height of the current draw window.</p>
<h4>
  <a name="1517967"> </a>Declared In 
</h4>
<code>Window.h <a name="1517968"> </a></code><h4>
  <a name="1517969"> </a>Prototype 
</h4>
<pre class="proto"><a name="1517970"></a>void WinGetWindowExtent (
   Coord *<code class="par">extentX</code>,
   Coord *<code class="par">extentY</code>
)
</pre>
<h4>
  <a name="1517971"> </a>Parameters 
</h4>

<dl>
<dt><a name="1517972"> </a><code>&larr;  <i>extentX</i></code></dt>
<dd><a name="1517973"> </a>A pointer to the width in pixels of the draw window.</dd>

<dt><a name="1517974"> </a><code>&larr;  <i>extentY</i></code></dt>
<dd><a name="1517975"> </a>A pointer to the height in pixels of the draw window.</dd>

</dl>
<h4>
  <a name="1517976"> </a>Returns 
</h4>

<p><a name="1517977"> </a>Nothing.</p>
<h4>
  <a name="1592474"> </a>Compatibility 
</h4>

<p><a name="1592475"> </a>For update-based or transitional windows, this function returns incorrect results until the <a href="UI_Window.html#1357625"><code>winResizedEvent</code></a> is received. It is acceptable to call this function in response to a <a href="UI_Form.html#1089359"><code>frmUpdateEvent</code></a> or <code>winUpdateEvent</code> because <code>winResizedEvent</code> is sent before <code>winUpdateEvent</code>. </p>
<h4>
  <a name="1517978"> </a>See Also 
</h4>

<p><a name="1517985"> </a><a href="UI_Window.html#1486704"><code>WinGetBounds()</code></a>, <a href="UI_Window.html#1518009"><code>WinGetWindowFrameRect()</code></a></p>

<h3 class="hbH3">
  <a name="1517987"> </a>WinGetWindowFlags Function <a href="#1160850"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="1517989"> </a>Purpose 
</h4>

<p><a name="1517990"> </a>Returns the flags used when the window was created. </p>
<h4>
  <a name="1517991"> </a>Declared In 
</h4>
<code>Window.h <a name="1517992"> </a></code><h4>
  <a name="1517993"> </a>Prototype 
</h4>
<pre class="proto"><a name="1517994"></a>WinFlagsType WinGetWindowFlags (
   WinHandle <code class="par">winHandle</code>
)
</pre>
<h4>
  <a name="1517995"> </a>Parameters 
</h4>

<dl>
<dt><a name="1517996"> </a><code>&rarr;  <i>winHandle</i></code></dt>
<dd><a name="1517997"> </a>The handle to the window. </dd>

</dl>
<h4>
  <a name="1517998"> </a>Returns 
</h4>

<p><a name="1518002"> </a>An integer containing the <a href="UI_Window.html#994040"><code>WinFlagsType</code></a> flags that were set when this window was created. </p>
<h4>
  <a name="1518003"> </a>See Also 
</h4>

<p><a name="1518007"> </a><a href="UI_Window.html#1480817"><code>WinCreateWindowWithConstraints()</code></a></p>

<h3 class="hbH3">
  <a name="1518009"> </a>WinGetWindowFrameRect Function <a href="#1160850"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="1518011"> </a>Purpose 
</h4>

<p><a name="1518012"> </a>Returns a rectangle, in display-relative coordinates, that defines the size and location of a window and its frame.</p>
<h4>
  <a name="1518013"> </a>Declared In 
</h4>
<code>Window.h <a name="1518014"> </a></code><h4>
  <a name="1518015"> </a>Prototype 
</h4>
<pre class="proto"><a name="1518016"></a>void WinGetWindowFrameRect (
   WinHandle <code class="par">winHandle</code>,
   RectangleType *<code class="par">r</code>
)
</pre>
<h4>
  <a name="1518017"> </a>Parameters 
</h4>

<dl>
<dt><a name="1518018"> </a><code>&rarr;  <i>winHandle</i></code></dt>
<dd><a name="1518019"> </a>The handle to the window whose coordinates are desired.</dd>

<dt><a name="1518020"> </a><code>&larr;  <i>r</i></code></dt>
<dd><a name="1518021"> </a>A pointer to the coordinates of the window (see <a href="UI_Rectangle.html#994219"><code>RectangleType</code></a>).</dd>

</dl>
<h4>
  <a name="1518022"> </a>Returns 
</h4>

<p><a name="1518023"> </a>Nothing.</p>
<h4>
  <a name="1592504"> </a>Compatibility 
</h4>

<p><a name="1592505"> </a>For update-based or transitional windows, this function returns incorrect results until the <a href="UI_Window.html#1357625"><code>winResizedEvent</code></a> is received. It is acceptable to call this function in response to a <a href="UI_Form.html#1089359"><code>frmUpdateEvent</code></a> or <code>winUpdateEvent</code> because <code>winResizedEvent</code> is sent before <code>winUpdateEvent</code>. </p>
<h4>
  <a name="1518024"> </a>See Also 
</h4>

<p><a name="1518028"> </a><a href="UI_Window.html#1486704"><code>WinGetBounds()</code></a></p>

<h3 class="hbH3">
  <a name="1522308"> </a>WinIndexToRGB Function <a href="#1160850"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="1522310"> </a>Purpose 
</h4>

<p><a name="1522311"> </a>Converts an index in the currently active color table to an RGB value.</p>
<h4>
  <a name="1522312"> </a>Declared In 
</h4>
<code>Window.h <a name="1522313"> </a></code><h4>
  <a name="1522314"> </a>Prototype 
</h4>
<pre class="proto"><a name="1522315"></a>void WinIndexToRGB (
   IndexedColorType <code class="par">i</code>,
   RGBColorType *<code class="par">rgbP</code>
)
</pre>
<h4>
  <a name="1522316"> </a>Parameters 
</h4>

<dl>
<dt><a name="1522317"> </a><code>&rarr;  <i>i</i></code></dt>
<dd><a name="1522321"> </a>A color index value. See <a href="UI_Window.html#1407675"><code>IndexedColorType</code></a>. </dd>

<dt><a name="1522322"> </a><code>&larr;  <i>rgbP</i></code></dt>
<dd><a name="1522323"> </a>A pointer to an RGB color value corresponding to the index value <code class="par">i</code>. See <a href="UI_Bitmap.html#1004052"><code>RGBColorType</code></a>. </dd>

</dl>
<h4>
  <a name="1522327"> </a>Returns 
</h4>

<p><a name="1522328"> </a>Nothing.</p>
<h4>
  <a name="1522329"> </a>See Also 
</h4>

<p><a name="1522333"> </a><a href="UI_Window.html#1535827"><code>WinRGBToIndex()</code></a></p>

<h3 class="hbH3">
  <a name="1522335"> </a>WinInvalidateRect Function <a href="#1160850"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="1522337"> </a>Purpose 
</h4>

<p><a name="1522338"> </a>Requests an update for a portion of a window. </p>
<h4>
  <a name="1522339"> </a>Declared In 
</h4>
<code>Window.h<a name="1522340"> </a></code><h4>
  <a name="1522341"> </a>Prototype 
</h4>
<pre class="proto"><a name="1522342"></a>void WinInvalidateRect (
   WinHandle <code class="par">window</code>,
   const RectangleType <code class="par">*dirtyRect</code>
)
</pre>
<h4>
  <a name="1522343"> </a>Parameters 
</h4>

<dl>
<dt><a name="1522344"> </a><code>&rarr;  <i>window</i></code></dt>
<dd><a name="1522345"> </a>A handle to an on-screen window. </dd>

<dt><a name="1522346"> </a><code>&rarr;  <i>dirtyRect</i></code></dt>
<dd><a name="1522347"> </a>The bounds given in active coordinates of the area that needs to be redrawn (see <a href="UI_Rectangle.html#994219"><code>RectangleType</code></a>). </dd>

</dl>
<h4>
  <a name="1522348"> </a>Returns 
</h4>

<p><a name="1522349"> </a>Nothing. </p>
<h4>
  <a name="1522350"> </a>Comments 
</h4>

<p><a name="1522355"> </a>This function generates a <a href="UI_Window.html#1357696"><code>winUpdateEvent</code></a>. If the window is update-based, the <code class="par">dirtyRect</code> is added to a pending update queue. All updates in this queue are sent during a single <code>winUpdateEvent</code> the next time through the event loop. </p>

<p><a name="1522357"> </a>If the window is a transitional window, the update event for <code class="par">dirtyRect</code> is enqueued immediately. </p>

<p><a name="1522358"> </a>If the window is off-screen, this function has no effect. </p>
<h4>
  <a name="1522359"> </a>See Also 
</h4>

<p><a name="1522366"> </a><a href="UI_Window.html#1522368"><code>WinInvalidateRectFunc()</code></a>, <a href="UI_Window.html#1522408"><code>WinInvalidateWindow()</code></a></p>

<h3 class="hbH3">
  <a name="1522368"> </a>WinInvalidateRectFunc Function <a href="#1160850"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="1522370"> </a>Purpose 
</h4>

<p><a name="1522371"> </a>Requests an update for a portion of the window, specifying a function that can handle the update if it is feasible. </p>
<h4>
  <a name="1522372"> </a>Declared In 
</h4>
<code>Window.h<a name="1522373"> </a></code><h4>
  <a name="1522374"> </a>Prototype 
</h4>
<pre class="proto"><a name="1522375"></a>void WinInvalidateRectFunc (
   WinHandle <code class="par">window</code>,
   const RectangleType <code class="par">*dirtyRect</code>,
   winInvalidateFunc <code class="par">func</code>,
   void <code class="par">*state</code>
)
</pre>
<h4>
  <a name="1522376"> </a>Parameters 
</h4>

<dl>
<dt><a name="1522377"> </a><code>&rarr;  <i>window</i></code></dt>
<dd><a name="1522378"> </a>A handle to the window. </dd>

<dt><a name="1522379"> </a><code>&rarr;  <i>dirtyRect</i></code></dt>
<dd><a name="1522380"> </a>The bounds given in active coordinates of the area that needs to be redrawn (see <a href="UI_Rectangle.html#994219"><code>RectangleType</code></a>). </dd>

<dt><a name="1522381"> </a><code>&rarr;  <i>func</i></code></dt>
<dd><a name="1522385"> </a>A <a href="UI_Window.html#1004784"><code>winInvalidateFunc()</code></a> callback function. The system calls this function to perform the redraw. </dd>

<dt><a name="1522386"> </a><code>&rarr;  <i>state</i></code></dt>
<dd><a name="1522387"> </a>Any data that needs to be passed to the <code class="par">func</code>. </dd>

</dl>
<h4>
  <a name="1522388"> </a>Returns 
</h4>

<p><a name="1522389"> </a>Nothing. </p>
<h4>
  <a name="1522390"> </a>Comments 
</h4>

<p><a name="1522395"> </a>This function is an optimization on invalidating a window that saves the application from having to wait for a <a href="UI_Form.html#1089359"><code>frmUpdateEvent</code></a> in certain circumstances. The supplied <a href="UI_Window.html#1004784"><code>winInvalidateFunc()</code></a> is called instead of performing an update under the following conditions: </p>
<ul type="disc">
  <li><a name="1607192"> </a>The window is a transitional window. In this case, <a href="UI_Window.html#1004784"><code>winInvalidateFunc()</code></a> is called directly from <code>WinInvalidateRectFunc()</code>. 
  <li><a name="1607217"> </a>If this is the only update in the pending update queue the next time through the event loop, the Window Manager calls <code>winInvalidateFunc()</code> directly instead of generating a <code>winUpdateEvent</code>. 
</ul>

<p><a name="1606628"> </a>If any other portion of the window is dirty for an update-based window, then the <code>winUpdateEvent</code> is generated as usual. </p>
<h4>
  <a name="1522399"> </a>See Also 
</h4>

<p><a name="1522406"> </a><a href="UI_Window.html#1522335"><code>WinInvalidateRect()</code></a>, <a href="UI_Window.html#1522408"><code>WinInvalidateWindow()</code></a></p>

<h3 class="hbH3">
  <a name="1522408"> </a>WinInvalidateWindow Function <a href="#1160850"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="1522410"> </a>Purpose 
</h4>

<p><a name="1522411"> </a>Requests that an entire window be redrawn. </p>
<h4>
  <a name="1522412"> </a>Declared In 
</h4>
<code>Window.h<a name="1522413"> </a></code><h4>
  <a name="1522414"> </a>Prototype 
</h4>
<pre class="proto"><a name="1522415"></a>void WinInvalidateWindow (
   WinHandle <code class="par">window</code>
)
</pre>
<h4>
  <a name="1522416"> </a>Parameters 
</h4>

<dl>
<dt><a name="1522417"> </a><code>&rarr;  <i>window</i></code></dt>
<dd><a name="1522418"> </a>The window to be redrawn. </dd>

</dl>
<h4>
  <a name="1522419"> </a>Returns 
</h4>

<p><a name="1522420"> </a>Nothing. </p>
<h4>
  <a name="1522421"> </a>Comments 
</h4>

<p><a name="1522426"> </a>This function generates a <a href="UI_Window.html#1357696"><code>winUpdateEvent</code></a> for the window. If the window is update-based, it is added to a pending update queue. All updates in this queue are sent during a single <code>winUpdateEvent</code> the next time through the event loop. </p>

<p><a name="1522428"> </a>If the window is a transitional window, the update event is enqueued immediately. </p>

<p><a name="1522429"> </a>If the window is off-screen, this function has no effect. </p>
<h4>
  <a name="1522430"> </a>See Also 
</h4>

<p><a name="1522437"> </a><a href="UI_Window.html#1522335"><code>WinInvalidateRect()</code></a>, <a href="UI_Window.html#1522368"><code>WinInvalidateRectFunc()</code></a></p>

<h3 class="hbH3">
  <a name="1527698"> </a>WinModal Function <a href="#1160850"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="1527700"> </a>Purpose 
</h4>

<p><a name="1527701"> </a>Returns <code>true</code> if the specified window is modal. </p>
<h4>
  <a name="1527702"> </a>Declared In 
</h4>
<code>Window.h<a name="1527703"> </a></code><h4>
  <a name="1527704"> </a>Prototype 
</h4>
<pre class="proto"><a name="1527705"></a>Boolean WinModal (
   WinHandle <code class="par">winHandle</code>
)
</pre>
<h4>
  <a name="1527706"> </a>Parameters 
</h4>

<dl>
<dt><a name="1527707"> </a><code>&rarr;  <i>winHandle</i></code></dt>
<dd><a name="1527708"> </a>The handle of a window.</dd>

</dl>
<h4>
  <a name="1527709"> </a>Returns 
</h4>

<p><a name="1527710"> </a><code>true</code> if the window is modal, otherwise <code>false</code>.</p>
<h4>
  <a name="1527714"> </a>See Also 
</h4>

<p><a name="1527724"> </a><a href="UI_Form.html#995492"><code>FrmAlert()</code></a>, <a href="UI_Form.html#996096"><code>FrmCustomAlert()</code></a>, <a href="UI_Form.html#997081"><code>FrmDoDialog()</code></a> </p>

<h3 class="hbH3">
  <a name="1530544"> </a>WinPalette Function <a href="#1160850"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="1530546"> </a>Purpose 
</h4>

<p><a name="1530547"> </a>Sets or retrieves the palette for the draw window.</p>
<h4>
  <a name="1530548"> </a>Declared In 
</h4>
<code>Window.h<a name="1530549"> </a></code><h4>
  <a name="1530550"> </a>Prototype 
</h4>
<pre class="proto"><a name="1530551"></a>status_t WinPalette (
   uint8_t <code class="par">operation</code>,
   int16_t <code class="par">startIndex</code>,
   uint16_t <code class="par">paletteEntries</code>,
   RGBColorType <code class="par">*tableP</code>
)
</pre>
<h4>
  <a name="1530552"> </a>Parameters 
</h4>

<dl>
<dt><a name="1530553"> </a><code>&rarr;  <i>operation</i></code></dt>
<dd><a name="1530554"> </a>One of the following values:</dd>

<dl>
<dt><a name="1530556"> </a><code>winPaletteGet</code></dt>
<dd><a name="1530557"> </a>Retrieve the palette. Entries are read from the palette beginning at <code class="par">startIndex</code> and placed into <code class="par">tableP</code> beginning at index 0.</dd>

<dt><a name="1530559"> </a><code>winPaletteSet</code></dt>
<dd><a name="1530560"> </a>Set the palette. Entries from <code class="par">tableP</code> (beginning at index 0) are set into the palette beginning at <code class="par">startIndex</code> in the palette. Use only for off-screen windows. </dd>

<dt><a name="1530562"> </a><code>winPaletteSetToDefault</code></dt>
<dd><a name="1530563"> </a>Set the palette to the default system palette. Use only for off-screen windows. </dd>

</dl>
<dt><a name="1530564"> </a><code>&rarr;  <i>startIndex</i></code></dt>
<dd><a name="1530565"> </a>Identifies where in the palette to start reading or writing. Specify <code>WinUseTableIndexes</code> to indicate that the entries are not to be set or read sequentially; instead, the <code>index</code> value in each <code>RGBColorType</code> entry in <code class="par">tableP</code> determines which slot in the palette is to be set or read. You can use this technique to get or set several discontiguous palette entries with a single function call.</dd>

<dt><a name="1530568"> </a><code>&rarr;  <i>paletteEntries</i></code></dt>
<dd><a name="1530569"> </a>The number of palette entries to get or set.</dd>

<dt><a name="1530570"> </a><code>&harr;  <i>tableP</i></code></dt>
<dd><a name="1530574"> </a>A pointer to a buffer of <a href="UI_Bitmap.html#1004052"><code>RGBColorType</code></a> entries that is either read from or written to, depending on the <code class="par">operation</code> parameter; the table entries from 0 to <code class="par">paletteEntries</code> &#8211; 1 are affected by this routine.</dd>

</dl>
<h4>
  <a name="1530575"> </a>Returns 
</h4>

<p><a name="1530576"> </a>One of the following values: </p>

<dl>
<dt><a name="1530577"> </a><code>errNone</code></dt>
<dd><a name="1530578"> </a>Success. </dd>

<dt><a name="1530579"> </a><code>winErrPalette</code></dt>
<dd><a name="1530580"> </a>The current draw window does not have a color table, a set operation has overflowed the color table, or one of the entries in <code class="par">tableP</code> has an invalid index value </dd>

<dt><a name="1530581"> </a><code>sysErrParamErr</code></dt>
<dd><a name="1530582"> </a>The <code class="par">startIndex</code> value is invalid.</dd>

</dl>
<h4>
  <a name="1530583"> </a>Comments 
</h4>

<p><a name="1530584"> </a>Here are some examples of how this routine works: </p>
<ul type="disc">
  <li><a name="1530585"> </a>If <code class="par">startIndex</code> is 0 and <code class="par">paletteEntries</code> is 10, the first 10 elements of the palette will be set from <code class="par">tableP</code> or will be copied into <code class="par">tableP</code>. 
  <li><a name="1530586"> </a>If <code class="par">startIndex</code> is 10 and <code class="par">paletteEntries</code> is 5, then entries 10, 11, 12, 13, and 14 in the palette will be set from or copied to elements 0, 1, 2, 3, and 4 in <code class="par">tableP</code>. 
  <li><a name="1530588"> </a>If <code class="par">startIndex</code> is <code>WinUseTableIndexes</code> and <code class="par">paletteEntries</code> is 1, then the index value in the <code>RGBColorType</code> of element 0 of <code class="par">tableP</code> will be read from or copied to <code class="par">tableP</code>; in this case, the <code class="par">index</code> field of the <code>RGBColorType</code> will not change.
</ul>

<p><a name="1530591"> </a>One use for this function is if you need to display a bitmap that uses a color table other than the one in use by the system. You can attach a custom color table to a bitmap, and if you do, the bitmap is drawn using that color table. However, this is a performance drain. As an optimization, you can use <code>WinPalette()</code> to change the system color table to match that used by the bitmap, display the bitmap, and use <code>WinPalette()</code> to reset the color table when the bitmap is no longer visible. </p>

<p><a name="1530592"> </a>When the palette is changed, this function broadcasts the <a href="UI_Window.html#1643915"><code>sysNotifyDisplayChangeEvent</code></a> to notify any interested observer that the color palette has changed. </p>

<p><a name="1585269"> </a>Palette changes affect only future drawing. The colors of elements already on the screen do not change. It is strongly recommended that you set the palette before you do any drawing. </p>
<h4>
  <a name="1606444"> </a>Compatibility 
</h4>

<p><a name="1606487"> </a>Earlier releases of Palm OS supported 1, 2, 4, and 8 bit per pixel grayscale and 8 and 16-bit color at the hardware level. Palm OS Cobalt removes hardware support for all but 16-bit color. All previously supported color depths are emulated for compatibility. </p>

<div><hr>
  <a name="1606556"> </a> <b>TIP: </b> If you previously set your application to run in 8-bit color on a 16-bit device for better performance, you will now experience worse performance because 8-bit color is emulated. 
<hr>
</div>

<h3 class="hbH3">
  <a name="1532369"> </a>WinRequestFocus Function <a href="#1160850"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="1532371"> </a>Purpose 
</h4>

<p><a name="1532372"> </a>Asks that the input focus be given to the specified window. </p>
<h4>
  <a name="1532373"> </a>Declared In 
</h4>
<code>Window.h<a name="1532374"> </a></code><h4>
  <a name="1532375"> </a>Prototype 
</h4>
<pre class="proto"><a name="1532376"></a>status_t WinRequestFocus (
   WinHandle <code class="par">winHandle</code>,
   uint32_t <code class="par">flags</code>
)
</pre>
<h4>
  <a name="1532377"> </a>Parameters 
</h4>

<dl>
<dt><a name="1532378"> </a><code>&rarr;  <i>winHandle</i></code></dt>
<dd><a name="1532379"> </a>The window that wants the focus. </dd>

<dt><a name="1532380"> </a><code>&rarr;  <i>flags</i></code></dt>
<dd><a name="1532381"> </a>Currently unused. </dd>

</dl>
<h4>
  <a name="1532382"> </a>Returns 
</h4>

<p><a name="1532383"> </a>One of the following values:</p>

<dl>
<dt><a name="1532385"> </a><code>errNone</code></dt>
<dd><a name="1532386"> </a>Success.</dd>

<dt><a name="1532388"> </a><code>winErrInvalidWindowHandle</code></dt>
<dd><a name="1532389"> </a><code class="par">winHandle</code> is not a valid window. </dd>

</dl>
<h4>
  <a name="1532390"> </a>Comments 
</h4>

<p><a name="1532391"> </a>The system satisfies the request asynchronously. At some point in the future, the application receives a <a href="UI_Window.html#1356631"><code>winFocusGainedEvent</code></a> to inform you that you have been granted focus. The application might not be granted input focus if a window in a higher layer within another thread requests input focus at the same time. </p>

<p><a name="1662874"> </a>The input focus can only be set for focusable windows. Menus, pop--up lists, and the input area do not use focusable windows. </p>
<h4>
  <a name="1532398"> </a>See Also 
</h4>

<p><a name="1532402"> </a><a href="UI_Window.html#1536351"><code>WinSetActiveWindow()</code></a></p>

<h3 class="hbH3">
  <a name="1535827"> </a>WinRGBToIndex Function <a href="#1160850"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="1535829"> </a>Purpose 
</h4>

<p><a name="1535830"> </a>Converts an RGB value to the index of the closest color in the currently active color lookup table (CLUT).</p>
<h4>
  <a name="1535831"> </a>Declared In 
</h4>
<code>Window.h<a name="1535832"> </a></code><h4>
  <a name="1535833"> </a>Prototype 
</h4>
<pre class="proto"><a name="1535834"></a>IndexedColorType WinRGBToIndex (
   const RGBColorType <code class="par">*rgbP</code>
)
</pre>
<h4>
  <a name="1535835"> </a>Parameters 
</h4>

<dl>
<dt><a name="1535836"> </a><code>&rarr;  <i>rgbP</i></code></dt>
<dd><a name="1535837"> </a>A pointer to an RGB color value.</dd>

</dl>
<h4>
  <a name="1535838"> </a>Returns 
</h4>

<p><a name="1535839"> </a>The index of the closest matching color in the CLUT.</p>
<h4>
  <a name="1535840"> </a>Comments 
</h4>

<p><a name="1535841"> </a>The number of colors supported is hardware-dependent. The number of possible RGB colors may exceed the number of supported colors. For this reason, an exact match may not be available for <code class="par">rgbP</code>. If there is no exact RGB match, then a luminance best-fit is used if the color lookup table is entirely gray scale (red, green, and blue values for each entry are identical), or a shortest-distance fit in RGB space is used if the palette contains colors. RGB shortest distance may not always produce the actual closest perceptible color, but it's relatively fast and works for the system palette.</p>

<p><a name="1535842"> </a><code>WinRGBToIndex()</code> uses the draw window's color table to return the appropriate color table index. If the draw window does not have a color table, the default color table of the current screen is used.</p>

<p><a name="1535843"> </a>If the draw window does not have a color table, and if the depth of the draw window and the depth of the screen are different, this function will return an inappropriate index. If this situation exists, the application should either define a color table for the draw window, or use <a href="UI_Window.html#1536068"><code>WinScreenMode()</code></a> to set the screen depth to the same depth as the draw window before calling <code>WinRGBToIndex()</code>.</p>

<div><hr>
  <a name="1535847"> </a> <b>NOTE: </b> The bitmap data will not be blitted properly if the depth of the screen is changed using <a href="UI_Window.html#1536068"><code>WinScreenMode()</code></a> and the new window uses a bitmap that does not define the bitmap's color table. See <a href="UI_Window.html#1536068"><code>WinScreenMode()</code></a> for information on how to work around this limitation.
<hr>
</div>
<h4>
  <a name="1535854"> </a>See Also 
</h4>

<p><a name="1535861"> </a><a href="UI_Window.html#1522308"><code>WinIndexToRGB()</code></a>, <a href="UI_Window.html#1536068"><code>WinScreenMode()</code></a></p>

<h3 class="hbH3">
  <a name="1535889"> </a>WinScaleCoord Function <a href="#1160850"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="1535891"> </a>Purpose 
</h4>

<p><a name="1535892"> </a>Converts a single coordinate from the standard coordinate system to the active coordinate system.</p>
<h4>
  <a name="1535893"> </a>Declared In 
</h4>
<code>Window.h<a name="1535894"> </a></code><h4>
  <a name="1535895"> </a>Prototype 
</h4>
<pre class="proto"><a name="1535896"></a>Coord WinScaleCoord (
   Coord <code class="par">coord</code>,
   Boolean <code class="par">ceiling</code>
)
</pre>
<h4>
  <a name="1535897"> </a>Parameters 
</h4>

<dl>
<dt><a name="1535898"> </a><code>&rarr;  <i>coord</i></code></dt>
<dd><a name="1535899"> </a>A coordinate in the standard coordinate system.</dd>

<dt><a name="1535900"> </a><code>&rarr;  <i>ceiling</i></code></dt>
<dd><a name="1535901"> </a>Pass <code>true</code> to round up, <code>false</code> to truncate the fractional part when scaling.</dd>

</dl>
<h4>
  <a name="1535902"> </a>Returns 
</h4>

<p><a name="1535903"> </a>The coordinate scaled to the active coordinate system.</p>
<h4>
  <a name="1535904"> </a>Comments 
</h4>

<p><a name="1767683"> </a>This function converts a coordinate by multiplying it by the coordinate scaling factor. What happens next depends upon the value of <code class="par">ceiling</code>:</p>

<p><a name="1767684"> </a>if <code class="par">ceiling</code> == true {</p>

<p><a name="1767685"> </a>   use <code>lfloorf()</code> function when scaleFactor &gt; 1</p>

<p><a name="1767686"> </a>   use <code>lceilf()</code> function when scaleFactor &lt; 1</p>

<p><a name="1767687"> </a>else</p>

<p><a name="1767688"> </a>   use <code>lceilf()</code> function when scaleFactor &gt; 1</p>

<p><a name="1767689"> </a>   use <code>lfloorf()</code> function when scaleFactor &lt; 1</p>

<p><a name="1767690"> </a>}</p>

<p><a name="1767691"> </a>The objective of this algorithm is to ensure that for any <code>Coord</code>, <code>Point</code>, or <code>Rectangle</code> "x", x = unscaled(scaled(x)). </p>

<p><a name="1535907"> </a>If the active coordinate system is <code>kCoordinatesStandard</code>, the returned coordinate is equal to the supplied coordinate.</p>
<h4>
  <a name="1535908"> </a>See Also 
</h4>

<p><a name="1535915"> </a><a href="UI_Window.html#1535921"><code>WinScalePoint()</code></a>, <a href="UI_Window.html#1535955"><code>WinScaleRectangle()</code></a>, <a href="UI_Window.html#1543404"><code>WinUnscaleCoord()</code></a>, <a href="UI_Window.html#1663801"><code>WinScaleCoordNativeToActive()</code></a></p>

<h3 class="hbH3">
  <a name="1663801"> </a>WinScaleCoordNativeToActive Function <a href="#1160850"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="1664343"> </a>Purpose 
</h4>

<p><a name="1669627"> </a>Converts a single coordinate from the device's native coordinate system to the active coordinate system.</p>
<h4>
  <a name="1668955"> </a>Declared In 
</h4>
<code>Window.h<a name="1669042"> </a></code><h4>
  <a name="1669105"> </a>Prototype 
</h4>
<pre class="proto"><a name="1669192"></a>Coord WinScaleCoordNativeToActive (
   Coord <code class="par">coord</code>,
   Boolean <code class="par">ceiling</code>
)
</pre>
<h4>
  <a name="1669327"> </a>Parameters 
</h4>

<dl>
<dt><a name="1669408"> </a><code>&rarr;  <i>coord</i></code></dt>
<dd><a name="1669651"> </a>A coordinate in the native coordinate system.</dd>

<dt><a name="1669564"> </a><code>&rarr;  <i>ceiling</i></code></dt>
<dd><a name="1669681"> </a>Pass <code>true</code> to round up, <code>false</code> to truncate the fractional part when scaling.</dd>

</dl>
<h4>
  <a name="1669689"> </a>Returns 
</h4>

<p><a name="1669690"> </a>The coordinate scaled to the active coordinate system.</p>
<h4>
  <a name="1669691"> </a>Comments 
</h4>

<p><a name="1769446"> </a>This function converts a coordinate by multiplying it by the coordinate scaling factor. What happens next depends upon the value of <code class="par">ceiling</code>:</p>

<p><a name="1769447"> </a>if <code class="par">ceiling</code> == true {</p>

<p><a name="1769448"> </a>   use <code>lfloorf()</code> function when scaleFactor &gt; 1</p>

<p><a name="1769449"> </a>   use <code>lceilf()</code> function when scaleFactor &lt; 1</p>

<p><a name="1769450"> </a>else</p>

<p><a name="1769451"> </a>   use <code>lceilf()</code> function when scaleFactor &gt; 1</p>

<p><a name="1769452"> </a>   use <code>lfloorf()</code> function when scaleFactor &lt; 1</p>

<p><a name="1769453"> </a>}</p>

<p><a name="1769454"> </a>The objective of this algorithm is to ensure that for any <code>Coord</code>, <code>Point</code>, or <code>Rectangle</code> "x", x = unscaled(scaled(x)). </p>

<p><a name="1669694"> </a>If the active coordinate system is <code>kCoordinatesNative</code>, the returned coordinate is equal to the supplied coordinate.</p>
<h4>
  <a name="1669695"> </a>See Also 
</h4>

<p><a name="1669702"> </a><a href="UI_Window.html#1535889"><code>WinScaleCoord()</code></a> </p>

<h3 class="hbH3">
  <a name="1535921"> </a>WinScalePoint Function <a href="#1160850"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="1535923"> </a>Purpose 
</h4>

<p><a name="1535924"> </a>Converts a point from the standard coordinate system to the active coordinate system.</p>
<h4>
  <a name="1535925"> </a>Declared In 
</h4>
<code>Window.h<a name="1535926"> </a></code><h4>
  <a name="1535927"> </a>Prototype 
</h4>
<pre class="proto"><a name="1535928"></a>void WinScalePoint (
   PointType <code class="par">*pointP</code>,
   Boolean <code class="par">ceiling</code>
)
</pre>
<h4>
  <a name="1535929"> </a>Parameters 
</h4>

<dl>
<dt><a name="1535930"> </a><code>&harr;  <i>pointP</i></code></dt>
<dd><a name="1535932"> </a>A pointer to a <code>PointType</code> structure that, before the call, should contain a point's standard coordinate system coordinates. After this function is called, the <code>PointType</code> structure contains the coordinates of the point scaled to the active coordinate system.</dd>

<dt><a name="1535934"> </a><code>&rarr;  <i>ceiling</i></code></dt>
<dd><a name="1535935"> </a>Pass <code>true</code> to round up, <code>false</code> to truncate the fractional part when scaling.</dd>

</dl>
<h4>
  <a name="1535936"> </a>Returns 
</h4>

<p><a name="1535937"> </a>Nothing. </p>
<h4>
  <a name="1535938"> </a>Comments 
</h4>

<p><a name="1768421"> </a>This function converts a point by multiplying its x and y coordinates by the coordinate scaling factor. What happens next depends upon the value of <code class="par">ceiling</code>:</p>

<p><a name="1768422"> </a>if <code class="par">ceiling</code> == true {</p>

<p><a name="1768423"> </a>   use <code>lfloorf()</code> function when scaleFactor &gt; 1</p>

<p><a name="1768424"> </a>   use <code>lceilf()</code> function when scaleFactor &lt; 1</p>

<p><a name="1768425"> </a>else</p>

<p><a name="1768426"> </a>   use <code>lceilf()</code> function when scaleFactor &gt; 1</p>

<p><a name="1768427"> </a>   use <code>lfloorf()</code> function when scaleFactor &lt; 1</p>

<p><a name="1768428"> </a>}</p>

<p><a name="1768429"> </a>The objective of this algorithm is to ensure that for any <code>Coord</code>, <code>Point</code>, or <code>Rectangle</code> "x", x = unscaled(scaled(x)). </p>

<p><a name="1535941"> </a>If the active coordinate system is <code>kCoordinatesStandard</code>, <code>pointP</code> is not changed by this function.</p>
<h4>
  <a name="1535942"> </a>See Also 
</h4>

<p><a name="1535949"> </a><a href="UI_Window.html#1710088"><code>WinConvertPoint()</code></a>, <a href="UI_Window.html#1535889"><code>WinScaleCoord()</code></a>, <a href="UI_Window.html#1535955"><code>WinScaleRectangle()</code></a>, <a href="UI_Window.html#1543435"><code>WinUnscalePoint()</code></a></p>

<h3 class="hbH3">
  <a name="1535955"> </a>WinScaleRectangle Function <a href="#1160850"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="1535957"> </a>Purpose 
</h4>

<p><a name="1535958"> </a>Converts a rectangle from the standard coordinate system to the active coordinate system.</p>
<h4>
  <a name="1535959"> </a>Declared In 
</h4>
<code>Window.h<a name="1535960"> </a></code><h4>
  <a name="1535961"> </a>Prototype 
</h4>
<pre class="proto"><a name="1535962"></a>void WinScaleRectangle (
   RectangleType <code class="par">*rectP</code>
)
</pre>
<h4>
  <a name="1535963"> </a>Parameters 
</h4>

<dl>
<dt><a name="1535964"> </a><code>&harr;  <i>rectP</i></code></dt>
<dd><a name="1535966"> </a>A pointer to a <a href="UI_Rectangle.html#994219"><code>RectangleType</code></a> structure that, before the call, should contain a rectangle's standard coordinate system coordinates. After this function is called the <code>RectangleType</code> structure contains the coordinates of the rectangle scaled to the active coordinate system.</dd>

</dl>
<h4>
  <a name="1535967"> </a>Returns 
</h4>

<p><a name="1535968"> </a>Nothing. The coordinates of the rectangle indicated by <code class="par">rectP</code> are converted to the native coordinate system.</p>
<h4>
  <a name="1535969"> </a>Comments 
</h4>

<p><a name="1535970"> </a>This function scales the rectangle's <code>topLeft</code> and <code>extent</code> points by multiplying their <code>x</code> and <code>y</code> coordinates by the coordinate scaling factor. All values are then truncated, but if either <code>topLeft.x</code> or <code>extent.x</code> had a fractional part, <code>extent.x</code> is incremented by 1 (and, similarly, if either <code>topLeft.y</code> or <code>extent.y</code> had a fractional part, <code>extent.y</code> is incremented by 1).</p>

<p><a name="1535972"> </a>If the active coordinate system is <code>kCoordinatesStandard</code>, <code class="par">rectP</code> is not changed by this function.</p>

<p><a name="1535973"> </a>You can use this function when your gadget handler draws using a more precise coordinate system than the Form Manager and needs to convert the form-based bounds of the gadget to the high-density bounds used by the gadget's drawing function.</p>
<h4>
  <a name="1535974"> </a>See Also 
</h4>

<p><a name="1535981"> </a><a href="UI_Window.html#1535889"><code>WinScaleCoord()</code></a>, <a href="UI_Window.html#1535921"><code>WinScalePoint()</code></a>, <a href="UI_Window.html#1543466"><code>WinUnscaleRectangle()</code></a></p>

<h3 class="hbH3">
  <a name="1535987"> </a>WinScreenGetAttribute Function <a href="#1160850"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="1535989"> </a>Purpose 
</h4>

<p><a name="1535990"> </a>Obtains various attributes of the screen.</p>
<h4>
  <a name="1535991"> </a>Declared In 
</h4>
<code>Window.h<a name="1535992"> </a></code><h4>
  <a name="1535993"> </a>Prototype 
</h4>
<pre class="proto"><a name="1535994"></a>status_t WinScreenGetAttribute (
   WinScreenAttrType <code class="par">selector</code>,
   uint32_t <code class="par">*attrP</code>
)
</pre>
<h4>
  <a name="1535995"> </a>Parameters 
</h4>

<dl>
<dt><a name="1535996"> </a><code>&rarr;  <i>selector</i></code></dt>
<dd><a name="1535997"> </a>One of the following:</dd>

<dl>
<dt><a name="1535998"> </a><code>winScreenWidth</code></dt>
<dd><a name="1535999"> </a>The width of the screen, in pixels.</dd>

<dt><a name="1536000"> </a><code>winScreenHeight</code></dt>
<dd><a name="1536001"> </a>The height of the screen, in pixels.</dd>

<dt><a name="1536002"> </a><code>winScreenRowBytes</code></dt>
<dd><a name="1536003"> </a>The number of bytes used by each row in the screen buffer.</dd>

<dt><a name="1536004"> </a><code>winScreenDepth</code></dt>
<dd><a name="1536005"> </a>The screen depth.</dd>

<dt><a name="1536006"> </a><code>winScreenAllDepths</code></dt>
<dd><a name="1536007"> </a>All screen depths (in bitmap format).</dd>

<dt><a name="1536008"> </a><code>winScreenDensity</code></dt>
<dd><a name="1536009"> </a>The screen bitmap's density.</dd>

<dt><a name="1536010"> </a><code>winScreenPixelFormat</code></dt>
<dd><a name="1536014"> </a>The <a href="UI_Bitmap.html#1004178"><code>PixelFormatType</code></a> appropriate for the screen.</dd>

<dt><a name="1536015"> </a><code>winScreenResolutionX</code></dt>
<dd><a name="1536016"> </a>The number of pixels per inch along the screen's x axis.</dd>

<dt><a name="1536017"> </a><code>winScreenResolutionY</code></dt>
<dd><a name="1536018"> </a>The number of pixels per inch along the screen's y axis.</dd>

</dl>
<dt><a name="1536019"> </a><code>&larr;  <i>attrP</i></code></dt>
<dd><a name="1536020"> </a>A pointer to a <code>uint32_t </code>into which the specified attribute value is placed by this function.</dd>

</dl>
<h4>
  <a name="1536021"> </a>Returns 
</h4>

<p><a name="1536022"> </a>One of the following values: </p>

<dl>
<dt><a name="1536023"> </a><code><code>errNone</code></code></dt>
<dd><a name="1536024"> </a>Success.</dd>

<dt><a name="1536025"> </a><code>sysErrParamErr</code></dt>
<dd><a name="1536026"> </a><code class="par">selector</code> doesn't represent a screen attribute.</dd>

</dl>
<h4>
  <a name="1536027"> </a>Comments 
</h4>

<p><a name="1536028"> </a>This function returns many of the attributes that can be obtained with <a href="UI_Window.html#1536068"><code>WinScreenMode()</code></a>. Unlike <code>WinScreenMode()</code>, however, this function can also return the number of bytes used by each row in the screen buffer as well as the number of pixels per inch on the screen's x and y axes.</p>

<p><a name="1536033"> </a>Unlike <code>WinScreenMode()</code>, you cannot set any attributes with this function. Also, you cannot use this function to obtain the "color enabled" attribute. And unlike <code>WinScreenMode()</code>, this function always returns the true screen dimensions; <code>WinScreenMode()</code> converts the dimensions to the active coordinate system.</p>

<p><a name="1536034"> </a>Applications can use the screen resolution information to make intelligent decisions about how to draw primitives on Palm Powered devices with different screen resolutions.</p>

<h3 class="hbH3">
  <a name="1536041"> </a>WinScreenLock Function <a href="#1160850"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="1536043"> </a>Purpose 
</h4>

<p><a name="1536044"> </a>"Locks" the current screen by switching the UI concept of the screen base address to an area that is not reflected on the display.</p>
<h4>
  <a name="1536045"> </a>Declared In 
</h4>
<code>Window.h<a name="1536046"> </a></code><h4>
  <a name="1536047"> </a>Prototype 
</h4>
<pre class="proto"><a name="1536048"></a>uint8_t *WinScreenLock (
   WinLockInitType <code class="par">initMode</code>
)
</pre>
<h4>
  <a name="1536049"> </a>Parameters 
</h4>

<dl>
<dt><a name="1536050"> </a><code>&rarr;  <i>initMode</i></code></dt>
<dd><a name="1536051"> </a>Indicates how to initialize the new screen area. Specify one of the following values:</dd>

<dl>
<dt><a name="1536052"> </a><code>winLockCopy</code></dt>
<dd><a name="1536053"> </a>Copy old screen to new.</dd>

<dt><a name="1536054"> </a><code>winLockErase</code></dt>
<dd><a name="1536055"> </a>Erase new screen to white.</dd>

<dt><a name="1536056"> </a><code>winLockDontCare</code></dt>
<dd><a name="1536057"> </a>Don't do anything</dd>

</dl>
</dl>
<h4>
  <a name="1536058"> </a>Returns 
</h4>

<p><a name="1536059"> </a>A pointer to the new screen base address, or <code>NULL</code> if this routine fails.</p>
<h4>
  <a name="1536060"> </a>Comments 
</h4>

<p><a name="1536061"> </a>This routine can be used to "freeze" the display while doing lengthy drawing operations to avoid a flickering effect. Call <a href="UI_Window.html#1536268"><code>WinScreenUnlock()</code></a> to unlock the display and cause it to be updated with any changes. The screen must be unlocked as many times as it is locked to actually update the display.</p>

<p><a name="1536065"> </a>Because this function copies the screen, using it is a relatively expensive operation. </p>
<h4>
  <a name="1536066"> </a>Compatibility 
</h4>

<p><a name="1544315"> </a>You can only call this function on a legacy or transitional window. Calling this function when the active window is update-based has no effect. </p>

<h3 class="hbH3">
  <a name="1536068"> </a>WinScreenMode Function <a href="#1160850"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="1536070"> </a>Purpose 
</h4>

<p><a name="1536071"> </a>Sets or returns display parameters, including display geometry, bit depth, and color support. </p>
<h4>
  <a name="1536072"> </a>Declared In 
</h4>
<code>Window.h<a name="1536073"> </a></code><h4>
  <a name="1536074"> </a>Prototype 
</h4>
<pre class="proto"><a name="1536075"></a>status_t WinScreenMode (
   WinScreenModeOperation <code class="par">operation</code>,
   uint32_t <code class="par">*widthP</code>,
   uint32_t <code class="par">*heightP</code>,
   uint32_t <code class="par">*depthP</code>,
   Boolean <code class="par">*enableColorP</code>
)
</pre>
<h4>
  <a name="1536076"> </a>Parameters 
</h4>

<dl>
<dt><a name="1536077"> </a><code>&rarr;  <i>operation</i></code></dt>
<dd><a name="1536079"> </a>The work this function is to perform, as specified by one of the following selectors:</dd>

<dl>
<dt><a name="1536081"> </a><code>winScreenModeGet</code></dt>
<dd><a name="1536082"> </a>Return the current settings for the display. </dd>

<dt><a name="1536084"> </a><code>winScreenModeGetDefaults</code></dt>
<dd><a name="1536085"> </a>Return the default settings for the display. </dd>

<dt><a name="1536087"> </a><code>winScreenModeGetSupportedDepths</code></dt>
<dd><a name="1536088"> </a>Return in <code class="par">depthP</code> a hexadecimal value indicating the supported screen depths. The binary representation of this value defines a bit field in which the value 1 indicates support for a particular display depth. The position representing a particular bit depth corresponds to the value <code>2</code><!-PS02-><span style="color: #000000;  font-family: Courier; font-style: normal; font-weight: normal; text-decoration: none; text-transform: none; vertical-align: super">(bitDepth-1)</span>. See the <a href="UI_Window.html#1583212">Example</a> at the end of this function description for more information.</dd>

<dt><a name="1536093"> </a><code>winScreenModeGetSupportsColor</code></dt>
<dd><a name="1536094"> </a>Return <code>true</code> as the value of the <code class="par">enableColorP</code> parameter when color mode can be enabled.</dd>

</dl>
<dt><a name="1536101"> </a><code>&harr;  <i>widthP</i></code></dt>
<dd><a name="1536102"> </a>A pointer to new/old screen width. For backward compatibility, when <code class="par">operation</code> is <code>winScreenModeGet</code> or <code>winScreenModeGetDefaults</code>, a single-density width is returned, even if the handheld has a double-density display. Use <a href="UI_Window.html#1535987"><code>WinScreenGetAttribute()</code></a> to retrieve the true hardware dimensions of the display.</dd>

<dt><a name="1536106"> </a><code>&harr;  <i>heightP</i></code></dt>
<dd><a name="1536107"> </a>A pointer to new/old screen height. For backward compatibility, when <code class="par">operation</code> is <code>winScreenModeGet</code> or <code>winScreenModeGetDefaults</code>, a single-density height is returned, even if the handheld has a double-density display. Use <a href="UI_Window.html#1535987"><code>WinScreenGetAttribute()</code></a> to retrieve the true hardware dimensions of the display.</dd>

<dt><a name="1536111"> </a><code>&harr;  <i>depthP</i></code></dt>
<dd><a name="1536112"> </a>A pointer to new/old/available screen depth.</dd>

<dt><a name="1536113"> </a><code>&harr;  <i>enableColorP</i></code></dt>
<dd><a name="1536114"> </a>Pass <code>true</code> to enable color drawing mode. The returned value (when using an operation that returns a value through this parameter) simply indicates whether or not the hardware supports color; its value does not change based on the current screen depth.</dd>

</dl>
<h4>
  <a name="1536115"> </a>Returns 
</h4>

<p><a name="1536116"> </a>One of the following values: </p>

<dl>
<dt><a name="1536117"> </a><code>errNone</code></dt>
<dd><a name="1536118"> </a>Success.</dd>

<dt><a name="1536119"> </a><code>sysErrParamErr</code></dt>
<dd><a name="1536120"> </a>An invalid argument was specified. </dd>

<dt><a name="1536121"> </a><code>memErrNotEnoughSpace</code></dt>
<dd><a name="1536122"> </a>There is not enough memory to perform the requested operation. </dd>

</dl>
<h4>
  <a name="1536123"> </a>Comments 
</h4>

<p><a name="1536124"> </a>The <code class="par">widthP</code>, <code class="par">heightP</code>, <code class="par">depthP</code>, and <code class="par">enableColorP</code> parameters are used in different ways for different operations. All "get" operations overwrite these values with a result when the function returns. The <code>winScreenModeSet</code> operation changes current display parameters when passed valid argument values that are not <code>NULL</code> pointers. The <code>winScreenModeSetToDefaults</code> operation ignores values passed for all of these parameters.</p>

<p><a name="1536128"> </a><a href="UI_Window.html#1536135">Table 36.1</a> summarizes parameter usage for each operation this function performs. </p>

<p class="caption"><a name="1536135"> </a><b>Table 36.1&nbsp;&nbsp;Use of parameters to WinScreenMode function </b></p>
<div class="tablediv"><table cellspacing="0" class="tTable">

  <tr valign="top">
    <th><p class="tt"><a name="1536145"> </a><b>Operation <code>winScreenMode...</code></b></p>
    </th>
    <th><p class="tt"><a name="1536147"> </a><b>widthP</b></p>
    </th>
    <th><p class="tt"><a name="1536149"> </a><b>heightP</b></p>
    </th>
    <th><p class="tt"><a name="1536151"> </a><b>depthP</b></p>
    </th>
    <th><p class="tt"><a name="1536153"> </a><b>enableColorP</b></p>
    </th>
  </tr>
  <tr valign="top">
    <td><p class="tt"><a name="1536155"> </a><code>...Get</code></p>
    </td>
    <td><p class="tt"><a name="1536157"> </a>returned</p>
    </td>
    <td><p class="tt"><a name="1536159"> </a>returned</p>
    </td>
    <td><p class="tt"><a name="1536161"> </a>returned</p>
    </td>
    <td><p class="tt"><a name="1536163"> </a>returned</p>
    </td>
  </tr>
  <tr valign="top">
    <td><p class="tt"><a name="1536165"> </a><code>...GetDefaults</code></p>
    </td>
    <td><p class="tt"><a name="1536167"> </a>returned</p>
    </td>
    <td><p class="tt"><a name="1536169"> </a>returned</p>
    </td>
    <td><p class="tt"><a name="1536171"> </a>returned</p>
    </td>
    <td><p class="tt"><a name="1536173"> </a>returned</p>
    </td>
  </tr>
  <tr valign="top">
    <td><p class="tt"><a name="1536175"> </a><code>...GetSupportedDepths</code></p>
    </td>
    <td><p class="tt"><a name="1536177"> </a>ignored</p>
    </td>
    <td><p class="tt"><a name="1536179"> </a>ignored</p>
    </td>
    <td><p class="tt"><a name="1536181"> </a>returned</p>
    </td>
    <td><p class="tt"><a name="1536183"> </a>pass in</p>
    </td>
  </tr>
  <tr valign="top">
    <td><p class="tt"><a name="1536185"> </a><code>...GetSupportsColor</code></p>
    </td>
    <td><p class="tt"><a name="1536187"> </a>ignored</p>
    </td>
    <td><p class="tt"><a name="1536189"> </a>ignored</p>
    </td>
    <td><p class="tt"><a name="1536191"> </a>pass in</p>
    </td>
    <td><p class="tt"><a name="1536193"> </a>returned</p>
    </td>
  </tr>
  <tr valign="top">
    <td><p class="tt"><a name="1536195"> </a><code>...Set</code></p>
    </td>
    <td><p class="tt"><a name="1536197"> </a>pass in</p>
    </td>
    <td><p class="tt"><a name="1536199"> </a>pass in</p>
    </td>
    <td><p class="tt"><a name="1536201"> </a>pass in</p>
    </td>
    <td><p class="tt"><a name="1536203"> </a>pass in</p>
    </td>
  </tr>
  <tr valign="top">
    <td><p class="tt"><a name="1536205"> </a><code>...SetToDefaults</code></p>
    </td>
    <td><p class="tt"><a name="1536207"> </a>ignored</p>
    </td>
    <td><p class="tt"><a name="1536209"> </a>ignored </p>
    </td>
    <td><p class="tt"><a name="1536211"> </a>ignored</p>
    </td>
    <td><p class="tt"><a name="1536213"> </a>ignored</p>
    </td>
  </tr>
</table>

</div>


<p><a name="1536215"> </a>This function ignores <code>NULL</code> pointer arguments to the <code class="par">widthP</code>, <code class="par">heightP</code>, <code class="par">depthP</code>, and <code class="par">enableColorP</code> parameters; thus, you can pass a <code>NULL</code> pointer for any of these values to leave the current value unchanged. Similarly, when getting values, this function does not return a value for any <code>NULL</code> pointer argument. </p>

<p><a name="1536216"> </a>If you change the display depth, it is recommended that you restore it to its previous state when your application closes, even though the system sets display parameters back to their default values when launching an application. </p>

<p><a name="1592803"> </a>Avoid bit depths of 1, 2, or 4 bits per pixel. They are supported, but they cause rendering to be much slower on Palm OS Cobalt. </p>

<p><a name="1536217"> </a>Note that none of the other operations interprets the depth parameter the same way that <code>winScreenModeGetSupportedDepths</code> does. For example, to set the display depth to 8-bit mode, you use 8 (decimal) for the display depth, not 0x80 (128 decimal). </p>

<p><a name="1536218"> </a>When a window is created, and if the window's associated bitmap does not have its own color table, the window will use the system's default color translation tables when a drawing operation occurs to that window. When the system's bit depth changes, the system's default color translation tables are recalculated based on the new screen depth. When the blit occurs at the new screen depth to the off-screen window, the color translation tables are out of sync. </p>

<p><a name="1583205"> </a>To work around this system limitation, developers should change the bit depth first, then create any off-screen windows. </p>
<h4>
  <a name="1583212"> </a>Example 
</h4>

<p><a name="1536228"> </a>Here are some additional examples of return values provided by the <code>winScreenModeGetSupportedDepths</code> mode of the <code>WinScreenMode()</code> function. </p>

<p><a name="1536229"> </a>This function indicates support for 4-bit drawing by returning a value of <code>0x08</code>, or 2<span style="color: #000000;  font-style: normal; font-weight: normal; text-decoration: none; text-transform: none; vertical-align: super">3</span>, which corresponds to a binary value of <code>1000</code>. Support for bit depths of 2 and 1 is indicated by a return value of <code>0x03</code>. Support for bit depths of 4, 2, and 1 is indicated by <code>0x0B</code>, which is a binary value of <code>1011</code>. Support for bit depths of 16, 8, 4 and 2 is indicated by <code>0x808A</code>. The figure immediately following depicts this final example graphically. </p>
<div align="left"><img src="images/UI_Windowi.jpg" height="150" width="480" border="0" hspace="0" vspace="0">
</div>
<h4>
  <a name="1727319"> </a>Compatibility 
</h4>

<p><a name="1727403"> </a>In earlier releases of Palm OS, this function supported two more operations: <code>winScreenModeSet</code> and <code>winScreenModeSetToDefaults</code>. In Palm OS Cobalt, <code>WinScreenMode()</code> does not support these two operations. </p>
<h4>
  <a name="1536262"> </a>See Also 
</h4>

<p><a name="1536266"> </a><a href="UI_Window.html#1535987"><code>WinScreenGetAttribute()</code></a></p>

<h3 class="hbH3">
  <a name="1536268"> </a>WinScreenUnlock Function <a href="#1160850"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="1536270"> </a>Purpose 
</h4>

<p><a name="1536271"> </a>Unlocks the screen and updates the display.</p>
<h4>
  <a name="1536272"> </a>Declared In 
</h4>
<code>Window.h<a name="1536273"> </a></code><h4>
  <a name="1536274"> </a>Prototype 
</h4>
<pre class="proto"><a name="1536275"></a>void WinScreenUnlock (
   void
)
</pre>
<h4>
  <a name="1536276"> </a>Parameters 
</h4>

<p><a name="1536277"> </a>None.</p>
<h4>
  <a name="1536278"> </a>Returns 
</h4>

<p><a name="1536279"> </a>Nothing.</p>
<h4>
  <a name="1536281"> </a>Comments 
</h4>

<p><a name="1536282"> </a>The screen must be unlocked as many times as it is locked to actually update the display.</p>
<h4>
  <a name="1544338"> </a>Compatibility 
</h4>

<p><a name="1536283"> </a>You can only call this function on a legacy or transitional window. Calling this function when the active window is update-based has no effect. </p>
<h4>
  <a name="1536284"> </a>See Also 
</h4>

<p><a name="1536288"> </a><a href="UI_Window.html#1536041"><code>WinScreenLock()</code></a></p>

<h3 class="hbH3">
  <a name="1536290"> </a>WinScrollRectangle Function <a href="#1160850"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="1536292"> </a>Purpose 
</h4>

<p><a name="1536293"> </a>Scrolls a rectangle in the draw window.</p>
<h4>
  <a name="1536294"> </a>Declared In 
</h4>
<code>Window.h<a name="1536295"> </a></code><h4>
  <a name="1536296"> </a>Prototype 
</h4>
<pre class="proto"><a name="1536297"></a>void WinScrollRectangle (
   const RectangleType <code class="par">*rP</code>,
   WinDirectionType <code class="par">direction</code>,
   Coord <code class="par">distance</code>,
   RectangleType <code class="par">*vacatedP</code>
)
</pre>
<h4>
  <a name="1536298"> </a>Parameters 
</h4>

<dl>
<dt><a name="1536299"> </a><code>&rarr;  <i>rP</i></code></dt>
<dd><a name="1536300"> </a>A pointer to the rectangle to scroll.</dd>

<dt><a name="1536301"> </a><code>&rarr;  <i>direction</i></code></dt>
<dd><a name="1536303"> </a>The direction to scroll (<code>winUp</code>, <code>winDown</code>, <code>winLeft</code>, or <code>winRight</code>).</dd>

<dt><a name="1536304"> </a><code>&rarr;  <i>distance</i></code></dt>
<dd><a name="1536305"> </a>The distance to scroll in pixels.</dd>

<dt><a name="1536306"> </a><code>&larr;  <i>vacatedP</i></code></dt>
<dd><a name="1536307"> </a>A pointer to the rectangle that needs to be redrawn because it has been vacated as a result of the scroll.</dd>

</dl>
<h4>
  <a name="1536308"> </a>Returns 
</h4>

<p><a name="1536309"> </a>Nothing.</p>
<h4>
  <a name="1536310"> </a>Comments 
</h4>

<p><a name="1536311"> </a>The rectangle scrolls within its own bounds. Any portion of the rectangle that is scrolled outside its bounds is clipped.</p>
<h4>
  <a name="1570055"> </a>Compatibility 
</h4>

<p><a name="1598329"> </a>Use this function only in legacy applications that contain only legacy windows. Palm OS Cobalt native applications should use <a href="UI_Window.html#1570060"><code>WinScrollRectangleAsync()</code></a>.</p>

<h3 class="hbH3">
  <a name="1570060"> </a>WinScrollRectangleAsync Function <a href="#1160850"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="1536319"> </a>Purpose 
</h4>

<p><a name="1536320"> </a>Scrolls a window by generating an update event. </p>
<h4>
  <a name="1536321"> </a>Declared In 
</h4>
<code>Window.h<a name="1536322"> </a></code><h4>
  <a name="1536323"> </a>Prototype 
</h4>
<pre class="proto"><a name="1536324"></a>status_t WinScrollRectangleAsync (
   WinHandle <code class="par">winHandle</code>,
   const RectangleType <code class="par">*rP</code>,
   Coord <code class="par">dx</code>,
   Coord <code class="par">dy</code>
)
</pre>
<h4>
  <a name="1536325"> </a>Parameters 
</h4>

<dl>
<dt><a name="1536326"> </a><code>&rarr;  <i>winHandle</i></code></dt>
<dd><a name="1536327"> </a>The window to scroll. </dd>

<dt><a name="1536328"> </a><code>&rarr;  <i>rP</i></code></dt>
<dd><a name="1536329"> </a>A pointer to the rectangle to scroll. </dd>

<dt><a name="1536330"> </a><code>&rarr;  <i>dx</i></code></dt>
<dd><a name="1536331"> </a>The amount by which to scroll horizontally. A negative value means scroll to the left. </dd>

<dt><a name="1536332"> </a><code>&rarr;  <i>dy</i></code></dt>
<dd><a name="1536333"> </a>The amount by which to scroll vertically. A negative amount means scroll to the top. </dd>

</dl>
<h4>
  <a name="1536334"> </a>Returns 
</h4>

<p><a name="1536335"> </a>One of the following values: </p>

<dl>
<dt><a name="1536336"> </a><code>errNone</code></dt>
<dd><a name="1536337"> </a>Success.</dd>

<dt><a name="1536338"> </a><code>winErrInvalidWindowHandle</code></dt>
<dd><a name="1536339"> </a><code class="par">winHandle</code> is not a valid window. </dd>

</dl>
<h4>
  <a name="1536340"> </a>Comments 
</h4>

<p><a name="1536344"> </a>This function differs from <a href="UI_Window.html#1536290"><code>WinScrollRectangle()</code></a> not only by how you specify the direction to scroll, but also by how scrolling occurs. This function marks the area as invalid and then triggers a <a href="UI_Window.html#1357696"><code>winUpdateEvent</code></a> with the region that needs to be redrawn. </p>

<p><a name="1536349"> </a>For off-screen windows, this merely performs a copy.</p>

<h3 class="hbH3">
  <a name="1536351"> </a>WinSetActiveWindow Function <a href="#1160850"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="1536353"> </a>Purpose 
</h4>

<p><a name="1536355"> </a>Makes a window the active window.</p>
<h4>
  <a name="1536356"> </a>Declared In 
</h4>
<code>Window.h<a name="1536357"> </a></code><h4>
  <a name="1536358"> </a>Prototype 
</h4>
<pre class="proto"><a name="1536359"></a>void WinSetActiveWindow (
   WinHandle <code class="par">winHandle</code>
)
</pre>
<h4>
  <a name="1536360"> </a>Parameters 
</h4>

<dl>
<dt><a name="1536361"> </a><code>&rarr;  <i>winHandle</i></code></dt>
<dd><a name="1536362"> </a>The handle of a window.</dd>

</dl>
<h4>
  <a name="1536363"> </a>Returns 
</h4>

<p><a name="1536364"> </a>Nothing.</p>
<h4>
  <a name="1536365"> </a>Comments 
</h4>

<p><a name="1536366"> </a>The active window is not actually set in this routine; flags are set to indicate that a window is being exited and another window is being entered, which generates the following sequence of events: </p>
<ul type="disc">
  <li><a name="1536371"> </a>A <a href="UI_Window.html#1659056"><code>winExitEvent</code></a> specifying the current window as the exit window and <code class="par">winHandle</code> as the new window.
  <li><a name="1536376"> </a>A <a href="UI_Window.html#1659238"><code>winEnterEvent</code></a> specifying the current window as the exit window and <code class="par">winHandle</code> as the new window. 
  <li><a name="1536384"> </a>The window is enabled. 
  <li><a name="1661327"> </a>If <code class="par">winHandle</code> should be able to receive <code>keyDownEvents</code>, input focus is requested for <code class="par">winHandle</code>. 
   <p><a name="1661489"> </a>At some point later on, if the system grants input focus to <code class="par">winHandle</code>, the <a href="UI_Window.html#1357484"><code>winFocusLostEvent</code></a> is sent to the event queue of the thread that contains the window that currently has input focus. Then a <a href="UI_Window.html#1356631"><code>winFocusGainedEvent</code></a> specifying <code class="par">winHandle</code> are is sent to the current thread's event queue. </p>
</ul>

<p><a name="1536392"> </a>All user input is directed to the active window.</p>
<h4>
  <a name="1536394"> </a>See Also 
</h4>

<p><a name="1536401"> </a><a href="UI_Window.html#1486637"><code>WinGetActiveWindow()</code></a>, <a href="../Programming_Basics/Event.html#996063"><code>EvtGetEvent()</code></a>, <a href="UI_Window.html#1542343"><code>WinSetDrawWindow()</code></a>, <a href="UI_Window.html#1532369"><code>WinRequestFocus()</code></a></p>

<h3 class="hbH3">
  <a name="1538337"> </a>WinSetBounds Function <a href="#1160850"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="1538339"> </a>Purpose 
</h4>

<p><a name="1538340"> </a>Sets the bounds of the window to display-relative coordinates.</p>
<h4>
  <a name="1538341"> </a>Declared In 
</h4>
<code>Window.h<a name="1538342"> </a></code><h4>
  <a name="1538343"> </a>Prototype 
</h4>
<pre class="proto"><a name="1538344"></a>void WinSetBounds (
   WinHandle <code class="par">winHandle</code>,
   const RectangleType <code class="par">*rP</code>
)
</pre>
<h4>
  <a name="1538345"> </a>Parameters 
</h4>

<dl>
<dt><a name="1538346"> </a><code>&rarr;  <i>winHandle</i></code></dt>
<dd><a name="1538347"> </a>A handle for the window for which to set the bounds.</dd>

<dt><a name="1538348"> </a><code>&rarr;  <i>rP</i></code></dt>
<dd><a name="1538349"> </a>A pointer to a rectangle to use for bounds.</dd>

</dl>
<h4>
  <a name="1538350"> </a>Returns 
</h4>

<p><a name="1538351"> </a>Nothing.</p>
<h4>
  <a name="1538352"> </a>Compatibility 
</h4>

<p><a name="1598382"> </a>Visible windows and transitional or update-based windows cannot have their bounds modified. You can only modify the bounds of a legacy or an off-screen window. For update-based or transitional windows, you specify the size requirements (or constraints) when you create the window. The system determines what size to make it, and then sends the <a href="UI_Window.html#1357625"><code>winResizedEvent</code></a>. </p>
<h4>
  <a name="1538357"> </a>See Also 
</h4>

<p><a name="1677655"> </a><a href="UI_Window.html#1486704"><code>WinGetBounds()</code></a></p>

<h3 class="hbH3">
  <a name="1677658"> </a>WinSetConstraints Function <a href="#1160850"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="1677660"> </a>Purpose 
</h4>

<p><a name="1541187"> </a>Sets a window's constraints. </p>
<h4>
  <a name="1541188"> </a>Declared In 
</h4>
<code>Window.h<a name="1541189"> </a></code><h4>
  <a name="1541190"> </a>Prototype 
</h4>
<pre class="proto"><a name="1541191"></a>status_t WinSetConstraints (
   WinHandle <code class="par">winHandle</code>,
   const WinConstraintsType <code class="par">*constraints</code>
)
</pre>
<h4>
  <a name="1541192"> </a>Parameters 
</h4>

<dl>
<dt><a name="1541193"> </a><code>&rarr;  <i>winHandle</i></code></dt>
<dd><a name="1541194"> </a>A handle to the window. </dd>

<dt><a name="1541195"> </a><code>&rarr;  <i>constraints</i></code></dt>
<dd><a name="1541199"> </a>A <a href="UI_Window.html#1617194"><code>WinConstraintsType</code></a> structure specifying the position and minimum, preferred, and maximum sizes for the window. </dd>

</dl>
<h4>
  <a name="1541200"> </a>Returns 
</h4>

<p><a name="1541201"> </a>Always returns <code>errNone</code>. </p>
<h4>
  <a name="1541202"> </a>Comments 
</h4>

<p><a name="1541203"> </a>You can use this to change a window's size constraints. Calling this function causes the Window Manager to re-evaluate the window's size. Eventually, a <a href="UI_Window.html#1357625"><code>winResizedEvent</code></a> and a <a href="UI_Window.html#1357696"><code>winUpdateEvent</code></a> are generated. </p>
<h4>
  <a name="1541211"> </a>See Also 
</h4>

<p><a name="1541215"> </a><a href="UI_Window.html#1480817"><code>WinCreateWindowWithConstraints()</code></a></p>

<h3 class="hbH3">
  <a name="1542343"> </a>WinSetDrawWindow Function <a href="#1160850"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="1542345"> </a>Purpose 
</h4>

<p><a name="1542346"> </a>Sets the draw window. (All drawing operations are relative to the draw window.)</p>
<h4>
  <a name="1542347"> </a>Declared In 
</h4>
<code>Window.h<a name="1542348"> </a></code><h4>
  <a name="1542349"> </a>Prototype 
</h4>
<pre class="proto"><a name="1542350"></a>WinHandle WinSetDrawWindow (
   WinHandle <code class="par">winHandle</code>
)
</pre>
<h4>
  <a name="1542351"> </a>Parameters 
</h4>

<dl>
<dt><a name="1542352"> </a><code>&rarr;  <i>winHandle</i></code></dt>
<dd><a name="1542353"> </a>The handle of a window.</dd>

</dl>
<h4>
  <a name="1542354"> </a>Returns 
</h4>

<p><a name="1542355"> </a>The previous draw window. </p>
<h4>
  <a name="1542356"> </a>Comments 
</h4>

<p><a name="1542362"> </a>Do not call this function in response to a <a href="UI_Window.html#1357696"><code>winUpdateEvent</code></a>. You cannot change the draw window during an update. </p>
<h4>
  <a name="1542363"> </a>See Also 
</h4>

<p><a name="1542370"> </a><a href="UI_Window.html#1497142"><code>WinGetDrawWindow()</code></a>, <a href="UI_Window.html#1536351"><code>WinSetActiveWindow()</code></a></p>

<h3 class="hbH3">
  <a name="1543355"> </a>WinSetWindowBounds Macro <a href="#1160850"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="1543357"> </a>Purpose 
</h4>

<p><a name="1543358"> </a>Calls <a href="UI_Window.html#1538337"><code>WinSetBounds()</code></a>.</p>
<h4>
  <a name="1543359"> </a>Declared In 
</h4>
<code>Window.h<a name="1543360"> </a></code><h4>
  <a name="1543361"> </a>Prototype 
</h4>
<pre class="proto"><a name="1543362"></a>#define WinSetWindowBounds (
   <code class="par">winH</code>,
   <code class="par"> rP</code>
)
</pre>
<h4>
  <a name="1543363"> </a>Parameters 
</h4>

<dl>
<dt><a name="1543364"> </a><code>&rarr;  <i>winHandle</i></code></dt>
<dd><a name="1543368"> </a>A <a href="UI_Window.html#1414441"><code>WinHandle</code></a> for the window for which to set the bounds.</dd>

<dt><a name="1543369"> </a><code>&rarr;  <i>rP</i></code></dt>
<dd><a name="1543370"> </a>A pointer to a <a href="UI_Rectangle.html#994219"><code>RectangleType</code></a> to use for bounds.</dd>

</dl>
<h4>
  <a name="1543371"> </a>Returns 
</h4>

<p><a name="1543372"> </a>Nothing.</p>

<h3 class="hbH3">
  <a name="1617695"> </a>WinStartThreadUI Function <a href="#1160850"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="1617697"> </a>Purpose 
</h4>

<p><a name="1617698"> </a>Starts the user interface context for a thread. </p>
<h4>
  <a name="1617699"> </a>Declared In 
</h4>
<code>Window.h<a name="1617700"> </a></code><h4>
  <a name="1617701"> </a>Prototype 
</h4>
<pre class="proto"><a name="1617702"></a>status_t WinStartThreadUI (
   void
)
</pre>
<h4>
  <a name="1617703"> </a>Parameters 
</h4>

<p><a name="1617704"> </a>None.</p>
<h4>
  <a name="1617705"> </a>Returns 
</h4>

<p><a name="1617706"> </a><code>errNone</code> upon success, or <code>sysErrNoFreeRAM</code> if an error occurs. </p>
<h4>
  <a name="1617707"> </a>Comments 
</h4>

<p><a name="1617753"> </a>Call this function from a thread spawned in your program if you want that thread to display a user interface. All of the windows that you create to display inside of this thread must be updated-based windows. </p>

<p><a name="1617773"> </a>Nested calls to <code>WinStartThreadUI()</code> are allowed. </p>
<h4>
  <a name="1617709"> </a>See Also 
</h4>

<p><a name="1617710"> </a><a href="UI_Window.html#1617340"><code>WinFinishThreadUI()</code></a></p>

<h3 class="hbH3">
  <a name="1543404"> </a>WinUnscaleCoord Function <a href="#1160850"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="1543406"> </a>Purpose 
</h4>

<p><a name="1543407"> </a>Converts a single coordinate from the active coordinate system to the standard coordinate system.</p>
<h4>
  <a name="1543408"> </a>Declared In 
</h4>
<code>Window.h<a name="1543409"> </a></code><h4>
  <a name="1543410"> </a>Prototype 
</h4>
<pre class="proto"><a name="1543411"></a>Coord WinUnscaleCoord (
   Coord <code class="par">coord</code>,
   Boolean <code class="par">ceiling</code>
)
</pre>
<h4>
  <a name="1543412"> </a>Parameters 
</h4>

<dl>
<dt><a name="1543413"> </a><code>&rarr;  <i>coord</i></code></dt>
<dd><a name="1543414"> </a>A coordinate in the active coordinate system.</dd>

<dt><a name="1543415"> </a><code>&rarr;  <i>ceiling</i></code></dt>
<dd><a name="1543416"> </a>Pass <code>true</code> to round up, <code>false</code> to truncate the fractional part when scaling.</dd>

</dl>
<h4>
  <a name="1543417"> </a>Returns 
</h4>

<p><a name="1543418"> </a>The coordinate scaled to the standard coordinate system.</p>
<h4>
  <a name="1543419"> </a>Comments 
</h4>

<p><a name="1767532"> </a>This function converts a coordinate by dividing it by the coordinate scaling factor. What happens next depends upon the value of <code>ceiling</code>:</p>

<p><a name="1767533"> </a>if <code>ceiling</code> == true {</p>

<p><a name="1767534"> </a>   use <code>lfloorf()</code> function when scaleFactor &gt; 1</p>

<p><a name="1767535"> </a>   use <code>lceilf()</code> function when scaleFactor &lt; 1</p>

<p><a name="1767536"> </a>else</p>

<p><a name="1767537"> </a>   use <code>lceilf()</code> function when scaleFactor &gt; 1</p>

<p><a name="1767538"> </a>   use <code>lfloorf()</code> function when scaleFactor &lt; 1</p>

<p><a name="1767539"> </a>}</p>

<p><a name="1767540"> </a>The objective of this algorithm is to ensure that for any <code>Coord</code>, <code>Point</code>, or <code>Rectangle</code> "x", x = unscaled(scaled(x)). </p>

<p><a name="1543421"> </a>If the active coordinate system is <code>kCoordinatesStandard</code>, the returned coordinate is equal to the supplied coordinate.</p>
<h4>
  <a name="1543422"> </a>See Also 
</h4>

<p><a name="1543429"> </a><a href="UI_Window.html#1535889"><code>WinScaleCoord()</code></a>, <a href="UI_Window.html#1543435"><code>WinUnscalePoint()</code></a>, <a href="UI_Window.html#1543466"><code>WinUnscaleRectangle()</code></a></p>

<h3 class="hbH3">
  <a name="1543435"> </a>WinUnscalePoint Function <a href="#1160850"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="1543437"> </a>Purpose 
</h4>

<p><a name="1543438"> </a>Converts a point from the active coordinate system to the standard coordinate system.</p>
<h4>
  <a name="1543439"> </a>Declared In 
</h4>
<code>Window.h<a name="1543440"> </a></code><h4>
  <a name="1543441"> </a>Prototype 
</h4>
<pre class="proto"><a name="1543442"></a>void WinUnscalePoint (
   PointType <code class="par">*pointP</code>,
   Boolean <code class="par">ceiling</code>
)
</pre>
<h4>
  <a name="1543443"> </a>Parameters 
</h4>

<dl>
<dt><a name="1543444"> </a><code>&harr;  <i>pointP</i></code></dt>
<dd><a name="1543445"> </a>A pointer to a <code>PointType</code> structure that, before the call, should contain a point's coordinates using the active coordinate system. After this function is called the <code>PointType</code> structure contains the coordinates of the point scaled to the standard coordinate system.</dd>

<dt><a name="1543446"> </a><code>&rarr;  <i>ceiling</i></code></dt>
<dd><a name="1543447"> </a>Pass <code>true</code> to round up, <code>false</code> to truncate the fractional part when scaling.</dd>

</dl>
<h4>
  <a name="1543448"> </a>Returns 
</h4>

<p><a name="1543449"> </a>Nothing. The coordinates of the point indicated by <code class="par">pointP</code> are converted to the standard coordinate system.</p>
<h4>
  <a name="1543450"> </a>Comments 
</h4>

<p><a name="1769471"> </a>This function converts a point by dividing its x and y coordinates by the coordinate scaling factor. What happens next depends upon the value of <code>ceiling</code>:</p>

<p><a name="1769472"> </a>if <code>ceiling</code> == true {</p>

<p><a name="1769473"> </a>   use <code>lfloorf()</code> function when scaleFactor &gt; 1</p>

<p><a name="1769474"> </a>   use <code>lceilf()</code> function when scaleFactor &lt; 1</p>

<p><a name="1769475"> </a>else</p>

<p><a name="1769476"> </a>   use <code>lceilf()</code> function when scaleFactor &gt; 1</p>

<p><a name="1769477"> </a>   use <code>lfloorf()</code> function when scaleFactor &lt; 1</p>

<p><a name="1769478"> </a>}</p>

<p><a name="1769479"> </a>The objective of this algorithm is to ensure that for any <code>Coord</code>, <code>Point</code>, or <code>Rectangle</code> "x", x = unscaled(scaled(x)). </p>

<p><a name="1543451"> </a>If the active coordinate system is <code>kCoordinatesStandard</code>, <code class="par">pointP</code> is not changed by this function.</p>
<h4>
  <a name="1543453"> </a>See Also 
</h4>

<p><a name="1543460"> </a><a href="UI_Window.html#1535921"><code>WinScalePoint()</code></a>, <a href="UI_Window.html#1543404"><code>WinUnscaleCoord()</code></a>, <a href="UI_Window.html#1543466"><code>WinUnscaleRectangle()</code></a></p>

<h3 class="hbH3">
  <a name="1543466"> </a>WinUnscaleRectangle Function <a href="#1160850"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="1543468"> </a>Purpose 
</h4>

<p><a name="1543469"> </a>Converts a rectangle from the active coordinate system to the standard coordinate system.</p>
<h4>
  <a name="1543470"> </a>Declared In 
</h4>
<code>Window.h<a name="1543471"> </a></code><h4>
  <a name="1543472"> </a>Prototype 
</h4>
<pre class="proto"><a name="1543473"></a>void WinUnscaleRectangle (
   RectangleType <code class="par">*rectP</code>
)
</pre>
<h4>
  <a name="1543474"> </a>Parameters 
</h4>

<dl>
<dt><a name="1543475"> </a><code>&harr;  <i>rectP</i></code></dt>
<dd><a name="1543476"> </a>A pointer to a <a href="UI_Rectangle.html#994219"><code>RectangleType</code></a> structure that, before the call, should contain a rectangle's coordinates using the active coordinate system. After this function is called the <code>RectangleType</code> structure contains the coordinates of the rectangle scaled to the standard coordinate system.</dd>

</dl>
<h4>
  <a name="1543477"> </a>Returns 
</h4>

<p><a name="1543478"> </a>Nothing. The coordinates of the rectangle indicated by <code class="par">rectP </code>are converted to the standard coordinate system.</p>
<h4>
  <a name="1543479"> </a>Comments 
</h4>

<p><a name="1543480"> </a>This function scales the rectangle's <code>topLeft</code> and <code>extent</code> points by dividing their <code>x</code> and <code>y</code> coordinates by the coordinate scaling factor. All values are then truncated, but if either <code>topLeft.x</code> or <code>extent.x</code> had a fractional part, <code>extent.x</code> is incremented by 1 (and, similarly, if either <code>topLeft.y</code> or <code>extent.y</code> had a fractional part, <code>extent.y</code> is incremented by 1).</p>

<p><a name="1543481"> </a>If the active coordinate system is <code>kCoordinatesStandard</code>, <code class="par">rectP</code> is not changed by this function.</p>
<h4>
  <a name="1543482"> </a>See Also 
</h4>

<p><a name="1604887"> </a><a href="UI_Window.html#1535955"><code>WinScaleRectangle()</code></a>, <a href="UI_Window.html#1543404"><code>WinUnscaleCoord()</code></a>, <a href="UI_Window.html#1543435"><code>WinUnscalePoint()</code></a></p>

<h3 class="hbH3">
  <a name="1604893"> </a>WinValidateHandle Function <a href="#1160850"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="1543497"> </a>Purpose 
</h4>

<p><a name="1543498"> </a>Validates a window handle.</p>
<h4>
  <a name="1543499"> </a>Declared In 
</h4>
<code>Window.h<a name="1543500"> </a></code><h4>
  <a name="1543501"> </a>Prototype 
</h4>
<pre class="proto"><a name="1543502"></a>Boolean WinValidateHandle (
   WinHandle <code class="par">winHandle</code>
)
</pre>
<h4>
  <a name="1543503"> </a>Parameters 
</h4>

<dl>
<dt><a name="1543504"> </a><code>&rarr;  <i>winHandle</i></code></dt>
<dd><a name="1543505"> </a>The handle to be tested. </dd>

</dl>
<h4>
  <a name="1543506"> </a>Returns 
</h4>

<p><a name="1543507"> </a><code>true</code> if the specified handle references a window that exists, <code>false</code> otherwise. </p>
<h4>
  <a name="1543508"> </a>Comments 
</h4>

<p><a name="1543509"> </a>For debugging purposes only. Do not include this function in commercial applications. </p>
<h4>
  <a name="1543510"> </a>See Also 
</h4>

<p><a name="1543517"> </a><a href="UI_Form.html#1004377"><code>FrmValidatePtr()</code></a>, <a href="UI_Form.html#1002111"><code>FrmRemoveObject()</code></a></p>

<h3 class="hbH3">
  <a name="1543519"> </a>WinWindowToDisplayPt Function <a href="#1160850"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="1543521"> </a>Purpose 
</h4>

<p><a name="1543522"> </a>Converts a window-relative coordinate to a display-relative coordinate.</p>
<h4>
  <a name="1543523"> </a>Declared In 
</h4>
<code>Window.h<a name="1543524"> </a></code><h4>
  <a name="1543525"> </a>Prototype 
</h4>
<pre class="proto"><a name="1543526"></a>void WinWindowToDisplayPt (
   Coord <code class="par">*x</code>,
   Coord <code class="par">*y</code>
)
</pre>
<h4>
  <a name="1543527"> </a>Parameters 
</h4>

<dl>
<dt><a name="1543528"> </a><code>&harr;  <i>extentX</i></code></dt>
<dd><a name="1543529"> </a>A pointer to x coordinate to convert.</dd>

<dt><a name="1543530"> </a><code>&harr;  <i>extentY</i></code></dt>
<dd><a name="1543531"> </a>A pointer to y coordinate to convert.</dd>

</dl>
<h4>
  <a name="1543532"> </a>Returns 
</h4>

<p><a name="1543533"> </a>Nothing.</p>
<h4>
  <a name="1543534"> </a>Comments 
</h4>

<p><a name="1543535"> </a>The coordinate passed is assumed to be relative to the draw window.</p>
<h4>
  <a name="1543536"> </a>See Also 
</h4>

<p><a name="1543541"> </a><a href="UI_Window.html#1480922"><code>WinDisplayToWindowPt()</code></a> </p>

<h2 class="haH2">
  <a name="1474314"> </a>Window Drawing Functions and Macros <a href="#1160850"><span class="nav">^TOP^</span></a>
</h2>


<p><a name="1474373"> </a>This section lists and describes drawing-related functions implemented in the Window Manager. All of these functions work as expected in Palm OS Cobalt, but they are considered obsolete and replaced by the <a href="UI_GraphicContext.html#608590">"Graphics Context Reference"</a> drawing functions. The two types of drawing functions maintain separate draw states and should not be mixed. Use either the <code>Win.</code>.. drawing functions or the<code> Gc.</code>.. drawing functions. </p>

<h3 class="hbH3">
  <a name="1021501"> </a>WinClipRectangle Function <a href="#1160850"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="1021503"> </a>Purpose 
</h4>

<p><a name="1021504"> </a>Truncates the rectangle to make it fit within the clipping region of the current draw window.</p>
<h4>
  <a name="1021505"> </a>Declared In 
</h4>
<code>Window.h <a name="1021506"> </a></code><h4>
  <a name="1021507"> </a>Prototype 
</h4>
<pre class="proto"><a name="1021508"></a>void WinClipRectangle (
   RectangleType *<code class="par">rP</code>
)
</pre>
<h4>
  <a name="1021509"> </a>Parameters 
</h4>

<dl>
<dt><a name="1021510"> </a><code>&harr;  <i>rP</i></code></dt>
<dd><a name="1021511"> </a>A pointer to a <a href="UI_Rectangle.html#994219"><code>RectangleType</code></a> structure holding the rectangle to clip. The rectangle returned is the intersection of the rectangle passed and the clipping bounds of the draw window.</dd>

</dl>
<h4>
  <a name="1021512"> </a>Returns 
</h4>

<p><a name="1021513"> </a>Nothing.</p>
<h4>
  <a name="1021514"> </a>Comments 
</h4>

<p><a name="1021515"> </a>This function does not change the clipping rectangle of the window. To modify the window's clipping rectangle, use the <a href="UI_Window.html#1539836"><code>WinSetClip()</code></a> and <a href="UI_Window.html#1000947"><code>WinResetClip()</code></a> functions.</p>

<p><a name="1021522"> </a>The draw window is the window to which all drawing functions send their output. It is returned by <a href="UI_Window.html#1497142"><code>WinGetDrawWindow()</code></a>.</p>
<h4>
  <a name="1599249"> </a>Compatibility 
</h4>

<p><a name="1599250"> </a>Do not use this function if you are using the graphics context APIs. </p>
<h4>
  <a name="1599251"> </a>See Also 
</h4>

<p><a name="1146006"> </a><a href="UI_Window.html#1021540"><code>WinCopyRectangle()</code></a>, <a href="UI_Window.html#1028621"><code>WinDrawRectangle()</code></a>, <a href="UI_Window.html#1029842"><code>WinEraseRectangle()</code></a>, <a href="UI_Window.html#1492237"><code>WinGetClip()</code></a> </p>

<h3 class="hbH3">
  <a name="1021540"> </a>WinCopyRectangle Function <a href="#1160850"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="1021542"> </a>Purpose 
</h4>

<p><a name="1021543"> </a>Copies a rectangular region from one place to another (either between windows or within a single window).</p>
<h4>
  <a name="1021544"> </a>Declared In 
</h4>
<code>Window.h <a name="1021545"> </a></code><h4>
  <a name="1021546"> </a>Prototype 
</h4>
<pre class="proto"><a name="1021547"></a>void WinCopyRectangle (
   WinHandle <code class="par">srcWin</code>,
   WinHandle <code class="par">dstWin</code>,
   const RectangleType *<code class="par">srcRect</code>,
   Coord <code class="par">destX</code>,
   Coord <code class="par">destY</code>,
   WinDrawOperation <code class="par">mode</code>
)
</pre>
<h4>
  <a name="1021548"> </a>Parameters 
</h4>

<dl>
<dt><a name="1021549"> </a><code>&rarr;  <i>srcWin</i></code></dt>
<dd><a name="1021550"> </a>The window from which the rectangle is copied. If <code>NULL</code>, use the draw window. </dd>

<dt><a name="1021551"> </a><code>&rarr;  <i>dstWin</i></code></dt>
<dd><a name="1021552"> </a>The window to which the rectangle is copied. If <code>NULL</code>, use the draw window. </dd>

<dt><a name="1021553"> </a><code>&rarr;  <i>srcRect</i></code></dt>
<dd><a name="1021554"> </a>The bounds of the region to copy (see <a href="UI_Rectangle.html#994219"><code>RectangleType</code></a>).</dd>

<dt><a name="1021555"> </a><code>&rarr;  <i>destX</i></code></dt>
<dd><a name="1021556"> </a>The left bound of the rectangle in destination window.</dd>

<dt><a name="1021557"> </a><code>&rarr;  <i>destY</i></code></dt>
<dd><a name="1021558"> </a>The top bound of the rectangle in destination window.</dd>

<dt><a name="1021559"> </a><code>&rarr;  <i>mode</i></code></dt>
<dd><a name="1021560"> </a>Must be set to the <code>winPaint</code> transfer mode. </dd>

</dl>
<h4>
  <a name="1021564"> </a>Returns 
</h4>

<p><a name="1021565"> </a>Nothing.</p>
<h4>
  <a name="1021566"> </a>Comments 
</h4>

<p><a name="1021567"> </a>Copies the bits of the window inside the rectangle region. </p>

<p><a name="1021568"> </a>If the destination bitmap is compressed, the mode parameter must be <code>winPaint</code>, and the destination coordinates must be (0,0). If the width of the destination rectangle is less than 16 pixels or if the destination coordinates are not (0,0), then this function turns off compression for the destination bitmap. Normally, you do not copy to a compressed bitmap. Instead, you copy to an uncompressed bitmap and compress it afterwards.</p>

<p><a name="1395996"> </a>This function does not work if the source window is an update-based window. It is best not to use this function to copy between two on-screen rectangles. It is better to copy your data to an off-screen window to capture data and then copy that onto the screen as needed. </p>
<h4>
  <a name="1726786"> </a>Compatibility 
</h4>

<p><a name="1726792"> </a>In earlier releases of Palm OS, this function used the transfer mode passed as a parameter. In Palm OS Cobalt, you must pass <code>winPaint</code> as the transfer mode. </p>
<h4>
  <a name="1021569"> </a>See Also 
</h4>

<p><a name="1021573"> </a><a href="UI_Window.html#1026915"><code>WinDrawBitmap()</code></a> </p>

<h3 class="hbH3">
  <a name="1026915"> </a>WinDrawBitmap Function <a href="#1160850"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="1026917"> </a>Purpose 
</h4>

<p><a name="1026918"> </a>Draws a bitmap at the given coordinates in <code>winPaint</code> mode (see <a href="UI_Window.html#1094199"><code>WinDrawOperation</code></a> for mode details).</p>
<h4>
  <a name="1026922"> </a>Declared In 
</h4>
<code>Window.h <a name="1026923"> </a></code><h4>
  <a name="1026924"> </a>Prototype 
</h4>
<pre class="proto"><a name="1026925"></a>void WinDrawBitmap (
   BitmapPtr <code class="par">bitmapP</code>,
   Coord <code class="par">x</code>,
   Coord <code class="par">y</code>
)
</pre>
<h4>
  <a name="1026926"> </a>Parameters 
</h4>

<dl>
<dt><a name="1026927"> </a><code>&rarr;  <i>bitmapP</i></code></dt>
<dd><a name="1026928"> </a>A pointer to a bitmap.</dd>

<dt><a name="1026929"> </a><code>&rarr;  <i>x</i></code></dt>
<dd><a name="1026930"> </a>The x coordinate of the top-left corner.</dd>

<dt><a name="1026931"> </a><code>&rarr;  <i>y</i></code></dt>
<dd><a name="1026932"> </a>The y coordinate of the top-left corner.</dd>

</dl>
<h4>
  <a name="1026933"> </a>Returns 
</h4>

<p><a name="1026934"> </a>Nothing.</p>
<h4>
  <a name="1026935"> </a>Comments 
</h4>

<p><a name="1026936"> </a>If the bitmap has multiple depths (is a bitmap family), the closest match less than or equal to the current draw window depth is used. If such a bitmap does not exist, the bitmap with the closest match greater than the draw window depth is used. </p>

<p><a name="1584065"> </a>If the bitmap has its own color table, color conversion to the draw window color table will be applied. This color conversion is slow and not recommended. </p>
<h4>
  <a name="1445681"> </a>Compatibility 
</h4>

<p><a name="1445698"> </a>Do not use this function in conjunction with the graphics context. Use <a href="UI_Window.html#1709837"><code>WinDrawBitmapHandle()</code></a>, <a href="UI_GraphicContext.html#1170306"><code>GcDrawBitmapAt()</code></a>, <a href="UI_GraphicContext.html#1170627"><code>GcDrawRawBitmapAt()</code></a>, or <a href="UI_GraphicContext.html#1120182"><code>GcPaintBitmap()</code></a> instead. </p>
<h4>
  <a name="1026945"> </a>See Also 
</h4>

<p><a name="1026949"> </a><a href="UI_Window.html#1029842"><code>WinEraseRectangle()</code></a> </p>

<h3 class="hbH3">
  <a name="1709837"> </a>WinDrawBitmapHandle Function <a href="#1160850"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="1709839"> </a>Purpose 
</h4>

<p><a name="1709840"> </a>Draws a bitmap at the coordinates specified, using a <a href="UI_GraphicContext.html#1169790"><code>GcBitmapHandle</code></a>. </p>
<h4>
  <a name="1709841"> </a>Declared In 
</h4>
<code>GcRender.h<a name="1709842"> </a></code><h4>
  <a name="1709843"> </a>Prototype 
</h4>
<pre class="proto"><a name="1709844"></a>void WinDrawBitmapHandle (
   GcBitmapHandle <code class="par">bitmapHandle</code>,
   Coord <code class="par">x</code>,
   Coord <code class="par">y</code>
)
</pre>
<h4>
  <a name="1709845"> </a>Parameters 
</h4>

<dl>
<dt><a name="1709846"> </a><code>&rarr;  <i>bitmapHandle</i></code></dt>
<dd><a name="1720775"> </a>The bitmap Use <a href="UI_Form.html#1329509"><code>FrmGetBitmapHandle()</code></a> or <a href="UI_GraphicContext.html#1170870"><code>GcLoadBitmap()</code></a> to obtain a <code>GcBitmapHandle</code> to a bitmap.</dd>

<dt><a name="1720698"> </a><code>&rarr;  <i>x</i></code></dt>
<dd><a name="1720789"> </a>The x coordinate of the top-left corner.</dd>

<dt><a name="1709848"> </a><code>&rarr;  <i>y</i></code></dt>
<dd><a name="1720797"> </a>The y coordinate of the top-left corner.</dd>

</dl>
<h4>
  <a name="1709850"> </a>Returns 
</h4>

<p><a name="1720805"> </a>Nothing.</p>
<h4>
  <a name="1709852"> </a>Comments 
</h4>

<p><a name="1709853"> </a>A <code>GcBitmapHandle</code> stores a bitmap that has been converted to draw to the screen more efficiently than a <code>BitmapType</code>. Use this function if you want the efficiency of the <code>GcBitmapHandle</code> type but do not want to convert all of your drawing code to use the new drawing model. </p>

<p><a name="1724310"> </a>This function behaves exactly like <a href="UI_Window.html#1026915"><code>WinDrawBitmap()</code></a> except that it ignores the current scaling mode. Scaling for <code>GcBitmapHandle</code> bitmaps is controlled when the <code>GcBitmapHandle</code> is created. </p>

<h3 class="hbH3">
  <a name="1026950"> </a>WinDrawChar Function <a href="#1160850"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="1026952"> </a>Purpose 
</h4>

<p><a name="1026953"> </a>Draws the specified character in the draw window.</p>
<h4>
  <a name="1026954"> </a>Declared In 
</h4>
<code>Window.h <a name="1026955"> </a></code><h4>
  <a name="1026956"> </a>Prototype 
</h4>
<pre class="proto"><a name="1026957"></a>void WinDrawChar (
   wchar32_t <code class="par">theChar</code>,
   Coord <code class="par">x</code>,
   Coord <code class="par">y</code>
)
</pre>
<h4>
  <a name="1026958"> </a>Parameters 
</h4>

<dl>
<dt><a name="1026959"> </a><code>&rarr;  <i>theChar</i></code></dt>
<dd><a name="1026960"> </a>The character to draw. This may be either a single-byte character or a multi-byte character. </dd>

<dt><a name="1026961"> </a><code>&rarr;  <i>x</i></code></dt>
<dd><a name="1026962"> </a>The x coordinate of the location where the character is to be drawn (left bound).</dd>

<dt><a name="1026963"> </a><code>&rarr;  <i>y</i></code></dt>
<dd><a name="1026964"> </a>The y coordinate of the location where the character is to be drawn (top bound).</dd>

</dl>
<h4>
  <a name="1026965"> </a>Returns 
</h4>

<p><a name="1026966"> </a>Nothing.</p>
<h4>
  <a name="1026967"> </a>Comments 
</h4>

<p><a name="1026971"> </a>Before calling this function, call <a href="UI_Window.html#1004170"><code>WinSetUnderlineMode()</code></a> and <a href="UI_Font.html#995852"><code>FntSetFont()</code></a> to set the desired underline and font to draw the characters. </p>

<p><a name="1026978"> </a>This function differs from <a href="UI_Window.html#999742"><code>WinPaintChar()</code></a> in that this function always uses <code>winPaint</code> mode (see <a href="UI_Window.html#1094199"><code>WinDrawOperation</code></a>). This means the on bits are drawn in the text color, the off bits are in the background color, and underlines are in the foreground color. <code>WinPaintChar()</code> uses the current drawing state transfer mode instead of <code>winPaint</code>. </p>
<h4>
  <a name="1445723"> </a>Compatibility 
</h4>

<p><a name="1764888"> </a>The <code>winInvert</code> drawing mode does not work when you draw text. If you try to use it, nothing is drawn to the screen. </p>

<p><a name="1445729"> </a>Do not use this function in conjunction with the graphics context APIs. Use <a href="UI_GraphicContext.html#1196638"><code>GcDrawTextAt()</code></a> instead. Note that <code>GcDrawTextAt()</code> uses the y value as the font baseline whereas <code>WinDrawChar()</code> uses the y value as the top of the character. </p>
<h4>
  <a name="1026991"> </a>See Also 
</h4>

<p><a name="1027001"> </a><a href="UI_Window.html#1027460"><code>WinDrawChars()</code></a>, <a href="UI_Window.html#1028455"><code>WinDrawInvertedChars()</code></a>, <a href="UI_Window.html#1029074"><code>WinDrawTruncChars()</code></a>, <a href="UI_Window.html#1029680"><code>WinEraseChars()</code></a>, <a href="UI_Window.html#999081"><code>WinInvertChars()</code></a>, <a href="UI_Window.html#999796"><code>WinPaintChars()</code></a></p>

<h3 class="hbH3">
  <a name="1027460"> </a>WinDrawChars Function <a href="#1160850"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="1027462"> </a>Purpose 
</h4>

<p><a name="1027463"> </a>Draws the specified characters in the draw window. </p>
<h4>
  <a name="1027464"> </a>Declared In 
</h4>
<code>Window.h <a name="1027465"> </a></code><h4>
  <a name="1027466"> </a>Prototype 
</h4>
<pre class="proto"><a name="1027467"></a>void WinDrawChars (
   const char *<code class="par">chars</code>,
   int16_t <code class="par">len</code>,
   Coord <code class="par">x</code>,
   Coord <code class="par">y</code>
)
</pre>
<h4>
  <a name="1027468"> </a>Parameters 
</h4>

<dl>
<dt><a name="1027469"> </a><code>&rarr;  <i>chars</i></code></dt>
<dd><a name="1027470"> </a>A pointer to the characters to draw.</dd>

<dt><a name="1027471"> </a><code>&rarr;  <i>len</i></code></dt>
<dd><a name="1027472"> </a>The length in bytes of the characters to draw.</dd>

<dt><a name="1027473"> </a><code>&rarr;  <i>x</i></code></dt>
<dd><a name="1027474"> </a>The x coordinate of the first character to draw (left bound).</dd>

<dt><a name="1027475"> </a><code>&rarr;  <i>y</i></code></dt>
<dd><a name="1027476"> </a>The y coordinate of the first character to draw (top bound).</dd>

</dl>
<h4>
  <a name="1027477"> </a>Returns 
</h4>

<p><a name="1027478"> </a>Nothing.</p>
<h4>
  <a name="1027479"> </a>Comments 
</h4>

<p><a name="1027480"> </a>This function is useful for printing non-editable status or warning messages on the screen. </p>

<p><a name="1027484"> </a>Before calling this function, call <a href="UI_Window.html#1004170"><code>WinSetUnderlineMode()</code></a> and <a href="UI_Font.html#995852"><code>FntSetFont()</code></a> to set the desired underline and font to draw the characters. </p>

<p><a name="1027491"> </a>This function differs from <a href="UI_Window.html#999796"><code>WinPaintChars()</code></a> in that this function always uses <code>winPaint</code> mode (see <a href="UI_Window.html#1094199"><code>WinDrawOperation</code></a>). This means the on bits are drawn in the text color, the off bits are in the background color, and underlines are in the foreground color. <code>WinPaintChar()</code> uses the current drawing state transfer mode instead of <code>winPaint</code>. </p>
<h4>
  <a name="1445988"> </a>Compatibility 
</h4>

<p><a name="1764900"> </a>The <code>winInvert</code> drawing mode does not work when you draw text. If you try to use it, nothing is drawn to the screen. </p>

<p><a name="1445989"> </a>Do not use this function in conjunction with the graphics context APIs. Use <a href="UI_GraphicContext.html#1196638"><code>GcDrawTextAt()</code></a> instead. Note that <code>GcDrawTextAt()</code> uses the y value as the font baseline whereas <code>WinDrawChars()</code> uses the y value as the top of the character. </p>
<h4>
  <a name="1027495"> </a>See Also 
</h4>

<p><a name="1027505"> </a><a href="UI_Window.html#1026950"><code>WinDrawChar()</code></a>, <a href="UI_Window.html#1028455"><code>WinDrawInvertedChars()</code></a>, <a href="UI_Window.html#1029074"><code>WinDrawTruncChars()</code></a>, <a href="UI_Window.html#1029680"><code>WinEraseChars()</code></a>, <a href="UI_Window.html#999081"><code>WinInvertChars()</code></a>, <a href="UI_Window.html#999742"><code>WinPaintChar()</code></a> </p>

<h3 class="hbH3">
  <a name="1027898"> </a>WinDrawGrayLine Function <a href="#1160850"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="1027900"> </a>Purpose 
</h4>

<p><a name="1027901"> </a>Draws a dashed line in the draw window.</p>
<h4>
  <a name="1027902"> </a>Declared In 
</h4>
<code>Window.h <a name="1027903"> </a></code><h4>
  <a name="1027904"> </a>Prototype 
</h4>
<pre class="proto"><a name="1027905"></a>void WinDrawGrayLine (
   Coord <code class="par">x1</code>,
   Coord <code class="par">y1</code>,
   Coord <code class="par">x2</code>,
   Coord <code class="par">y2</code>
)
</pre>
<h4>
  <a name="1027906"> </a>Parameters 
</h4>

<dl>
<dt><a name="1027907"> </a><code>&rarr;  <i>x1</i></code></dt>
<dd><a name="1027908"> </a>The x coordinate of line start point.</dd>

<dt><a name="1027909"> </a><code>&rarr;  <i>y1</i></code></dt>
<dd><a name="1027910"> </a>The y coordinate of line start point.</dd>

<dt><a name="1027911"> </a><code>&rarr;  <i>x2</i></code></dt>
<dd><a name="1027912"> </a>The x coordinate of line endpoint.</dd>

<dt><a name="1027913"> </a><code>&rarr;  <i>y2</i></code></dt>
<dd><a name="1027914"> </a>The y coordinate of line endpoint.</dd>

</dl>
<h4>
  <a name="1027915"> </a>Returns 
</h4>

<p><a name="1027916"> </a>Nothing.</p>
<h4>
  <a name="1027917"> </a>Comments 
</h4>

<p><a name="1027918"> </a>This routine does not draw in the gray color; it draws with alternating foreground and background pixels. That is, it uses the <code>grayPattern</code> pattern type. </p>
<h4>
  <a name="1446095"> </a>Compatibility 
</h4>

<p><a name="1446096"> </a>Do not use this function in conjunction with the graphics context APIs. Use <a href="UI_GraphicContext.html#1118074"><code>GcLineTo()</code></a> instead. </p>
<h4>
  <a name="1027919"> </a>See Also 
</h4>

<p><a name="1027932"> </a><a href="UI_Window.html#1028506"><code>WinDrawLine()</code></a>, <a href="UI_Window.html#1029727"><code>WinEraseLine()</code></a>, <a href="UI_Window.html#1145105"><code>WinFillLine()</code></a>, <a href="UI_Window.html#999137"><code>WinInvertLine()</code></a>, <a href="UI_Window.html#999872"><code>WinPaintLine()</code></a>, <a href="UI_Window.html#999945"><code>WinPaintLines()</code></a></p>

<h3 class="hbH3">
  <a name="1027939"> </a>WinDrawGrayRectangleFrame Function <a href="#1160850"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="1027941"> </a>Purpose 
</h4>

<p><a name="1027942"> </a>Draws a gray rectangular frame in the draw window.</p>
<h4>
  <a name="1027943"> </a>Declared In 
</h4>
<code>Window.h <a name="1027944"> </a></code><h4>
  <a name="1027945"> </a>Prototype 
</h4>
<pre class="proto"><a name="1027946"></a>void WinDrawGrayRectangleFrame (
   FrameType <code class="par">frame</code>,
   const RectangleType *<code class="par">rP</code>
)
</pre>
<h4>
  <a name="1027947"> </a>Parameters 
</h4>

<dl>
<dt><a name="1027948"> </a><code>&rarr;  <i>frame</i></code></dt>
<dd><a name="1027952"> </a>The type of frame to draw (see <a href="UI_Window.html#1610364"><code>FrameType</code></a>).</dd>

<dt><a name="1027953"> </a><code>&rarr;  <i>rP</i></code></dt>
<dd><a name="1027954"> </a>A pointer to the rectangle to frame (see <a href="UI_Rectangle.html#994219"><code>RectangleType</code></a>).</dd>

</dl>
<h4>
  <a name="1027955"> </a>Returns 
</h4>

<p><a name="1027956"> </a>Nothing.</p>
<h4>
  <a name="1027957"> </a>Comments 
</h4>

<p><a name="1027958"> </a>This routine does not draw in the gray color; it draws with alternating foreground and background pixels. The standard gray pattern is not used by this routine; rather, the frame is drawn so that the top-left pixel of the frame is always on.</p>
<h4>
  <a name="1446268"> </a>Compatibility 
</h4>

<p><a name="1764904"> </a>The <code>winInvert</code> and <code>winSwap</code> drawing modes do not work when you draw a rectangle frame or unfilled rectangle. Nothing is drawn to the screen. </p>

<p><a name="1446269"> </a>Do not use this function in conjunction with the graphics context APIs. Use <a href="UI_GraphicContext.html#1122410"><code>GcRect()</code></a> instead. Note that <code>GcRect()</code> specifies a rectangle's bounds differently than a <code>RectangleType</code> structure does. </p>
<h4>
  <a name="1027959"> </a>See Also 
</h4>

<p><a name="1027966"> </a><a href="UI_Window.html#1570711"><code>WinDrawRectangleFrame()</code></a>, <a href="UI_Window.html#1029878"><code>WinEraseRectangleFrame()</code></a>, <a href="UI_Window.html#1497232"><code>WinGetFramesRectangle()</code></a>, <a href="UI_Window.html#999326"><code>WinInvertRectangleFrame()</code></a>, <a href="UI_Window.html#1000125"><code>WinPaintRectangleFrame()</code></a></p>

<h3 class="hbH3">
  <a name="1028455"> </a>WinDrawInvertedChars Function <a href="#1160850"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="1028457"> </a>Purpose 
</h4>

<p><a name="1028458"> </a>Draws the specified characters inverted (background color) in the draw window. </p>
<h4>
  <a name="1028459"> </a>Declared In 
</h4>
<code>Window.h <a name="1028460"> </a></code><h4>
  <a name="1028461"> </a>Prototype 
</h4>
<pre class="proto"><a name="1028462"></a>void WinDrawInvertedChars (
   const char *<code class="par">chars</code>,
   int16_t <code class="par">len</code>,
   Coord <code class="par">x</code>,
   Coord <code class="par">y</code>
)
</pre>
<h4>
  <a name="1028463"> </a>Parameters 
</h4>

<dl>
<dt><a name="1028464"> </a><code>&rarr;  <i>chars</i></code></dt>
<dd><a name="1028465"> </a>A pointer to the characters to draw.</dd>

<dt><a name="1028466"> </a><code>&rarr;  <i>len</i></code></dt>
<dd><a name="1028467"> </a>The length in bytes of the characters to draw.</dd>

<dt><a name="1028468"> </a><code>&rarr;  <i>x</i></code></dt>
<dd><a name="1028469"> </a>The x coordinate of the first character to draw (left bound).</dd>

<dt><a name="1028470"> </a><code>&rarr;  <i>y</i></code></dt>
<dd><a name="1028471"> </a>The y coordinate of the first character to draw (top bound).</dd>

</dl>
<h4>
  <a name="1028472"> </a>Returns 
</h4>

<p><a name="1028473"> </a>Nothing.</p>
<h4>
  <a name="1028474"> </a>Compatibility 
</h4>

<p><a name="1028476"> </a>This function is deprecated in Palm OS Cobalt.</p>
<h4>
  <a name="1028483"> </a>See Also 
</h4>

<p><a name="1028493"> </a><a href="UI_Window.html#1026950"><code>WinDrawChar()</code></a>, <a href="UI_Window.html#1027460"><code>WinDrawChars()</code></a>, <a href="UI_Window.html#1029074"><code>WinDrawTruncChars()</code></a>, <a href="UI_Window.html#1029680"><code>WinEraseChars()</code></a>, <a href="UI_Window.html#999081"><code>WinInvertChars()</code></a>, <a href="UI_Window.html#999742"><code>WinPaintChar()</code></a>, <a href="UI_Window.html#999796"><code>WinPaintChars()</code></a></p>

<h3 class="hbH3">
  <a name="1028506"> </a>WinDrawLine Function <a href="#1160850"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="1028508"> </a>Purpose 
</h4>

<p><a name="1028509"> </a>Draws a line in the draw window using the current foreground color.</p>
<h4>
  <a name="1028510"> </a>Declared In 
</h4>
<code>Window.h <a name="1028511"> </a></code><h4>
  <a name="1028512"> </a>Prototype 
</h4>
<pre class="proto"><a name="1028513"></a>void WinDrawLine (
   Coord <code class="par">x1</code>,
   Coord <code class="par">y1</code>,
   Coord <code class="par">x2</code>,
   Coord <code class="par">y2</code>
)
</pre>
<h4>
  <a name="1028514"> </a>Parameters 
</h4>

<dl>
<dt><a name="1028515"> </a><code>&rarr;  <i>x1</i></code></dt>
<dd><a name="1028516"> </a>The x coordinate of line start point.</dd>

<dt><a name="1028517"> </a><code>&rarr;  <i>y1</i></code></dt>
<dd><a name="1028518"> </a>The y coordinate of line start point.</dd>

<dt><a name="1028519"> </a><code>&rarr;  <i>x2</i></code></dt>
<dd><a name="1028520"> </a>The x coordinate of line endpoint.</dd>

<dt><a name="1028521"> </a><code>&rarr;  <i>y2</i></code></dt>
<dd><a name="1028522"> </a>The y coordinate of line endpoint.</dd>

</dl>
<h4>
  <a name="1028523"> </a>Returns 
</h4>

<p><a name="1028524"> </a>Nothing.</p>
<h4>
  <a name="1028525"> </a>Comments 
</h4>

<p><a name="1028529"> </a>This function differs from <a href="UI_Window.html#999872"><code>WinPaintLine()</code></a> in that it always uses <code>winPaint</code> mode (see <a href="UI_Window.html#1094199"><code>WinDrawOperation</code></a>). <code>WinPaintLine()</code> uses the current drawing state transfer mode instead of <code>winPaint</code>. </p>
<h4>
  <a name="1446402"> </a>Compatibility 
</h4>

<p><a name="1446403"> </a>Do not use this function in conjunction with the graphics context APIs. Use <a href="UI_GraphicContext.html#1118074"><code>GcLineTo()</code></a> instead. </p>
<h4>
  <a name="1028533"> </a>See Also 
</h4>

<p><a name="1028543"> </a><a href="UI_Window.html#1027898"><code>WinDrawGrayLine()</code></a>, <a href="UI_Window.html#1029727"><code>WinEraseLine()</code></a>, <a href="UI_Window.html#1145105"><code>WinFillLine()</code></a>, <a href="UI_Window.html#999137"><code>WinInvertLine()</code></a>, <a href="UI_Window.html#999872"><code>WinPaintLine()</code></a>, <a href="UI_Window.html#999945"><code>WinPaintLines()</code></a></p>

<h3 class="hbH3">
  <a name="1028592"> </a>WinDrawPixel Function <a href="#1160850"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="1028594"> </a>Purpose 
</h4>

<p><a name="1028595"> </a>Draws a pixel in the draw window using the current foreground color.</p>
<h4>
  <a name="1028596"> </a>Declared In 
</h4>
<code>Window.h <a name="1028597"> </a></code><h4>
  <a name="1028598"> </a>Prototype 
</h4>
<pre class="proto"><a name="1028599"></a>void WinDrawPixel (
   Coord <code class="par">x</code>,
   Coord <code class="par">y</code>
)
</pre>
<h4>
  <a name="1028600"> </a>Parameters 
</h4>

<dl>
<dt><a name="1028601"> </a><code>&rarr;  <i>x</i></code></dt>
<dd><a name="1028602"> </a>A pointer to the x coordinate of a pixel.</dd>

<dt><a name="1028603"> </a><code>&rarr;  <i>y</i></code></dt>
<dd><a name="1028604"> </a>A pointer to the y coordinate of a pixel.</dd>

</dl>
<h4>
  <a name="1028605"> </a>Returns 
</h4>

<p><a name="1028606"> </a>Nothing. </p>
<h4>
  <a name="1446540"> </a>Compatibility 
</h4>

<p><a name="1446541"> </a>Do not use this function in conjunction with the graphics context APIs. Use <a href="UI_GraphicContext.html#1118074"><code>GcLineTo()</code></a> instead. </p>
<h4>
  <a name="1145167"> </a>See Also 
</h4>

<p><a name="1028617"> </a><a href="UI_Window.html#1029808"><code>WinErasePixel()</code></a>, <a href="UI_Window.html#999210"><code>WinInvertPixel()</code></a>, <a href="UI_Window.html#999989"><code>WinPaintPixel()</code></a>, <a href="UI_Window.html#1000033"><code>WinPaintPixels()</code></a></p>

<h3 class="hbH3">
  <a name="1028621"> </a>WinDrawRectangle Function <a href="#1160850"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="1028623"> </a>Purpose 
</h4>

<p><a name="1028624"> </a>Draws a rectangle in the draw window using the current foreground color.</p>
<h4>
  <a name="1028625"> </a>Declared In 
</h4>
<code>Window.h <a name="1028626"> </a></code><h4>
  <a name="1028627"> </a>Prototype 
</h4>
<pre class="proto"><a name="1028628"></a>void WinDrawRectangle (
   const RectangleType *<code class="par">rP</code>,
   uint16_t <code class="par">cornerDiam</code>
)
</pre>
<h4>
  <a name="1028629"> </a>Parameters 
</h4>

<dl>
<dt><a name="1028630"> </a><code>&rarr;  <i>rP</i></code></dt>
<dd><a name="1028631"> </a>A pointer to the rectangle to draw (see <a href="UI_Rectangle.html#994219"><code>RectangleType</code></a>).</dd>

<dt><a name="1028632"> </a><code>&rarr;  <i>cornerDiam</i></code></dt>
<dd><a name="1028633"> </a>The radius of rounded corners. Specify zero for square corners.</dd>

</dl>
<h4>
  <a name="1028634"> </a>Returns 
</h4>

<p><a name="1028635"> </a>Nothing.</p>
<h4>
  <a name="1028636"> </a>Comments 
</h4>

<p><a name="1028637"> </a>The <code class="par">cornerDiam</code> parameter specifies the radius of four imaginary circles used to form the rounded corners. An imaginary circle is placed within each corner tangent to the rectangle on two sides.</p>

<p><a name="1028641"> </a>This function differs from <a href="UI_Window.html#1000081"><code>WinPaintRectangle()</code></a> in that it always uses <code>winPaint</code> mode (see <a href="UI_Window.html#1094199"><code>WinDrawOperation</code></a>). <code>WinPaintRectangle()</code> uses the current drawing state transfer mode instead of <code>winPaint</code>. </p>
<h4>
  <a name="1446574"> </a>Compatibility 
</h4>

<p><a name="1446575"> </a>Do not use this function in conjunction with the graphics context APIs. Use <a href="UI_GraphicContext.html#1122410"><code>GcRect()</code></a> instead. Note that <code>GcRect()</code> specifies a rectangle's bounds differently than a <code>RectangleType</code> structure does. </p>
<h4>
  <a name="1570699"> </a>See Also 
</h4>

<p><a name="1570706"> </a><a href="UI_Window.html#1029842"><code>WinEraseRectangle()</code></a>, <a href="UI_Window.html#1029991"><code>WinFillRectangle()</code></a>, <a href="UI_Window.html#999254"><code>WinInvertRectangle()</code></a></p>

<h3 class="hbH3">
  <a name="1570711"> </a>WinDrawRectangleFrame Function <a href="#1160850"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="1029031"> </a>Purpose 
</h4>

<p><a name="1029032"> </a>Draws a rectangular frame in the draw window using the current foreground color.</p>
<h4>
  <a name="1029034"> </a>Declared In 
</h4>
<code>Window.h <a name="1029035"> </a></code><h4>
  <a name="1029036"> </a>Prototype 
</h4>
<pre class="proto"><a name="1029037"></a>void WinDrawRectangleFrame (
   FrameType <code class="par">frame</code>,
   const RectangleType *<code class="par">rP</code>
)
</pre>
<h4>
  <a name="1029038"> </a>Parameters 
</h4>

<dl>
<dt><a name="1029039"> </a><code>&rarr;  <i>frame</i></code></dt>
<dd><a name="1029043"> </a>The type of frame to draw (see <a href="UI_Window.html#1610364"><code>FrameType</code></a>).</dd>

<dt><a name="1029044"> </a><code>&rarr;  <i>rP</i></code></dt>
<dd><a name="1029045"> </a>A pointer to the rectangle to frame (see <a href="UI_Rectangle.html#994219"><code>RectangleType</code></a>).</dd>

</dl>
<h4>
  <a name="1029046"> </a>Returns 
</h4>

<p><a name="1029047"> </a>Nothing.</p>
<h4>
  <a name="1029048"> </a>Comments 
</h4>

<p><a name="1029049"> </a>The frame is drawn outside the specified rectangle. </p>

<p><a name="1029056"> </a>This function differs from <a href="UI_Window.html#1000125"><code>WinPaintRectangleFrame()</code></a> in that it always uses <code>winPaint</code> mode (see <a href="UI_Window.html#1094199"><code>WinDrawOperation</code></a>). <code>WinPaintRectangleFrame()</code> uses the current drawing state transfer mode instead of <code>winPaint</code>. </p>
<h4>
  <a name="1446600"> </a>Compatibility 
</h4>

<p><a name="1764937"> </a>The <code>winInvert</code> and <code>winSwap</code> drawing modes do not work when you draw a rectangle frame or unfilled rectangle. Nothing is drawn to the screen. </p>

<p><a name="1446601"> </a>Do not use this function in conjunction with the graphics context APIs. Use <a href="UI_GraphicContext.html#1122410"><code>GcRect()</code></a> instead. Note that <code>GcRect()</code> specifies a rectangle's bounds differently than a <code>RectangleType</code> structure does. </p>
<h4>
  <a name="1029060"> </a>See Also 
</h4>

<p><a name="1029067"> </a><a href="UI_Window.html#1027939"><code>WinDrawGrayRectangleFrame()</code></a>, <a href="UI_Window.html#1029878"><code>WinEraseRectangleFrame()</code></a>, <a href="UI_Window.html#1497232"><code>WinGetFramesRectangle()</code></a>, <a href="UI_Window.html#999326"><code>WinInvertRectangleFrame()</code></a></p>

<h3 class="hbH3">
  <a name="1029074"> </a>WinDrawTruncChars Function <a href="#1160850"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="1029076"> </a>Purpose 
</h4>

<p><a name="1029077"> </a>Draws the specified characters in the draw window, truncating the characters to the specified width.</p>
<h4>
  <a name="1029078"> </a>Declared In 
</h4>
<code>Window.h <a name="1029079"> </a></code><h4>
  <a name="1029080"> </a>Prototype 
</h4>
<pre class="proto"><a name="1029081"></a>void WinDrawTruncChars (
   const char *<code class="par">chars</code>,
   int16_t <code class="par">len</code>,
   Coord <code class="par">x</code>,
   Coord <code class="par">y</code>,
   Coord <code class="par">maxWidth</code>
)
</pre>
<h4>
  <a name="1029082"> </a>Parameters 
</h4>

<dl>
<dt><a name="1029083"> </a><code>&rarr;  <i>chars</i></code></dt>
<dd><a name="1029084"> </a>A pointer to the characters to draw.</dd>

<dt><a name="1029085"> </a><code>&rarr;  <i>len</i></code></dt>
<dd><a name="1029086"> </a>The length in bytes of the characters to draw.</dd>

<dt><a name="1029087"> </a><code>&rarr;  <i>x</i></code></dt>
<dd><a name="1029088"> </a>The x coordinate of the first character to draw (left bound).</dd>

<dt><a name="1029089"> </a><code>&rarr;  <i>y</i></code></dt>
<dd><a name="1029090"> </a>The y coordinate of the first character to draw (top bound).</dd>

<dt><a name="1029091"> </a><code>&rarr;  <i>maxWidth</i></code></dt>
<dd><a name="1029092"> </a>The maximum width in pixels of the characters that are to be drawn.</dd>

</dl>
<h4>
  <a name="1029093"> </a>Returns 
</h4>

<p><a name="1029094"> </a>Nothing.</p>
<h4>
  <a name="1029095"> </a>Comments 
</h4>

<p><a name="1029096"> </a>Before calling this function, consider calling <a href="UI_Window.html#1004170"><code>WinSetUnderlineMode()</code></a> and <a href="UI_Font.html#995852"><code>FntSetFont()</code></a>. </p>

<p><a name="1029103"> </a>If drawing all of the specified characters requires more space than <code class="par">maxWidth</code> allows, <code>WinDrawTruncChars()</code> draws one less than the number of characters that can fit in <code class="par">maxWidth</code> and then draws an ellipsis (...) in the remaining space. (If the boundary characters are narrower than the ellipsis, more than one character may be dropped to make room.) If <code class="par">maxWidth</code> is narrower than the width of an ellipsis, nothing is drawn. </p>

<p><a name="1029104"> </a>Use this function to truncate text that may contain multi-byte characters. </p>

<p><a name="1454535"> </a>This function differs from <a href="UI_Window.html#1000540"><code>WinPaintTruncChars()</code></a> in that it always uses <code>winPaint</code>. <code>WinPaintTruncChars()</code> uses the current draw state transfer mode. </p>
<h4>
  <a name="1446610"> </a>Compatibility 
</h4>

<p><a name="1446611"> </a>The <code>winInvert</code> drawing mode does not work when you draw text. Nothing is drawn to the screen. </p>

<p><a name="1764956"> </a>Do not use this function in conjunction with the graphics context APIs. Use <a href="UI_GraphicContext.html#1196638"><code>GcDrawTextAt()</code></a> instead. Note that <code>GcDrawTextAt()</code> uses the y value as the font baseline whereas <code>WinDrawTruncChars()</code> uses the y value as the top of the character. </p>
<h4>
  <a name="1029114"> </a>See Also 
</h4>

<p><a name="1029124"> </a><a href="UI_Window.html#1026950"><code>WinDrawChar()</code></a>, <a href="UI_Window.html#1027460"><code>WinDrawChars()</code></a>, <a href="UI_Window.html#1028455"><code>WinDrawInvertedChars()</code></a>, <a href="UI_Window.html#1029680"><code>WinEraseChars()</code></a>, <a href="UI_Window.html#999081"><code>WinInvertChars()</code></a>, <a href="UI_Window.html#999742"><code>WinPaintChar()</code></a>, <a href="UI_Window.html#999796"><code>WinPaintChars()</code></a>, <a href="UI_Window.html#1000540"><code>WinPaintTruncChars()</code></a></p>

<h3 class="hbH3">
  <a name="1029680"> </a>WinEraseChars Function <a href="#1160850"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="1029682"> </a>Purpose 
</h4>

<p><a name="1029683"> </a>Erases the specified characters in the draw window.</p>
<h4>
  <a name="1029684"> </a>Declared In 
</h4>
<code>Window.h <a name="1029685"> </a></code><h4>
  <a name="1029686"> </a>Prototype 
</h4>
<pre class="proto"><a name="1029687"></a>void WinEraseChars (
   const char *<code class="par">chars</code>,
   int16_t <code class="par">len</code>,
   Coord <code class="par">x</code>,
   Coord <code class="par">y</code>
)
</pre>
<h4>
  <a name="1029688"> </a>Parameters 
</h4>

<dl>
<dt><a name="1029689"> </a><code>&rarr;  <i>chars</i></code></dt>
<dd><a name="1029690"> </a>A pointer to the characters to erase.</dd>

<dt><a name="1029691"> </a><code>&rarr;  <i>len</i></code></dt>
<dd><a name="1029692"> </a>The length in bytes of the characters to erase.</dd>

<dt><a name="1029693"> </a><code>&rarr;  <i>x</i></code></dt>
<dd><a name="1029694"> </a>The x coordinate of the first character to erase (left bound).</dd>

<dt><a name="1029695"> </a><code>&rarr;  <i>y</i></code></dt>
<dd><a name="1029696"> </a>The y coordinate of the first character to erase (top bound).</dd>

</dl>
<h4>
  <a name="1029697"> </a>Returns 
</h4>

<p><a name="1029698"> </a>Nothing.</p>
<h4>
  <a name="1029699"> </a>Comments 
</h4>

<p><a name="1029700"> </a>The <code>winMask</code> transfer mode is used to erase the characters. See <a href="UI_Window.html#1094199"><code>WinDrawOperation</code></a> for more information. This has the effect of erasing only the on bits for the characters rather than the entire text rectangle. This function only works if the foreground color is black and the background color is white. </p>
<h4>
  <a name="1447733"> </a>Compatibility 
</h4>

<p><a name="1447734"> </a>Do not use this function in conjunction with the graphics context APIs. Use <a href="UI_GraphicContext.html#1196638"><code>GcDrawTextAt()</code></a> instead. Note that <code>GcDrawTextAt()</code> uses the y value as the font baseline whereas <code>WinEraseChars()</code> uses the y value as the top of the character. </p>
<h4>
  <a name="1029704"> </a>See Also 
</h4>

<p><a name="1029714"> </a><a href="UI_Window.html#1026950"><code>WinDrawChar()</code></a>, <a href="UI_Window.html#1027460"><code>WinDrawChars()</code></a>, <a href="UI_Window.html#1028455"><code>WinDrawInvertedChars()</code></a>, <a href="UI_Window.html#1029074"><code>WinDrawTruncChars()</code></a>, <a href="UI_Window.html#999081"><code>WinInvertChars()</code></a>, <a href="UI_Window.html#999742"><code>WinPaintChar()</code></a>, <a href="UI_Window.html#999796"><code>WinPaintChars()</code></a></p>

<h3 class="hbH3">
  <a name="1029727"> </a>WinEraseLine Function <a href="#1160850"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="1029729"> </a>Purpose 
</h4>

<p><a name="1029730"> </a>Draws a line in the draw window using the current background color.</p>
<h4>
  <a name="1029731"> </a>Declared In 
</h4>
<code>Window.h <a name="1029732"> </a></code><h4>
  <a name="1029733"> </a>Prototype 
</h4>
<pre class="proto"><a name="1029734"></a>void WinEraseLine (
   Coord <code class="par">x1</code>,
   Coord <code class="par">y1</code>,
   Coord <code class="par">x2</code>,
   Coord <code class="par">y2</code>
)
</pre>
<h4>
  <a name="1029735"> </a>Parameters 
</h4>

<dl>
<dt><a name="1029736"> </a><code>&rarr;  <i>x1</i></code></dt>
<dd><a name="1029737"> </a>The x coordinate of line start point.</dd>

<dt><a name="1029738"> </a><code>&rarr;  <i>y1</i></code></dt>
<dd><a name="1029739"> </a>The y coordinate of line start point.</dd>

<dt><a name="1029740"> </a><code>&rarr;  <i>x2</i></code></dt>
<dd><a name="1029741"> </a>The x coordinate of line endpoint.</dd>

<dt><a name="1029742"> </a><code>&rarr;  <i>y2</i></code></dt>
<dd><a name="1029743"> </a>The y coordinate of line endpoint.</dd>

</dl>
<h4>
  <a name="1029744"> </a>Returns 
</h4>

<p><a name="1029745"> </a>Nothing.</p>
<h4>
  <a name="1447757"> </a>Compatibility 
</h4>

<p><a name="1447758"> </a>Do not use this function in conjunction with the graphics context APIs. Use <a href="UI_GraphicContext.html#1118074"><code>GcLineTo()</code></a> instead. </p>
<h4>
  <a name="1029746"> </a>See Also 
</h4>

<p><a name="1029756"> </a><a href="UI_Window.html#1027898"><code>WinDrawGrayLine()</code></a>, <a href="UI_Window.html#1028506"><code>WinDrawLine()</code></a>, <a href="UI_Window.html#1145105"><code>WinFillLine()</code></a>, <a href="UI_Window.html#999137"><code>WinInvertLine()</code></a>, <a href="UI_Window.html#999872"><code>WinPaintLine()</code></a>, <a href="UI_Window.html#999945"><code>WinPaintLines()</code></a></p>

<h3 class="hbH3">
  <a name="1029808"> </a>WinErasePixel Function <a href="#1160850"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="1029810"> </a>Purpose 
</h4>

<p><a name="1029811"> </a>Draws a pixel in the draw window using the current background color.</p>
<h4>
  <a name="1029812"> </a>Declared In 
</h4>
<code>Window.h <a name="1029813"> </a></code><h4>
  <a name="1029814"> </a>Prototype 
</h4>
<pre class="proto"><a name="1029815"></a>void WinErasePixel (
   Coord <code class="par">x</code>,
   Coord <code class="par">y</code>
)
</pre>
<h4>
  <a name="1029816"> </a>Parameters 
</h4>

<dl>
<dt><a name="1029817"> </a><code>&rarr;  <i>x</i></code></dt>
<dd><a name="1029818"> </a>A pointer to the x coordinate of a pixel.</dd>

<dt><a name="1029819"> </a><code>&rarr;  <i>y</i></code></dt>
<dd><a name="1029820"> </a>A pointer to the y coordinate of a pixel.</dd>

</dl>
<h4>
  <a name="1029821"> </a>Returns 
</h4>

<p><a name="1029822"> </a>Nothing.</p>
<h4>
  <a name="1447795"> </a>Compatibility 
</h4>

<p><a name="1447796"> </a>Do not use this function in conjunction with the graphics context APIs. Use <a href="UI_GraphicContext.html#1118074"><code>GcLineTo()</code></a> instead. </p>
<h4>
  <a name="1029828"> </a>See Also 
</h4>

<p><a name="1029838"> </a><a href="UI_Window.html#1028592"><code>WinDrawPixel()</code></a>, <a href="UI_Window.html#999210"><code>WinInvertPixel()</code></a>, <a href="UI_Window.html#999989"><code>WinPaintPixel()</code></a>, <a href="UI_Window.html#1000033"><code>WinPaintPixels()</code></a></p>

<h3 class="hbH3">
  <a name="1029842"> </a>WinEraseRectangle Function <a href="#1160850"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="1029844"> </a>Purpose 
</h4>

<p><a name="1029845"> </a>Draws a rectangle in the draw window using the current background color.</p>
<h4>
  <a name="1029846"> </a>Declared In 
</h4>
<code>Window.h <a name="1029847"> </a></code><h4>
  <a name="1029848"> </a>Prototype 
</h4>
<pre class="proto"><a name="1029849"></a>void WinEraseRectangle (
   const RectangleType *<code class="par">rP</code>,
   uint16_t <code class="par">cornerDiam</code>
)
</pre>
<h4>
  <a name="1029850"> </a>Parameters 
</h4>

<dl>
<dt><a name="1029851"> </a><code>&rarr;  <i>rP</i></code></dt>
<dd><a name="1029852"> </a>A pointer to the rectangle to erase (see <a href="UI_Rectangle.html#994219"><code>RectangleType</code></a>).</dd>

<dt><a name="1029853"> </a><code>&rarr;  <i>cornerDiam</i></code></dt>
<dd><a name="1029854"> </a>The radius of rounded corners. Specify zero for square corners.</dd>

</dl>
<h4>
  <a name="1029855"> </a>Returns 
</h4>

<p><a name="1029856"> </a>Nothing.</p>
<h4>
  <a name="1029857"> </a>Comments 
</h4>

<p><a name="1029858"> </a>The <code class="par">cornerDiam</code> parameter specifies the radius of four imaginary circles used to form the rounded corners. An imaginary circle is placed within each corner tangent to the rectangle on two sides.</p>
<h4>
  <a name="1447807"> </a>Compatibility 
</h4>

<p><a name="1447808"> </a>Do not use this function in conjunction with the graphics context APIs. Use <a href="UI_GraphicContext.html#1122410"><code>GcRect()</code></a> instead. Note that <code>GcRect()</code> specifies a rectangle's bounds differently than a <code>RectangleType</code> structure does. </p>
<h4>
  <a name="1029859"> </a>See Also 
</h4>

<p><a name="1029866"> </a><a href="UI_Window.html#1028621"><code>WinDrawRectangle()</code></a>, <a href="UI_Window.html#1029991"><code>WinFillRectangle()</code></a>, <a href="UI_Window.html#999254"><code>WinInvertRectangle()</code></a>, <a href="UI_Window.html#1000081"><code>WinPaintRectangle()</code></a></p>

<h3 class="hbH3">
  <a name="1029878"> </a>WinEraseRectangleFrame Function <a href="#1160850"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="1029880"> </a>Purpose 
</h4>

<p><a name="1029881"> </a>Draws a rectangular frame in the draw window using the current background color.</p>
<h4>
  <a name="1029882"> </a>Declared In 
</h4>
<code>Window.h <a name="1029883"> </a></code><h4>
  <a name="1029884"> </a>Prototype 
</h4>
<pre class="proto"><a name="1029885"></a>void WinEraseRectangleFrame (
   FrameType <code class="par">frame</code>,
   const RectangleType *<code class="par">rP</code>
)
</pre>
<h4>
  <a name="1029886"> </a>Parameters 
</h4>

<dl>
<dt><a name="1029887"> </a><code>&rarr;  <i>frame</i></code></dt>
<dd><a name="1029891"> </a>The type of frame to draw (see <a href="UI_Window.html#1610364"><code>FrameType</code></a>).</dd>

<dt><a name="1029892"> </a><code>&rarr;  <i>rP</i></code></dt>
<dd><a name="1029893"> </a>A pointer to the rectangle to frame (see <a href="UI_Rectangle.html#994219"><code>RectangleType</code></a>).</dd>

</dl>
<h4>
  <a name="1029894"> </a>Returns 
</h4>

<p><a name="1029895"> </a>Nothing.</p>
<h4>
  <a name="1447839"> </a>Compatibility 
</h4>

<p><a name="1447840"> </a>Do not use this function in conjunction with the graphics context APIs. Use <a href="UI_GraphicContext.html#1122410"><code>GcRect()</code></a> instead. </p>
<h4>
  <a name="1029896"> </a>See Also 
</h4>

<p><a name="1029903"> </a><a href="UI_Window.html#1027939"><code>WinDrawGrayRectangleFrame()</code></a>, <a href="UI_Window.html#1570711"><code>WinDrawRectangleFrame()</code></a>, <a href="UI_Window.html#1497232"><code>WinGetFramesRectangle()</code></a>, <a href="UI_Window.html#999326"><code>WinInvertRectangleFrame()</code></a>, <a href="UI_Window.html#1000125"><code>WinPaintRectangleFrame()</code></a></p>

<h3 class="hbH3">
  <a name="1029913"> </a>WinEraseWindow Function <a href="#1160850"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="1029915"> </a>Purpose 
</h4>

<p><a name="1029916"> </a>Erases the contents of the draw window. </p>
<h4>
  <a name="1029917"> </a>Declared In 
</h4>
<code>Window.h <a name="1029918"> </a></code><h4>
  <a name="1029919"> </a>Prototype 
</h4>
<pre class="proto"><a name="1029920"></a>void WinEraseWindow (
   void
)
</pre>
<h4>
  <a name="1029921"> </a>Parameters 
</h4>

<p><a name="1029922"> </a>None.</p>
<h4>
  <a name="1029923"> </a>Returns 
</h4>

<p><a name="1029924"> </a>Nothing.</p>
<h4>
  <a name="1029925"> </a>Comments 
</h4>

<p><a name="1029929"> </a><a href="UI_Window.html#1029842"><code>WinEraseRectangle()</code></a> is used to erase the window. This routine doesn't erase the frame around the draw window. See <a href="UI_Window.html#1029878"><code>WinEraseRectangleFrame()</code></a> and <a href="UI_Window.html#1518009"><code>WinGetWindowFrameRect()</code></a>. </p>
<h4>
  <a name="1447867"> </a>Compatibility 
</h4>

<p><a name="1447868"> </a>Do not use this function in conjunction with the graphics context APIs. Use <a href="UI_GraphicContext.html#1120151"><code>GcPaint()</code></a> instead. </p>

<h3 class="hbH3">
  <a name="1145105"> </a>WinFillLine Function <a href="#1160850"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="1029949"> </a>Purpose 
</h4>

<p><a name="1029950"> </a>Fills a line in the draw window with the current pattern.</p>
<h4>
  <a name="1029951"> </a>Declared In 
</h4>
<code>Window.h <a name="1029952"> </a></code><h4>
  <a name="1029953"> </a>Prototype 
</h4>
<pre class="proto"><a name="1029954"></a>void WinFillLine (
   Coord <code class="par">x1</code>,
   Coord <code class="par">y1</code>,
   Coord <code class="par">x2</code>,
   Coord <code class="par">y2</code>
)
</pre>
<h4>
  <a name="1029955"> </a>Parameters 
</h4>

<dl>
<dt><a name="1029956"> </a><code>&rarr;  <i>x1</i></code></dt>
<dd><a name="1029957"> </a>The x coordinate of line start point.</dd>

<dt><a name="1029958"> </a><code>&rarr;  <i>y1</i></code></dt>
<dd><a name="1029959"> </a>The y coordinate of line start point.</dd>

<dt><a name="1029960"> </a><code>&rarr;  <i>x2</i></code></dt>
<dd><a name="1029961"> </a>The x coordinate of line endpoint.</dd>

<dt><a name="1029962"> </a><code>&rarr;  <i>y2</i></code></dt>
<dd><a name="1029963"> </a>The y coordinate of line endpoint.</dd>

</dl>
<h4>
  <a name="1029964"> </a>Returns 
</h4>

<p><a name="1029965"> </a>Nothing.</p>
<h4>
  <a name="1029966"> </a>Comments 
</h4>

<p><a name="1029970"> </a>You can set the current pattern with <a href="UI_Window.html#1003650"><code>WinSetPattern()</code></a>.</p>
<h4>
  <a name="1448028"> </a>Compatibility 
</h4>

<p><a name="1448029"> </a>Do not use this function in conjunction with the graphics context APIs. Use <a href="UI_GraphicContext.html#1118074"><code>GcLineTo()</code></a> instead. </p>
<h4>
  <a name="1029971"> </a>See Also 
</h4>

<p><a name="1029981"> </a><a href="UI_Window.html#1027898"><code>WinDrawGrayLine()</code></a>, <a href="UI_Window.html#1028506"><code>WinDrawLine()</code></a>, <a href="UI_Window.html#1029727"><code>WinEraseLine()</code></a>, <a href="UI_Window.html#999137"><code>WinInvertLine()</code></a>, <a href="UI_Window.html#999872"><code>WinPaintLine()</code></a>, <a href="UI_Window.html#999945"><code>WinPaintLines()</code></a></p>

<h3 class="hbH3">
  <a name="1029991"> </a>WinFillRectangle Function <a href="#1160850"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="1029993"> </a>Purpose 
</h4>

<p><a name="1029994"> </a>Draws a rectangle in the draw window with current pattern.</p>
<h4>
  <a name="1029995"> </a>Declared In 
</h4>
<code>Window.h <a name="1029996"> </a></code><h4>
  <a name="1029997"> </a>Prototype 
</h4>
<pre class="proto"><a name="1029998"></a>void WinFillRectangle (
   const RectangleType *<code class="par">rP</code>,
   uint16_t <code class="par">cornerDiam</code>
)
</pre>
<h4>
  <a name="1029999"> </a>Parameters 
</h4>

<dl>
<dt><a name="1030000"> </a><code>&rarr;  <i>rP</i></code></dt>
<dd><a name="1030001"> </a>A pointer to the rectangle to draw (see <a href="UI_Rectangle.html#994219"><code>RectangleType</code></a>).</dd>

<dt><a name="1030002"> </a><code>&rarr;  <i>cornerDiam</i></code></dt>
<dd><a name="1030003"> </a>The radius of rounded corners. Specify zero for square corners.</dd>

</dl>
<h4>
  <a name="1030004"> </a>Returns 
</h4>

<p><a name="1030005"> </a>Nothing.</p>
<h4>
  <a name="1030006"> </a>Comments 
</h4>

<p><a name="1030010"> </a>You can set the current pattern with <a href="UI_Window.html#1003650"><code>WinSetPattern()</code></a>.</p>

<p><a name="1030011"> </a>The <code class="par">cornerDiam</code> parameter specifies the radius of four imaginary circles used to form the rounded corners. An imaginary circle is placed within each corner tangent to the rectangle on two sides.</p>
<h4>
  <a name="1448066"> </a>Compatibility 
</h4>

<p><a name="1448067"> </a>Do not use this function in conjunction with the graphics context APIs. Use <a href="UI_GraphicContext.html#1122410"><code>GcRect()</code></a> instead. Note that <code>GcRect()</code> specifies a rectangle's bounds differently than a <code>RectangleType</code> structure does. </p>
<h4>
  <a name="1030012"> </a>See Also 
</h4>

<p><a name="1030019"> </a><a href="UI_Window.html#1028621"><code>WinDrawRectangle()</code></a>, <a href="UI_Window.html#1029842"><code>WinEraseRectangle()</code></a>, <a href="UI_Window.html#999254"><code>WinInvertRectangle()</code></a>, <a href="UI_Window.html#1000081"><code>WinPaintRectangle()</code></a></p>

<h3 class="hbH3">
  <a name="1492237"> </a>WinGetClip Function <a href="#1160850"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="1492239"> </a>Purpose 
</h4>

<p><a name="1492240"> </a>Returns the clipping rectangle of the draw window.</p>
<h4>
  <a name="1492241"> </a>Declared In 
</h4>
<code>Window.h <a name="1492242"> </a></code><h4>
  <a name="1492243"> </a>Prototype 
</h4>
<pre class="proto"><a name="1492244"></a>void WinGetClip (
   RectangleType *<code class="par">rP</code>
)
</pre>
<h4>
  <a name="1492245"> </a>Parameters 
</h4>

<dl>
<dt><a name="1492246"> </a><code>&larr;  <i>rP</i></code></dt>
<dd><a name="1492247"> </a>A pointer to a structure to hold the clipping bounds (see <a href="UI_Rectangle.html#994219"><code>RectangleType</code></a>).</dd>

</dl>
<h4>
  <a name="1492248"> </a>Returns 
</h4>

<p><a name="1492249"> </a>Nothing.</p>
<h4>
  <a name="1492250"> </a>See Also 
</h4>

<p><a name="1492254"> </a><a href="UI_Window.html#1539836"><code>WinSetClip()</code></a></p>

<h3 class="hbH3">
  <a name="1492257"> </a>WinGetCoordinateSystem Function <a href="#1160850"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="1492259"> </a>Purpose 
</h4>

<p><a name="1492260"> </a>Gets the coordinate system. </p>
<h4>
  <a name="1492261"> </a>Declared In 
</h4>
<code>Window.h <a name="1492262"> </a></code><h4>
  <a name="1492263"> </a>Prototype 
</h4>
<pre class="proto"><a name="1492264"></a>uint16_t WinGetCoordinateSystem (
   void
)
</pre>
<h4>
  <a name="1492265"> </a>Parameters 
</h4>

<p><a name="1492266"> </a>None.</p>
<h4>
  <a name="1492267"> </a>Returns 
</h4>

<p><a name="1492270"> </a>A value representing the current coordinate system. See <a href="UI_Window.html#1687709">"Coordinate System Constants"</a> for the values that this function can return.</p>
<h4>
  <a name="1492272"> </a>Comments 
</h4>

<p><a name="1492273"> </a>Use this function to determine the active window coordinate system. Armed with this information, an application can properly initialize graphic primitive coordinates and dimensions, or can modify the coordinate system with <a href="UI_Window.html#1002873"><code>WinSetCoordinateSystem()</code></a>.</p>
<h4>
  <a name="1492277"> </a>Compatibility 
</h4>

<p><a name="1492278"> </a>Do not use this function in conjunction with the graphics context APIs. It returns the coordinate system of the window rather than the coordinate system of the graphics context. </p>

<h3 class="hbH3">
  <a name="1500947"> </a>WinGetPattern Function <a href="#1160850"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="1500949"> </a>Purpose 
</h4>

<p><a name="1500950"> </a>Returns the current fill pattern.</p>
<h4>
  <a name="1500951"> </a>Declared In 
</h4>
<code>Window.h <a name="1500952"> </a></code><h4>
  <a name="1500953"> </a>Prototype 
</h4>
<pre class="proto"><a name="1500954"></a>void WinGetPattern (
   CustomPatternType *<code class="par">patternP</code>
)
</pre>
<h4>
  <a name="1500955"> </a>Parameters 
</h4>

<dl>
<dt><a name="1500956"> </a><code>&larr;  <i>patternP</i></code></dt>
<dd><a name="1500957"> </a>The buffer where the current pattern is returned (see <a href="UI_Window.html#1093797"><code>CustomPatternType</code></a>).</dd>

</dl>
<h4>
  <a name="1500961"> </a>Returns 
</h4>

<p><a name="1500962"> </a>Nothing.</p>
<h4>
  <a name="1500963"> </a>Comments 
</h4>

<p><a name="1500967"> </a>The fill pattern is used by <a href="UI_Window.html#1145105"><code>WinFillLine()</code></a> and <a href="UI_Window.html#1029991"><code>WinFillRectangle()</code></a>.</p>

<p><a name="1500971"> </a>This function returns the pattern data stored in the drawing state. The drawing state only has pattern data if the pattern field itself is set to <code>customPattern</code>. Therefore, it's a good idea to use <a href="UI_Window.html#1505993"><code>WinGetPatternType()</code></a> instead of this function on systems that support <code>WinGetPatternType()</code>.</p>
<h4>
  <a name="1500979"> </a>See Also 
</h4>

<p><a name="1500983"> </a><a href="UI_Window.html#1003650"><code>WinSetPattern()</code></a></p>

<h3 class="hbH3">
  <a name="1505993"> </a>WinGetPatternType Function <a href="#1160850"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="1505995"> </a>Purpose 
</h4>

<p><a name="1505996"> </a>Returns the current pattern type. </p>
<h4>
  <a name="1505997"> </a>Declared In 
</h4>
<code>Window.h <a name="1505998"> </a></code><h4>
  <a name="1505999"> </a>Prototype 
</h4>
<pre class="proto"><a name="1506000"></a>PatternType WinGetPatternType (
   void
)
</pre>
<h4>
  <a name="1506001"> </a>Parameters 
</h4>

<p><a name="1506002"> </a>None.</p>
<h4>
  <a name="1506003"> </a>Returns 
</h4>

<p><a name="1506007"> </a>The current draw window pattern type (see <a href="UI_Window.html#1098738"><code>PatternType</code></a>). If the return value is <code>customPattern</code>, you can retrieve the pattern with <a href="UI_Window.html#1500947"><code>WinGetPattern()</code></a>.</p>
<h4>
  <a name="1506012"> </a>Comments 
</h4>

<p><a name="1506016"> </a>The fill pattern is used by <a href="UI_Window.html#1145105"><code>WinFillLine()</code></a> and <a href="UI_Window.html#1029991"><code>WinFillRectangle()</code></a>.</p>
<h4>
  <a name="1506020"> </a>See Also 
</h4>

<p><a name="1506024"> </a><a href="UI_Window.html#1003690"><code>WinSetPatternType()</code></a></p>

<h3 class="hbH3">
  <a name="1699863"> </a>WinGetScalingMode Function <a href="#1160850"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="1699865"> </a>Purpose 
</h4>

<p><a name="1699866"> </a>Gets the current scaling mode.</p>
<h4>
  <a name="1699867"> </a>Declared In 
</h4>
<code>Window.h<a name="1699868"> </a></code><h4>
  <a name="1699869"> </a>Prototype 
</h4>
<pre class="proto"><a name="1699870"></a>uint32_t WinGetScalingMode (
   void
)
</pre>
<h4>
  <a name="1699871"> </a>Parameters 
</h4>

<p><a name="1699872"> </a>None.</p>
<h4>
  <a name="1699873"> </a>Returns 
</h4>

<p><a name="1699877"> </a>One of the <a href="UI_Window.html#1679132">Scaling Mode Constants</a>. </p>
<h4>
  <a name="1699878"> </a>See Also 
</h4>

<p><a name="1699882"> </a><a href="UI_Window.html#1704064"><code>WinSetScalingMode()</code></a></p>

<h3 class="hbH3">
  <a name="999081"> </a>WinInvertChars Function <a href="#1160850"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="1706793"> </a>Purpose 
</h4>

<p><a name="1706795"> </a>Inverts the specified characters in the draw window.</p>
<h4>
  <a name="1706796"> </a>Declared In 
</h4>
<code>Window.h<a name="999096"> </a></code><h4>
  <a name="999098"> </a>Prototype 
</h4>
<pre class="proto"><a name="999101"></a>void WinInvertChars (
   const char <code class="par">*chars</code>,
   int16_t <code class="par">len</code>,
   Coord <code class="par">x</code>,
   Coord <code class="par">y</code>
)
</pre>
<h4>
  <a name="999103"> </a>Parameters 
</h4>

<dl>
<dt><a name="1042200"> </a><code>&rarr;  <i>chars</i></code></dt>
<dd><a name="1042201"> </a>A pointer to the characters to invert.</dd>

<dt><a name="1042202"> </a><code>&rarr;  <i>len</i></code></dt>
<dd><a name="1042203"> </a>The length in bytes of the characters to invert.</dd>

<dt><a name="1042204"> </a><code>&rarr;  <i>x</i></code></dt>
<dd><a name="1042205"> </a>The x coordinate of the first character to invert (left bound).</dd>

<dt><a name="1042206"> </a><code>&rarr;  <i>y</i></code></dt>
<dd><a name="1042207"> </a>The y coordinate of the first character to invert (top bound).</dd>

</dl>
<h4>
  <a name="1042208"> </a>Returns 
</h4>

<p><a name="1042209"> </a>Nothing.</p>
<h4>
  <a name="1042210"> </a>Compatibility 
</h4>

<p><a name="1415656"> </a>This function is deprecated in Palm OS Cobalt.</p>
<h4>
  <a name="1573768"> </a>See Also 
</h4>

<p><a name="1573778"> </a><a href="UI_Window.html#1026950"><code>WinDrawChar()</code></a>, <a href="UI_Window.html#1027460"><code>WinDrawChars()</code></a>, <a href="UI_Window.html#1028455"><code>WinDrawInvertedChars()</code></a>, <a href="UI_Window.html#1029074"><code>WinDrawTruncChars()</code></a>, <a href="UI_Window.html#1029680"><code>WinEraseChars()</code></a>, <a href="UI_Window.html#999742"><code>WinPaintChar()</code></a>, <a href="UI_Window.html#999796"><code>WinPaintChars()</code></a></p>

<h3 class="hbH3">
  <a name="999137"> </a>WinInvertLine Function <a href="#1160850"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="999140"> </a>Purpose 
</h4>

<p><a name="999143"> </a>Inverts a line in the draw window (using the <a href="UI_Window.html#1094199"><code>WinDrawOperation</code></a> <code>winInvert</code>).</p>
<h4>
  <a name="999145"> </a>Declared In 
</h4>
<code>Window.h<a name="999148"> </a></code><h4>
  <a name="999150"> </a>Prototype 
</h4>
<pre class="proto"><a name="999153"></a>void WinInvertLine (
   Coord <code class="par">x1</code>,
   Coord <code class="par">y1</code>,
   Coord <code class="par">x2</code>,
   Coord <code class="par">y2</code>
)
</pre>
<h4>
  <a name="999155"> </a>Parameters 
</h4>

<dl>
<dt><a name="1042323"> </a><code>&rarr;  <i>x1</i></code></dt>
<dd><a name="1042324"> </a>The x coordinate of line start point.</dd>

<dt><a name="1042325"> </a><code>&rarr;  <i>y1</i></code></dt>
<dd><a name="1042326"> </a>The y coordinate of line start point.</dd>

<dt><a name="1042327"> </a><code>&rarr;  <i>x2</i></code></dt>
<dd><a name="1042328"> </a>The x coordinate of line endpoint.</dd>

<dt><a name="1042329"> </a><code>&rarr;  <i>y2</i></code></dt>
<dd><a name="1042330"> </a>The y coordinate of line endpoint.</dd>

</dl>
<h4>
  <a name="1042331"> </a>Returns 
</h4>

<p><a name="1042332"> </a>Nothing.</p>
<h4>
  <a name="1415686"> </a>Compatibility 
</h4>

<p><a name="1415705"> </a>This function is deprecated in Palm OS Cobalt.</p>
<h4>
  <a name="1042333"> </a>See Also 
</h4>

<p><a name="1042343"> </a><a href="UI_Window.html#1027898"><code>WinDrawGrayLine()</code></a>, <a href="UI_Window.html#1028506"><code>WinDrawLine()</code></a>, <a href="UI_Window.html#1029727"><code>WinEraseLine()</code></a>, <a href="UI_Window.html#1145105"><code>WinFillLine()</code></a>, <a href="UI_Window.html#999872"><code>WinPaintLine()</code></a>, <a href="UI_Window.html#999945"><code>WinPaintLines()</code></a></p>

<h3 class="hbH3">
  <a name="999210"> </a>WinInvertPixel Function <a href="#1160850"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="999213"> </a>Purpose 
</h4>

<p><a name="999216"> </a>Inverts a pixel in the draw window (using the <a href="UI_Window.html#1094199"><code>WinDrawOperation</code></a> <code>winInvert</code>).</p>
<h4>
  <a name="999218"> </a>Declared In 
</h4>
<code>Window.h<a name="999221"> </a></code><h4>
  <a name="999223"> </a>Prototype 
</h4>
<pre class="proto"><a name="999226"></a>void WinInvertPixel (
   Coord <code class="par">x</code>,
   Coord <code class="par">y</code>
)
</pre>
<h4>
  <a name="999228"> </a>Parameters 
</h4>

<dl>
<dt><a name="1042485"> </a><code>&rarr;  <i>x</i></code></dt>
<dd><a name="1042486"> </a>A pointer to the x coordinate of a pixel.</dd>

<dt><a name="1042487"> </a><code>&rarr;  <i>y</i></code></dt>
<dd><a name="1042488"> </a>A pointer to the y coordinate of a pixel.</dd>

</dl>
<h4>
  <a name="1042489"> </a>Returns 
</h4>

<p><a name="1042490"> </a>Nothing.</p>
<h4>
  <a name="1418138"> </a>Compatibility 
</h4>

<p><a name="1418139"> </a>This function is deprecated in Palm OS Cobalt.</p>
<h4>
  <a name="1042496"> </a>See Also 
</h4>

<p><a name="1042506"> </a><a href="UI_Window.html#1028592"><code>WinDrawPixel()</code></a>, <a href="UI_Window.html#1029808"><code>WinErasePixel()</code></a>, <a href="UI_Window.html#999989"><code>WinPaintPixel()</code></a>, <a href="UI_Window.html#1000033"><code>WinPaintPixels()</code></a></p>

<h3 class="hbH3">
  <a name="999254"> </a>WinInvertRectangle Function <a href="#1160850"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="1042565"> </a>Purpose 
</h4>

<p><a name="999260"> </a>Inverts a rectangle in the draw window (using the <a href="UI_Window.html#1094199"><code>WinDrawOperation</code></a> <code>winInvert</code>).</p>
<h4>
  <a name="999262"> </a>Declared In 
</h4>
<code>Window.h<a name="999265"> </a></code><h4>
  <a name="999267"> </a>Prototype 
</h4>
<pre class="proto"><a name="999270"></a>void WinInvertRectangle (
   const RectangleType <code class="par">*rP</code>,
   uint16_t <code class="par">cornerDiam</code>
)
</pre>
<h4>
  <a name="999272"> </a>Parameters 
</h4>

<dl>
<dt><a name="1042578"> </a><code>&rarr;  <i>rP</i></code></dt>
<dd><a name="1042579"> </a>A pointer to the rectangle to invert (see <a href="UI_Rectangle.html#994219"><code>RectangleType</code></a>).</dd>

<dt><a name="1042580"> </a><code>&rarr;  <i>cornerDiam</i></code></dt>
<dd><a name="1042581"> </a>The radius of rounded corners. Specify zero for square corners.</dd>

</dl>
<h4>
  <a name="1042582"> </a>Returns 
</h4>

<p><a name="1042583"> </a>Nothing.</p>
<h4>
  <a name="1418550"> </a>Compatibility 
</h4>

<p><a name="1418551"> </a>This function is deprecated in Palm OS Cobalt.</p>
<h4>
  <a name="1042587"> </a>See Also 
</h4>

<p><a name="1042597"> </a><a href="UI_Window.html#1028621"><code>WinDrawRectangle()</code></a>, <a href="UI_Window.html#1029842"><code>WinEraseRectangle()</code></a>, <a href="UI_Window.html#1029991"><code>WinFillRectangle()</code></a>, <a href="UI_Window.html#1000081"><code>WinPaintRectangle()</code></a></p>

<h3 class="hbH3">
  <a name="999326"> </a>WinInvertRectangleFrame Function <a href="#1160850"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="1042625"> </a>Purpose 
</h4>

<p><a name="1042626"> </a>Inverts a rectangular frame in the draw window (using the <a href="UI_Window.html#1094199"><code>WinDrawOperation</code></a> <code>winInvert</code>).</p>
<h4>
  <a name="999358"> </a>Declared In 
</h4>
<code>Window.h<a name="999361"> </a></code><h4>
  <a name="999363"> </a>Prototype 
</h4>
<pre class="proto"><a name="999366"></a>void WinInvertRectangleFrame (
   FrameType <code class="par">frame</code>,
   const RectangleType <code class="par">*rP</code>
)
</pre>
<h4>
  <a name="999368"> </a>Parameters 
</h4>

<dl>
<dt><a name="1042838"> </a><code>&rarr;  <i>frame</i></code></dt>
<dd><a name="1042842"> </a>The type of frame to draw (see <a href="UI_Window.html#1610364"><code>FrameType</code></a>).</dd>

<dt><a name="1042843"> </a><code>&rarr;  <i>rP</i></code></dt>
<dd><a name="1042844"> </a>A pointer to the rectangle to frame (see <a href="UI_Rectangle.html#994219"><code>RectangleType</code></a>).</dd>

</dl>
<h4>
  <a name="1042845"> </a>Returns 
</h4>

<p><a name="1042846"> </a>Nothing.</p>
<h4>
  <a name="1420588"> </a>Compatibility 
</h4>

<p><a name="1420589"> </a>This function is deprecated in Palm OS Cobalt.</p>
<h4>
  <a name="1042847"> </a>See Also 
</h4>

<p><a name="1042854"> </a><a href="UI_Window.html#1027939"><code>WinDrawGrayRectangleFrame()</code></a>, <a href="UI_Window.html#1570711"><code>WinDrawRectangleFrame()</code></a>, <a href="UI_Window.html#1029878"><code>WinEraseRectangleFrame()</code></a>, <a href="UI_Window.html#1497232"><code>WinGetFramesRectangle()</code></a>, <a href="UI_Window.html#1000125"><code>WinPaintRectangleFrame()</code></a></p>

<h3 class="hbH3">
  <a name="999434"> </a>WinPaintBitmap Function <a href="#1160850"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="1043059"> </a>Purpose 
</h4>

<p><a name="1043060"> </a>Draws a bitmap in the current draw window at the specified coordinates using the <code>winPaint</code> transfer mode.</p>
<h4>
  <a name="999442"> </a>Declared In 
</h4>
<code>Window.h<a name="999445"> </a></code><h4>
  <a name="999447"> </a>Prototype 
</h4>
<pre class="proto"><a name="999450"></a>void WinPaintBitmap (
   BitmapType <code class="par">*bitmapP</code>,
   Coord <code class="par">x</code>,
   Coord <code class="par">y</code>
)
</pre>
<h4>
  <a name="999468"> </a>Parameters 
</h4>

<dl>
<dt><a name="1043092"> </a><code>&rarr;  <i>bitmapP</i></code></dt>
<dd><a name="1043093"> </a>A pointer to a bitmap.</dd>

<dt><a name="1043094"> </a><code>&rarr;  <i>x</i></code></dt>
<dd><a name="1043095"> </a>The x coordinate of the top-left corner.</dd>

<dt><a name="1043096"> </a><code>&rarr;  <i>y</i></code></dt>
<dd><a name="1043097"> </a>The y coordinate of the top-left corner.</dd>

</dl>
<h4>
  <a name="1043098"> </a>Returns 
</h4>

<p><a name="1043099"> </a>Nothing.</p>
<h4>
  <a name="1043100"> </a>Comments 
</h4>

<p><a name="1043101"> </a>If the bitmap has multiple depths (is a bitmap family), the closest match less than or equal to the current draw window depth is used. If such a bitmap does not exist, the bitmap with the closest match greater than the draw window depth is used. </p>

<p><a name="1043102"> </a>Using <code>WinPaintBitmap()</code> is recommended instead of the rendering bitmaps into an off-screen window and then using <a href="UI_Window.html#1021540"><code>WinCopyRectangle()</code></a> to draw them on screen.</p>

<p><a name="1043110"> </a>If the bitmap has its own color table, color conversion to the draw window color table will be applied. This color conversion is slow and not recommended. </p>
<h4>
  <a name="1450184"> </a>Compatibility 
</h4>

<p><a name="1450201"> </a>Do not use this function with the graphics context. Use <a href="UI_GraphicContext.html#1120182"><code>GcPaintBitmap()</code></a> instead. </p>

<p><a name="1726637"> </a>In earlier releases, this function used the transfer mode set in the draw state to paint the bitmap to the screen. Palm OS Cobalt ignores the current transfer mode and uses <code>winPaint</code> instead. </p>
<h4>
  <a name="1043119"> </a>See Also 
</h4>

<p><a name="1043126"> </a><a href="UI_Window.html#1026915"><code>WinDrawBitmap()</code></a>, <a href="UI_Window.html#1029842"><code>WinEraseRectangle()</code></a>, <a href="UI_Window.html#1000472"><code>WinPaintTiledBitmap()</code></a></p>

<h3 class="hbH3">
  <a name="999742"> </a>WinPaintChar Function <a href="#1160850"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="1043500"> </a>Purpose 
</h4>

<p><a name="1043501"> </a>Draws a character in the draw window using the current drawing state.</p>
<h4>
  <a name="999750"> </a>Declared In 
</h4>
<code>Window.h<a name="999753"> </a></code><h4>
  <a name="999755"> </a>Prototype 
</h4>
<pre class="proto"><a name="999758"></a>void WinPaintChar (
   wchar32_t <code class="par">theChar</code>,
   Coord <code class="par">x</code>,
   Coord <code class="par">y</code>
)
</pre>
<h4>
  <a name="1043640"> </a>Parameters 
</h4>

<dl>
<dt><a name="1043770"> </a><code>&rarr;  <i>theChar</i></code></dt>
<dd><a name="1043771"> </a>The character to draw. This may be either a single-byte character or a multi-byte character. </dd>

<dt><a name="1043772"> </a><code>&rarr;  <i>x</i></code></dt>
<dd><a name="1043773"> </a>The x coordinate of the location where the character is to be drawn (left bound).</dd>

<dt><a name="1043774"> </a><code>&rarr;  <i>y</i></code></dt>
<dd><a name="1043775"> </a>The y coordinate of the location where the character is to be drawn (top bound).</dd>

</dl>
<h4>
  <a name="1043776"> </a>Returns 
</h4>

<p><a name="1043777"> </a>Nothing.</p>
<h4>
  <a name="1043778"> </a>Comments 
</h4>

<p><a name="1043779"> </a><code>WinPaintChar()</code> draws the <b>on</b> bits in the text color and the <b>off</b> bits in the background color, with underlines (if any) drawn in the foreground color using the current drawing mode.</p>

<p><a name="1043780"> </a>This function uses the current drawing state. </p>
<h4>
  <a name="1450220"> </a>Compatibility 
</h4>

<p><a name="1764958"> </a>The <code>winInvert</code> drawing mode does not work when you draw text. Nothing is drawn to the screen. </p>

<p><a name="1450221"> </a>Do not use this function with the graphics context. Use <a href="UI_GraphicContext.html#1196638"><code>GcDrawTextAt()</code></a> instead. Note that <code>GcDrawTextAt()</code> uses the y value as the baseline for the font whereas <code>WinPaintChar()</code> uses the y value as the top of the character. </p>
<h4>
  <a name="1043872"> </a>See Also 
</h4>

<p><a name="1043882"> </a><a href="UI_Window.html#1026950"><code>WinDrawChar()</code></a>, <a href="UI_Window.html#1027460"><code>WinDrawChars()</code></a>, <a href="UI_Window.html#1028455"><code>WinDrawInvertedChars()</code></a>, <a href="UI_Window.html#1029074"><code>WinDrawTruncChars()</code></a>, <a href="UI_Window.html#1029680"><code>WinEraseChars()</code></a>, <a href="UI_Window.html#999081"><code>WinInvertChars()</code></a>, <a href="UI_Window.html#999796"><code>WinPaintChars()</code></a></p>

<h3 class="hbH3">
  <a name="999796"> </a>WinPaintChars Function <a href="#1160850"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="1043932"> </a>Purpose 
</h4>

<p><a name="1043933"> </a>Draws the specified characters in the draw window with the current draw state.</p>
<h4>
  <a name="999828"> </a>Declared In 
</h4>
<code>Window.h<a name="999831"> </a></code><h4>
  <a name="999833"> </a>Prototype 
</h4>
<pre class="proto"><a name="999836"></a>void WinPaintChars (
   const char <code class="par">*chars</code>,
   int16_t <code class="par">len</code>,
   Coord <code class="par">x</code>,
   Coord <code class="par">y</code>
)
</pre>
<h4>
  <a name="999838"> </a>Parameters 
</h4>

<dl>
<dt><a name="1043969"> </a><code>&rarr;  <i>chars</i></code></dt>
<dd><a name="1043970"> </a>A pointer to the characters to draw.</dd>

<dt><a name="1043971"> </a><code>&rarr;  <i>len</i></code></dt>
<dd><a name="1043972"> </a>The length in bytes of the characters to draw.</dd>

<dt><a name="1043973"> </a><code>&rarr;  <i>x</i></code></dt>
<dd><a name="1043974"> </a>The x coordinate of the first character to draw (left bound).</dd>

<dt><a name="1043975"> </a><code>&rarr;  <i>y</i></code></dt>
<dd><a name="1043976"> </a>The y coordinate of the first character to draw (top bound).</dd>

</dl>
<h4>
  <a name="1043977"> </a>Returns 
</h4>

<p><a name="1043978"> </a>Nothing.</p>
<h4>
  <a name="1043979"> </a>Comments 
</h4>

<p><a name="1043980"> </a><code>WinPaintChars()</code> draws the <b>on</b> bits in the text color and the <b>off</b> bits in the background color, with underlines (if any) drawn in the foreground color using the current drawing mode.</p>

<p><a name="1043981"> </a>This function uses the current drawing state. </p>

<p><a name="1043985"> </a>Before calling this function, consider calling <a href="UI_Window.html#1004170"><code>WinSetUnderlineMode()</code></a> and <a href="UI_Font.html#995852"><code>FntSetFont()</code></a>. </p>
<h4>
  <a name="1450717"> </a>Compatibility 
</h4>

<p><a name="1765369"> </a>The <code>winInvert</code> drawing mode does not work when you draw text. Nothing is drawn to the screen. </p>

<p><a name="1450718"> </a>Do not use this function with the graphics context. Use <a href="UI_GraphicContext.html#1196638"><code>GcDrawTextAt()</code></a> instead. Note that <code>GcDrawTextAt()</code> uses the y value as the baseline for the font whereas <code>WinPaintChars()</code> uses the y value as the top of the character. </p>
<h4>
  <a name="1044023"> </a>See Also 
</h4>

<p><a name="1044033"> </a><a href="UI_Window.html#1026950"><code>WinDrawChar()</code></a>, <a href="UI_Window.html#1027460"><code>WinDrawChars()</code></a>, <a href="UI_Window.html#1028455"><code>WinDrawInvertedChars()</code></a>, <a href="UI_Window.html#1029074"><code>WinDrawTruncChars()</code></a>, <a href="UI_Window.html#1029680"><code>WinEraseChars()</code></a>, <a href="UI_Window.html#999081"><code>WinInvertChars()</code></a>, <a href="UI_Window.html#999742"><code>WinPaintChar()</code></a></p>

<h3 class="hbH3">
  <a name="999872"> </a>WinPaintLine Function <a href="#1160850"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="1044239"> </a>Purpose 
</h4>

<p><a name="1044240"> </a>Draws a line in the draw window using the current drawing state.</p>
<h4>
  <a name="999880"> </a>Declared In 
</h4>
<code>Window.h<a name="999883"> </a></code><h4>
  <a name="999885"> </a>Prototype 
</h4>
<pre class="proto"><a name="999888"></a>void WinPaintLine (
   Coord <code class="par">x1</code>,
   Coord <code class="par">y1</code>,
   Coord <code class="par">x2</code>,
   Coord <code class="par">y2</code>
)
</pre>
<h4>
  <a name="999890"> </a>Parameters 
</h4>

<dl>
<dt><a name="1406972"> </a><code>&rarr;  <i>x1</i></code></dt>
<dd><a name="1406973"> </a>The x coordinate of line beginning point.</dd>

<dt><a name="1406974"> </a><code>&rarr;  <i>y1</i></code></dt>
<dd><a name="1044269"> </a>The y coordinate of line beginning point.</dd>

<dt><a name="1044270"> </a><code>&rarr;  <i>x2</i></code></dt>
<dd><a name="1044271"> </a>The x coordinate of line endpoint.</dd>

<dt><a name="1044272"> </a><code>&rarr;  <i>y2</i></code></dt>
<dd><a name="1044273"> </a>The y coordinate of line endpoint.</dd>

</dl>
<h4>
  <a name="1044274"> </a>Returns 
</h4>

<p><a name="1044275"> </a>Nothing.</p>
<h4>
  <a name="1044276"> </a>Comments 
</h4>

<p><a name="1044277"> </a>This function uses the current drawing state. </p>
<h4>
  <a name="1450763"> </a>Compatibility 
</h4>

<p><a name="1450764"> </a>Do not use this function with the graphics context. Use <a href="UI_GraphicContext.html#1118074"><code>GcLineTo()</code></a> instead. </p>
<h4>
  <a name="999940"> </a>See Also 
</h4>

<p><a name="999943"> </a><a href="UI_Window.html#1028506"><code>WinDrawLine()</code></a>, <a href="UI_Window.html#1027898"><code>WinDrawGrayLine()</code></a>, <a href="UI_Window.html#1029727"><code>WinEraseLine()</code></a>, <a href="UI_Window.html#1145105"><code>WinFillLine()</code></a>, <a href="UI_Window.html#999137"><code>WinInvertLine()</code></a>, <a href="UI_Window.html#999945"><code>WinPaintLines()</code></a></p>

<h3 class="hbH3">
  <a name="999945"> </a>WinPaintLines Function <a href="#1160850"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="1044371"> </a>Purpose 
</h4>

<p><a name="1044372"> </a>Draws several lines in the draw window using the current drawing state.</p>
<h4>
  <a name="999953"> </a>Declared In 
</h4>
<code>Window.h<a name="999956"> </a></code><h4>
  <a name="999958"> </a>Prototype 
</h4>
<pre class="proto"><a name="999961"></a>void WinPaintLines (
   uint16_t <code class="par">numLines</code>,
   WinLineType <code class="par">lines</code>[]
)
</pre>
<h4>
  <a name="999963"> </a>Parameters 
</h4>

<dl>
<dt><a name="1044408"> </a><code>&rarr;  <i>numLines</i></code></dt>
<dd><a name="1044409"> </a>The number of lines to paint.</dd>

<dt><a name="1044410"> </a><code>&rarr;  <i>lines</i></code></dt>
<dd><a name="1044414"> </a>An array of lines. See <a href="UI_Window.html#1005120"><code>WinLineType</code></a>.</dd>

</dl>
<h4>
  <a name="1044415"> </a>Returns 
</h4>

<p><a name="1044416"> </a>Nothing.</p>
<h4>
  <a name="1044417"> </a>Comments 
</h4>

<p><a name="1044418"> </a>This function uses the current drawing state. </p>
<h4>
  <a name="1453318"> </a>Compatibility 
</h4>

<p><a name="1453319"> </a>Do not use this function with the graphics context. Use <a href="UI_GraphicContext.html#1118074"><code>GcLineTo()</code></a> instead. </p>
<h4>
  <a name="999984"> </a>See Also 
</h4>

<p><a name="999987"> </a><a href="UI_Window.html#1028506"><code>WinDrawLine()</code></a>, <a href="UI_Window.html#1027898"><code>WinDrawGrayLine()</code></a>, <a href="UI_Window.html#1029727"><code>WinEraseLine()</code></a>, <a href="UI_Window.html#1145105"><code>WinFillLine()</code></a>, <a href="UI_Window.html#999137"><code>WinInvertLine()</code></a>, <a href="UI_Window.html#999872"><code>WinPaintLine()</code></a></p>

<h3 class="hbH3">
  <a name="999989"> </a>WinPaintPixel Function <a href="#1160850"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="1044453"> </a>Purpose 
</h4>

<p><a name="1044454"> </a>Renders a pixel in the draw window using the current drawing state.</p>
<h4>
  <a name="999997"> </a>Declared In 
</h4>
<code>Window.h<a name="1000000"> </a></code><h4>
  <a name="1000002"> </a>Prototype 
</h4>
<pre class="proto"><a name="1000005"></a>void WinPaintPixel (
   Coord <code class="par">x</code>,
   Coord <code class="par">y</code>
)
</pre>
<h4>
  <a name="1000007"> </a>Parameters 
</h4>

<dl>
<dt><a name="1044458"> </a><code>&rarr;  <i>x</i></code></dt>
<dd><a name="1044459"> </a>A pointer to the x coordinate of a pixel.</dd>

<dt><a name="1044460"> </a><code>&rarr;  <i>y</i></code></dt>
<dd><a name="1044461"> </a>A pointer to the y coordinate of a pixel.</dd>

</dl>
<h4>
  <a name="1044462"> </a>Returns 
</h4>

<p><a name="1044463"> </a>Nothing.</p>
<h4>
  <a name="1044464"> </a>Comments 
</h4>

<p><a name="1044465"> </a>This function uses the current drawing state. </p>
<h4>
  <a name="1453721"> </a>Compatibility 
</h4>

<p><a name="1453722"> </a>Do not use this function with the graphics context. Use <a href="UI_GraphicContext.html#1118074"><code>GcLineTo()</code></a> instead. </p>
<h4>
  <a name="1000028"> </a>See Also 
</h4>

<p><a name="1000031"> </a><a href="UI_Window.html#1028592"><code>WinDrawPixel()</code></a>, <a href="UI_Window.html#1029808"><code>WinErasePixel()</code></a>, <a href="UI_Window.html#999210"><code>WinInvertPixel()</code></a>, <a href="UI_Window.html#1000033"><code>WinPaintPixels()</code></a></p>

<h3 class="hbH3">
  <a name="1000033"> </a>WinPaintPixels Function <a href="#1160850"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="1000040"> </a>Purpose 
</h4>

<p><a name="1044501"> </a>Renders several pixels in the draw window using the current drawing state.</p>
<h4>
  <a name="1000045"> </a>Declared In 
</h4>
<code>Window.h<a name="1000048"> </a></code><h4>
  <a name="1000050"> </a>Prototype 
</h4>
<pre class="proto"><a name="1000053"></a>void WinPaintPixels (
   uint16_t <code class="par">numPoints</code>,
   PointType <code class="par">pts[]</code>
)
</pre>
<h4>
  <a name="1000055"> </a>Parameters 
</h4>

<dl>
<dt><a name="1044520"> </a><code>&rarr;  <i>numPoints</i></code></dt>
<dd><a name="1044521"> </a>The number of pixels to paint.</dd>

<dt><a name="1044522"> </a><code>&rarr;  <i>pts</i></code></dt>
<dd><a name="1044523"> </a>An array of pixels.</dd>

</dl>
<h4>
  <a name="1044524"> </a>Returns 
</h4>

<p><a name="1044525"> </a>Nothing.</p>
<h4>
  <a name="1044526"> </a>Comments 
</h4>

<p><a name="1044527"> </a>This function uses the current drawing state. </p>
<h4>
  <a name="1453751"> </a>Compatibility 
</h4>

<p><a name="1453752"> </a>Do not use this function with the graphics context. Use <a href="UI_GraphicContext.html#1118074"><code>GcLineTo()</code></a> instead. </p>
<h4>
  <a name="1044536"> </a>See Also 
</h4>

<p><a name="1044546"> </a><a href="UI_Window.html#1028592"><code>WinDrawPixel()</code></a>, <a href="UI_Window.html#1029808"><code>WinErasePixel()</code></a>, <a href="UI_Window.html#999210"><code>WinInvertPixel()</code></a>, <a href="UI_Window.html#999989"><code>WinPaintPixel()</code></a></p>

<h3 class="hbH3">
  <a name="1000081"> </a>WinPaintRectangle Function <a href="#1160850"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="1000084"> </a>Purpose 
</h4>

<p><a name="1044768"> </a>Draws a rectangle in the draw window using the current drawing state.</p>
<h4>
  <a name="1000089"> </a>Declared In 
</h4>
<code>Window.h<a name="1000092"> </a></code><h4>
  <a name="1000094"> </a>Prototype 
</h4>
<pre class="proto"><a name="1000097"></a>void WinPaintRectangle (
   const RectangleType <code class="par">*rP</code>,
   uint16_t <code class="par">cornerDiam</code>
)
</pre>
<h4>
  <a name="1000099"> </a>Parameters 
</h4>

<dl>
<dt><a name="1044822"> </a><code>&rarr;  <i>rP</i></code></dt>
<dd><a name="1044823"> </a>The pointer to the rectangle to draw (see <a href="UI_Rectangle.html#994219"><code>RectangleType</code></a>).</dd>

<dt><a name="1044824"> </a><code>&rarr;  <i>cornerDiam</i></code></dt>
<dd><a name="1044825"> </a>The radius of rounded corners. Specify zero for square corners.</dd>

</dl>
<h4>
  <a name="1044826"> </a>Returns 
</h4>

<p><a name="1044827"> </a>Nothing.</p>
<h4>
  <a name="1044828"> </a>Comments 
</h4>

<p><a name="1044829"> </a>The <code class="par">cornerDiam</code> parameter specifies the radius of four imaginary circles used to form the rounded corners. An imaginary circle is placed within each corner tangent to the rectangle on two sides.</p>

<p><a name="1044830"> </a>This function uses the current drawing state. </p>
<h4>
  <a name="1453798"> </a>Compatibility 
</h4>

<p><a name="1765086"> </a>The <code>winInvert</code> and <code>winSwap</code> drawing mode do not work when you draw a rectangle frame or unfilled rectangle. Nothing is drawn to the screen. </p>

<p><a name="1453799"> </a>Do not use this function with the graphics context. Use <a href="UI_GraphicContext.html#1122410"><code>GcRect()</code></a> instead. Note that <code>GcRect()</code> specifies a rectangle's bounds differently than a <code>RectangleType</code> structure does. </p>
<h4>
  <a name="1044861"> </a>See Also 
</h4>

<p><a name="1044871"> </a><a href="UI_Window.html#1028621"><code>WinDrawRectangle()</code></a>, <a href="UI_Window.html#1029842"><code>WinEraseRectangle()</code></a>, <a href="UI_Window.html#1029991"><code>WinFillRectangle()</code></a>, <a href="UI_Window.html#999254"><code>WinInvertRectangle()</code></a></p>

<h3 class="hbH3">
  <a name="1000125"> </a>WinPaintRectangleFrame Function <a href="#1160850"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="1000128"> </a>Purpose 
</h4>

<p><a name="1044880"> </a>Draws a rectangular frame in the draw window using the current drawing state.</p>
<h4>
  <a name="1000145"> </a>Declared In 
</h4>
<code>Window.h<a name="1000166"> </a></code><h4>
  <a name="1000190"> </a>Prototype 
</h4>
<pre class="proto"><a name="1000217"></a>void WinPaintRectangleFrame (
   FrameType <code class="par">frame</code>,
   const RectangleType <code class="par">*rP</code>
)
</pre>
<h4>
  <a name="1000255"> </a>Parameters 
</h4>

<dl>
<dt><a name="1044899"> </a><code>&rarr;  <i>frame</i></code></dt>
<dd><a name="1044903"> </a>The type of frame to draw (see <a href="UI_Window.html#1610364"><code>FrameType</code></a>).</dd>

<dt><a name="1044904"> </a><code>&rarr;  <i>rP</i></code></dt>
<dd><a name="1044905"> </a>A pointer to the rectangle to frame (see <a href="UI_Rectangle.html#994219"><code>RectangleType</code></a>).</dd>

</dl>
<h4>
  <a name="1044906"> </a>Returns 
</h4>

<p><a name="1044907"> </a>Nothing.</p>
<h4>
  <a name="1044908"> </a>Comments 
</h4>

<p><a name="1044909"> </a>The frame is drawn outside the specified rectangle.</p>

<p><a name="1044910"> </a>This function uses the current drawing state. </p>
<h4>
  <a name="1453808"> </a>Compatibility 
</h4>

<p><a name="1765102"> </a>The <code>winInvert</code> and <code>winSwap</code> drawing mode do not work when you draw a rectangle frame or unfilled rectangle. Nothing is drawn to the screen. </p>

<p><a name="1453812"> </a>Do not use this function with the graphics context. Use <a href="UI_GraphicContext.html#1122410"><code>GcRect()</code></a> instead. Note that <code>GcRect()</code> specifies a rectangle's bounds differently than a <code>RectangleType</code> structure does. </p>
<h4>
  <a name="1000372"> </a>See Also 
</h4>

<p><a name="1000375"> </a><a href="UI_Window.html#1027939"><code>WinDrawGrayRectangleFrame()</code></a>, <a href="UI_Window.html#1570711"><code>WinDrawRectangleFrame()</code></a>, <a href="UI_Window.html#1029878"><code>WinEraseRectangleFrame()</code></a>, <a href="UI_Window.html#1497232"><code>WinGetFramesRectangle()</code></a>, <a href="UI_Window.html#999326"><code>WinInvertRectangleFrame()</code></a>, <a href="UI_Window.html#1000377"><code>WinPaintRoundedRectangleFrame()</code></a></p>

<h3 class="hbH3">
  <a name="1000377"> </a>WinPaintRoundedRectangleFrame Function <a href="#1160850"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="1000380"> </a>Purpose 
</h4>

<p><a name="1045018"> </a>Draws a rectangular frame with rounded corners in the draw window using the current drawing state.</p>
<h4>
  <a name="1000385"> </a>Declared In 
</h4>
<code>Window.h<a name="1000388"> </a></code><h4>
  <a name="1000390"> </a>Prototype 
</h4>
<pre class="proto"><a name="1000393"></a>void WinPaintRoundedRectangleFrame (
   const RectangleType <code class="par">*rP</code>,
   Coord <code class="par">width</code>,
   Coord <code class="par">cornerRadius</code>,
   Coord <code class="par">shadowWidth</code>
)
</pre>
<h4>
  <a name="1000395"> </a>Parameters 
</h4>

<dl>
<dt><a name="1045022"> </a><code>&rarr;  <i>rP</i></code></dt>
<dd><a name="1045023"> </a>A pointer to the rectangle to frame (see <a href="UI_Rectangle.html#994219"><code>RectangleType</code></a>).</dd>

<dt><a name="1045024"> </a><code>&rarr;  <i>width</i></code></dt>
<dd><a name="1045025"> </a>The width of the frame, interpreted using the active coordinate system.</dd>

<dt><a name="1045026"> </a><code>&rarr;  <i>cornerRadius</i></code></dt>
<dd><a name="1045027"> </a>The radius of the rectangle's rounded corners, interpreted using the active coordinate system.</dd>

<dt><a name="1045028"> </a><code>&rarr;  <i>shadowWidth</i></code></dt>
<dd><a name="1045029"> </a>The shadow offset, interpreted using the active coordinate system.</dd>

</dl>
<h4>
  <a name="1000414"> </a>Returns 
</h4>

<p><a name="1045161"> </a>Nothing.</p>
<h4>
  <a name="1045162"> </a>Comments 
</h4>

<p><a name="1765121"> </a>The <code>winInvert</code> and <code>winSwap</code> drawing mode do not work when you draw a rectangle frame or unfilled rectangle. Nothing is drawn to the screen. </p>

<p><a name="1045163"> </a>This function allows you to draw a rectangle with a frame width and corner radius specified in the active coordinate system. It is necessary because <a href="UI_Window.html#1000125"><code>WinPaintRectangleFrame()</code></a> doesn't allow you to draw rounded rectangles with a frame width greater than 2. Note that because there isn't a function that parallels either <a href="UI_Window.html#1570711"><code>WinDrawRectangleFrame()</code></a>, <a href="UI_Window.html#1029878"><code>WinEraseRectangleFrame()</code></a>, or <a href="UI_Window.html#999326"><code>WinInvertRectangleFrame()</code></a>, you must set the drawing mode and colors as appropriate and use <code>WinPaintRoundedRectangleFrame()</code> to achieve the desired effect.</p>
<h4>
  <a name="1453818"> </a>Compatibility 
</h4>

<p><a name="1453822"> </a>Do not use this function with the graphics context. Use <a href="UI_GraphicContext.html#994936"><code>GcRoundRect()</code></a> instead. Note that <code>GcRoundRect()</code> specifies a rectangle's bounds differently than a <code>RectangleType</code> structure does. </p>

<h3 class="hbH3">
  <a name="1000472"> </a>WinPaintTiledBitmap Function <a href="#1160850"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="1000499"> </a>Purpose 
</h4>

<p><a name="1045185"> </a>Fills a rectangle with a pattern defined by a bitmap.</p>
<h4>
  <a name="1000504"> </a>Declared In 
</h4>
<code>Window.h<a name="1000507"> </a></code><h4>
  <a name="1000509"> </a>Prototype 
</h4>
<pre class="proto"><a name="1000512"></a>void WinPaintTiledBitmap (
   const BitmapType <code class="par">*bitmapP</code>,
   RectangleType <code class="par">*rectP</code>
)
</pre>
<h4>
  <a name="1000514"> </a>Parameters 
</h4>

<dl>
<dt><a name="1045189"> </a><code>&rarr;  <i>bitmapP</i></code></dt>
<dd><a name="1045190"> </a>A pointer to the bitmap that contains the desired pattern.</dd>

<dt><a name="1045191"> </a><code>&rarr;  <i>rectP</i></code></dt>
<dd><a name="1045192"> </a>A pointer to the rectangle that is to be filled (see <a href="UI_Rectangle.html#994219"><code>RectangleType</code></a>).</dd>

</dl>
<h4>
  <a name="1045193"> </a>Returns 
</h4>

<p><a name="1045194"> </a>Nothing. On a debug ROM, if either <code class="par">bitmapP</code> or <code class="par">rectP</code> are <code>NULL</code>, an error is displayed.</p>
<h4>
  <a name="1000530"> </a>Comments 
</h4>

<p><a name="1045198"> </a>This function makes it possible for an application to define a pattern that is larger than the standard 8 by 8 custom pattern, and to define high-density custom patterns.</p>

<p><a name="1045199"> </a>The pattern is scaled using the density of <code class="par">bitmapP</code> and the density of the screen bitmap. <code class="par">bitmapP</code> can be a bitmap family; if it is, the Window Manager selects a bitmap using the same algorithm used by <a href="UI_Window.html#999434"><code>WinPaintBitmap()</code></a>. As with other patterns, the tiled pattern is anchored to the window's origin.</p>
<h4>
  <a name="1453852"> </a>Compatibility 
</h4>

<p><a name="1453856"> </a>Do not use this function with the graphics context. Use <a href="UI_GraphicContext.html#1120182"><code>GcPaintBitmap()</code></a> instead. </p>

<h3 class="hbH3">
  <a name="1655765"> </a>WinPaintThinLine Function <a href="#1160850"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="1655767"> </a>Purpose 
</h4>

<p><a name="1655768"> </a>Draws a line that is one pixel thick. </p>
<h4>
  <a name="1655769"> </a>Declared In 
</h4>
<code>Window.h<a name="1655770"> </a></code><h4>
  <a name="1655771"> </a>Prototype 
</h4>
<pre class="proto"><a name="1655772"></a>void WinPaintThinLine (
   Coord <code class="par">x1</code>,
   Coord <code class="par">y1</code>,
   Coord <code class="par">x2</code>,
   Coord <code class="par">y2</code>
)
</pre>
<h4>
  <a name="1657873"> </a>Parameters 
</h4>

<dl>
<dt><a name="1658363"> </a><code>&rarr;  <i>x1</i></code></dt>
<dd><a name="1658364"> </a>The x coordinate of line start point.</dd>

<dt><a name="1658365"> </a><code>&rarr;  <i>y1</i></code></dt>
<dd><a name="1658366"> </a>The y coordinate of line start point.</dd>

<dt><a name="1658367"> </a><code>&rarr;  <i>x2</i></code></dt>
<dd><a name="1658368"> </a>The x coordinate of line endpoint.</dd>

<dt><a name="1658369"> </a><code>&rarr;  <i>y2</i></code></dt>
<dd><a name="1658370"> </a>The y coordinate of line endpoint.</dd>

</dl>
<h4>
  <a name="1658385"> </a>Returns 
</h4>

<p><a name="1658390"> </a>Nothing. </p>
<h4>
  <a name="1658424"> </a>Comments 
</h4>

<p><a name="1658525"> </a>The text field uses this function when it needs to extend the text underline past the end of the text. </p>
<h4>
  <a name="1658398"> </a>Compatibility 
</h4>

<p><a name="1658399"> </a>Do not use this function with the graphics context. Use <a href="UI_GraphicContext.html#1118074"><code>GcLineTo()</code></a> instead. </p>
<h4>
  <a name="1658137"> </a>See Also 
</h4>

<p><a name="1658197"> </a><a href="UI_Window.html#999872"><code>WinPaintLine()</code></a></p>

<h3 class="hbH3">
  <a name="1000540"> </a>WinPaintTruncChars Function <a href="#1160850"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="1000543"> </a>Purpose 
</h4>

<p><a name="1327308"> </a>Draws the specified characters in the draw window using the current transfer mode, truncating the characters to the specified width.</p>
<h4>
  <a name="1000548"> </a>Declared In 
</h4>
<code>Window.h<a name="1000551"> </a></code><h4>
  <a name="1000553"> </a>Prototype 
</h4>
<pre class="proto"><a name="1000556"></a>void WinPaintTruncChars (
   const char <code class="par">*chars</code>,
   int16_t <code class="par">len</code>,
   Coord <code class="par">x</code>,
   Coord <code class="par">y</code>,
   Coord <code class="par">maxWidth</code>
)
</pre>
<h4>
  <a name="1000558"> </a>Parameters 
</h4>

<dl>
<dt><a name="1326904"> </a><code>&rarr;  <i>chars</i></code></dt>
<dd><a name="1326905"> </a>A pointer to the characters to draw.</dd>

<dt><a name="1326906"> </a><code>&rarr;  <i>len</i></code></dt>
<dd><a name="1326907"> </a>The length in bytes of the characters to draw.</dd>

<dt><a name="1326908"> </a><code>&rarr;  <i>x</i></code></dt>
<dd><a name="1326909"> </a>The x coordinate of the first character to draw (left bound).</dd>

<dt><a name="1326910"> </a><code>&rarr;  <i>y</i></code></dt>
<dd><a name="1326911"> </a>The y coordinate of the first character to draw (top bound).</dd>

<dt><a name="1326912"> </a><code>&rarr;  <i>maxWidth</i></code></dt>
<dd><a name="1326913"> </a>The maximum width in pixels of the characters that are to be drawn.</dd>

</dl>
<h4>
  <a name="1326914"> </a>Returns 
</h4>

<p><a name="1326915"> </a>Nothing.</p>
<h4>
  <a name="1326916"> </a>Comments 
</h4>

<p><a name="1326917"> </a>Before calling this function, consider calling <a href="UI_Window.html#1004002"><code>WinSetTextColor()</code></a>, <a href="UI_Window.html#1004170"><code>WinSetUnderlineMode()</code></a> and <a href="UI_Font.html#995852"><code>FntSetFont()</code></a>. </p>

<p><a name="1326924"> </a>If drawing all of the specified characters requires more space than <code class="par">maxWidth</code> allows, <code>WinPainTruncChars()</code> draws one less than the number of characters that can fit in <code class="par">maxWidth</code> and then draws an ellipsis (...) in the remaining space. (If the boundary characters are narrower than the ellipsis, more than one character may be dropped to make room.) If <code class="par">maxWidth</code> is narrower than the width of an ellipsis, nothing is drawn. </p>

<p><a name="1326925"> </a>Use this function to truncate text that may contain multi-byte characters. </p>

<p><a name="1329884"> </a>This function differs from <a href="UI_Window.html#1029074"><code>WinDrawTruncChars()</code></a> in that it uses the current drawing state's transfer mode. <code>WinDrawTruncChars() </code>always uses <code>winPaint</code>. </p>
<h4>
  <a name="1453916"> </a>Compatibility 
</h4>

<p><a name="1453917"> </a>Do not use this function with the graphics context. Use <a href="UI_GraphicContext.html#1196638"><code>GcDrawTextAt()</code></a> instead. Note that <code>GcDrawTextAt()</code> uses the y value as the baseline for the font whereas <code>WinPaintTruncChars()</code> uses the y value as the top of the character. </p>
<h4>
  <a name="1326935"> </a>See Also 
</h4>

<p><a name="1326945"> </a><a href="UI_Window.html#1026950"><code>WinDrawChar()</code></a>, <a href="UI_Window.html#1027460"><code>WinDrawChars()</code></a>, <a href="UI_Window.html#1028455"><code>WinDrawInvertedChars()</code></a>, <a href="UI_Window.html#1029680"><code>WinEraseChars()</code></a>, <a href="UI_Window.html#999081"><code>WinInvertChars()</code></a>, <a href="UI_Window.html#999742"><code>WinPaintChar()</code></a>, <a href="UI_Window.html#999796"><code>WinPaintChars()</code></a>, <a href="UI_Window.html#1029074"><code>WinDrawTruncChars()</code></a></p>

<h3 class="hbH3">
  <a name="1144225"> </a>WinPopDrawState Function <a href="#1160850"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="1000659"> </a>Purpose 
</h4>

<p><a name="1046023"> </a>Restores the draw state values to the last saved set on the stack.</p>
<h4>
  <a name="1000672"> </a>Declared In 
</h4>
<code>Window.h<a name="1000683"> </a></code><h4>
  <a name="1000693"> </a>Prototype 
</h4>
<pre class="proto"><a name="1000704"></a>void WinPopDrawState (
   void
)
</pre>
<h4>
  <a name="1000714"> </a>Parameters 
</h4>

<p><a name="1000725"> </a>None.</p>
<h4>
  <a name="1000735"> </a>Returns 
</h4>

<p><a name="1046055"> </a>Nothing.</p>
<h4>
  <a name="1046056"> </a>Comments 
</h4>

<p><a name="1046057"> </a>Use this routine to restore the draw state saved by the previous call to <a href="UI_Window.html#1000758"><code>WinPushDrawState()</code></a>.</p>
<h4>
  <a name="1454913"> </a>Compatibility 
</h4>

<p><a name="1454950"> </a>Do not use this function with the graphics context. Use <a href="UI_GraphicContext.html#1121283"><code>GcPopState()</code></a> instead. </p>

<h3 class="hbH3">
  <a name="1000758"> </a>WinPushDrawState Function <a href="#1160850"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="1000761"> </a>Purpose 
</h4>

<p><a name="1000764"> </a>Saves the current draw state values onto the draw state stack.</p>
<h4>
  <a name="1000766"> </a>Declared In 
</h4>
<code>Window.h<a name="1000769"> </a></code><h4>
  <a name="1000771"> </a>Prototype 
</h4>
<pre class="proto"><a name="1000774"></a>void WinPushDrawState (
   void
)
</pre>
<h4>
  <a name="1000776"> </a>Parameters 
</h4>

<p><a name="1000779"> </a>None.</p>
<h4>
  <a name="1000781"> </a>Returns 
</h4>

<p><a name="1046113"> </a>Nothing.</p>
<h4>
  <a name="1046114"> </a>Comments 
</h4>

<p><a name="1046115"> </a>Use this routine to save the current draw state before making changes to it. Call <a href="UI_Window.html#1144225"><code>WinPopDrawState()</code></a> to restore the saved settings.</p>
<h4>
  <a name="1454979"> </a>Compatibility 
</h4>

<p><a name="1454980"> </a>Do not use this function with the graphics context. Use <a href="UI_GraphicContext.html#1121303"><code>GcPushState()</code></a> instead. </p>

<h3 class="hbH3">
  <a name="1000947"> </a>WinResetClip Function <a href="#1160850"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="1000950"> </a>Purpose 
</h4>

<p><a name="1000953"> </a>Resets the clipping rectangle of the draw window to the portion of the draw window that is within the bounds of the display. </p>
<h4>
  <a name="1000955"> </a>Declared In 
</h4>
<code>Window.h<a name="1000958"> </a></code><h4>
  <a name="1000960"> </a>Prototype 
</h4>
<pre class="proto"><a name="1000963"></a>void WinResetClip (
   void
)
</pre>
<h4>
  <a name="1000965"> </a>Parameters 
</h4>

<p><a name="1000968"> </a>None.</p>
<h4>
  <a name="1049119"> </a>Returns 
</h4>

<p><a name="1455015"> </a>Nothing.</p>
<h4>
  <a name="1455016"> </a>See Also 
</h4>

<p><a name="1455020"> </a><a href="UI_Window.html#1539836"><code>WinSetClip()</code></a></p>

<h3 class="hbH3">
  <a name="1002597"> </a>WinSetBackColor Function <a href="#1160850"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="1002600"> </a>Purpose 
</h4>

<p><a name="1073299"> </a>Sets the background color to use in subsequent draw operations.</p>
<h4>
  <a name="1002605"> </a>Declared In 
</h4>
<code>Window.h<a name="1002608"> </a></code><h4>
  <a name="1002610"> </a>Prototype 
</h4>
<pre class="proto"><a name="1002613"></a>IndexedColorType WinSetBackColor (
   IndexedColorType <code class="par">backColor</code>
)
</pre>
<h4>
  <a name="1002615"> </a>Parameters 
</h4>

<dl>
<dt><a name="1073307"> </a><code>&rarr;  <i>backColor</i></code></dt>
<dd><a name="1073311"> </a>The color to set; specify a value of type <a href="UI_Window.html#1407675"><code>IndexedColorType</code></a>.</dd>

</dl>
<h4>
  <a name="1073312"> </a>Returns 
</h4>

<p><a name="1073313"> </a>The previous background color index.</p>
<h4>
  <a name="1073314"> </a>Comments 
</h4>

<p><a name="1073315"> </a>This function changes the current drawing state. If necessary, use <a href="UI_Window.html#1000758"><code>WinPushDrawState()</code></a> to preserve the current drawing state before you set this function and use <a href="UI_Window.html#1144225"><code>WinPopDrawState()</code></a> to restore it later. </p>

<p><a name="1073322"> </a>To set the foreground color to a predefined UI color default, use <a href="UI_Color.html#993462"><code>UIColorGetTableEntryIndex()</code></a> as an input to this function. For example: </p>

<div class="CodeRule"><hr></div><pre class="CodeBlock">
curColor = WinSetBackColor
(UIColorGetTableEntryIndex(<code>UIFieldBackground</code>));<a name="1073326"> </a>
</pre><div class="CodeRule"><hr></div>


<p><a name="1394942"> </a>Using <a href="UI_Window.html#1002637"><code>WinSetBackColorRGB()</code></a> is preferred over this function. It is faster. </p>
<h4>
  <a name="1002632"> </a>See Also 
</h4>

<p><a name="1002635"> </a><a href="UI_Window.html#1003040"><code>WinSetForeColor()</code></a>, <a href="UI_Window.html#1004002"><code>WinSetTextColor()</code></a></p>

<h3 class="hbH3">
  <a name="1002637"> </a>WinSetBackColorRGB Function <a href="#1160850"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="1002644"> </a>Purpose 
</h4>

<p><a name="1073470"> </a>Sets the background color to use in subsequent draw operations.</p>
<h4>
  <a name="1002649"> </a>Declared In 
</h4>
<code>Window.h<a name="1002652"> </a></code><h4>
  <a name="1002654"> </a>Prototype 
</h4>
<pre class="proto"><a name="1002657"></a>void WinSetBackColorRGB (
   const RGBColorType <code class="par">*newRgbP</code>,
   RGBColorType <code class="par">*prevRgbP</code>
)
</pre>
<h4>
  <a name="1002659"> </a>Parameters 
</h4>

<dl>
<dt><a name="1073522"> </a><code>&rarr;  <i>newRgbP</i></code></dt>
<dd><a name="1073526"> </a>The color to set; specify a value of type <a href="UI_Bitmap.html#1004052"><code>RGBColorType</code></a>.</dd>

<dt><a name="1073527"> </a><code>&larr;  <i>prevRgbP</i></code></dt>
<dd><a name="1073531"> </a>The previous color; specify a value of type <a href="UI_Bitmap.html#1004052"><code>RGBColorType</code></a>.</dd>

</dl>
<h4>
  <a name="1073532"> </a>Returns 
</h4>

<p><a name="1073533"> </a>Nothing</p>
<h4>
  <a name="1073534"> </a>Comments 
</h4>

<p><a name="1329497"> </a>This function takes new and previous <a href="UI_Bitmap.html#1004052"><code>RGBColorType</code></a> arguments. It is okay to set <code class="par">newRgbP</code> or <code class="par">prevRgbP</code> to <code>NULL</code>. If an application only wants to get the current color, the <code class="par">newRgbP</code> argument is set to <code>NULL</code>. If the application does not care about the previous color, <code class="par">prevRgbP</code> can be set to <code>NULL</code>.</p>

<p><a name="1073542"> </a>This function sets the background color to the value specified by <code class="par">newRgbP</code>. It then sets the index field of <code>backColorRGB</code> to the 8 bit system palette entry that most closely matches the RGB components. Finally, it sets the <code>backColor</code> index field to this index value.</p>

<p><a name="1073546"> </a>This function changes the current drawing state. If necessary, use <a href="UI_Window.html#1000758"><code>WinPushDrawState()</code></a> to preserve the current drawing state before you set this function and use <a href="UI_Window.html#1144225"><code>WinPopDrawState()</code></a> to restore it later. </p>
<h4>
  <a name="1457938"> </a>Compatibility 
</h4>

<p><a name="1457939"> </a>Do not use this function with the graphics context. Use <a href="UI_GraphicContext.html#1124873"><code>GcSetColor()</code></a> instead. </p>
<h4>
  <a name="1002680"> </a>See Also 
</h4>

<p><a name="1002683"> </a><a href="UI_Window.html#1003354"><code>WinSetForeColorRGB()</code></a>, <a href="UI_Window.html#1004042"><code>WinSetTextColorRGB()</code></a></p>

<h3 class="hbH3">
  <a name="1539836"> </a>WinSetClip Function <a href="#1160850"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="1539838"> </a>Purpose 
</h4>

<p><a name="1539839"> </a>Sets the clipping rectangle of the draw window.</p>
<h4>
  <a name="1539840"> </a>Declared In 
</h4>
<code>Window.h<a name="1539841"> </a></code><h4>
  <a name="1539842"> </a>Prototype 
</h4>
<pre class="proto"><a name="1539843"></a>void WinSetClip (
   const RectangleType <code class="par">*rP</code>
)
</pre>
<h4>
  <a name="1539844"> </a>Parameters 
</h4>

<dl>
<dt><a name="1539845"> </a><code>&rarr;  <i>rP</i></code></dt>
<dd><a name="1539846"> </a>A pointer to a structure holding the clipping bounds (see <a href="UI_Rectangle.html#994219"><code>RectangleType</code></a>).</dd>

</dl>
<h4>
  <a name="1539847"> </a>Returns 
</h4>

<p><a name="1539848"> </a>Nothing.</p>
<h4>
  <a name="1539849"> </a>Compatibility 
</h4>

<p><a name="1539850"> </a>This function sets a rectangular region of the window into which the application may draw. It differs from <a href="UI_GraphicContext.html#1104793"><code>GcBeginClip()</code></a> in that <code>GcBeginClip()</code> works only with a graphics context and is able to define non-rectangular clipping regions. </p>
<h4>
  <a name="1539854"> </a>See Also 
</h4>

<p><a name="1539864"> </a><a href="UI_Window.html#1021501"><code>WinClipRectangle()</code></a>, <a href="UI_Window.html#1539836"><code>WinSetClip()</code></a>, <a href="UI_Window.html#1492237"><code>WinGetClip()</code></a></p>

<h3 class="hbH3">
  <a name="1539865"> </a>WinSetColors Function <a href="#1160850"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="1539867"> </a>Purpose 
</h4>

<p><a name="1539868"> </a>Sets the colors. </p>
<h4>
  <a name="1539869"> </a>Declared In 
</h4>
<code>Window.h<a name="1539870"> </a></code><h4>
  <a name="1539871"> </a>Prototype 
</h4>
<pre class="proto"><a name="1539872"></a>void WinSetColors (
   const RGBColorType <code class="par">*newForeColorP</code>,
   RGBColorType <code class="par">*oldForeColorP</code>,
   const RGBColorType <code class="par">*newBackColorP</code>,
   RGBColorType <code class="par">*oldBackColorP</code>
)
</pre>
<h4>
  <a name="1539873"> </a>Parameters 
</h4>

<dl>
<dt><a name="1539874"> </a><code>&rarr;  <i>newForeColorP</i></code></dt>
<dd><a name="1539875"> </a>The color to use for the foreground and the text; specify a value of type <a href="UI_Bitmap.html#1004052"><code>RGBColorType</code></a>.</dd>

<dt><a name="1539879"> </a><code>&larr;  <i>oldForeColorP</i></code></dt>
<dd><a name="1539880"> </a>Previous foreground color.</dd>

<dt><a name="1539881"> </a><code>&rarr;  <i>newBackColorP</i></code></dt>
<dd><a name="1539882"> </a>The color to use for the background; specify a value of type <a href="UI_Bitmap.html#1004052"><code>RGBColorType</code></a>.</dd>

<dt><a name="1539886"> </a><code>&larr;  <i>oldBackColorP</i></code></dt>
<dd><a name="1539887"> </a>Previous background color.</dd>

</dl>
<h4>
  <a name="1539888"> </a>Returns 
</h4>

<p><a name="1539889"> </a>Nothing. </p>
<h4>
  <a name="1539890"> </a>See Also 
</h4>

<p><a name="1539897"> </a><a href="UI_Window.html#1002637"><code>WinSetBackColorRGB()</code></a>, <a href="UI_Window.html#1004042"><code>WinSetTextColorRGB()</code></a>, <a href="UI_Window.html#1003354"><code>WinSetForeColorRGB()</code></a></p>

<h3 class="hbH3">
  <a name="1002873"> </a>WinSetCoordinateSystem Function <a href="#1160850"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="1002876"> </a>Purpose 
</h4>

<p><a name="1073708"> </a>Establishes the coordinate system to be used for subsequent drawing operations.</p>
<h4>
  <a name="1002881"> </a>Declared In 
</h4>
<code>Window.h<a name="1002884"> </a></code><h4>
  <a name="1002886"> </a>Prototype 
</h4>
<pre class="proto"><a name="1002889"></a>uint16_t WinSetCoordinateSystem (
   uint16_t <code class="par">coordSys</code>
)
</pre>
<h4>
  <a name="1002891"> </a>Parameters 
</h4>

<dl>
<dt><a name="1073716"> </a><code>&rarr;  <i>coordSys</i></code></dt>
<dd><a name="1073717"> </a>The desired coordinate system. Supply one of the values defined in <a href="UI_Window.html#1687709">"Coordinate System Constants."</a></dd>

</dl>
<h4>
  <a name="1073721"> </a>Returns 
</h4>

<p><a name="1073722"> </a>The previous coordinate system value.</p>
<h4>
  <a name="1073723"> </a>Comments 
</h4>

<p><a name="1073724"> </a>This function modifies the draw state. As when making other modifications to a window's draw state, applications should call <a href="UI_Window.html#1000758"><code>WinPushDrawState()</code></a> before modifying the coordinate system. To restore the coordinate system, your application can then call <a href="UI_Window.html#1144225"><code>WinPopDrawState()</code></a>.</p>

<p><a name="1329823"> </a>To calculate the amount by which it will scale all coordinates, the Window Manager divides the density of the bitmap associated with the draw window by <code class="par">coordSys</code>. If <code class="par">coordSys</code> is <code>kCoordinatesNative</code>, the Window Manager sets the scale field to 1.0, which to enables 1-to-1 mapping of coordinates to pixels. </p>

<p><a name="1073735"> </a>If you supply a value of <code>kCoordinatesStandard</code> for <code class="par">coordSys</code>, subsequent drawing will use the standard coordinate system.</p>
<h4>
  <a name="1740339"> </a>Compatibility 
</h4>

<p><a name="1740388"> </a>If you are making graphics context calls, use <a href="UI_GraphicContext.html#1124904"><code>GcSetCoordinateSystem()</code></a> to set the coordinate system that the graphics context uses within the window. It is a good idea to always make both calls so that you are certain that the window's coordinate system is the same as the graphics context's coordinate system. </p>
<h4>
  <a name="1002931"> </a>See Also 
</h4>

<p><a name="1002942"> </a><a href="UI_Window.html#1492257"><code>WinGetCoordinateSystem()</code></a></p>

<h3 class="hbH3">
  <a name="1002952"> </a>WinSetDrawMode Function <a href="#1160850"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="1002963"> </a>Purpose 
</h4>

<p><a name="1002966"> </a>Sets the transfer mode to use in subsequent draw operations.</p>
<h4>
  <a name="1002968"> </a>Declared In 
</h4>
<code>Window.h<a name="1002971"> </a></code><h4>
  <a name="1002973"> </a>Prototype 
</h4>
<pre class="proto"><a name="1002976"></a>WinDrawOperation WinSetDrawMode (
   WinDrawOperation <code class="par">newMode</code>
)
</pre>
<h4>
  <a name="1002978"> </a>Parameters 
</h4>

<dl>
<dt><a name="1073678"> </a><code>&rarr;  <i>newMode</i></code></dt>
<dd><a name="1073682"> </a>The transfer mode to set; specify one of the <a href="UI_Window.html#1094199"><code>WinDrawOperation</code></a> values.</dd>

</dl>
<h4>
  <a name="1073683"> </a>Returns 
</h4>

<p><a name="1073684"> </a>The previous transfer mode.</p>
<h4>
  <a name="1073685"> </a>Comments 
</h4>

<p><a name="1073686"> </a>This function changes the current drawing state. If necessary, use <a href="UI_Window.html#1000758"><code>WinPushDrawState()</code></a> to preserve the current drawing state before you set this function and use <a href="UI_Window.html#1144225"><code>WinPopDrawState()</code></a> to restore it later. </p>
<h4>
  <a name="1459012"> </a>Compatibility 
</h4>

<p><a name="1459013"> </a>Do not use this function with the graphics context. </p>

<h3 class="hbH3">
  <a name="1003040"> </a>WinSetForeColor Function <a href="#1160850"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="1003043"> </a>Purpose 
</h4>

<p><a name="1003046"> </a>Sets the foreground color to use in subsequent draw operations.</p>
<h4>
  <a name="1003048"> </a>Declared In 
</h4>
<code>Window.h<a name="1003051"> </a></code><h4>
  <a name="1003053"> </a>Prototype 
</h4>
<pre class="proto"><a name="1003056"></a>IndexedColorType WinSetForeColor (
   IndexedColorType <code class="par">foreColor</code>
)
</pre>
<h4>
  <a name="1003116"> </a>Parameters 
</h4>

<dl>
<dt><a name="1003169"> </a><code>&rarr;  <i>foreColor</i></code></dt>
<dd><a name="1074147"> </a>The color to set; specify a value of type <a href="UI_Window.html#1407675"><code>IndexedColorType</code></a>.</dd>

</dl>
<h4>
  <a name="1074148"> </a>Returns 
</h4>

<p><a name="1074149"> </a>The previous foreground color index.</p>
<h4>
  <a name="1074150"> </a>Comments 
</h4>

<p><a name="1074151"> </a>This function changes the current drawing state. If necessary, use <a href="UI_Window.html#1000758"><code>WinPushDrawState()</code></a> to preserve the current drawing state before you set this function and use <a href="UI_Window.html#1144225"><code>WinPopDrawState()</code></a> to restore it later. </p>

<p><a name="1074158"> </a>To set the foreground color to a predefined UI color default, use <a href="UI_Color.html#993462"><code>UIColorGetTableEntryIndex()</code></a> as an input to this function. For example: </p>

<div class="CodeRule"><hr></div><pre class="CodeBlock">
curColor = WinSetForeColor
   (UIColorGetTableEntryIndex(UIObjectForeground));<a name="1074162"> </a>
</pre><div class="CodeRule"><hr></div>


<p><a name="1395654"> </a>Using <a href="UI_Window.html#1003354"><code>WinSetForeColorRGB()</code></a> is preferred over this function. It is faster. </p>
<h4>
  <a name="1459072"> </a>Compatibility 
</h4>

<p><a name="1459073"> </a>Do not use this function with the graphics context. Use <a href="UI_GraphicContext.html#1124873"><code>GcSetColor()</code></a> instead. </p>
<h4>
  <a name="1074217"> </a>See Also 
</h4>

<p><a name="1074224"> </a><a href="UI_Window.html#1002597"><code>WinSetBackColor()</code></a>, <a href="UI_Window.html#1004002"><code>WinSetTextColor()</code></a></p>

<h3 class="hbH3">
  <a name="1003354"> </a>WinSetForeColorRGB Function <a href="#1160850"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="1003357"> </a>Purpose 
</h4>

<p><a name="1074284"> </a>Sets the foreground color to use in subsequent draw operations.</p>
<h4>
  <a name="1003362"> </a>Declared In 
</h4>
<code>Window.h<a name="1003365"> </a></code><h4>
  <a name="1003367"> </a>Prototype 
</h4>
<pre class="proto"><a name="1003370"></a>void WinSetForeColorRGB (
   const RGBColorType <code class="par">*newRgbP</code>,
   RGBColorType <code class="par">*prevRgbP</code>
)
</pre>
<h4>
  <a name="1003372"> </a>Parameters 
</h4>

<dl>
<dt><a name="1074344"> </a><code>&rarr;  <i>newRgbP</i></code></dt>
<dd><a name="1074348"> </a>The color to set; specify a value of type <a href="UI_Bitmap.html#1004052"><code>RGBColorType</code></a>.</dd>

<dt><a name="1074349"> </a><code>&larr;  <i>prevRgbP</i></code></dt>
<dd><a name="1074353"> </a>Previous color</dd>

</dl>
<h4>
  <a name="1074354"> </a>Returns 
</h4>

<p><a name="1074355"> </a>Nothing.</p>
<h4>
  <a name="1074356"> </a>Comments 
</h4>

<p><a name="1074360"> </a>This function takes new and previous <a href="UI_Bitmap.html#1004052"><code>RGBColorType</code></a> arguments. It is okay to set <code class="par">newRgbP</code> or <code class="par">prevRgbP</code> to <code>NULL</code>. If an application only wants to get the current color, the <code class="par">newRgbP</code> argument is set to <code>NULL</code>. If the application does not care about the previous color, <code class="par">prevRgbP</code> can be set to <code>NULL</code>.</p>

<p><a name="1074364"> </a>This function sets the <code>foreColorRGB</code> field to the value specified by <code class="par">newRgbP</code>. It then sets the index field of <code>foreColorRGB</code> to the 8 bit system palette entry that most closely matches the RGB components. Finally, it sets the <code>foreColor</code> index field to this index value.</p>

<p><a name="1074368"> </a>This function changes the current drawing state. If necessary, use <a href="UI_Window.html#1000758"><code>WinPushDrawState()</code></a> to preserve the current drawing state before you set this function and use <a href="UI_Window.html#1144225"><code>WinPopDrawState()</code></a> to restore it later. </p>
<h4>
  <a name="1459082"> </a>Compatibility 
</h4>

<p><a name="1459083"> </a>Do not use this function with the graphics context. Use <a href="UI_GraphicContext.html#1124873"><code>GcSetColor()</code></a> instead. </p>
<h4>
  <a name="1074380"> </a>See Also 
</h4>

<p><a name="1074387"> </a><a href="UI_Window.html#1002637"><code>WinSetBackColorRGB()</code></a>, <a href="UI_Window.html#1004042"><code>WinSetTextColorRGB()</code></a></p>

<h3 class="hbH3">
  <a name="1003398"> </a>WinSetFrameType Function <a href="#1160850"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="1003401"> </a>Purpose 
</h4>

<p><a name="1003408"> </a>Sets the type of frame to be used for a specified window. </p>
<h4>
  <a name="1003418"> </a>Declared In 
</h4>
<code>Window.h<a name="1003439"> </a></code><h4>
  <a name="1003463"> </a>Prototype 
</h4>
<pre class="proto"><a name="1003490"></a>void WinSetFrameType (
   const WinHandle <code class="par">winH</code>,
   FrameType <code class="par">frame</code>
)
</pre>
<h4>
  <a name="1003528"> </a>Parameters 
</h4>

<dl>
<dt><a name="1003555"> </a><code>&rarr;  <i>winH</i></code></dt>
<dd><a name="1003581"> </a>The window's handle. </dd>

<dt><a name="1003607"> </a><code>&rarr;  <i>frame</i></code></dt>
<dd><a name="1003633"> </a>The style of frame to be used. See <a href="UI_Window.html#1610364"><code>FrameType</code></a>.</dd>

</dl>
<h4>
  <a name="1003635"> </a>Returns 
</h4>

<p><a name="1003638"> </a>Nothing. </p>
<h4>
  <a name="1003645"> </a>See Also 
</h4>

<p><a name="1003648"> </a><a href="UI_Window.html#1497210"><code>WinGetFrameType()</code></a></p>

<h3 class="hbH3">
  <a name="1003650"> </a>WinSetPattern Function <a href="#1160850"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="1003653"> </a>Purpose 
</h4>

<p><a name="1003656"> </a>Sets the current fill pattern.</p>
<h4>
  <a name="1003658"> </a>Declared In 
</h4>
<code>Window.h<a name="1003661"> </a></code><h4>
  <a name="1003663"> </a>Prototype 
</h4>
<pre class="proto"><a name="1003666"></a>void WinSetPattern (
   const CustomPatternType <code class="par">*patternP</code>
)
</pre>
<h4>
  <a name="1003668"> </a>Parameters 
</h4>

<dl>
<dt><a name="1074430"> </a><code>&rarr;  <i>patternP</i></code></dt>
<dd><a name="1074434"> </a>The pattern to set (see <a href="UI_Window.html#1093797"><code>CustomPatternType</code></a>).</dd>

</dl>
<h4>
  <a name="1074435"> </a>Returns 
</h4>

<p><a name="1074436"> </a>Nothing.</p>
<h4>
  <a name="1074437"> </a>Comments 
</h4>

<p><a name="1074444"> </a>The fill pattern is used by <a href="UI_Window.html#1145105"><code>WinFillLine()</code></a> and <a href="UI_Window.html#1029991"><code>WinFillRectangle()</code></a>.</p>

<p><a name="1074445"> </a>This function changes the current drawing state. If necessary, use <a href="UI_Window.html#1000758"><code>WinPushDrawState()</code></a> to preserve the current drawing state before you set this function and use <a href="UI_Window.html#1144225"><code>WinPopDrawState()</code></a> to restore it later. </p>
<h4>
  <a name="1459092"> </a>Compatibility 
</h4>

<p><a name="1459093"> </a>Do not use this function with the graphics context. </p>
<h4>
  <a name="1074452"> </a>See Also 
</h4>

<p><a name="1074456"> </a><a href="UI_Window.html#1500947"><code>WinGetPattern()</code></a></p>

<h3 class="hbH3">
  <a name="1003690"> </a>WinSetPatternType Function <a href="#1160850"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="1003693"> </a>Purpose 
</h4>

<p><a name="1074505"> </a>Sets the current pattern type.</p>
<h4>
  <a name="1003698"> </a>Declared In 
</h4>
<code>Window.h<a name="1003701"> </a></code><h4>
  <a name="1003703"> </a>Prototype 
</h4>
<pre class="proto"><a name="1003732"></a>void WinSetPatternType (
   PatternType <code class="par">newPattern</code>
)
</pre>
<h4>
  <a name="1003764"> </a>Parameters 
</h4>

<dl>
<dt><a name="1288766"> </a><code>&rarr;  <i>newPattern</i></code></dt>
<dd><a name="1288767"> </a>The pattern type to set for the draw window (see <a href="UI_Window.html#1098738"><code>PatternType</code></a>).</dd>

</dl>
<h4>
  <a name="1288771"> </a>Returns 
</h4>

<p><a name="1074529"> </a>Nothing.</p>
<h4>
  <a name="1074530"> </a>Comments 
</h4>

<p><a name="1074531"> </a>This function sets the drawing state's pattern <code>newPattern</code> and sets the custom pattern data to <code>NULL</code>. To set a custom pattern use <a href="UI_Window.html#1003650"><code>WinSetPattern()</code></a>.</p>

<p><a name="1074541"> </a>The fill pattern is used by <a href="UI_Window.html#1145105"><code>WinFillLine()</code></a> and <a href="UI_Window.html#1029991"><code>WinFillRectangle()</code></a>.</p>

<p><a name="1074542"> </a>This function changes the current drawing state. If necessary, use <a href="UI_Window.html#1000758"><code>WinPushDrawState()</code></a> to preserve the current drawing state before you set this function and use <a href="UI_Window.html#1144225"><code>WinPopDrawState()</code></a> to restore it later. </p>
<h4>
  <a name="1459120"> </a>Compatibility 
</h4>

<p><a name="1459121"> </a>Do not use this function with the graphics context. </p>
<h4>
  <a name="1003997"> </a>See Also 
</h4>

<p><a name="1004000"> </a><a href="UI_Window.html#1505993"><code>WinGetPatternType()</code></a></p>

<h3 class="hbH3">
  <a name="1704064"> </a>WinSetScalingMode Function <a href="#1160850"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="1704066"> </a>Purpose 
</h4>

<p><a name="1704067"> </a>Controls the scaling of bitmaps and bitmapped fonts and the spacing between text glyphs.</p>
<h4>
  <a name="1704068"> </a>Declared In 
</h4>
<code>Window.h<a name="1704069"> </a></code><h4>
  <a name="1704070"> </a>Prototype 
</h4>
<pre class="proto"><a name="1704071"></a>uint32_t WinSetScalingMode (
   uint32_t <code class="par">mode</code>
)
</pre>
<h4>
  <a name="1704072"> </a>Parameters 
</h4>

<dl>
<dt><a name="1704073"> </a><code>&rarr;  <i><code>mode</code></i></code></dt>
<dd><a name="1704077"> </a>One or more of the <a href="UI_Window.html#1679132">Scaling Mode Constants</a> OR'd together. </dd>

</dl>
<h4>
  <a name="1704078"> </a>Returns 
</h4>

<p><a name="1704079"> </a>The previous scaling mode.</p>
<h4>
  <a name="1704080"> </a>Comments 
</h4>

<p><a name="1704081"> </a>If you need to display a large, low-density bitmap&#8212;for instance, a map or a photograph&#8212;you can use <code>WinSetScalingMode()</code> to draw your bitmap unscaled, allowing the user to see more of the bitmap at one time. If you want to draw more, but smaller, text on a device that has a high-density display, you can use <code>WinSetScalingMode()</code> to draw text unscaled. </p>

<p><a name="1704083"> </a>On a device with a high-density display, if the bitmap being drawn, or the font being used, is part of a family that contains both low- and high-density members, <code>WinSetScalingMode()</code> controls which member is used. If <code>kTextScalingOff</code> is set, for instance, the low-density font is used, unscaled, when drawing subsequent text.</p>

<p><a name="1704089"> </a>When an application calls <a href="UI_Window.html#1002873"><code>WinSetCoordinateSystem()</code></a> to use native coordinates for a high-density window, the operating system turns off text padding. When an application calls <code>WinSetCoordinateSystem()</code> to use standard coordinates, the operating system turns text padding on. To use standard coordinates with text padding turned off, or to use native coordinates with text padding turned on, call <code>WinSetScalingMode()</code> after calling <code>WinSetCoordinateSystem()</code>. Note that using standard coordinates with padding off is not recommended since the Font Manager functions that measures character widths will return inaccurate widths.</p>

<p><a name="1704090"> </a>The scaling mode flags are part of the window's draw state. In order to ensure that the draw state is properly restored, save that state using <a href="UI_Window.html#1000758"><code>WinPushDrawState()</code></a> before calling functions that alter the draw state&#8212;such as <code>WinSetScalingMode()</code> or <code>WinSetCoordinateSystem()</code>. After drawing is completed, restore the draw state with <a href="UI_Window.html#1144225"><code>WinPopDrawState()</code></a>.</p>

<p><a name="1704099"> </a>When an application quits, the draw state is restored to the default settings.</p>
<h4>
  <a name="1704100"> </a>See Also 
</h4>

<p><a name="1704104"> </a><a href="UI_Window.html#1699863"><code>WinGetScalingMode()</code></a></p>

<h3 class="hbH3">
  <a name="1004002"> </a>WinSetTextColor Function <a href="#1160850"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="1004005"> </a>Purpose 
</h4>

<p><a name="1074696"> </a>Sets the color to use for drawing characters in subsequent draw operations.</p>
<h4>
  <a name="1004010"> </a>Declared In 
</h4>
<code>Window.h<a name="1004013"> </a></code><h4>
  <a name="1004015"> </a>Prototype 
</h4>
<pre class="proto"><a name="1004018"></a>IndexedColorType WinSetTextColor (
   IndexedColorType <code class="par">textColor</code>
)
</pre>
<h4>
  <a name="1004020"> </a>Parameters 
</h4>

<dl>
<dt><a name="1074744"> </a><code>&rarr;  <i>textColor</i></code></dt>
<dd><a name="1074748"> </a>The color to set; specify a value of type <a href="UI_Window.html#1407675"><code>IndexedColorType</code></a>.</dd>

</dl>
<h4>
  <a name="1074749"> </a>Returns 
</h4>

<p><a name="1074750"> </a>The previous text color index.</p>
<h4>
  <a name="1074751"> </a>Comments 
</h4>

<p><a name="1074752"> </a>This function changes the current drawing state. If necessary, use <a href="UI_Window.html#1000758"><code>WinPushDrawState()</code></a> to preserve the current drawing state before you set this function and use <a href="UI_Window.html#1144225"><code>WinPopDrawState()</code></a> to restore it later. </p>

<p><a name="1074759"> </a>To set the foreground color to a predefined UI color default, use <a href="UI_Color.html#993462"><code>UIColorGetTableEntryIndex()</code></a> as an input to this function. For example: </p>

<div class="CodeRule"><hr></div><pre class="CodeBlock">
curColor = WinSetTextColor<a name="1074763"> </a>
  (UIColorGetTableEntryIndex(UIFieldText));<a name="1074764"> </a>
</pre><div class="CodeRule"><hr></div>


<p><a name="1395784"> </a>Using <a href="UI_Window.html#1004042"><code>WinSetTextColorRGB()</code></a> is preferred over this function. It is faster. </p>
<h4>
  <a name="1459141"> </a>Compatibility 
</h4>

<p><a name="1459142"> </a>Do not use this function with the graphics context. Use <a href="UI_GraphicContext.html#1124873"><code>GcSetColor()</code></a> instead. </p>
<h4>
  <a name="1004037"> </a>See Also 
</h4>

<p><a name="1004040"> </a><a href="UI_Window.html#1002597"><code>WinSetBackColor()</code></a>, <a href="UI_Window.html#1003040"><code>WinSetForeColor()</code></a></p>

<h3 class="hbH3">
  <a name="1004042"> </a>WinSetTextColorRGB Function <a href="#1160850"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="1004045"> </a>Purpose 
</h4>

<p><a name="1074790"> </a>Sets the color to use for drawing characters in subsequent draw operations.</p>
<h4>
  <a name="1004050"> </a>Declared In 
</h4>
<code>Window.h<a name="1004053"> </a></code><h4>
  <a name="1004055"> </a>Prototype 
</h4>
<pre class="proto"><a name="1004058"></a>void WinSetTextColorRGB (
   const RGBColorType <code class="par">*newRgbP</code>,
   RGBColorType <code class="par">*prevRgbP</code>
)
</pre>
<h4>
  <a name="1004060"> </a>Parameters 
</h4>

<dl>
<dt><a name="1074794"> </a><code>&rarr;  <i>newRgbP</i></code></dt>
<dd><a name="1074798"> </a>The color to set; specify a value of type <a href="UI_Bitmap.html#1004052"><code>RGBColorType</code></a>.</dd>

<dt><a name="1074799"> </a><code>&larr;  <i>prevRgbP</i></code></dt>
<dd><a name="1074803"> </a>The previous color; specify a value of type <a href="UI_Bitmap.html#1004052"><code>RGBColorType</code></a>.</dd>

</dl>
<h4>
  <a name="1074804"> </a>Returns 
</h4>

<p><a name="1074805"> </a>Nothing.</p>
<h4>
  <a name="1074806"> </a>Comments 
</h4>

<p><a name="1074810"> </a>This function takes new and previous <a href="UI_Bitmap.html#1004052"><code>RGBColorType</code></a> arguments. It is acceptable to set <code class="par">newRgbP</code> or <code class="par">prevRgbP</code> to <code>NULL</code>. If an application only wants to get the current color, the <code class="par">newRgbP</code> argument is set to <code>NULL</code>. If the application does not care about the previous color, <code class="par">prevRgbP</code> can be set to <code>NULL</code>.</p>

<p><a name="1074814"> </a>This function sets the <code>textColorRGB</code> field to the value specified by <code class="par">newRgbP</code>. It then sets the index field of <code>textColorRGB</code> to the 8 bit system palette entry that most closely matches the RGB components. Finally, it sets the <code>textColor</code> index field to this index value.</p>

<p><a name="1074818"> </a>This function changes the current drawing state. If necessary, use <a href="UI_Window.html#1000758"><code>WinPushDrawState()</code></a> to preserve the current drawing state before you set this function and use <a href="UI_Window.html#1144225"><code>WinPopDrawState()</code></a> to restore it later. </p>
<h4>
  <a name="1459159"> </a>Compatibility 
</h4>

<p><a name="1459160"> </a>Do not use this function with the graphics context. Use <a href="UI_GraphicContext.html#1124873"><code>GcSetColor()</code></a> instead. </p>
<h4>
  <a name="1004165"> </a>See Also 
</h4>

<p><a name="1004168"> </a><a href="UI_Window.html#1002637"><code>WinSetBackColorRGB()</code></a>, <a href="UI_Window.html#1003354"><code>WinSetForeColorRGB()</code></a></p>

<h3 class="hbH3">
  <a name="1004170"> </a>WinSetUnderlineMode Function <a href="#1160850"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="1004173"> </a>Purpose 
</h4>

<p><a name="1074893"> </a>Sets the graphic state to enable or disable the underlining of characters.</p>
<h4>
  <a name="1004178"> </a>Declared In 
</h4>
<code>Window.h<a name="1004181"> </a></code><h4>
  <a name="1004183"> </a>Prototype 
</h4>
<pre class="proto"><a name="1004186"></a>UnderlineModeType WinSetUnderlineMode (
   UnderlineModeType <code class="par">mode</code>
)
</pre>
<h4>
  <a name="1004188"> </a>Parameters 
</h4>

<dl>
<dt><a name="1074907"> </a><code>&harr;  <i>mode</i></code></dt>
<dd><a name="1074911"> </a>The new underline mode type; see <a href="UI_Window.html#1428400"><code>UnderlineModeType</code></a>.</dd>

</dl>
<h4>
  <a name="1074912"> </a>Returns 
</h4>

<p><a name="1074913"> </a>The previous underline mode type.</p>
<h4>
  <a name="1074914"> </a>Comments 
</h4>

<p><a name="1074915"> </a>This function changes the current drawing state. If necessary, use <a href="UI_Window.html#1000758"><code>WinPushDrawState()</code></a> to preserve the current drawing state before you set this function and use <a href="UI_Window.html#1144225"><code>WinPopDrawState()</code></a> to restore it later. </p>
<h4>
  <a name="1592232"> </a>Compatibility 
</h4>

<p><a name="1592233"> </a>Do not use this function with the graphics context. </p>
<h4>
  <a name="1592234"> </a>See Also 
</h4>

<p><a name="1074926"> </a><a href="UI_Window.html#1027460"><code>WinDrawChars()</code></a></p>

<h2 class="haH2">
  <a name="1004771"> </a>Application-Defined Functions <a href="#1160850"><span class="nav">^TOP^</span></a>
</h2>


<h3 class="hbH3">
  <a name="1004784"> </a>winInvalidateFunc Function <a href="#1160850"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="1004817"> </a>Purpose 
</h4>

<p><a name="1004836"> </a>Redraws the specified portion of a window. </p>
<h4>
  <a name="1004854"> </a>Declared In 
</h4>
<code>Window.h<a name="1004873"> </a></code><h4>
  <a name="1004891"> </a>Prototype 
</h4>
<pre class="proto"><a name="1004910"></a>Boolean (
   *winInvalidateFunc
) (
   int32_t <code class="par">cmd</code>,
   WinHandle <code class="par">window</code>,
   const RectangleType <code class="par">*dirtyRect</code>,
   void <code class="par">*state</code>
)
</pre>
<h4>
  <a name="1004936"> </a>Parameters 
</h4>

<dl>
<dt><a name="1004955"> </a><code>&rarr;  <i>cmd</i></code></dt>
<dd><a name="1004973"> </a>One of the following: </dd>

<dl>
<dt><a name="1352008"> </a><code>winInvalidateExecute</code></dt>
<dd><a name="1352013"> </a>Redraw the region <code class="par">dirtyRect</code> in the <code class="par">window</code>. </dd>

<dt><a name="1352014"> </a><code>winInvalidateDestroy</code></dt>
<dd><a name="1352015"> </a>Free the <code class="par">state</code> if necessary. </dd>

</dl>
<dt><a name="1004991"> </a><code>&rarr;  <i>window</i></code></dt>
<dd><a name="1005009"> </a>The window into which to draw. </dd>

<dt><a name="1005011"> </a><code>&rarr;  <i>dirtyRect</i></code></dt>
<dd><a name="1005013"> </a>The region of the window that needs to be redrawn (see <a href="UI_Rectangle.html#994219"><code>RectangleType</code></a>). </dd>

<dt><a name="1005015"> </a><code>&rarr;  <i>state</i></code></dt>
<dd><a name="1005017"> </a>Application-specific data necessary for the redraw. </dd>

</dl>
<h4>
  <a name="1005019"> </a>Returns 
</h4>

<p><a name="1005022"> </a><code>true</code> if the function handled the cmd, or <code>false</code> if an error occurred. </p>
<h4>
  <a name="1005024"> </a>Comments 
</h4>

<p><a name="1005027"> </a>This function is used as a drawing optimization. You specify this function in a call to <a href="UI_Window.html#1522368"><code>WinInvalidateRectFunc()</code></a>. If certain conditions are met, the Window Manager calls this function instead of enqueueing a <a href="UI_Window.html#1357696"><code>winUpdateEvent</code></a>. </p>

<p><a name="1607634"> </a>Even if this function is not used to redraw the specified area, it is always called with the <code>winInvalidateDestroy</code> parameter to free the state. </p>

<p><a name="1610299"> </a>After you receive the call with <code>winInvalidateDestroy</code>, the association between the rectangle and this function is destroyed. If you want to keep using your callback function for this region, you should use <a href="UI_Window.html#1522368"><code>WinInvalidateRectFunc()</code></a> each time you need to invalidate it. </p>
&nbsp;<br>
</div>
<!--END CONTENT-->

</td>
<td width="5">&nbsp;&nbsp;</td>
</tr>

</table>

<!-- BEGIN FOOTER -->
<table width="100%" border="0" cellspacing="0" cellpadding="0">
<tr>
<td width="7" rowspan="2"><img name="index_x" src="images/shim.gif" width="7" height="33" border="0" alt=""></td>
<td align="left"><img name="dashes" src="images/dashes.gif" width="744" height="3" border="0" alt=""></td>
<td width="10" rowspan="2"><img name="index_x" src="images/shim.gif" width="10" height="33" border="0" alt=""></td>
</tr>
<tr>
<td align="center">
<p class="footer">
Copyright © 2003&#8211;2004, PalmSource, Inc. and its affiliates. All rights reserved.<br>
<a href="http://www.palmsource.com/contact/">Write Us</a> | <a href="http://www.palmos.com/dev/training/">Training</a> | <a href="http://www.palmos.com/dev/support/kb/">Knowledge Base</a> | <a href="UI_Front.html" target="_blank">Legal</a></p>
<br>
<!--BEGIN BOOK NAVIGATION-->
<p class="nav">
<A href="http://www.palmos.com/dev/support/docs/">Documentation</a>&nbsp;&nbsp;|&nbsp;&nbsp;
<a href="UI_TOC.html">Table of Contents</a>&nbsp;&nbsp;
             |&nbsp;&nbsp;<a href="UI_Color.html">&lt;&nbsp;Previous</a>&nbsp;&nbsp;
             |&nbsp;&nbsp;<a href="UI_IX.html">Next&nbsp;&gt;</a>&nbsp;&nbsp;
             |&nbsp;&nbsp;<a href="UI_IX.html">Index</a>
</p>
</td>
</tr>
</table>
<!-- END FOOTER -->

</body>
</html>