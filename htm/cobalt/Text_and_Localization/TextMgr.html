<html>
<head>
<title>(Protein) Text Manager | Text and Localization </title> 
<link href="psi_devpubs.css" rel="stylesheet" type="text/css">

<!-- BEGIN META DATA -->
<meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
<META NAME="PSITEMPLATE" CONTENT="1006-007 PalmSource_HTML_2003 20041101">
<META NAME="GENERATOR" CONTENT="Quadralay WebWorks AutoMap 2003 for FrameMaker 8.0.6.2138">
<META NAME="LASTUPDATED" CONTENT="11/22/04 11:30:44">
<!-- END META DATA -->
</head>

<body bgcolor="#ffffff" text="#000000" leftmargin="0" topmargin="0" marginwidth="0" marginheight="0">
<a name="1044699"></a>

<!-- BEGIN TOPNAV -->
<table width="100%" border="0" cellspacing="0" cellpadding="0">
<tr>
<td><img src="images/shim.gif" width="7" height="75" border="0" alt=""></td>
<td align="left"><table border="0" cellpadding="0" cellspacing="0" width="744">
<tr>
<td><img name="index_r2_c1" src="images/shim.gif" width="25" height="75" border="0" alt=""></td>
<td valign="top"><table border="0" cellpadding="0" cellspacing="0" width="96">
<tr>
<td><img name="index_r2_c4" src="images/shim.gif" width="96" height="15" border="0" alt=""></td>
</tr>
<tr>
<td><a href="http://www.palmsource.com/"><img name="ps_logo" src="images/ps_logo.gif" width="96" height="54" border="0" alt=""></a></td>
</tr>

</table>
</td>

<td><table border="0" cellpadding="0" cellspacing="0" width="30">
<td><img name="index_x" src="images/shim.gif" width="30" height="75" border="0" alt=""></td>
</table></td>

<!--BEGIN MASTHEAD-->
<td><table border="0" cellpadding="0" cellspacing="0" width="96">
<tr>
<td><img name="index_x" src="images/shim.gif" width="615" height="5" border="0" alt=""></td>
</tr>
<tr>
<td>
<!--BEGIN BOOK NAVIGATION-->
<span class="nav">
<A href="http://www.palmos.com/dev/support/docs/">Documentation</a>&nbsp;&nbsp;|&nbsp;&nbsp;
<a href="TextLocTOC.html">Table of Contents</a>&nbsp;&nbsp;
             |&nbsp;&nbsp;<a href="StringMgr.html">&lt;&nbsp;Previous</a>&nbsp;&nbsp;
             |&nbsp;&nbsp;<a href="TextLoc_PartApx.html">Next&nbsp;&gt;</a>&nbsp;&nbsp;
             |&nbsp;&nbsp;<a href="TextLocIX.html">Index</a>
</span>
<!--END BOOK NAVIGATION-->
</tr>
<tr>
<td>
<!--BEGIN PAGE TITLE-->
<h2 class="PageTitle">8 &nbsp;&nbsp;
Text Manager</h2></td>
<!--END PAGE TITLE-->
</tr>
<tr>
<td>
<!--BEGIN BOOK TITLE-->
<p class="BookTitle">Text and Localization </p>
<p class="SubTitle">Exploring Palm OS&#174; </p>
<!--END BOOK TITLE-->
</td>
</tr>
<tr>
<td><img name="index_x" src="images/shim.gif" width="615" height="5" border="0" alt=""></td>
</tr>
</table>
</td>
<!--END MASTHEAD-->
</tr>
</table>
<img name="dashes" src="images/dashes.gif" width="744" height="3" border="0" alt=""></td>
</tr>
</table>
<!-- END TOPNAV -->

<table width="100%" border="0" cellspacing="0" cellpadding="0">
<tr>
<td valign="top" width="5"><img name="index_x" src="images/shim.gif" width="5" height="33" border="0" alt=""></td>

<!--BEGIN SIDETOC-->
<td valign="top" width="175">
<div id="sidetoc" valign="bottom">
<h1 class="SideTOC1-PartTab"><a href="TextLoc_PartRef.html">Part II: Reference</a> </h1>
<h1 class="SideTOC1"><a href="TextMgr.html">8  Text Manager</a></h1>

   <h2 class="SideTOC2"><a href="#995827">
   Text Manager Structures and Types</a></h2>

      <h3 class="SideTOC3"><a href="#995858">
      CharEncodingType</a></h3>

      <h3 class="SideTOC3"><a href="#1092092">
      TxtConvertStateType</a></h3>

   <h2 class="SideTOC2"><a href="#997863">
   Text Manager Constants</a></h2>

      <h3 class="SideTOC3"><a href="#1068590">
      Byte Attribute Flags</a></h3>

      <h3 class="SideTOC3"><a href="#1073649">
      Character Attributes</a></h3>

      <h3 class="SideTOC3"><a href="#1104428">
      Character Encoding Attributes </a></h3>

      <h3 class="SideTOC3"><a href="#1048967">
      Encoding Conversion Constant Modifiers</a></h3>

      <h3 class="SideTOC3"><a href="#1111542">
      Encoding Conversion Substitution Constants</a></h3>

      <h3 class="SideTOC3"><a href="#1063377">
      Size Constants</a></h3>

      <h3 class="SideTOC3"><a href="#1107595">
      Text Manager Error Constants</a></h3>

      <h3 class="SideTOC3"><a href="#1063543">
      Text Manager Feature Settings</a></h3>

      <h3 class="SideTOC3"><a href="#1095301">
      TranslitOpType</a></h3>

   <h2 class="SideTOC2"><a href="#1004479">
   Text Manager Functions and Macros</a></h2>

      <h3 class="SideTOC3"><a href="#1004514">
      CHAR_ENCODING_VALUE</a></h3>

      <h3 class="SideTOC3"><a href="#1006332">
      sizeOf7BitChar</a></h3>

      <h3 class="SideTOC3"><a href="#1006895">
      TxtByteAttr</a></h3>

      <h3 class="SideTOC3"><a href="#1008102">
      TxtCaselessCompare</a></h3>

      <h3 class="SideTOC3"><a href="#1008908">
      TxtCharAttr</a></h3>

      <h3 class="SideTOC3"><a href="#1010728">
      TxtCharBounds</a></h3>

      <h3 class="SideTOC3"><a href="#1011389">
      TxtCharEncoding</a></h3>

      <h3 class="SideTOC3"><a href="#1013248">
      TxtCharIsAlNum</a></h3>

      <h3 class="SideTOC3"><a href="#1013327">
      TxtCharIsAlpha</a></h3>

      <h3 class="SideTOC3"><a href="#1076978">
      TxtCharIsCntrl</a></h3>

      <h3 class="SideTOC3"><a href="#1015436">
      TxtCharIsDelim</a></h3>

      <h3 class="SideTOC3"><a href="#1015619">
      TxtCharIsDigit</a></h3>

      <h3 class="SideTOC3"><a href="#1016826">
      TxtCharIsGraph</a></h3>

      <h3 class="SideTOC3"><a href="#1017728">
      TxtCharIsHardKey</a></h3>

      <h3 class="SideTOC3"><a href="#1017967">
      TxtCharIsHex</a></h3>

      <h3 class="SideTOC3"><a href="#1018752">
      TxtCharIsLower</a></h3>

      <h3 class="SideTOC3"><a href="#1019502">
      TxtCharIsPrint</a></h3>

      <h3 class="SideTOC3"><a href="#1019629">
      TxtCharIsPunct</a></h3>

      <h3 class="SideTOC3"><a href="#1021409">
      TxtCharIsSpace</a></h3>

      <h3 class="SideTOC3"><a href="#1021984">
      TxtCharIsUpper</a></h3>

      <h3 class="SideTOC3"><a href="#1023191">
      TxtCharIsValid</a></h3>

      <h3 class="SideTOC3"><a href="#1024093">
      TxtCharIsVirtual</a></h3>

      <h3 class="SideTOC3"><a href="#1024332">
      TxtCharSize</a></h3>

      <h3 class="SideTOC3"><a href="#1025117">
      TxtCharXAttr</a></h3>

      <h3 class="SideTOC3"><a href="#1025867">
      TxtCompare</a></h3>

      <h3 class="SideTOC3"><a href="#1026712">
      TxtConvertEncoding</a></h3>

      <h3 class="SideTOC3"><a href="#1131659">
      TxtEncodingName</a></h3>

      <h3 class="SideTOC3"><a href="#1027900">
      TxtFindString</a></h3>

      <h3 class="SideTOC3"><a href="#1028845">
      TxtGetChar</a></h3>

      <h3 class="SideTOC3"><a href="#1029614">
      TxtGetEncodingFlags</a></h3>

      <h3 class="SideTOC3"><a href="#1030398">
      TxtGetNextChar</a></h3>

      <h3 class="SideTOC3"><a href="#1031665">
      TxtGetPreviousChar</a></h3>

      <h3 class="SideTOC3"><a href="#1081784">
      TxtGetTruncationOffset</a></h3>

      <h3 class="SideTOC3"><a href="#1033687">
      TxtGetWordWrapOffset</a></h3>

      <h3 class="SideTOC3"><a href="#1034527">
      TxtMaxEncoding</a></h3>

      <h3 class="SideTOC3"><a href="#1034702">
      TxtNameToEncoding</a></h3>

      <h3 class="SideTOC3"><a href="#1035928">
      TxtNextCharSize</a></h3>

      <h3 class="SideTOC3"><a href="#1036088">
      TxtParamString</a></h3>

      <h3 class="SideTOC3"><a href="#1036841">
      TxtPrepFindString</a></h3>

      <h3 class="SideTOC3"><a href="#1037714">
      TxtPreviousCharSize</a></h3>

      <h3 class="SideTOC3"><a href="#1038314">
      TxtReplaceStr</a></h3>

      <h3 class="SideTOC3"><a href="#1039340">
      TxtSetNextChar</a></h3>

      <h3 class="SideTOC3"><a href="#1039568">
      TxtStrEncoding</a></h3>

      <h3 class="SideTOC3"><a href="#1041408">
      TxtTransliterate</a></h3>

      <h3 class="SideTOC3"><a href="#1043012">
      TxtTruncateString</a></h3>

      <h3 class="SideTOC3"><a href="#1043661">
      TxtWordBounds</a></h3>

</div>
</td>

<td width="5">&nbsp;&nbsp;</td>
<td width="2" background="images/index_r8_c10.gif"><img src="images/shim.gif" width="2" height="75" border="0" alt=""></td>
<td width="5">&nbsp;&nbsp;</td>

<!--END SIDETOC-->

<td valign="top">

<!--BEGIN CONTENT-->
<div id="content" valign="bottom">
<p><a name="1044700"> </a>This chapter provides information about the Text Manager API declared in <code>TextMgr.h</code> by discussing these topics: </p>
   <blockquote class = "bq"><a name="1044701"> </a><a href="TextMgr.html#995827">Text Manager Structures and Types</a></blockquote>
   <blockquote class = "bq"><a name="1044702"> </a><a href="TextMgr.html#997863">Text Manager Constants</a></blockquote>
   <blockquote class = "bq"><a name="1004508"> </a><a href="TextMgr.html#1004479">Text Manager Functions and Macros</a></blockquote>

<p><a name="1044724"> </a>For more information on the Text Manager, see the chapter <a href="Text.html#1036996">"Text"</a>. </p>

<h2 class="haH2">
  <a name="995827"> </a>Text Manager Structures and Types <a href="#1044699"><span class="nav">^TOP^</span></a>
</h2>


<h3 class="hbH3">
  <a name="995858"> </a>CharEncodingType Typedef <a href="#1044699"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="995877"> </a>Purpose 
</h4>

<p><a name="995879"> </a>Specifies possible character encodings. </p>
<h4>
  <a name="995882"> </a>Declared In 
</h4>
<code>TextMgr.h<a name="995884"> </a></code><h4>
  <a name="995935"> </a>Prototype 
</h4>
<pre class="proto"><a name="995960"></a>typedef uint16_t CharEncodingType
</pre>
<h4>
  <a name="1126676"> </a>Comments 
</h4>

<p><a name="1126677"> </a>A given device supports a single character encoding. Palm OS<sup>&#174;</sup> Cobalt devices support either the Palm OS version of Windows code page 1252<a href="#1126680"><sup>1</sup></a> (an extension of ISO Latin 1) or the Palm OS version of Windows code page 932<sup>1</sup> (an extension of Shift JIS). In addition, Palm OS licensees and some third-party developers provide support for additional character encodings including Big-5, Hebrew, Arabic, Thai, Korean, and Cyrillic. </p>

<p><a name="1091259"> </a>The character encoding constants generally follow the format: </p>
<pre class="sl">charEncoding<i>Name</i></pre>

<p><a name="1091261"> </a>where <i>Name</i> is the name of the character encoding. </p>

<p><a name="1091262"> </a>The following table shows examples of the character encoding constants. For a complete list, see the <code>TextMgr.h</code> file. </p>


<div class="tablediv"><table cellspacing="0" class="tTable">

  <tr valign="top">
    <th><p class="tt"><a name="1092035"> </a><b>Constant</b></p>
    </th>
    <th><p class="tt"><a name="1092037"> </a><b>Description</b></p>
    </th>
  </tr>
  <tr valign="top">
    <td><p class="tt"><a name="1092040"> </a><code>charEncodingUnknown</code> </p>
    </td>
    <td><p class="tt"><a name="1092042"> </a>Unknown to this version of Palm OS </p>
    </td>
  </tr>
  <tr valign="top">
    <td><p class="tt"><a name="1092044"> </a><code>charEncodingAscii</code> </p>
    </td>
    <td><p class="tt"><a name="1092046"> </a>ISO 646-1991 </p>
    </td>
  </tr>
  <tr valign="top">
    <td><p class="tt"><a name="1092048"> </a><code>charEncodingISO8859_1</code> </p>
    </td>
    <td><p class="tt"><a name="1092050"> </a>ISO 8859 Part 1 (also known as ISO Latin 1). This encoding is commonly used for the Roman alphabet </p>
    </td>
  </tr>
  <tr valign="top">
    <td><p class="tt"><a name="1092052"> </a><code>charEncodingPalmLatin</code> </p>
    </td>
    <td><p class="tt"><a name="1092054"> </a>Palm OS version of Microsoft Windows code page 1252. This encoding is identical to code page 1252 with Palm-specific characters added in the control range. </p>
    </td>
  </tr>
  <tr valign="top">
    <td><p class="tt"><a name="1092056"> </a><code>charEncodingShiftJIS</code> </p>
    </td>
    <td><p class="tt"><a name="1092058"> </a>Encoding for 0208-1990 with single-byte Japanese Katakana. This encoding is commonly used for Japanese alphabets. </p>
    </td>
  </tr>
  <tr valign="top">
    <td><p class="tt"><a name="1092060"> </a><code>charEncodingPalmSJIS </code></p>
    </td>
    <td><p class="tt"><a name="1092062"> </a>Palm OS version of Microsoft Windows code page 932. This encoding is identical to code page 932, with Palm-specific characters added in the control range and with a Yen symbol instead of the Reverse Solidus at location 0x5c.</p>
    </td>
  </tr>
  <tr valign="top">
    <td><p class="tt"><a name="1092065"> </a><code>charEncodingCP1252</code> </p>
    </td>
    <td><p class="tt"><a name="1092067"> </a>Microsoft Windows extensions to ISO 8859 Part 1 </p>
    </td>
  </tr>
  <tr valign="top">
    <td><p class="tt"><a name="1092069"> </a><code>charEncodingCP932</code> </p>
    </td>
    <td><p class="tt"><a name="1092071"> </a>Microsoft Windows extensions to Shift JIS </p>
    </td>
  </tr>
  <tr valign="top">
    <td><p class="tt"><a name="1092073"> </a><code>charEncodingUTF8</code> </p>
    </td>
    <td><p class="tt"><a name="1092075"> </a>Eight-bit safe encoding for Unicode </p>
    </td>
  </tr>
</table>

</div>


<h3 class="hbH3">
  <a name="1092092"> </a>TxtConvertStateType Struct <a href="#1044699"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="1046292"> </a>Purpose 
</h4>

<p><a name="1046293"> </a>Maintains state across calls to <a href="TextMgr.html#1026712"><code>TxtConvertEncoding()</code></a>. It is essentially opaque; simply declare a structure of this type and pass a pointer to your structure when making multiple calls to <code>TxtConvertEncoding()</code> for a single source text buffer.</p>
<h4>
  <a name="1046294"> </a>Declared In 
</h4>
<code>TextMgr.h<a name="1046295"> </a></code><h4>
  <a name="997610"> </a>Prototype 
</h4>
<pre class="proto"><a name="997642"></a>typedef struct {
   uint8_t ioSrcState[kTxtConvertStateSize];
   uint8_t ioDstState[kTxtConvertStateSize];
} TxtConvertStateType
</pre>
<h4>
  <a name="997754"> </a>Comments 
</h4>

<p><a name="1047668"> </a><code>kTxtConvertStateSize</code> is simply a constant that determines the size of the source and destination state buffers.</p>

<h2 class="haH2">
  <a name="997863"> </a>Text Manager Constants <a href="#1044699"><span class="nav">^TOP^</span></a>
</h2>


<h3 class="hbH3">
  <a name="1068590"> </a>Byte Attribute Flags <a href="#1044699"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="1068591"> </a>Purpose 
</h4>

<p><a name="1068592"> </a>Flags that identify the possible locations of a given byte within a multi-byte character. </p>
<h4>
  <a name="1068593"> </a>Declared In 
</h4>
<code>TextMgr.h<a name="1068594"> </a></code><h4>
  <a name="1068595"> </a>Constants 
</h4>

<dl>
<dt><a name="1068596"> </a><code>#define byteAttrFirst 0x80</code></dt>
<dd><a name="1068597"> </a>First byte of multi-byte character.</dd>

<dt><a name="1068598"> </a><code>#define byteAttrHighLow (byteAttrFirst | byteAttrLast)</code></dt>
<dd><a name="1068599"> </a>Either the first byte of a multi-byte character or the last byte of a multi-byte character.</dd>

<dt><a name="1068600"> </a><code>#define byteAttrLast 0x40</code></dt>
<dd><a name="1068601"> </a>Last byte of multi-byte character.</dd>

<dt><a name="1068602"> </a><code>#define byteAttrMiddle 0x20</code></dt>
<dd><a name="1068873"> </a>Middle byte of multi-byte character.</dd>

<dt><a name="1068604"> </a><code>#define byteAttrSingle 0x01</code></dt>
<dd><a name="1068605"> </a>Single-byte character.</dd>

<dt><a name="1068606"> </a><code>#define byteAttrSingleLow (byteAttrSingle | byteAttrLast)</code></dt>
<dd><a name="1068607"> </a>Either a single-byte character or the low-order byte of a multi-byte character.</dd>

</dl>
<h4>
  <a name="1068882"> </a>Comments 
</h4>

<p><a name="1095351"> </a>If a byte is valid in more than one location of a character, multiple return bits are set. For example, 0x40 in the Shift JIS character encoding is valid as a single-byte character and as the low-order byte of a double-byte character. Thus, the return value for <code>TxtByteAttr(0x40)</code> on a Shift JIS system has both the <code>byteAttrSingle</code> and <code>byteAttrLast</code> bits set.</p>

<p><a name="1095354"> </a>Every byte in a stream of double-byte data must be either a single byte, a high byte, a single/low byte (<code>byteAttrSingleLow</code>), or a high/low byte (<code>byteAttrHighLow</code>).</p>
<h4>
  <a name="1125027"> </a>See Also 
</h4>

<p><a name="1125042"> </a><a href="TextMgr.html#1006895"><code>TxtByteAttr()</code></a></p>

<h3 class="hbH3">
  <a name="1073649"> </a>Character Attributes <a href="#1044699"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="1073650"> </a>Purpose 
</h4>

<p><a name="1073651"> </a>Flags that identify various character attributes. </p>
<h4>
  <a name="1073652"> </a>Declared In 
</h4>
<code>TextMgr.h<a name="1073653"> </a></code><h4>
  <a name="1073654"> </a>Constants 
</h4>

<dl>
<dt><a name="1073655"> </a><code>#define charAttrAlNum (charAttr_DI | charAttr_LO | charAttr_UP | charAttr_XA)</code></dt>
<dd><a name="1073656"> </a>Alphanumeric characters</dd>

<dt><a name="1073657"> </a><code>#define charAttrAlpha (charAttr_LO | charAttr_UP | charAttr_XA)</code></dt>
<dd><a name="1073658"> </a>Alphabetic characters</dd>

<dt><a name="1073659"> </a><code>#define charAttrCntrl (charAttr_BB | charAttr_CN)</code></dt>
<dd><a name="1073660"> </a>Control characters</dd>

<dt><a name="1073661"> </a><code>#define charAttrDelim (charAttr_SP | charAttr_PU)</code></dt>
<dd><a name="1073662"> </a>Delimiters</dd>

<dt><a name="1073663"> </a><code>#define charAttrGraph (charAttr_DI | charAttr_LO | charAttr_PU | charAttr_UP | charAttr_XA)</code></dt>
<dd><a name="1073664"> </a>Printable, non-space characters</dd>

<dt><a name="1073665"> </a><code>#define charAttrPrint (charAttr_DI | charAttr_LO | charAttr_PU | charAttr_SP | charAttr_UP | charAttr_XA)</code></dt>
<dd><a name="1073666"> </a>Printable characters</dd>

<dt><a name="1073667"> </a><code>#define charAttrSpace (charAttr_CN | charAttr_SP | charAttr_XS)</code></dt>
<dd><a name="1073668"> </a>Whitespace characters</dd>

<dt><a name="1073669"> </a><code>#define charAttr_BB 0x00000080</code></dt>
<dd><a name="1073670"> </a>BEL, BS, etc.</dd>

<dt><a name="1073671"> </a><code>#define charAttr_CN 0x00000040</code></dt>
<dd><a name="1073672"> </a>CR, FF, HT, NL, VT</dd>

<dt><a name="1073673"> </a><code>#define charAttr_DI 0x00000020</code></dt>
<dd><a name="1073674"> </a>'0'-'9'</dd>

<dt><a name="1073675"> </a><code>#define charAttr_DO 0x00000400</code></dt>
<dd><a name="1073676"> </a>Characters that appear on the display but never in user data, such as the ellipsis character </dd>

<dt><a name="1073677"> </a><code>#define charAttr_LO 0x00000010</code></dt>
<dd><a name="1073678"> </a>'a'-'z' and lowercase extended characters</dd>

<dt><a name="1073679"> </a><code>#define charAttr_PU 0x00000008</code></dt>
<dd><a name="1073680"> </a>Punctuation</dd>

<dt><a name="1073681"> </a><code>#define charAttr_SP 0x00000004</code></dt>
<dd><a name="1073682"> </a>Space</dd>

<dt><a name="1073683"> </a><code>#define charAttr_UP 0x00000002</code></dt>
<dd><a name="1073684"> </a>'A'-'Z' and uppercase extended characters</dd>

<dt><a name="1073685"> </a><code>#define charAttr_XA 0x00000200</code></dt>
<dd><a name="1073686"> </a>Extra alphabetic</dd>

<dt><a name="1073687"> </a><code>#define charAttr_XD 0x00000001</code></dt>
<dd><a name="1073688"> </a>'0'-'9', 'A'-'F', 'a'-'f'</dd>

<dt><a name="1073689"> </a><code>#define charAttr_XS 0x00000100</code></dt>
<dd><a name="1073690"> </a>Extra space</dd>

</dl>

<h3 class="hbH3">
  <a name="1104428"> </a>Character Encoding Attributes  <a href="#1044699"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="1104429"> </a>Purpose 
</h4>

<p><a name="1104430"> </a>Constants used to interpret the return value of <a href="TextMgr.html#1029614"><code>TxtGetEncodingFlags()</code></a>. </p>
<h4>
  <a name="1104434"> </a>Declared In 
</h4>
<code>TextMgr.h<a name="1104435"> </a></code><h4>
  <a name="1104436"> </a>Constants 
</h4>

<dl>
<dt><a name="1104437"> </a><code>#define charEncodingOnlySingleByte 0x00000001</code></dt>
<dd><a name="1104438"> </a>The character encoding consists only of single-byte characters.</dd>

<dt><a name="1104439"> </a><code>#define charEncodingHasDoubleByte 0x00000002</code></dt>
<dd><a name="1104440"> </a>The character encoding contains one or more double-byte characters.</dd>

<dt><a name="1104441"> </a><code>#define charEncodingHasLigatures 0x00000004</code></dt>
<dd><a name="1104442"> </a>The character encoding has ligatures.</dd>

<dt><a name="1104443"> </a><code>#define charEncodingRightToLeft 0x00000008</code></dt>
<dd><a name="1104444"> </a>The character encoding supports a writing system that primarily renders text right-to-left.</dd>

</dl>

<h3 class="hbH3">
  <a name="1048967"> </a>Encoding Conversion Constant Modifiers <a href="#1044699"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="1048968"> </a>Purpose 
</h4>

<p><a name="1048969"> </a>Constants to OR with the destination character encoding (<a href="TextMgr.html#995858"><code>CharEncodingType</code></a>) passed to <a href="TextMgr.html#1026712"><code>TxtConvertEncoding()</code></a>. </p>
<h4>
  <a name="1048970"> </a>Declared In 
</h4>
<code>TextMgr.h<a name="1048971"> </a></code><h4>
  <a name="1048972"> </a>Constants 
</h4>

<dl>
<dt><a name="1048962"> </a><code>#define charEncodingDstBestFitFlag 0x8000</code></dt>
<dd><a name="1048963"> </a>Causes <code>TxtConvertEncoding()</code> to make an extra effort to convert characters in the source encoding to similar (if not equal) characters in the destination encoding.</dd>

</dl>
<h4>
  <a name="1049297"> </a>Comments 
</h4>

<p><a name="1050812"> </a>As an example, when converting from <code>charEncodingUCS2</code> to <code>charEncodingPalmSJIS</code>, no mapping exists for <code>U+00A1</code> (INVERTED EXCLAMATION MARK) because this character doesn't exist in <code>charEncodingPalmSJIS</code>. In this case, <code>TxtConvertEncoding()</code> returns <code>txtErrNoCharMapping</code>. If you OR the <code>charEncodingDstBestFitFlag</code> with the destination character encoding, however, <code>TxtConvertEncoding()</code> converts the character to <code>chrExclamationMark</code> (which is close). Generally, the operating system tries to support as many code page 1252 characters as possible in the "best fit" table.</p>

<p><a name="1050813"> </a>If <code>charEncodingDstBestFitFlag</code> is set and either the source or destination encoding is unknown, <code>TxtConvertEncoding()</code> copies anything that is 7-bit ASCII from the source to the destination. It then returns <code>txtErrUnknownEncodingFallbackCopy</code>. The rules for unknown characters apply during this 7-bit copy; if an inconvertible character is encountered, the substitution string (if one has been specified) is used in its place, and <code>txtErrNoCharMapping</code> is returned instead.</p>

<h3 class="hbH3">
  <a name="1111542"> </a>Encoding Conversion Substitution Constants <a href="#1044699"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="1111543"> </a>Purpose 
</h4>

<p><a name="1111547"> </a>Values used to substitute in <a href="TextMgr.html#1026712"><code>TxtConvertEncoding()</code></a>.</p>
<h4>
  <a name="1111548"> </a>Declared In 
</h4>
<code>TextMgr.h<a name="1111549"> </a></code><h4>
  <a name="1111550"> </a>Constants 
</h4>

<dl>
<dt><a name="1111551"> </a><code>#define textSubstitutionDefaultLen 1</code></dt>
<dd><a name="1111552"> </a>The length in bytes of <code>textSubstitutionDefaultStr</code>. </dd>

<dt><a name="1111553"> </a><code>#define textSubstitutionDefaultStr "?"</code></dt>
<dd><a name="1111554"> </a>Can be passed to <code>TxtConvertEncoding()</code> as the substitution string parameter. The substitution string contains a character that is used in the destination string if a character from the source string is not recognized in the destination encoding. </dd>

<dt><a name="1111558"> </a><code>#define textSubstitutionEncoding charEncodingUTF8</code></dt>
<dd><a name="1111559"> </a>The encoding used for the substitution string parameter of <code>TxtConvertEncoding()</code>. The string you pass for the substitution string parameter is always assumed to be in this encoding. </dd>

</dl>

<h3 class="hbH3">
  <a name="1063377"> </a>Size Constants <a href="#1044699"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="1063378"> </a>Purpose 
</h4>

<p><a name="1063379"> </a>Constants that specify sizes of items used in the Text Manager. </p>
<h4>
  <a name="1063380"> </a>Declared In 
</h4>
<code>TextMgr.h<a name="1063381"> </a></code><h4>
  <a name="1095339"> </a>Constants 
</h4>

<dl>
<dt><a name="1003501"> </a><code>#define kTxtConvertStateSize 32</code></dt>
<dd><a name="1003527"> </a>Used in the <a href="TextMgr.html#1092092"><code>TxtConvertStateType</code></a> structure to specify the maximum size of the source and destination encodings. </dd>

<dt><a name="1003553"> </a><code>#define maxCharBytes 4</code></dt>
<dd><a name="1003571"> </a>Maximum size a single <code>wchar32_t</code> character will occupy in a text string.</dd>

<dt><a name="1003589"> </a><code>#define maxEncodingNameLength 40</code></dt>
<dd><a name="1003607"> </a>Maximum length in bytes of any character encoding name. </dd>

</dl>

<h3 class="hbH3">
  <a name="1107595"> </a>Text Manager Error Constants <a href="#1044699"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="1107596"> </a>Purpose 
</h4>

<p><a name="1107597"> </a>Error constants. </p>
<h4>
  <a name="1107598"> </a>Declared In 
</h4>
<code>TextMgr.h<a name="1107599"> </a></code><h4>
  <a name="1107600"> </a>Constants 
</h4>

<dl>
<dt><a name="1107601"> </a><code>#define txtErrConvertOverflow (txtErrorClass | 4)</code></dt>
<dd><a name="1107602"> </a>The destination buffer is not large enough to contain the converted text. </dd>

<dt><a name="1107603"> </a><code>#define txtErrConvertUnderflow (txtErrorClass | 5)</code></dt>
<dd><a name="1107604"> </a>The end of the source buffer contains a partial character. </dd>

<dt><a name="1107605"> </a><code>#define txtErrMalformedText (txtErrorClass | 9)</code></dt>
<dd><a name="1107606"> </a>An error in the source text encoding has been discovered.</dd>

<dt><a name="1107607"> </a><code>#define txtErrNoCharMapping (txtErrorClass | 7)</code></dt>
<dd><a name="1107608"> </a>The device does not contain a mapping between the source and destination encodings for at least one of the characters in the source string.</dd>

<dt><a name="1107609"> </a><code>#define txtErrTranslitOverflow (txtErrorClass | 3)</code></dt>
<dd><a name="1107610"> </a>The destination buffer is not large enough to contain the converted string. </dd>

<dt><a name="1107611"> </a><code>#define txtErrTranslitOverrun (txtErrorClass | 2)</code></dt>
<dd><a name="1107612"> </a>The source and destination buffers point to the same memory location and performing the requested operation would cause the function to overwrite unprocessed data in the input buffer. </dd>

<dt><a name="1107613"> </a><code>#define txtErrTranslitUnderflow (txtErrorClass | 8)</code></dt>
<dd><a name="1107614"> </a>The end of the source buffer contains a partial character. </dd>

<dt><a name="1107615"> </a><code>#define txtErrUknownTranslitOp (txtErrorClass | 1)</code></dt>
<dd><a name="1107616"> </a>The transliteration operation constant value is not recognized</dd>

<dt><a name="1107617"> </a><code>#define txtErrUnknownEncoding (txtErrorClass | 6)</code></dt>
<dd><a name="1107618"> </a>One of the specified encodings is unknown or can't be handled.</dd>

<dt><a name="1107619"> </a><code>#define txtErrUnknownEncodingFallbackCopy (txtErrorClass | 10)</code></dt>
<dd><a name="1107620"> </a>Either the source or destination encoding is unknown, and the best fit flag was set in the destination encoding. </dd>

</dl>

<h3 class="hbH3">
  <a name="1063543"> </a>Text Manager Feature Settings <a href="#1044699"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="1063544"> </a>Purpose 
</h4>

<p><a name="1063545"> </a>Text Manager settings that can be obtained or set in the <code>sysFtrNumTextMgrFlags</code> feature. </p>
<h4>
  <a name="1063546"> </a>Declared In 
</h4>
<code>TextMgr.h<a name="1063547"> </a></code><h4>
  <a name="1095333"> </a>Constants 
</h4>

<dl>
<dt><a name="1003617"> </a><code>#define textMgrBestFitFlag 0x00000004</code></dt>
<dd><a name="1003627"> </a>The <a href="TextMgr.html#1026712"><code>TxtConvertEncoding()</code></a> function can use the <span style="color: #000000;  font-family: Courier; font-style: normal; font-weight: normal; text-decoration: none; text-transform: none; vertical-align: baseline">charEncodingDstBestFitFlag</span>. See <a href="TextMgr.html#1048967">"Encoding Conversion Constant Modifiers"</a> for more information. This flag is always set in Palm OS Cobalt. </dd>

<dt><a name="1003637"> </a><code>#define textMgrExistsFlag 0x00000001</code></dt>
<dd><a name="1003716"> </a>The Text Manager is installed on the device. This flag is always set in Palm OS Cobalt. </dd>

<dt><a name="1003742"> </a><code>#define textMgrStrictFlag 0x00000002</code></dt>
<dd><a name="1003744"> </a>No longer used. </dd>

</dl>

<h3 class="hbH3">
  <a name="1095301"> </a>TranslitOpType Typedef <a href="#1044699"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="1095303"> </a>Purpose 
</h4>

<p><a name="1095304"> </a>Specifies the transliteration operation to be performed by a given call to <a href="TextMgr.html#1041408"><code>TxtTransliterate()</code></a>. Each character encoding contains its own set of special transliteration operations, the values for which begin at <code>translitOpCustomBase</code>.</p>
<h4>
  <a name="1095309"> </a>Declared In 
</h4>
<code>TextMgr.h<a name="1095310"> </a></code><h4>
  <a name="1095311"> </a>Prototype 
</h4>
<pre class="proto"><a name="1095312"></a>typedef uint16_t TranslitOpType
</pre>
<h4>
  <a name="1095317"> </a>Constants 
</h4>

<dl>
<dt><a name="1100674"> </a><code>#define translitOpStandardBase 0</code></dt>
<dd><a name="1100675"> </a>Base value at which character-encoding-independent transliterations are defined. </dd>

<dt><a name="1100676"> </a><code>#define translitOpUpperCase 0</code></dt>
<dd><a name="1100677"> </a>Convert all characters to uppercase. </dd>

<dt><a name="1003762"> </a><code>#define translitOpLowerCase 1</code></dt>
<dd><a name="1003789"> </a>Convert all characters to lowercase. </dd>

<dt><a name="1003799"> </a><code>#define translitOpReserved2 2</code></dt>
<dd><a name="1003801"> </a>Reserved for future use. </dd>

<dt><a name="1003803"> </a><code>#define translitOpReserved3 3</code></dt>
<dd><a name="1101525"> </a>Reserved for future use. </dd>

<dt><a name="1100690"> </a><code>#define translitOpPreprocess 0x8000</code></dt>
<dd><a name="1100691"> </a>OR this value with another transliteration flag to have the <code>TxtTransliterate()</code> function return the space requirements for the result. </dd>

<dt><a name="1100683"> </a><code>#define translitOpCustomBase 1000</code></dt>
<dd><a name="1100684"> </a>Base value at which character-encoding specific transliteration constants begin. </dd>

</dl>

<h2 class="haH2">
  <a name="1004479"> </a>Text Manager Functions and Macros <a href="#1044699"><span class="nav">^TOP^</span></a>
</h2>


<h3 class="hbH3">
  <a name="1004514"> </a>CHAR_ENCODING_VALUE Macro <a href="#1044699"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="1004533"> </a>Purpose 
</h4>

<p><a name="1004535"> </a>Macro used to set the values of the character encoding constants. </p>
<h4>
  <a name="1004586"> </a>Declared In 
</h4>
<code>TextMgr.h<a name="1004611"> </a></code><h4>
  <a name="1004614"> </a>Prototype 
</h4>
<pre class="proto"><a name="1004616"></a>#define CHAR_ENCODING_VALUE (
   <code class="par">value</code>
)
</pre>
<h4>
  <a name="1005421"> </a>Parameters 
</h4>

<dl>
<dt><a name="1005672"> </a><code>&rarr;  <i>value</i></code></dt>
<dd><a name="1005831"> </a>An integer value. </dd>

</dl>
<h4>
  <a name="1005865"> </a>Returns 
</h4>

<p><a name="1005903"> </a>A <a href="TextMgr.html#995858"><code>CharEncodingType</code></a> value. </p>
<h4>
  <a name="1006018"> </a>Comments 
</h4>

<p><a name="1006056"> </a>Applications do not need to use this macro. </p>

<h3 class="hbH3">
  <a name="1006332"> </a>sizeOf7BitChar Macro <a href="#1044699"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="1006382"> </a>Purpose 
</h4>

<p><a name="1006428"> </a>Returns the true size of a low-ASCII character. </p>
<h4>
  <a name="1006451"> </a>Declared In 
</h4>
<code>TextMgr.h<a name="1006475"> </a></code><h4>
  <a name="1006508"> </a>Prototype 
</h4>
<pre class="proto"><a name="1006548"></a>#define sizeOf7BitChar (
   <code class="par">c</code>
)
</pre>
<h4>
  <a name="1006597"> </a>Parameters 
</h4>

<dl>
<dt><a name="1006653"> </a><code>&rarr;  <i>c</i></code></dt>
<dd><a name="1006773"> </a>A character constant. </dd>

</dl>
<h4>
  <a name="1006818"> </a>Returns 
</h4>

<p><a name="1006882"> </a>The value 1. </p>
<h4>
  <a name="1006885"> </a>Comments 
</h4>

<p><a name="1006887"> </a>In C, checking the size of a character constant returns the size of an integer. For example, <code>sizeof('a')</code> returns 2. Because of this, it's safest to use the <code>sizeOf7BitChar()</code> macro to document buffer size and string length calculations. Note that this can only be used with low-ASCII characters, as anything else might be the high byte of a double-byte character.</p>

<h3 class="hbH3">
  <a name="1006895"> </a>TxtByteAttr Function <a href="#1044699"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="1006925"> </a>Purpose 
</h4>

<p><a name="1006927"> </a>Returns the possible locations of a given byte within a multi-byte character. </p>
<h4>
  <a name="1006930"> </a>Declared In 
</h4>
<code>TextMgr.h<a name="1006936"> </a></code><h4>
  <a name="1006939"> </a>Prototype 
</h4>
<pre class="proto"><a name="1006941"></a>uint8_t TxtByteAttr (
   uint8_t <code class="par">iByte</code>
)
</pre>
<h4>
  <a name="1006944"> </a>Parameters 
</h4>

<dl>
<dt><a name="1066851"> </a><code>&rarr;  <i>iByte</i></code></dt>
<dd><a name="1066852"> </a>A byte representing all or part of a valid character.</dd>

</dl>
<h4>
  <a name="1006974"> </a>Returns 
</h4>

<p><a name="1006976"> </a>A byte with one or more of the <a href="TextMgr.html#1068590">Byte Attribute Flags</a> set. </p>
<h4>
  <a name="1006979"> </a>Comments 
</h4>

<p><a name="1070790"> </a>Text Manager functions that need to determine the byte positioning of a character use <code>TxtByteAttr()</code> to do so. You rarely need to use this function yourself. </p>

<h3 class="hbH3">
  <a name="1008102"> </a>TxtCaselessCompare Function <a href="#1044699"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="1008172"> </a>Purpose 
</h4>

<p><a name="1008226"> </a>Performs a case-insensitive comparison of two text buffers. </p>
<h4>
  <a name="1008261"> </a>Declared In 
</h4>
<code>TextMgr.h<a name="1008301"> </a></code><h4>
  <a name="1008346"> </a>Prototype 
</h4>
<pre class="proto"><a name="1008394"></a>int16_t TxtCaselessCompare (
   const char <code class="par">*s1</code>,
   size_t <code class="par">s1Len</code>,
   size_t <code class="par">*s1MatchLen</code>,
   const char <code class="par">*s2</code>,
   size_t <code class="par">s2Len</code>,
   size_t <code class="par">*s2MatchLen</code>
)
</pre>
<h4>
  <a name="1008483"> </a>Parameters 
</h4>

<dl>
<dt><a name="1070816"> </a><code>&rarr;  <i>s1</i></code></dt>
<dd><a name="1070817"> </a>The first text buffer to compare. </dd>

<dt><a name="1070818"> </a><code>&rarr;  <i>s1Len</i></code></dt>
<dd><a name="1070819"> </a>The length in bytes of the text pointed to by <code class="par">s1</code>. </dd>

<dt><a name="1070820"> </a><code>&larr;  <i>s1MatchLen</i></code></dt>
<dd><a name="1070821"> </a>Points to the offset of the first character in <code class="par">s1</code> that determines the sort order. Pass <code>NULL</code> for this parameter if you don't need to know this number. </dd>

<dt><a name="1070822"> </a><code>&rarr;  <i>s2</i></code></dt>
<dd><a name="1070823"> </a>The second text buffer to compare. </dd>

<dt><a name="1070824"> </a><code>&rarr;  <i>s2Len</i></code></dt>
<dd><a name="1070825"> </a>The length in bytes of the text pointed to by <code class="par">s2</code>.</dd>

<dt><a name="1070826"> </a><code>&larr;  <i>s2MatchLen</i></code></dt>
<dd><a name="1070827"> </a>Points to the offset of the first character in <code class="par">s2</code> that determines the sort order. Pass <code>NULL</code> for this parameter if you don't need to know this number. </dd>

</dl>
<h4>
  <a name="1070828"> </a>Returns 
</h4>

<p><a name="1070829"> </a>One of the following values: </p>


<div class="tablediv"><table cellspacing="0" class="tTableNR">

  <tr valign="top">
    <td><p class="tt"><a name="1070832"> </a><span style="color: #000000;  font-style: normal; font-weight: normal; text-decoration: none; text-transform: none; vertical-align: baseline">&lt; 0 </span></p>
    </td>
    <td><p class="tt"><a name="1070834"> </a>If <code class="par">s1</code> occurs before <code class="par">s2</code> in alphabetical order.</p>
    </td>
  </tr>
  <tr valign="top">
    <td><p class="tt"><a name="1070836"> </a>&gt; 0 </p>
    </td>
    <td><p class="tt"><a name="1070838"> </a>If <code class="par">s1</code> occurs after <code class="par">s2</code> in alphabetical order.</p>
    </td>
  </tr>
  <tr valign="top">
    <td><p class="tt"><a name="1070840"> </a>0 </p>
    </td>
    <td><p class="tt"><a name="1070842"> </a>If the two substrings that were compared are equal. </p>
    </td>
  </tr>
</table>

</div>

<h4>
  <a name="1070844"> </a>Comments 
</h4>

<p><a name="1070845"> </a>In certain character encodings (such as Shift JIS), one character may be accurately represented as either a single-byte character or a multi-byte character. <code>TxtCaselessCompare()</code> accurately matches a single-byte character with its multi-byte equivalent. For this reason, the values returned in <code class="par">s1MatchLen</code> and <code class="par">s2MatchLen</code> are not always equal. </p>

<p><a name="1070846"> </a>You must make sure that the parameters <code class="par">s1</code> and <code class="par">s2</code> point to the start of a valid character. That is, they must point to the first byte of a multi-byte character or they must point to a single-byte character; if they don't, results are unpredictable. </p>
<h4>
  <a name="1070931"> </a>See Also 
</h4>

<p><a name="1070941"> </a><a href="StringMgr.html#997023"><code>StrCaselessCompare()</code></a>, <a href="TextMgr.html#1025867"><code>TxtCompare()</code></a>, <a href="StringMgr.html#999999"><code>StrCompare()</code></a> </p>

<h3 class="hbH3">
  <a name="1008908"> </a>TxtCharAttr Function <a href="#1044699"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="1008913"> </a>Purpose 
</h4>

<p><a name="1070950"> </a>Returns a character's attributes. </p>
<h4>
  <a name="1008941"> </a>Declared In 
</h4>
<code>TextMgr.h<a name="1008943"> </a></code><h4>
  <a name="1009724"> </a>Prototype 
</h4>
<pre class="proto"><a name="1009950"></a>uint32_t TxtCharAttr (
   wchar32_t <code class="par">iChar</code>
)
</pre>
<h4>
  <a name="1010023"> </a>Parameters 
</h4>

<dl>
<dt><a name="1010103"> </a><code>&rarr;  <i>iChar</i></code></dt>
<dd><a name="1070958"> </a>Any valid character. </dd>

</dl>
<h4>
  <a name="1010285"> </a>Returns 
</h4>

<p><a name="1070966"> </a>An integer with any of the <a href="TextMgr.html#1073649">Character Attributes</a> bits set.</p>
<h4>
  <a name="1074090"> </a>Comments 
</h4>

<p><a name="1074091"> </a>The character passed to this function must be a valid character given the system encoding. </p>

<p><a name="1074092"> </a>This function is used in the Text Manager's character attribute macros (<a href="TextMgr.html#1013248"><code>TxtCharIsAlNum()</code></a>, <a href="TextMgr.html#1076978"><code>TxtCharIsCntrl()</code></a>, and so on). The macros perform operations analogous to the standard C functions <code>isPunct()</code>, <code>isPrintable()</code>, and so on. Usually, you'd use one of these macros instead of calling <code>TxtCharAttr()</code> directly. </p>

<p><a name="1074099"> </a>To obtain attributes specific to a given character encoding, use <a href="TextMgr.html#1025117"><code>TxtCharXAttr()</code></a>.</p>
<h4>
  <a name="1010567"> </a>See Also 
</h4>

<p><a name="1074243"> </a><a href="TextMgr.html#1023191"><code>TxtCharIsValid()</code></a> </p>

<h3 class="hbH3">
  <a name="1010728"> </a>TxtCharBounds Function <a href="#1044699"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="1010766"> </a>Purpose 
</h4>

<p><a name="1074276"> </a>Returns the boundaries of a character containing the byte at a specified offset in a string. </p>
<h4>
  <a name="1010823"> </a>Declared In 
</h4>
<code>TextMgr.h<a name="1010847"> </a></code><h4>
  <a name="1010880"> </a>Prototype 
</h4>
<pre class="proto"><a name="1010920"></a>wchar32_t TxtCharBounds (
   const char <code class="par">*iTextP</code>,
   size_t <code class="par">iOffset</code>,
   size_t <code class="par">*oCharStart</code>,
   size_t <code class="par">*oCharEnd</code>
)
</pre>
<h4>
  <a name="1010989"> </a>Parameters 
</h4>

<dl>
<dt><a name="1011037"> </a><code>&rarr;  <i>iTextP</i></code></dt>
<dd><a name="1074392"> </a>The text buffer to search. </dd>

<dt><a name="1011162"> </a><code>&rarr;  <i>iOffset</i></code></dt>
<dd><a name="1074424"> </a>A valid offset into the buffer <code class="par">iTextP</code>. This location may contain a byte in any position (start, middle, or end) of a multi-byte character.</dd>

<dt><a name="1011214"> </a><code>&larr;  <i>oCharStart</i></code></dt>
<dd><a name="1074448"> </a>Points to the starting offset of the character containing the byte at <code class="par">iOffset</code>.</dd>

<dt><a name="1011295"> </a><code>&larr;  <i>oCharEnd</i></code></dt>
<dd><a name="1074472"> </a>Points to the ending offset of the character containing the byte at <code class="par">iOffset</code>.</dd>

</dl>
<h4>
  <a name="1011303"> </a>Returns 
</h4>

<p><a name="1074496"> </a>The character located between the offsets <span style="color: #000000;  font-family: Courier; font-style: oblique; font-weight: normal; text-decoration: none; text-transform: none; vertical-align: baseline">oCharStart</span> and <span style="color: #000000;  font-family: Courier; font-style: oblique; font-weight: normal; text-decoration: none; text-transform: none; vertical-align: baseline">oCharEnd</span>. </p>
<h4>
  <a name="1074497"> </a>Comments 
</h4>

<p><a name="1074498"> </a>Use this function to determine the boundaries of a character in a string or text buffer. </p>

<p><a name="1086083"> </a><code>TxtCharBounds()</code> is often slow and should be used only where needed. If the byte at <span style="color: #000000;  font-family: Courier; font-style: oblique; font-weight: normal; text-decoration: none; text-transform: none; vertical-align: baseline">iOffset</span> is valid in more than one location of a character, the function must search back toward the beginning of the text buffer until it finds an unambiguous byte to determine the appropriate boundaries. </p>

<p><a name="1086084"> </a>You must make sure that the parameter <span style="color: #000000;  font-family: Courier; font-style: oblique; font-weight: normal; text-decoration: none; text-transform: none; vertical-align: baseline">iTextP</span> points to the beginning of the string. That is, if the string begins with a multi-byte character, <span style="color: #000000;  font-family: Courier; font-style: oblique; font-weight: normal; text-decoration: none; text-transform: none; vertical-align: baseline">iTextP</span> must point to the first byte of that character; if it doesn't, results are unpredictable. </p>

<h3 class="hbH3">
  <a name="1011389"> </a>TxtCharEncoding Function <a href="#1044699"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="1012324"> </a>Purpose 
</h4>

<p><a name="1074651"> </a>Returns the minimum encoding required to represent a character. </p>
<h4>
  <a name="1012429"> </a>Declared In 
</h4>
<code>TextMgr.h<a name="1012477"> </a></code><h4>
  <a name="1012530"> </a>Prototype 
</h4>
<pre class="proto"><a name="1012586"></a>CharEncodingType TxtCharEncoding (
   wchar32_t <code class="par">iChar</code>
)
</pre>
<h4>
  <a name="1012651"> </a>Parameters 
</h4>

<dl>
<dt><a name="1012723"> </a><code>&rarr;  <i>iChar</i></code></dt>
<dd><a name="1074683"> </a>A valid character. </dd>

</dl>
<h4>
  <a name="1012877"> </a>Returns 
</h4>

<p><a name="1074718"> </a>A <a href="TextMgr.html#995858"><code>CharEncodingType</code></a> value that indicates the minimum encoding required to represent <span style="color: #000000;  font-family: Courier; font-style: oblique; font-weight: normal; text-decoration: none; text-transform: none; vertical-align: baseline">iChar</span>. If the character isn't recognizable, <code>charEncodingUnknown</code> is returned. </p>
<h4>
  <a name="1074719"> </a>Comments 
</h4>

<p><a name="1074720"> </a>The minimum encoding is the encoding that represents the fewest number of characters while still containing the character specified in <span style="color: #000000;  font-family: Courier; font-style: oblique; font-weight: normal; text-decoration: none; text-transform: none; vertical-align: baseline">iChar</span>. For example, if the character is a blank or a tab character, the minimum encoding is <code>charEncodingAscii</code> because these characters can be represented in single-byte ASCII. If the character is a ü, the minimum encoding is <code>charEncodingISO8859_1</code>. </p>

<p><a name="1074724"> </a>This function is used by <a href="TextMgr.html#1039568"><code>TxtStrEncoding()</code></a>, which is the function that most applications should use to determine the character encoding for tagging text (for instance, for email).</p>

<p><a name="1074728"> </a>Use <a href="TextMgr.html#1034527"><code>TxtMaxEncoding()</code></a> to determine the order of encodings. </p>

<p><a name="1074813"> </a>Palm OS only supports a single character encoding at a time. Because of this, the result of <code>TxtCharEncoding()</code> is always logically equal to or less than the encoding used on the current system. That is, you'll only receive a return value of <code>charEncodingISO8859_1</code> if you're running on a US or European system and you pass a non-ASCII character. </p>
<h4>
  <a name="1074836"> </a>See Also 
</h4>

<p><a name="1074843"> </a><a href="TextMgr.html#1039568"><code>TxtStrEncoding()</code></a>, <a href="TextMgr.html#1034527"><code>TxtMaxEncoding()</code></a></p>

<h3 class="hbH3">
  <a name="1013248"> </a>TxtCharIsAlNum Macro <a href="#1044699"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="1013266"> </a>Purpose 
</h4>

<p><a name="1074851"> </a>Indicates if the character is alphanumeric. </p>
<h4>
  <a name="1013295"> </a>Declared In 
</h4>
<code>TextMgr.h<a name="1013297"> </a></code><h4>
  <a name="1013300"> </a>Prototype 
</h4>
<pre class="proto"><a name="1013302"></a>#define TxtCharIsAlNum (
   <code class="par">ch</code>
)
</pre>
<h4>
  <a name="1013305"> </a>Parameters 
</h4>

<dl>
<dt><a name="1074859"> </a><code>&rarr;  <i>ch</i></code></dt>
<dd><a name="1074860"> </a>A valid character.</dd>

</dl>
<h4>
  <a name="1074861"> </a>Returns 
</h4>

<p><a name="1074862"> </a><code>true</code> if the character is a letter in an alphabet or a numeric digit, <code>false</code> otherwise.</p>
<h4>
  <a name="1075910"> </a>See Also 
</h4>

<p><a name="1075011"> </a><a href="TextMgr.html#1015619"><code>TxtCharIsDigit()</code></a>, <a href="TextMgr.html#1013327"><code>TxtCharIsAlpha()</code></a> </p>

<h3 class="hbH3">
  <a name="1013327"> </a>TxtCharIsAlpha Macro <a href="#1044699"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="1013357"> </a>Purpose 
</h4>

<p><a name="1075916"> </a>Indicates if a character is a letter in an alphabet. </p>
<h4>
  <a name="1013362"> </a>Declared In 
</h4>
<code>TextMgr.h<a name="1013368"> </a></code><h4>
  <a name="1013371"> </a>Prototype 
</h4>
<pre class="proto"><a name="1013373"></a>#define TxtCharIsAlpha (
   <code class="par">ch</code>
)
</pre>
<h4>
  <a name="1013376"> </a>Parameters 
</h4>

<dl>
<dt><a name="1076969"> </a><code>&rarr;  <i>ch</i></code></dt>
<dd><a name="1077120"> </a>A valid character.</dd>

</dl>
<h4>
  <a name="1077121"> </a>Returns 
</h4>

<p><a name="1077122"> </a><code>true</code> if the character is a letter in an alphabet, <code>false</code> otherwise.</p>
<h4>
  <a name="1078019"> </a>See Also 
</h4>

<p><a name="1078029"> </a><a href="TextMgr.html#1013248"><code>TxtCharIsAlNum()</code></a>, <a href="TextMgr.html#1018752"><code>TxtCharIsLower()</code></a>, <a href="TextMgr.html#1021984"><code>TxtCharIsUpper()</code></a></p>

<h3 class="hbH3">
  <a name="1076978"> </a>TxtCharIsCntrl Macro <a href="#1044699"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="1014604"> </a>Purpose 
</h4>

<p><a name="1078033"> </a>Indicates if a character is a control character. </p>
<h4>
  <a name="1014693"> </a>Declared In 
</h4>
<code>TextMgr.h<a name="1014733"> </a></code><h4>
  <a name="1014778"> </a>Prototype 
</h4>
<pre class="proto"><a name="1014826"></a>#define TxtCharIsCntrl (
   <code class="par">ch</code>
)
</pre>
<h4>
  <a name="1014883"> </a>Parameters 
</h4>

<dl>
<dt><a name="1078037"> </a><code>&rarr;  <i>ch</i></code></dt>
<dd><a name="1078038"> </a>A valid character.</dd>

</dl>
<h4>
  <a name="1078039"> </a>Returns 
</h4>

<p><a name="1078040"> </a><code>true</code> if the character is a non-printable character, such as the bell character or a carriage return; <code>false</code> otherwise. </p>

<h3 class="hbH3">
  <a name="1015436"> </a>TxtCharIsDelim Macro <a href="#1044699"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="1015558"> </a>Purpose 
</h4>

<p><a name="1078048"> </a>Indicates if a character is a delimiter. </p>
<h4>
  <a name="1015587"> </a>Declared In 
</h4>
<code>TextMgr.h<a name="1015589"> </a></code><h4>
  <a name="1015592"> </a>Prototype 
</h4>
<pre class="proto"><a name="1015594"></a>#define TxtCharIsDelim (
   <code class="par">ch</code>
)
</pre>
<h4>
  <a name="1015597"> </a>Parameters 
</h4>

<dl>
<dt><a name="1078052"> </a><code>&rarr;  <i>ch</i></code></dt>
<dd><a name="1078053"> </a>A valid character.</dd>

</dl>
<h4>
  <a name="1078054"> </a>Returns 
</h4>

<p><a name="1078055"> </a><code>true</code> if the character is a word delimiter (whitespace or punctuation), <code>false</code> otherwise. </p>

<h3 class="hbH3">
  <a name="1015619"> </a>TxtCharIsDigit Macro <a href="#1044699"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="1015649"> </a>Purpose 
</h4>

<p><a name="1078101"> </a>Indicates if the character is a decimal digit. </p>
<h4>
  <a name="1015654"> </a>Declared In 
</h4>
<code>TextMgr.h<a name="1015660"> </a></code><h4>
  <a name="1015663"> </a>Prototype 
</h4>
<pre class="proto"><a name="1015665"></a>#define TxtCharIsDigit (
   <code class="par">ch</code>
)
</pre>
<h4>
  <a name="1015668"> </a>Parameters 
</h4>

<dl>
<dt><a name="1078105"> </a><code>&rarr;  <i>ch</i></code></dt>
<dd><a name="1078106"> </a>A valid character.</dd>

</dl>
<h4>
  <a name="1078107"> </a>Returns 
</h4>

<p><a name="1078108"> </a><code>true</code> if the character is 0 through 9, <code>false</code> otherwise. </p>
<h4>
  <a name="1078162"> </a>See Also 
</h4>

<p><a name="1078169"> </a><a href="TextMgr.html#1013248"><code>TxtCharIsAlNum()</code></a>, <a href="TextMgr.html#1017967"><code>TxtCharIsHex()</code></a> </p>

<h3 class="hbH3">
  <a name="1016826"> </a>TxtCharIsGraph Macro <a href="#1044699"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="1016896"> </a>Purpose 
</h4>

<p><a name="1078215"> </a>Indicates if a character is a graphic character.</p>
<h4>
  <a name="1016985"> </a>Declared In 
</h4>
<code>TextMgr.h<a name="1017025"> </a></code><h4>
  <a name="1017070"> </a>Prototype 
</h4>
<pre class="proto"><a name="1017118"></a>#define TxtCharIsGraph (
   <code class="par">ch</code>
)
</pre>
<h4>
  <a name="1017175"> </a>Parameters 
</h4>

<dl>
<dt><a name="1078259"> </a><code>&rarr;  <i>ch</i></code></dt>
<dd><a name="1078260"> </a>A valid character.</dd>

</dl>
<h4>
  <a name="1078261"> </a>Returns 
</h4>

<p><a name="1078263"> </a><code>true</code> if the character is a graphic character, <code>false</code> otherwise. </p>
<h4>
  <a name="1078264"> </a>Comments 
</h4>

<p><a name="1078265"> </a>A graphic character is any character visible on the screen, in other words, letters, digits, and punctuation marks. A blank space is not a graphic character because it is not visible. </p>

<p><a name="1078269"> </a>This macro differs from <a href="TextMgr.html#1019502"><code>TxtCharIsPrint()</code></a> in that it returns <code>false</code> if the character is whitespace. <code>TxtCharIsPrint()</code> returns <code>true</code> if the character is whitespace. </p>

<h3 class="hbH3">
  <a name="1017728"> </a>TxtCharIsHardKey Macro <a href="#1044699"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="1017850"> </a>Purpose 
</h4>

<p><a name="1078302"> </a>Returns true if the character is one of the hard keys on the device.</p>
<h4>
  <a name="1017879"> </a>Declared In 
</h4>
<code>TextMgr.h<a name="1017881"> </a></code><h4>
  <a name="1017884"> </a>Prototype 
</h4>
<pre class="proto"><a name="1017886"></a>#define TxtCharIsHardKey (
   <code class="par">m</code>,
   <code class="par"> c</code>
)
</pre>
<h4>
  <a name="1017889"> </a>Parameters 
</h4>

<dl>
<dt><a name="1078326"> </a><code>&rarr;  <i>m</i></code></dt>
<dd><a name="1126822"> </a>The value passed in the <code>modifiers</code> field of the <a href="../Input_Services/In_LowEvents.html#993792"><code>keyDownEvent</code></a>. </dd>

<dt><a name="1017896"> </a><code>&rarr;  <i>c</i></code></dt>
<dd><a name="1078354"> </a>The character from the <code>keyDownEvent</code>.</dd>

</dl>
<h4>
  <a name="1017900"> </a>Returns 
</h4>

<p><a name="1078378"> </a><code>true</code> if the character is one of the built-in hard keys on the device, <code>false</code> otherwise. </p>

<h3 class="hbH3">
  <a name="1017967"> </a>TxtCharIsHex Macro <a href="#1044699"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="1017997"> </a>Purpose 
</h4>

<p><a name="1078435"> </a>Indicates if a character is a hexadecimal digit. </p>
<h4>
  <a name="1018006"> </a>Declared In 
</h4>
<code>TextMgr.h<a name="1018008"> </a></code><h4>
  <a name="1018011"> </a>Prototype 
</h4>
<pre class="proto"><a name="1018013"></a>#define TxtCharIsHex (
   <code class="par">ch</code>
)
</pre>
<h4>
  <a name="1018064"> </a>Parameters 
</h4>

<dl>
<dt><a name="1018089"> </a><code>&rarr;  <i>ch</i></code></dt>
<dd><a name="1078459"> </a>A valid character.</dd>

</dl>
<h4>
  <a name="1078460"> </a>Returns 
</h4>

<p><a name="1078461"> </a><code>true</code> if the character is a hexadecimal digit from 0 to F, <code>false</code> otherwise. </p>
<h4>
  <a name="1018571"> </a>See Also 
</h4>

<p><a name="1078496"> </a><a href="TextMgr.html#1015619"><code>TxtCharIsDigit()</code></a> </p>

<h3 class="hbH3">
  <a name="1018752"> </a>TxtCharIsLower Macro <a href="#1044699"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="1018818"> </a>Purpose 
</h4>

<p><a name="1078530"> </a>Indicates if a character is a lowercase letter. </p>
<h4>
  <a name="1018895"> </a>Declared In 
</h4>
<code>TextMgr.h<a name="1018927"> </a></code><h4>
  <a name="1018968"> </a>Prototype 
</h4>
<pre class="proto"><a name="1019016"></a>#define TxtCharIsLower (
   <code class="par">ch</code>
)
</pre>
<h4>
  <a name="1019069"> </a>Parameters 
</h4>

<dl>
<dt><a name="1019129"> </a><code>&rarr;  <i>ch</i></code></dt>
<dd><a name="1078556"> </a>A valid character.</dd>

</dl>
<h4>
  <a name="1078557"> </a>Returns 
</h4>

<p><a name="1078558"> </a><code>true</code> if the character is a lowercase letter, <code>false</code> otherwise.</p>
<h4>
  <a name="1019457"> </a>See Also 
</h4>

<p><a name="1078601"> </a><a href="TextMgr.html#1013327"><code>TxtCharIsAlpha()</code></a>, <a href="TextMgr.html#1021984"><code>TxtCharIsUpper()</code></a> </p>

<h3 class="hbH3">
  <a name="1019502"> </a>TxtCharIsPrint Macro <a href="#1044699"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="1019515"> </a>Purpose 
</h4>

<p><a name="1078607"> </a>Indicates if a character is printable. </p>
<h4>
  <a name="1019520"> </a>Declared In 
</h4>
<code>TextMgr.h<a name="1019522"> </a></code><h4>
  <a name="1019525"> </a>Prototype 
</h4>
<pre class="proto"><a name="1019527"></a>#define TxtCharIsPrint (
   <code class="par">ch</code>
)
</pre>
<h4>
  <a name="1019530"> </a>Parameters 
</h4>

<dl>
<dt><a name="1019532"> </a><code>&rarr;  <i>ch</i></code></dt>
<dd><a name="1078611"> </a>A valid character.</dd>

</dl>
<h4>
  <a name="1078612"> </a>Returns 
</h4>

<p><a name="1078613"> </a><code>true</code> if the character is not a control character, <code>false</code> otherwise. </p>
<h4>
  <a name="1078614"> </a>Comments 
</h4>

<p><a name="1078618"> </a>This macro differs from <a href="TextMgr.html#1016826"><code>TxtCharIsGraph()</code></a> in that it returns <code>true</code> if the character is whitespace. <code>TxtCharIsGraph()</code> returns <code>false</code> if the character is whitespace.</p>

<p><a name="1078619"> </a>If you are using a debug ROM and you pass a virtual character to this macro, a fatal alert is generated.</p>
<h4>
  <a name="1078740"> </a>See Also 
</h4>

<p><a name="1078744"> </a><a href="TextMgr.html#1023191"><code>TxtCharIsValid()</code></a> </p>

<h3 class="hbH3">
  <a name="1019629"> </a>TxtCharIsPunct Macro <a href="#1044699"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="1019646"> </a>Purpose 
</h4>

<p><a name="1078784"> </a>Indicates if a character is a punctuation mark. </p>
<h4>
  <a name="1019699"> </a>Declared In 
</h4>
<code>TextMgr.h<a name="1019724"> </a></code><h4>
  <a name="1019727"> </a>Prototype 
</h4>
<pre class="proto"><a name="1019729"></a>#define TxtCharIsPunct (
   <code class="par">ch</code>
)
</pre>
<h4>
  <a name="1020522"> </a>Parameters 
</h4>

<dl>
<dt><a name="1020760"> </a><code>&rarr;  <i>ch</i></code></dt>
<dd><a name="1078824"> </a>A valid character.</dd>

</dl>
<h4>
  <a name="1078825"> </a>Returns 
</h4>

<p><a name="1078826"> </a><code>true</code> if the character is a punctuation mark, <code>false</code> otherwise. </p>

<h3 class="hbH3">
  <a name="1021409"> </a>TxtCharIsSpace Macro <a href="#1044699"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="1021459"> </a>Purpose 
</h4>

<p><a name="1078988"> </a>Indicates if a character is a whitespace character.</p>
<h4>
  <a name="1021532"> </a>Declared In 
</h4>
<code>TextMgr.h<a name="1021560"> </a></code><h4>
  <a name="1021597"> </a>Prototype 
</h4>
<pre class="proto"><a name="1021637"></a>#define TxtCharIsSpace (
   <code class="par">ch</code>
)
</pre>
<h4>
  <a name="1021686"> </a>Parameters 
</h4>

<dl>
<dt><a name="1021742"> </a><code>&rarr;  <i>ch</i></code></dt>
<dd><a name="1079012"> </a>A valid character.</dd>

</dl>
<h4>
  <a name="1021907"> </a>Returns 
</h4>

<p><a name="1079036"> </a><code>true</code> if the character is whitespace such as a blank space, tab, or newline; <code>false</code> otherwise. </p>

<h3 class="hbH3">
  <a name="1021984"> </a>TxtCharIsUpper Macro <a href="#1044699"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="1022014"> </a>Purpose 
</h4>

<p><a name="1079076"> </a>Indicates if a character is an uppercase letter. </p>
<h4>
  <a name="1022019"> </a>Declared In 
</h4>
<code>TextMgr.h<a name="1022025"> </a></code><h4>
  <a name="1022028"> </a>Prototype 
</h4>
<pre class="proto"><a name="1022030"></a>#define TxtCharIsUpper (
   <code class="par">ch</code>
)
</pre>
<h4>
  <a name="1022033"> </a>Parameters 
</h4>

<dl>
<dt><a name="1022035"> </a><code>&rarr;  <i>ch</i></code></dt>
<dd><a name="1079108"> </a>A valid character.</dd>

</dl>
<h4>
  <a name="1079109"> </a>Returns 
</h4>

<p><a name="1079110"> </a><code>true</code> if the character is an uppercase letter, <code>false</code> otherwise.</p>
<h4>
  <a name="1079152"> </a>See Also 
</h4>

<p><a name="1079159"> </a><a href="TextMgr.html#1013327"><code>TxtCharIsAlpha()</code></a>, <a href="TextMgr.html#1018752"><code>TxtCharIsLower()</code></a> </p>

<h3 class="hbH3">
  <a name="1023191"> </a>TxtCharIsValid Function <a href="#1044699"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="1023261"> </a>Purpose 
</h4>

<p><a name="1079194"> </a>Determines whether a character is valid given the Palm OS character encoding. </p>
<h4>
  <a name="1023350"> </a>Declared In 
</h4>
<code>TextMgr.h<a name="1023390"> </a></code><h4>
  <a name="1023435"> </a>Prototype 
</h4>
<pre class="proto"><a name="1023483"></a>Boolean TxtCharIsValid (
   wchar32_t <code class="par">iChar</code>
)
</pre>
<h4>
  <a name="1023540"> </a>Parameters 
</h4>

<dl>
<dt><a name="1023604"> </a><code>&rarr;  <i>iChar</i></code></dt>
<dd><a name="1079226"> </a>A character. </dd>

</dl>
<h4>
  <a name="1079227"> </a>Returns 
</h4>

<p><a name="1079228"> </a><code>true</code> if <span style="color: #000000;  font-family: Courier; font-style: oblique; font-weight: normal; text-decoration: none; text-transform: none; vertical-align: baseline">iChar</span> is a valid character; <code>false</code> if <span style="color: #000000;  font-family: Courier; font-style: oblique; font-weight: normal; text-decoration: none; text-transform: none; vertical-align: baseline">iChar</span> is not a valid character. </p>
<h4>
  <a name="1023964"> </a>See Also 
</h4>

<p><a name="1079268"> </a><a href="TextMgr.html#1008908"><code>TxtCharAttr()</code></a>, <a href="TextMgr.html#1019502"><code>TxtCharIsPrint()</code></a> </p>

<h3 class="hbH3">
  <a name="1024093"> </a>TxtCharIsVirtual Macro <a href="#1044699"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="1024215"> </a>Purpose 
</h4>

<p><a name="1084203"> </a>Returns whether a character is a virtual character or not. </p>
<h4>
  <a name="1024244"> </a>Declared In 
</h4>
<code>TextMgr.h<a name="1024246"> </a></code><h4>
  <a name="1024249"> </a>Prototype 
</h4>
<pre class="proto"><a name="1024251"></a>#define TxtCharIsVirtual (
   <code class="par">m</code>,
   <code class="par"> c</code>
)
</pre>
<h4>
  <a name="1024254"> </a>Parameters 
</h4>

<dl>
<dt><a name="1024256"> </a><code>&rarr;  <i>m</i></code></dt>
<dd><a name="1084207"> </a>The value passed in the <code>modifiers</code> field of the <a href="../Input_Services/In_LowEvents.html#993792"><code>keyDownEvent</code></a>. </dd>

<dt><a name="1024261"> </a><code>&rarr;  <i>c</i></code></dt>
<dd><a name="1126858"> </a>The character from the <code>keyDownEvent</code>.</dd>

</dl>
<h4>
  <a name="1024265"> </a>Returns 
</h4>

<p><a name="1084218"> </a><code>true</code> if the character <span style="color: #000000;  font-family: Courier; font-style: oblique; font-weight: normal; text-decoration: none; text-transform: none; vertical-align: baseline">c</span> is a virtual character, <code>false</code> otherwise. </p>
<h4>
  <a name="1084219"> </a>Comments 
</h4>

<p><a name="1084220"> </a>Virtual characters are nondisplayable characters that trigger special events in the operating system, such as displaying low battery warnings or displaying the keyboard dialog. Virtual characters should never occur in any data and should never appear on the screen. </p>

<h3 class="hbH3">
  <a name="1024332"> </a>TxtCharSize Function <a href="#1044699"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="1024362"> </a>Purpose 
</h4>

<p><a name="1079305"> </a>Returns the number of bytes required to store the character in a string. </p>
<h4>
  <a name="1024371"> </a>Declared In 
</h4>
<code>TextMgr.h<a name="1024373"> </a></code><h4>
  <a name="1024376"> </a>Prototype 
</h4>
<pre class="proto"><a name="1024378"></a>size_t TxtCharSize (
   wchar32_t <code class="par">iChar</code>
)
</pre>
<h4>
  <a name="1024429"> </a>Parameters 
</h4>

<dl>
<dt><a name="1024454"> </a><code>&rarr;  <i>iChar</i></code></dt>
<dd><a name="1079325"> </a>A valid character. </dd>

</dl>
<h4>
  <a name="1079326"> </a>Returns 
</h4>

<p><a name="1079327"> </a>The number of bytes required to store the character in a string. </p>
<h4>
  <a name="1079328"> </a>Comments 
</h4>

<p><a name="1079329"> </a>Although character variables are always multi-byte long <code>wchar32_t</code> values, in some character encodings such as Shift JIS, characters in strings are represented by a mix of one or more bytes per character. If the character can be represented by a single byte (its high-order bytes are 0), it is stored in a string as a single-byte character. </p>
<h4>
  <a name="1024936"> </a>See Also 
</h4>

<p><a name="1079336"> </a><a href="TextMgr.html#1010728"><code>TxtCharBounds()</code></a> </p>

<h3 class="hbH3">
  <a name="1025117"> </a>TxtCharXAttr Function <a href="#1044699"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="1025183"> </a>Purpose 
</h4>

<p><a name="1079347"> </a>Returns the extended attribute bits for a character.</p>
<h4>
  <a name="1025260"> </a>Declared In 
</h4>
<code>TextMgr.h<a name="1025292"> </a></code><h4>
  <a name="1025333"> </a>Prototype 
</h4>
<pre class="proto"><a name="1025381"></a>uint32_t TxtCharXAttr (
   wchar32_t <code class="par">iChar</code>
)
</pre>
<h4>
  <a name="1025434"> </a>Parameters 
</h4>

<dl>
<dt><a name="1025494"> </a><code>&rarr;  <i>iChar</i></code></dt>
<dd><a name="1079355"> </a>A valid character.</dd>

</dl>
<h4>
  <a name="1079356"> </a>Returns 
</h4>

<p><a name="1079357"> </a>An unsigned 32-bit value with one or more extended attribute bits set. For specific return values, look in the header files that are specific to certain character encodings (<code>CharLatin.h</code> or <code>CharShiftJIS.h</code>). </p>
<h4>
  <a name="1079358"> </a>Comments 
</h4>

<p><a name="1079359"> </a>To interpret the results, you must know the character encoding being used. The function <a href="LocaleMgr.html#1015402"><code>LmGetSystemLocale()</code></a> returns the character encoding used on the device as one of the <a href="TextMgr.html#995858"><code>CharEncodingType</code></a> values. You can pass <code>NULL</code> as the parameter to <code>LmGetSystemLocale()</code> if you don't want to retrieve any other locale information. </p>
<h4>
  <a name="1025822"> </a>See Also 
</h4>

<p><a name="1079477"> </a><a href="TextMgr.html#1008908"><code>TxtCharAttr()</code></a>, <a href="Text.html#1037155">"Retrieving the Character Encoding"</a></p>

<h3 class="hbH3">
  <a name="1025867"> </a>TxtCompare Function <a href="#1044699"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="1025880"> </a>Purpose 
</h4>

<p><a name="1079540"> </a>Performs a case-sensitive comparison of all or part of two text buffers.</p>
<h4>
  <a name="1025885"> </a>Declared In 
</h4>
<code>TextMgr.h<a name="1025887"> </a></code><h4>
  <a name="1025890"> </a>Prototype 
</h4>
<pre class="proto"><a name="1025892"></a>int16_t TxtCompare (
   const char <code class="par">*s1</code>,
   size_t <code class="par">s1Len</code>,
   size_t <code class="par">*s1MatchLen</code>,
   const char <code class="par">*s2</code>,
   size_t <code class="par">s2Len</code>,
   size_t <code class="par">*s2MatchLen</code>
)
</pre>
<h4>
  <a name="1025895"> </a>Parameters 
</h4>

<dl>
<dt><a name="1079590"> </a><code>&rarr;  <i>s1</i></code></dt>
<dd><a name="1079591"> </a>The first text buffer to compare. </dd>

<dt><a name="1079592"> </a><code>&rarr;  <i>s1Len</i></code></dt>
<dd><a name="1079593"> </a>The length in bytes of the text pointed to by <code class="par">s1</code>. </dd>

<dt><a name="1079594"> </a><code>&larr;  <i>s1MatchLen</i></code></dt>
<dd><a name="1079595"> </a>Points to the offset of the first character in <code class="par">s1</code> that determines the sort order. Pass <code>NULL</code> for this parameter if you don't need to know this number. </dd>

<dt><a name="1079596"> </a><code>&rarr;  <i>s2</i></code></dt>
<dd><a name="1079597"> </a>The second text buffer to compare.</dd>

<dt><a name="1079598"> </a><code>&rarr;  <i>s2Len</i></code></dt>
<dd><a name="1079599"> </a>The length in bytes of the text pointed to by <code class="par">s2</code>.</dd>

<dt><a name="1079600"> </a><code>&larr;  <i>s2MatchLen</i></code></dt>
<dd><a name="1079601"> </a>Points to the offset of the first character in <code class="par">s2</code> that determines the sort order. Pass <code>NULL</code> for this parameter if you don't need to know this number. </dd>

</dl>
<h4>
  <a name="1079602"> </a>Returns 
</h4>

<p><a name="1079603"> </a>One of the following values: </p>


<div class="tablediv"><table cellspacing="0" class="tTableNR">

  <tr valign="top">
    <td><p class="tt"><a name="1079606"> </a>&lt; 0 </p>
    </td>
    <td><p class="tt"><a name="1079608"> </a>If <code class="par">s1</code> occurs before <code class="par">s2</code> in alphabetical order.</p>
    </td>
  </tr>
  <tr valign="top">
    <td><p class="tt"><a name="1079610"> </a>&gt; 0 </p>
    </td>
    <td><p class="tt"><a name="1079612"> </a>If <code class="par">s1</code> occurs after <code class="par">s2</code> in alphabetical order.</p>
    </td>
  </tr>
  <tr valign="top">
    <td><p class="tt"><a name="1079614"> </a>0 </p>
    </td>
    <td><p class="tt"><a name="1079616"> </a>If the two substrings that were compared are equal. </p>
    </td>
  </tr>
</table>

</div>

<h4>
  <a name="1079618"> </a>Comments 
</h4>

<p><a name="1079619"> </a>This function performs a case-sensitive comparison. If you want to perform a case-insensitive comparison, use <a href="TextMgr.html#1008102"><code>TxtCaselessCompare()</code></a>.</p>

<p><a name="1079623"> </a>The <code class="par">s1MatchLen</code> and <code class="par">s2MatchLen</code> parameters are not as useful for the <code>TxtCompare()</code> function as they are for the <code>TxtCaselessCompare()</code> function because <code>TxtCompare()</code> implements a multi-pass sort algorithm. For example, if you use <code>TxtCaselessCompare()</code> to compare the string "celery" with the string "Cauliflower," it returns a positive value to indicate that "celery" sorts after "Cauliflower," and it returns a match length of 1 to indicate that the second letter determines the sort order ("e" comes after "a"). However, because <code>TxtCompare()</code> ultimately does a case-sensitive comparison, comparing the string "c" to the string "C" produces a negative result and a match length of 0. </p>

<p><a name="1079624"> </a>In certain character encodings (such as Shift JIS), one character may be accurately represented as either a single-byte character or a multi-byte character. <code>TxtCompare()</code> accurately matches a single-byte character with its multi-byte equivalent. For this reason, the values returned in <code class="par">s1MatchLen</code> and <code class="par">s2MatchLen</code> are not always equal. </p>

<p><a name="1079625"> </a>You must make sure that the parameters <code class="par">s1</code> and <code class="par">s2</code> point to the start of a a valid character. That is, they must point to the first byte of a multi-byte character or they must point to a single-byte character; if they don't, results are unpredictable. </p>
<h4>
  <a name="1079778"> </a>See Also 
</h4>

<p><a name="1079785"> </a><a href="StringMgr.html#999999"><code>StrCompare()</code></a>, <a href="TextMgr.html#1027900"><code>TxtFindString()</code></a> </p>

<h3 class="hbH3">
  <a name="1026712"> </a>TxtConvertEncoding Function <a href="#1044699"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="1026746"> </a>Purpose 
</h4>

<p><a name="1079789"> </a>Converts a text buffer from one character encoding to another. </p>
<h4>
  <a name="1026803"> </a>Declared In 
</h4>
<code>TextMgr.h<a name="1026827"> </a></code><h4>
  <a name="1026856"> </a>Prototype 
</h4>
<pre class="proto"><a name="1026888"></a>status_t TxtConvertEncoding (
   Boolean <code class="par">newConversion</code>,
   TxtConvertStateType <code class="par">*ioStateP</code>,
   const char <code class="par">*srcTextP</code>,
   size_t <code class="par">*ioSrcBytes</code>,
   CharEncodingType <code class="par">srcEncoding</code>,
   char <code class="par">*dstTextP</code>,
   size_t <code class="par">*ioDstBytes</code>,
   CharEncodingType <code class="par">dstEncoding</code>,
   const char <code class="par">*substitutionStr</code>,
   size_t <code class="par">substitutionLen</code>
)
</pre>
<h4>
  <a name="1026949"> </a>Parameters 
</h4>

<dl>
<dt><a name="1079793"> </a><code>&rarr;  <i>newConversion</i></code></dt>
<dd><a name="1079794"> </a>Set to <code>true</code> if this function call is starting a new conversion, or <code>false</code> if this function call is a continuation of a previous conversion.</dd>

<dt><a name="1079795"> </a><code>&harr;  <i>ioStateP</i></code></dt>
<dd><a name="1079796"> </a>If <code class="par">newConversion</code> is <code>false</code>, this parameter must point to a <a href="TextMgr.html#1092092"><code>TxtConvertStateType</code></a> structure containing the same data used for the previous invocation. If <code class="par">newConversion</code> is <code>true</code> and no subsequent calls are planned, this parameter can be <code>NULL</code>. </dd>

<dt><a name="1079800"> </a><code>&rarr;  <i>srcTextP</i></code></dt>
<dd><a name="1079801"> </a>The source text buffer. If <code class="par">newConversion</code> is <code>true</code>, this must point to the start of a text buffer. If <code class="par">newConversion</code> is <code>false</code>, it may point to a location in the middle of a text buffer. In either case, it must point to an inter-character boundary.</dd>

<dt><a name="1079802"> </a><code>&harr;  <i>ioSrcBytes</i></code></dt>
<dd><a name="1079803"> </a>A pointer to the size, in bytes, of the text starting at <code class="par">srcTextP</code> that needs to be converted. Upon return, <code class="par">*ioSrcBytes</code> contains the number of bytes successfully processed.</dd>

<dd><a name="1126435"> </a>If <code class="par">srcTextP</code> is null-terminated and you want <code class="par">dstTextP</code> to be null terminated, include a byte for the null terminator in this size. </dd>

<dt><a name="1079804"> </a><code>&rarr;  <i>srcEncoding</i></code></dt>
<dd><a name="1079805"> </a>The character encoding that the source text uses. See <a href="TextMgr.html#995858"><code>CharEncodingType</code></a>. </dd>

<dt><a name="1079809"> </a><code>&harr;  <i>dstTextP</i></code></dt>
<dd><a name="1079810"> </a>The destination text buffer, which must be large enough to hold the result of converting <code class="par">srcTextP</code> to the specified encoding. You can pass <code>NULL</code> for the <code class="par">dstTextP</code> parameter to determine the required length of the buffer before actually doing the conversion; the required length is returned in <code class="par">ioDstBytes</code>.</dd>

<dd><a name="1124230"> </a><code>TxtConvertEncoding()</code> does not write the terminating null character to <code class="par">dstTextP</code> unless one is present in <code class="par">srcTextP</code> and <code class="par">ioSrcBytes</code> includes space for it. </dd>

<dt><a name="1079811"> </a><code>&harr;  <i>ioDstBytes</i></code></dt>
<dd><a name="1079812"> </a>A pointer to the length, in bytes, of <code class="par">dstTextP</code>. Upon return, <code class="par">*ioDstBytes</code> contains the number of bytes required to represent the source text in the new encoding.</dd>

<dt><a name="1079813"> </a><code>&rarr;  <i>dstEncoding</i></code></dt>
<dd><a name="1126771"> </a>The character encoding to which to convert <code class="par">srcTextP</code>. See <a href="TextMgr.html#995858"><code>CharEncodingType</code></a> for a description of the possible values. Note that the encoding can be modified, giving you greater control over the conversion process; see <a href="TextMgr.html#1048967">"Encoding Conversion Constant Modifiers."</a></dd>

<dt><a name="1079821"> </a><code>&rarr;  <i>substitutionStr</i></code></dt>
<dd><a name="1079822"> </a>A string to be substituted for any invalid or inconvertible characters that occur in the source text. This string must be valid in the encoding specified by the constant <code>textSubstitutionEncoding</code>. If this parameter is <code>NULL</code>, <code>TxtConvertEncoding()</code> immediately returns if it encounters an invalid character.</dd>

<dd><a name="1112001"> </a>You can pass the constant <span style="color: #000000;  font-family: Courier; font-style: normal; font-weight: normal; text-decoration: none; text-transform: none; vertical-align: baseline">textSubstitutionDefaultStr </span>for this parameter to have a question mark used as the substitution string. </dd>

<dt><a name="1079823"> </a><code>&rarr;  <i>substitutionLen</i></code></dt>
<dd><a name="1079824"> </a>The number of bytes in <code class="par">substitutionStr</code>, not including the terminating null byte. </dd>

<dd><a name="1112120"> </a>If you use <span style="color: #000000;  font-family: Courier; font-style: normal; font-weight: normal; text-decoration: none; text-transform: none; vertical-align: baseline">textSubstitutionDefaultStr </span>for <code class="par">substitutionStr</code>, use <span style="color: #000000;  font-family: Courier; font-style: normal; font-weight: normal; text-decoration: none; text-transform: none; vertical-align: baseline">textSubstitutionDefaultLen</span> for this parameter. </dd>

</dl>
<h4>
  <a name="1079825"> </a>Returns 
</h4>

<p><a name="1079826"> </a><code>errNone</code> upon success or one of the following if an error occurs: </p>

<dl>
<dt><a name="1079828"> </a><code><code>txtErrConvertOverflow</code></code></dt>
<dd><a name="1079829"> </a>The destination buffer is not large enough to contain the converted text. </dd>

<dt><a name="1079830"> </a><code><code>txtErrConvertUnderflow</code></code></dt>
<dd><a name="1079831"> </a>The end of the source buffer contains a partial character. </dd>

<dt><a name="1079832"> </a><code><code>txtErrMalformedText</code></code></dt>
<dd><a name="1079833"> </a>An error in the source text encoding has been discovered.</dd>

<dt><a name="1079834"> </a><code><code>txtErrNoCharMapping</code></code></dt>
<dd><a name="1079835"> </a>The device does not contain a mapping between the source and destination encodings for at least one of the characters in <code class="par">srcTextP</code>. </dd>

<dt><a name="1079836"> </a><code><code>txtErrUnknownEncoding</code></code></dt>
<dd><a name="1079837"> </a>One of the specified encodings is unknown or can't be handled.</dd>

<dt><a name="1079839"> </a><code><code>txtErrUnknownEncodingFallbackCopy</code></code></dt>
<dd><a name="1079840"> </a>Either the source or destination encoding is unknown, and the best fit flag was set in the destination encoding. Before returning this error code, <code>TxtConvertEncoding()</code> copies anything that is 7-bit ASCII from the source text buffer to the destination text buffer.</dd>

</dl>
<h4>
  <a name="1079841"> </a>Comments 
</h4>

<p><a name="1079842"> </a>This function converts <code class="par">ioSrcBytes</code> of text in <code class="par">srcTextP</code> from the <code class="par">srcEncoding</code> to the <code class="par">dstEncoding</code> character encoding and returns the result in <code class="par">dstTextP</code>. </p>

<p><a name="1079869"> </a>The supported encodings for <code class="par">srcEncoding</code> and <code class="par">dstEncoding</code> are locale-dependent. See <a href="TextMgr.html#1079895">"Encodings Supported by Various Locales."</a> However, this function is most commonly used to convert between an encoding used on the Internet and the device's encoding; therefore, all locales support conversions between most Unicode character sets and the device's encoding. If you use any of the following character encodings, the conversion should work: </p>
<ul type="disc">
  <li><a name="1114807"> </a>The device's character encoding as returned by the function <a href="LocaleMgr.html#1015402"><code>LmGetSystemLocale()</code></a> 
  <li><a name="1115344"> </a>Any of the following, which can be retrieved using <a href="LocaleMgr.html#998534"><code>LmGetLocaleSetting()</code></a>: 
  <ul type="disc">
    <li><a name="1115606"> </a><code>lmChoiceInboundDefaultVObjectEncoding</code> (as <code class="par">srcEncoding</code> only) 
    <li><a name="1115607"> </a><code>lmChoicePrimarySMSEncoding</code> (as <code class="par">dstEncoding</code> only) 
    <li><a name="1115561"> </a><code>lmChoiceSecondarySMSEncoding</code> (as <code class="par">dstEncoding</code> only) 
    <li><a name="1115562"> </a><code>lmChoicePrimaryEmailEncoding</code> (as <code class="par">dstEncoding</code> only) 
    <li><a name="1115563"> </a><code>lmChoiceSecondaryEmailEncoding</code> (as <code class="par">dstEncoding</code> only) 
    <li><a name="1115564"> </a><code>lmChoiceOutboundVObjectEncoding </code><span style="color: #000000;  font-style: normal; font-weight: normal; text-decoration: none; text-transform: none; vertical-align: baseline">(as </span><code class="par">dstEncoding</code><span style="color: #000000;  font-style: normal; font-weight: normal; text-decoration: none; text-transform: none; vertical-align: baseline"> only) </span>
  </ul>
</ul>

<div><hr>
  <a name="1121701"> </a> <b>TIP: </b> If you're converting text that was received from the Internet, the encoding name is passed along with the text data. Use the <a href="TextMgr.html#1034702"><code>TxtNameToEncoding()</code></a> function to convert the name to a <code>CharEncodingType</code> value. 
<hr>
</div>

<p><a name="1079880"> </a>If the function encounters an inconvertible character in the source text, it puts <code class="par">substitutionStr</code> in the destination buffer in that character's place and continues the conversion. When the conversion is complete, it returns <code>txtErrNoCharMapping</code> to indicate that an error occurred (assuming that no other higher-priority error occurred during the conversion). If <code class="par">substitutionStr</code> is <code>NULL</code>, the function stops the conversion and immediately returns <code>txtErrNoCharMapping</code>. <code class="par">ioSrcBytes</code> is set to the offset of the inconvertible character, <code class="par">dstTextP</code> contains the converted string up to that point, and <code class="par">ioDstBytes</code> contains the size of the converted text. You can examine the character at <code class="par">ioSrcBytes</code> and choose to move past it and continue the conversion. Follow the rules for making repeated calls to <code>TxtConvertEncoding()</code> as described below. </p>

<h4 class="hcH4">
  <a name="1125236"> </a>Calling TxtConvertEncoding() in a Loop
</h4>

<p><a name="1079881"> </a>You can make repeated calls to <code>TxtConvertEncoding()</code> in a loop if you only want to convert part of the input buffer at a time. When you make repeated calls to this function, the first call should use <code>true</code> for <code class="par">newConversion</code>, and <code class="par">srcTextP</code> should point to the start of the text buffer. All subsequent calls should use the following values: </p>

<dl>
<dt><a name="1079882"> </a><code><code class="par">newConversion</code></code></dt>
<dd><a name="1079883"> </a><code>false</code>. </dd>

<dt><a name="1079884"> </a><code><code class="par">ioStateP</code></code></dt>
<dd><a name="1079885"> </a>The same data that was returned by the previous invocation. </dd>

<dt><a name="1079886"> </a><code><code class="par">srcTextP</code></code></dt>
<dd><a name="1079887"> </a>The location where this call should begin converting. Typically, this would be the previous <code class="par">srcTextP</code> plus the number of bytes returned in <code class="par">ioSrcBytes</code>. </dd>

<dd><a name="1079888"> </a>If you are skipping over an inconvertible character, <code class="par">srcTextP</code> must point to the character after that location. </dd>

<dt><a name="1079889"> </a><code><code class="par">ioSrcBytes</code> </code></dt>
<dd><a name="1079890"> </a>The number of bytes that this function call should convert. </dd>

<dt><a name="1079891"> </a><code><code class="par">dstTextP</code></code></dt>
<dd><a name="1079892"> </a>A pointer to a location where this function can begin writing the converted string. You might choose to have each function call write to a different destination buffer. To have successive calls write to the same buffer, pass the previous <code class="par">dstTextP</code> plus the number of bytes returned in <code class="par">ioDstBytes</code> each time. </dd>

<dt><a name="1079893"> </a><code><code class="par">ioDstBytes</code></code></dt>
<dd><a name="1079894"> </a>The number of bytes available for output in the <code class="par">dstTextP</code> buffer. In other words, the number of bytes remaining. </dd>

</dl>

<h4 class="hcH4">
  <a name="1079895"> </a>Encodings Supported by Various Locales
</h4>

<p><a name="1079896"> </a>Each device's ROM contains a system-use only locale module that contains tables <code>TxtConvertEncoding()</code> uses to convert one encoding to another. Therefore, the encodings that <code>TxtConvertEncoding()</code> supports are dependent upon the ROM's locale. The locale module provides support for Unicode, the device encoding, and a set of related or locale-important encodings. The following tables summarize the set of encodings supported in <code>TxtConvertEncoding()</code> by various locales.</p>

<p class="caption"><a name="1079903"> </a><b>Table 8.1&nbsp;&nbsp;Source encodings for Latin ROMs </b></p>
<div class="tablediv"><table cellspacing="0" class="tTable">

  <tr valign="top">
    <td><p class="tt"><a name="1079907"> </a>charEncodingUCS2</p>
    </td>
    <td><p class="tt"><a name="1079909"> </a>charEncodingUCS4</p>
    </td>
  </tr>
  <tr valign="top">
    <td><p class="tt"><a name="1079911"> </a>charEncodingUTF16</p>
    </td>
    <td><p class="tt"><a name="1079913"> </a>charEncodingUTF32</p>
    </td>
  </tr>
  <tr valign="top">
    <td><p class="tt"><a name="1120242"> </a>charEncodingUTF16BE</p>
    </td>
    <td><p class="tt"><a name="1120244"> </a>charEncodingUTF32BE</p>
    </td>
  </tr>
  <tr valign="top">
    <td><p class="tt"><a name="1119591"> </a>charEncodingUTF16LE</p>
    </td>
    <td><p class="tt"><a name="1119593"> </a>charEncodingUTF32LE</p>
    </td>
  </tr>
  <tr valign="top">
    <td><p class="tt"><a name="1079915"> </a>charEncodingUTF8</p>
    </td>
    <td><p class="tt"><a name="1079917"> </a>charEncodingPalmLatin</p>
    </td>
  </tr>
  <tr valign="top">
    <td><p class="tt"><a name="1120669"> </a>charEncodingAscii</p>
    </td>
    <td><p class="tt"><a name="1120671"> </a>charEncodingGSM</p>
    </td>
  </tr>
  <tr valign="top">
    <td><p class="tt"><a name="1120689"> </a>charEncodingISO8859_1</p>
    </td>
    <td><p class="tt"><a name="1120691"> </a>charEncodingCP1252</p>
    </td>
  </tr>
</table>

</div>


<p class="caption"><a name="1079921"> </a><b>Table 8.2&nbsp;&nbsp;Destination encodings for Latin ROMs </b></p>
<div class="tablediv"><table cellspacing="0" class="tTable">

  <tr valign="top">
    <td><p class="tt"><a name="1120735"> </a>charEncodingUCS2</p>
    </td>
    <td><p class="tt"><a name="1120737"> </a>charEncodingUCS4</p>
    </td>
  </tr>
  <tr valign="top">
    <td><p class="tt"><a name="1120739"> </a>charEncodingUTF16</p>
    </td>
    <td><p class="tt"><a name="1120741"> </a>charEncodingUTF32</p>
    </td>
  </tr>
  <tr valign="top">
    <td><p class="tt"><a name="1120743"> </a>charEncodingUTF16BE</p>
    </td>
    <td><p class="tt"><a name="1120745"> </a>charEncodingUTF32BE</p>
    </td>
  </tr>
  <tr valign="top">
    <td><p class="tt"><a name="1120751"> </a>charEncodingUTF16LE</p>
    </td>
    <td><p class="tt"><a name="1120753"> </a>charEncodingUTF32LE</p>
    </td>
  </tr>
  <tr valign="top">
    <td><p class="tt"><a name="1120747"> </a>charEncodingUTF8</p>
    </td>
    <td><p class="tt"><a name="1120749"> </a>charEncodingPalmLatin</p>
    </td>
  </tr>
  <tr valign="top">
    <td><p class="tt"><a name="1131330"> </a>charEncodingAscii</p>
    </td>
    <td><p class="tt"><a name="1131332"> </a>charEncodingGSM</p>
    </td>
  </tr>
  <tr valign="top">
    <td><p class="tt"><a name="1131326"> </a>charEncodingISO8859_1</p>
    </td>
    <td><p class="tt"><a name="1131328"> </a>charEncodingCP1252</p>
    </td>
  </tr>
</table>

</div>


<p class="caption"><a name="1131583"> </a><b>Table 8.3&nbsp;&nbsp;Source encodings for Shift JIS ROMs </b></p>
<div class="tablediv"><table cellspacing="0" class="tTable">

  <tr valign="top">
    <td><p class="tt"><a name="1131587"> </a>charEncodingUCS2</p>
    </td>
    <td><p class="tt"><a name="1131589"> </a>charEncodingUCS4</p>
    </td>
  </tr>
  <tr valign="top">
    <td><p class="tt"><a name="1131591"> </a>charEncodingUTF16</p>
    </td>
    <td><p class="tt"><a name="1131593"> </a>charEncodingUTF32</p>
    </td>
  </tr>
  <tr valign="top">
    <td><p class="tt"><a name="1131595"> </a>charEncodingUTF16BE</p>
    </td>
    <td><p class="tt"><a name="1131597"> </a>charEncodingUTF32BE</p>
    </td>
  </tr>
  <tr valign="top">
    <td><p class="tt"><a name="1131599"> </a>charEncodingUTF16LE</p>
    </td>
    <td><p class="tt"><a name="1131601"> </a>charEncodingUTF32LE</p>
    </td>
  </tr>
  <tr valign="top">
    <td><p class="tt"><a name="1131603"> </a>charEncodingUTF8</p>
    </td>
    <td><p class="tt"><a name="1131605"> </a>charEncodingPalmSJIS</p>
    </td>
  </tr>
  <tr valign="top">
    <td><p class="tt"><a name="1131607"> </a>charEncodingAscii</p>
    </td>
    <td><p class="tt"><a name="1131609"> </a>charEncodingISO8859_1</p>
    </td>
  </tr>
  <tr valign="top">
    <td><p class="tt"><a name="1131611"> </a>charEncodingCP1252</p>
    </td>
    <td><p class="tt"><a name="1131613"> </a>charEncodingGSM</p>
    </td>
  </tr>
  <tr valign="top">
    <td><p class="tt"><a name="1131615"> </a>charEncodingShiftJIS</p>
    </td>
    <td><p class="tt"><a name="1131617"> </a>charEncodingCP932</p>
    </td>
  </tr>
  <tr valign="top">
    <td><p class="tt"><a name="1131619"> </a>charEncodingISO2022Jp</p>
    </td>
    <td><p class="tt"><a name="1131621"> </a></p>
    </td>
  </tr>
</table>

</div>


<p class="caption"><a name="1131625"> </a><b>Table 8.4&nbsp;&nbsp;Destination encodings for Shift JIS ROMs<br> </b></p>
<div class="tablediv"><table cellspacing="0" class="tTable">

  <tr valign="top">
    <td><p class="tt"><a name="1131632"> </a>charEncodingUCS2</p>
    </td>
    <td><p class="tt"><a name="1131634"> </a>charEncodingUCS4</p>
    </td>
  </tr>
  <tr valign="top">
    <td><p class="tt"><a name="1131636"> </a>charEncodingUTF16</p>
    </td>
    <td><p class="tt"><a name="1131638"> </a>charEncodingUTF32</p>
    </td>
  </tr>
  <tr valign="top">
    <td><p class="tt"><a name="1131640"> </a>charEncodingUTF16BE</p>
    </td>
    <td><p class="tt"><a name="1131642"> </a>charEncodingUTF32BE</p>
    </td>
  </tr>
  <tr valign="top">
    <td><p class="tt"><a name="1131644"> </a>charEncodingUTF16LE</p>
    </td>
    <td><p class="tt"><a name="1131646"> </a>charEncodingUTF32LE</p>
    </td>
  </tr>
  <tr valign="top">
    <td><p class="tt"><a name="1131648"> </a>charEncodingUTF8</p>
    </td>
    <td><p class="tt"><a name="1131650"> </a>charEncodingPalmSJIS</p>
    </td>
  </tr>
  <tr valign="top">
    <td><p class="tt"><a name="1132003"> </a>charEncodingShiftJIS</p>
    </td>
    <td><p class="tt"><a name="1132005"> </a>charEncodingCP932</p>
    </td>
  </tr>
  <tr valign="top">
    <td><p class="tt"><a name="1132435"> </a>charEncodingGSM</p>
    </td>
    <td><p class="tt"><a name="1132437"> </a>charEncodingISO2022Jp</p>
    </td>
  </tr>
  <tr valign="top">
    <td><p class="tt"><a name="1132527"> </a>charEncodingISO8859_1</p>
    </td>
    <td><p class="tt"><a name="1132529"> </a>charEncodingCP1252</p>
    </td>
  </tr>
  <tr valign="top">
    <td><p class="tt"><a name="1132536"> </a>charEncodingAscii</p>
    </td>
    <td><p class="tt"><a name="1132538"> </a></p>
    </td>
  </tr>
</table>

</div>


<p class="caption"><a name="1134059"> </a><b>Table 8.5&nbsp;&nbsp;Source encodings for GB ROMs </b></p>
<div class="tablediv"><table cellspacing="0" class="tTable">

  <tr valign="top">
    <td><p class="tt"><a name="1134063"> </a>charEncodingUCS2</p>
    </td>
    <td><p class="tt"><a name="1134065"> </a>charEncodingUTF8</p>
    </td>
  </tr>
  <tr valign="top">
    <td><p class="tt"><a name="1134067"> </a>charEncodingUTF16</p>
    </td>
    <td><p class="tt"><a name="1134069"> </a>charEncodingUTF16LE</p>
    </td>
  </tr>
  <tr valign="top">
    <td><p class="tt"><a name="1134071"> </a>charEncodingUTF16BE</p>
    </td>
    <td><p class="tt"><a name="1134073"> </a>charEncodingUTF32</p>
    </td>
  </tr>
  <tr valign="top">
    <td><p class="tt"><a name="1134075"> </a>charEncodingUTF32BE</p>
    </td>
    <td><p class="tt"><a name="1134077"> </a>charEncodingUTF32LE</p>
    </td>
  </tr>
  <tr valign="top">
    <td><p class="tt"><a name="1134079"> </a>charEncodingUCS4</p>
    </td>
    <td><p class="tt"><a name="1134081"> </a>charEncodingPalmGB</p>
    </td>
  </tr>
  <tr valign="top">
    <td><p class="tt"><a name="1134083"> </a>charEncodingGB2312</p>
    </td>
    <td><p class="tt"><a name="1134085"> </a>charEncodingGBK</p>
    </td>
  </tr>
  <tr valign="top">
    <td><p class="tt"><a name="1134087"> </a>charEncodingISO2022CN</p>
    </td>
    <td><p class="tt"><a name="1134089"> </a>charEncodingBig5</p>
    </td>
  </tr>
  <tr valign="top">
    <td><p class="tt"><a name="1134091"> </a>charEncodingBig5_HKSCS</p>
    </td>
    <td><p class="tt"><a name="1134093"> </a>charEncodingAscii</p>
    </td>
  </tr>
  <tr valign="top">
    <td><p class="tt"><a name="1134095"> </a>charEncodingCP1252</p>
    </td>
    <td><p class="tt"><a name="1134097"> </a>charEncodingISO8859_1</p>
    </td>
  </tr>
  <tr valign="top">
    <td><p class="tt"><a name="1134099"> </a>charEncodingGSM</p>
    </td>
    <td><p class="tt"><a name="1134101"> </a></p>
    </td>
  </tr>
</table>

</div>


<p class="caption"><a name="1134107"> </a><b>Table 8.6&nbsp;&nbsp;Destination encodings for GB ROMs </b></p>
<div class="tablediv"><table cellspacing="0" class="tTable">

  <tr valign="top">
    <td><p class="tt"><a name="1134112"> </a>charEncodingUCS2</p>
    </td>
    <td><p class="tt"><a name="1134114"> </a>charEncodingUTF8</p>
    </td>
  </tr>
  <tr valign="top">
    <td><p class="tt"><a name="1134116"> </a>charEncodingUTF16</p>
    </td>
    <td><p class="tt"><a name="1134118"> </a>charEncodingUTF16LE</p>
    </td>
  </tr>
  <tr valign="top">
    <td><p class="tt"><a name="1134120"> </a>charEncodingUTF16BE</p>
    </td>
    <td><p class="tt"><a name="1134122"> </a>charEncodingUTF32</p>
    </td>
  </tr>
  <tr valign="top">
    <td><p class="tt"><a name="1134124"> </a>charEncodingUTF32BE</p>
    </td>
    <td><p class="tt"><a name="1134126"> </a>charEncodingUTF32LE</p>
    </td>
  </tr>
  <tr valign="top">
    <td><p class="tt"><a name="1134128"> </a>charEncodingUCS4</p>
    </td>
    <td><p class="tt"><a name="1134130"> </a>charEncodingPalmGB</p>
    </td>
  </tr>
  <tr valign="top">
    <td><p class="tt"><a name="1134132"> </a>charEncodingGB2312</p>
    </td>
    <td><p class="tt"><a name="1134134"> </a>charEncodingGBK</p>
    </td>
  </tr>
  <tr valign="top">
    <td><p class="tt"><a name="1134136"> </a>charEncodingISO2022CN</p>
    </td>
    <td><p class="tt"><a name="1134138"> </a>charEncodingAscii</p>
    </td>
  </tr>
  <tr valign="top">
    <td><p class="tt"><a name="1134140"> </a>charEncodingISO8859_1</p>
    </td>
    <td><p class="tt"><a name="1134142"> </a>charEncodingGSM</p>
    </td>
  </tr>
</table>

</div>


<h3 class="hbH3">
  <a name="1131659"> </a>TxtEncodingName Function <a href="#1044699"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="1027734"> </a>Purpose 
</h4>

<p><a name="1080544"> </a>Obtains a character encoding's name. </p>
<h4>
  <a name="1027739"> </a>Declared In 
</h4>
<code>TextMgr.h<a name="1027741"> </a></code><h4>
  <a name="1027744"> </a>Prototype 
</h4>
<pre class="proto"><a name="1027746"></a>const char *TxtEncodingName (
   CharEncodingType <code class="par">iEncoding</code>
)
</pre>
<h4>
  <a name="1027826"> </a>Parameters 
</h4>

<dl>
<dt><a name="1027828"> </a><code>&rarr;  <i>iEncoding</i></code></dt>
<dd><a name="1080555"> </a>One of the <a href="TextMgr.html#995858"><code>CharEncodingType</code></a> values, indicating a character encoding. </dd>

</dl>
<h4>
  <a name="1027833"> </a>Returns 
</h4>

<p><a name="1121724"> </a>A constant string containing the name of the encoding. </p>
<h4>
  <a name="1121725"> </a>Comments 
</h4>

<p><a name="1080579"> </a>Use this function to obtain the official name of the character encoding, suitable to pass to an Internet application or any other application that requires the character encoding's name to be passed along with the data.</p>
<h4>
  <a name="1027847"> </a>See Also 
</h4>

<p><a name="1080590"> </a><a href="TextMgr.html#1034702"><code>TxtNameToEncoding()</code></a></p>

<h3 class="hbH3">
  <a name="1027900"> </a>TxtFindString Function <a href="#1044699"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="1027976"> </a>Purpose 
</h4>

<p><a name="1080693"> </a>Performs a case-insensitive search for a string in another string. </p>
<h4>
  <a name="1028231"> </a>Declared In 
</h4>
<code>TextMgr.h<a name="1028279"> </a></code><h4>
  <a name="1028336"> </a>Prototype 
</h4>
<pre class="proto"><a name="1028400"></a>Boolean TxtFindString (
   const char <code class="par">*iSrcStringP</code>,
   const char <code class="par">*iTargetStringP</code>,
   size_t <code class="par">*oFoundPos</code>,
   size_t <code class="par">*oFoundLen</code>
)
</pre>
<h4>
  <a name="1028505"> </a>Parameters 
</h4>

<dl>
<dt><a name="1028577"> </a><code>&rarr;  <i>iSrcStringP</i></code></dt>
<dd><a name="1080701"> </a>The string to be searched. </dd>

<dt><a name="1121734"> </a><code>&rarr;  <i>iTargetStringP</i></code></dt>
<dd><a name="1121735"> </a>Prepared version of the string to be found. This string should either be passed directly from the <code>strToFind</code> field in the <a href="Find.html#1007141"><code>sysAppLaunchCmdFind</code></a> launch code's parameter block or it should be prepared using the function <a href="TextMgr.html#1036841"><code>TxtPrepFindString()</code></a>.</dd>

<dt><a name="1028779"> </a><code>&larr;  <i>oFoundPos</i></code></dt>
<dd><a name="1080742"> </a>Pointer to the offset of the match in <span style="color: #000000;  font-family: Courier; font-style: oblique; font-weight: normal; text-decoration: none; text-transform: none; vertical-align: baseline">iSrcStringP</span>. </dd>

<dt><a name="1028826"> </a><code>&larr;  <i>oFoundLen</i></code></dt>
<dd><a name="1080758"> </a>Pointer to the length in bytes of the matching text. </dd>

</dl>
<h4>
  <a name="1028830"> </a>Returns 
</h4>

<p><a name="1080847"> </a><code>true</code> if the function finds <span style="color: #000000;  font-family: Courier; font-style: oblique; font-weight: normal; text-decoration: none; text-transform: none; vertical-align: baseline">iTargetStringP</span> within <span style="color: #000000;  font-family: Courier; font-style: oblique; font-weight: normal; text-decoration: none; text-transform: none; vertical-align: baseline">iSrcStringP</span>; <code>false</code> otherwise. </p>

<p><a name="1080848"> </a>If found, the values pointed to by the <span style="color: #000000;  font-family: Courier; font-style: oblique; font-weight: normal; text-decoration: none; text-transform: none; vertical-align: baseline">oFoundPos</span> and <span style="color: #000000;  font-family: Courier; font-style: oblique; font-weight: normal; text-decoration: none; text-transform: none; vertical-align: baseline">oFoundLen</span> parameters are set to the starting offset and the length of the matching text. If not found, the values pointed to by <span style="color: #000000;  font-family: Courier; font-style: oblique; font-weight: normal; text-decoration: none; text-transform: none; vertical-align: baseline">oFoundPos</span> and <span style="color: #000000;  font-family: Courier; font-style: oblique; font-weight: normal; text-decoration: none; text-transform: none; vertical-align: baseline">oFoundLen</span> are set to 0. </p>

<p><a name="1080849"> </a>The search that <code>TxtFindString()</code> performs is locale-dependent. On most ROMs with Latin-based encodings, <code>TxtFindString()</code> returns <code>true</code> only if the string is at the beginning of a word. On Shift JIS encoded ROMs, <code>TxtFindString()</code> returns <code>true</code> if the string is located anywhere in the word. </p>

<p><a name="1080858"> </a>You must make sure that the parameters <span style="color: #000000;  font-family: Courier; font-style: oblique; font-weight: normal; text-decoration: none; text-transform: none; vertical-align: baseline">iSrcStringP</span> and <span style="color: #000000;  font-family: Courier; font-style: oblique; font-weight: normal; text-decoration: none; text-transform: none; vertical-align: baseline">iTargetStringP</span> point to the start of a valid character. That is, they must point to the first byte of a multi-byte character, or they must point to a single-byte character; if they don't, results are unpredictable. </p>
<h4>
  <a name="1080986"> </a>See Also 
</h4>

<p><a name="1080990"> </a><a href="TextMgr.html#1008102"><code>TxtCaselessCompare()</code></a></p>

<h3 class="hbH3">
  <a name="1028845"> </a>TxtGetChar Function <a href="#1044699"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="1028850"> </a>Purpose 
</h4>

<p><a name="1081067"> </a>Retrieves the character starting at the specified offset within a text buffer. </p>
<h4>
  <a name="1028880"> </a>Declared In 
</h4>
<code>TextMgr.h<a name="1028882"> </a></code><h4>
  <a name="1028885"> </a>Prototype 
</h4>
<pre class="proto"><a name="1028887"></a>wchar32_t TxtGetChar (
   const char <code class="par">*iTextP</code>,
   size_t <code class="par">iOffset</code>
)
</pre>
<h4>
  <a name="1028894"> </a>Parameters 
</h4>

<dl>
<dt><a name="1028896"> </a><code>&rarr;  <i>iTextP</i></code></dt>
<dd><a name="1081133"> </a>Pointer to the text buffer to be searched. </dd>

<dt><a name="1028924"> </a><code>&rarr;  <i>iOffset</i></code></dt>
<dd><a name="1081281"> </a>A valid offset into the buffer <span style="color: #000000;  font-family: Courier; font-style: oblique; font-weight: normal; text-decoration: none; text-transform: none; vertical-align: baseline">iTextP</span>. This offset must point to an inter-character boundary. </dd>

</dl>
<h4>
  <a name="1029131"> </a>Returns 
</h4>

<p><a name="1081321"> </a>The character at <span style="color: #000000;  font-family: Courier; font-style: oblique; font-weight: normal; text-decoration: none; text-transform: none; vertical-align: baseline">iOffset</span> in <span style="color: #000000;  font-family: Courier; font-style: oblique; font-weight: normal; text-decoration: none; text-transform: none; vertical-align: baseline">iTextP</span>. </p>
<h4>
  <a name="1081322"> </a>Comments 
</h4>

<p><a name="1081323"> </a>You must make sure that the parameter <span style="color: #000000;  font-family: Courier; font-style: oblique; font-weight: normal; text-decoration: none; text-transform: none; vertical-align: baseline">iTextP</span> points to the start of a valid character. That is, it must point to the first byte of a multi-byte character or it must point to a single-byte character; if it doesn't, results are unpredictable. </p>
<h4>
  <a name="1029437"> </a>See Also 
</h4>

<p><a name="1081357"> </a><a href="TextMgr.html#1030398"><code>TxtGetNextChar()</code></a>, <a href="TextMgr.html#1039340"><code>TxtSetNextChar()</code></a></p>

<h3 class="hbH3">
  <a name="1029614"> </a>TxtGetEncodingFlags Function <a href="#1044699"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="1029676"> </a>Purpose 
</h4>

<p><a name="1121784"> </a>Returns the attributes of a particular character encoding. </p>
<h4>
  <a name="1029749"> </a>Declared In 
</h4>
<code>TextMgr.h<a name="1029781"> </a></code><h4>
  <a name="1029822"> </a>Prototype 
</h4>
<pre class="proto"><a name="1029870"></a>uint32_t TxtGetEncodingFlags (
   CharEncodingType <code class="par">iEncoding</code>
)
</pre>
<h4>
  <a name="1029951"> </a>Parameters 
</h4>

<dl>
<dt><a name="1030007"> </a><code>&rarr;  <i>iEncoding</i></code></dt>
<dd><a name="1030131"> </a>A <a href="TextMgr.html#995858"><code>CharEncodingType</code></a> value specifying a character encoding. </dd>

</dl>
<h4>
  <a name="1030141"> </a>Returns 
</h4>

<p><a name="1030273"> </a>An unsigned integer with one or more of the <a href="TextMgr.html#1104428">Character Encoding Attributes</a> flags set. </p>

<h3 class="hbH3">
  <a name="1030398"> </a>TxtGetNextChar Function <a href="#1044699"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="1030403"> </a>Purpose 
</h4>

<p><a name="1081386"> </a>Retrieves the character starting at the specified offset within a text buffer. </p>
<h4>
  <a name="1030408"> </a>Declared In 
</h4>
<code>TextMgr.h<a name="1030410"> </a></code><h4>
  <a name="1030413"> </a>Prototype 
</h4>
<pre class="proto"><a name="1030415"></a>size_t TxtGetNextChar (
   const char <code class="par">*iTextP</code>,
   size_t <code class="par">iOffset</code>,
   wchar32_t <code class="par">*oChar</code>
)
</pre>
<h4>
  <a name="1030418"> </a>Parameters 
</h4>

<dl>
<dt><a name="1030420"> </a><code>&rarr;  <i>iTextP</i></code></dt>
<dd><a name="1081400"> </a>Pointer to the text buffer to be searched. </dd>

<dt><a name="1030502"> </a><code>&rarr;  <i>iOffset</i></code></dt>
<dd><a name="1081444"> </a>A valid offset into the buffer <span style="color: #000000;  font-family: Courier; font-style: oblique; font-weight: normal; text-decoration: none; text-transform: none; vertical-align: baseline">iTextP</span>. This offset must point to an inter-character boundary. </dd>

<dt><a name="1081452"> </a><code>&larr;  <i>oChar</i></code></dt>
<dd><a name="1081453"> </a>The character at <span style="color: #000000;  font-family: Courier; font-style: oblique; font-weight: normal; text-decoration: none; text-transform: none; vertical-align: baseline">iOffset</span> in <span style="color: #000000;  font-family: Courier; font-style: oblique; font-weight: normal; text-decoration: none; text-transform: none; vertical-align: baseline">iTextP</span>. Pass <code>NULL</code> for this parameter if you don't need the character returned. </dd>

</dl>
<h4>
  <a name="1030514"> </a>Returns 
</h4>

<p><a name="1081461"> </a>The size in bytes of the character at <span style="color: #000000;  font-family: Courier; font-style: oblique; font-weight: normal; text-decoration: none; text-transform: none; vertical-align: baseline">iOffset</span>. If <span style="color: #000000;  font-family: Courier; font-style: oblique; font-weight: normal; text-decoration: none; text-transform: none; vertical-align: baseline">oChar</span> is not <code>NULL</code> upon entry, it points to the character at <span style="color: #000000;  font-family: Courier; font-style: oblique; font-weight: normal; text-decoration: none; text-transform: none; vertical-align: baseline">iOffset</span> upon return.</p>
<h4>
  <a name="1122875"> </a>Comments 
</h4>

<p><a name="1081482"> </a>You must make sure that the parameter <span style="color: #000000;  font-family: Courier; font-style: oblique; font-weight: normal; text-decoration: none; text-transform: none; vertical-align: baseline">iTextP</span> points to the start of a valid character. That is, it must point to the first byte of a multi-byte character or it must point to a single-byte character; if it doesn't, results are unpredictable. </p>
<h4>
  <a name="1123287"> </a>Example 
</h4>

<p><a name="1123353"> </a>You can use this function to iterate through a text buffer character-by-character in this way: </p>

<div class="CodeRule"><hr></div><pre class="CodeBlock">
size_t i = 0;<a name="1123288"> </a>
wchar32_t ch;<a name="1123289"> </a>
while (i &lt; bufferLength) {<a name="1123408"> </a>
    i += TxtGetNextChar(buffer, i, &amp;ch);<a name="1123453"> </a>
    //do something with ch.<a name="1123501"> </a>
}<a name="1123502"> </a>
</pre><div class="CodeRule"><hr></div>

<h4>
  <a name="1081563"> </a>See Also 
</h4>

<p><a name="1081573"> </a><a href="TextMgr.html#1028845"><code>TxtGetChar()</code></a>, <a href="TextMgr.html#1031665"><code>TxtGetPreviousChar()</code></a>, <a href="TextMgr.html#1039340"><code>TxtSetNextChar()</code></a></p>

<h3 class="hbH3">
  <a name="1031665"> </a>TxtGetPreviousChar Function <a href="#1044699"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="1031735"> </a>Purpose 
</h4>

<p><a name="1081592"> </a>Retrieves the character before the specified offset within a text buffer. </p>
<h4>
  <a name="1031824"> </a>Declared In 
</h4>
<code>TextMgr.h<a name="1031864"> </a></code><h4>
  <a name="1031913"> </a>Prototype 
</h4>
<pre class="proto"><a name="1031969"></a>size_t TxtGetPreviousChar (
   const char <code class="par">*iTextP</code>,
   size_t <code class="par">iOffset</code>,
   wchar32_t <code class="par">*oChar</code>
)
</pre>
<h4>
  <a name="1032058"> </a>Parameters 
</h4>

<dl>
<dt><a name="1032122"> </a><code>&rarr;  <i>iTextP</i></code></dt>
<dd><a name="1081614"> </a>Pointer to the text buffer to be searched. </dd>

<dt><a name="1032276"> </a><code>&rarr;  <i>iOffset</i></code></dt>
<dd><a name="1081678"> </a>A valid offset into the buffer <span style="color: #000000;  font-family: Courier; font-style: oblique; font-weight: normal; text-decoration: none; text-transform: none; vertical-align: baseline">iTextP</span>. This offset must point to an inter-character boundary. </dd>

<dt><a name="1032296"> </a><code>&larr;  <i>oChar</i></code></dt>
<dd><a name="1081682"> </a>The character immediately preceding <span style="color: #000000;  font-family: Courier; font-style: oblique; font-weight: normal; text-decoration: none; text-transform: none; vertical-align: baseline">iOffset</span> in <span style="color: #000000;  font-family: Courier; font-style: oblique; font-weight: normal; text-decoration: none; text-transform: none; vertical-align: baseline">iTextP</span>. Pass <code>NULL</code> for this parameter if you don't need the character returned. </dd>

</dl>
<h4>
  <a name="1081777"> </a>Returns 
</h4>

<p><a name="1082255"> </a>The size in bytes of the character preceding <span style="color: #000000;  font-family: Courier; font-style: oblique; font-weight: normal; text-decoration: none; text-transform: none; vertical-align: baseline">iOffset</span> in <span style="color: #000000;  font-family: Courier; font-style: oblique; font-weight: normal; text-decoration: none; text-transform: none; vertical-align: baseline">iTextP</span>. If <span style="color: #000000;  font-family: Courier; font-style: oblique; font-weight: normal; text-decoration: none; text-transform: none; vertical-align: baseline">oChar</span> is not <code>NULL</code> upon entry, then it points to the character preceding <span style="color: #000000;  font-family: Courier; font-style: oblique; font-weight: normal; text-decoration: none; text-transform: none; vertical-align: baseline">iOffset</span> upon return. Returns 0 if <span style="color: #000000;  font-family: Courier; font-style: oblique; font-weight: normal; text-decoration: none; text-transform: none; vertical-align: baseline">iOffset</span> is at the start of the buffer (that is, <span style="color: #000000;  font-family: Courier; font-style: oblique; font-weight: normal; text-decoration: none; text-transform: none; vertical-align: baseline">iOffset</span> is 0). </p>
<h4>
  <a name="1123967"> </a>Comments 
</h4>

<p><a name="1082269"> </a>This function is often slower to use than <a href="TextMgr.html#1030398"><code>TxtGetNextChar()</code></a> because it must determine the appropriate character boundaries if the byte immediately before the offset is valid in more than one location (start, middle, or end) of a multi-byte character. To do this, it must work backwards toward the beginning of the string until it finds an unambiguous byte.</p>

<p><a name="1082270"> </a>You must make sure that the parameter <span style="color: #000000;  font-family: Courier; font-style: oblique; font-weight: normal; text-decoration: none; text-transform: none; vertical-align: baseline">iTextP</span> points to the start of a valid character. That is, it must point to the first byte of a multi-byte character or it must point to a single-byte character; if it doesn't, results are unpredictable. </p>
<h4>
  <a name="1123904"> </a>Example 
</h4>

<p><a name="1123905"> </a>You can use this function to iterate through a text buffer character-by-character in this way: </p>

<div class="CodeRule"><hr></div><pre class="CodeBlock">
wchar32_t ch;<a name="1123906"> </a>
// Find the start of the character containing the last byte. <a name="1123907"> </a>
TxtCharBounds (buffer, bufferLength - 1, &amp;start, &amp;end);<a name="1123908"> </a>
i = start;<a name="1123909"> </a>
while (i &gt; 0) {<a name="1123910"> </a>
    i -= TxtGetPreviousChar(buffer, i, &amp;ch);<a name="1123911"> </a>
    //do something with ch.<a name="1123912"> </a>
}<a name="1123913"> </a>
</pre><div class="CodeRule"><hr></div>


<h3 class="hbH3">
  <a name="1081784"> </a>TxtGetTruncationOffset Function <a href="#1044699"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="1081786"> </a>Purpose 
</h4>

<p><a name="1082338"> </a>Returns the appropriate byte position for truncating a text buffer such that it is at most a specified number of bytes long. </p>
<h4>
  <a name="1032426"> </a>Declared In 
</h4>
<code>TextMgr.h<a name="1032428"> </a></code><h4>
  <a name="1032483"> </a>Prototype 
</h4>
<pre class="proto"><a name="1032510"></a>size_t TxtGetTruncationOffset (
   const char <code class="par">*iTextP</code>,
   size_t <code class="par">iOffset</code>
)
</pre>
<h4>
  <a name="1032513"> </a>Parameters 
</h4>

<dl>
<dt><a name="1032515"> </a><code>&rarr;  <i>iTextP</i></code></dt>
<dd><a name="1082358"> </a>Pointer to a text buffer. </dd>

<dt><a name="1032532"> </a><code>&rarr;  <i>iOffset</i></code></dt>
<dd><a name="1082394"> </a>An offset into the buffer <span style="color: #000000;  font-family: Courier; font-style: oblique; font-weight: normal; text-decoration: none; text-transform: none; vertical-align: baseline">iTextP</span>. </dd>

</dl>
<h4>
  <a name="1032536"> </a>Returns 
</h4>

<p><a name="1082414"> </a>The appropriate byte offset for truncating <span style="color: #000000;  font-family: Courier; font-style: oblique; font-weight: normal; text-decoration: none; text-transform: none; vertical-align: baseline">iTextP</span> at a valid inter-character boundary. The return value may be less than or equal to <span style="color: #000000;  font-family: Courier; font-style: oblique; font-weight: normal; text-decoration: none; text-transform: none; vertical-align: baseline">iOffset</span>. </p>
<h4>
  <a name="1082415"> </a>Comments 
</h4>

<p><a name="1082416"> </a>You must make sure that the parameter <span style="color: #000000;  font-family: Courier; font-style: oblique; font-weight: normal; text-decoration: none; text-transform: none; vertical-align: baseline">iTextP</span> points to the start of a valid character. That is, it must point to the first byte of a multi-byte character or it must point to a single-byte character; if it doesn't, results are unpredictable. </p>

<h3 class="hbH3">
  <a name="1033687"> </a>TxtGetWordWrapOffset Function <a href="#1044699"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="1033757"> </a>Purpose 
</h4>

<p><a name="1082426"> </a>Locates an appropriate place for a line break in a text buffer. </p>
<h4>
  <a name="1033846"> </a>Declared In 
</h4>
<code>TextMgr.h<a name="1033886"> </a></code><h4>
  <a name="1033935"> </a>Prototype 
</h4>
<pre class="proto"><a name="1033991"></a>size_t TxtGetWordWrapOffset (
   const char <code class="par">*iTextP</code>,
   size_t <code class="par">iOffset</code>
)
</pre>
<h4>
  <a name="1034080"> </a>Parameters 
</h4>

<dl>
<dt><a name="1034144"> </a><code>&rarr;  <i>iTextP</i></code></dt>
<dd><a name="1082434"> </a>Pointer to a text buffer. </dd>

<dt><a name="1034298"> </a><code>&rarr;  <i>iOffset</i></code></dt>
<dd><a name="1082446"> </a>A valid offset where the search should begin. The search is performed backward starting from this offset. </dd>

</dl>
<h4>
  <a name="1034318"> </a>Returns 
</h4>

<p><a name="1082454"> </a>The offset of a character that can begin on a new line (typically, the beginning of the word that contains <span style="color: #000000;  font-family: Courier; font-style: oblique; font-weight: normal; text-decoration: none; text-transform: none; vertical-align: baseline">iOffset</span> or last word before <span style="color: #000000;  font-family: Courier; font-style: oblique; font-weight: normal; text-decoration: none; text-transform: none; vertical-align: baseline">iOffset</span>). If an appropriate break could not be found, returns <span style="color: #000000;  font-family: Courier; font-style: oblique; font-weight: normal; text-decoration: none; text-transform: none; vertical-align: baseline">iOffset</span>. </p>
<h4>
  <a name="1034485"> </a>Comments 
</h4>

<p><a name="1082468"> </a>The <a href="../User_Interface/UI_Font.html#996319"><code>FntWordWrap()</code></a> function calls <code>TxtGetWordWrapOffset()</code> to locate an appropriate place to break the text. The returned offset points to the character that should begin the next line. </p>

<p><a name="1082469"> </a>This function starts at <span style="color: #000000;  font-family: Courier; font-style: oblique; font-weight: normal; text-decoration: none; text-transform: none; vertical-align: baseline">iOffset</span> and works backward until it finds a character that typically occurs between words (for example, white space or punctuation). Then it moves forward until it locates the character that begins a word (typically, a letter or number). Note that this function may return an offset value that is greater than the one passed in if the offset passed in occurs immediately before white space or in the middle of white space. </p>

<h3 class="hbH3">
  <a name="1034527"> </a>TxtMaxEncoding Function <a href="#1044699"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="1034532"> </a>Purpose 
</h4>

<p><a name="1082553"> </a>Returns the higher of two encodings.</p>
<h4>
  <a name="1034537"> </a>Declared In 
</h4>
<code>TextMgr.h<a name="1034539"> </a></code><h4>
  <a name="1034542"> </a>Prototype 
</h4>
<pre class="proto"><a name="1034544"></a>CharEncodingType TxtMaxEncoding (
   CharEncodingType <code class="par">a</code>,
   CharEncodingType <code class="par">b</code>
)
</pre>
<h4>
  <a name="1034547"> </a>Parameters 
</h4>

<dl>
<dt><a name="1034549"> </a><code>&rarr;  <i>a</i></code></dt>
<dd><a name="1082601"> </a>A <a href="TextMgr.html#995858"><code>CharEncodingType</code></a> to compare. </dd>

<dt><a name="1034631"> </a><code>&rarr;  <i>b</i></code></dt>
<dd><a name="1082649"> </a>Another <code>CharEncodingType</code> to compare. </dd>

</dl>
<h4>
  <a name="1082650"> </a>Returns 
</h4>

<p><a name="1082651"> </a>The higher of <code class="par">a</code> or <code class="par">b</code>. One character encoding is higher than another if it is more specific. For example code page 1252 is "higher" than ISO 8859-1 because it represents more characters than ISO 8859-1. </p>
<h4>
  <a name="1082652"> </a>Comments 
</h4>

<p><a name="1082656"> </a>This function is used by <a href="TextMgr.html#1039568"><code>TxtStrEncoding()</code></a> to determine the encoding required for a string. </p>
<h4>
  <a name="1082660"> </a>See Also 
</h4>

<p><a name="1082667"> </a><a href="TextMgr.html#1011389"><code>TxtCharEncoding()</code></a>, <a href="TextMgr.html#995858"><code>CharEncodingType</code></a> </p>

<h3 class="hbH3">
  <a name="1034702"> </a>TxtNameToEncoding Function <a href="#1044699"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="1034778"> </a>Purpose 
</h4>

<p><a name="1082699"> </a>Returns an encoding's constant given its name. </p>
<h4>
  <a name="1035033"> </a>Declared In 
</h4>
<code>TextMgr.h<a name="1035081"> </a></code><h4>
  <a name="1035138"> </a>Prototype 
</h4>
<pre class="proto"><a name="1035202"></a>CharEncodingType TxtNameToEncoding (
   const char <code class="par">*iEncodingName</code>
)
</pre>
<h4>
  <a name="1035311"> </a>Parameters 
</h4>

<dl>
<dt><a name="1082727"> </a><code>&rarr;  <i>iEncodingName</i></code></dt>
<dd><a name="1082728"> </a>One of the string constants containing the official name of an encoding. You can find a list of official names at this URL: <code>http://www.iana.org/assignments/character-sets</code>. </dd>

</dl>
<h4>
  <a name="1082729"> </a>Returns 
</h4>

<p><a name="1082733"> </a>One of the <a href="TextMgr.html#995858"><code>CharEncodingType</code></a> constants. Returns <code>charEncodingUnknown</code> if the specified encoding could not be found. </p>
<h4>
  <a name="1082735"> </a>Comments 
</h4>

<p><a name="1082736"> </a>Use this function to convert a character encoding's name as received from an Internet application into the character encoding constant that some Text Manager functions require. </p>

<p><a name="1082737"> </a>This function properly converts aliases for a character encoding. For example, passing the strings "us-ascii", "ASCII", "cp367", and "IBM367" all return <code>charEncodingAscii</code>.</p>

<p><a name="1082738"> </a>All locales can access the Text Manager's character set list, which contains the standard set of aliases for the locales that Palm OS supports. Each locale may add its own aliases to the list as well. For example, a device with the Shift JIS encoding might add its own set of aliases, which would be unknown in other locales. </p>
<h4>
  <a name="1082765"> </a>See Also 
</h4>

<p><a name="1082769"> </a><a href="TextMgr.html#1131659"><code>TxtEncodingName()</code></a></p>

<h3 class="hbH3">
  <a name="1035928"> </a>TxtNextCharSize Macro <a href="#1044699"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="1035946"> </a>Purpose 
</h4>

<p><a name="1082797"> </a>Returns the size of the character starting at the specified offset within a text buffer. </p>
<h4>
  <a name="1035975"> </a>Declared In 
</h4>
<code>TextMgr.h<a name="1035977"> </a></code><h4>
  <a name="1035980"> </a>Prototype 
</h4>
<pre class="proto"><a name="1035982"></a>#define TxtNextCharSize (
   <code class="par">iTextP</code>,
   <code class="par"> iOffset</code>
)
</pre>
<h4>
  <a name="1035985"> </a>Parameters 
</h4>

<dl>
<dt><a name="1035987"> </a><code>&rarr;  <i>iTextP</i></code></dt>
<dd><a name="1082808"> </a>Pointer to the text buffer to be searched. </dd>

<dt><a name="1035992"> </a><code>&rarr;  <i>iOffset</i></code></dt>
<dd><a name="1082861"> </a>A valid offset into the buffer <span style="color: #000000;  font-family: Courier; font-style: oblique; font-weight: normal; text-decoration: none; text-transform: none; vertical-align: baseline">iTextP</span>. This offset must point to an inter-character boundary. </dd>

</dl>
<h4>
  <a name="1082862"> </a>Returns 
</h4>

<p><a name="1082863"> </a>The size in bytes of the character at <span style="color: #000000;  font-family: Courier; font-style: oblique; font-weight: normal; text-decoration: none; text-transform: none; vertical-align: baseline">iOffset</span>. </p>
<h4>
  <a name="1082864"> </a>Comments 
</h4>

<p><a name="1082865"> </a>You must make sure that the parameter <span style="color: #000000;  font-family: Courier; font-style: oblique; font-weight: normal; text-decoration: none; text-transform: none; vertical-align: baseline">iTextP</span> points to the start of a valid character. That is, it must point to the first byte of a multi-byte character or it must point to a single-byte character; if it doesn't, results are unpredictable. </p>
<h4>
  <a name="1082906"> </a>See Also 
</h4>

<p><a name="1082910"> </a><a href="TextMgr.html#1030398"><code>TxtGetNextChar()</code></a> </p>

<h3 class="hbH3">
  <a name="1036088"> </a>TxtParamString Function <a href="#1044699"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="1036097"> </a>Purpose 
</h4>

<p><a name="1082926"> </a>Replaces substrings within a string with the specified values.</p>
<h4>
  <a name="1036102"> </a>Declared In 
</h4>
<code>TextMgr.h<a name="1036104"> </a></code><h4>
  <a name="1036155"> </a>Prototype 
</h4>
<pre class="proto"><a name="1036180"></a>char *TxtParamString (
   const char <code class="par">*inTemplate</code>,
   const char <code class="par">*param0</code>,
   const char <code class="par">*param1</code>,
   const char <code class="par">*param2</code>,
   const char <code class="par">*param3</code>
)
</pre>
<h4>
  <a name="1036183"> </a>Parameters 
</h4>

<dl>
<dt><a name="1082942"> </a><code>&rarr;  <i>inTemplate</i></code></dt>
<dd><a name="1082943"> </a>The string containing the substrings to replace. </dd>

<dt><a name="1082944"> </a><code>&rarr;  <i>param0</i></code></dt>
<dd><a name="1082945"> </a>String to replace ^0 with or <code>NULL</code>. </dd>

<dt><a name="1082946"> </a><code>&rarr;  <i>param1</i></code></dt>
<dd><a name="1082947"> </a>String to replace ^1 with or <code>NULL</code>. </dd>

<dt><a name="1082948"> </a><code>&rarr;  <i>param2</i></code></dt>
<dd><a name="1082949"> </a>String to replace ^2 with or <code>NULL</code>. </dd>

<dt><a name="1082950"> </a><code>&rarr;  <i>param3</i></code></dt>
<dd><a name="1082951"> </a>String to replace ^3 with or <code>NULL</code>. </dd>

</dl>
<h4>
  <a name="1082952"> </a>Returns 
</h4>

<p><a name="1082953"> </a>A pointer to a locked relocatable chunk in the dynamic heap that contains the appropriate substitutions.</p>
<h4>
  <a name="1082954"> </a>Comments 
</h4>

<p><a name="1082955"> </a>This function searches <code class="par">inTemplate</code> for occurrences of the sequences ^0, ^1, ^2, and ^3. When it finds these, it replaces them with the corresponding string passed to this function. Multiple instances of each sequence will be replaced. </p>

<p><a name="1082956"> </a>The replacement strings can also contain the substitution strings, provided they refer to a later parameter. That is, the <code class="par">param0</code> string can have references to ^1, ^2, and ^3, the <code class="par">param1</code> string can have references to ^2 and ^3, and the <code class="par">param2</code> string can have references to ^3. Any other occurrences of the substitution strings in the replacement strings are ignored. For example, if <code class="par">param3</code> is the string "^0", any occurrences of ^3 in <code class="par">inTemplate</code> are replaced with the string "^0". </p>

<p><a name="1082957"> </a>You must make sure that the parameter <code class="par">inTemplate</code> points to the start of a valid character. That is, it must point to the first byte of a multi-byte character or it must point to a single-byte character; if it doesn't, results are unpredictable. </p>

<p><a name="1082958"> </a><code>TxtParamString()</code> allocates space for the returned string in the dynamic heap through a call to <a href="../Memory_Databases_Files/MemoryMgr.html#994503"><code>MemHandleNew()</code></a>, and then returns the result of calling <a href="../Memory_Databases_Files/MemoryMgr.html#994367"><code>MemHandleLock()</code></a> with this handle. Your code is responsible for freeing this memory when it is no longer needed. </p>
<h4>
  <a name="1083009"> </a>See Also 
</h4>

<p><a name="1083016"> </a><a href="TextMgr.html#1038314"><code>TxtReplaceStr()</code></a>, <a href="../User_Interface/UI_Form.html#996096"><code>FrmCustomAlert()</code></a> </p>

<h3 class="hbH3">
  <a name="1036841"> </a>TxtPrepFindString Function <a href="#1044699"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="1036846"> </a>Purpose 
</h4>

<p><a name="1083026"> </a>Prepares a string for use in <a href="TextMgr.html#1027900"><code>TxtFindString()</code></a>. </p>
<h4>
  <a name="1036851"> </a>Declared In 
</h4>
<code>TextMgr.h<a name="1036853"> </a></code><h4>
  <a name="1036908"> </a>Prototype 
</h4>
<pre class="proto"><a name="1036935"></a>size_t TxtPrepFindString (
   const char <code class="par">*iSrcTextP</code>,
   size_t <code class="par">iSrcLen</code>,
   char <code class="par">*oDstTextP</code>,
   size_t <code class="par">iDstSize</code>
)
</pre>
<h4>
  <a name="1036938"> </a>Parameters 
</h4>

<dl>
<dt><a name="1036940"> </a><code>&rarr;  <i>iSrcTextP</i></code></dt>
<dd><a name="1084409"> </a>The text to be searched for. Must not be <code>NULL</code>. </dd>

<dt><a name="1036949"> </a><code>&rarr;  <i>iSrcLen</i></code></dt>
<dd><a name="1036951"> </a>The number of bytes of <code class="par">iSrcTextP</code> to convert. </dd>

<dt><a name="1036976"> </a><code>&larr;  <i>oDstTextP</i></code></dt>
<dd><a name="1084421"> </a>The same text as in <span style="color: #000000;  font-family: Courier; font-style: oblique; font-weight: normal; text-decoration: none; text-transform: none; vertical-align: baseline">iSrcTextP</span> but converted to a suitable format for searching. <span style="color: #000000;  font-family: Courier; font-style: oblique; font-weight: normal; text-decoration: none; text-transform: none; vertical-align: baseline">oDstTextP</span> must not be the same address as <span style="color: #000000;  font-family: Courier; font-style: oblique; font-weight: normal; text-decoration: none; text-transform: none; vertical-align: baseline">iSrcTextP</span>. </dd>

<dt><a name="1037199"> </a><code>&rarr;  <i>iDstSize</i></code></dt>
<dd><a name="1084425"> </a>The length in bytes of the area pointed to by <span style="color: #000000;  font-family: Courier; font-style: oblique; font-weight: normal; text-decoration: none; text-transform: none; vertical-align: baseline">oDstTextP</span>. </dd>

</dl>
<h4>
  <a name="1037267"> </a>Returns 
</h4>

<p><a name="1084429"> </a>The number of bytes from <code class="par">iSrcTextP</code> that were converted. </p>
<h4>
  <a name="1084430"> </a>Comments 
</h4>

<p><a name="1084431"> </a>Use this function to normalize the string to search for before using <code>TxtFindString()</code> to perform a search that is internal to your application. If you are using <code>TxtFindString()</code> in response to the <a href="Find.html#1007141"><code>sysAppLaunchCmdFind</code></a> launch code, the string that the launch code passes in is already properly normalized for the search. </p>

<p><a name="1084445"> </a>This function normalizes the string to be searched for. The method by which a search string is normalized varies depending on the version of Palm OS and the character encoding supported by the device. </p>

<p><a name="1084446"> </a>If necessary to prevent overflow of the destination buffer, not all of <span style="color: #000000;  font-family: Courier; font-style: oblique; font-weight: normal; text-decoration: none; text-transform: none; vertical-align: baseline">iSrcTextP</span> is converted. </p>

<p><a name="1084447"> </a>You must make sure that the parameter <span style="color: #000000;  font-family: Courier; font-style: oblique; font-weight: normal; text-decoration: none; text-transform: none; vertical-align: baseline">iSrcTextP</span> points to the start of a valid character. That is, it must point to the first byte of a multi-byte character or it must point to a single-byte character. If it doesn't, results are unpredictable. </p>

<h3 class="hbH3">
  <a name="1037714"> </a>TxtPreviousCharSize Macro <a href="#1044699"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="1037760"> </a>Purpose 
</h4>

<p><a name="1083082"> </a>Returns the size of the character before the specified offset within a text buffer. </p>
<h4>
  <a name="1037829"> </a>Declared In 
</h4>
<code>TextMgr.h<a name="1037853"> </a></code><h4>
  <a name="1037886"> </a>Prototype 
</h4>
<pre class="proto"><a name="1037926"></a>#define TxtPreviousCharSize (
   <code class="par">iTextP</code>,
   <code class="par"> iOffset</code>
)
</pre>
<h4>
  <a name="1037971"> </a>Parameters 
</h4>

<dl>
<dt><a name="1038019"> </a><code>&rarr;  <i>iTextP</i></code></dt>
<dd><a name="1083086"> </a>Pointer to the text buffer. </dd>

<dt><a name="1038162"> </a><code>&rarr;  <i>iOffset</i></code></dt>
<dd><a name="1083090"> </a>A valid offset into the buffer <span style="color: #000000;  font-family: Courier; font-style: oblique; font-weight: normal; text-decoration: none; text-transform: none; vertical-align: baseline">iTextP</span>. This offset must point to an inter-character boundary. </dd>

</dl>
<h4>
  <a name="1038222"> </a>Returns 
</h4>

<p><a name="1083094"> </a>The size in bytes of the character preceding <span style="color: #000000;  font-family: Courier; font-style: oblique; font-weight: normal; text-decoration: none; text-transform: none; vertical-align: baseline">iOffset</span> in <span style="color: #000000;  font-family: Courier; font-style: oblique; font-weight: normal; text-decoration: none; text-transform: none; vertical-align: baseline">iTextP</span>. Returns 0 if <span style="color: #000000;  font-family: Courier; font-style: oblique; font-weight: normal; text-decoration: none; text-transform: none; vertical-align: baseline">iOffset</span> is at the start of the buffer (that is, <span style="color: #000000;  font-family: Courier; font-style: oblique; font-weight: normal; text-decoration: none; text-transform: none; vertical-align: baseline">iOffset</span> is 0). </p>
<h4>
  <a name="1083095"> </a>Comments 
</h4>

<p><a name="1083096"> </a>You must make sure that the parameter <span style="color: #000000;  font-family: Courier; font-style: oblique; font-weight: normal; text-decoration: none; text-transform: none; vertical-align: baseline">iTextP</span> points to the start of a valid character. That is, it must point to the first byte of a multi-byte character or it must point to a single-byte character; if it doesn't, results are unpredictable. </p>

<p><a name="1083100"> </a>This macro is often slower to use than <a href="TextMgr.html#1035928"><code>TxtNextCharSize()</code></a> because it must determine the appropriate character boundaries if the byte immediately before the offset is valid in more than one location (start, middle, or end) of a multi-byte character. To do this, it must work backwards toward the beginning of the string until it finds an unambiguous byte.</p>
<h4>
  <a name="1038284"> </a>See Also 
</h4>

<p><a name="1083147"> </a><a href="TextMgr.html#1031665"><code>TxtGetPreviousChar()</code></a> </p>

<h3 class="hbH3">
  <a name="1038314"> </a>TxtReplaceStr Function <a href="#1044699"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="1038323"> </a>Purpose 
</h4>

<p><a name="1083181"> </a>Replaces a substring of a given format with another string. </p>
<h4>
  <a name="1038328"> </a>Declared In 
</h4>
<code>TextMgr.h<a name="1038330"> </a></code><h4>
  <a name="1038381"> </a>Prototype 
</h4>
<pre class="proto"><a name="1038406"></a>uint16_t TxtReplaceStr (
   char <code class="par">*iStringP</code>,
   size_t <code class="par">iMaxLen</code>,
   const char <code class="par">*iParamStringP</code>,
   uint16_t <code class="par">iParamNum</code>
)
</pre>
<h4>
  <a name="1038409"> </a>Parameters 
</h4>

<dl>
<dt><a name="1038651"> </a><code>&harr;  <i>iStringP</i></code></dt>
<dd><a name="1083235"> </a>The string in which to perform the replacing. </dd>

<dt><a name="1038849"> </a><code>&rarr;  <i>iMaxLen</i></code></dt>
<dd><a name="1083267"> </a>The maximum length in bytes that <span style="color: #000000;  font-family: Courier; font-style: oblique; font-weight: normal; text-decoration: none; text-transform: none; vertical-align: baseline">iStringP</span> can become. </dd>

<dt><a name="1038909"> </a><code>&rarr;  <i>iParamStringP</i></code></dt>
<dd><a name="1087848"> </a>The string that <code>^</code><code class="par">iParamNum </code>should be replaced with. If <code>NULL</code>, no changes are made. </dd>

<dt><a name="1087849"> </a><code>&rarr;  <i>iParamNum</i></code></dt>
<dd><a name="1083287"> </a>A single-digit number (0 to 9). </dd>

</dl>
<h4>
  <a name="1039001"> </a>Returns 
</h4>

<p><a name="1083295"> </a>The number of occurrences found and replaced. </p>

<p><a name="1083296"> </a>Raises a fatal error message if <span style="color: #000000;  font-family: Courier; font-style: oblique; font-weight: normal; text-decoration: none; text-transform: none; vertical-align: baseline">iParamNum</span> is greater than 9.</p>
<h4>
  <a name="1083297"> </a>Comments 
</h4>

<p><a name="1083298"> </a>This function searches <span style="color: #000000;  font-family: Courier; font-style: oblique; font-weight: normal; text-decoration: none; text-transform: none; vertical-align: baseline">iStringP</span> for occurrences of the string <code>^</code><code class="par">iParamNum,</code> where <code class="par">iParamNum</code> is any digit from 0 to 9. When it finds the string, it replaces it with <span style="color: #000000;  font-family: Courier; font-style: oblique; font-weight: normal; text-decoration: none; text-transform: none; vertical-align: baseline">iParamStringP</span>. Multiple instances are replaced as long as the resulting string doesn't contain more than <span style="color: #000000;  font-family: Courier; font-style: oblique; font-weight: normal; text-decoration: none; text-transform: none; vertical-align: baseline">iMaxLen</span> bytes, not counting the terminating null. </p>

<p><a name="1083299"> </a>You can set the <span style="color: #000000;  font-family: Courier; font-style: oblique; font-weight: normal; text-decoration: none; text-transform: none; vertical-align: baseline">iParamStringP</span> parameter to <code>NULL</code> to determine the required length of <span style="color: #000000;  font-family: Courier; font-style: oblique; font-weight: normal; text-decoration: none; text-transform: none; vertical-align: baseline">iStringP</span> before actually doing the replacing. <code>TxtReplaceStr()</code> returns the number of occurrences it finds of <code>^</code><code class="par">iParamNum</code>. Multiply this value by the length of the <code class="par">iParamStr</code> you intend to use to determine the appropriate length of <span style="color: #000000;  font-family: Courier; font-style: oblique; font-weight: normal; text-decoration: none; text-transform: none; vertical-align: baseline">iStringP</span>. </p>

<p><a name="1083300"> </a>You must make sure that the parameter <span style="color: #000000;  font-family: Courier; font-style: oblique; font-weight: normal; text-decoration: none; text-transform: none; vertical-align: baseline">iStringP</span> points to the start of a valid character. That is, it must point to the first byte of a multi-byte character or it must point to a single-byte character; if it doesn't, results are unpredictable. </p>

<h3 class="hbH3">
  <a name="1039340"> </a>TxtSetNextChar Function <a href="#1044699"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="1039462"> </a>Purpose 
</h4>

<p><a name="1083343"> </a>Sets a character within a text buffer. </p>
<h4>
  <a name="1039491"> </a>Declared In 
</h4>
<code>TextMgr.h<a name="1039493"> </a></code><h4>
  <a name="1039496"> </a>Prototype 
</h4>
<pre class="proto"><a name="1039498"></a>size_t TxtSetNextChar (
   char <code class="par">*iTextP</code>,
   size_t <code class="par">iOffset</code>,
   wchar32_t <code class="par">iChar</code>
)
</pre>
<h4>
  <a name="1039501"> </a>Parameters 
</h4>

<dl>
<dt><a name="1039503"> </a><code>&harr;  <i>iTextP</i></code></dt>
<dd><a name="1083389"> </a>Pointer to a text buffer. </dd>

<dt><a name="1039508"> </a><code>&rarr;  <i>iOffset</i></code></dt>
<dd><a name="1083425"> </a>A valid offset into the buffer <span style="color: #000000;  font-family: Courier; font-style: oblique; font-weight: normal; text-decoration: none; text-transform: none; vertical-align: baseline">iTextP</span>. This offset must point to an inter-character boundary. </dd>

<dt><a name="1039512"> </a><code>&rarr;  <i>iChar</i></code></dt>
<dd><a name="1083441"> </a>The character to replace the character at <span style="color: #000000;  font-family: Courier; font-style: oblique; font-weight: normal; text-decoration: none; text-transform: none; vertical-align: baseline">iOffset</span> with. Must not be a virtual character.</dd>

</dl>
<h4>
  <a name="1039541"> </a>Returns 
</h4>

<p><a name="1083457"> </a>The size of <span style="color: #000000;  font-family: Courier; font-style: oblique; font-weight: normal; text-decoration: none; text-transform: none; vertical-align: baseline">iChar</span>. </p>
<h4>
  <a name="1083458"> </a>Comments 
</h4>

<p><a name="1083459"> </a>This function replaces the character in <span style="color: #000000;  font-family: Courier; font-style: oblique; font-weight: normal; text-decoration: none; text-transform: none; vertical-align: baseline">iTextP</span> at the location <span style="color: #000000;  font-family: Courier; font-style: oblique; font-weight: normal; text-decoration: none; text-transform: none; vertical-align: baseline">iOffset</span> with the character <span style="color: #000000;  font-family: Courier; font-style: oblique; font-weight: normal; text-decoration: none; text-transform: none; vertical-align: baseline">iChar</span>. Note that there must be enough space at <span style="color: #000000;  font-family: Courier; font-style: oblique; font-weight: normal; text-decoration: none; text-transform: none; vertical-align: baseline">iOffset</span> to write the character. </p>

<p><a name="1083463"> </a>You can use <a href="TextMgr.html#1024332"><code>TxtCharSize()</code></a> to determine the size of <span style="color: #000000;  font-family: Courier; font-style: oblique; font-weight: normal; text-decoration: none; text-transform: none; vertical-align: baseline">iChar</span>. </p>

<p><a name="1083464"> </a>You must make sure that the parameter <span style="color: #000000;  font-family: Courier; font-style: oblique; font-weight: normal; text-decoration: none; text-transform: none; vertical-align: baseline">iTextP</span> points to the start of a valid character. That is, it must point to the first byte of a multi-byte character or it must point to a single-byte character; if it doesn't, results are unpredictable. </p>
<h4>
  <a name="1039559"> </a>See Also 
</h4>

<p><a name="1083494"> </a><a href="TextMgr.html#1030398"><code>TxtGetNextChar()</code></a></p>

<h3 class="hbH3">
  <a name="1039568"> </a>TxtStrEncoding Function <a href="#1044699"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="1039573"> </a>Purpose 
</h4>

<p><a name="1083531"> </a>Returns the encoding required to represent a string. </p>
<h4>
  <a name="1039601"> </a>Declared In 
</h4>
<code>TextMgr.h<a name="1039603"> </a></code><h4>
  <a name="1040384"> </a>Prototype 
</h4>
<pre class="proto"><a name="1040610"></a>CharEncodingType TxtStrEncoding (
   const char <code class="par">*iStringP</code>
)
</pre>
<h4>
  <a name="1040723"> </a>Parameters 
</h4>

<dl>
<dt><a name="1040803"> </a><code>&rarr;  <i>iStringP</i></code></dt>
<dd><a name="1083567"> </a>A string. </dd>

</dl>
<h4>
  <a name="1083568"> </a>Returns 
</h4>

<p><a name="1083572"> </a>A <a href="TextMgr.html#995858"><code>CharEncodingType</code></a> value that indicates the encoding required to represent <span style="color: #000000;  font-family: Courier; font-style: oblique; font-weight: normal; text-decoration: none; text-transform: none; vertical-align: baseline">iStringP</span>. If any character in the string isn't recognizable, then <code>charEncodingUnknown</code> is returned. </p>
<h4>
  <a name="1041134"> </a>Comments 
</h4>

<p><a name="1083604"> </a>The encoding for the string is the maximum encoding of any character in that string. For example, if a two-character string contains a blank space and a ü, the appropriate encoding is <code>charEncodingISO8859_1</code>. The blank space's minimum encoding is ASCII. The minimum encoding for the ü is ISO 8859-1. The maximum of these two encodings is ISO 8859-1. </p>

<p><a name="1083605"> </a>Use this function for informational purposes only. Your code should not assume that the character encoding returned by this function is the Palm OS system's character encoding. (Instead use <a href="LocaleMgr.html#1015402"><code>LmGetSystemLocale()</code></a>.)</p>
<h4>
  <a name="1041259"> </a>See Also 
</h4>

<p><a name="1083647"> </a><a href="TextMgr.html#1011389"><code>TxtCharEncoding()</code></a>, <a href="TextMgr.html#1034527"><code>TxtMaxEncoding()</code></a> </p>

<h3 class="hbH3">
  <a name="1041408"> </a>TxtTransliterate Function <a href="#1044699"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="1041442"> </a>Purpose 
</h4>

<p><a name="1083688"> </a>Converts the specified number of bytes in a text buffer using the specified operation. </p>
<h4>
  <a name="1041495"> </a>Declared In 
</h4>
<code>TextMgr.h<a name="1041511"> </a></code><h4>
  <a name="1041536"> </a>Prototype 
</h4>
<pre class="proto"><a name="1041562"></a>status_t TxtTransliterate (
   const char <code class="par">*iSrcTextP</code>,
   size_t <code class="par">iSrcLength</code>,
   char <code class="par">*oDstTextP</code>,
   size_t <code class="par">*ioDstLength</code>,
   TranslitOpType <code class="par">iTranslitOp</code>
)
</pre>
<h4>
  <a name="1041601"> </a>Parameters 
</h4>

<dl>
<dt><a name="1041627"> </a><code>&rarr;  <i>iSrcTextP</i></code></dt>
<dd><a name="1083728"> </a>Pointer to a text buffer. </dd>

<dt><a name="1041692"> </a><code>&rarr;  <i>iSrcLength</i></code></dt>
<dd><a name="1083804"> </a>The length in bytes of <span style="color: #000000;  font-family: Courier; font-style: oblique; font-weight: normal; text-decoration: none; text-transform: none; vertical-align: baseline">iSrcTextP</span>. </dd>

<dt><a name="1041720"> </a><code>&larr;  <i>oDstTextP</i></code></dt>
<dd><a name="1083880"> </a>The output buffer containing the converted characters. </dd>

<dt><a name="1041801"> </a><code>&harr;  <i>ioDstLength</i></code></dt>
<dd><a name="1083926"> </a>Upon entry, the maximum length of <span style="color: #000000;  font-family: Courier; font-style: oblique; font-weight: normal; text-decoration: none; text-transform: none; vertical-align: baseline">oDstTextP</span>. Upon return, the actual length of <span style="color: #000000;  font-family: Courier; font-style: oblique; font-weight: normal; text-decoration: none; text-transform: none; vertical-align: baseline">oDstTextP</span>. </dd>

<dt><a name="1126805"> </a><code>&rarr;  <i>iTranslitOp</i></code></dt>
<dd><a name="1126807"> </a>A 16-bit unsigned value that specifies which transliteration operation is to be performed. See <a href="TextMgr.html#1095301"><code>TranslitOpType</code></a> for the possible values for this field.</dd>

<dd><a name="1124315"> </a>You can ensure that you have enough space for the output by OR-ing your chosen operation with <code>translitOpPreprocess</code>. </dd>

</dl>
<h4>
  <a name="1041861"> </a>Returns 
</h4>

<p><a name="1083966"> </a>One of the following values: </p>

<dl>
<dt><a name="1083967"> </a><code><code>errNone</code></code></dt>
<dd><a name="1083968"> </a>Success</dd>

<dt><a name="1083970"> </a><code><code>txtErrUknownTranslitOp</code></code></dt>
<dd><a name="1083971"> </a><span style="color: #000000;  font-family: Courier; font-style: oblique; font-weight: normal; text-decoration: none; text-transform: none; vertical-align: baseline">iTranslitOp</span>'s value is not recognized</dd>

<dt><a name="1083973"> </a><code><code>txtErrTranslitOverrun</code></code></dt>
<dd><a name="1083974"> </a><span style="color: #000000;  font-family: Courier; font-style: oblique; font-weight: normal; text-decoration: none; text-transform: none; vertical-align: baseline">iSrcTextP</span> and <span style="color: #000000;  font-family: Courier; font-style: oblique; font-weight: normal; text-decoration: none; text-transform: none; vertical-align: baseline">oDstTextP</span> point to the same memory location and the operation would cause the function to overwrite unprocessed data in the input buffer. </dd>

<dt><a name="1083976"> </a><code><code>txtErrTranslitOverflow</code></code></dt>
<dd><a name="1083977"> </a><span style="color: #000000;  font-family: Courier; font-style: oblique; font-weight: normal; text-decoration: none; text-transform: none; vertical-align: baseline">oDstTextP</span> is not large enough to contain the converted string. </dd>

<dt><a name="1083979"> </a><code><code>txtErrTranslitUnderflow</code></code></dt>
<dd><a name="1083980"> </a>The end of the source buffer contains a partial character. </dd>

</dl>


<h4>
  <a name="1083982"> </a>Comments 
</h4>

<p><a name="1083983"> </a><span style="color: #000000;  font-family: Courier; font-style: oblique; font-weight: normal; text-decoration: none; text-transform: none; vertical-align: baseline">iSrcTextP</span> and <span style="color: #000000;  font-family: Courier; font-style: oblique; font-weight: normal; text-decoration: none; text-transform: none; vertical-align: baseline">oDstTextP</span> may point to the same location if you want to perform the operation in place. However, you should be careful that the space required for <span style="color: #000000;  font-family: Courier; font-style: oblique; font-weight: normal; text-decoration: none; text-transform: none; vertical-align: baseline">oDstTextP</span> is not larger than <span style="color: #000000;  font-family: Courier; font-style: oblique; font-weight: normal; text-decoration: none; text-transform: none; vertical-align: baseline">iSrcTextP</span> so that you don't generate a <code>txtErrTranslitOverrun</code> error. </p>

<p><a name="1083984"> </a>For example, suppose on a Shift JIS encoded system, you want to convert a series of single-byte Japanese Katakana symbols to double-byte Katakana symbols. You cannot perform this operation in place because it replaces a single-byte character with a multi-byte character. When the first converted character is written to the buffer, it overwrites the second input character. Thus, a text overrun has occurred. </p>

<p><a name="1083989"> </a>You must make sure that the parameter <span style="color: #000000;  font-family: Courier; font-style: oblique; font-weight: normal; text-decoration: none; text-transform: none; vertical-align: baseline">iSrcTextP</span> points to the start of a valid character. That is, it must point to the first byte of a multi-byte character or it must point to a single-byte character; if it doesn't, results are unpredictable. </p>
<h4>
  <a name="1124298"> </a>Example 
</h4>

<p><a name="1124288"> </a>The following code shows how to convert a string to uppercase. </p>

<div class="CodeRule"><hr></div><pre class="CodeBlock">
outSize = buf2Len;
error = TxtTransliterate(buf1, buf1len, &amp;buf2, &amp;outSize,<a name="1124289"> </a>
   translitOpUpperCase|translitOpPreprocess);<a name="1124336"> </a>
if (outSize &gt; buf2len) 
    /* allocate more memory for buf2 */<a name="1125348"> </a>
error = TxtTransliterate(buf1, buf1Len, &amp;buf2, &amp;outSize,<a name="1125349"> </a>
   translitOpUpperCase);<a name="1124341"> </a>
</pre><div class="CodeRule"><hr></div>


<h3 class="hbH3">
  <a name="1043012"> </a>TxtTruncateString Function <a href="#1044699"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="1043082"> </a>Purpose 
</h4>

<p><a name="1084497"> </a>Determines if a string fits within a given number of bytes. If not, truncates the string. </p>
<h4>
  <a name="1043171"> </a>Declared In 
</h4>
<code>TextMgr.h<a name="1043211"> </a></code><h4>
  <a name="1043256"> </a>Prototype 
</h4>
<pre class="proto"><a name="1043304"></a>Boolean TxtTruncateString (
   char <code class="par">*iDstString</code>,
   const char <code class="par">*iSrcString</code>,
   size_t <code class="par">iMaxLength</code>,
   Boolean <code class="par">iAddEllipsis</code>
)
</pre>
<h4>
  <a name="1043393"> </a>Parameters 
</h4>

<dl>
<dt><a name="1043457"> </a><code>&larr;  <i>iDstString</i></code></dt>
<dd><a name="1084559"> </a>The null-terminated string truncated if necessary so that it is no more than <span style="color: #000000;  font-family: Courier; font-style: oblique; font-weight: normal; text-decoration: none; text-transform: none; vertical-align: baseline">iMaxLength</span> bytes long. </dd>

<dt><a name="1043599"> </a><code>&rarr;  <i>iSrcString</i></code></dt>
<dd><a name="1084691"> </a>A null-terminated string. </dd>

<dt><a name="1043638"> </a><code>&rarr;  <i>iMaxLength</i></code></dt>
<dd><a name="1084695"> </a>The maximum length of <code class="par">iDstString</code> including the null terminator. </dd>

<dt><a name="1043642"> </a><code>&rarr;  <i>iAddEllipsis</i></code></dt>
<dd><a name="1043644"> </a>If <code>true</code>, an ellipsis character is the last character of <code class="par">iDstString</code> if <code class="par">iSrcString</code> had to be truncated. If <code>false</code>, <code class="par">iSrcString</code> is truncated at the last character that fits in <code class="par">iDstString</code>. </dd>

</dl>
<h4>
  <a name="1043646"> </a>Returns 
</h4>

<p><a name="1084699"> </a><code>true</code> if the string was truncated, or <code>false</code> if the string can fit without truncation. </p>
<h4>
  <a name="1043651"> </a>Comments 
</h4>

<p><a name="1084703"> </a>This function determines whether <span style="color: #000000;  font-family: Courier; font-style: oblique; font-weight: normal; text-decoration: none; text-transform: none; vertical-align: baseline">iSrcString</span> can be copied into a string with the specified length without being truncated. If it can, <code>TxtTruncateString()</code> returns <code>false</code> and copies <code class="par">iSrcString</code> into <code class="par">iDstString</code>. If the string must be truncated, this function copies one less than the number of characters that can fit in <span style="color: #000000;  font-family: Courier; font-style: oblique; font-weight: normal; text-decoration: none; text-transform: none; vertical-align: baseline">iMaxLength</span> into <code class="par">iDstString</code> and then appends an ellipsis (...) character. </p>
<h4>
  <a name="1043656"> </a>See Also 
</h4>

<p><a name="1084729"> </a><a href="../User_Interface/UI_Font.html#996257"><code>FntWidthToOffset()</code></a>, <a href="../User_Interface/UI_Window.html#1029074"><code>WinDrawTruncChars()</code></a>, <a href="TextMgr.html#1081784"><code>TxtGetTruncationOffset()</code></a></p>

<h3 class="hbH3">
  <a name="1043661"> </a>TxtWordBounds Function <a href="#1044699"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="1043691"> </a>Purpose 
</h4>

<p><a name="1084078"> </a>Finds the boundaries of a word of text that contains the character starting at the specified offset. </p>
<h4>
  <a name="1043696"> </a>Declared In 
</h4>
<code>TextMgr.h<a name="1043702"> </a></code><h4>
  <a name="1043705"> </a>Prototype 
</h4>
<pre class="proto"><a name="1043707"></a>Boolean TxtWordBounds (
   const char <code class="par">*iTextP</code>,
   size_t <code class="par">iLength</code>,
   size_t <code class="par">iOffset</code>,
   size_t <code class="par">*oWordStart</code>,
   size_t <code class="par">*oWordEnd</code>
)
</pre>
<h4>
  <a name="1043710"> </a>Parameters 
</h4>

<dl>
<dt><a name="1043735"> </a><code>&rarr;  <i>iTextP</i></code></dt>
<dd><a name="1084132"> </a>Pointer to a text buffer. </dd>

<dt><a name="1043927"> </a><code>&rarr;  <i>iLength</i></code></dt>
<dd><a name="1084164"> </a>The length in bytes of the text pointed to by <span style="color: #000000;  font-family: Courier; font-style: oblique; font-weight: normal; text-decoration: none; text-transform: none; vertical-align: baseline">iTextP</span>. </dd>

<dt><a name="1043995"> </a><code>&rarr;  <i>iOffset</i></code></dt>
<dd><a name="1084168"> </a>A valid offset into the text buffer <span style="color: #000000;  font-family: Courier; font-style: oblique; font-weight: normal; text-decoration: none; text-transform: none; vertical-align: baseline">iTextP</span>. This offset must point to the beginning of a character. </dd>

<dt><a name="1044063"> </a><code>&larr;  <i>oWordStart</i></code></dt>
<dd><a name="1084172"> </a>The starting offset of the text word. </dd>

<dt><a name="1044127"> </a><code>&larr;  <i>oWordEnd</i></code></dt>
<dd><a name="1084176"> </a>The ending offset of the text word. </dd>

</dl>
<h4>
  <a name="1044171"> </a>Returns 
</h4>

<p><a name="1084180"> </a><code>true</code> if a word is found. Returns <code>false</code> if the word doesn't exist or is punctuation or whitespace. </p>
<h4>
  <a name="1084181"> </a>Comments 
</h4>

<p><a name="1084182"> </a>Assuming the ASCII encoding, if the text buffer contains the string "Hi! How are you?" and you pass 5 as the offset, <code>TxtWordBounds()</code> returns the start and end of the word containing the character at offset 5, which is the character "o". Thus, <span style="color: #000000;  font-family: Courier; font-style: oblique; font-weight: normal; text-decoration: none; text-transform: none; vertical-align: baseline">oWordStart</span> and <span style="color: #000000;  font-family: Courier; font-style: oblique; font-weight: normal; text-decoration: none; text-transform: none; vertical-align: baseline">oWordEnd</span> would point to the start and end of the word "How". </p>

<p><a name="1084183"> </a>You must make sure that the parameter <span style="color: #000000;  font-family: Courier; font-style: oblique; font-weight: normal; text-decoration: none; text-transform: none; vertical-align: baseline">iTextP</span> points to the start of a valid character. That is, it must point to the first byte of a multi-byte character or it must point to a single-byte character; if it doesn't, results are unpredictable. </p>
<h4>
  <a name="1044381"> </a>See Also 
</h4>

<p><a name="1084193"> </a><a href="TextMgr.html#1010728"><code>TxtCharBounds()</code></a>, <a href="TextMgr.html#1015436"><code>TxtCharIsDelim()</code></a>, <a href="TextMgr.html#1033687"><code>TxtGetWordWrapOffset()</code></a></p>

<p><a name="986245"> </a></p>
 

<hr> 
<p class="FNFootnote">
<a name="1126680"> </a><a href="#1126677">1</a>. This encoding is identical to its Windows counterpart with some additional characters added in the control range.</p>
&nbsp;<br>
</div>
<!--END CONTENT-->

</td>
<td width="5">&nbsp;&nbsp;</td>
</tr>

</table>

<!-- BEGIN FOOTER -->
<table width="100%" border="0" cellspacing="0" cellpadding="0">
<tr>
<td width="7" rowspan="2"><img name="index_x" src="images/shim.gif" width="7" height="33" border="0" alt=""></td>
<td align="left"><img name="dashes" src="images/dashes.gif" width="744" height="3" border="0" alt=""></td>
<td width="10" rowspan="2"><img name="index_x" src="images/shim.gif" width="10" height="33" border="0" alt=""></td>
</tr>
<tr>
<td align="center">
<p class="footer">
Copyright © 2004, PalmSource, Inc. and its affiliates. All rights reserved.<br>
<a href="http://www.palmsource.com/contact/">Write Us</a> | <a href="http://www.palmos.com/dev/training/">Training</a> | <a href="http://www.palmos.com/dev/support/kb/">Knowledge Base</a> | <a href="TextLoc_Front.html" target="_blank">Legal</a></p>
<br>
<!--BEGIN BOOK NAVIGATION-->
<p class="nav">
<A href="http://www.palmos.com/dev/support/docs/">Documentation</a>&nbsp;&nbsp;|&nbsp;&nbsp;
<a href="TextLocTOC.html">Table of Contents</a>&nbsp;&nbsp;
             |&nbsp;&nbsp;<a href="StringMgr.html">&lt;&nbsp;Previous</a>&nbsp;&nbsp;
             |&nbsp;&nbsp;<a href="TextLoc_PartApx.html">Next&nbsp;&gt;</a>&nbsp;&nbsp;
             |&nbsp;&nbsp;<a href="TextLocIX.html">Index</a>
</p>
</td>
</tr>
</table>
<!-- END FOOTER -->

</body>
</html>