<HTML>

<HEAD>
<SMALLSCREENIGNORE> 
<LINK HREF="copy_of_palmos.css" REL="stylesheet" TYPE="text/css">
<LINK HREF="document.css" REL="StyleSheet" TYPE="text/css" media="screen">
<!-- SCRIPT_START -->
<!-- SCRIPT_END -->
</SMALLSCREENIGNORE>
<TITLE>Expansion</TITLE>

<META NAME="PALMTEMPLATE" CONTENT="1006-002 Palm HTML 20020513">
<META NAME="GENERATOR" CONTENT="Quadralay WebWorks Publisher Professional Edition 6.0.7">
<META NAME="TEMPLATEBASE" CONTENT="Palm HTML 20010625">
<META NAME="LASTUPDATED" CONTENT="12/13/02 10:05:46">
<META HTTP-EQUIV="content-type" CONTENT="text/html;charset=ISO-8859-1">

</HEAD>

<BODY LEFTMARGIN="0" MARGINWIDTH="0" TOPMARGIN="0" MARGINHEIGHT="0">
<SMALLSCREENIGNORE> 
<table width="100%" border="0" cellspacing="0" cellpadding="0">
  <tr>
	<td><a name="1000865"></a>
      <table border="0" cellpadding="0" cellspacing="0" width="100%">
        <tr height="35"> 
          <td height="35" colspan="2" bgcolor="#6699CC">&nbsp;</td>
        </tr>
        <tr valign="top"> 
          <td width="160" align="left"><a href="http://www.palmos.com"><img src="images/bigorb.gif" width="160" height="110" border="0"></a></td>
          <td align="left" width="100%"> 
            </SMALLSCREENIGNORE>
            <!-- CONTENTCELL_START -->
            <img border="0" height="45" src="images/orb_bkgrnd_600.gif" width="600"><br>
            <!--PAGENAV_START-->
            <SPAN CLASS="subnav">&nbsp;&lt;&nbsp;<A HREF="http://www.palmos.com/index.html">Home</a> 
              &nbsp;&nbsp;&lt;&nbsp;<A HREF="http://www.palmos.com/dev/">Developers</a> 
              &nbsp;&nbsp;&lt;&nbsp;<A HREF="http://www.palmos.com/dev/support/">Development Support</a>
              &nbsp;&nbsp;&lt;&nbsp;<A HREF="http://www.palmos.com/dev/support/docs/">Documentation</a></span><BR>
             <img src="images/pixel_ltblue.gif" width="600" height="1" border="0" vspace="2"><br>
             <h2 class="HeadDocPage">7  Expansion</h2>
             <img src="images/pixel_ltblue.gif" width="600" height="1" border="0" vspace="2"><br>
             &nbsp;<span class="subnav"><a href="CompanionTOC.html">Table of Contents</a>&nbsp;&nbsp;
             |&nbsp;&nbsp;<a href="FilesAndDatabases.html">&lt;&nbsp;Previous</a>&nbsp;&nbsp;
             |&nbsp;&nbsp;<a href="Text.html">Next&nbsp;&gt;</a>&nbsp;&nbsp;
             |&nbsp;&nbsp;<a href="CompanionIX.html">Index</a></span>  
            <!--PAGENAV_END-->
          </td>
        </tr>
      </table>
    </td>
			</tr>
  <tr>
				<td> 
      <table width="100%" border="0" cellspacing="0" cellpadding="0">
        <tr>
							<td>&nbsp;&nbsp;&nbsp;</td>
						</tr>
        <tr>
		<td valign="top" width="10">&nbsp;&nbsp;&nbsp;</td>
		<td valign="top" width="175">
			<p class="SideTitle">Title - <br><a href="Companion_Front.html">Palm OS® Programmer's Companion</a></p>
			<p class="SideTOC1-PartTab">Volume I </p>
			<p class="SideTOC1"><a href="ExpAndVFSConcepts.html">7  Expansion</a></p>
			
<p class="SideTOC2">
<a href="#1000912">Expansion Support
</a></p>

<p class="SideTOC3">
<a href="#1000918">Primary vs. Secondary Storage
</a></p>

<p class="SideTOC3">
<a href="#1000936">Expansion Slot
</a></p>

<p class="SideTOC3">
<a href="#1000946">Universal Connector
</a></p>

<p class="SideTOC2">
<a href="#1000953">Architectural Overview
</a></p>

<p class="SideTOC3">
<a href="#1000965">Slot Drivers
</a></p>

<p class="SideTOC3">
<a href="#1000976">File Systems
</a></p>

<p class="SideTOC3">
<a href="#1000985">VFS Manager
</a></p>

<p class="SideTOC3">
<a href="#1001008">Expansion Manager
</a></p>

<p class="SideTOC2">
<a href="#1001026">Standard Directories
</a></p>

<p class="SideTOC2">
<a href="#1001070">Applications on Cards
</a></p>

<p class="SideTOC2">
<a href="#1001095">Card Insertion and Removal
</a></p>

<p class="SideTOC3">
<a href="#1001193">Start.prc
</a></p>

<p class="SideTOC2">
<a href="#1001214">Checking for Expansion Cards
</a></p>

<p class="SideTOC3">
<a href="#1001217">Verifying Handheld Compatibility
</a></p>

<p class="SideTOC3">
<a href="#1001246">Checking for Mounted Volumes
</a></p>

<p class="SideTOC3">
<a href="#1001269">Enumerating Slots
</a></p>

<p class="SideTOC3">
<a href="#1001298">Determining a Card's Capabilities
</a></p>

<p class="SideTOC2">
<a href="#1001315">Volume Operations
</a></p>

<p class="SideTOC3">
<a href="#1001384">Hidden Volumes
</a></p>

<p class="SideTOC3">
<a href="#1001393">Matching Volumes to Slots
</a></p>

<p class="SideTOC3">
<a href="#1001411">Naming Volumes
</a></p>

<p class="SideTOC2">
<a href="#1001446">File Operations
</a></p>

<p class="SideTOC3">
<a href="#1001455">Common Operations
</a></p>

<p class="SideTOC3">
<a href="#1001623">Naming Files
</a></p>

<p class="SideTOC3">
<a href="#1001634">Working with Palm Databases
</a></p>

<p class="SideTOC2">
<a href="#1001799">Directory Operations
</a></p>

<p class="SideTOC3">
<a href="#1001810">Directory Paths
</a></p>

<p class="SideTOC3">
<a href="#1001813">Common Operations
</a></p>

<p class="SideTOC3">
<a href="#1001908">Enumerating the Files in a Directory
</a></p>

<p class="SideTOC3">
<a href="#1001944">Determining the Default Directory for a Particular File Type
</a></p>

<p class="SideTOC3">
<a href="#1001973">Default Directories Registered at Initialization
</a></p>

<p class="SideTOC2">
<a href="#1002126">Custom Calls
</a></p>

<p class="SideTOC3">
<a href="#1002141">Custom I/O
</a></p>

<p class="SideTOC2">
<a href="#1002147">Debugging
</a></p>

<p class="SideTOC2">
<a href="#1002154">Summary of Expansion and VFS Managers
</a></p>

		</td>

		<td width="5">&nbsp;&nbsp;</td>
		<td width="1" bgcolor="#6699cc">&nbsp;</td>
		<td width="5">&nbsp;&nbsp;</td>
		<td> 

				<!-- CONTENT_START -->

<p class="Body">
  <a name="1000866"> </a>This chapter describes how to work with expansion cards and add-on devices using the Palm OS<sup>®</sup> Expansion and Virtual File System (VFS) Managers.
</p>

  <a name="1000870"> </a><p class="B1Bullet"> &#8226; <a href="ExpAndVFSConcepts.html#1000912">Expansion Support</a> introduces basic terminology and discusses the hardware and file systems supported by the Expansion and VFS Managers.</p>

  <a name="1000874"> </a><p class="B1Bullet"> &#8226; <a href="ExpAndVFSConcepts.html#1000953">Architectural Overview</a> illustrates the Palm OS expansion architecture and discusses the differences between primary and secondary storage.</p>

  <a name="1000878"> </a><p class="B1Bullet"> &#8226; <a href="ExpAndVFSConcepts.html#1001026">Standard Directories</a> lists directories that are treated specially by the Palm OS and describes their use.</p>

  <a name="1000882"> </a><p class="B1Bullet"> &#8226; <a href="ExpAndVFSConcepts.html#1001070">Applications on Cards</a> covers the various implications of running Palm OS applications from an expansion card.</p>

  <a name="1000886"> </a><p class="B1Bullet"> &#8226; <a href="ExpAndVFSConcepts.html#1001095">Card Insertion and Removal</a> covers, in detail, the sequence of events that occur when an expansion card is inserted into or removed from an expansion slot.</p>

  <a name="1000890"> </a><p class="B1Bullet"> &#8226; <a href="ExpAndVFSConcepts.html#1001214">Checking for Expansion Cards</a> shows you how to verify that the handheld supports expansion, how to check each of the handheld's slots for expansion cards, and how to determine the capabilities of a card in a given slot.</p>

  <a name="1000894"> </a><p class="B1Bullet"> &#8226; <a href="ExpAndVFSConcepts.html#1001315">Volume Operations</a> discusses the various ways in which you can work with volumes on an expansion card.</p>

  <a name="1000898"> </a><p class="B1Bullet"> &#8226; <a href="ExpAndVFSConcepts.html#1001446">File Operations</a> discusses the various ways in which you can work with files on an expansion card.</p>

  <a name="1000902"> </a><p class="B1Bullet"> &#8226; <a href="ExpAndVFSConcepts.html#1001799">Directory Operations</a> discusses the various ways in which you can work with directories on an expansion card.</p>

  <a name="1000906"> </a><p class="B1Bullet"> &#8226; <a href="ExpAndVFSConcepts.html#1002126">Custom Calls</a> briefly discusses how you can go beyond the functions provided by the Expansion and VFS Managers and interact with specialized I/O devices.</p>

  <a name="1000910"> </a><p class="B1Bullet"> &#8226; <a href="ExpAndVFSConcepts.html#1002147">Debugging</a> briefly introduces the process of debugging an application that relies on the presence of an expansion card.</p>

<h2 class="HaHeadA">
  <a name="1000912"> </a>Expansion Support 
<a href="#1000865"><img src="images/top.gif" border="0"></a></h2>

<p class="Body">
  <a name="1000917"> </a>Beginning with Palm OS 4.0<a href="#1000915"><span class="Footnote">1</span></a>, a set of optional system extensions provide a standard mechanism by which Palm OS applications can take advantage of the expansion capabilities of various Palm Powered<sup>&#8482;</sup> handhelds. This capability not only augments the memory and I/O of the handheld, but facilitates data interchange with other Palm Powered handhelds and with devices that aren't running the Palm OS. These other devices include digital cameras, digital audio players, desktop or laptop computers, and the like.
</p>

<h2 class="HBHeadB">
  <a name="1000918"> </a>Primary vs. Secondary Storage
<a href="#1000865"><img src="images/top.gif" border="0"></a></h2>

<p class="Body">
  <a name="1000920"> </a>All Palm Powered handhelds contain <b>primary storage</b>-directly addressable memory that is used for both long-term and temporary storage. This includes storage RAM, used to hold nonvolatile user data and applications; and dynamic RAM, which is used as working space for temporary allocations.
</p>
<p class="Body">
  <a name="1000922"> </a>On most handhelds, primary storage is contained entirely within the device itself. The Palm OS memory architecture doesn't limit devices to this, however; devices can be designed to accept additional storage RAM. The products developed by Handspring&#8482; work this way; memory modules plugged into the Springboard slot are fully-addressable and appear to a Palm OS application as additional storage RAM.
</p>
<p class="Body">
  <a name="1000924"> </a><b>Secondary storage</b>, by contrast, is designed primarily to be add-on nonvolatile storage. Although not limited to any particular implementation, most secondary storage media:
</p>

  <a name="1000925"> </a><p class="B1Bullet"> &#8226; can be inserted and removed from the expansion slot at will</p>

  <a name="1000927"> </a><p class="B1Bullet"> &#8226; are based upon a third-party standard, such as Secure Digital (SD) memory cards, MultiMedia (MMC) cards, CompactFlash, Sony's Memory Stick&#8482;, and others</p>

  <a name="1000931"> </a><p class="B1Bullet"> &#8226; present a serial interface, accessing data one bit, byte, or block at a time</p>
<p class="Body">
  <a name="1000932"> </a>Applications access primary storage either directly, in the case of most dynamic RAM, or through the Database and Resource Managers. To access secondary storage, however, applications use the Expansion and VFS Managers. These have been designed to support as broad a range of serial expansion architectures as possible.
</p>

<h2 class="HBHeadB">
  <a name="1000936"> </a>Expansion Slot
<a href="#1000865"><img src="images/top.gif" border="0"></a></h2>

<p class="Body">
  <a name="1000937"> </a>The expansion slots found on many Palm Powered handhelds vary depending on the manufacturer. While some may accept SD and MMC cards, others may accept Memory Stick or CompactFlash. Note that there is no restriction on the number of expansion slots that a given handheld can have.
</p>
<p class="Body">
  <a name="1000938"> </a>Depending on the expansion technology used, there can be a wide variety of expansion cards usable with a given handheld:
</p>

  <a name="1000940"> </a><p class="B1Bullet"> &#8226; Storage cards provide secondary storage and can either be used to hold additional applications and data, or can be used for a specific purpose, for instance as a backup mechanism.</p>

  <a name="1000942"> </a><p class="B1Bullet"> &#8226; ROM cards hold dedicated applications and data.</p>

  <a name="1000943"> </a><p class="B1Bullet"> &#8226; I/O cards extend the handheld's I/O capabilities. A modem, for instance, could provide wired access, while a Bluetooth&#8482; transceiver could add wireless capability.</p>

  <a name="1000944"> </a><p class="B1Bullet"> &#8226; "Combo" cards provide both additional storage or ROM along with some I/O capability.</p>

<h2 class="HBHeadB">
  <a name="1000946"> </a>Universal Connector
<a href="#1000865"><img src="images/top.gif" border="0"></a></h2>

<p class="Body">
  <a name="1000947"> </a>Certain newer Palm Powered handhelds may be equipped with a universal connector that connects the handheld to a HotSync<sup>®</sup> cradle. This connector can be used to connect the handheld to snap-on I/O devices as well. A special slot driver dedicated to this connector allows handheld-to-accessory communication using the serial portion of the connector. This "plug and play" slot driver presents the peripheral as a card in a slot, even to the extent of providing the card insertion notification when the peripheral is attached.
</p>
<p class="Body">
  <a name="1000950"> </a>Because the universal connector's slot driver makes a snap-on peripheral appear to be a card in a slot, such peripherals can be treated as expansion cards, at least from an application developer's perspective. For the remainder of this chapter, wherever an I/O card could be used, the phrase "expansion card" can be taken to mean both "expansion card" and "plug and play peripheral."
</p>

<h2 class="HaHeadA">
  <a name="1000953"> </a>Architectural Overview 
<a href="#1000865"><img src="images/top.gif" border="0"></a></h2>

<p class="Body">
  <a name="1000957"> </a><a href="ExpAndVFSConcepts.html#1000959">Figure 7.1</a> illustrates the Palm OS expansion architecture. It is designed to be flexible enough to support multiple file systems and diverse physical expansion mechanisms while still presenting a consistent set of APIs to applications and to other parts of the Palm OS. The following sections describe the major components of the Palm OS expansion architecture. Working from the bottom up, those components are: slot drivers, file systems, the VFS Manager, and the Expansion Manager.
</p>

<p class="FFigureCaption">
  <a name="1000959"> </a>Figure 7.1	 Palm OS expansion architecture
</p>
<p class="FgFigure">
  <a name="1000963"> </a><div align="left"><img src="images/ExpAndVFSConceptsa.gif" height="327" width="360" border="0" hspace="20" vspace="0">
</div>
</p>

<h2 class="HBHeadB">
  <a name="1000965"> </a>Slot Drivers
<a href="#1000865"><img src="images/top.gif" border="0"></a></h2>

<p class="Body">
  <a name="1000966"> </a>A slot driver is a standard Palm OS shared library of type <span style="font-family: monospace">sysFileTSlotDriver</span> (<span style="font-family: monospace">'libs'</span>). It is a special library that encapsulates direct access to the hardware and provides a standard set of services to the Expansion Manager and, optionally, to file system libraries. Adding support for a new type of hardware expansion is usually simply a matter of writing a slot driver for it. As illustrated in <a href="ExpAndVFSConcepts.html#1000959">Figure 7.1</a>, applications don't normally interact directly with slot drivers.
</p>
<p class="Body">
  <a name="1000970"> </a>Each expansion slot has a slot driver associated with it. Slots are identified by a unique <b>slot reference number</b>, which is assigned by the Expansion Manager. Expansion cards themselves are not numbered individually; applications typically reference the slot into which a card is inserted. Note, however, that a slot may or may not have a card in it at any given time, and that a card can be inserted and removed while an application is running.
</p>
<div class="NINoteImportant"><hr>
  <a name="1000972"> </a> <span style="color: #333;  font-style: normal; font-weight: bold; text-decoration: none; text-transform: none; vertical-align: baseline">NOTE:  </span> "Card number" is a Palm OS Memory Manager term, and is not to be confused with "slot reference number."
<hr>
</div>
<p class="Body">
  <a name="1000974"> </a>The current implementation only supports one volume per slot.
</p>

<h2 class="HBHeadB">
  <a name="1000976"> </a>File Systems
<a href="#1000865"><img src="images/top.gif" border="0"></a></h2>

<p class="Body">
  <a name="1000977"> </a>The Palm OS expansion architecture defines a common interface for all file system implementations on the Palm OS. This interface consists of a complete set of APIs for interacting with the file system, including the ability to open, close, read, write, and delete both files and directories on named volumes.
</p>
<p class="Body">
  <a name="1000979"> </a>File system implementations are packaged as shared libraries of type <span style="font-family: monospace">sysFileTFileSystem</span> (<span style="font-family: monospace">'libf'</span>). They are modular plug-ins that add support for a particular type of file system, such as VFAT, HFS, or NFS. The Palm OS expansion architecture allows multiple file system libraries to be installed at any given time. Typically, an implementation of the VFAT file system is present.
</p>
<p class="Body">
  <a name="1000981"> </a>VFAT is the industry standard for flash memory cards of all types. It enables easy transfer of data and or applications to desktops and other devices. The VFAT file system library included with Palm OS 4.0 natively supports VFAT file systems on secondary storage media. It is able to recognize and mount FAT and VFAT file systems, and offers to reformat unrecognizable or corrupted media.
</p>
<p class="Body">
  <a name="1000984"> </a>Because the VFAT file system requires long filenames to be stored in Unicode/UCS2 format, the standard VFAT file system library supports conversion between UCS2 and Shift-JIS (the standard Palm OS multi-byte character encoding), and the Palm/Latin encoding.
</p>

<h2 class="HBHeadB">
  <a name="1000985"> </a>VFS Manager
<a href="#1000865"><img src="images/top.gif" border="0"></a></h2>

<p class="Body">
  <a name="1000986"> </a>The VFS (Virtual File System) Manager provides a unified API that gives applications access to many different file systems on many different media types. It abstracts the underlying file systems so that applications can be written without regard to the actual file system in use. The VFS Manager includes APIs for manipulating files, directories, and volumes.
</p>
<div class="NINoteImportant"><hr>
  <a name="1000988"> </a> <span style="color: #333;  font-style: normal; font-weight: bold; text-decoration: none; text-transform: none; vertical-align: baseline">NOTE:  </span> Although the great majority of the functions in the VFS Manager can be used by any application, some are intended only for use by slot drivers and file systems. Others are not intended for use by third-party applications but are designed primarily for system use.
<hr>
</div>

<h4 class="HCHeadC">
  <a name="1000990"> </a>The VFS Manager, the Data Manager, and File Streaming APIs
</h4>
<p class="Body">
  <a name="1000991"> </a>With the addition of the VFS Manager to the Palm OS, there are now three distinct ways applications can store and retrieve Palm OS user data:
</p>

  <a name="1000992"> </a><p class="B1Bullet"> &#8226; The Data Manager manages user data in the storage heap. It was specifically designed to make the most of the limited dynamic RAM and the nonvolatile RAM used instead of disk storage on most handhelds. Use the Data Manager to store and retrieve Palm OS user data when storage on the handheld is all that is needed, or when efficient access to data is paramount.</p>

  <a name="1000993"> </a><p class="B1Bullet"> &#8226; The File Streaming API is a layer on top of the Data Manager that provides file functionality with all data being read from or written to a database in the storage heap. Most applications have no need for the File Streaming APIs; they are primarily used by applications that need to work with large blocks of data.</p>

  <a name="1000995"> </a><p class="B1Bullet"> &#8226; The VFS and Expansion Managers were designed specifically to support many types of expansion memory as secondary storage. The VFS Manager APIs present a consistent interface to many different types of file systems on many types of external media. Applications that use the VFS APIs can support the widest variety of file systems. Use the VFS Manager when your application needs to read and write data stored on external media.</p>
<p class="Body">
  <a name="1000996"> </a>Palm OS applications should use the appropriate APIs for each given situation. The Data Manager, being an efficient manager of storage in the storage heap, should be used whenever access to external media is not absolutely needed. Use the VFS API when interoperability and file system access is needed. Note, however, that the VFS Manager adds the extra overhead of buffering all reads and writes in memory when accessing data, so only applications that specifically need this functionality should use the VFS Manager. 
</p>
<p class="Body">
  <a name="1000997"> </a>For more information on the Data and Resource Managers, as well as on the File Streaming APIs, see <a href="FilesAndDatabases.html#998419">Chapter 6, "Files and Databases."</a> For details of the APIs presented by the VFS Manager, see <a href="VFSMgr.html#1180996">Chapter 53, "Virtual File System Manager,"</a> in the <i>Palm OS Programmer's API Reference</i>.
</p>

<h2 class="HBHeadB">
  <a name="1001008"> </a>Expansion Manager
<a href="#1000865"><img src="images/top.gif" border="0"></a></h2>

<p class="Body">
  <a name="1001009"> </a>The Expansion Manager is a software layer that manages slot drivers on Palm OS handhelds. Supported expansion card types include, but are not limited to, Memory Stick and SD cards. The Expansion Manager does not support these expansion cards directly; rather, it provides an architecture and higher level set of APIs that, with the help of low level slot drivers and file system libraries, support these types of media.
</p>
<p class="Body">
  <a name="1001011"> </a>The Expansion Manager:
</p>

  <a name="1001012"> </a><p class="B1Bullet"> &#8226; broadcasts notification of card insertion and removal</p>

  <a name="1001013"> </a><p class="B1Bullet"> &#8226; plays sounds to signify card insertion and removal</p>

  <a name="1001014"> </a><p class="B1Bullet"> &#8226; mounts and unmounts card-resident volumes</p>
<div class="NINoteImportant"><hr>
  <a name="1001016"> </a> <span style="color: #333;  font-style: normal; font-weight: bold; text-decoration: none; text-transform: none; vertical-align: baseline">NOTE:  </span> Some of the other functions provided by the Expansion Manager are for use by slot drivers and file systems and are not generally used by their-party applications.
<hr>
</div>
<p class="Body">
  <a name="1001019"> </a>For details of the APIs presented by the VFS Manager, see <a href="ExpansionManager.html#1107231">Chapter 29, "Expansion Manager,"</a> in the <i>Palm OS Programmer's API Reference</i>.
</p>

<h2 class="HaHeadA">
  <a name="1001026"> </a>Standard Directories 
<a href="#1000865"><img src="images/top.gif" border="0"></a></h2>

<p class="Body">
  <a name="1001027"> </a>The user experience presented by the Palm OS is simpler and more intuitive than that of a typical desktop computer. Part of this simplicity arises from the fact that the Palm OS doesn't present a file system to the user. Users don't have to understand the complexities of a typical file system; applications are readily available with one or two taps of a button or icon, and data associated with those applications is accessible only through each application. Maintaining this simplicity of user operation while supporting a file system on an expansion card is made possible through a standard set of directories on the expansion card.
</p>
<p class="Body">
  <a name="1001029"> </a>The following table lists the standard directory layout for all "standards compliant" Palm OS secondary storage. All Palm OS relevant data should be in the <span style="font-family: monospace">/PALM </span>directory (or in a subdirectory of the <span style="font-family: monospace">/PALM </span>directory), effectively partitioning off a private name space.
</p>

<h5 class="TgTable">
  <a name="1001056"> </a>

<table border="1" cellpadding="5" cellspacing="0">
  <caption></caption>
  <tr bgcolor="#CCCCCC" valign="top">
    <th><a name="1001032"> </a><div class="CellHeading">Directory</div></th>
    <th><a name="1001034"> </a><div class="CellHeading">Description</div></th>
  </tr>
  <tr valign="top">
    <td><a name="1001036"> </a><div class="CellBody"><span style="font-family: monospace">/</span></div></td>
    <td><a name="1001038"> </a><div class="CellBody">Root of the secondary storage.</div></td>
  </tr>
  <tr valign="top">
    <td><a name="1001040"> </a><div class="CellBody"><span style="font-family: monospace">/PALM</span></div></td>
    <td><a name="1001042"> </a><div class="CellBody">Most data written by Palm<sup>&#8482;</sup> applications lives in a subdirectory of this directory. <span style="font-family: monospace">start.prc</span> lives directly in <span style="font-family: monospace">/PALM</span>. This optional file is automatically run when the secondary storage volume is mounted. Other applications may also reside in this directory.</div></td>
  </tr>
  <tr valign="top">
    <td><a name="1001045"> </a><div class="CellBody"><span style="font-family: monospace">/PALM/Backup</span></div></td>
    <td><a name="1001047"> </a><div class="CellBody">Reserved by the Palm OS for backup purposes.</div></td>
  </tr>
  <tr valign="top">
    <td><a name="1001049"> </a><div class="CellBody"><span style="font-family: monospace">/PALM/Programs</span></div></td>
    <td><a name="1001051"> </a><div class="CellBody">Catch-all for other applications and data.</div></td>
  </tr>
  <tr valign="top">
    <td><a name="1001053"> </a><div class="CellBody"><span style="font-family: monospace">/PALM/Launcher</span></div></td>
    <td><a name="1001055"> </a><div class="CellBody">Home of Launcher-visible applications.</div></td>
  </tr>
</table>




</h5><p class="Body">
  <a name="1001058"> </a>The Palm OS Launcher has been enhanced to be expansion card aware. When an expansion card containing a file system is inserted, all applications listed in the card's <span style="font-family: monospace">/PALM/Launcher</span> directory are automatically added to a new Launcher category. This new category takes the name of the expansion card volume. Note that the name displayed in the Launcher for a given application is the name in the application's <span style="font-family: monospace">tAIN</span> (application icon name) resource or, if this resource is empty, the database name, which may or may not match the name of the file.
</p>
<div class="NINoteImportant"><hr>
  <a name="1001061"> </a> <span style="color: #333;  font-style: normal; font-weight: bold; text-decoration: none; text-transform: none; vertical-align: baseline">NOTE:  </span> Whenever possible give the same name to the <span style="font-family: monospace">.prc</span> file and to the database. If the <span style="font-family: monospace">.prc</span> filename differs from the database name, and users copy your application from the card to the handheld and then to another card, the filename may change. This is because the database name is used when an application is copied from the handheld to the card.
<hr>
</div>
<p class="Body">
  <a name="1001062"> </a>When a writable volume is mounted, the Launcher automatically creates the <span style="font-family: monospace">/PALM </span>and <span style="font-family: monospace">/PALM/Launcher</span> directories if they don't already exist. If they do, and if there are applications present in the <span style="font-family: monospace">/PALM/Launcher</span> directory, the Launcher automatically switches to the card's list of applications unless it runs <span style="font-family: monospace">start.prc</span>.
</p>
<p class="Body">
  <a name="1001063"> </a>In addition to these standard directories, the VFS Manager supports the concept of a <b>default directory</b>; a directory in which data of a particular type is typically stored. See <a href="ExpAndVFSConcepts.html#1001944">"Determining the Default Directory for a Particular File Type"</a> for more information.
</p>

<h2 class="HaHeadA">
  <a name="1001070"> </a>Applications on Cards 
<a href="#1000865"><img src="images/top.gif" border="0"></a></h2>

<p class="Body">
  <a name="1001071"> </a>Palm OS applications located in the <span style="font-family: monospace">/PALM/Launcher</span> directory of an expansion card volume appear in a separate Launcher category when the card is inserted into the handheld's expansion slot. If you tap the icon for one of these applications, it is copied to main memory and then launched.
</p>
<p class="Body">
  <a name="1001073"> </a>Applications launched from a card ("card-launched" applications) are first sent a <a href="AppLaunchCodes.html#970473"><span style="font-family: monospace">sysAppLaunchCmdCardLaunch</span></a> launch code, along with a parameter block that includes the reference number of the volume on which the application resides and the complete path to the application. When processing this launch code, the application shouldn't interact with the user or access globals. Unless the application sets the <span style="font-family: monospace">sysAppLaunchStartFlagNoUISwitch</span> bit in the <span style="font-family: monospace">start</span> flags (which are part of the parameter block), the application is then sent a <span style="font-family: monospace">sysAppLaunchCmdNormalLaunch</span> launch code. This is when the application should, if it needs to, interact with user. Applications may want to save some state when <span style="font-family: monospace">sysAppLaunchCmdCardLaunch</span> is received, then act upon that state information when <span style="font-family: monospace">sysAppLaunchCmdNormalLaunch</span> is received.
</p>
<p class="Body">
  <a name="1001080"> </a>When the user switches to a new application, the card-launched application is removed from main memory. Note, however, that any databases created by the card-launched application remain.
</p>
<p class="Body">
  <a name="1001081"> </a>There are certain implications to this "copy and run" process.
</p>

  <a name="1001082"> </a><p class="B1Bullet"> &#8226; There must be sufficient memory for the application. If the handheld doesn't have enough memory to receive the application, it isn't copied from the expansion card and it isn't launched.</p>

  <a name="1001083"> </a><p class="B1Bullet"> &#8226; The copying process takes time. For large applications, this can cause a noticeable delay before the application is actually launched.</p>

  <a name="1001084"> </a><p class="B1Bullet"> &#8226; If some version of the application on the card is already present in main memory, the Launcher puts up a dialog that requires the user to choose whether or not to overwrite the in-memory version.</p>

  <a name="1001087"> </a><p class="B1Bullet"> &#8226; Card-launched applications have a limited lifetime: applications reside in main memory only while they are running. When the user switches to a different application, the card-launched application that was just running is removed from main memory. If the card-launched application is then re-launched, it is once again copied into the handheld's memory.</p>

  <a name="1001089"> </a><p class="B1Bullet"> &#8226; "Legacy" applications-those that are unaware that they are being launched from a card-only work with databases in main memory. Associated databases aren't copied to main memory along with the application unless the database is bundled with the application. Databases created by card-launched applications are not removed along with the application, however, so this data is available to the application when it is subsequently run. Applications that are written to take advantage of the VFS Manager can read and write data on the expansion card, so this limitation generally only applies to legacy applications.</p>
<p class="Indented1"> <a name="1001090"> </a>Bundled databases, although copied to main memory along with their associated application, are meant for static data that doesn't change, such as a game level database. Bundled databases are not copied back to the card; they are simply deleted from memory when the user chooses another application. To bundle a database with an application, give it the same creator ID as the owning application, set the <span style="font-family: monospace">dmHdrAttrBundle</span> bit, and place it in the <span style="font-family: monospace">/PALM/Launcher</span> directory along with the application.</p>

  <a name="1001092"> </a><p class="B1Bullet"> &#8226; Unless a card-launched application is running, it doesn't receive notifications or launch codes since it isn't present on the handheld. In particular, these applications don't receive notifications and aren't informed when an alarm is triggered.</p>

<h2 class="HaHeadA">
  <a name="1001095"> </a>Card Insertion and Removal 
<a href="#1000865"><img src="images/top.gif" border="0"></a></h2>

<p class="Body">
  <a name="1001096"> </a>The Expansion Manager supports the insertion and removal of expansion media at any time. The handheld continues to run as before, though an application switch may occur upon card insertion. The handheld need not be reset or otherwise explicitly informed that a card has been inserted or removed.
</p>
<div class="NWNoteWarning"><hr>
  <a name="1001097"> </a> <span style="color: #FF0000;  font-style: normal; font-weight: bold; text-decoration: none; text-transform: none; vertical-align: baseline">WARNING!  </span> Due to the way certain expansion cards are constructed, if the user removes an expansion card while it is being written to, in certain rare circumstances it is possible for the card to become damaged to the point where either it can no longer be used or it must be reformatted. To the greatest extent possible, applications should only write to the card at well-defined points, and the application should warn the user-perhaps with a "Please Wait" or progress dialog-at that time not to remove the expansion card. The card can be removed while an application is reading from it without fear of damage.
<hr>
</div>
<p class="Body">
  <a name="1001099"> </a>The Palm OS uses a series of notifications to indicate that a card has been inserted or removed, or that a volume has been mounted or unmounted. The following table lists these notifications, and the priority for which they have been registered by the Expansion and VFS Managers. Note that the priorities may change in a future release, so applications shouldn't depend on these precise values. Applications that register for these using normal priority get the correct behavior.
</p>

<h5 class="TgTable">
  <a name="1001163"> </a>

<table border="1" cellpadding="5" cellspacing="0">
  <caption><a name="1001103"> </a><div class="TableTitle">Table 7.1  Expansion card notifications</div></caption>
  <tr bgcolor="#CCCCCC" valign="top">
    <th><a name="1001109"> </a><div class="CellHeading">Notification</div></th>
    <th><a name="1001111"> </a><div class="CellHeading">Registered by</div></th>
    <th><a name="1001113"> </a><div class="CellHeading">Priority</div></th>
  </tr>
  <tr valign="top">
    <td><a name="1001119"> </a><div class="CellBody"><a href="Notifications.html#979884"><span style="font-family: monospace">sysNotifyCardInsertedEvent</span></a></div></td>
    <td><a name="1001121"> </a><div class="CellBody">Exp. Manager</div></td>
    <td><a name="1001123"> </a><div class="CellBody"> 20</div></td>
  </tr>
  <tr valign="top">
    <td><a name="1001129"> </a><div class="CellBody"><a href="Notifications.html#979904"><span style="font-family: monospace">sysNotifyCardRemovedEvent</span></a></div></td>
    <td><a name="1001131"> </a><div class="CellBody">Exp. Manager</div></td>
    <td><a name="1001133"> </a><div class="CellBody">-20</div></td>
  </tr>
  <tr valign="top">
    <td><a name="1001139"> </a><div class="CellBody"><a href="Notifications.html#980406"><span style="font-family: monospace">sysNotifyVolumeMountedEvent</span></a></div></td>
    <td><a name="1001141"> </a><div class="CellBody">Exp. Manager</div></td>
    <td><a name="1001143"> </a><div class="CellBody">-20</div></td>
  </tr>
  <tr valign="top">
    <td><a name="1001148"> </a><div class="CellBody"><a href="Notifications.html#980406"><span style="font-family: monospace">sysNotifyVolumeMountedEvent</span></a></div></td>
    <td><a name="1001150"> </a><div class="CellBody">VFS Manager</div></td>
    <td><a name="1001152"> </a><div class="CellBody"> 10</div></td>
  </tr>
  <tr valign="top">
    <td><a name="1001158"> </a><div class="CellBody"><a href="Notifications.html#980428"><span style="font-family: monospace">sysNotifyVolumeUnmountedEvent</span></a></div></td>
    <td><a name="1001160"> </a><div class="CellBody">Exp. Manager</div></td>
    <td><a name="1001162"> </a><div class="CellBody">-20</div></td>
  </tr>
</table>




</h5><p class="Body">
  <a name="1001164"> </a>The following diagram shows the sequence of events that occur when an expansion card is inserted into a Palm Powered handheld's expansion slot. For clarity, it assumes that no errors occur. If the card doesn't contain a mountable volume, and if the card cannot be formatted and then mounted, this sequence is aborted and the card remains unmounted, although the card insertion notification is still broadcast.
</p>

<p class="FFigureCaption">
  <a name="1001165"> </a>Figure 7.2	 Sequence of events upon card insertion
</p>
<p class="FgFigure">
  <a name="1001169"> </a><div align="left"><img src="images/ExpAndVFSConcepts2.gif" height="446" width="480" border="0" hspace="20" vspace="0">
</div>
</p>
<p class="Body">
  <a name="1001171"> </a>The Expansion Manager registers for <span style="font-family: monospace">sysNotifyCardInsertedEvent</span> with a priority of 20, ensuring that it is notified after other handlers that may have registered with normal priority. To override the Expansion Manager's default handler, register your handler to receive <span style="font-family: monospace">sysNotifyCardInsertedEvent</span> with normal priority, and have it set the appropriate bits in the <span style="font-family: monospace">handled</span> member of the <span style="font-family: monospace">SysNotifyParamType</span> structure: 
</p>

  <a name="1001172"> </a><p class="B1Bullet"> &#8226; <span style="font-family: monospace">expHandledVolume</span> indicates that any volumes associated with the card have been dealt with, and prevents the Expansion Manager from mounting or unmounting the card's volumes.</p>

  <a name="1001173"> </a><p class="B1Bullet"> &#8226; <span style="font-family: monospace">expHandledSound</span> indicates that your application has handled the playing of an appropriate sound, and prevents the Expansion Manager from playing a sound when the card is inserted or removed. </p>
<p class="Body">
  <a name="1001174"> </a>Note that the number of the slot into which the card was inserted is passed to your handler using the <span style="font-family: monospace">notifyDetailsP</span> member-which is a <span style="font-family: monospace">UInt16</span>, cast to a <span style="font-family: monospace">void *</span>-of the <span style="font-family: monospace">SysNotifyParamType</span> structure.
</p>
<p class="Body">
  <a name="1001175"> </a>Although most applications only register for volume mount and unmount notifications, if you need to receive notifications when the user removes a card from a slot managed by the Expansion Manager, have your application register to receive <span style="font-family: monospace">sysNotifyCardRemovedEvent</span>. Unlike with <span style="font-family: monospace">sysNotifyCardInsertedEvent</span>, the Expansion Manager registers for <span style="font-family: monospace">sysNotifyCardRemovedEvent</span> with a priority of -20, ensuring that it receives the notification before other handlers that are registered for it with normal priority. This notification, too, passes the number of the slot from which the card was removed to your handler using the <span style="font-family: monospace">notifyDetailsP</span> member-which is a <span style="font-family: monospace">UInt16</span>, cast to a <span style="font-family: monospace">void *</span>-of the <span style="font-family: monospace">SysNotifyParamType</span> structure.
</p>
<p class="Body">
  <a name="1001177"> </a>The VFS Manager registers for <span style="font-family: monospace">sysNotifyVolumeMountedEvent</span> with a priority of 10. To override the VFS Manager's default handler, register your handler to receive <span style="font-family: monospace">sysNotifyVolumeMountedEvent</span> with normal priority, and have it set the appropriate bits in the <span style="font-family: monospace">handled</span> member of the <span style="font-family: monospace">SysNotifyParamType</span> structure:
</p>

  <a name="1001179"> </a><p class="B1Bullet"> &#8226; <span style="font-family: monospace">vfsHandledUIAppSwitch</span> indicates that your application has handled <span style="font-family: monospace">SysUIAppSwitch</span> to <span style="font-family: monospace">start.prc</span>. This bit prevents the VFS Manager from performing its own <span style="font-family: monospace">SysUIAppSwitch</span> to <span style="font-family: monospace">start.prc</span> (although <span style="font-family: monospace">start.prc</span> is still loaded and a <span style="font-family: monospace">SysAppLaunch</span> is performed), and also prevents the launcher from switching to itself.</p>

  <a name="1001180"> </a><p class="B1Bullet"> &#8226; <span style="font-family: monospace">vfsHandledStartPrc</span> indicates that your handler has dealt with the automatic running of <span style="font-family: monospace">start.prc</span>. The VFS Manager won't load it and won't call either <span style="font-family: monospace">SysAppLaunch</span> or <span style="font-family: monospace">SysUIAppSwitch</span>.</p>
<p class="Body">
  <a name="1001181"> </a>Note that if your application handles the running of <span style="font-family: monospace">start.prc</span>, you need to keep security in mind. If the handheld is locked when an expansion card is inserted, the VFS Manager's own handler defers the execution of <span style="font-family: monospace">start.prc</span> until the user unlocks the handheld.
</p>
<p class="Body">
  <a name="1001184"> </a>Card removal follows a similar sequence, although there is no equivalent to <span style="font-family: monospace">start.prc</span> that is automatically run. This sequence is illustrated in the following diagram.
</p>

<p class="FFigureCaption">
  <a name="1001185"> </a>Figure 7.3	 Sequence of events upon card removal
</p>
<p class="FgFigure">
  <a name="1001189"> </a><div align="left"><img src="images/ExpAndVFSConcepts3.gif" height="302" width="480" border="0" hspace="20" vspace="0">
</div>
</p>
<p class="Body">
  <a name="1001190"> </a>Upon card removal, the Expansion Manager broadcasts a notification to all applications that have registered to receive card removal notifications and unmounts any mounted volumes on the card. This causes the VFS Manager to issue a card unmounted notification. Each application must register for the card unmounted notification and provide the necessary error handling code if card removal at any time will cause a problem for the application.
</p>
<p class="Body">
  <a name="1001191"> </a>Note that the card insertion and removal notifications are intended primarily for system use, although they can be registered for by applications that need them. Applications that deal only with file systems and the VFS Manager should confine themselves to the volume mounted and unmounted notifications.
</p>

<h2 class="HBHeadB">
  <a name="1001193"> </a>Start.prc
<a href="#1000865"><img src="images/top.gif" border="0"></a></h2>

<p class="Body">
  <a name="1001198"> </a>Upon receipt of a <a href="Notifications.html#980406"><span style="font-family: monospace">sysNotifyVolumeMountedEvent</span></a> that hasn't already been handled (as indicated by the state of the <span style="font-family: monospace">vfsHandledStartPrc</span> bit, as described in the previous section), the VFS Manager copies <span style="font-family: monospace">/Palm/start.prc</span>-and its overlay, if there is one-to the storage heap and launches it. This process enables "application cards"-single-function cards that execute automatically upon card insertion. It also allows for combo cards that automatically load any necessary drivers and applications to support card I/O.
</p>
<p class="Body">
  <a name="1001199"> </a>To launch <span style="font-family: monospace">start.prc</span>, the VFS Manager first sends it a special launch code, <a href="AppLaunchCodes.html#970473"><span style="font-family: monospace">sysAppLaunchCmdCardLaunch</span></a>. If the application only needs to do a bit of work and return, it should do it here and then set the <span style="font-family: monospace">sysAppLaunchStartFlagNoUISwitch</span> bit in the start flags, which are part of the <span style="font-family: monospace">sysAppLaunchCmdCardLaunch</span> parameter block. Note that the application doesn't have access to globals and it shouldn't interact with the user here. If the <span style="font-family: monospace">sysAppLaunchStartFlagNoUISwitch</span> bit is not set, as it isn't if the application ignores the <span style="font-family: monospace">sysAppLaunchCmdCardLaunch</span> launch code, the VFS Manager then sends it a <span style="font-family: monospace">sysAppLaunchCmdNormalLaunch</span> launch code to run the application normally. This ensures backwards compatibility with applications that do not understand the <span style="font-family: monospace">sysAppLaunchCmdCardLaunch</span> launch code. This is where the application can interact with the user; an application may want to save state when it receives <span style="font-family: monospace">sysAppLaunchCmdCardLaunch</span>, and then act upon that state when it receives <span style="font-family: monospace">sysAppLaunchCmdNormalLaunch</span>.
</p>
<p class="Body">
  <a name="1001206"> </a>To avoid running out of stack space, the VFS Manager sets the "new stack" bit when launching <span style="font-family: monospace">start.prc</span>. The <span style="font-family: monospace">start.prc</span> application remains in system memory until the volume from which it was copied is removed. <span style="font-family: monospace">start.prc</span> is deleted before <span style="font-family: monospace">VFSVolumeUnmount</span> broadcasts <span style="font-family: monospace">sysNotifyVolumeUnmountedEvent</span> but after the Expansion Manager broadcasts <span style="font-family: monospace">sysNotifyCardRemovedEvent</span>. By registering for <span style="font-family: monospace">sysNotifyCardRemovedEvent</span>, <span style="font-family: monospace">start.prc</span> can react to the volume being removed before it is deleted.
</p>
<div class="NINoteImportant"><hr>
  <a name="1001208"> </a> <span style="color: #333;  font-style: normal; font-weight: bold; text-decoration: none; text-transform: none; vertical-align: baseline">NOTE:  </span> If an expansion card is inserted while the handheld is locked, <span style="font-family: monospace">start.prc</span> is not executed until the user unlocks the handheld.
<hr>
</div>

<h2 class="HaHeadA">
  <a name="1001214"> </a>Checking for Expansion Cards 
<a href="#1000865"><img src="images/top.gif" border="0"></a></h2>

<p class="Body">
  <a name="1001215"> </a>Before looking for an expansion card, your program should first make sure that the handheld supports expansion by verifying the presence of the Expansion and VFS Managers. It can then query for mounted volumes. Finally, your program may want to ascertain the capabilities of the card; whether it has memory, whether it does I/O, and so on. The following sections describe each of these steps.
</p>

<h2 class="HBHeadB">
  <a name="1001217"> </a>Verifying Handheld Compatibility
<a href="#1000865"><img src="images/top.gif" border="0"></a></h2>

<p class="Body">
  <a name="1001218"> </a>There are many different Palm OS handhelds, and in the future there will be many more. Some will have expansion slots to support secondary storage, and some will not. Hardware to support secondary storage is optional, and may or may not be present on a given handheld. Since the Expansion and VFS Managers are of no use on a handheld that has no physical expansion capability, they are optional system extensions that are not present on every Palm Powered handheld. 
</p>
<p class="Body">
  <a name="1001219"> </a>Due to the great variability both in handheld configuration and in the modules which can be plugged into or snapped onto the handheld, applications shouldn't attempt to detect the manufacturer or model of a specific handheld when determining if it supports secondary storage. Instead, check for the presence and capabilities of the underlying operating system.
</p>
<p class="Body">
  <a name="1001220"> </a>The VFS Manager and the Expansion Manager are individual system extensions that are both optional. They both make use of other parts of the operating system that were introduced in Palm OS 4.0. Thus, in order to be fully capable of running an application that relies on the Expansion and VFS Managers, the following all have to be true for a given handheld:
</p>

  <a name="1001224"> </a><p class="B1Bullet"> &#8226; The handheld must be running Palm OS 4.0<a href="#1001223"><span class="Footnote">2</span></a>.</p>

  <a name="1001225"> </a><p class="B1Bullet"> &#8226; The Expansion Manager must be present.</p>

  <a name="1001226"> </a><p class="B1Bullet"> &#8226; The VFS Manager must be present.</p>
<p class="Body">
  <a name="1001230"> </a><a href="CompatibilityApdx.html#987591">Appendix B, "Compatibility Guide,"</a> details how to verify the presence of each:
</p>

  <a name="1001234"> </a><p class="B1Bullet"> &#8226; <a href="CompatibilityApdx.html#971763">4.0 New Feature Set</a> begins by illustrating how to verify that the handheld is running Palm OS 4.0.</p>

  <a name="1001238"> </a><p class="B1Bullet"> &#8226; <a href="CompatibilityApdx.html#972784">Expansion Manager Feature Set</a> shows how to check for the presence of the Expansion Manager.</p>

  <a name="1001242"> </a><p class="B1Bullet"> &#8226; <a href="CompatibilityApdx.html#972838">VFS Manager Feature Set</a> shows how to check for the presence of the VFS Manager.</p>
<p class="Body">
  <a name="1001243"> </a>Although your program could check for the presence of all of the above, it can take advantage of the fact that the VFS Manager relies on the Expansion Manager and won't be present without it. Thus, if the VFS Manager is present, you can safely assume that the Expansion Manager is present as well.
</p>

<h2 class="HBHeadB">
  <a name="1001246"> </a>Checking for Mounted Volumes
<a href="#1000865"><img src="images/top.gif" border="0"></a></h2>

<p class="Body">
  <a name="1001247"> </a>Many applications rely on the handheld's expansion capabilities for additional storage. Applications that don't care about the physical characteristics of the secondary storage module, and that don't need to know the slot into which the module is inserted, can rely on the fact that the Palm OS automatically mounts any recognized volumes inserted into or snapped onto the handheld. Thus, many applications can simply enumerate the mounted volumes and select one as appropriate. The following code illustrates how to do this:
</p>
<p class="CCodeCaption">
  <a name="1001248"> </a>Listing 7.1  Enumerating mounted volumes
</p>
<div class="CodeRule"><hr></div><pre class="CodeBlock">
UInt16 volRefNum;<a name="1001249"> </a>
UInt32 volIterator = vfsIteratorStart;<a name="1001250"> </a>
 <a name="1001251"> </a>
while (volIterator != vfsIteratorStop) {<a name="1001252"> </a>
   err = VFSVolumeEnumerate(&amp;volRefNum, &amp;volIterator);<a name="1001253"> </a>
   if (err == errNone) {<a name="1001254"> </a>
      // Do something with the volRefNum<a name="1001255"> </a>
   } else {<a name="1001256"> </a>
      // handle error... possibly by <a name="1001257"> </a>
      // breaking out of the loop<a name="1001258"> </a>
   }<a name="1001259"> </a>
}<a name="1001260"> </a>
</pre><div class="CodeRule"><hr></div>
<p class="Body">
  <a name="1001261"> </a>The volume reference number obtained from <a href="VFSMgr.html#1183274"><span style="font-family: monospace">VFSVolumeEnumerate</span></a> can then be used with many of the volume, directory, and file operations that are described later in this chapter.
</p>
<p class="Body">
  <a name="1001266"> </a>Occasionally an application needs to know more than that there is secondary storage available for use. Those applications likely need to take a few extra steps, beginning with checking each of the handheld's slots.
</p>

<h2 class="HBHeadB">
  <a name="1001269"> </a>Enumerating Slots
<a href="#1000865"><img src="images/top.gif" border="0"></a></h2>

<p class="Body">
  <a name="1001270"> </a>Before you can determine which expansion modules are attached to a Palm OS handheld, you must first determine how those modules could be attached. Expansion cards and some I/O devices could be plugged into physical slots, and snap-on modules could be connected through the handheld's universal connector. Irrespective of how they're physically connected, the Expansion Manager presents these to the developer as slots. Enumerating these slots is made simple due to the presence of the <a href="ExpansionManager.html#1107648"><span style="font-family: monospace">ExpSlotEnumerate</span></a> function. The use of this function is illustrated here:
</p>
<p class="CCodeCaption">
  <a name="1001275"> </a>Listing 7.2  Iterating through a handheld's expansion slots
</p>
<div class="CodeRule"><hr></div><pre class="CodeBlock">
UInt16 slotRefNum;<a name="1001276"> </a>
UInt32 slotIterator = expIteratorStart;<a name="1001277"> </a>
 <a name="1001278"> </a>
while (slotIterator != expIteratorStop) {<a name="1001279"> </a>
   // Get the slotRefNum for the next slot<a name="1001280"> </a>
   err = ExpSlotEnumerate(&amp;slotRefNum, &amp;slotIterator);<a name="1001281"> </a>
   if(err == errNone) {<a name="1001282"> </a>
      // perform slot-specific processing here<a name="1001283"> </a>
   } else {<a name="1001284"> </a>
      // handle error... possibly by<a name="1001285"> </a>
      // breaking out of the loop<a name="1001286"> </a>
}<a name="1001287"> </a>
</pre><div class="CodeRule"><hr></div>
<p class="Body">
  <a name="1001289"> </a>The slot reference number returned by <span style="font-family: monospace">ExpSlotEnumerate</span> uniquely identifies a given slot. This can be supplied to various Expansion Manager functions to obtain information about the slot, such as whether there is a card or other expansion module present in the slot.
</p>

<h4 class="HCHeadC">
  <a name="1001291"> </a>Checking a Slot for the Presence of a Card
</h4>
<p class="Body">
  <a name="1001296"> </a>Use the <a href="ExpansionManager.html#1107548"><span style="font-family: monospace">ExpCardPresent</span></a> function to determine if a card is present in a given slot. Given the slot reference number, this function returns <span style="font-family: monospace">errNone</span> if there is a card in the slot, or an error if either there is no card in the slot or there is a problem with the specified slot.
</p>

<h2 class="HBHeadB">
  <a name="1001298"> </a>Determining a Card's Capabilities
<a href="#1000865"><img src="images/top.gif" border="0"></a></h2>

<p class="Body">
  <a name="1001299"> </a>Just knowing that an expansion card is inserted into a slot or connected to the handheld isn't enough; your application needs to know something about the card to ensure that the operations it needs to perform are compatible with the card. For instance, if your application needs to write data to the card, its important to know if writing is permitted.
</p>
<p class="Body">
  <a name="1001300"> </a>The capabilities available to your application depend not only on the card but on the slot driver as well. Handheld manufacturers will provide one or more slot drivers that define standard interfaces to certain classes of expansion hardware. Card and device manufacturers may also choose to provide card-specific slot drivers, or they may require that applications use the slot custom control function and a registered creator code to access and control certain cards.
</p>
<p class="Body">
  <a name="1001301"> </a>The slot driver is responsible for querying expansion cards for a standard set of capabilities. When a slot driver is present for a given expansion card, you can use the <a href="ExpansionManager.html#1107500"><span style="font-family: monospace">ExpCardInfo</span></a> function to determine the following:
</p>

  <a name="1001306"> </a><p class="B1Bullet"> &#8226; the name of the expansion card's manufacturer</p>

  <a name="1001307"> </a><p class="B1Bullet"> &#8226; the name of the expansion card</p>

  <a name="1001308"> </a><p class="B1Bullet"> &#8226; the "device class," or type of expansion card. Values returned here might include "Ethernet" or "Backup"</p>

  <a name="1001309"> </a><p class="B1Bullet"> &#8226; a unique identifier for the device, such as a serial number</p>

  <a name="1001310"> </a><p class="B1Bullet"> &#8226; whether the card supports both reading and writing, or whether it is read-only</p>

  <a name="1001311"> </a><p class="B1Bullet"> &#8226; whether the card supports a simple serial interface</p>
<p class="Body">
  <a name="1001312"> </a>Note that the existence of the <span style="font-family: monospace">ExpCardInfo</span> function does not imply that all expansion cards support these capabilities. It only means that the slot driver is able to assess a card and report its findings up to the Expansion Manager.
</p>

<h2 class="HaHeadA">
  <a name="1001315"> </a>Volume Operations 
<a href="#1000865"><img src="images/top.gif" border="0"></a></h2>

<p class="Body">
  <a name="1001316"> </a>If an expansion card supports a file system, the VFS Manager allows you to perform a number of standard volume operations. To determine which volumes are currently mounted and available, use <a href="VFSMgr.html#1183274"><span style="font-family: monospace">VFSVolumeEnumerate</span></a>. This function, the use of which is illustrated in <a href="ExpAndVFSConcepts.html#1001246">"Checking for Mounted Volumes,"</a> returns a volume reference number that you then to supply to the remainder of the volume operations.
</p>
<p class="Body">
  <a name="1001324"> </a>When the user inserts a card containing a mountable volume into a slot (note that the current implementation only supports one volume per slot), the VFS Manager attempts to mount the volume automatically. You should rarely, if ever, have to mount volumes directly. You can attempt to mount a volume using a different file system, however, perhaps after installing a new file system driver on the handheld. To explicitly mount or unmount a volume, use <a href="VFSMgr.html#1183461"><span style="font-family: monospace">VFSVolumeMount</span></a> and <a href="VFSMgr.html#1183622"><span style="font-family: monospace">VFSVolumeUnmount</span></a>. When mounting a volume, you can either specify an explicit file system with which to mount the volume, or you can request that the VFS Manager try to determine the appropriate file system. If the VFS Manager cannot mount the volume using any of the available file systems, it attempts to format the volume using a file system deemed appropriate for the slot, and then mount it. See the description of <span style="font-family: monospace">VFSVolumeMount</span> in the <i>Palm OS Programmer's API Reference</i> for the precise arguments you must supply when explicitly mounting a volume.
</p>
<p class="Body">
  <a name="1001341"> </a>Use <a href="VFSMgr.html#1183315"><span style="font-family: monospace">VFSVolumeFormat</span></a> to format a volume. This function can be used to change the file system on the expansion card; you can explicitly indicate a file system to use when formatting it. Once the card has been formatted, the VFS Manager automatically mounts it; a new volume reference number is returned from <span style="font-family: monospace">VFSVolumeFormat</span>.
</p>
<p class="Body">
  <a name="1001350"> </a>The <a href="VFSMgr.html#1183388"><span style="font-family: monospace">VFSVolumeGetLabel</span></a> and <a href="VFSMgr.html#1183542"><span style="font-family: monospace">VFSVolumeSetLabel</span></a> functions get and set the volume label, respectively. Since the file system is responsible for verifying the validity of strings, you can try to set the volume label to any desired value. If the file system doesn't natively support the name given, the VFS Manager creates the <span style="font-family: monospace">/VOLUME.NAM</span> file used to support long volume names (see <a href="ExpAndVFSConcepts.html#1001411">"Naming Volumes"</a> for more information) or you get an error back if the file system doesn't support the supplied string.
</p>
<p class="Body">
  <a name="1001354"> </a>Additional information about the volume can be obtained through the use of <a href="VFSMgr.html#1183589"><span style="font-family: monospace">VFSVolumeSize</span></a> and <a href="VFSMgr.html#1183424"><span style="font-family: monospace">VFSVolumeInfo</span></a>. As the name implies, <span style="font-family: monospace">VFSVolumeSize</span> returns size information about the volume. In particular, it returns both the total amount of space on the volume, in bytes, and the amount of that volume's space that is currently in use, again in bytes. <span style="font-family: monospace">VFSVolumeInfo</span> returns various pieces of information about the volume, including:
</p>

  <a name="1001365"> </a><p class="B1Bullet"> &#8226; whether the volume is hidden</p>

  <a name="1001367"> </a><p class="B1Bullet"> &#8226; whether the volume is read-only</p>

  <a name="1001368"> </a><p class="B1Bullet"> &#8226; whether the volume is supported by a slot driver, or is being simulated by the Palm OS Emulator</p>

  <a name="1001369"> </a><p class="B1Bullet"> &#8226; the type and creator of the underlying file system</p>

  <a name="1001370"> </a><p class="B1Bullet"> &#8226; the slot with which the volume is associated, and the reference number of the slot driver controlling the slot</p>

  <a name="1001372"> </a><p class="B1Bullet"> &#8226; the type of media on which this volume is located, such as SD, CompactFlash, or Memory Stick</p>
<p class="Body">
  <a name="1001373"> </a>All of the above information is returned encapsulated within a <a href="VFSMgr.html#1181158"><span style="font-family: monospace">VolumeInfoType</span></a> structure. Whether the volume is hidden or read-only is further encoded into a single field within this structure; see <a href="VFSMgr.html#1181469">Volume Attributes</a> in the <i>Palm OS Programmer's API Reference</i> for the bits that make up this field.
</p>

<h2 class="HBHeadB">
  <a name="1001384"> </a>Hidden Volumes
<a href="#1000865"><img src="images/top.gif" border="0"></a></h2>

<p class="Body">
  <a name="1001385"> </a>Included among the volume attributes is a "hidden" bit, <span style="font-family: monospace">vfsVolumeAttrHidden</span>, that indicates whether the volume on the card is to be visible or hidden. Hidden volumes are typically not meant to be directly available to the user; the Launcher and the CardInfo application both ignore all hidden volumes.
</p>
<p class="Body">
  <a name="1001387"> </a>To make a volume hidden, simply create an empty file named <span style="font-family: monospace">HIDDEN.VOL</span> in the <span style="font-family: monospace">/PALM </span>directory. The <a href="VFSMgr.html#1183424"><span style="font-family: monospace">VFSVolumeInfo</span></a> function looks for this file and, if found, returns the <span style="font-family: monospace">vfsVolumeAttrHidden</span> bit along with the volume's other attributes.
</p>

<h2 class="HBHeadB">
  <a name="1001393"> </a>Matching Volumes to Slots
<a href="#1000865"><img src="images/top.gif" border="0"></a></h2>

<p class="Body">
  <a name="1001394"> </a>Many applications don't need to know the specifics of an expansion card as provided by the <a href="ExpansionManager.html#1107500"><span style="font-family: monospace">ExpCardInfo</span></a> function. Often, the information provided by the <a href="VFSMgr.html#1183424"><span style="font-family: monospace">VFSVolumeInfo</span></a> function is enough. Some applications need to know more about a particular volume, however. The name of the manufacturer or the type of card, for instance, may be important. 
</p>
<p class="Body">
  <a name="1001405"> </a>The <a href="VFSMgr.html#1181158"><span style="font-family: monospace">VolumeInfoType</span></a> structure returned from <span style="font-family: monospace">VFSVolumeInfo</span> contains a <span style="font-family: monospace">slotRefNum</span> field that can be passed to <span style="font-family: monospace">ExpCardInfo</span>. This allows you to obtain specific information about the card on which a particular volume is located.
</p>
<p class="Body">
  <a name="1001407"> </a>Although slot drivers currently only support one volume per slot, obtaining volume information that corresponds to a given slot reference number isn't quite so simple, since there isn't a function that returns the volume reference number given a slot reference number. You can, however, iterate through the mounted volumes and check each volume's slot reference number. This is the technique that the CardInfo application uses.
</p>

<h2 class="HBHeadB">
  <a name="1001411"> </a>Naming Volumes
<a href="#1000865"><img src="images/top.gif" border="0"></a></h2>

<p class="Body">
  <a name="1001412"> </a>Different file system libraries support volume names of different maximum lengths and have different restrictions on character sets. The file system library is responsible for verifying whether or not a given volume name is valid, and returns an error if it is not. From a Palm OS developer's standpoint, volume names can be up to 255 characters long, and can include any printable character.
</p>
<p class="Body">
  <a name="1001413"> </a>The file system library is responsible for translating the volume name into a format that is acceptable to the underlying file system. For example, in a file system where the 8.3 naming convention is used for filenames, to translate a long volume name the first eleven valid, non-space characters are used. Valid characters in this instance are A-Z, 0-9, $, %, ', -, _, @, ~, ', !, (, ), ^, #, and &amp;.
</p>
<p class="Body">
  <a name="1001414"> </a>When the underlying file system doesn't support a long volume name, <a href="VFSMgr.html#1183542"><span style="font-family: monospace">VFSVolumeSetLabel</span></a> creates the file <span style="font-family: monospace">/VOLUME.NAM</span> in an effort to preserve the long volume name. This file contains the following, in order: 
</p>

<h5 class="TgTable">
  <a name="1001443"> </a>

<table border="1" cellpadding="5" cellspacing="0">
  <caption></caption>
  <tr bgcolor="#CCCCCC" valign="top">
    <th><a name="1001420"> </a><div class="CellHeading">Field</div></th>
    <th><a name="1001422"> </a><div class="CellHeading">Description</div></th>
  </tr>
  <tr valign="top">
    <td><a name="1001424"> </a><div class="CellBody"><span style="font-family: monospace">Char cookie[4]</span></div></td>
    <td><a name="1001426"> </a><div class="CellBody">4 byte cookie that identifies this file. The value of this cookie is <span style="font-family: monospace">vfsVolumeNameFileCookie</span>.</div></td>
  </tr>
  <tr valign="top">
    <td><a name="1001428"> </a><div class="CellBody"><span style="font-family: monospace">UInt16 cacheLen</span></div></td>
    <td><a name="1001430"> </a><div class="CellBody">Big-endian length, in bytes, of the cached file-system-level volume label.</div></td>
  </tr>
  <tr valign="top">
    <td><a name="1001432"> </a><div class="CellBody"><span style="font-family: monospace">Char cacheLabel[cacheLen]</span></div></td>
    <td><a name="1001434"> </a><div class="CellBody">Unicode UCS-2 format string containing the volume label as it is stored in the file system layer. This is compared with the file system volume label to see if the user has changed the volume label on a device that doesn't support the <span style="font-family: monospace">/VOLUME.NAM</span> file. In this event, the file system volume label is used; the contents of <span style="font-family: monospace">/VOLUME.NAM</span> are ignored.</div></td>
  </tr>
  <tr valign="top">
    <td><a name="1001436"> </a><div class="CellBody"><span style="font-family: monospace">UInt16 length</span></div></td>
    <td><a name="1001438"> </a><div class="CellBody">Big-endian length, in bytes, of the long volume label.</div></td>
  </tr>
  <tr valign="top">
    <td><a name="1001440"> </a><div class="CellBody"><span style="font-family: monospace">Char label[length]</span></div></td>
    <td><a name="1001442"> </a><div class="CellBody">Unicode UCS-2 format string containing the long volume label.</div></td>
  </tr>
</table>




</h5>
<h2 class="HaHeadA">
  <a name="1001446"> </a>File Operations 
<a href="#1000865"><img src="images/top.gif" border="0"></a></h2>

<p class="Body">
  <a name="1001447"> </a>All of the familiar operations you'd use to operate on files in a desktop application are supported by the VFS Manager; these are listed in <a href="ExpAndVFSConcepts.html#1001455">"Common Operations,"</a> below. In addition, the VFS Manager includes a set of functions that simplify the way you work with files that represent Palm databases (<span style="font-family: monospace">.pdb</span>) or Palm resource databases (<span style="font-family: monospace">.prc</span>). These are covered in <a href="ExpAndVFSConcepts.html#1001634">"Working with Palm Databases."</a>
</p>

<h2 class="HBHeadB">
  <a name="1001455"> </a>Common Operations
<a href="#1000865"><img src="images/top.gif" border="0"></a></h2>

<p class="Body">
  <a name="1001456"> </a>The VFS Manager provides all of the standard file operations that should be familiar from desktop and larger computer systems. Because these functions work largely as you would expect, their use isn't detailed here. See the descriptions of each individual function in the <i>Palm OS Programmer's API Reference</i> for the arguments, return values, and side effects of each.
</p>
<p class="Body">
  <a name="1001460"> </a>Note that some of these functions can be applied to both files and directories, while others work only with files.
</p>

<h5 class="TgTable">
  <a name="1001615"> </a>

<table border="1" cellpadding="5" cellspacing="0">
  <caption><a name="1001466"> </a><div class="TableTitle">Table 7.2  Common file operations </div></caption>
  <tr bgcolor="#CCCCCC" valign="top">
    <th><a name="1001470"> </a><div class="CellHeading">Function</div></th>
    <th><a name="1001472"> </a><div class="CellHeading">Description</div></th>
  </tr>
  <tr valign="top">
    <td><a name="1001478"> </a><div class="CellBody"><a href="VFSMgr.html#1182499"><span style="font-family: monospace">VFSFileOpen</span></a></div></td>
    <td><a name="1001480"> </a><div class="CellBody">Open a file, given a volume reference number and a file path.</div></td>
  </tr>
  <tr valign="top">
    <td><a name="1001486"> </a><div class="CellBody"><a href="VFSMgr.html#1182090"><span style="font-family: monospace">VFSFileClose</span></a></div></td>
    <td><a name="1001488"> </a><div class="CellBody">Close an open file.</div></td>
  </tr>
  <tr valign="top">
    <td><a name="1001494"> </a><div class="CellBody"><a href="VFSMgr.html#1182551"><span style="font-family: monospace">VFSFileRead</span></a></div></td>
    <td><a name="1001496"> </a><div class="CellBody">Read data from a file into the dynamic heap or any writable memory.</div></td>
  </tr>
  <tr valign="top">
    <td><a name="1001502"> </a><div class="CellBody"><a href="VFSMgr.html#1182601"><span style="font-family: monospace">VFSFileReadData</span></a></div></td>
    <td><a name="1001504"> </a><div class="CellBody">Read data from a file into a chunk of memory in the storage heap.</div></td>
  </tr>
  <tr valign="top">
    <td><a name="1001510"> </a><div class="CellBody"><a href="VFSMgr.html#1182938"><span style="font-family: monospace">VFSFileWrite</span></a></div></td>
    <td><a name="1001512"> </a><div class="CellBody">Write data to an open file.</div></td>
  </tr>
  <tr valign="top">
    <td><a name="1001518"> </a><div class="CellBody"><a href="VFSMgr.html#1182734"><span style="font-family: monospace">VFSFileSeek</span></a></div></td>
    <td><a name="1001520"> </a><div class="CellBody">Set the position within an open file from which to read or write.</div></td>
  </tr>
  <tr valign="top">
    <td><a name="1001526"> </a><div class="CellBody"><a href="VFSMgr.html#1182903"><span style="font-family: monospace">VFSFileTell</span></a></div></td>
    <td><a name="1001528"> </a><div class="CellBody">Get the current position of the file pointer within an open file.</div></td>
  </tr>
  <tr valign="top">
    <td><a name="1001534"> </a><div class="CellBody"><a href="VFSMgr.html#1182388"><span style="font-family: monospace">VFSFileEOF</span></a></div></td>
    <td><a name="1001536"> </a><div class="CellBody">Get the end-of-file status for an open file.</div></td>
  </tr>
  <tr valign="top">
    <td><a name="1001542"> </a><div class="CellBody"><a href="VFSMgr.html#1182117"><span style="font-family: monospace">VFSFileCreate</span></a></div></td>
    <td><a name="1001544"> </a><div class="CellBody">Create a file, given a volume reference number and a file path.</div></td>
  </tr>
  <tr valign="top">
    <td><a name="1001550"> </a><div class="CellBody"><a href="VFSMgr.html#1182357"><span style="font-family: monospace">VFSFileDelete</span></a></div></td>
    <td><a name="1001552"> </a><div class="CellBody">Delete a closed file.</div></td>
  </tr>
  <tr valign="top">
    <td><a name="1001558"> </a><div class="CellBody"><a href="VFSMgr.html#1182655"><span style="font-family: monospace">VFSFileRename</span></a></div></td>
    <td><a name="1001560"> </a><div class="CellBody">Rename a closed file.</div></td>
  </tr>
  <tr valign="top">
    <td><a name="1001566"> </a><div class="CellBody"><a href="VFSMgr.html#1182865"><span style="font-family: monospace">VFSFileSize</span></a></div></td>
    <td><a name="1001568"> </a><div class="CellBody">Obtain the size of an open file.</div></td>
  </tr>
  <tr valign="top">
    <td><a name="1001574"> </a><div class="CellBody"><a href="VFSMgr.html#1182699"><span style="font-family: monospace">VFSFileResize</span></a></div></td>
    <td><a name="1001576"> </a><div class="CellBody">Change the size of an open file.</div></td>
  </tr>
  <tr valign="top">
    <td><a name="1001582"> </a><div class="CellBody"><a href="VFSMgr.html#1182415"><span style="font-family: monospace">VFSFileGetAttributes</span></a></div></td>
    <td><a name="1001584"> </a><div class="CellBody">Obtain the attributes of an open file, including hidden, read-only, system, and archive bits. See <a href="VFSMgr.html#1181400">"File and Directory Attributes"</a> in the <i>Palm OS Programmer's API Reference</i> for the bits that make up the attributes field.</div></td>
  </tr>
  <tr valign="top">
    <td><a name="1001596"> </a><div class="CellBody"><a href="VFSMgr.html#1182776"><span style="font-family: monospace">VFSFileSetAttributes</span></a></div></td>
    <td><a name="1001598"> </a><div class="CellBody">Set the attributes of an open file, including hidden, read-only, system, and archive bits.</div></td>
  </tr>
  <tr valign="top">
    <td><a name="1001604"> </a><div class="CellBody"><a href="VFSMgr.html#1182455"><span style="font-family: monospace">VFSFileGetDate</span></a></div></td>
    <td><a name="1001606"> </a><div class="CellBody">Get the created, modified, and last accessed dates for an open file.</div></td>
  </tr>
  <tr valign="top">
    <td><a name="1001612"> </a><div class="CellBody"><a href="VFSMgr.html#1182823"><span style="font-family: monospace">VFSFileSetDate</span></a></div></td>
    <td><a name="1001614"> </a><div class="CellBody">Set the created, modified, and last accessed dates for an open file.</div></td>
  </tr>
</table>




</h5><p class="Body">
  <a name="1001617"> </a>Once a file has been opened, it is identified by a unique reference number: a <a href="VFSMgr.html#1181060"><span style="font-family: monospace">FileRef</span></a>. Functions that work with open files take a file reference. Others, such as <span style="font-family: monospace">VFSFileOpen</span>, require a volume reference and a path that identifies the file within the volume. Note that all paths are volume relative, <b>and absolute within that volume</b>: the VFS Manager has no concept of a "current working directory," so relative path names are not supported. The directory separator character is the forward slash: "/". The root directory for the specified volume is specified by a path of "/".
</p>

<h2 class="HBHeadB">
  <a name="1001623"> </a>Naming Files
<a href="#1000865"><img src="images/top.gif" border="0"></a></h2>

<p class="Body">
  <a name="1001624"> </a>Different file systems support filenames and paths of different maximum lengths. The file system library is responsible for verifying whether or not a given path is valid and returns an error if it is not valid. From an application developer's standpoint, filenames can be up to 255 characters long and can include any normal character including spaces and lower case characters in any character set. They can also include the following special characters:
</p>
<p class="Body">
  <a name="1001625"> </a><span style="font-family: monospace">$ % ' - _ @ ~ </span><span style="color: #333;;  font-style: oblique; font-weight: bold; text-decoration: none; text-transform: none; vertical-align: baseline">'</span><i> </i><span style="font-family: monospace">! ( ) ^ # &amp; + , ; = [ ]</span>
</p>
<p class="Body">
  <a name="1001626"> </a>The file system library is responsible for translating each filename and path into a format that is acceptable to the underlying file system. For example, when the 8.3 naming convention is used to translate a long filename, the following guidelines are used:
</p>

  <a name="1001627"> </a><p class="B1Bullet"> &#8226; The name is created from the first six valid, non-space characters which appear before the last period. The only valid characters are A-Z, 0-9, $, %, ', -, _, @, ~, ', !, (, ), ^, #, and &amp;.</p>

  <a name="1001628"> </a><p class="B1Bullet"> &#8226; The extension is the first three valid characters after the last period.</p>

  <a name="1001629"> </a><p class="B1Bullet"> &#8226; The end of the six byte name has "~1" appended to it for the first occurrence of the shortened filename. Each subsequent occurrence uses the next unique number, so the second occurrence would have "~2" appended, and so on.</p>
<p class="Body">
  <a name="1001631"> </a>The standard VFAT file system library provided with all Palm Powered handhelds that support expansion uses the above rules to create FAT-compliant names from long filenames.
</p>

<h2 class="HBHeadB">
  <a name="1001634"> </a>Working with Palm Databases
<a href="#1000865"><img src="images/top.gif" border="0"></a></h2>

<p class="Body">
  <a name="1001635"> </a>Expansion cards are often used to hold Palm applications and data in <span style="font-family: monospace">.prc</span> and <span style="font-family: monospace">.pdb</span> format. Due to the way that secondary storage media are connected to the Palm Powered handheld, applications cannot be run directly from the expansion card, nor can databases be manipulated using the Data Manager without first transferring them to main memory. Applications written to use the VFS Manager, however, can operate directly on files located on an expansion card.
</p>
<div class="NINoteImportant"><hr>
  <a name="1001637"> </a> <span style="color: #333;  font-style: normal; font-weight: bold; text-decoration: none; text-transform: none; vertical-align: baseline">NOTE:  </span> Whenever possible give the same name to the <span style="font-family: monospace">.prc</span> file and to the database. If the <span style="font-family: monospace">.prc</span> filename differs from the database name, and the user copies your application from the card to the handheld and then to another card, the filename may change. This is because the database name is used when an application is copied from the handheld to the card.
<hr>
</div>

<h4 class="HCHeadC">
  <a name="1001638"> </a>Stand-Alone Applications
</h4>
<p class="Body">
  <a name="1001640"> </a>To allow the user to run an application that is self-contained-that isn't accompanied by a separate database-you need only do one of two things:
</p>

  <a name="1001641"> </a><p class="B1Bullet"> &#8226; If the application is to be run whenever the card is inserted into the expansion slot, simply name the application <span style="font-family: monospace">start.prc</span> and place it in the <span style="font-family: monospace">/PALM </span>directory. The operating system takes care of transferring the application to main memory and starting it automatically.</p>

  <a name="1001643"> </a><p class="B1Bullet"> &#8226; If the application is to be run on-demand, place it in the <span style="font-family: monospace">/PALM/Launcher</span> directory. All applications located in this directory appear in the launcher when the user selects the category bearing the name of the expansion card.</p>
<p class="Body">
  <a name="1001644"> </a>Both of these mechanisms allow applications that were written without any knowledge of the VFS or Expansion Manager APIs to be run from a card. Because they are transferred to main memory prior to being run, such applications need not know that they are being run from an expansion card. Databases created by these applications are placed in the storage heap, as usual. When the card containing the application is removed, the application disappears from main memory unless it is running, in which case it remains until such time as the application is no longer running. Any databases it created remain. When the card is re-inserted and the application re-run, it is once again copied into main memory and is able to access those databases.
</p>

<h4 class="HCHeadC">
  <a name="1001645"> </a>Applications with Static Data
</h4>
<p class="Body">
  <a name="1001646"> </a>Many applications are accompanied by one or more associated Palm databases when installed. These applications, at least to a limited degree, need to be cognizant of the fact that they reside on an expansion card.
</p>
<p class="Body">
  <a name="1001658"> </a>If there is no specific requirement for the application's data to be stored in Palm database format, you may want to use the VFS Manager's many file I/O operations to read and write the data on the card. Because of the large data storage capabilities of the expansion media relative to the handheld's memory, this latter solution is the one preferred by applications where large capacity data storage is a key feature.
</p>

<h5 class="HDHeadD">
  <a name="1001660"> </a>Bundled Databases
</h5>
<p class="Body">
  <a name="1001661"> </a>When an application is launched from a card using the launcher, any bundled databases present in the <span style="font-family: monospace">/PALM/Launcher</span> directory are also imported. Bundled databases have the same creator as the "owning" application and have the <span style="font-family: monospace">dmHdrAttrBundle</span> bit set. Note that bundled databases are intended only for read-only data, such as a game-level database. Bundled databases are removed from main memory along with the application when the user switches to another application and are not copied back to the expansion card.
</p>

<h4 class="HCHeadC">
  <a name="1001662"> </a>Transferring Palm Databases to and from Expansion Cards
</h4>
<p class="Body">
  <a name="1001667"> </a>The <a href="VFSMgr.html#1181987"><span style="font-family: monospace">VFSExportDatabaseToFile</span></a> function converts a database from its internal format on the handheld to its equivalent <span style="font-family: monospace">.prc</span> or <span style="font-family: monospace">.pdb</span> file format and transfers it to an expansion card. The <a href="VFSMgr.html#1183026"><span style="font-family: monospace">VFSImportDatabaseFromFile</span></a> function does the reverse; it transfers the <span style="font-family: monospace">.prc</span> or <span style="font-family: monospace">.pdb</span> file to main memory and converts it to the internal format used by the Palm OS. Use these functions when moving Palm databases between main memory and an expansion card. These two functions rely upon Exchange Manager routines to convert and transfer the data; see <a href="ExchangeManagerConcept.html#969979">Chapter 1</a>, "<a href="ExchangeManagerConcept.html#969979">Object Exchange</a>" in <i>Palm OS Programmer's Companion</i>, vol. II, <i>Communications</i> for more information on using the Exchange Manager to send and receive data.
</p>
<p class="Body">
  <a name="1001680"> </a>The <span style="font-family: monospace">VFSExportDatabaseToFile</span> and <span style="font-family: monospace">VFSImportDatabaseFromFile</span> routines are atomic and, depending on the size of the database and the mechanism by which it is being transferred, can take some time. Use <a href="VFSMgr.html#1182034"><span style="font-family: monospace">VFSExportDatabaseToFileCustom</span></a> and <a href="VFSMgr.html#1183078"><span style="font-family: monospace">VFSImportDatabaseFromFileCustom</span></a> if you want to display a progress dialog or allow the user to cancel the operation. These routines make repeated calls to a callback function that you specify; within this callback function you can update a progress indicator. The return value from your callback determines whether the database transfer should proceed; return <span style="font-family: monospace">errNone</span> if it should continue, or return any other value to abort the process. See the documentation for <a href="VFSMgr.html#1183659"><span style="font-family: monospace">VFSExportProcPtr</span></a> and <a href="VFSMgr.html#1183698"><span style="font-family: monospace">VFSImportProcPtr</span></a> in the <i>Palm OS Programmer's API Reference</i> for the format of each callback function.
</p>
<p class="Body">
  <a name="1001698"> </a>The following code excerpt illustrates the use of <span style="color: #333;;  font-style: normal; font-weight: normal; text-decoration: none; text-transform: none; vertical-align: baseline">VFSImportDatabaseFromFileCustom</span> with a progress tracker.
</p>
<p class="CCodeCaption">
  <a name="1001699"> </a>Listing 7.3  Using VFSImportDatabaseFromFileCustom
</p>
<div class="CodeRule"><hr></div><pre class="CodeBlock">
typedef struct {<a name="1001700"> </a>
   ProgressType *progressP;<a name="1001701"> </a>
   const Char   *nameP;<a name="1001702"> </a>
} CBDataType, *CBDataPtr;<a name="1001703"> </a>
 <a name="1001704"> </a>
static Boolean ProgressTextCB(PrgCallbackDataPtr cbP) {<a name="1001705"> </a>
   const Char *nameP = ((CBDataPtr) cbP-&gt;userDataP)-&gt;nameP;<a name="1001706"> </a>
 <a name="1001707"> </a>
   // Set up the progress text to be displayed<a name="1001708"> </a>
   StrPrintF(cbP-&gt;textP, "Importing %s.", nameP);<a name="1001709"> </a>
   cbP-&gt;textChanged = true;<a name="1001710"> </a>
   <a name="1001711"> </a>
   return true;  // So what we specify here is used to update the dialog<a name="1001712"> </a>
}<a name="1001713"> </a>
 <a name="1001714"> </a>
static Err CopyProgressCB(UInt32 size, UInt32 offset, void *userDataP) {<a name="1001715"> </a>
   CBDataPtr CBDataP = (CBDataPtr) userDataP;<a name="1001716"> </a>
   <a name="1001717"> </a>
   if (offset == 0) {  // If we're just starting, we need to set up the dialog<a name="1001718"> </a>
      CBDataP-&gt;progressP = PrgStartDialog("Importing Database", ProgressTextCB,
         CBDataP);<a name="1001719"> </a>
      <a name="1001720"> </a>
      if (!CBDataP-&gt;progressP)<a name="1001721"> </a>
         return memErrNotEnoughSpace;<a name="1001722"> </a>
   } else {<a name="1001723"> </a>
      EventType event;<a name="1001724"> </a>
      Boolean   handled;<a name="1001725"> </a>
 <a name="1001726"> </a>
      do {<a name="1001727"> </a>
         EvtGetEvent(&amp;event, 0);  // Check for events<a name="1001728"> </a>
 <a name="1001729"> </a>
         handled = PrgHandleEvent(CBDataP-&gt;progressP, &amp;event);<a name="1001730"> </a>
         <a name="1001731"> </a>
         if (!handled) {  // Did the user tap the "Cancel" button?<a name="1001732"> </a>
            if( PrgUserCancel(CBDataP-&gt;progressP) )<a name="1001733"> </a>
               return exgErrUserCancel;<a name="1001734"> </a>
         }<a name="1001735"> </a>
      } while(event.eType != sysEventNilEvent);<a name="1001736"> </a>
   }<a name="1001737"> </a>
      <a name="1001738"> </a>
   return errNone;		<a name="1001739"> </a>
}<a name="1001740"> </a>
 <a name="1001741"> </a>
static Err ImportFile(UInt16 volRefNum, Char *pathP, Char *nameP, 
   UInt16 *cardNoP, LocalID *dbIDP) <a name="1001742"> </a>
{<a name="1001743"> </a>
   CBDataType userData;<a name="1001744"> </a>
   Char       fullPathP[256];<a name="1001745"> </a>
   Err        err;<a name="1001746"> </a>
 <a name="1001747"> </a>
   userData.progressP = NULL;<a name="1001748"> </a>
   userData.nameP = nameP;<a name="1001749"> </a>
   <a name="1001750"> </a>
   StrPrintF(fullPathP, "%s/%s", pathP, nameP); // rebuild full path to the file<a name="1001751"> </a>
   err = VFSImportDatabaseFromFileCustom(volRefNum, fullPathP, cardNoP, dbIDP,
      CopyProgressCB, &amp;userData);<a name="1001752"> </a>
 <a name="1001753"> </a>
   if (userData.progressP) // If the progress dialog was displayed, remove it.<a name="1001754"> </a>
      PrgStopDialog(userData.progressP, (err == exgErrUserCancel) );<a name="1001755"> </a>
   <a name="1001756"> </a>
   return err;<a name="1001757"> </a>
}<a name="1001758"> </a>
</pre><div class="CodeRule"><hr></div>

<h4 class="HCHeadC">
  <a name="1001760"> </a>Exploring Palm Databases on Expansion Cards
</h4>
<p class="Body">
  <a name="1001761"> </a>The VFS Manager includes functions specifically designed for exploring the contents of a Palm database located on an expansion card. This access is read-only, however. You can extract individual records and resources from a database, and you can determine information such as the last modification date of a database on an expansion card. But there aren't parallel functions to write records and resources to a database or to update database-specific information for a database that is located on an expansion card. To do this you need to import the database into main memory, make the necessary changes, and then export it back to the expansion card.
</p>
<p class="Body">
  <a name="1001762"> </a>To obtain a single record from a database located on an expansion card without first importing the database into main memory, use <a href="VFSMgr.html#1182173"><span style="font-family: monospace">VFSFileDBGetRecord</span></a>. This function is analogous to <a href="DataAndResourceManager.html#1096247"><span style="font-family: monospace">DmGetRecord</span></a> but works with files on an external card rather than with databases in main memory. It transfers the specified record to the storage heap after allocating a handle of the appropriate size. Note that you'll need to free this memory, using <a href="MemoryManager.html#1132656"><span style="font-family: monospace">MemHandleFree</span></a>, when the record is no longer needed.
</p>
<p class="Body">
  <a name="1001777"> </a>The <a href="VFSMgr.html#1182230"><span style="font-family: monospace">VFSFileDBGetResource</span></a> function operates in a similar fashion, but instead of loading a particular database record it loads a specified resource from a resource database located on an expansion card. This resource is put onto the storage heap. Again, free this memory once the resource is no longer needed.
</p>
<p class="Body">
  <a name="1001778"> </a>To obtain more general information about a database on an external card, use <a href="VFSMgr.html#1182269"><span style="font-family: monospace">VFSFileDBInfo</span></a>. In addition to the information you could obtain about any file on an external card using the <a href="VFSMgr.html#1182415"><span style="font-family: monospace">VFSFileGetAttributes</span></a> and <a href="VFSMgr.html#1182455"><span style="font-family: monospace">VFSFileGetDate</span></a> functions, <span style="font-family: monospace">VFSFileDBInfo</span> returns:
</p>

  <a name="1001788"> </a><p class="B1Bullet"> &#8226; the database name</p>

  <a name="1001789"> </a><p class="B1Bullet"> &#8226; the version of the database</p>

  <a name="1001790"> </a><p class="B1Bullet"> &#8226; the number of times the database was modified</p>

  <a name="1001791"> </a><p class="B1Bullet"> &#8226; the application info block handle</p>

  <a name="1001792"> </a><p class="B1Bullet"> &#8226; the sort info block handle</p>

  <a name="1001793"> </a><p class="B1Bullet"> &#8226; the database's type</p>

  <a name="1001794"> </a><p class="B1Bullet"> &#8226; the database's creator</p>

  <a name="1001795"> </a><p class="B1Bullet"> &#8226; the number of records in the database</p>
<div class="NINoteImportant"><hr>
  <a name="1001796"> </a> <span style="color: #333;  font-style: normal; font-weight: bold; text-decoration: none; text-transform: none; vertical-align: baseline">NOTE:  </span> The functions described in this section incur a lot of overhead in order to parse the database file format. Frequent use of these functions is not recommended. Also, if you request either the application info block handle or the sort info block handle, you must free the handle when it is no longer needed.
<hr>
</div>

<h2 class="HaHeadA">
  <a name="1001799"> </a>Directory Operations 
<a href="#1000865"><img src="images/top.gif" border="0"></a></h2>

<p class="Body">
  <a name="1001800"> </a>All of the familiar operations you'd use to operate on directories are supported by the VFS Manager; these are listed in <a href="ExpAndVFSConcepts.html#1001813">"Common Operations"</a>, below. One common operation-determining the files that are contained within a given directory-is covered in some detail in <a href="ExpAndVFSConcepts.html#1001908">"Enumerating the Files in a Directory."</a> To improve data interchange with devices that aren't running the Palm OS, expansion card manufacturers have specified default directories for certain file types. <a href="ExpAndVFSConcepts.html#1001944">"Determining the Default Directory for a Particular File Type"</a> discusses how you can both determine and set the default directory for a given file type.
</p>

<h2 class="HBHeadB">
  <a name="1001810"> </a>Directory Paths
<a href="#1000865"><img src="images/top.gif" border="0"></a></h2>

<p class="Body">
  <a name="1001811"> </a>All paths are volume relative, <b>and absolute within that volume</b>: the VFS Manager has no concept of a "current working directory," so relative path names are not supported. The directory separator character is the forward slash: "/". The root directory for the specified volume is specified by a path of "/".
</p>

<h2 class="HBHeadB">
  <a name="1001813"> </a>Common Operations
<a href="#1000865"><img src="images/top.gif" border="0"></a></h2>

<p class="Body">
  <a name="1001814"> </a>The VFS Manager provides all of the standard directory operations that should be familiar from desktop and larger computer systems. Because these functions work largely as you would expect, their use isn't detailed here. See the descriptions of each individual function in the <i>Palm OS Programmer's API Reference</i> for the arguments, return values, and side effects of each.
</p>
<p class="Body">
  <a name="1001818"> </a>Note that most of these functions can be applied to files as well as directories.

<table border="1" cellpadding="5" cellspacing="0">
  <caption><a name="1001821"> </a><div class="TableTitle">Table 7.3  Common directory operations </div></caption>
  <tr bgcolor="#CCCCCC" valign="top">
    <th><a name="1001825"> </a><div class="CellHeading">Function</div></th>
    <th><a name="1001827"> </a><div class="CellHeading">Description</div></th>
  </tr>
  <tr valign="top">
    <td><a name="1001833"> </a><div class="CellBody"><a href="VFSMgr.html#1181880"><span style="font-family: monospace">VFSDirCreate</span></a></div></td>
    <td><a name="1001835"> </a><div class="CellBody">Create a new directory.</div></td>
  </tr>
  <tr valign="top">
    <td><a name="1001841"> </a><div class="CellBody"><a href="VFSMgr.html#1182357"><span style="font-family: monospace">VFSFileDelete</span></a></div></td>
    <td><a name="1001843"> </a><div class="CellBody">Delete a directory, given a path.</div></td>
  </tr>
  <tr valign="top">
    <td><a name="1001849"> </a><div class="CellBody"><a href="VFSMgr.html#1182655"><span style="font-family: monospace">VFSFileRename</span></a></div></td>
    <td><a name="1001851"> </a><div class="CellBody">Rename a directory.</div></td>
  </tr>
  <tr valign="top">
    <td><a name="1001857"> </a><div class="CellBody"><a href="VFSMgr.html#1182499"><span style="font-family: monospace">VFSFileOpen</span></a></div></td>
    <td><a name="1001859"> </a><div class="CellBody">Open the file or directory.</div></td>
  </tr>
  <tr valign="top">
    <td><a name="1001865"> </a><div class="CellBody"><a href="VFSMgr.html#1182090"><span style="font-family: monospace">VFSFileClose</span></a></div></td>
    <td><a name="1001867"> </a><div class="CellBody">Close the file or directory.</div></td>
  </tr>
  <tr valign="top">
    <td><a name="1001873"> </a><div class="CellBody"><a href="VFSMgr.html#1182415"><span style="font-family: monospace">VFSFileGetAttributes</span></a></div></td>
    <td><a name="1001875"> </a><div class="CellBody">Obtain the attributes of an open directory, including hidden, read-only, system, and archive bits. See <a href="VFSMgr.html#1181400">"File and Directory Attributes"</a> in the <i>Palm OS Programmer's API Reference</i> for the bits that make up the attributes field.</div></td>
  </tr>
  <tr valign="top">
    <td><a name="1001887"> </a><div class="CellBody"><a href="VFSMgr.html#1182776"><span style="font-family: monospace">VFSFileSetAttributes</span></a></div></td>
    <td><a name="1001889"> </a><div class="CellBody">Set the attributes of an open directory, including hidden, read-only, system, and archive bits.</div></td>
  </tr>
  <tr valign="top">
    <td><a name="1001895"> </a><div class="CellBody"><a href="VFSMgr.html#1182455"><span style="font-family: monospace">VFSFileGetDate</span></a></div></td>
    <td><a name="1001897"> </a><div class="CellBody">Get the created, modified, and last accessed dates for an open file.</div></td>
  </tr>
  <tr valign="top">
    <td><a name="1001903"> </a><div class="CellBody"><a href="VFSMgr.html#1182823"><span style="font-family: monospace">VFSFileSetDate</span></a></div></td>
    <td><a name="1001905"> </a><div class="CellBody">Set the created, modified, and last accessed dates for an open file.</div></td>
  </tr>
</table>




</p>

<h2 class="HBHeadB">
  <a name="1001908"> </a>Enumerating the Files in a Directory
<a href="#1000865"><img src="images/top.gif" border="0"></a></h2>

<p class="Body">
  <a name="1001909"> </a>Enumerating the files within a directory is made simple due to the presence of the <a href="VFSMgr.html#1181918"><span style="font-family: monospace">VFSDirEntryEnumerate</span></a> function. The use of this function is illustrated below. Note that <span style="font-family: monospace">volRefNum</span> and <span style="font-family: monospace">dirPathStr</span> must be declared and initialized prior to the following code.
</p>
<p class="CCodeCaption">
  <a name="1001914"> </a>Listing 7.4  Enumerating a directory's contents
</p>
<div class="CodeRule"><hr></div><pre class="CodeBlock">
// Open the directory and iterate through the files in it.<a name="1001915"> </a>
// volRefNum must have already been defined.<a name="1001916"> </a>
err = VFSFileOpen(volRefNum, "/", vfsModeRead, &amp;dirRef);<a name="1001917"> </a>
if(err == errNone) {<a name="1001918"> </a>
   // Iterate through all the files in the open directory<a name="1001919"> </a>
   UInt32 fileIterator;<a name="1001920"> </a>
   FileInfoType fileInfo;<a name="1001921"> </a>
   FileRef dirRef;<a name="1001922"> </a>
   Char *fileName = MemPtrNew(256);   // should check for err<a name="1001923"> </a>
 <a name="1001924"> </a>
   fileInfo.nameP = fileName;    // point to local buffer<a name="1001925"> </a>
   fileInfo.nameBufLen = sizeof(fileName);<a name="1001926"> </a>
   fileIterator = expIteratorStart;<a name="1001927"> </a>
   while (fileIterator != expIteratorStop) {<a name="1001928"> </a>
      // Get the next file<a name="1001929"> </a>
      err = VFSDirEntryEnumerate(dirRef, &amp;fileIterator,
            &amp;fileInfo);<a name="1001930"> </a>
      if(err == errNone) {<a name="1001931"> </a>
         // Process the file here.<a name="1001932"> </a>
      }<a name="1001933"> </a>
   } else {<a name="1001934"> </a>
      // handle directory open error here<a name="1001935"> </a>
   }<a name="1001936"> </a>
   MemPtrFree(fileName);<a name="1001937"> </a>
}<a name="1001938"> </a>
</pre><div class="CodeRule"><hr></div>
<p class="Body">
  <a name="1001939"> </a>Each time through the while loop, <span style="font-family: monospace">VFSDirEntryEnumerate</span> sets the <a href="VFSMgr.html#1181030"><span style="font-family: monospace">FileInfoType</span></a> structure as appropriate for the file currently being enumerated. Note that if you want the file name it isn't enough to simply allocate space for the <span style="font-family: monospace">FileInfoType</span> structure; you must also allocate a buffer for the filename, set the appropriate pointer to it in the <span style="font-family: monospace">FileInfoType</span> structure, and specify your buffer's length. Since the only other information encapsulated within <span style="font-family: monospace">FileInfoType</span> is the file's attributes, most applications will want to also know the file's name.
</p>

<h2 class="HBHeadB">
  <a name="1001944"> </a>Determining the Default Directory for a Particular File Type
<a href="#1000865"><img src="images/top.gif" border="0"></a></h2>

<p class="Body">
  <a name="1001949"> </a>As explained in <a href="ExpAndVFSConcepts.html#1001026">"Standard Directories,"</a> the expansion capabilities of Palm OS 4.0 include a mechanism to map MIME types or file extensions to specific directory names. This mechanism is specific to the slot driver: where an image might be stored in the "/Images" directory on a Memory Stick, on an MMC card it may be stored in the "/DCIM" directory. The VFS Manager includes a function that enables you to get the default directory on a particular volume for a given file extension or MIME type, along with functions that allow you to register and un-register your own default directories.
</p>
<p class="Body">
  <a name="1001955"> </a>The <a href="VFSMgr.html#1182983"><span style="font-family: monospace">VFSGetDefaultDirectory</span></a> function takes a volume reference and a string containing the file extension or MIME type and returns a string containing the full path to the corresponding default directory. When specifying the file type, either supply a MIME media type/subtype pair, such as "image/jpeg", "text/plain", or "audio/basic"; or a file extension, such as "<span style="font-family: monospace">.jpeg</span>". As with most other Palm OS functions, you'll need to pre-allocate a buffer to contain the returned path. Supply a pointer to this buffer along with the buffer's length. The length is updated upon return to indicate the actual length of the path, which won't exceed the originally-specified buffer length.
</p>
<p class="Body">
  <a name="1001957"> </a>The default directory registered for a given file type is intended to be the "root" default directory. If a given default directory has one or more subdirectories, applications should also search those subdirectories for files of the appropriate type.
</p>
<p class="Body">
  <a name="1001958"> </a><span style="font-family: monospace">VFSGetDefaultDirectory</span> allows you to determine the directory associated with a particular file suffix. However, there's no way to get the entire list of file suffixes that are mapped to default directories. For this reason, CardInfo keeps its own list of possible file suffixes. It iterates through this list, calling <span style="font-family: monospace">VFSGetDefaultDirectory</span> for each file suffix to get the full path to the corresponding default directory. It then looks into each default directory for files that match the expected suffix or suffixes for that directory.
</p>

<h4 class="HCHeadC">
  <a name="1001961"> </a>Registering New Default Directories
</h4>
<p class="Body">
  <a name="1001962"> </a>In addition to the default directories that the underlying slot driver is already aware of, you can create your own mappings between files of a given type and a specific directory on a particular kind of external storage card. Most applications don't need this functionality; it is generally used by a slot driver to register those files and media types that are supported by that slot driver. However, <a href="VFSMgr.html#1183168"><span style="font-family: monospace">VFSRegisterDefaultDirectory</span></a> and its opposite, <a href="VFSMgr.html#1183236"><span style="font-family: monospace">VFSUnregisterDefaultDirectory</span></a>, are available to those applications that need them. Such applications should generally register the desired file types for <span style="font-family: monospace">expMediaType_Any</span>. This is a wildcard which works for all media types; it can be overridden by a registration that specifies a real media type.
</p>
<p class="Body">
  <a name="1001971"> </a>If a default directory has already been registered for a given file/media type combination, applications should use the pre-existing registration instead of establishing a new one. Existing registrations should generally not be removed.
</p>

<h2 class="HBHeadB">
  <a name="1001973"> </a>Default Directories Registered at Initialization
<a href="#1000865"><img src="images/top.gif" border="0"></a></h2>

<p class="Body">
  <a name="1001974"> </a>The VFS Manager registers the following under the <span style="font-family: monospace">expMediaType_Any</span> media type, which <a href="VFSMgr.html#1182983"><span style="font-family: monospace">VFSGetDefaultDirectory</span></a> reverts to when there is no default registered by the slot driver for a given media type. 
</p>

<h5 class="TgTable">
  <a name="1002070"> </a>

<table border="1" cellpadding="5" cellspacing="0">
  <caption><a name="1001983"> </a><div class="TableTitle">Table 7.4  Default registrations </div></caption>
  <tr bgcolor="#CCCCCC" valign="top">
    <th><a name="1001987"> </a><div class="CellHeading">File Type</div></th>
    <th><a name="1001989"> </a><div class="CellHeading">Path</div></th>
  </tr>
  <tr valign="top">
    <td><a name="1001991"> </a><div class="CellBody"><span style="font-family: monospace">.prc</span></div></td>
    <td><a name="1001993"> </a><div class="CellBody"><span style="font-family: monospace">/PALM/Launcher/</span></div></td>
  </tr>
  <tr valign="top">
    <td><a name="1001995"> </a><div class="CellBody"><span style="font-family: monospace">.pdb</span></div></td>
    <td><a name="1001997"> </a><div class="CellBody"><span style="font-family: monospace">/PALM/Launcher/</span></div></td>
  </tr>
  <tr valign="top">
    <td><a name="1001999"> </a><div class="CellBody"><span style="font-family: monospace">.pqa</span></div></td>
    <td><a name="1002001"> </a><div class="CellBody"><span style="font-family: monospace">/PALM/Launcher/</span></div></td>
  </tr>
  <tr valign="top">
    <td><a name="1002003"> </a><div class="CellBody"><span style="font-family: monospace">application/vnd.palm</span></div></td>
    <td><a name="1002005"> </a><div class="CellBody"><span style="font-family: monospace">/PALM/Launcher/</span></div></td>
  </tr>
  <tr valign="top">
    <td><a name="1002007"> </a><div class="CellBody"><span style="font-family: monospace">.jpg</span></div></td>
    <td><a name="1002009"> </a><div class="CellBody"><span style="font-family: monospace">/DCIM/</span></div></td>
  </tr>
  <tr valign="top">
    <td><a name="1002011"> </a><div class="CellBody"><span style="font-family: monospace">.jpeg</span></div></td>
    <td><a name="1002013"> </a><div class="CellBody"><span style="font-family: monospace">/DCIM/</span></div></td>
  </tr>
  <tr valign="top">
    <td><a name="1002015"> </a><div class="CellBody"><span style="font-family: monospace">image/jpeg</span></div></td>
    <td><a name="1002017"> </a><div class="CellBody"><span style="font-family: monospace">/DCIM/</span></div></td>
  </tr>
  <tr valign="top">
    <td><a name="1002019"> </a><div class="CellBody"><span style="font-family: monospace">.gif</span></div></td>
    <td><a name="1002021"> </a><div class="CellBody"><span style="font-family: monospace">/DCIM/</span></div></td>
  </tr>
  <tr valign="top">
    <td><a name="1002023"> </a><div class="CellBody"><span style="font-family: monospace">image/gif</span></div></td>
    <td><a name="1002025"> </a><div class="CellBody"><span style="font-family: monospace">/DCIM/</span></div></td>
  </tr>
  <tr valign="top">
    <td><a name="1002027"> </a><div class="CellBody"><span style="font-family: monospace">.qt</span></div></td>
    <td><a name="1002029"> </a><div class="CellBody"><span style="font-family: monospace">/DCIM/</span></div></td>
  </tr>
  <tr valign="top">
    <td><a name="1002031"> </a><div class="CellBody"><span style="font-family: monospace">.mov</span></div></td>
    <td><a name="1002033"> </a><div class="CellBody"><span style="font-family: monospace">/DCIM/</span></div></td>
  </tr>
  <tr valign="top">
    <td><a name="1002035"> </a><div class="CellBody"><span style="font-family: monospace">video/quicktime</span></div></td>
    <td><a name="1002037"> </a><div class="CellBody"><span style="font-family: monospace">/DCIM/</span></div></td>
  </tr>
  <tr valign="top">
    <td><a name="1002039"> </a><div class="CellBody"><span style="font-family: monospace">.avi</span></div></td>
    <td><a name="1002041"> </a><div class="CellBody"><span style="font-family: monospace">/DCIM/</span></div></td>
  </tr>
  <tr valign="top">
    <td><a name="1002043"> </a><div class="CellBody"><span style="font-family: monospace">video/x-msvideo</span></div></td>
    <td><a name="1002045"> </a><div class="CellBody"><span style="font-family: monospace">/DCIM/</span></div></td>
  </tr>
  <tr valign="top">
    <td><a name="1002047"> </a><div class="CellBody"><span style="font-family: monospace">.mpg</span></div></td>
    <td><a name="1002049"> </a><div class="CellBody"><span style="font-family: monospace">/DCIM/</span></div></td>
  </tr>
  <tr valign="top">
    <td><a name="1002051"> </a><div class="CellBody"><span style="font-family: monospace">.mpeg</span></div></td>
    <td><a name="1002053"> </a><div class="CellBody"><span style="font-family: monospace">/DCIM/</span></div></td>
  </tr>
  <tr valign="top">
    <td><a name="1002055"> </a><div class="CellBody"><span style="font-family: monospace">video/mpeg</span></div></td>
    <td><a name="1002057"> </a><div class="CellBody"><span style="font-family: monospace">/DCIM/</span></div></td>
  </tr>
  <tr valign="top">
    <td><a name="1002059"> </a><div class="CellBody"><span style="font-family: monospace">.mp3</span></div></td>
    <td><a name="1002061"> </a><div class="CellBody"><span style="font-family: monospace">/AUDIO/</span></div></td>
  </tr>
  <tr valign="top">
    <td><a name="1002063"> </a><div class="CellBody"><span style="font-family: monospace">.wav</span></div></td>
    <td><a name="1002065"> </a><div class="CellBody"><span style="font-family: monospace">/AUDIO/</span></div></td>
  </tr>
  <tr valign="top">
    <td><a name="1002067"> </a><div class="CellBody"><span style="font-family: monospace">audio/x-wav</span></div></td>
    <td><a name="1002069"> </a><div class="CellBody"><span style="font-family: monospace">/AUDIO/</span></div></td>
  </tr>
</table>




</h5><p class="Body">
  <a name="1002072"> </a>The SD slot driver provided by PalmSource, Inc. registers the following, since it has an appropriate specification for these file types: 
</p>

<h5 class="TgTable">
  <a name="1002117"> </a>

<table border="1" cellpadding="5" cellspacing="0">
  <caption><a name="1002078"> </a><div class="TableTitle">Table 7.5  Directories registered by the SD slot driver </div></caption>
  <tr bgcolor="#CCCCCC" valign="top">
    <th><a name="1002082"> </a><div class="CellHeading">File Type</div></th>
    <th><a name="1002084"> </a><div class="CellHeading">Path</div></th>
  </tr>
  <tr valign="top">
    <td><a name="1002086"> </a><div class="CellBody"><span style="font-family: monospace">.jpg</span></div></td>
    <td><a name="1002088"> </a><div class="CellBody"><span style="font-family: monospace">/DCIM/</span></div></td>
  </tr>
  <tr valign="top">
    <td><a name="1002090"> </a><div class="CellBody"><span style="font-family: monospace">.jpeg</span></div></td>
    <td><a name="1002092"> </a><div class="CellBody"><span style="font-family: monospace">/DCIM/</span></div></td>
  </tr>
  <tr valign="top">
    <td><a name="1002094"> </a><div class="CellBody"><span style="font-family: monospace">image/jpeg</span></div></td>
    <td><a name="1002096"> </a><div class="CellBody"><span style="font-family: monospace">/DCIM/</span></div></td>
  </tr>
  <tr valign="top">
    <td><a name="1002098"> </a><div class="CellBody"><span style="font-family: monospace">.qt</span></div></td>
    <td><a name="1002100"> </a><div class="CellBody"><span style="font-family: monospace">/DCIM/</span></div></td>
  </tr>
  <tr valign="top">
    <td><a name="1002102"> </a><div class="CellBody"><span style="font-family: monospace">.mov</span></div></td>
    <td><a name="1002104"> </a><div class="CellBody"><span style="font-family: monospace">/DCIM/</span></div></td>
  </tr>
  <tr valign="top">
    <td><a name="1002106"> </a><div class="CellBody"><span style="font-family: monospace">video/quicktime</span></div></td>
    <td><a name="1002108"> </a><div class="CellBody"><span style="font-family: monospace">/DCIM/</span></div></td>
  </tr>
  <tr valign="top">
    <td><a name="1002110"> </a><div class="CellBody"><span style="font-family: monospace">.avi</span></div></td>
    <td><a name="1002112"> </a><div class="CellBody"><span style="font-family: monospace">/DCIM/</span></div></td>
  </tr>
  <tr valign="top">
    <td><a name="1002114"> </a><div class="CellBody"><span style="font-family: monospace">video/x-msvideo</span></div></td>
    <td><a name="1002116"> </a><div class="CellBody"><span style="font-family: monospace">/DCIM/</span></div></td>
  </tr>
</table>




</h5><p class="Body">
  <a name="1002118"> </a>Although the directories registered by Palm's SD slot driver all happen to be duplicates of the default registrations made by the VFS Manager, they are also registered under the SD media type since the SD specification explicitly includes them.
</p>
<p class="Body">
  <a name="1002121"> </a>Slot drivers written by other Palm Powered handheld manufacturers that support different media types, such as Memory Stick, will register default directories appropriate to their media's specifications. In some cases these registrations will override the <span style="font-family: monospace">expMediaType_Any</span> media type registration, or in some cases augment the <span style="font-family: monospace">expMediaType_Any</span> registrations with file types not previously registered.
</p>
<p class="Body">
  <a name="1002122"> </a>These registrations are intended to aid applications developers, but you aren't required to follow them. Although you can choose to ignore these registrations, by following them you'll improve interoperability between applications and other devices. For example, a digital camera which conforms to the media specifications will put its pictures into the registered directory (or a subdirectory of it) appropriate for the image format and media type. By looking up the registered directory for that format, an image viewer application on the handheld can easily find the images without having to search the entire card. These registrations also help prevent different developers from hard-coding different paths for specific file types. Thus, if a user has two different image viewer applications, both will look in the same location and find the same set of images.
</p>
<p class="Body">
  <a name="1002123"> </a>Registering these file types at initialization allows you to use HotSync to transfer files of these types to an expansion card. During the HotSync process, files of the registered types are placed directly in the specified directories on the card.
</p>

<h2 class="HaHeadA">
  <a name="1002126"> </a>Custom Calls 
<a href="#1000865"><img src="images/top.gif" border="0"></a></h2>

<p class="Body">
  <a name="1002127"> </a>Recognizing that some file systems may implement functionality not covered by the APIs included in the VFS and Expansion Managers, the VFS Manager includes a single function that exists solely to give developers access to the underlying file system. This function, <a href="VFSMgr.html#1181847"><span style="font-family: monospace">VFSCustomControl</span></a>, takes a registered creator code and a selector that together identify the operation that is to be performed. <span style="font-family: monospace">VFSCustomControl</span> can either request that a specific file system perform the specified operation, or it can iterate through all of the currently-registered file systems in an effort to locate one that responds to the desired operation.
</p>
<p class="Body">
  <a name="1002132"> </a>Parameters are passed to the file system's custom function through a single <span style="font-family: monospace">VFSCustomControl</span> parameter. This parameter, <span style="font-family: monospace">valueP</span>, is declared as a <span style="font-family: monospace">void *</span> so you can pass a pointer to a structure of any type. A second parameter, <span style="font-family: monospace">valueLenP</span>, allows you to specify the length of <span style="font-family: monospace">valueP</span>. Note that these values are simply passed to the file system and are in reality dependent upon the underlying file system. See the description of <a href="VFSMgr.html#1181847"><span style="font-family: monospace">VFSCustomControl</span></a> in the <i>Palm OS Programmer's API Reference</i> for more information.
</p>
<p class="Body">
  <a name="1002139"> </a>Because <span style="font-family: monospace">VFSCustomControl</span> is designed to allow access to non-standard functionality provided by a particular file system, see the documentation provided with that file system for a list of any custom functions that it provides.
</p>

<h2 class="HBHeadB">
  <a name="1002141"> </a>Custom I/O
<a href="#1000865"><img src="images/top.gif" border="0"></a></h2>

<p class="Body">
  <a name="1002142"> </a>While the Expansion and VFS Managers provide higher-level OS support for secondary storage applications, they don't attempt to present anything more than a raw interface to custom I/O applications. Since it isn't really possible to envision all uses of an expansion mechanism, the Expansion and VFS Managers simply try to get out of the way of custom hardware.
</p>
<p class="Body">
  <a name="1002143"> </a>The Expansion Manager provides insertion and removal notification and can load and unload drivers. Everything else is the responsibility of the application developer. Palm has defined a common expansion slot driver API which is extensible by licensees. This API is designed to support all of the needs of the Expansion Manager, the VFS Manager, and the file system libraries. Applications that need to communicate with an I/O device, however, may need to go beyond the provided APIs. Such applications should wherever possible use the slot custom call, which provides direct access to the expansion slot driver. See the developer documentation provided to licensees for more information on slot drivers and the slot custom call. For documentation on functions made available by a particular I/O device, along with how you access those functions, contact the I/O device manufacturer.
</p>

<h2 class="HaHeadA">
  <a name="1002147"> </a>Debugging 
<a href="#1000865"><img src="images/top.gif" border="0"></a></h2>

<p class="Body">
  <a name="1002148"> </a>The Palm OS Emulator has been extended to support the expansion capabilities of the VFS Manager. It can be configured to present a directory on the host file system as a volume to the virtual file system. You can populate this directory on your host system and then simulate a volume mount. Changes made to the emulated expansion card's contents can be verified simply by examining the directory on the host.
</p>
<p class="Body">
  <a name="1002149"> </a>For more information on configuring and operating the Palm OS Emulator, see the <i>Palm OS Programming Development Tools Guide</i>.
</p>

<h2 class="HaHeadA">
  <a name="1002154"> </a>Summary of Expansion and VFS Managers 
<a href="#1000865"><img src="images/top.gif" border="0"></a></h2>


<h5 class="TgTable">
  <a name="1002185"> </a>

<table border="1" cellpadding="5" cellspacing="0">
  <caption></caption>
  <tr bgcolor="#CCCCCC" valign="top">
    <th colspan="2" rowspan="1"><a name="1002157"> </a><div class="CellHeading">Expansion Manager Functions</div></th>
  </tr>
  <tr valign="top">
    <td><a name="1002164"> </a><div class="CellBody"><a href="ExpansionManager.html#1107472">ExpCardGetSerialPort</a><br><a href="ExpansionManager.html#1107500">ExpCardInfo</a><br><a href="ExpansionManager.html#1107548">ExpCardPresent</a><br><a href="ExpansionManager.html#1107582">ExpSlotDriverInstall</a></div></td>
    <td><a name="1002178"> </a><div class="CellBody"><a href="ExpansionManager.html#1107616">ExpSlotDriverRemove</a><br><a href="ExpansionManager.html#1107648">ExpSlotEnumerate</a><br><a href="ExpansionManager.html#1107698">ExpSlotLibFind</a></div></td>
  </tr>
</table>




</h5>
<h5 class="TgTable">
  <a name="1002368"> </a>

<table border="1" cellpadding="5" cellspacing="0">
  <caption></caption>
  <tr bgcolor="#CCCCCC" valign="top">
    <th colspan="2" rowspan="1"><a name="1002188"> </a><div class="CellHeading">VFS Manager Functions</div></th>
  </tr>
  <tr valign="top">
    <td><a name="1002192"> </a><div class="CellHeading">Working with Files</div></td>
    <td><a name="1002194"> </a><div class="CellBody"><br></div></td>
  </tr>
  <tr valign="top">
    <td><a name="1002199"> </a><div class="CellBody"><a href="VFSMgr.html#1182090">VFSFileClose</a><br><a href="VFSMgr.html#1182117">VFSFileCreate</a><br><a href="VFSMgr.html#1182357">VFSFileDelete</a><br><a href="VFSMgr.html#1182388">VFSFileEOF</a><br><a href="VFSMgr.html#1182415">VFSFileGetAttributes</a><br><a href="VFSMgr.html#1182455">VFSFileGetDate</a><br><a href="VFSMgr.html#1182499">VFSFileOpen</a><br><a href="VFSMgr.html#1182551">VFSFileRead</a><br><a href="VFSMgr.html#1182601">VFSFileReadData</a></div></td>
    <td><a name="1002228"> </a><div class="CellBody"><a href="VFSMgr.html#1182655">VFSFileRename</a><br><a href="VFSMgr.html#1182699">VFSFileResize</a><br><a href="VFSMgr.html#1182734">VFSFileSeek</a><br><a href="VFSMgr.html#1182776">VFSFileSetAttributes</a><br><a href="VFSMgr.html#1182823">VFSFileSetDate</a><br><a href="VFSMgr.html#1182865">VFSFileSize</a><br><a href="VFSMgr.html#1182903">VFSFileTell</a><br><a href="VFSMgr.html#1182938">VFSFileWrite</a></div></td>
  </tr>
  <tr valign="top">
    <td><a name="1002251"> </a><div class="CellHeading">Working with Directories</div></td>
    <td><a name="1002253"> </a><div class="CellBody"><br></div></td>
  </tr>
  <tr valign="top">
    <td><a name="1002258"> </a><div class="CellBody"><a href="VFSMgr.html#1181880">VFSDirCreate</a><br><a href="VFSMgr.html#1181918">VFSDirEntryEnumerate</a><br><a href="VFSMgr.html#1182090">VFSFileClose</a><br><a href="VFSMgr.html#1182357">VFSFileDelete</a><br><a href="VFSMgr.html#1182415">VFSFileGetAttributes</a><br><a href="VFSMgr.html#1182455">VFSFileGetDate</a><br><a href="VFSMgr.html#1182499">VFSFileOpen</a><br><a href="VFSMgr.html#1182655">VFSFileRename</a></div></td>
    <td><a name="1002284"> </a><div class="CellBody"><a href="VFSMgr.html#1182776">VFSFileSetAttributes</a><br><a href="VFSMgr.html#1182823">VFSFileSetDate</a><br><a href="VFSMgr.html#1182983">VFSGetDefaultDirectory</a><br><a href="VFSMgr.html#1183168">VFSRegisterDefaultDirectory</a><br><a href="VFSMgr.html#1183236">VFSUnregisterDefaultDirectory</a></div></td>
  </tr>
  <tr valign="top">
    <td><a name="1002298"> </a><div class="CellHeading">Working with Volumes</div></td>
    <td><a name="1002300"> </a><div class="CellBody"><br></div></td>
  </tr>
  <tr valign="top">
    <td><a name="1002305"> </a><div class="CellBody"><a href="VFSMgr.html#1183274">VFSVolumeEnumerate</a><br><a href="VFSMgr.html#1183315">VFSVolumeFormat</a><br><a href="VFSMgr.html#1183388">VFSVolumeGetLabel</a><br><a href="VFSMgr.html#1183424">VFSVolumeInfo</a></div></td>
    <td><a name="1002319"> </a><div class="CellBody"><a href="VFSMgr.html#1183461">VFSVolumeMount</a><br><a href="VFSMgr.html#1183542">VFSVolumeSetLabel</a><br><a href="VFSMgr.html#1183589">VFSVolumeSize</a></div><a name="1002329"> </a><div class="CellBody"><a href="VFSMgr.html#1183622">VFSVolumeUnmount</a></div></td>
  </tr>
  <tr valign="top">
    <td><a name="1002331"> </a><div class="CellHeading">Miscellaneous Functions</div></td>
    <td><a name="1002333"> </a><div class="CellBody"><br></div></td>
  </tr>
  <tr valign="top">
    <td><a name="1002338"> </a><div class="CellBody"><a href="VFSMgr.html#1181847">VFSCustomControl</a><br><a href="VFSMgr.html#1181987">VFSExportDatabaseToFile</a><br><a href="VFSMgr.html#1182034">VFSExportDatabaseToFileCustom</a><br><a href="VFSMgr.html#1182269">VFSFileDBInfo</a><br><a href="VFSMgr.html#1182173">VFSFileDBGetRecord</a><br><a href="VFSMgr.html#1182230">VFSFileDBGetResource</a></div></td>
    <td><a name="1002358"> </a><div class="CellBody"><a href="VFSMgr.html#1183026">VFSImportDatabaseFromFile</a><br><a href="VFSMgr.html#1183078">VFSImportDatabaseFromFileCustom</a><br><a href="VFSMgr.html#1183134">VFSInstallFSLib</a><br><a href="VFSMgr.html#1183210">VFSRemoveFSLib</a></div></td>
  </tr>
</table>



w
</h5> 

<p class="Body">&nbsp;</p><hr> <p class="FNFootnote">
  <a name="1000915"> </a><a href="#1000917"><span class="FootnoteNumber">1. </span></a><p class="FNFootnote">
  <a name="1000915"> </a>The Sony CLIÉ<sup>&#8482;</sup> handheld running Palm OS 3.5 runs a binary-compatible version of these extensions.
</p>

</p>
<p class="FNFootnote">
  <a name="1001223"> </a><a href="#1001224"><span class="FootnoteNumber">2. </span></a><p class="FNFootnote">
  <a name="1001223"> </a>The Sony CLIÉ<sup>&#8482;</sup> handheld running Palm OS 3.5 uses a version of the Expansion and VFS Managers. Sony's version of these managers is binary compatible with those included with Palm OS 4.0.
</p>

</p>
&nbsp;<br>
				<!-- CONTENT_END -->

		</td>
		<td width="5">&nbsp;&nbsp;</td>
	</tr>
      </table>
    </td>
			</tr>
  <tr>
				<td>
					<table border="0" cellpadding="0" cellspacing="0" width="760">
        <!-- CONTENTCELL_END -->
        <tr valign="top"> 
          <td width="10">&nbsp;<!-- FOOTER_START --></td>
          <td width="72">&nbsp;</td>
          <td width="25" bgcolor="white" background="images/bkgrnd.gif">&nbsp;</td>
          <td width="600"> 
            <table border="0" cellpadding="0" cellspacing="0" width="600">
              <tr> 
                <td><img src="images/rule_10-1-5_ltblue.gif" width="600" height="16" border="0"></td>
              </tr>
              <tr> 
                <td> 
                  <p align="center" class="footer"> ©2002 PalmSource, Inc. and its affiliates.  All rights reserved. 
<a href="http://www.palmos.com/dev/training/">Training</a>&nbsp;|&nbsp;<a href="http://www.palmos.com/dev/support/kb/">Knowledge Base</a>&nbsp;|&nbsp;<a href="http://www.palmos.com/">Palm&nbsp;OS&nbsp;Platform</a>&nbsp;|&nbsp;<a href="Companion_Front.html" target="_blank">Legal Notices</a>&nbsp;<br>
												<!-- FOOTER_END --><br>
											</p>
                </td>
              </tr>
            </table>
          </td>
        </tr>
      </table>
				</td>
			</tr>
</table>
</BODY>
</HTML>