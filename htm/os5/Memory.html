<HTML>

<HEAD>
<SMALLSCREENIGNORE> 
<LINK HREF="copy_of_palmos.css" REL="stylesheet" TYPE="text/css">
<LINK HREF="document.css" REL="StyleSheet" TYPE="text/css" media="screen">
<!-- SCRIPT_START -->
<!-- SCRIPT_END -->
</SMALLSCREENIGNORE>
<TITLE>Memory</TITLE>

<META NAME="PALMTEMPLATE" CONTENT="1006-002 Palm HTML 20020513">
<META NAME="GENERATOR" CONTENT="Quadralay WebWorks Publisher Professional Edition 6.0.7">
<META NAME="TEMPLATEBASE" CONTENT="Palm HTML 20010625">
<META NAME="LASTUPDATED" CONTENT="12/13/02 10:05:43">
<META HTTP-EQUIV="content-type" CONTENT="text/html;charset=ISO-8859-1">

</HEAD>

<BODY LEFTMARGIN="0" MARGINWIDTH="0" TOPMARGIN="0" MARGINHEIGHT="0">
<SMALLSCREENIGNORE> 
<table width="100%" border="0" cellspacing="0" cellpadding="0">
  <tr>
	<td><a name="995988"></a>
      <table border="0" cellpadding="0" cellspacing="0" width="100%">
        <tr height="35"> 
          <td height="35" colspan="2" bgcolor="#6699CC">&nbsp;</td>
        </tr>
        <tr valign="top"> 
          <td width="160" align="left"><a href="http://www.palmos.com"><img src="images/bigorb.gif" width="160" height="110" border="0"></a></td>
          <td align="left" width="100%"> 
            </SMALLSCREENIGNORE>
            <!-- CONTENTCELL_START -->
            <img border="0" height="45" src="images/orb_bkgrnd_600.gif" width="600"><br>
            <!--PAGENAV_START-->
            <SPAN CLASS="subnav">&nbsp;&lt;&nbsp;<A HREF="http://www.palmos.com/index.html">Home</a> 
              &nbsp;&nbsp;&lt;&nbsp;<A HREF="http://www.palmos.com/dev/">Developers</a> 
              &nbsp;&nbsp;&lt;&nbsp;<A HREF="http://www.palmos.com/dev/support/">Development Support</a>
              &nbsp;&nbsp;&lt;&nbsp;<A HREF="http://www.palmos.com/dev/support/docs/">Documentation</a></span><BR>
             <img src="images/pixel_ltblue.gif" width="600" height="1" border="0" vspace="2"><br>
             <h2 class="HeadDocPage">5  Memory</h2>
             <img src="images/pixel_ltblue.gif" width="600" height="1" border="0" vspace="2"><br>
             &nbsp;<span class="subnav"><a href="CompanionTOC.html">Table of Contents</a>&nbsp;&nbsp;
             |&nbsp;&nbsp;<a href="UserInterface.html">&lt;&nbsp;Previous</a>&nbsp;&nbsp;
             |&nbsp;&nbsp;<a href="FilesAndDatabases.html">Next&nbsp;&gt;</a>&nbsp;&nbsp;
             |&nbsp;&nbsp;<a href="CompanionIX.html">Index</a></span>  
            <!--PAGENAV_END-->
          </td>
        </tr>
      </table>
    </td>
			</tr>
  <tr>
				<td> 
      <table width="100%" border="0" cellspacing="0" cellpadding="0">
        <tr>
							<td>&nbsp;&nbsp;&nbsp;</td>
						</tr>
        <tr>
		<td valign="top" width="10">&nbsp;&nbsp;&nbsp;</td>
		<td valign="top" width="175">
			<p class="SideTitle">Title - <br><a href="Companion_Front.html">Palm OS® Programmer's Companion</a></p>
			<p class="SideTOC1-PartTab">Volume I </p>
			<p class="SideTOC1"><a href="Memory.html">5  Memory</a></p>
			
<p class="SideTOC2">
<a href="#996003">Introduction to Palm OS Memory Use
</a></p>

<p class="SideTOC3">
<a href="#996013">Hardware Architecture
</a></p>

<p class="SideTOC3">
<a href="#996027">PC Connectivity
</a></p>

<p class="SideTOC2">
<a href="#996034">Memory Architecture
</a></p>

<p class="SideTOC3">
<a href="#996190">Heap Overview
</a></p>

<p class="SideTOC2">
<a href="#996217">The Memory Manager
</a></p>

<p class="SideTOC3">
<a href="#996229">Memory Manager Structures
</a></p>

<p class="SideTOC3">
<a href="#996283">Using the Memory Manager
</a></p>

<p class="SideTOC3">
<a href="#996399">Achieving Optimum Performance
</a></p>

<p class="SideTOC2">
<a href="#996441">Summary of Memory Management
</a></p>

		</td>

		<td width="5">&nbsp;&nbsp;</td>
		<td width="1" bgcolor="#6699cc">&nbsp;</td>
		<td width="5">&nbsp;&nbsp;</td>
		<td> 

				<!-- CONTENT_START -->

<p class="Body">
  <a name="998498"> </a>This chapter helps you understand memory use on Palm OS<sup>®</sup>. 
</p>

  <a name="995993"> </a><p class="B1Bullet"> &#8226; <a href="Memory.html#996003">Introduction to Palm OS Memory Use</a> provides information about Palm OS hardware relevant to memory management. </p>

  <a name="995997"> </a><p class="B1Bullet"> &#8226; <a href="Memory.html#996034">Memory Architecture</a> discusses in detail how memory is structured on Palm OS. It also examines the structure of the basic building blocks of Palm OS memory: heaps, chunks, and records.</p>

  <a name="996001"> </a><p class="B1Bullet"> &#8226; <a href="Memory.html#996217">The Memory Manager</a> discusses how to use the Palm OS Memory Manager in your applications. The Memory Manager maintains the location and size of each memory chunk in nonvolatile storage, volatile storage, and ROM. It provides functions for allocating chunks, disposing of chunks, resizing chunks, locking and unlocking chunks, and compacting the heap when it becomes fragmented.</p>

<h2 class="HaHeadA">
  <a name="996003"> </a>Introduction to Palm OS Memory Use 
<a href="#995988"><img src="images/top.gif" border="0"></a></h2>

<p class="Body">
  <a name="996005"> </a>The Palm OS system software supports applications on low-cost, low-power, handhelds. Given these constraints, Palm OS is efficient in its use of both memory and processing resources. This section presents two aspects of Palm Powered<sup>&#8482;</sup> handheld that contribute to this efficiency: <a href="Memory.html#996013">Hardware Architecture</a> and <a href="Memory.html#996027">PC Connectivity</a>.
</p>

<h2 class="HBHeadB">
  <a name="996013"> </a>Hardware Architecture
<a href="#995988"><img src="images/top.gif" border="0"></a></h2>

<p class="Body">
  <a name="996014"> </a>The first implementation of Palm OS provided nearly instantaneous response to user input while running on a 16 MHz Motorola<sup>®</sup> 68000 type processor with a minimum of 128 KB of nonvolatile storage memory and 512 KB of ROM. Subsequent Palm Powered handhelds provide additional RAM and ROM in varying amounts.
</p>
<p class="Body">
  <a name="998937"> </a>The ROM and RAM for each Palm Powered handheld resides on a memory module known as a <b>card</b>. Each memory card can contain ROM, RAM, or both. A "card" is really just a logical construct used by the operating system-Palm Powered handhelds can have one card, multiple cards, or no cards. For example, the Simulator provided by the Palm OS SDK on Macintosh can simulate a handheld that has two cards. 
</p>
<div class="NINoteImportant"><hr>
  <a name="996019"> </a> <span style="color: #333;  font-style: normal; font-weight: bold; text-decoration: none; text-transform: none; vertical-align: baseline">IMPORTANT:  </span> Do not confuse memory cards with expansion cards, such as SD cards or MemoryStick cards. You access expansion cards through a different API. See <a href="ExpAndVFSConcepts.html#1000865">Chapter 7, "Expansion,"</a> for more information. 
<hr>
</div>
<p class="Body">
  <a name="996024"> </a>The main suite of applications provided with each Palm Powered handheld is built into ROM. This design permits the user to replace the operating system and the entire applications suite simply by installing a single replacement module<span style="color: #333;;  font-style: italic; font-weight: normal; text-decoration: none; text-transform: none; vertical-align: baseline">. </span>Additional or replacement applications and system extensions can be loaded into RAM, but doing so is not always practical in this RAM-constrained environment.
</p>

<h2 class="HBHeadB">
  <a name="996027"> </a>PC Connectivity
<a href="#995988"><img src="images/top.gif" border="0"></a></h2>

<p class="Body">
  <a name="996029"> </a>PC connectivity is an integral component of Palm Powered handhelds. The handheld comes with a cradle that connects to a desktop PC and with software for the PC that provides "one-button" backup and synchronization of all data on the handheld with the user's PC. 
</p>
<p class="Body">
  <a name="996031"> </a>Because all user data can be backed up on the PC, replacement of the nonvolatile storage area of the Palm Powered handheld becomes a simple matter of installing the new module in place of the old one and resynchronizing with the PC. The format of the user's data in storage RAM can change with a new version of the ROM; the connectivity software on the PC is responsible for translating the data into the correct format when downloading it onto a handheld with a new ROM.
</p>

<h2 class="HaHeadA">
  <a name="996034"> </a>Memory Architecture 
<a href="#995988"><img src="images/top.gif" border="0"></a></h2>

<div class="NINoteImportant"><hr>
  <a name="996035"> </a> <span style="color: #333;  font-style: normal; font-weight: bold; text-decoration: none; text-transform: none; vertical-align: baseline">IMPORTANT:  </span> This section describes the current implementation of Palm OS memory architecture. This implementation may change as the Palm OS evolves. Do not rely on implementation-specific information described here; instead, always use the API provided to manipulate memory. 
<hr>
</div>
<p class="Body">
  <a name="996037"> </a>The Palm OS system software is designed around a 32-bit architecture. The system uses 32-bit addresses, and its basic data types are 8, 16, and 32 bits long. 
</p>
<p class="Body">
  <a name="996038"> </a>The 32-bit addresses available to software provide a total of 4 GB of address space for storing code and data. This address space affords a large growth potential for future revisions of both the hardware and software without affecting the execution model. Although a large memory space is available, Palm OS was designed to work efficiently with small amounts of RAM. For example, the first commercial Palm Powered handheld has less than 1 MB of memory, or 0.025% of this address space. 
</p>
<p class="Body">
  <a name="996040"> </a>The Motorola 68328 processor's 32-bit registers and 32 internal address lines support a 32-bit execution model as well, although the external data bus is only 16 bits wide. This design reduces cost without impacting the software model. The processor's bus controller automatically breaks down 32-bit reads and writes into multiple 16-bit reads and writes externally.
</p>
<p class="Body">
  <a name="996041"> </a>Each memory card in the Palm Powered handheld has 256 MB of address space reserved for it. Memory card 0 starts at address $1000000, memory card 1 starts at address $2000000, and so on. 
</p>
<p class="Body">
  <a name="996042"> </a>The Palm OS divides the total available RAM store into two logical areas: <b>dynamic</b> RAM and <b>storage</b> RAM. Dynamic RAM is used as working space for temporary allocations, and is analogous to the RAM installed in a typical desktop system. The remainder of the available RAM on the card is designated as storage RAM and is analogous to disk storage on a typical desktop system. 
</p>
<p class="Body">
  <a name="996044"> </a>Because power is always applied to the memory system, both areas of RAM preserve their contents when the handheld is turned "off" (i.e., is in low-power sleep mode). See <a href="SystemFeatures.html#1014623">"Palm OS Power Modes"</a> in the chapter <a href="SystemFeatures.html#1013426">"Palm System Support"</a> in this book. All of storage memory is preserved even when the handheld is reset explicitly. As part of the boot sequence, the system software reinitializes the dynamic area, and leaves the storage area intact. 
</p>
<p class="Body">
  <a name="996051"> </a>The entire dynamic area of RAM is used to implement a single heap that provides memory for dynamic allocations. From this <b>dynamic heap</b>, the system provides memory for dynamic data such as global variables, system dynamic allocations (TCP/IP, IrDA, and so on, as applicable), application stacks, temporary memory allocations, and application dynamic allocations (such as those performed when the application calls the <a href="MemoryManager.html#1132723"><span style="font-family: monospace">MemHandleNew</span></a> function).
</p>
<p class="Body">
  <a name="996055"> </a>The entire amount of RAM reserved for the dynamic heap is always dedicated to this use, regardless of whether it is actually used for allocations. The size of the dynamic area of RAM on a particular handheld varies according to the OS version running, the amount of physical RAM available, and the requirements of pre-installed software such as the TCP/IP stack or IrDA stack. <a href="Memory.html#996066">Table 5.1</a> provides more information about the dynamic heap space that currently available combinations of OS and hardware provide.
</p>

<h5 class="TgTable">
  <a name="996166"> </a>

<table border="1" cellpadding="5" cellspacing="0">
  <caption><a name="996066"> </a><div class="TableTitle">Table 5.1  Dynamic Heap Space </div></caption>
  <tr bgcolor="#CCCCCC" valign="top">
    <th><a name="996078"> </a><div class="TT11Tabletest11pt"><b>RAM Usage</b></div></th>
    <th><a name="996080"> </a><div class="TT11Tabletest11pt"><span style="color: #333;;  font-style: normal; font-weight: bold; text-decoration: none; text-transform: none; vertical-align: baseline"> OS 3.5</span></div><a name="996081"> </a><div class="TT11Tabletest11pt"><span style="color: #333;;  font-family: Symbol; font-style: normal; font-weight: normal; text-decoration: none; text-transform: none; vertical-align: baseline">£ </span><span style="color: #333;;  font-style: normal; font-weight: bold; text-decoration: none; text-transform: none; vertical-align: baseline">4 MB</span></div><a name="996082"> </a><div class="TT11Tabletest11pt"><b>TCP/IP &amp; IrDA<br></b></div></th>
    <th><a name="996084"> </a><div class="TT11Tabletest11pt"><span style="color: #333;;  font-style: normal; font-weight: bold; text-decoration: none; text-transform: none; vertical-align: baseline"> OS 3.5</span></div><a name="996085"> </a><div class="TT11Tabletest11pt"><span style="color: #333;;  font-family: Symbol; font-style: normal; font-weight: normal; text-decoration: none; text-transform: none; vertical-align: baseline">£ </span><span style="color: #333;;  font-style: normal; font-weight: bold; text-decoration: none; text-transform: none; vertical-align: baseline">2 MB</span></div><a name="996086"> </a><div class="TT11Tabletest11pt"><b><br></b><b>TCP/IP &amp; IrDA</b></div></th>
    <th><a name="996088"> </a><div class="TT11Tabletest11pt"><b>OS 3.0 </b><span style="color: #333;;  font-family: Symbol; font-style: normal; font-weight: normal; text-decoration: none; text-transform: none; vertical-align: baseline">&gt;</span><span style="color: #333;;  font-style: normal; font-weight: bold; text-decoration: none; text-transform: none; vertical-align: baseline"> 3.3<br></span><span style="color: #333;;  font-family: Symbol; font-style: normal; font-weight: normal; text-decoration: none; text-transform: none; vertical-align: baseline">&gt;</span><span style="color: #333;;  font-style: normal; font-weight: bold; text-decoration: none; text-transform: none; vertical-align: baseline"> 1 MB<br>TCP/IP &amp; IrDA<br>(Palm III</span><span style="color: #333;;  font-style: normal; font-weight: bold; text-decoration: none; text-transform: none; vertical-align: super">&#8482;</span><span style="color: #333;;  font-style: normal; font-weight: bold; text-decoration: none; text-transform: none; vertical-align: baseline">)</span></div></th>
    <th><a name="996090"> </a><div class="TT11Tabletest11pt"><b>OS 2.0 <br>1 MB<br>TCP/IP only<br>(Professional)</b></div></th>
    <th><a name="996092"> </a><div class="TT11Tabletest11pt"><b>OS 2.0/1.0<br>512 KB<br>no TCP/IP or IrDA (Personal)</b></div></th>
  </tr>
  <tr valign="top">
    <td><a name="996094"> </a><div class="TT11Tabletest11pt">Total dynamic area</div></td>
    <td><a name="996096"> </a><div class="TT11Tabletest11pt">256 KB</div></td>
    <td><a name="996098"> </a><div class="TT11Tabletest11pt">128 KB</div></td>
    <td><a name="996100"> </a><div class="TT11Tabletest11pt">96 KB</div></td>
    <td><a name="996102"> </a><div class="TT11Tabletest11pt">64 KB</div></td>
    <td><a name="996104"> </a><div class="TT11Tabletest11pt">32 KB</div></td>
  </tr>
  <tr valign="top">
    <td><a name="996106"> </a><div class="TT11Tabletest11pt">System Globals<br>(screen buffer, UI globals, database references, etc.)</div></td>
    <td><a name="996108"> </a><div class="TT11Tabletest11pt">40 KB<br>(OS)</div></td>
    <td><a name="996110"> </a><div class="TT11Tabletest11pt">40 KB</div><a name="996111"> </a><div class="TT11Tabletest11pt">(OS)</div></td>
    <td><a name="996113"> </a><div class="TT11Tabletest11pt">~2.5 KB</div></td>
    <td><a name="996115"> </a><div class="TT11Tabletest11pt">~2.5 KB</div></td>
    <td><a name="996117"> </a><div class="TT11Tabletest11pt">~2.5 KB</div></td>
  </tr>
  <tr valign="top">
    <td><a name="996119"> </a><div class="TT11Tabletest11pt">TCP/IP stack</div></td>
    <td><a name="996121"> </a><div class="TT11Tabletest11pt">32 KB</div></td>
    <td><a name="996123"> </a><div class="TT11Tabletest11pt">32 KB</div></td>
    <td><a name="996125"> </a><div class="TT11Tabletest11pt">32 KB</div></td>
    <td><a name="996127"> </a><div class="TT11Tabletest11pt">32 KB</div></td>
    <td><a name="996129"> </a><div class="TT11Tabletest11pt">0 KB</div></td>
  </tr>
  <tr valign="top">
    <td><a name="996131"> </a><div class="TT11Tabletest11pt">System dynamic allocation<br>(IrDA, "Find" window, temporary allocations)</div></td>
    <td><a name="996133"> </a><div class="TT11Tabletest11pt">variable</div></td>
    <td><a name="996135"> </a><div class="TT11Tabletest11pt">variable</div></td>
    <td><a name="996137"> </a><div class="TT11Tabletest11pt">variable amount</div></td>
    <td><a name="996139"> </a><div class="TT11Tabletest11pt">~15 KB<br>(no IrDA in this OS)</div></td>
    <td><a name="996141"> </a><div class="TT11Tabletest11pt">~15 KB</div></td>
  </tr>
  <tr valign="top">
    <td><a name="996143"> </a><div class="TT11Tabletest11pt">Application stack<br>(call stack and local vars)</div></td>
    <td><a name="996145"> </a><div class="TT11Tabletest11pt">N/A (see note)</div></td>
    <td><a name="996147"> </a><div class="TT11Tabletest11pt">N/A (see note)</div></td>
    <td><a name="996149"> </a><div class="TT11Tabletest11pt">4 KB <br>(default)</div></td>
    <td><a name="996151"> </a><div class="TT11Tabletest11pt">2.5 KB</div></td>
    <td><a name="996153"> </a><div class="TT11Tabletest11pt">2.5 KB</div></td>
  </tr>
  <tr valign="top">
    <td><a name="996155"> </a><div class="TT11Tabletest11pt">Remaining dynamic space<br>(dynamic allocations, application global variables, and static variables)</div></td>
    <td><a name="996157"> </a><div class="TT11Tabletest11pt">184 KB</div></td>
    <td><a name="996159"> </a><div class="TT11Tabletest11pt">56 KB</div></td>
    <td><a name="996161"> </a><div class="TT11Tabletest11pt"><span style="color: #333;;  font-family: Symbol; font-style: normal; font-weight: normal; text-decoration: none; text-transform: none; vertical-align: baseline">£</span> 36 KB</div></td>
    <td><a name="996163"> </a><div class="TT11Tabletest11pt"><span style="color: #333;;  font-family: Symbol; font-style: normal; font-weight: normal; text-decoration: none; text-transform: none; vertical-align: baseline">£</span> 12 KB</div></td>
    <td><a name="996165"> </a><div class="TT11Tabletest11pt"><span style="color: #333;;  font-family: Symbol; font-style: normal; font-weight: normal; text-decoration: none; text-transform: none; vertical-align: baseline">£ </span>12 KB</div></td>
  </tr>
</table>




</h5><div class="NINoteImportant"><hr>
  <a name="996167"> </a> <span style="color: #333;  font-style: normal; font-weight: bold; text-decoration: none; text-transform: none; vertical-align: baseline">NOTE:  </span> Starting with Palm OS 3.5, the dynamic heap is sized based on the amount of memory available to the system. 
<hr>
</div>
<p class="Body">
  <a name="996168"> </a>The remaining portion of RAM not dedicated to the dynamic heap is configured as one or more <b>storage heaps</b> used to hold nonvolatile user data such as appointments, to do lists, memos, address lists, and so on. An application accesses a storage heap by calling the Data Manager or Resource Manager, according to whether it needs to manipulate user data or resources. 
</p>
<p class="Body">
  <a name="996169"> </a>The size and number of storage heaps available on a particular handheld varies according to the OS version that is running; the amount of physical RAM that is available; and the storage requirements of end-user application software such as the Address Book, Date Book, or third-party applications.
</p>
<p class="Body">
  <a name="996170"> </a>Versions 1.0 and 2.0 of Palm OS subdivide storage RAM into multiple storage heaps of 64 KB each. Palm OS 3.0 and later configure all storage RAM on a card as a single storage heap. Under all versions of Palm OS, system overhead limits the maximum usable data storage available in a single chunk to slightly less than 64 KB.
</p>
<p class="Body">
  <a name="996180"> </a>In the Palm OS environment, all data are stored in Memory Manager chunks. A <b>chunk</b> is an area of contiguous memory between 1 byte and slightly less than 64 KB in size that has been allocated by the Palm OS Memory Manager. (Because system overhead requirements may vary, an exact figure for the maximum amount of usable data storage for all chunks cannot be specified.) Currently, all Palm OS implementations limit the maximum size of any chunk to slightly less than 64 KB; however, the API does not have this constraint, and it may be relaxed in the future. 
</p>
<p class="Body">
  <a name="996182"> </a>Each chunk resides in a heap. Some heaps are ROM-based and contain only nonmovable chunks; some are RAM-based and may contain movable or nonmovable chunks. A RAM-based heap may be a dynamic heap or a storage heap. The Palm OS Memory Manager allocates memory in the dynamic heap (for dynamic allocations, stacks, global variables, and so on). The Palm OS Data Manager allocates memory in one or more storage heaps (for nonvolatile user data). 
</p>
<p class="Body">
  <a name="996183"> </a>Every memory chunk used to hold storage data (as opposed to memory chunks that store dynamic data) is a <b>record</b> in a database implemented by the Palm OS Data Manager. In the Palm OS environment, a <b>database</b> is simply a list of memory chunks and associated database header information. Normally, the items in a database share some logical association; for example, a database may hold a collection of all address book entries, all datebook entries, and so on.
</p>
<p class="Body">
  <a name="996185"> </a>A database is analogous to a file in a desktop system. Just as a traditional file system can create, delete, open, and close files, Palm OS applications can create, delete, open, and close databases as necessary. There is no restriction on where the records for a particular database reside as long as they are all on the same memory card. The records from one database can be interspersed with the records from one or more other databases in memory.
</p>
<p class="Body">
  <a name="996187"> </a>Storing data by database fits nicely with the Palm OS Memory Manager design. Each record in a database is in fact a Memory Manager chunk. The Data Manager can use Memory Manager calls to allocate, delete, and resize database records. All heaps except for the dynamic heap are nonvolatile, so database records can be stored in any heap except the dynamic heap. Because records can be stored anywhere on the memory card, databases can be distributed over multiple discontiguous areas of physical RAM, but all records belonging to a particular database must reside on the same card. 
</p>
<p class="Body">
  <a name="996188"> </a>To understand how database records are manipulated, it helps to know something about the way the Memory Manager allocates and tracks memory chunks, as the next section describes.
</p>

<h2 class="HBHeadB">
  <a name="996190"> </a>Heap Overview
<a href="#995988"><img src="images/top.gif" border="0"></a></h2>

<div class="NINoteImportant"><hr>
  <a name="996191"> </a> <span style="color: #333;  font-style: normal; font-weight: bold; text-decoration: none; text-transform: none; vertical-align: baseline">IMPORTANT:  </span> This section describes the current implementation of Palm OS memory architecture. This implementation may change as the Palm OS evolves. Do not rely on implementation-specific information described here; instead, always use the API provided to manipulate memory. 
<hr>
</div>
<p class="Body">
  <a name="996193"> </a>Recall that a <b>heap</b> is a contiguous area of memory used to contain and manage one or more smaller chunks of memory. When applications work with memory (allocate, resize, lock, etc.) they usually work with chunks of memory. An application can specify whether to allocate a new chunk of memory in the storage heap or the dynamic heap. The Memory Manager manages each heap independently and rearranges chunks as necessary to defragment heaps and merge free space. 
</p>
<p class="Body">
  <a name="996194"> </a>Heaps in the Palm OS environment are referenced through heap IDs. A <b>heap ID</b> is a unique 16-bit value that the Memory Manager uses to identify a heap within the Palm OS address space. Heap IDs start at 0 and increment sequentially by units of 1. Values are assigned beginning with the RAM heaps on card 0, continuing with the ROM heaps on card 0, and then continuing through RAM and ROM heaps on subsequent cards. The sequence of heap IDs is continuous; that is, no values in the sequence are skipped. 
</p>
<p class="Body">
  <a name="996195"> </a>The first heap (heap 0) on card 0 is the dynamic heap. This heap is reinitialized every time the Palm Powered handheld is reset. When an application quits, the system frees any chunks allocated by that application in the dynamic heap. All other heaps are nonvolatile storage heaps that retain their contents through soft reset cycles. 
</p>
<p class="Body">
  <a name="996197"> </a>When a Palm Powered handheld is presented with multiple dynamic heaps, the first heap (heap 0) on card 0 is the active dynamic heap. All other potential dynamic heaps are ignored. For example, it is possible that a future Palm Powered handheld supporting multiple cards might be presented with two cards, each having its own dynamic heap; if so, only the dynamic heap residing on card 0 would be active-the system would not treat any heaps on other cards as dynamic heaps, nor would heap IDs be assigned to these heaps. Subsequent storage heaps would be assigned IDs in sequential order, as always beginning with RAM heaps, followed by ROM heaps. 
</p>
<div class="NINoteImportant"><hr>
  <a name="996198"> </a> <span style="color: #333;  font-style: normal; font-weight: bold; text-decoration: none; text-transform: none; vertical-align: baseline">NOTE:  </span> In Palm OS 3.5, the dynamic heap is sized based on the amount of memory available to the system.
<hr>
</div>

<h4 class="HCHeadC">
  <a name="996199"> </a>Overview of Memory Chunk Structure
</h4>
<p class="Body">
  <a name="996200"> </a>Memory chunks can be movable or nonmovable. Applications need to store data in movable chunks whenever feasible, thereby enabling the Memory Manager to move chunks as necessary to create contiguous free space in memory for allocation requests. 
</p>
<p class="Body">
  <a name="996201"> </a>When the Memory Manager allocates a nonmovable chunk it returns a pointer to that chunk. The pointer is simply that chunk's address in memory. Because the chunk cannot move, its pointer remains valid for the chunk's lifetime; thus, the pointer can be passed "as is" to the caller that requested the allocation. 
</p>
<p class="Body">
  <a name="996202"> </a>When the Memory Manager allocates a moveable chunk, it generates a pointer to that chunk, just as it did for the nonmovable chunk, but it does not return the pointer to the caller. Instead, it stores the pointer to the chunk, called the <b>master chunk pointer</b>, in a <b>master pointer table</b> that is used to track all of the moveable chunks in the heap, and returns a reference to the master chunk pointer. This reference to the master chunk pointer is known as a <b>handle</b>. It is this handle that the Memory Manager returns to the caller that requested the allocation of a moveable chunk. 
</p>
<p class="Body">
  <a name="996203"> </a>Using handles imposes a slight performance penalty over direct pointer access but permits the Memory Manager to move chunks around in the heap without invalidating any chunk references that an application might have stored away. As long as an application uses handles to reference data, only the master pointer to a chunk needs to be updated by the Memory Manager when it moves a chunk during defragmentation.
</p>
<p class="Body">
  <a name="996204"> </a>An application typically locks a chunk handle for a short time while it has to read or manipulate the contents of the chunk. The process of locking a chunk tells the Memory Manager to mark that data chunk as immobile. When an application no longer needs the data chunk, it should unlock the handle immediately to keep heap fragmentation to a minimum.
</p>
<p class="Body">
  <a name="996205"> </a>Note that any handle is good only until the system is reset. When the system resets, it reinitializes all dynamic memory areas and relaunches applications. Therefore, you must not store a handle in a database record or a resource. 
</p>
<p class="Body">
  <a name="996208"> </a>Each chunk on a memory card is actually located by means of a card-relative reference called a <b>local ID</b>. A local ID is a reference to a data chunk that the system computes from the base address of the card. The local ID of a nonmovable chunk is simply the offset of the chunk from the base address of the card. The local ID of a movable chunk is the offset of the master pointer to the chunk from the base address of the card, but with the low-order bit set. Since chunks are always aligned on word boundaries, only local IDs of movable chunks have the low-order bit set. Once the base address of the card is determined at runtime, a local ID can be converted quickly to a pointer or handle. 
</p>
<p class="Body">
  <a name="996210"> </a>For example, when an application needs the handle to a particular data record, it calls the Data Manager to retrieve the record by index from the appropriate database. The Data Manager fetches the local ID of the record out of the database header and uses it to compute the handle to the record. The handle to the record is never actually stored in the database itself. 
</p>
<p class="Body">
  <a name="996211"> </a>Although currently available Palm Powered handhelds do not provide hardware support for multiple cards, the use of local IDs provides support in software for future handhelds that may allow the user to remove or insert memory cards. If the user moves a memory card to a slot having a different base address, the handle to a memory chunk on that card is likely to change, but the local ID associated with that chunk does not change. 
</p>
<div class="NINoteImportant"><hr>
  <a name="996212"> </a> <span style="color: #333;  font-style: normal; font-weight: bold; text-decoration: none; text-transform: none; vertical-align: baseline">IMPORTANT:  </span> Do not confuse memory cards with expansion cards, such as SD cards or MemoryStick cards. You access expansion cards through a different API. See <a href="ExpAndVFSConcepts.html#1000865">Chapter 7, "Expansion,"</a> for more information. 
<hr>
</div>

<h2 class="HaHeadA">
  <a name="996217"> </a>The Memory Manager 
<a href="#995988"><img src="images/top.gif" border="0"></a></h2>

<p class="Body">
  <a name="996218"> </a>The Palm OS Memory Manager is responsible for maintaining the location and size of every memory chunk in nonvolatile storage, volatile storage, and ROM. It provides an API for allocating new chunks, disposing of chunks, resizing chunks, locking and unlocking chunks, and compacting heaps when they become fragmented. Because of the limited RAM and processor resources of the Palm Powered handheld, the Memory Manager is efficient in its use of processing power and memory. 
</p>
<p class="Body">
  <a name="996219"> </a>This section provides background information on the organization of memory in Palm OS and provides an overview of the Memory Manager API, discussing these topics: 
</p>

  <a name="996223"> </a><p class="B1Bullet"> &#8226; <a href="Memory.html#996229">Memory Manager Structures</a></p>

  <a name="996227"> </a><p class="B1Bullet"> &#8226; <a href="Memory.html#996283">Using the Memory Manager</a></p>

<h2 class="HBHeadB">
  <a name="996229"> </a>Memory Manager Structures
<a href="#995988"><img src="images/top.gif" border="0"></a></h2>

<p class="Body">
  <a name="996230"> </a>This section discusses the different structures the Memory Manager uses: 
</p>

  <a name="996234"> </a><p class="B1Bullet"> &#8226; <a href="Memory.html#996244">Heap Structures</a></p>

  <a name="996238"> </a><p class="B1Bullet"> &#8226; <a href="Memory.html#996261">Chunk Structures</a></p>

  <a name="996242"> </a><p class="B1Bullet"> &#8226; <a href="Memory.html#996274">Local ID Structures</a></p>

<h4 class="HCHeadC">
  <a name="996244"> </a>Heap Structures
</h4>
<div class="NINoteImportant"><hr>
  <a name="996245"> </a> <span style="color: #333;  font-style: normal; font-weight: bold; text-decoration: none; text-transform: none; vertical-align: baseline">IMPORTANT:  </span> Expect the heap structure to change in the future. Use the API to work with heaps.
<hr>
</div>
<p class="Body">
  <a name="996247"> </a>A heap consists of the heap header, master pointer table, and the heap chunks.
</p>

  <a name="996249"> </a><p class="B1Bullet"> &#8226; <b>Heap header</b>. The heap header is located at the beginning of the heap. It holds the size of the heap and contains flags for the heap that provide certain information to the Memory Manager; for example, whether the heap is ROM-based.</p>

  <a name="996251"> </a><p class="B1Bullet"> &#8226; <b>Master pointer table</b>. Following the heap header is a master pointer table. It is used to store 32-bit pointers to movable chunks in the heap. </p>
  <a name="996252"> </a><p class="B2BulletSub"> -	 When the Memory Manager moves a chunk to compact the heap, the pointer for that chunk in the master pointer table is updated to the chunk's new location. The handles an application uses to track movable chunks reference the address of the master pointer to the chunk, not the chunk itself. In this way, handles remain valid even after a chunk is moved. The OS compacts the heap automatically when available contiguous space is not sufficient to fulfill an allocation request.</p>  <a name="996253"> </a><p class="B2BulletSub"> -	 If the master pointer table becomes full, another is allocated and its offset is stored in the <span style="font-family: monospace">nextMstrPtrTable</span> field of the previous master pointer table. Any number of master pointer tables can be linked in this way. Because additional master pointer chunks are nonmovable, they are allocated at the end of the heap, according to the guidelines described in the "Heap chunks" section following immediately. </p>
  <a name="996254"> </a><p class="B1Bullet"> &#8226; <b>Heap chunks</b>. Following the master pointer table are the actual chunks in the heap. </p>
  <a name="996256"> </a><p class="B2BulletSub"> -	 Movable chunks are generally allocated at the beginning of the heap, and nonmovable chunks at the end of the heap. </p>  <a name="996257"> </a><p class="B2BulletSub"> -	 Nonmovable chunks do not need an entry in the master pointer table since they are never relocated by the Memory Manager. </p>  <a name="996258"> </a><p class="B2BulletSub"> -	 Applications can easily walk the heap by hopping from chunk to chunk because each chunk header contains the size of the chunk. All free and nonmovable chunks can be found in this manner by checking the flags in each chunk header.</p><p class="Indented1"> <a name="996259"> </a>Because heaps can be ROM-based, there is no information in the header that must be changed when using a heap. Also, ROM-based heaps contain only nonmovable chunks and have a master pointer table with 0 entries. </p>

<h4 class="HCHeadC">
  <a name="996261"> </a>Chunk Structures
</h4>
<div class="NINoteImportant"><hr>
  <a name="996262"> </a> <span style="color: #333;  font-style: normal; font-weight: bold; text-decoration: none; text-transform: none; vertical-align: baseline">IMPORTANT:  </span> Expect the chunk structure to change in the future. Use the API to work with chunks.
<hr>
</div>
<p class="Body">
  <a name="996263"> </a>Each chunk begins with an 8-byte header followed by that chunk's data. The chunk header consists of a <span style="color: #333;;  font-style: normal; font-weight: normal; text-decoration: none; text-transform: none; vertical-align: baseline">Flags:size</span> adjustment byte, 3 bytes of size information, a <span style="color: #333;;  font-style: normal; font-weight: normal; text-decoration: none; text-transform: none; vertical-align: baseline">lock:owner</span> byte, and 3 bytes of <span style="font-family: monospace">hOffset</span> information. 
</p>

  <a name="996264"> </a><p class="B1Bullet"> &#8226; <span style="color: #333;;  font-style: normal; font-weight: bold; text-decoration: none; text-transform: none; vertical-align: baseline">Flags:</span><span style="font-family: monospace">sizeAdj</span><span style="color: #333;;  font-style: normal; font-weight: bold; text-decoration: none; text-transform: none; vertical-align: baseline"> byte.</span>This byte contains flags in the high nibble and a size adjustment in the low nibble. </p>
  <a name="996265"> </a><p class="B2BulletSub"> -	 The flags nibble has 1 bit currently defined, which is set for free chunks. </p>  <a name="996266"> </a><p class="B2BulletSub"> -	 The size adjustment nibble can be used to calculate the requested size of the chunk, given the actual size. The requested size is computed by taking the size as stored in the chunk header and subtracting the size of the header and the size adjustment field. The actual size of a chunk is always a multiple of two so that chunks always start on a word boundary. </p>
  <a name="996267"> </a><p class="B1Bullet"> &#8226; <span style="color: #333;;  font-style: normal; font-weight: bold; text-decoration: none; text-transform: none; vertical-align: baseline">size</span> <b>field (3 bytes)</b>. This three-byte value describes the size of the chunk, which is <b>larger</b> than the size requested by the application and includes the size of the chunk header itself. The maximum data size for a chunk is slightly less than 64 KB.</p>

  <a name="996269"> </a><p class="B1Bullet"> &#8226; <span style="color: #333;;  font-style: normal; font-weight: bold; text-decoration: none; text-transform: none; vertical-align: baseline">Lock:owner</span><span style="color: #333;;  font-style: normal; font-weight: bold; text-decoration: none; text-transform: none; vertical-align: baseline"> byte</span>. Following the size information is a byte that holds the lock count in the high nibble and the owner ID in the low nibble. </p>
  <a name="996270"> </a><p class="B2BulletSub"> -	 The lock count is incremented every time a chunk is locked and decremented every time a chunk is unlocked. A movable chunk can be locked a maximum of 14 times before being unlocked. Nonmovable chunks always have 15 in the lock field.</p>  <a name="996271"> </a><p class="B2BulletSub"> -	 The owner ID determines the owner of a memory chunk and is set by the Memory Manager when allocating a new chunk. Owner ID information is useful for debugging and for garbage collection when an application terminates abnormally. </p>
  <a name="996272"> </a><p class="B1Bullet"> &#8226; <span style="color: #333;;  font-style: normal; font-weight: bold; text-decoration: none; text-transform: none; vertical-align: baseline">hOffset</span><span style="color: #333;;  font-style: normal; font-weight: bold; text-decoration: none; text-transform: none; vertical-align: baseline"> field (3 bytes)</span>. The last three bytes in the chunk header is the distance from the master pointer for the chunk to the chunk's header, divided by two. Note that this offset could be a negative value if the master pointer table is at a higher address than the chunk itself. For nonmovable chunks that do not need an entry in the master pointer table, this field is 0.</p>

<h4 class="HCHeadC">
  <a name="996274"> </a>Local ID Structures
</h4>
<div class="NINoteImportant"><hr>
  <a name="996275"> </a> <span style="color: #333;  font-style: normal; font-weight: bold; text-decoration: none; text-transform: none; vertical-align: baseline">IMPORTANT:  </span> Expect the local ID structure to change in the future. Use the API to work with chunks.
<hr>
</div>
<p class="Body">
  <a name="996276"> </a>Chunks that contain database records or other database information are tracked by the Data Manager through local IDs. A local ID is card relative and is always valid no matter what memory slot the card resides in. A local ID can be easily converted to a pointer or the handle to a chunk once the base address of the card is known. 
</p>
<p class="Body">
  <a name="996277"> </a>The upper 31 bits of a local ID contain the offset of the chunk or master pointer to the chunk from the beginning of the card. The low-order bit is set for local IDs of handles and clear for local IDs of pointers.
</p>
<p class="Body">
  <a name="996281"> </a>The <a href="MemoryManager.html#1133108"><span style="font-family: monospace">MemLocalIDToGlobal</span></a> function converts a local ID and card number (either 0 or 1) to a pointer or handle. It looks at the card number and adds the appropriate card base address to convert the local ID to a pointer or handle for that card.
</p>

<h2 class="HBHeadB">
  <a name="996283"> </a>Using the Memory Manager
<a href="#995988"><img src="images/top.gif" border="0"></a></h2>

<p class="Body">
  <a name="996284"> </a>Use the Memory Manager API to allocate memory in the dynamic heap (for dynamic allocations, stacks, global variables, and so on) and use the Data Manager API to allocate memory in one or more storage heaps (for user data). The Data Manager calls the Memory Manager as appropriate to perform low-level allocations. (See <a href="FilesAndDatabases.html#998438">The Data Manager</a> for more information.)
</p>

<h4 class="HCHeadC">
  <a name="996288"> </a>Overview of the Memory Manager API
</h4>
<p class="Body">
  <a name="996293"> </a>To allocate a movable chunk, call <a href="MemoryManager.html#1132723"><span style="font-family: monospace">MemHandleNew</span></a> and pass the desired chunk size. Before you can read or write data to this chunk, you must call <a href="MemoryManager.html#1132698"><span style="font-family: monospace">MemHandleLock</span></a> to lock it and get a pointer to it. Every time you lock a chunk, its lock count is incremented. You can lock a chunk a maximum of 14 times before an error is returned. (Recall that unmovable chunks hold the value 15 in the lock field.) <a href="MemoryManager.html#1132865"><span style="font-family: monospace">MemHandleUnlock</span></a> reverses the effect of <a href="MemoryManager.html#1132698"><span style="font-family: monospace">MemHandleLock</span></a>-it decrements the value of the lock field by 1. When the lock count is reduced to 0, the chunk is free to be moved by the Memory Manager.
</p>
<p class="Body">
  <a name="996306"> </a>When an application allocates memory in the dynamic heap, the Memory Manager uses an owner ID to associate that chunk with the application. The system further distinguishes chunks belonging to the currently active allocation by setting a special bit in the owner ID information. When the application quits, all chunks in the dynamic heap having this bit set are freed automatically. 
</p>
<p class="Body">
  <a name="996308"> </a>If the system needs to allocate a chunk that is not disposed of when an application quits, it changes the chunk's owner ID to 0 by calling the system functions <a href="MemoryManager.html#1132792"><span style="font-family: monospace">MemHandleSetOwner</span></a> or <a href="MemoryManager.html#1133408"><span style="font-family: monospace">MemPtrSetOwner</span></a>. These functions are not generally used by applications, except in special circumstances. For example, when the current application is passing a parameter block to a new application that it is launching with <a href="SystemManager.html#1166426"><span style="font-family: monospace">SysUIAppSwitch</span></a>, the owner of the block must be set to the system; otherwise, when the current application exits, the system deletes the block when it frees all memory allocated by the current application.
</p>
<p class="Body">
  <a name="996318"> </a>To determine the size of a movable chunk, pass its handle to <a href="MemoryManager.html#1132818"><span style="font-family: monospace">MemHandleSize</span></a>. To resize it, call <a href="MemoryManager.html#1132757"><span style="font-family: monospace">MemHandleResize</span></a>. You generally cannot increase the size of a chunk if it's locked unless there happens to be free space in the heap immediately following the chunk. If the chunk is unlocked, the Memory Manager is allowed to move it to another area of the heap to increase its size.When you no longer need the chunk, call <a href="MemoryManager.html#1132656"><span style="font-family: monospace">MemHandleFree</span></a>, which releases the chunk even if it is locked. 
</p>
<p class="Body">
  <a name="996331"> </a>If you have a pointer to a locked, movable chunk, you can recover the handle by calling <a href="MemoryManager.html#1133367"><span style="font-family: monospace">MemPtrRecoverHandle</span></a>. In fact, all of the <span style="font-family: monospace">MemPtr</span><i>Xxx</i> calls, including <a href="MemoryManager.html#1133434"><span style="font-family: monospace">MemPtrSize</span></a>, also work on pointers to locked, movable chunks.
</p>
<p class="Body">
  <a name="996343"> </a>To allocate a nonmovable chunk, call <a href="MemoryManager.html#1133348"><span style="font-family: monospace">MemPtrNew</span></a> and pass the desired size of the chunk. This call returns a pointer to the chunk, which can be used directly to read or write to it. 
</p>
<div class="NINoteImportant"><hr>
  <a name="996344"> </a> <span style="color: #333;  font-style: normal; font-weight: bold; text-decoration: none; text-transform: none; vertical-align: baseline">NOTE:  </span> You cannot allocate a zero-size chunk.
<hr>
</div>
<p class="Body">
  <a name="996345"> </a>To determine the size of a nonmovable chunk, call <span style="font-family: monospace">MemPtrSize. </span>To resize it, call <a href="MemoryManager.html#1133383"><span style="font-family: monospace">MemPtrResize</span></a>. You generally can't increase the size of a nonmovable chunk unless there is free space in the heap immediately following the chunk. When you no longer need the chunk, call <a href="MemoryManager.html#1133314"><span style="font-family: monospace">MemPtrFree</span></a>, which releases the chunk even if it's locked. 
</p>
<p class="Body">
  <a name="996361"> </a>Use the Memory Manager utility routines <a href="MemoryManager.html#1133188"><span style="font-family: monospace">MemMove</span></a> and <a href="MemoryManager.html#1133492"><span style="font-family: monospace">MemSet</span></a> to move memory from one place to another or to fill memory with a specific value.
</p>
<p class="Body">
  <a name="996362"> </a>In most situations, the proper way to free memory is by calling one of the <a href="MemoryManager.html#1133314"><span style="font-family: monospace">MemPtrFree</span></a> or <a href="MemoryManager.html#1132656"><span style="font-family: monospace">MemHandleFree</span></a> functions.
</p>
<div class="NINoteImportant"><hr>
  <a name="996369"> </a> <span style="color: #333;  font-style: normal; font-weight: bold; text-decoration: none; text-transform: none; vertical-align: baseline">NOTE:  </span> For important cautions and practical advice regarding the proper use of memory on Palm Powered handhelds, be sure to read <a href="Nutshell.html#970185">"Writing Robust Code"</a> in <a href="Nutshell.html#969980">Chapter 1, "Programming Palm OS in a Nutshell,"</a> in this book.
<hr>
</div>

<h4 class="HCHeadC">
  <a name="996376"> </a>Storage Heap Sizes and Memory Management Schemes
</h4>
<p class="Body">
  <a name="996378"> </a>In Palm OS version 1.0, individual storage heaps were limited to a maximum size of 64 KB each and the Memory Manager moved objects automatically among multiple storage heaps to prevent any of them from becoming too full. This strategy tended to decrease the availability of contiguous space for large objects. The version 2.0 Memory Manager abandoned this approach, increasing the availability of contiguous heap space; however, it still limited the maximum size of individual heaps to 64 KB each. Palm OS version 3.0 removed the 64 KB maximum size restriction on individual heaps and creates just two heaps: one 96 KB dynamic heap and one storage heap that is the size of all remaining RAM on the card. 
</p>
<p class="Body">
  <a name="996379"> </a>Starting with Palm OS 3.5, the dynamic heap is sized based on the amount of memory available to the system, as follows:
</p>

<h5 class="TgTable">
  <a name="996397"> </a>

<table border="1" cellpadding="5" cellspacing="0">
  <caption></caption>
  <tr bgcolor="#CCCCCC" valign="top">
    <th><a name="996382"> </a><div class="CellHeading">Device RAM size </div></th>
    <th><a name="996384"> </a><div class="CellHeading">Heap size </div></th>
  </tr>
  <tr valign="top">
    <td><a name="996386"> </a><div class="CellBody">&lt; 2 MB of ram </div></td>
    <td><a name="996388"> </a><div class="CellBody">64 KB</div></td>
  </tr>
  <tr valign="top">
    <td><a name="996390"> </a><div class="CellBody">&gt;= 2 MB </div></td>
    <td><a name="996392"> </a><div class="CellBody">128 KB</div></td>
  </tr>
  <tr valign="top">
    <td><a name="996394"> </a><div class="CellBody">&gt;= 4 MB </div></td>
    <td><a name="996396"> </a><div class="CellBody">256 KB</div></td>
  </tr>
</table>



 
</h5>
<h2 class="HBHeadB">
  <a name="996399"> </a>Achieving Optimum Performance
<a href="#995988"><img src="images/top.gif" border="0"></a></h2>

<p class="Body">
  <a name="996401"> </a>Because the Palm Powered handheld has limited heap space and storage, optimization is critical. To make your application as fast and efficient as possible, optimize for heap space first, speed second, code size third.
</p>
<p class="Body">
  <a name="996402"> </a>Follow these guidelines to optimize memory use: 
</p>

  <a name="996404"> </a><p class="B1Bullet"> &#8226; Allocate handles for your memory to avoid heap fragmentation. That is, use <a href="MemoryManager.html#1132723"><span style="font-family: monospace">MemHandleNew</span></a> to allocate memory rather than <a href="MemoryManager.html#1133348"><span style="font-family: monospace">MemPtrNew</span></a> as much as possible. </p>

  <a name="996412"> </a><p class="B1Bullet"> &#8226; Sort on demand; don't keep different sort lists around. This makes your program simpler and requires less storage. </p>

  <a name="996414"> </a><p class="B1Bullet"> &#8226; Dynamic memory is a potential bottleneck. Don't put large structures on the stack. </p>

  <a name="996416"> </a><p class="B1Bullet"> &#8226; Arrange subroutines within the application to avoid 32K jumps. </p>
<p class="Indented1"> <a name="996417"> </a>Because Palm OS applications must perform well in a RAM-constrained environment, proper code segmentation is critical to achieving optimum performance. </p>
<p class="Indented1"> <a name="996418"> </a>If your application segments are too large, your application may not perform well (or to run at all) when large contiguous blocks of memory are not available. Conversely, if your application segments are too small, performance may be hindered by the overhead required to find and load resources too frequently. </p>
<p class="Indented1"> <a name="996419"> </a>Unfortunately, it's impossible to specify a single size for memory chunks that will perform optimally for all applications.You will need to experiment with segmenting your code in different ways while measuring your application's performance in order to discover the size and arrangement of resource chunks that will optimize your particular application's responsiveness and overall performance. The Metrowerks CodeWarrior Debugger, Palm OS Debugger, and the Simulator provide tools for examining the internal structure of heaps, viewing the amount of free space available, manipulating blocks, and so on. </p>

  <a name="996420"> </a><p class="B1Bullet"> &#8226; To have your application run well within the constraints of the limited dynamic heap, follow these guidelines: </p>
  <a name="996422"> </a><p class="B2BulletSub"> -	 Allocate memory chunks instead of using global variables where possible.</p>  <a name="996423"> </a><p class="B2BulletSub"> -	 Switch from one UI form to another instead of stacking up dialogs. To accomplish this, use <a href="Form.html#1023267"><span style="font-family: monospace">FrmGotoForm</span></a> to switch to forms and <a href="Form.html#1022589"><span style="font-family: monospace">FrmDoDialog</span></a> to switch to modal dialogs. Avoid <a href="Form.html#1023820"><span style="font-family: monospace">FrmPopupForm</span></a>. </p>  <a name="996437"> </a><p class="B2BulletSub"> -	 Edit database records in place; don't make extra copies on the dynamic heap. </p>
  <a name="996439"> </a><p class="B1Bullet"> &#8226; Avoid placing large amounts of data on the stack. Heap corruption is hard to debug. Global variables are preferable to local variables; however, chunks are preferable to global variables. Your application has a limited amount of stack space depending on the system software version. </p>

<h2 class="HaHeadA">
  <a name="996441"> </a>Summary of Memory Management 
<a href="#995988"><img src="images/top.gif" border="0"></a></h2>


<h5 class="TgTable">
  <a name="996643"> </a>

<table border="1" cellpadding="5" cellspacing="0">
  <caption></caption>
  <tr bgcolor="#CCCCCC" valign="top">
    <th><a name="996444"> </a><div class="CellHeading">Memory Manager Functions</div></th>
    <th><a name="996446"> </a><div class="CellHeading"><br></div></th>
  </tr>
  <tr valign="top">
    <td colspan="2" rowspan="1"><a name="996448"> </a><div class="CellHeading">Allocating and Freeing Memory</div></td>
  </tr>
  <tr valign="top">
    <td><a name="996455"> </a><div class="CellBody"><a href="MemoryManager.html#1132723">MemHandleNew</a><br><a href="MemoryManager.html#1132698">MemHandleLock</a><br><a href="MemoryManager.html#1133131">MemLocalIDToLockedPtr</a><br><a href="MemoryManager.html#1132656">MemHandleFree</a></div></td>
    <td><a name="996469"> </a><div class="CellBody"><a href="MemoryManager.html#1133348">MemPtrNew</a><br><a href="MemoryManager.html#1132865">MemHandleUnlock</a><br><a href="MemoryManager.html#1133471">MemPtrUnlock</a><br><a href="MemoryManager.html#1133314">MemPtrFree</a></div></td>
  </tr>
  <tr valign="top">
    <td><a name="996480"> </a><div class="CellHeading">Resizing Chunks</div></td>
    <td><a name="996482"> </a><div class="CellBody"><br></div></td>
  </tr>
  <tr valign="top">
    <td><a name="996487"> </a><div class="CellBody"><a href="MemoryManager.html#1132757">MemHandleResize</a><br><a href="MemoryManager.html#1133383">MemPtrResize</a><br><a href="MemoryManager.html#1132979">MemHeapFreeBytes</a></div></td>
    <td><a name="996498"> </a><div class="CellBody"><a href="MemoryManager.html#1132818">MemHandleSize</a><br><a href="MemoryManager.html#1133434">MemPtrSize</a><br><a href="MemoryManager.html#1133070">MemHeapSize</a></div></td>
  </tr>
  <tr valign="top">
    <td><a name="996506"> </a><div class="CellHeading">Working With Memory</div></td>
    <td><a name="996508"> </a><div class="CellBody"><br></div></td>
  </tr>
  <tr valign="top">
    <td><a name="996513"> </a><div class="CellBody"><a href="MemoryManager.html#1133188">MemMove</a><br><a href="MemoryManager.html#1132572">MemCmp</a></div></td>
    <td><a name="996521"> </a><div class="CellBody"><a href="MemoryManager.html#1133492">MemSet</a><br><a href="MemoryManager.html#1132911">MemHeapCompact</a></div></td>
  </tr>
  <tr valign="top">
    <td><a name="996526"> </a><div class="CellHeading">Converting Pointers</div></td>
    <td><a name="996528"> </a><div class="CellBody"><br></div></td>
  </tr>
  <tr valign="top">
    <td><a name="996533"> </a><div class="CellBody"><a href="MemoryManager.html#1133367">MemPtrRecoverHandle</a><br><a href="MemoryManager.html#1133092">MemLocalIDKind</a><br><a href="MemoryManager.html#1133450">MemPtrToLocalID</a></div></td>
    <td><a name="996544"> </a><div class="CellBody"><a href="MemoryManager.html#1132840">MemHandleToLocalID</a><br><a href="MemoryManager.html#1133108">MemLocalIDToGlobal</a><br><a href="MemoryManager.html#1133164">MemLocalIDToPtr</a></div></td>
  </tr>
  <tr valign="top">
    <td><a name="996552"> </a><div class="CellHeading">Chunk Information</div></td>
    <td><a name="996554"> </a><div class="CellBody"><br></div></td>
  </tr>
  <tr valign="top">
    <td><a name="996559"> </a><div class="CellBody"><a href="MemoryManager.html#1132613">MemHandleCardNo</a><br><a href="MemoryManager.html#1132677">MemHandleHeapID</a><br><a href="MemoryManager.html#1133274">MemPtrCardNo</a><br><a href="MemoryManager.html#1133408">MemPtrSetOwner</a></div></td>
    <td><a name="996573"> </a><div class="CellBody"><a href="MemoryManager.html#1132633">MemHandleDataStorage</a><br><a href="MemoryManager.html#1132792">MemHandleSetOwner</a><br><a href="MemoryManager.html#1133292">MemPtrDataStorage</a></div></td>
  </tr>
  <tr valign="top">
    <td><a name="996581"> </a><div class="CellHeading">Heap Information</div></td>
    <td><a name="996583"> </a><div class="CellBody"><br></div></td>
  </tr>
  <tr valign="top">
    <td><a name="996588"> </a><div class="CellBody"><a href="MemoryManager.html#1133331">MemPtrHeapID</a><br><a href="MemoryManager.html#1132928">MemHeapDynamic</a><br><a href="MemoryManager.html#1132954">MemHeapFlags</a></div></td>
    <td><a name="996599"> </a><div class="CellBody"><a href="MemoryManager.html#1133018">MemHeapID</a><br><a href="MemoryManager.html#1132889">MemHeapCheck</a><br></div></td>
  </tr>
  <tr valign="top">
    <td><a name="996604"> </a><div class="CellHeading">Card Information</div></td>
    <td><a name="996606"> </a><div class="CellBody"><br></div></td>
  </tr>
  <tr valign="top">
    <td><a name="996611"> </a><div class="CellBody"><a href="MemoryManager.html#1132549">MemCardInfo</a> <br><a href="MemoryManager.html#1133227">MemNumHeaps</a><br><a href="MemoryManager.html#1133533">MemStoreInfo</a></div></td>
    <td><a name="996622"> </a><div class="CellBody"><a href="MemoryManager.html#1133213">MemNumCards</a><br><a href="MemoryManager.html#1133255">MemNumRAMHeaps</a><br></div></td>
  </tr>
  <tr valign="top">
    <td><a name="996627"> </a><div class="CellHeading">Debugging</div></td>
    <td><a name="996629"> </a><div class="CellBody"><br></div></td>
  </tr>
  <tr valign="top">
    <td><a name="996634"> </a><div class="CellBody"><a href="MemoryManager.html#1132596">MemDebugMode</a> <br><a href="MemoryManager.html#1133516">MemSetDebugMode</a></div></td>
    <td><a name="996642"> </a><div class="CellBody"><a href="MemoryManager.html#1133044">MemHeapScramble</a></div></td>
  </tr>
</table>




</h5><p class="Body">
  <a name="996655"> </a>
</p>
&nbsp;<br>
				<!-- CONTENT_END -->

		</td>
		<td width="5">&nbsp;&nbsp;</td>
	</tr>
      </table>
    </td>
			</tr>
  <tr>
				<td>
					<table border="0" cellpadding="0" cellspacing="0" width="760">
        <!-- CONTENTCELL_END -->
        <tr valign="top"> 
          <td width="10">&nbsp;<!-- FOOTER_START --></td>
          <td width="72">&nbsp;</td>
          <td width="25" bgcolor="white" background="images/bkgrnd.gif">&nbsp;</td>
          <td width="600"> 
            <table border="0" cellpadding="0" cellspacing="0" width="600">
              <tr> 
                <td><img src="images/rule_10-1-5_ltblue.gif" width="600" height="16" border="0"></td>
              </tr>
              <tr> 
                <td> 
                  <p align="center" class="footer"> ©2002 PalmSource, Inc. and its affiliates.  All rights reserved. 
<a href="http://www.palmos.com/dev/training/">Training</a>&nbsp;|&nbsp;<a href="http://www.palmos.com/dev/support/kb/">Knowledge Base</a>&nbsp;|&nbsp;<a href="http://www.palmos.com/">Palm&nbsp;OS&nbsp;Platform</a>&nbsp;|&nbsp;<a href="Companion_Front.html" target="_blank">Legal Notices</a>&nbsp;<br>
												<!-- FOOTER_END --><br>
											</p>
                </td>
              </tr>
            </table>
          </td>
        </tr>
      </table>
				</td>
			</tr>
</table>
</BODY>
</HTML>