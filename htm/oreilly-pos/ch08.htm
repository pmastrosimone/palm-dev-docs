<HTML>
<HEAD>
<TITLE>Palm OS:  &#160;8.&#160; Extras </TITLE>
<META NAME="GENERATOR" CONTENT="Transit Central Station 3.2 by InfoAccess Inc. www.infoaccess.com">
</HEAD>
<BODY BACKGROUND="images/grnitbkg.gif"><A NAME="TopOfPage"> </A>
<A HREF="http://www.oreilly.com/catalog/palmprog/"><IMG SRC="images/palm_comp_ani_ad.gif" ALT="Order the book from O'Reilly" BORDER=0 width="468" height="60"></A>
<P ALIGN=RIGHT><!-- TRANSIT - PREVIOUS PAGE --><A HREF="ch07.htm#TopOfPage"><IMG SRC="images/appleppv.gif" ALT="Previous Page" BORDER=0 width="34" height="26"></A><!-- TRANSIT - TOC --><A HREF="TableOfContents.htm#TopOfPage" TARGET="_top"><IMG SRC="images/appletoc.gif" ALT="Table Of Contents" BORDER=0 width="34" height="26"></A><!-- TRANSIT - INDEX --><A HREF="index.htm#TopOfPage"><IMG SRC="images/appleidx.gif" ALT="Index" BORDER=0 width="34" height="26"></A><!-- TRANSIT - NEXT PAGE --><A HREF="ch09.htm#TopOfPage"><IMG SRC="images/applepnx.gif" ALT="Next Page" BORDER=0 width="34" height="26"></A></P><P><I>In this chapter:</I></P>


  <UL COMPACT><LI><A HREF="#P27_302" NAME="LOC_P27_302">Tables</A></LI>

  <LI><A HREF="#P506_19236" NAME="LOC_P506_19236">Tables in the Sample Application</A></LI>

  <LI><A HREF="#P983_37405" NAME="LOC_P983_37405">Find</A></LI>

  <LI><A HREF="#P1306_56888" NAME="LOC_P1306_56888">Beaming</A></LI>

  <LI><A HREF="#P1781_78849" NAME="LOC_P1781_78849">Barcodes</A></LI></UL>
<P><UL><UL><UL><UL><UL><UL><UL><UL><UL><UL>
<TABLE>
<TR>
<TD WIDTH=156>
</TD></TR></TABLE></UL></UL></UL></UL></UL></UL></UL></UL></UL></UL>

<P ALIGN=LEFT><IMG SRC="images/applespl.gif" width="751" height="7"></P>
<H1 ALIGN=LEFT><I><FONT SIZE=+3>&#160;8.&#160; Extras</FONT></I></H1>
<P ALIGN=LEFT><IMG SRC="images/applespl.gif" width="751" height="7"></P>

<P ALIGN=LEFT><FONT FACE="Times">This chapter is a grab bag of items that have no particular programmatic relationship to each other. We put them together here because they need to be discussed, and they had to go somewhere. </FONT></P>

<P><A NAME="P27_302"></A>

<TABLE BORDER=0 WIDTH="100%">
<TR>
<TD><H1 ALIGN=LEFT><I><FONT FACE="Times" SIZE="+2">Tables</FONT></I></H1></TD>
<TD><P ALIGN=RIGHT><A HREF="#TopOfPage"><IMG SRC="images/appletop.gif" ALT="Top Of Page" BORDER=0 width="34" height="26"></A></P></TD></TR></TABLE></P>
<P ALIGN=LEFT><IMG SRC="images/applespl.gif" width="751" height="7"></P>

<P ALIGN=LEFT><FONT FACE="Times"><A NAME="P29_308"></A>In this section, we do three things. First, we talk in general about tables, the kinds of data they contain, what they look like, what features are automatically supported, and what you need to add yourself. Second, we create a small sample application that shows you how to implement all the available table data types. Third, we show you the implementation of a table in our Sales order application. We also discuss the problems that we encountered in implementing tables and offer you a variety of tips.</FONT></P>

<P><I><FONT FACE="Times" SIZE="+1">An Overview of Tables</FONT></I></P>

<P ALIGN=LEFT><FONT FACE="Times">Tables are useful forms if you need to display and edit multiple columns of data. (Use a list to display a single column; see &quot;List Objects&quot; in Chapter&#160;5, <I>Forms and Form Objects</I>, on page&#160;91). <A HREF="#P35_1227">Figure 8-1</A> contains three examples of tables from the built-in applications. As you can see, tables can contain a number of different types of data-everything from text to dates to numbers.</FONT></P>

<P><B><FONT FACE="Times" SIZE="-1">Figure 8- 1</FONT></B><A NAME="P35_1227"></A>. 

<B><FONT FACE="Times" SIZE="-1"><A NAME="P37_1227"></A>Sample tables from the built-in applications; the first item in the To Do list has a note icon associated with it</FONT></B><BR>
<P><UL>
<TABLE>
<TR>
<TD WIDTH=512><P ALIGN=CENTER><IMG SRC="images/ch08-plmp.0801-1.gif" WIDTH=503 HEIGHT=139 align=left></P>
</TD></TR></TABLE></UL>

<P><I><FONT FACE="Times">Scrolling in tables</FONT></I></P>

<P ALIGN=LEFT><FONT FACE="Times"><A NAME="P47_1359"></A>While the List Manager automatically supports scrolling, the Table Manager does not. You have to add that support if you need it.</FONT></P>

<P><I><FONT FACE="Times">Adjusting width and height</FONT></I></P>

<P ALIGN=LEFT><FONT FACE="Times"><A NAME="P51_1514"></A>The height and width of table columns and rows are independently adjustable (in fact, editing a text field automatically makes a row change size).</FONT></P>

<P><I><FONT FACE="Times">Data types in tables</FONT></I></P>

<P ALIGN=LEFT><FONT FACE="Times"><A NAME="P55_1680"></A>The Palm OS Table Manager offers greater built-in support for displaying data than for editing it. The following sections list the data types and whether the Table Manager supports them for display purposes only or for editing as well.</FONT></P>

<P><I><FONT FACE="Times">Display-only data types</FONT></I></P>

<P ALIGN=LEFT><FONT FACE="Times">The following are display-only data types:</FONT></P>

  <UL><LI><FONT FACE="Times">  Numbers</FONT></LI>

  <LI><FONT FACE="Times">  Dates</FONT></LI>

  <LI><FONT FACE="Times">  Labels (non-editable text)</FONT></LI></UL>

<P><I><FONT FACE="Times">Edit and display data types</FONT></I></P>

<P ALIGN=LEFT><FONT FACE="Times">The following are edit and display data types:</FONT></P>

  <UL><LI><FONT FACE="Times">  Text (including an optional note icon; see <A HREF="#P37_1227">Figure 8-1</A>)</FONT></LI>

  <LI><FONT FACE="Times">  Pop-up triggers</FONT></LI>

  <LI><FONT FACE="Times">  Checkboxes</FONT></LI></UL>

<P ALIGN=LEFT><FONT FACE="Times">Unlike other controls, tables require some programming in order to work. The table stores data for each cell in two parts-an integer and a pointer. The data is used differently, depending on the type of the column. Because of this, you must specify a data type for each column. Here are the possible specifications you can make.</FONT></P>

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=6>

<TR BGCOLOR="#DCF0FF">

<TD>

NOTE:<BR>
<P ALIGN=LEFT><FONT FACE="Times">The source code for the 1.0 OS Table Manager can be found at </FONT><FONT FACE="Times" SIZE="-1"><I>http:// www.palmpilot.com/dev</I>. Be aware that the Table Manager has changed since the 1.0 OS. It is still useful, however, as it gives you a good idea of how the manager works.</FONT></P>
</TD>

</TR>

</TABLE>

<P><I><FONT FACE="Times">Display-only data types</FONT></I></P>

<P ALIGN=LEFT><FONT FACE="Times">These are the actual names of data types supported by the Table Manager. These <A NAME="P80_2852"></A>display-only types cannot be edited.</FONT></P>

<P><I><FONT FACE="Times"><A NAME="P82_2888"></A>dateTableItem</FONT></I></P>

<P><FONT FACE="Times">This displays a date (as month/day). The data for a cell should be an integer that can be cast to a </FONT><FONT FACE="Courier New">DateType</FONT><FONT FACE="Times">. If the value is -1, a hyphen (-) is displayed; otherwise, the actual date is shown. If the displayed date is earlier than the handheld's current date, an exclamation point (!) is appended to it. Tapping on a date highlights the cell.</FONT></P>

<P><I><FONT FACE="Times">labelTableItem</FONT></I><A NAME="P84_3258"></A></P>

<P><FONT FACE="Times">This displays the text stored in the pointer portion of the cell with an appended colon (:). Tapping on a label highlights the cell.</FONT></P>

<P><I><FONT FACE="Times">numericTableItem</FONT></I><A NAME="P86_3406"></A></P>

<P><FONT FACE="Times">This displays the number stored in the integer portion of the cell. Tapping on a numeric cell highlights the cell.</FONT></P>

<P><I><FONT FACE="Times">Editable data types</FONT></I></P>

<P ALIGN=LEFT><FONT FACE="Times">These are the <A NAME="P91_3553"></A>types of data that the user can change or edit as necessary:</FONT></P>

<P><I><FONT FACE="Times">checkboxTableItem</FONT></I><A NAME="P93_3630"></A></P>

<P><FONT FACE="Times">This displays a checkbox with no associated label. The data for a particular cell should be an integer with a value of either 0 or 1. Clicking on the checkbox toggles the value. Tapping on a checkbox doesn't highlight the row.</FONT></P>

<P><I><FONT FACE="Times">popupTriggerTableItem</FONT></I><A NAME="P95_3877"></A></P>

<P><FONT FACE="Times">This displays an item from a pop-up list (with an arrow before it). The list pointer is stored in the pointer data of the cell; the item from the list is stored in the integer data of the cell. Tapping on a pop-up trigger displays the pop-up, allowing the user to change the value in the integer.</FONT></P>

<P><I><FONT FACE="Times">textTableItem</FONT></I><A NAME="P97_4186"></A></P>

<P><FONT FACE="Times">This displays a text cell that can be edited. The column that contains these cells needs a load routine that provides a handle. This handle has an offset and length that are used when editing the text cell. An optional save routine is called after editing.</FONT></P>

<P><I><FONT FACE="Times">textWithNoteTableItem</FONT></I><A NAME="P99_4463"></A></P>

<P><FONT FACE="Times">This is similar to </FONT><FONT FACE="Courier New">textTableItem</FONT><FONT FACE="Times">, but it also displays a note icon at the righthand side of the cell. Tapping on the note icon highlights the cell.</FONT></P>

<P><I><FONT FACE="Times">narrowTextTableItem</FONT></I><A NAME="P101_4629"></A></P>

<P><FONT FACE="Times">This is like </FONT><FONT FACE="Courier New">textTableItem</FONT><FONT FACE="Times">, but it reserves space at the righthand side of the cell. The number of pixel spaces reserved is stored in the integer data of the cell. This is often used for text fields that have 0 or more icons and need to reserve space for them.</FONT></P>

<P><I><FONT FACE="Times">customTableItem</FONT></I><A NAME="P103_4904"></A></P>

<P><FONT FACE="Times">This is used for a custom cell. A callback routine needs to be installed for the column; it will be called to draw the contents of each cell at display time. The callback routine can use the integer and pointer data in the cell for whatever it likes. Tapping on a custom table cell highlights the cell.</FONT><A NAME="P104_5206"></A></P>

<P><I><FONT FACE="Times">Initializing tables</FONT></I></P>

<P ALIGN=LEFT><FONT FACE="Times"><A NAME="P108_5225"></A>There are some difficulties with initializing tables. When you initialize a table, you should first set the types of each column. You can further mark each row and column as usable or unusable. By dynamically switching a column (or row) from unusable to usable (or usable to unusable), you can make it appear (or disappear).</FONT></P>

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=6>

<TR BGCOLOR="#DCF0FF">

<TD>

NOTE:<BR>
<P ALIGN=LEFT><FONT FACE="Times">Although </FONT><FONT FACE="Times" SIZE="-1"><I>Table.h</I> defines a </FONT><FONT FACE="Courier New">timeTableItem</FONT><FONT FACE="Times"> type, this type doesn't actually work.</FONT><BR>
</P>
</TD>

</TR>

</TABLE>

<P ALIGN=LEFT><FONT FACE="Times">If you make changes to the data in a cell, you need to mark that row invalid so that it will be redisplayed when the table is redrawn. For some mysterious reason, by default rows are usable, but by default columns are not. If you don't explicitly mark your columns as usable, they won't display.</FONT></P>

<P ALIGN=LEFT><FONT FACE="Times">You can set a two-byte ID and a two-byte data value, which are associated with each row. It's common to set the row ID to the record number of a record in a database.</FONT></P>

<P><I><FONT FACE="Times" SIZE="+1">Simple Table Sample</FONT></I></P>

<P ALIGN=LEFT><FONT FACE="Times">The following sections describe a table sample in a simple application that shows you how to use all the table data types available in the Table Manager. <A HREF="#P122_6547">Figure 8-2</A> shows the running application. You can see that it contains one table with nine columns and eight rows. <A HREF="#P131_6574">Figure 8-3</A> contains the resource descriptions as they are created in Constructor. Note that the columns go from the easiest data types to code to the hardest.</FONT></P>

<P><B><FONT FACE="Times" SIZE="-1">-Figure 8- 2</FONT></B>. 

<B><FONT FACE="Times" SIZE="-1"><A NAME="P122_6547"></A>The table sample</FONT></B><BR>
<P><UL>
<TABLE>
<TR>
<TD WIDTH=512><P ALIGN=CENTER><IMG SRC="images/ch08-plmp.0802-2.gif" WIDTH=503 HEIGHT=116 align=left></P>
</TD></TR></TABLE></UL>

<P><B><FONT FACE="Times" SIZE="-1">Figure 8- 3</FONT></B>. 

<B><FONT FACE="Times" SIZE="-1"><A NAME="P131_6574"></A>The table resource in Constructor</FONT></B><BR>
<P><UL>
<TABLE>
<TR>
<TD WIDTH=512><P ALIGN=CENTER><IMG SRC="images/ch08-plmp.0803-3.gif" WIDTH=503 HEIGHT=291 align=left></P>
</TD></TR></TABLE></UL>

<P ALIGN=LEFT><FONT FACE="Times"> </FONT></P>

<P><I><FONT FACE="Times">Initialization of the simple table sample</FONT></I></P>

<P ALIGN=LEFT><FONT FACE="Times"><A NAME="P141_6649"></A>Initializing this table requires initializing the style and data for each cell in the table. <A HREF="#P143_6885">Example&#160;8-1</A> shows you the entire initialization method. First, look at the entire block of code; then we discuss it, bit by bit.</FONT></P>

<P><B><FONT FACE="Times" SIZE="-1">&#160;-Example&#160; 8- 1</FONT></B><A NAME="P143_6885"></A>. 

<B><FONT FACE="Times" SIZE="-1">Initialization of Table</FONT></B></P><PRE><FONT SIZE="-1"> void MainViewInit(void)</FONT>
<FONT SIZE="-1">{</FONT>
<FONT SIZE="-1">   FormPtr        frm;</FONT>
<FONT SIZE="-1">   TablePtr       tableP;</FONT>
<FONT SIZE="-1">   UInt           numRows;</FONT>
<FONT SIZE="-1">   UInt           i;</FONT>
<FONT SIZE="-1">   static char *  labels[] = {&quot;0&quot;, &quot;1&quot;, &quot;2&quot;, &quot;3&quot;, &quot;4&quot;, &quot;5&quot;, &quot;6&quot;, &quot;7&quot;};</FONT>
<FONT SIZE="-1">   DateType       dates[10];</FONT>
<FONT SIZE="-1">   ListPtr        list;</FONT>
<FONT SIZE="-1">   </FONT>
<FONT SIZE="-1">   // we&quot;ll have a missing date, and then some dates before and</FONT>
<FONT SIZE="-1">   // after the current date</FONT>
<FONT SIZE="-1">   * ((IntPtr) &amp;dates[0]) = noTime;</FONT>
<FONT SIZE="-1">   for (i = 1; i &lt; sizeof(dates)/sizeof(*dates); i++) {</FONT>
<FONT SIZE="-1">      dates[i].year = 1994 + i - 1904; // offset from 1904</FONT>
<FONT SIZE="-1">      dates[i].month = 8;</FONT>
<FONT SIZE="-1">      dates[i].day = 29;</FONT>
<FONT SIZE="-1">   }</FONT>
<FONT SIZE="-1">   // Get a pointer to the main form.</FONT>
<FONT SIZE="-1">   frm = FrmGetActiveForm();</FONT>
<FONT SIZE="-1">   </FONT>
<FONT SIZE="-1">   tableP = FrmGetObjectPtr(frm, </FONT>
<FONT SIZE="-1">      FrmGetObjectIndex(frm, MemoPadMainTableTable));</FONT>
<FONT SIZE="-1">   list = FrmGetObjectPtr(frm, </FONT>
<FONT SIZE="-1">      FrmGetObjectIndex (frm, MemoPadMainListList));</FONT>

<FONT SIZE="-1">   numRows = TblGetNumberOfRows (tableP);</FONT>
<FONT SIZE="-1">   for (i = 0; i &lt; numRows; i++) {</FONT>
<FONT SIZE="-1">      TblSetItemStyle(tableP, i, 0, textWithNoteTableItem);</FONT>
<FONT SIZE="-1">      </FONT>
<FONT SIZE="-1">      TblSetItemStyle(tableP, i, 1, numericTableItem);</FONT>
<FONT SIZE="-1">      TblSetItemInt(tableP, i, 1, i);</FONT>
<FONT SIZE="-1">      </FONT>
<FONT SIZE="-1">      TblSetItemStyle(tableP, i, 2, checkboxTableItem);</FONT>
<FONT SIZE="-1">      TblSetItemInt(tableP, i, 2, i % 2);</FONT>
<FONT SIZE="-1">      </FONT>
<FONT SIZE="-1">      TblSetItemStyle(tableP, i, 3, labelTableItem);</FONT>
<FONT SIZE="-1">      TblSetItemPtr(tableP, i, 3, labels[i]);</FONT>

<FONT SIZE="-1">      TblSetItemStyle(tableP, i, 4, dateTableItem);</FONT>
<FONT SIZE="-1">      TblSetItemInt(tableP, i, 4, DateToInt(dates[i]));</FONT>

<FONT SIZE="-1">      TblSetItemStyle(tableP, i, 5, textTableItem);</FONT>
<FONT SIZE="-1">      TblSetItemInt(tableP, i, 5, i * 2);</FONT>

<FONT SIZE="-1">      TblSetItemStyle(tableP, i, 6, popupTriggerTableItem);</FONT>
<FONT SIZE="-1">      TblSetItemInt(tableP, i, 6, i % 5);</FONT>
<FONT SIZE="-1">      TblSetItemPtr(tableP, i, 6, list);</FONT>

<FONT SIZE="-1">      TblSetItemStyle(tableP, i, 7, narrowTextTableItem);</FONT>
<FONT SIZE="-1">      TblSetItemInt(tableP, i, 7, i * 2);</FONT>

<FONT SIZE="-1">      TblSetItemStyle(tableP, i, 8, customTableItem);</FONT>
<FONT SIZE="-1">      TblSetItemInt(tableP, i, 8, i % 4);</FONT>
<FONT SIZE="-1">   }</FONT>
<FONT SIZE="-1">   TblSetRowUsable(tableP, 1, false);  // just to see what happens</FONT>
<FONT SIZE="-1">   </FONT>
<FONT SIZE="-1">   for (i = 0; i &lt; kNumColumns; i++)</FONT>
<FONT SIZE="-1">      TblSetColumnUsable(tableP, i, true);</FONT>

<FONT SIZE="-1">   TblSetLoadDataProcedure(tableP, 0, CustomLoadItem);</FONT>
<FONT SIZE="-1">   TblSetLoadDataProcedure(tableP, 5, CustomLoadItem);</FONT>
<FONT SIZE="-1">   TblSetSaveDataProcedure(tableP, 5, CustomSaveItem);</FONT>
<FONT SIZE="-1">   TblSetLoadDataProcedure(tableP, 7, CustomLoadItem);</FONT>
<FONT SIZE="-1">   </FONT>
<FONT SIZE="-1">   TblSetCustomDrawProcedure(tableP, 8, CustomDrawItem);</FONT>

<FONT SIZE="-1">   // Draw the form.</FONT>
<FONT SIZE="-1">   FrmDrawForm(frm);</FONT>
<FONT SIZE="-1">}</FONT></PRE>

<P ALIGN=LEFT><FONT FACE="Times">Let's look at the columns not in column order, but in terms of complexity.</FONT></P>

<P><I><FONT FACE="Times">Column 1-handling numbers</FONT></I></P>

<P ALIGN=LEFT><FONT FACE="Times">The code starts with a numeric column that is quite an easy data type to handle. We use the row number as the number to display. Here's the code that executes for each row. As you can see, there is not a lot to it:</FONT></P><PRE><FONT SIZE="-1">      TblSetItemStyle(tableP, i, 1, numericTableItem);</FONT>
<FONT SIZE="-1">      TblSetItemInt(tableP, i, 1, i);</FONT></PRE>

<P><I><FONT FACE="Times">Column 2-a checkbox</FONT></I></P>

<P ALIGN=LEFT><FONT FACE="Times"><A NAME="P229_9535"></A>This second column displays a simple checkbox. We set the initial value of the checkbox to be on for even row numbers and off for odd row numbers:</FONT></P><PRE><FONT SIZE="-1">      TblSetItemStyle(tableP, i, 2, checkboxTableItem);</FONT>
<FONT SIZE="-1">      TblSetItemInt(tableP, i, 2, i % 2);</FONT></PRE>

<P><I><FONT FACE="Times">Column 3-a label</FONT></I></P>

<P ALIGN=LEFT><FONT FACE="Times"><A NAME="P235_9793"></A>This column displays a label that contains a piece of noneditable text. We set the text to successive values from a text array. The table manager appends a colon to the label:</FONT></P><PRE><FONT SIZE="-1">static char *   labels[] = {&quot;0&quot;, &quot;1&quot;, &quot;2&quot;, &quot;3&quot;, &quot;4&quot;, &quot;5&quot;, &quot;6&quot;, &quot;7&quot;};</FONT>
<FONT SIZE="-1">// for each row:</FONT>
<FONT SIZE="-1">    TblSetItemStyle(tableP, i, 3, labelTableItem);</FONT>
<FONT SIZE="-1">    TblSetItemPtr(tableP, i, 3, labels[i]);</FONT></PRE>

<P><I><FONT FACE="Times">Column 4-a date</FONT></I></P>

<P ALIGN=LEFT><FONT FACE="Times"><A NAME="P243_10160"></A>In the date column, we create an array of dates that are used to initialize each cell. Note that the first date is missing, which is why the &quot;-&quot; is displayed instead of a date. The remaining dates range over successive years; some dates are before the current time, and others are after it:</FONT></P><PRE><FONT SIZE="-1">   DateType       dates[10];</FONT>
<FONT SIZE="-1">   ListPtr        list;</FONT>
<FONT SIZE="-1">   </FONT>
<FONT SIZE="-1">   // we&quot;ll have a missing date, and then some before and after </FONT>
<FONT SIZE="-1">   // the current date</FONT>
<FONT SIZE="-1">   * ((IntPtr) &amp;dates[0]) = noTime;</FONT>
<FONT SIZE="-1">   for (i = 1; i &lt; sizeof(dates)/sizeof(*dates); i++) {</FONT>
<FONT SIZE="-1">      dates[i].year = 1994 + i - 1904; // offset from 1904</FONT>
<FONT SIZE="-1">      dates[i].month = 8;</FONT>
<FONT SIZE="-1">      dates[i].day = 29;</FONT>
<FONT SIZE="-1">   }</FONT>
<FONT SIZE="-1">   // for each row:</FONT>
<FONT SIZE="-1">      TblSetItemStyle(tableP, i, 4, dateTableItem);</FONT>
<FONT SIZE="-1">      TblSetItemInt(tableP, i, 4, DateToInt(dates[i]));</FONT></PRE>

<P><I><FONT FACE="Times">Column 6-a pop-up trigger</FONT></I></P>

<P ALIGN=LEFT><FONT FACE="Times"><A NAME="P261_10941"></A>As with any pop-up trigger, we've got to create a list in our resource. We've created one that has the values &quot;1&quot;, &quot;2&quot;, &quot;3&quot;, &quot;4&quot;, and &quot;5&quot;. For each cell in the column, we set the pointer value to the list itself, then set the data value as the item number in the list:</FONT></P><PRE><FONT SIZE="-1">   ListPtr   list;</FONT>
<FONT SIZE="-1">   list = FrmGetObjectPtr(frm, </FONT>
<FONT SIZE="-1">      FrmGetObjectIndex(frm, MemoPadMainListList));</FONT>
<FONT SIZE="-1">   // for each row:</FONT>
<FONT SIZE="-1">      TblSetItemStyle(tableP, i, 6, popupTriggerTableItem);</FONT>
<FONT SIZE="-1">      TblSetItemInt(tableP, i, 6, i % 5);</FONT>
<FONT SIZE="-1">      TblSetItemPtr(tableP, i, 6, list);</FONT></PRE>

<P><I><FONT FACE="Times">Columns 0, 5, and 7-handling text</FONT></I></P>

<P ALIGN=LEFT><FONT FACE="Times"><A NAME="P272_11501"></A>Now let's look at the text columns. Notice that we use all three of the available text column types:</FONT></P><PRE><FONT SIZE="-1">      TblSetItemStyle(tableP, i, 0, textWithNoteTableItem);</FONT>
<FONT SIZE="-1">      TblSetItemStyle(tableP, i, 5, textTableItem);</FONT>
<FONT SIZE="-1">      TblSetItemStyle(tableP, i, 7, narrowTextTableItem);</FONT></PRE>

<P ALIGN=LEFT><FONT FACE="Times">With the narrow text table item, we set the integer data as a pixel reserve on the righthand side. We give each row a different pixel reserve so that we can see the effect:</FONT></P><PRE><FONT SIZE="-1">      TblSetItemInt(tableP, i, 7, i * 2);</FONT></PRE>

<P ALIGN=LEFT><FONT FACE="Times">Each of the text items requires a custom load procedure to provide the needed handle for the cell. Actually, we have the option of providing only a portion of the handle as well:</FONT></P><PRE><FONT SIZE="-1">   TblSetLoadDataProcedure(tableP, 0, CustomLoadItem);</FONT>
<FONT SIZE="-1">   TblSetLoadDataProcedure(tableP, 5, CustomLoadItem);</FONT>
<FONT SIZE="-1">   TblSetLoadDataProcedure(tableP, 7, CustomLoadItem);</FONT></PRE>

<P ALIGN=LEFT><FONT FACE="Times">We customize the saving of the second text column:</FONT></P><PRE><FONT SIZE="-1">   TblSetSaveDataProcedure(tableP, 5, CustomSaveItem);</FONT></PRE>

<P ALIGN=LEFT><FONT FACE="Times">We'll look at the custom load and save routines that we just called after we discuss the eighth column.</FONT></P>

<P><I><FONT FACE="Times">Column 8-handling custom content</FONT></I></P>

<P ALIGN=LEFT><FONT FACE="Times">The final column is a custom column that displays a line at one of four angles. The angle is determined by the integer data in the cell. We initialize the integer data to a value between 0 and 3, depending on the row:</FONT></P><PRE><FONT SIZE="-1">      TblSetItemStyle(tableP, i, 8, customTableItem);</FONT>
<FONT SIZE="-1">      TblSetItemInt(tableP, i, 8, i % 4);</FONT></PRE>

<P ALIGN=LEFT><FONT FACE="Times">We set a custom draw procedure for that column:</FONT></P><PRE><FONT SIZE="-1">   TblSetCustomDrawProcedure(tableP, 8, CustomDrawItem);</FONT></PRE>

<P><I><FONT FACE="Times">Displaying the columns</FONT></I></P>

<P ALIGN=LEFT><FONT FACE="Times">In order to make the columns display, we've got to mark them usable:</FONT></P><PRE><FONT SIZE="-1">   for (i = 0; i &lt; kNumColumns; i++)</FONT>
<FONT SIZE="-1">      TblSetColumnUsable(tableP, i, true);</FONT></PRE>

<P ALIGN=LEFT><FONT FACE="Times">Just as an exercise, we mark row 1 as unusable (now it won't appear in the table):</FONT></P><PRE><FONT SIZE="-1">   TblSetRowUsable(tableP, 1, false);   // just to see what happens</FONT></PRE>

<P><I><FONT FACE="Times">Custom load routines</FONT></I></P>

<P ALIGN=LEFT><FONT FACE="Times"><A NAME="P310_13311"></A>The custom load routines that we used with the text columns need to return three things: </FONT></P>

  <UL><LI><FONT FACE="Times">  A handle</FONT></LI>

  <LI><FONT FACE="Times">  An offset within it</FONT></LI>

  <LI><FONT FACE="Times">  A length within it</FONT></LI></UL>

<P ALIGN=LEFT><FONT FACE="Times">The Table Manager calls on the Field Manager to display and edit the range within the handle. It's our job to allocate one (null-terminated) handle for every text cell:</FONT></P><PRE><FONT SIZE="-1">#define  kNumTextColumns   3</FONT>
<FONT SIZE="-1">Handle   gHandles[kNumTextColumns][kNumRows];</FONT>
<FONT SIZE="-1">static Boolean StartApplication(void)</FONT>
<FONT SIZE="-1">{</FONT>
<FONT SIZE="-1">   int   i;</FONT>
<FONT SIZE="-1">   int   j;</FONT>

<FONT SIZE="-1">#ifdef __GNUC__</FONT>
<FONT SIZE="-1">   CALLBACK_PROLOGUE</FONT>
<FONT SIZE="-1">#endif</FONT>
<FONT SIZE="-1">   for (i = 0; i &lt; kNumTextColumns; i++)</FONT>
<FONT SIZE="-1">      for (j = 0; j &lt; kNumRows; j++) {</FONT>
<FONT SIZE="-1">         CharPtr  s;</FONT>
<FONT SIZE="-1">         gHandles[i][j] = MemHandleNew(1);</FONT>
<FONT SIZE="-1">         s = MemHandleLock(gHandles[i][j]);</FONT>
<FONT SIZE="-1">         *s = '\0';</FONT>
<FONT SIZE="-1">         MemHandleUnlock(gHandles[i][j]);</FONT>
<FONT SIZE="-1">      }</FONT>
<FONT SIZE="-1">#ifdef __GNUC__</FONT>
<FONT SIZE="-1">   CALLBACK_EPILOGUE</FONT>
<FONT SIZE="-1">#endif</FONT>
<FONT SIZE="-1">   return false;</FONT>
<FONT SIZE="-1">}</FONT></PRE>

<P ALIGN=LEFT><FONT FACE="Times">A utility routine converts a table column number to an appropriate index in our handles array:</FONT></P><PRE><FONT SIZE="-1">static int &#160;<A NAME="P342_14207"></A>WhichTextColumn(int column)</FONT>
<FONT SIZE="-1">{</FONT>
<FONT SIZE="-1">   if (column == 0)</FONT>
<FONT SIZE="-1">      return 0;</FONT>
<FONT SIZE="-1">   else if (column == 5)</FONT>
<FONT SIZE="-1">      return 1;</FONT>
<FONT SIZE="-1">   else //column == 7</FONT>
<FONT SIZE="-1">      return 2;</FONT>
<FONT SIZE="-1">}</FONT></PRE>

<P ALIGN=LEFT><FONT FACE="Times">Once we have the handles for each text cell, we can set the offset and length within each one. We set our offset to 0 and the size to the appropriate length of data:</FONT></P><PRE><FONT SIZE="-1">static Err &#160;<A NAME="P353_14522"></A>CustomLoadItem(VoidPtr table, Word row, Word column, </FONT>
<FONT SIZE="-1">   Boolean editable, VoidHand * dataH, WordPtr dataOffset, </FONT>
<FONT SIZE="-1">   WordPtr dataSize, FieldPtr fld)</FONT>
<FONT SIZE="-1">{</FONT>
<FONT SIZE="-1">#ifdef __GNUC__</FONT>
<FONT SIZE="-1">   CALLBACK_PROLOGUE</FONT>
<FONT SIZE="-1">#endif</FONT>
<FONT SIZE="-1">   *dataH = gHandles[WhichTextColumn(column)][row];</FONT>
<FONT SIZE="-1">   *dataOffset = 0;</FONT>
<FONT SIZE="-1">   *dataSize = MemHandleSize(*dataH);</FONT>
<FONT SIZE="-1">   </FONT>
<FONT SIZE="-1">#ifdef __GNUC__</FONT>
<FONT SIZE="-1">   CALLBACK_EPILOGUE</FONT>
<FONT SIZE="-1">#endif</FONT>
<FONT SIZE="-1">return 0;</FONT>
<FONT SIZE="-1">}</FONT></PRE>

<P><I><FONT FACE="Times">Custom save routine</FONT></I></P>

<P ALIGN=LEFT><FONT FACE="Times">This &#160;<A NAME="P371_14896"></A>save routine customizes the saving of the first cell in the second text column. If the text has been edited, the text converts from uppercase to lowercase. Note that the save routine returns true in this case to show that the table needs to be redrawn:</FONT></P><PRE><FONT SIZE="-1">static Boolean CustomSaveItem(VoidPtr table, Word row, Word column)</FONT>
<FONT SIZE="-1">{</FONT>
<FONT SIZE="-1">   int textColumn;</FONT>
<FONT SIZE="-1">   Boolean result = false;</FONT>

<FONT SIZE="-1">#ifdef __GNUC__</FONT>
<FONT SIZE="-1">   CALLBACK_PROLOGUE</FONT>
<FONT SIZE="-1">#endif</FONT>
<FONT SIZE="-1">   textColumn = WhichTextColumn(column);</FONT>
<FONT SIZE="-1">   // the handle that we provided in CustomLoadItem has been modified</FONT>
<FONT SIZE="-1">   // We could edit that (if we wanted).</FONT>
<FONT SIZE="-1">   // If it's been edited, let's make the first row </FONT>
<FONT SIZE="-1">   // convert to lower-case and redraw</FONT>
<FONT SIZE="-1">   if (row == 0 &amp;&amp; textColumn == 1) {</FONT>
<FONT SIZE="-1">      FieldPtr field = TblGetCurrentField(table);</FONT>
<FONT SIZE="-1">      if (field &amp;&amp; FldDirty(field)) {</FONT>
<FONT SIZE="-1">         VoidHand h = gHandles[textColumn][row];</FONT>
<FONT SIZE="-1">         CharPtr        s;</FONT>
<FONT SIZE="-1">         int            i;</FONT>
<FONT SIZE="-1">         </FONT>
<FONT SIZE="-1">         s = MemHandleLock(h);</FONT>
<FONT SIZE="-1">         for (i = 0; s[i] != '\0'; i++)</FONT>
<FONT SIZE="-1">            if (s[i] &gt;= 'A' &amp;&amp; s[i] &lt;= 'Z')</FONT>
<FONT SIZE="-1">               s[i] += 'a' - 'A';</FONT>
<FONT SIZE="-1">         MemHandleUnlock(h);</FONT>
<FONT SIZE="-1">         TblMarkRowInvalid(table, row);</FONT>
<FONT SIZE="-1">         result = true;</FONT>
<FONT SIZE="-1">      }</FONT>
<FONT SIZE="-1">   }</FONT>
<FONT SIZE="-1">#ifdef __GNUC__</FONT>
<FONT SIZE="-1">   CALLBACK_EPILOGUE</FONT>
<FONT SIZE="-1">#endif</FONT>
<FONT SIZE="-1">   return result;  // should the table be redrawn</FONT>
<FONT SIZE="-1">}</FONT></PRE>

<P><I><FONT FACE="Times">Custom draw routine</FONT></I></P>

<P ALIGN=LEFT><FONT FACE="Times">&#160;<A NAME="P409_16129"></A>We need a drawing routine that creates our rotating line:</FONT></P><PRE><FONT SIZE="-1">// draws either \, |, /, or -</FONT>
<FONT SIZE="-1">static void CustomDrawItem(VoidPtr table, Word row, Word column,</FONT>
<FONT SIZE="-1">   RectanglePtr bounds)</FONT>
<FONT SIZE="-1">{</FONT>
<FONT SIZE="-1">   UInt  fromx, fromy, tox, toy;</FONT>
<FONT SIZE="-1">   </FONT>
<FONT SIZE="-1">#ifdef __GNUC__</FONT>
<FONT SIZE="-1">   CALLBACK_PROLOGUE</FONT>
<FONT SIZE="-1">#endif</FONT>
<FONT SIZE="-1">   switch (TblGetItemInt(table, row, column)) {</FONT>
<FONT SIZE="-1">   case 0:</FONT>
<FONT SIZE="-1">      fromx = bounds-&gt;topLeft.x;</FONT>
<FONT SIZE="-1">      fromy = bounds-&gt;topLeft.y;</FONT>
<FONT SIZE="-1">      tox = fromx + bounds-&gt;extent.x;</FONT>
<FONT SIZE="-1">      toy = fromy + bounds-&gt;extent.y;</FONT>
<FONT SIZE="-1">      break;</FONT>
<FONT SIZE="-1">   case 1:</FONT>
<FONT SIZE="-1">      fromx = bounds-&gt;topLeft.x + bounds-&gt;extent.x / 2;</FONT>
<FONT SIZE="-1">      fromy = bounds-&gt;topLeft.y;</FONT>
<FONT SIZE="-1">      tox = fromx;</FONT>
<FONT SIZE="-1">      toy = fromy + bounds-&gt;extent.y;</FONT>
<FONT SIZE="-1">      break;</FONT>
<FONT SIZE="-1">   case 2:</FONT>
<FONT SIZE="-1">      fromx = bounds-&gt;topLeft.x + bounds-&gt;extent.x;</FONT>
<FONT SIZE="-1">      fromy = bounds-&gt;topLeft.y;</FONT>
<FONT SIZE="-1">      tox = bounds-&gt;topLeft.x;</FONT>
<FONT SIZE="-1">      toy = fromy + bounds-&gt;extent.y;</FONT>
<FONT SIZE="-1">      break;</FONT>
<FONT SIZE="-1">   case 3:</FONT>
<FONT SIZE="-1">      fromx = bounds-&gt;topLeft.x;</FONT>
<FONT SIZE="-1">      fromy = bounds-&gt;topLeft.y + bounds-&gt;extent.y / 2;</FONT>
<FONT SIZE="-1">      tox = fromx + bounds-&gt;extent.x;</FONT>
<FONT SIZE="-1">      toy = fromy;</FONT>
<FONT SIZE="-1">      break;</FONT>
<FONT SIZE="-1">   default:</FONT>
<FONT SIZE="-1">      fromx = tox = bounds-&gt;topLeft.x;</FONT>
<FONT SIZE="-1">      fromy = toy = bounds-&gt;topLeft.y;</FONT>
<FONT SIZE="-1">      break;</FONT>
<FONT SIZE="-1">   }</FONT>
<FONT SIZE="-1">   WinDrawLine(fromx, fromy, tox, toy);</FONT>
<FONT SIZE="-1">#ifdef __GNUC__</FONT>
<FONT SIZE="-1">   CALLBACK_EPILOGUE</FONT>
<FONT SIZE="-1">#endif</FONT>
<FONT SIZE="-1">}</FONT><A NAME="P454_17270"></A></PRE>

<P><I><FONT FACE="Times">Handling a table event</FONT></I></P>

<P ALIGN=LEFT><FONT FACE="Times"><A NAME="P457_17292"></A>If we tap on a cell in the custom column, we want the angle of the line to change. We do that by changing the integer value. The </FONT><FONT FACE="Courier New"><A NAME="P457_17421"></A>tblSelectEvent</FONT><FONT FACE="Times"> is posted to the event queue when a custom cell is successfully tapped (that is, the user taps on and releases the same cell).</FONT></P>

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=6>

<TR BGCOLOR="#DCF0FF">

<TD>

NOTE:<BR>
<P ALIGN=LEFT><FONT FACE="Times">While you might assume that the </FONT><FONT FACE="Courier New">tblSelectEvent</FONT><FONT FACE="Times"> is where to change the value and redraw, this isn't the case. The Table Manager highlights the selected cell, and we overwrite the highlighting when we redraw. If we switch to a new cell, the Table Manager tries to unhighlight by inverting. As these are certainly not the results we want, we need to handle the call in another place.</FONT></P>
</TD>

</TR>

</TABLE>

<P ALIGN=LEFT><FONT FACE="Times">We're going to handle the redraw in </FONT><FONT FACE="Courier New">tblEnterEvent</FONT><FONT FACE="Times">, looking to see whether the tapped cell is in our column:</FONT></P><PRE><FONT SIZE="-1">static Boolean MainViewHandleEvent(EventPtr event)</FONT>
<FONT SIZE="-1">{</FONT>
<FONT SIZE="-1">   Boolean     handled = false;</FONT>

<FONT SIZE="-1">#ifdef __GNUC__</FONT>
<FONT SIZE="-1">   CALLBACK_PROLOGUE</FONT>
<FONT SIZE="-1">#endif</FONT>
<FONT SIZE="-1">   switch (event-&gt;eType)</FONT>
<FONT SIZE="-1">   {</FONT>
<FONT SIZE="-1">      // code deleted</FONT>

<FONT SIZE="-1">      case tblSelectEvent:    </FONT>
<FONT SIZE="-1">         // handle successful tap on a cell</FONT>
<FONT SIZE="-1">         // for a checkbox or popup, tblExitEvent will be </FONT>
<FONT SIZE="-1">         // called instead of tblSelectEvent</FONT>
<FONT SIZE="-1">         // if the user cancels the control</FONT>
<FONT SIZE="-1">         break;</FONT>
<FONT SIZE="-1">         </FONT>
<FONT SIZE="-1">      case tblEnterEvent:</FONT>
<FONT SIZE="-1">         {</FONT>
<FONT SIZE="-1">            UInt  row = event-&gt;data.tblEnter.row;</FONT>
<FONT SIZE="-1">            UInt  column = event-&gt;data.tblEnter.column;</FONT>
<FONT SIZE="-1">            </FONT>
<FONT SIZE="-1">            if (column == 8) {</FONT>
<FONT SIZE="-1">               TablePtr table = event-&gt;data.tblEnter.pTable;</FONT>
<FONT SIZE="-1">               int      oldValue = TblGetItemInt(table, row, column);</FONT>
<FONT SIZE="-1">               </FONT>
<FONT SIZE="-1">               TblSetItemInt(table, row, column, (oldValue + 1) % 4);</FONT>
<FONT SIZE="-1">               TblMarkRowInvalid(table, row);</FONT>
<FONT SIZE="-1">               TblRedrawTable(table);</FONT>
<FONT SIZE="-1">               handled = true;</FONT>
<FONT SIZE="-1">            }</FONT>
<FONT SIZE="-1">         }</FONT>
<FONT SIZE="-1">         break;</FONT>
<FONT SIZE="-1">   }</FONT>
<FONT SIZE="-1">#ifdef __GNUC__</FONT>
<FONT SIZE="-1">   CALLBACK_EPILOGUE</FONT>
<FONT SIZE="-1">#endif</FONT>
<FONT SIZE="-1">   return handled;</FONT>
<FONT SIZE="-1">}</FONT></PRE>

<P ALIGN=LEFT><FONT FACE="Times">This is all that is worth mentioning in the simple example of a table. It should be enough to guide you in the implementation of these data types in your own <A NAME="P503_19229"></A>tables.</FONT><A NAME="P503_19236"></A></P>

<P><A NAME="P506_19236"></A>

<TABLE BORDER=0 WIDTH="100%">
<TR>
<TD><H1 ALIGN=LEFT><I><FONT FACE="Times" SIZE="+2">Tables in the Sample Application</FONT></I></H1></TD>
<TD><P ALIGN=RIGHT><A HREF="#TopOfPage"><IMG SRC="images/appletop.gif" ALT="Top Of Page" BORDER=0 width="34" height="26"></A></P></TD></TR></TABLE></P>
<P ALIGN=LEFT><IMG SRC="images/applespl.gif" width="751" height="7"></P>

<P ALIGN=LEFT><FONT FACE="Times"><A NAME="P508_19268"></A>In our sample application, we use a table in the Order form. There are three columns: the product ID, the product, and the quantity. Note that we don't use the numeric cell type for either the product ID or quantity, because we need editing as well as display.</FONT></P>

<P ALIGN=LEFT><FONT FACE="Times">We don't use the text cell type for the product ID or quantity, either. These are numbers that we want displayed as right-justified-the text cell type doesn't provide for right-justified text. Therefore, we don't use table's built-in types. We use the custom cell type to create our own data type, an editable numeric value, instead. </FONT></P>

<P><I><FONT FACE="Times" SIZE="+1">Tables with Editable Numeric Values</FONT></I></P>

<P ALIGN=LEFT><FONT FACE="Times">If we ignore the Table Manager APIs and create our own data type, we have the advantage of having a preexisting model on which we can rely-the built-in applications for which source code is available use this approach. The major disadvantage to this approach is that we won't be able to rely on the Table Manager for help with all the standard little details (such as key events). For our application, all the Table Manager provides is some iterating through cells for drawing and indicating which cell has been tapped. Thus, we will need to write additional code for the following:</FONT></P>

  <UL><LI><FONT FACE="Times">  Key events</FONT></LI>

  <LI><FONT FACE="Times">  Selecting and deselecting an item in an Order form (a row in the table)</FONT></LI>

  <LI><FONT FACE="Times">  Tapping on a product ID</FONT></LI>

  <LI><FONT FACE="Times">  Tapping on an item quantity</FONT></LI></UL>

<P><I><FONT FACE="Times">Initialization</FONT></I></P>

<P ALIGN=LEFT><FONT FACE="Times"><A NAME="P524_20632"></A>Here's the code for the one-time initialization done when we load the Order form:</FONT></P><PRE><FONT SIZE="-1">static void InitializeItemsList(void)</FONT>
<FONT SIZE="-1">{</FONT>
<FONT SIZE="-1">   TablePtr table = GetObjectFromActiveForm(OrderItemsTable);</FONT>
<FONT SIZE="-1">   Word     rowsInTable;</FONT>
<FONT SIZE="-1">   Word     row;</FONT>
<FONT SIZE="-1">   </FONT>
<FONT SIZE="-1">   ErrNonFatalDisplayIf(!gCurrentOrder, &quot;nil gCurrentOrder&quot;);</FONT>

<FONT SIZE="-1">   TblSetCustomDrawProcedure(table, kProductNameColumn, </FONT>
<FONT SIZE="-1">      OrderDrawProductName);</FONT>
<FONT SIZE="-1">   TblSetCustomDrawProcedure(table, kQuantityColumn, OrderDrawNumber);</FONT>
<FONT SIZE="-1">   TblSetCustomDrawProcedure(table, kProductIDColumn, OrderDrawNumber);</FONT>
<FONT SIZE="-1">      </FONT>
<FONT SIZE="-1">   rowsInTable = TblGetNumberOfRows(table);</FONT>
<FONT SIZE="-1">   for (row = 0; row &lt; rowsInTable; row++) {</FONT>
<FONT SIZE="-1">      TblSetItemStyle(table, row, kProductIDColumn, customTableItem);</FONT>
<FONT SIZE="-1">      TblSetItemStyle(table, row, kProductNameColumn, customTableItem);</FONT>
<FONT SIZE="-1">      TblSetItemStyle(table, row, kQuantityColumn, customTableItem);</FONT>
<FONT SIZE="-1">   }</FONT>
<FONT SIZE="-1">   TblSetColumnUsable(table, kProductIDColumn, true);</FONT>
<FONT SIZE="-1">   TblSetColumnUsable(table, kProductNameColumn, true);</FONT>
<FONT SIZE="-1">   TblSetColumnUsable(table, kQuantityColumn, true);</FONT>
<FONT SIZE="-1">   </FONT>
<FONT SIZE="-1">   LoadTable();</FONT>
<FONT SIZE="-1">}</FONT>
<FONT SIZE="-1">tblSelectEvent</FONT></PRE>

<P><I><FONT FACE="Times">Refreshing the form</FONT></I></P>

<P ALIGN=LEFT><FONT FACE="Times"><A NAME="P554_21658"></A>Since the contents of the rows change (as scrolling takes place or as items are added or deleted), we need a routine to update the contents of each row. </FONT><FONT FACE="Courier New">&#160;<A NAME="P554_21812"></A>LoadTable</FONT><FONT FACE="Times"> updates the scrollbars, sets whether each row is visible or not visible, and sets the global </FONT><FONT FACE="Courier New">gTopVisibleItem</FONT><FONT FACE="Times">:</FONT></P><PRE><FONT SIZE="-1">static void LoadTable(void)      </FONT>
<FONT SIZE="-1">{</FONT>
<FONT SIZE="-1">   TablePtr table = GetObjectFromActiveForm(OrderItemsTable);</FONT>
<FONT SIZE="-1">   Word  rowsInTable = TblGetNumberOfRows(table);</FONT>
<FONT SIZE="-1">   Word  row;</FONT>
<FONT SIZE="-1">   SWord lastPossibleTopItem = ((Word) gCurrentOrder-&gt;numItems) - </FONT>
<FONT SIZE="-1">      rowsInTable;</FONT>
<FONT SIZE="-1">   </FONT>
<FONT SIZE="-1">   if (lastPossibleTopItem &lt; 0)</FONT>
<FONT SIZE="-1">      lastPossibleTopItem = 0;</FONT>
<FONT SIZE="-1">   </FONT>
<FONT SIZE="-1">   // If we have a currently selected item, make sure that it is visible</FONT>
<FONT SIZE="-1">   if (gCellSelected)</FONT>
<FONT SIZE="-1">      if (gCurrentSelectedItemIndex &lt; gTopVisibleItem || </FONT>
<FONT SIZE="-1">         gCurrentSelectedItemIndex &gt;= gTopVisibleItem + rowsInTable)</FONT>
<FONT SIZE="-1">         gTopVisibleItem = gCurrentSelectedItemIndex;</FONT>
<FONT SIZE="-1">         </FONT>
<FONT SIZE="-1">   // scroll up as necessary to display an entire page of info</FONT>
<FONT SIZE="-1">   gTopVisibleItem = min(gTopVisibleItem, lastPossibleTopItem);</FONT>

<FONT SIZE="-1">   for (row = 0; row &lt; rowsInTable; row++) {</FONT>
<FONT SIZE="-1">      if (row + gTopVisibleItem &lt; gCurrentOrder-&gt;numItems)</FONT>
<FONT SIZE="-1">         OrderInitTableRow(table, row, row + gTopVisibleItem);</FONT>
<FONT SIZE="-1">      else</FONT>
<FONT SIZE="-1">         TblSetRowUsable(table, row, false);</FONT>
<FONT SIZE="-1">   }</FONT>
<FONT SIZE="-1">   SclSetScrollBar(GetObjectFromActiveForm(OrderScrollbarScrollBar), </FONT>
<FONT SIZE="-1">      gTopVisibleItem, 0, lastPossibleTopItem, rowsInTable - 1);</FONT>
<FONT SIZE="-1">}</FONT></PRE>

<P><I><FONT FACE="Times">Displaying the quantity and product data</FONT></I></P>

<P ALIGN=LEFT><FONT FACE="Courier New" SIZE="+0">&#160;<A NAME="P587_23041"></A>OrderInitTableRow</FONT><FONT FACE="Times"> actually makes the Table Manager calls to (1) mark this row usable, (2) set the row ID to the item number (so we can go from table row to an item), and (3) mark the row as invalid so that it will be redrawn:</FONT></P><PRE><FONT SIZE="-1">static void OrderInitTableRow(TablePtr table, Word row, Word itemNum)</FONT>
<FONT SIZE="-1">{</FONT>
<FONT SIZE="-1">   // Make the row usable.</FONT>
<FONT SIZE="-1">   TblSetRowUsable(table, row, true);</FONT>
<FONT SIZE="-1">   </FONT>
<FONT SIZE="-1">   // Store the item number as the row id.</FONT>
<FONT SIZE="-1">   TblSetRowID(table, row, itemNum);</FONT>

<FONT SIZE="-1">   // make sure the row will be redrawn</FONT>
<FONT SIZE="-1">   TblMarkRowInvalid(table, row);</FONT>
<FONT SIZE="-1">}</FONT></PRE>

<P ALIGN=LEFT><FONT FACE="Times">Instead of creating one field for each numeric cell, we create a field when it's time to draw the cell or when it's time to edit a numeric cell.</FONT></P>

<P ALIGN=LEFT><FONT FACE="Times">Using this programming strategy is a big win for memory use, which, you will remember, is quite tight on the handheld. Because we are creating a field for only one cell at a time, we need to allocate memory for only that one field. If we created all the fields all at once, we would have to reserve a great deal of precious memory, as well.</FONT></P>

<P ALIGN=LEFT><FONT FACE="Times">The custom draw routine for the quantity and product ID is </FONT><FONT FACE="Courier New">OrderDrawNumber</FONT><FONT FACE="Times">:</FONT></P><PRE><FONT SIZE="-1">static void &#160;<A NAME="P606_24125"></A>OrderDrawNumber(VoidPtr table, Word row, Word column, </FONT>
<FONT SIZE="-1">   RectanglePtr bounds)</FONT>
<FONT SIZE="-1">{</FONT>
<FONT SIZE="-1">   FieldPtr field;</FONT>
<FONT SIZE="-1">#ifdef __GNUC__</FONT>
<FONT SIZE="-1">   CALLBACK_PROLOGUE</FONT>
<FONT SIZE="-1">#endif</FONT>
<FONT SIZE="-1">   field = OrderInitNumberField(table, row, column, bounds, true);</FONT>
<FONT SIZE="-1">   </FONT>
<FONT SIZE="-1">   FldDrawField(field);</FONT>
<FONT SIZE="-1">   FldFreeMemory(field);</FONT>
<FONT SIZE="-1">   </FONT>
<FONT SIZE="-1">   OrderDeinitNumberField(table, field);</FONT>
<FONT SIZE="-1">#ifdef __GNUC__</FONT>
<FONT SIZE="-1">   CALLBACK_EPILOGUE</FONT>
<FONT SIZE="-1">#endif</FONT>
<FONT SIZE="-1">}</FONT></PRE>

<P><I><FONT FACE="Times">Dynamically adjusting number fields</FONT></I></P>

<P ALIGN=LEFT><FONT FACE="Times"><A NAME="P625_24498"></A>We want to dynamically adjust the number fields as an optimization of memory usage, as well. Unfortunately, there is no documented way prior to 3.0 to dynamically set aspects of a field (bounds, etc.). Therefore, like the built-in applications, we need a routine that fills in the fields of the structure by hand. On a 3.0 (or later) OS, there is a documented </FONT><FONT FACE="Courier New">&#160;<A NAME="P625_24859"></A>FldNewField</FONT><FONT FACE="Times"> routine to create a new field in the form (although there is still no way to modify an existing field).</FONT></P>

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=6>

<TR BGCOLOR="#DCF0FF">

<TD>

NOTE:<BR>
<P ALIGN=LEFT><FONT FACE="Times">The code that calls </FONT><FONT FACE="Courier New">FldNewField</FONT><FONT FACE="Times"> and </FONT><FONT FACE="Courier New">&#160;<A NAME="P628_25011"></A>FrmRemoveObject</FONT><FONT FACE="Times"> (in </FONT><FONT FACE="Courier New">OrderDeInitNumberField</FONT><FONT FACE="Times">) can cause a runtime error (at least we found one in our Gremlins testing). Deadlines happen to everyone, and we had to go to press before finding the cause of this error. Check the code on the CD, as it might reflect a solution (the CD has a later deadline!).</FONT></P>
</TD>

</TR>

</TABLE>

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=6>

<TR BGCOLOR="#DCF0FF">

<TD>

NOTE:<BR>
<P ALIGN=LEFT><FONT FACE="Times">Rather than not show you the code at all, we've defined a constant, </FONT><FONT FACE="Courier New">qUseDynamicUI</FONT><FONT FACE="Times">. If it's false, the code isn't actually used. In the event that we don't yet have a solution, we would be glad to hear from you if you find the answer <A HREF="MAILTO:(neil@pobox.com,">(<I>neil@pobox.com</I>,</A> <A HREF="MAILTO:julie@pobox.com)"><I>julie@pobox.com</I>)</A>.</FONT></P>
</TD>

</TR>

</TABLE>

<P ALIGN=LEFT><FONT FACE="Times">We've provided code that uses </FONT><FONT FACE="Courier New">FldNewField</FONT><FONT FACE="Times">:</FONT></P><PRE><FONT SIZE="-1">#define  qUseDynamicUI     0</FONT>
<FONT SIZE="-1">#define  kDynamicFieldID   9999  // a field ID not present in the form</FONT>

<FONT SIZE="-1">// WARNING, the form, and any controls, table, etc. on the form may change</FONT>
<FONT SIZE="-1">// locations in memory after this call; don't keep pointers to them while</FONT>
<FONT SIZE="-1">// calling this routine.</FONT>
<FONT SIZE="-1">static FieldPtr OrderInitNumberField(TablePtr table, Word row, </FONT>
<FONT SIZE="-1">   Word column, RectanglePtr bounds, Boolean temporary)</FONT>
<FONT SIZE="-1">{</FONT>
<FONT SIZE="-1">   VoidHand    textH;</FONT>
<FONT SIZE="-1">   CharPtr  textP;</FONT>
<FONT SIZE="-1">   char     buffer[10];</FONT>
<FONT SIZE="-1">   ULong    number;</FONT>
<FONT SIZE="-1">   UInt     itemNumber = TblGetRowID(table, row);</FONT>
<FONT SIZE="-1">   FieldPtr fld;</FONT>
<FONT SIZE="-1">   </FONT>
<FONT SIZE="-1">   if (!qUseDynamicUI || sysGetROMVerMajor(gRomVersion) &lt; 3) {</FONT>
<FONT SIZE="-1">      if (temporary)</FONT>
<FONT SIZE="-1">         fld = &amp;gTempFieldType;</FONT>
<FONT SIZE="-1">      else</FONT>
<FONT SIZE="-1">         gCurrentFieldInTable = fld = TblGetCurrentField(table);</FONT>
<FONT SIZE="-1">      </FONT>
<FONT SIZE="-1">      MemSet(fld, sizeof(FieldType), 0);</FONT>
<FONT SIZE="-1">      </FONT>
<FONT SIZE="-1">      RctCopyRectangle(bounds, &amp;fld-&gt;rect);</FONT>
<FONT SIZE="-1">   </FONT>
<FONT SIZE="-1">      fld-&gt;attr.usable = true;</FONT>
<FONT SIZE="-1">      fld-&gt;attr.visible = !temporary;</FONT>
<FONT SIZE="-1">      fld-&gt;attr.editable = true;</FONT>
<FONT SIZE="-1">      fld-&gt;attr.singleLine = true;</FONT>
<FONT SIZE="-1">      fld-&gt;attr.dynamicSize = false;</FONT>
<FONT SIZE="-1">      fld-&gt;attr.underlined = true;</FONT>
<FONT SIZE="-1">      fld-&gt;attr.insPtVisible = true;</FONT>
<FONT SIZE="-1">      fld-&gt;attr.numeric = true;</FONT>
<FONT SIZE="-1">      fld-&gt;attr.justification = rightAlign;</FONT>
<FONT SIZE="-1">      </FONT>
<FONT SIZE="-1">      fld-&gt;maxChars = kMaxNumericStringLength;</FONT>
<FONT SIZE="-1">   } else {</FONT>
<FONT SIZE="-1">      FormPtr  frm = FrmGetActiveForm();</FONT>
<FONT SIZE="-1">      </FONT>
<FONT SIZE="-1">      fld = FldNewField((VoidPtr) &amp;frm, kDynamicFieldID, </FONT>
<FONT SIZE="-1">         bounds-&gt;topLeft.x, bounds-&gt;topLeft.y, bounds-&gt;extent.x, </FONT>
<FONT SIZE="-1">         bounds-&gt;extent.y, stdFont, kMaxNumericStringLength, </FONT>
<FONT SIZE="-1">         true, true, true, false, rightAlign, false, false, true);</FONT>
<FONT SIZE="-1">      if (!temporary)</FONT>
<FONT SIZE="-1">         gCurrentFieldInTable = fld;</FONT>
<FONT SIZE="-1">   }</FONT>

<FONT SIZE="-1">   if (column == kQuantityColumn)</FONT>
<FONT SIZE="-1">      number = gCurrentOrder-&gt;items[itemNumber].quantity;</FONT>
<FONT SIZE="-1">   else</FONT>
<FONT SIZE="-1">      number = gCurrentOrder-&gt;items[itemNumber].productID;</FONT>
<FONT SIZE="-1">      </FONT>
<FONT SIZE="-1">   buffer[0] = '\0';</FONT>
<FONT SIZE="-1">   // 0 will display as empty string</FONT>
<FONT SIZE="-1">   if (number) </FONT>
<FONT SIZE="-1">      StrIToA(buffer, number);</FONT>
<FONT SIZE="-1">      </FONT>
<FONT SIZE="-1">   textH = MemHandleNew(StrLen(buffer) + 1);</FONT>
<FONT SIZE="-1">   textP = MemHandleLock(textH);</FONT>
<FONT SIZE="-1">   StrCopy(textP, buffer);</FONT>

<FONT SIZE="-1">   MemPtrUnlock(textP);</FONT>
<FONT SIZE="-1">   FldSetTextHandle(fld, (Handle) textH);</FONT>
<FONT SIZE="-1">   </FONT>
<FONT SIZE="-1">   if (temporary)</FONT>
<FONT SIZE="-1">      return fld;</FONT>
<FONT SIZE="-1">   else</FONT>
<FONT SIZE="-1">      return NULL;</FONT>
<FONT SIZE="-1">}</FONT></PRE>

<P><I><FONT FACE="Times">Deallocating number fields</FONT></I></P>

<P ALIGN=LEFT><FONT FACE="Times">If the </FONT><FONT FACE="Courier New">qUseDynamicUI</FONT><FONT FACE="Times"> macro is set to true, the deinitialization routine deallocates the field on a 3.0 or later OS:</FONT></P><PRE><FONT SIZE="-1">// WARNING, the form, and any controls, table, etc. on the form may change</FONT>
<FONT SIZE="-1">// locations in memory after this call; don't keep pointers to them while</FONT>
<FONT SIZE="-1">// calling this routine.</FONT>
<FONT SIZE="-1">static void &#160;<A NAME="P710_27999"></A>OrderDeinitNumberField(TablePtr table, FieldPtr fld)</FONT>
<FONT SIZE="-1">{</FONT>
<FONT SIZE="-1">   if (qUseDynamicUI &amp;&amp; sysGetROMVerMajor(gRomVersion) &gt;= 3) {</FONT>
<FONT SIZE="-1">      FormPtr  frm = FrmGetActiveForm();</FONT>
<FONT SIZE="-1">      </FONT>
<FONT SIZE="-1">      FrmRemoveObject(&amp;frm, FrmGetObjectIndex(frm, kDynamicFieldID));</FONT>
<FONT SIZE="-1">   }</FONT>
<FONT SIZE="-1">   if (fld == gCurrentFieldInTable)</FONT>
<FONT SIZE="-1">         gCurrentFieldInTable = NULL;</FONT>
<FONT SIZE="-1">}</FONT></PRE>

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=6>

<TR BGCOLOR="#DCF0FF">

<TD>

NOTE:<BR>
<P ALIGN=LEFT><FONT FACE="Courier New" SIZE="+0">FldNewField</FONT><FONT FACE="Times"> and </FONT><FONT FACE="Courier New">FrmRemoveObject</FONT><FONT FACE="Times"> both change the form pointer and can change the pointers to any objects in the form. Make sure not to reuse any pointer (like the table or the field) after calling either of these routines.</FONT></P>
</TD>

</TR>

</TABLE>

<P><I><FONT FACE="Times">Adding product names</FONT></I></P>

<P ALIGN=LEFT><FONT FACE="Times">&#160;<A NAME="P725_28548"></A>Here's the routine that draws a product name (since it's called by the Table Manager, it must have the </FONT><FONT FACE="Courier New">CALLBACK</FONT><FONT FACE="Times"> macros for GCC):</FONT></P><PRE><FONT SIZE="-1">static void OrderDrawProductName(VoidPtr table, Word row, Word column, </FONT>
<FONT SIZE="-1">   RectanglePtr bounds)</FONT>
<FONT SIZE="-1">{</FONT>
<FONT SIZE="-1">   VoidHand h = NULL;</FONT>
<FONT SIZE="-1">   Product  p;</FONT>
<FONT SIZE="-1">   UInt  itemNumber;</FONT>
<FONT SIZE="-1">   ULong productID;</FONT>
<FONT SIZE="-1">   CharPtr  toDraw;</FONT>
<FONT SIZE="-1">   </FONT>
<FONT SIZE="-1">#ifdef __GNUC__</FONT>
<FONT SIZE="-1">   CALLBACK_PROLOGUE</FONT>
<FONT SIZE="-1">#endif</FONT>
<FONT SIZE="-1">   itemNumber = TblGetRowID(table, row);</FONT>
<FONT SIZE="-1">   productID = gCurrentOrder-&gt;items[itemNumber].productID;</FONT>
<FONT SIZE="-1">   if (productID) {</FONT>
<FONT SIZE="-1">      h = GetProductFromProductID(productID, &amp;p, NULL);</FONT>
<FONT SIZE="-1">      toDraw = (CharPtr) p.name;</FONT>
<FONT SIZE="-1">   } else</FONT>
<FONT SIZE="-1">      toDraw = &quot;-Product-&quot;;</FONT>
<FONT SIZE="-1">   DrawCharsToFitWidth(toDraw, bounds);</FONT>
<FONT SIZE="-1">   if (h)</FONT>
<FONT SIZE="-1">      MemHandleUnlock(h);</FONT>
<FONT SIZE="-1">#ifdef __GNUC__</FONT>
<FONT SIZE="-1">   CALLBACK_EPILOGUE</FONT>
<FONT SIZE="-1">#endif</FONT>
<FONT SIZE="-1">}</FONT></PRE>

<P><I><FONT FACE="Times">Adding scrolling support</FONT></I></P>

<P ALIGN=LEFT><FONT FACE="Times"><A NAME="P756_29287"></A>We've got to handle scrolling if we want items to display properly. In the routine </FONT><FONT FACE="Courier New">OrderHandleEvent</FONT><FONT FACE="Times">, we look for a </FONT><FONT FACE="Courier New">sclRepeatEvent</FONT><FONT FACE="Times">:</FONT></P><PRE><FONT SIZE="-1">case sclRepeatEvent:</FONT>
<FONT SIZE="-1">   OrderDeselectRowAndDeleteIfEmpty();</FONT>
<FONT SIZE="-1">   OrderScrollRows(event-&gt;data.sclRepeat.newValue - </FONT>
<FONT SIZE="-1">      event-&gt;data.sclRepeat.value);</FONT>
<FONT SIZE="-1">   handled = false;  // scrollbar needs to handle the event, too</FONT>
<FONT SIZE="-1">   break;</FONT></PRE>

<P ALIGN=LEFT><FONT FACE="Courier New" SIZE="+0">OrderScrollRows</FONT><FONT FACE="Times"> is straightforward. It updates </FONT><FONT FACE="Courier New">gTopVisibleItem</FONT><FONT FACE="Times">, then reloads the table and redraws it:</FONT></P><PRE><FONT SIZE="-1">static void OrderScrollRows(SWord numRows)</FONT>
<FONT SIZE="-1">{</FONT>
<FONT SIZE="-1">   TablePtr table = GetObjectFromActiveForm(OrderItemsTable);</FONT>
<FONT SIZE="-1">   </FONT>
<FONT SIZE="-1">   gTopVisibleItem += numRows;</FONT>
<FONT SIZE="-1">   if (gTopVisibleItem &lt; 0)</FONT>
<FONT SIZE="-1">      gTopVisibleItem = 0;</FONT>

<FONT SIZE="-1">   LoadTable();</FONT>
<FONT SIZE="-1">   TblUnhighlightSelection(table);</FONT>
<FONT SIZE="-1">   TblRedrawTable(table);</FONT>
<FONT SIZE="-1">}</FONT></PRE>

<P><I><FONT FACE="Times">The table event handler</FONT></I></P>

<P ALIGN=LEFT><FONT FACE="Times"><A NAME="P780_30025"></A>We handle a great number of things in our code and rely on the Table Manager for very little. As a result, we've got quite a complex event handler. Here's how we handle the </FONT><FONT FACE="Courier New">tblEnterEvent</FONT><FONT FACE="Times">:</FONT></P><PRE><FONT SIZE="-1">case tblEnterEvent:</FONT>
<FONT SIZE="-1">{</FONT>
<FONT SIZE="-1">   Word     row = event-&gt;data.tblEnter.row;</FONT>
<FONT SIZE="-1">   Word     column = event-&gt;data.tblEnter.column;</FONT>
<FONT SIZE="-1">   TablePtr table = event-&gt;data.tblEnter.pTable;</FONT>
<FONT SIZE="-1">   </FONT>
<FONT SIZE="-1">   // if the user taps on a new row, deselect the old row</FONT>
<FONT SIZE="-1">   if (gCellSelected &amp;&amp; row != table-&gt;currentRow) {</FONT>
<FONT SIZE="-1">      handled = OrderDeselectRowAndDeleteIfEmpty();</FONT>
<FONT SIZE="-1">      // if we delete a row, leave everything unselected</FONT>
<FONT SIZE="-1">      if (handled)</FONT>
<FONT SIZE="-1">         break;</FONT>
<FONT SIZE="-1">   }</FONT>
<FONT SIZE="-1">   if (gCellSelected) {</FONT>
<FONT SIZE="-1">      // if the user taps a prod in the currently selected row, edit it</FONT>
<FONT SIZE="-1">      if (column == kProductNameColumn) {</FONT>
<FONT SIZE="-1">         ListPtr list = GetObjectFromActiveForm(OrderProductsList);</FONT>
<FONT SIZE="-1">         int      selection;</FONT>
<FONT SIZE="-1">         UInt  index;</FONT>
<FONT SIZE="-1">         UInt  attr;</FONT>
<FONT SIZE="-1">         </FONT>
<FONT SIZE="-1">         LstSetDrawFunction(list, DrawOneProductInList);</FONT>
<FONT SIZE="-1">         </FONT>
<FONT SIZE="-1">         if (gCurrentOrder-&gt;items[gCurrentSelectedItemIndex].productID) {</FONT>
<FONT SIZE="-1">            // initialize the popup for this product</FONT>
<FONT SIZE="-1">            GetProductFromProductID(</FONT>
<FONT SIZE="-1">               gCurrentOrder-&gt;items[gCurrentSelectedItemIndex].productID, </FONT>
<FONT SIZE="-1">               NULL, &amp;index);</FONT>
<FONT SIZE="-1">            DmRecordInfo(gProductDB, index, &amp;attr, NULL, NULL);</FONT>
<FONT SIZE="-1">            SelectACategory(list, attr &amp; dmRecAttrCategoryMask);</FONT>
<FONT SIZE="-1">            </FONT>
<FONT SIZE="-1">            LstSetSelection(list, </FONT>
<FONT SIZE="-1">               DmPositionInCategory(gProductDB, index, gCurrentCategory) + </FONT>
<FONT SIZE="-1">               (gNumCategories + 1));</FONT>
<FONT SIZE="-1">         } else</FONT>
<FONT SIZE="-1">            SelectACategory(list, gCurrentCategory);</FONT>
<FONT SIZE="-1">         </FONT>
<FONT SIZE="-1">         do {</FONT>
<FONT SIZE="-1">            selection = LstPopupList(list);</FONT>
<FONT SIZE="-1">            if (selection &gt;= 0 &amp;&amp; selection &lt; gNumCategories)</FONT>
<FONT SIZE="-1">               SelectACategory(list, selection);</FONT>
<FONT SIZE="-1">         } while (selection &gt;= 0 &amp;&amp; selection &lt; (gNumCategories + 1));</FONT>
<FONT SIZE="-1">         if (selection &gt;= 0) {</FONT>
<FONT SIZE="-1">            UInt  index = 0;</FONT>
<FONT SIZE="-1">            VoidHand       h;</FONT>
<FONT SIZE="-1">            PackedProduct  *packedProduct;</FONT>
<FONT SIZE="-1">            Product        s;</FONT>
<FONT SIZE="-1">            Int            oldSelectedColumn = table-&gt;currentColumn;</FONT>
<FONT SIZE="-1">            </FONT>
<FONT SIZE="-1">            gCurrentProductIndex = 0;</FONT>
<FONT SIZE="-1">            DmSeekRecordInCategory(gProductDB, &amp;gCurrentProductIndex, </FONT>
<FONT SIZE="-1">               selection - (gNumCategories + 1), dmSeekForward, </FONT>
<FONT SIZE="-1">               gCurrentCategory);</FONT>
<FONT SIZE="-1">            ErrNonFatalDisplayIf(DmGetLastErr(), &quot;Can't seek to product&quot;);</FONT>
<FONT SIZE="-1">            h = DmQueryRecord(gProductDB, gCurrentProductIndex);</FONT>
<FONT SIZE="-1">            gHaveProductIndex = true;</FONT>

<FONT SIZE="-1">            ErrNonFatalDisplayIf(!h, &quot;Can't get record&quot;);</FONT>
<FONT SIZE="-1">            packedProduct = MemHandleLock(h);</FONT>
<FONT SIZE="-1">            UnpackProduct(&amp;s, packedProduct);</FONT>
<FONT SIZE="-1">            </FONT>
<FONT SIZE="-1">            DmWrite(gCurrentOrder, </FONT>
<FONT SIZE="-1">               offsetof(Order,</FONT>
<FONT SIZE="-1">               items[gCurrentSelectedItemIndex].productID),</FONT>
<FONT SIZE="-1">               &amp;packedProduct-&gt;productID, </FONT>
<FONT SIZE="-1">               sizeof(packedProduct-&gt;productID));</FONT>
<FONT SIZE="-1">            MemHandleUnlock(h);</FONT>
<FONT SIZE="-1">            // Redraw current row. Can't have anything selected or the </FONT>
<FONT SIZE="-1">            // table will highlight it.</FONT>
<FONT SIZE="-1">            OrderSaveAmount(table);</FONT>
<FONT SIZE="-1">            LoadTable();</FONT>
<FONT SIZE="-1">            TblRedrawTable(table);</FONT>
<FONT SIZE="-1">            OrderSelectNumericCell(NULL, OrderItemsTable, row,</FONT>
<FONT SIZE="-1">               oldSelectedColumn);</FONT>
<FONT SIZE="-1">         }</FONT>
<FONT SIZE="-1">      } else {</FONT>
<FONT SIZE="-1">         if (column == table-&gt;currentColumn) {</FONT>
<FONT SIZE="-1">            // the user tapped in the current field</FONT>
<FONT SIZE="-1">            OrderTapInActiveField(event, table);</FONT>
<FONT SIZE="-1">         } else {</FONT>
<FONT SIZE="-1">            // the user tapped in another field in the row</FONT>
<FONT SIZE="-1">            OrderSaveAmount(table);</FONT>
<FONT SIZE="-1">            OrderSelectNumericCell(event, OrderItemsTable, row, column);</FONT>
<FONT SIZE="-1">         }</FONT>
<FONT SIZE="-1">      }</FONT>
<FONT SIZE="-1">   } else {</FONT>
<FONT SIZE="-1">      // user tapped in a new row</FONT>
<FONT SIZE="-1">      if (column == kQuantityColumn || column == kProductIDColumn) {</FONT>
<FONT SIZE="-1">         OrderSelectNumericCell(event, OrderItemsTable, row, column);</FONT>
<FONT SIZE="-1">      } else {</FONT>
<FONT SIZE="-1">         OrderSelectRow(OrderItemsTable, row);</FONT>
<FONT SIZE="-1">      }</FONT>
<FONT SIZE="-1">   }</FONT>
<FONT SIZE="-1">   handled = true;</FONT>
<FONT SIZE="-1">}</FONT>
<FONT SIZE="-1">break;</FONT><A NAME="P877_33798"></A></PRE>

<P><I><FONT FACE="Times">Handling taps</FONT></I></P>

<P ALIGN=LEFT><FONT FACE="Times" SIZE="-1">&#160;</FONT><FONT FACE="Times"><A NAME="P880_33812"></A>We need to convert a </FONT><FONT FACE="Courier New">tblEnterEvent</FONT><FONT FACE="Times"> (tap in a numeric cell) into a </FONT><FONT FACE="Courier New">fldEnterEvent</FONT><FONT FACE="Times"> so that the Field Manager will handle the event and set the insertion point, or start drag-selecting. Here is how we do that:</FONT></P><PRE><FONT SIZE="-1">static void OrderTapInActiveField(EventPtr event, TablePtr table)</FONT>
<FONT SIZE="-1">{</FONT>
<FONT SIZE="-1">   EventType   newEvent;</FONT>
<FONT SIZE="-1">   FieldPtr    fld;</FONT>

<FONT SIZE="-1">   fld = gCurrentFieldInTable;</FONT>
<FONT SIZE="-1">   // Convert the table enter event to a field enter event.</FONT>
<FONT SIZE="-1">   </FONT>
<FONT SIZE="-1">   EvtCopyEvent(event, &amp;newEvent);</FONT>
<FONT SIZE="-1">   newEvent.eType = fldEnterEvent;</FONT>
<FONT SIZE="-1">   newEvent.data.fldEnter.fieldID = fld-&gt;id;</FONT>
<FONT SIZE="-1">   newEvent.data.fldEnter.pField = fld;</FONT>

<FONT SIZE="-1">   FldHandleEvent(fld, &amp;newEvent);</FONT>
<FONT SIZE="-1">}</FONT></PRE>

<P><I><FONT FACE="Times">Handling key events</FONT></I></P>

<P ALIGN=LEFT><FONT FACE="Times" SIZE="-1">&#160;</FONT><FONT FACE="Times"><A NAME="P899_34424"></A>We've got to handle scrolling when our table receives key-down events. If the user is writing in a cell, we filter to allow only arrows, backspace, and digits. If the user has no cell selected and writes a digit, we add a new item and insert the new digit in the quantity cell.</FONT></P>

<P ALIGN=LEFT><FONT FACE="Times">Note that the character we retrieve from the event is a two-byte </FONT><FONT FACE="Courier New">word</FONT><FONT FACE="Times">, not a one-byte </FONT><FONT FACE="Courier New">char</FONT><FONT FACE="Times">:</FONT></P><PRE><FONT SIZE="-1">static Boolean OrderHandleKey(EventPtr event)</FONT>
<FONT SIZE="-1">{</FONT>
<FONT SIZE="-1">   Word  c = event-&gt;data.keyDown.chr;</FONT>
<FONT SIZE="-1">   </FONT>
<FONT SIZE="-1">   // bottom-to-top screen gesture can cause this, depending on  </FONT>
<FONT SIZE="-1">   // configuration in Prefs/Buttons/Pen</FONT>
<FONT SIZE="-1">   if (c == sendDataChr)      </FONT>
<FONT SIZE="-1">      return OrderHandleMenuEvent(RecordBeamCustomer);</FONT>
<FONT SIZE="-1">   else if (c == pageUpChr || c == pageDownChr) {</FONT>
<FONT SIZE="-1">      SWord numRowsToScroll = </FONT>
<FONT SIZE="-1">         TblGetNumberOfRows(GetObjectFromActiveForm(OrderItemsTable)) - 1;</FONT>
<FONT SIZE="-1">      </FONT>
<FONT SIZE="-1">      OrderDeselectRowAndDeleteIfEmpty();</FONT>
<FONT SIZE="-1">      if (c == pageUpChr)</FONT>
<FONT SIZE="-1">         numRowsToScroll = -numRowsToScroll;</FONT>
<FONT SIZE="-1">      OrderScrollRows(numRowsToScroll);</FONT>
<FONT SIZE="-1">   } else if (c == linefeedChr) {</FONT>
<FONT SIZE="-1">      // The return character takes us out of edit mode.</FONT>
<FONT SIZE="-1">      OrderDeselectRowAndDeleteIfEmpty();</FONT>
<FONT SIZE="-1">   } else if (gCellSelected) {</FONT>
<FONT SIZE="-1">      if ((c == backspaceChr) || (c == leftArrowChr) || </FONT>
<FONT SIZE="-1">         (c == rightArrowChr) || IsDigit(GetCharAttr(), c))</FONT>
<FONT SIZE="-1">         FldHandleEvent(gCurrentFieldInTable, event);</FONT>
<FONT SIZE="-1">   } else {</FONT>
<FONT SIZE="-1">      // writing a digit with nothing selected creates a new item</FONT>
<FONT SIZE="-1">      if (IsDigit(GetCharAttr(), c)) {</FONT>
<FONT SIZE="-1">         UInt  itemNumber;</FONT>
<FONT SIZE="-1">         </FONT>
<FONT SIZE="-1">         OrderDeselectRowAndDeleteIfEmpty();</FONT>
<FONT SIZE="-1">         if (AddNewItem(&amp;itemNumber)) {</FONT>
<FONT SIZE="-1">            OrderSelectItemNumber(itemNumber, kQuantityColumn);</FONT>
<FONT SIZE="-1">            FldHandleEvent(gCurrentFieldInTable, event);</FONT>
<FONT SIZE="-1">         }</FONT>
<FONT SIZE="-1">      }</FONT>
<FONT SIZE="-1">   }</FONT>
<FONT SIZE="-1">   return true;</FONT>
<FONT SIZE="-1">}</FONT></PRE>

<P><I><FONT FACE="Times">Handling numeric cell selection</FONT></I></P>

<P ALIGN=LEFT><FONT FACE="Times" SIZE="-1">&#160;</FONT><FONT FACE="Times"><A NAME="P942_36123"></A>Here's how we handle the user's tapping on a numeric cell:</FONT></P><PRE><FONT SIZE="-1">static void OrderSelectNumericCell(EventPtr event, Word tableID, </FONT>
<FONT SIZE="-1">   Word row, Word column)</FONT>
<FONT SIZE="-1">{</FONT>
<FONT SIZE="-1">   TablePtr    table;</FONT>
<FONT SIZE="-1">   </FONT>
<FONT SIZE="-1">   table = GetObjectFromActiveForm(tableID);</FONT>
<FONT SIZE="-1">   </FONT>
<FONT SIZE="-1">   // make this cell selected, if it isn't already</FONT>
<FONT SIZE="-1">   if (row != table-&gt;currentRow || column != table-&gt;currentColumn || </FONT>
<FONT SIZE="-1">      !table-&gt;attr.editing) {</FONT>
<FONT SIZE="-1">      RectangleType  r;</FONT>
<FONT SIZE="-1">      FormPtr     frm;</FONT>

<FONT SIZE="-1">      table-&gt;attr.editing = true;</FONT>
<FONT SIZE="-1">      table-&gt;currentRow = row;</FONT>
<FONT SIZE="-1">      table-&gt;currentColumn = column;</FONT>

<FONT SIZE="-1">      TblGetItemBounds(table, row, column, &amp;r);</FONT>
<FONT SIZE="-1">      OrderInitNumberField(table, row, column, &amp;r, false);</FONT>
<FONT SIZE="-1">      </FONT>
<FONT SIZE="-1">      // reacquire the table, since OrderInitNumberField may have</FONT>
<FONT SIZE="-1">      // made it invalid</FONT>
<FONT SIZE="-1">      table = GetObjectFromActiveForm(tableID);</FONT>
<FONT SIZE="-1">      </FONT>
<FONT SIZE="-1">      gCurrentSelectedItemIndex = TblGetRowID(table, row);</FONT>
<FONT SIZE="-1">      gCellSelected = true;</FONT>
<FONT SIZE="-1">      OrderHiliteSelectedRow(table, true);</FONT>
<FONT SIZE="-1">      </FONT>
<FONT SIZE="-1">      frm = FrmGetActiveForm();</FONT>
<FONT SIZE="-1">      FrmSetFocus(frm, FrmGetObjectIndex(frm, tableID));</FONT>
<FONT SIZE="-1">      FldGrabFocus(gCurrentFieldInTable);</FONT>
<FONT SIZE="-1">   }</FONT>
<FONT SIZE="-1">   // if there's an event, pass it on</FONT>
<FONT SIZE="-1">   if (event)</FONT>
<FONT SIZE="-1">      OrderTapInActiveField(event, table);</FONT>
<FONT SIZE="-1">}</FONT></PRE>

<P ALIGN=LEFT><FONT FACE="Times">We (like the built-in applications) modify the table fields </FONT><FONT FACE="Courier New">attr.editing</FONT><FONT FACE="Times">, </FONT><FONT FACE="Courier New">currentRow</FONT><FONT FACE="Times">, and </FONT><FONT FACE="Courier New">currentColumn</FONT><FONT FACE="Times"> directly, since there is no API to change these values.</FONT><A NAME="P980_37405"></A></P>

<P><A NAME="P983_37405"></A>

<TABLE BORDER=0 WIDTH="100%">
<TR>
<TD><H1 ALIGN=LEFT><I><FONT FACE="Times" SIZE="+2">Find</FONT></I></H1></TD>
<TD><P ALIGN=RIGHT><A HREF="#TopOfPage"><IMG SRC="images/appletop.gif" ALT="Top Of Page" BORDER=0 width="34" height="26"></A></P></TD></TR></TABLE></P>
<P ALIGN=LEFT><IMG SRC="images/applespl.gif" width="751" height="7"></P>

<P ALIGN=LEFT><FONT FACE="Times"><A NAME="P985_37409"></A>In this section, we discuss the Find feature of the Palm OS. First, we give you an overview of Find, the user interface, and its intended goals. Second, we walk through the entire Find process from the beginning to the end. Third, we implement Find in our sample application and discuss important aspects of the code.</FONT></P>

<P><I><FONT FACE="Times" SIZE="+1">Overview of Find</FONT></I></P>

<P ALIGN=LEFT><FONT FACE="Times">The Palm OS user interface supports a global Find-a user can find all the instances of a string in all applications. The operating system doesn't do the work, however. Instead, it orders each application, in turn, to search through its own databases and return the results. </FONT></P>

<P ALIGN=LEFT><FONT FACE="Times">There is much to be said for this approach. The most obvious rationale is that the operating system has no idea what's inside the records of a database: strings, numbers, or other data. Therefore, it's in no position to know what's a reasonable return result and what's nonsense. Indeed, the application is uniquely positioned to interpret the Find request and determine the display of the found information to the user.</FONT></P>

<P ALIGN=LEFT><FONT FACE="Courier New" SIZE="+0">&#160;</FONT><FONT FACE="Times"><A NAME="P994_38437"></A>Find requests are sent from the OS by calling the application's </FONT><FONT FACE="Courier New">PilotMain</FONT><FONT FACE="Times"> (see &quot;Other Times Your Application Is Called&quot; on page&#160;88) with a specific launch code, </FONT><FONT FACE="Courier New">sysAppLaunchCmdFind</FONT><FONT FACE="Times">, along with parameters having to do with interpreting the Find.</FONT></P>

<P><I><FONT FACE="Times">The objectives of Find</FONT></I></P>

<P ALIGN=LEFT><FONT FACE="Times"><A NAME="P998_38703"></A>Remembering that speed on the handheld is essential, Find is intended to be a very quick process. Here are some of the things that the OS does to ensure this:</FONT></P>

<P><I><FONT FACE="Times">No global variables</FONT></I></P>

<P><FONT FACE="Times">An application's global variables are not created when it receives the </FONT><FONT FACE="Courier New">sysAppLaunchCmdFind</FONT><FONT FACE="Times"> launch code, as creating, initializing, and releasing every application's globals would be a time-consuming process.</FONT></P>

<P><I><FONT FACE="Times">Only one screenful of items at a time</FONT></I></P>

<P><FONT FACE="Times">The Find goes on only long enough to fill one screen with items. If the user wants to see more results, the Find resumes where it left off until it has another screenful of found items, then stops again. This process continues until it runs out of return results.</FONT></P>

<P><I><FONT FACE="Times">Long Finds are easy to stop</FONT></I></P>

<P><FONT FACE="Times">Applications check the event queue every so often to see whether an event has occurred. If so, the application prematurely quits the Find. Thus, a simple tap outside the Find prevents a long search of a large database that would otherwise lock up the handheld.</FONT></P>

<P ALIGN=LEFT><FONT FACE="Times"><A NAME="P1006_39674"></A>Another goal is to minimize the amount of memory used. Remember that the Find request could well occur while an application other than yours is running. In such cases, it would be very rude, indeed, to suck away the application's dynamic heap. To prevent such bad manners, memory use is minimized in the following ways:</FONT></P>

<P><I><FONT FACE="Times">No global variables</FONT></I></P>

<P><FONT FACE="Times">No unopen application global variables are created.</FONT></P>

<P><I><FONT FACE="Times">Minimal information about each found item is stored</FONT></I></P>

<P><FONT FACE="Times">An application doesn't save much about the items it finds. Rather, the application draws a summary of the found items and passes the Find Manager six bits of information: the database, the record number, the field number, the card number, the position within the field, and an additional integer.</FONT></P>

<P><I><FONT FACE="Times">Only one screenful of items at a time</FONT></I></P>

<P><FONT FACE="Times">Only one screenful of found items is maintained in memory. If the user requests more, the current information is thrown out and the search continues where it left off.</FONT></P>

<P><I><FONT FACE="Times" SIZE="+1">A Walkthrough of Finding Items</FONT></I></P>

<P ALIGN=LEFT><FONT FACE="Times">The following is a walkthrough of what happens when the user writes in a string to be found and taps Find. First, the current application is sent the launch code </FONT><FONT FACE="Courier New"><A NAME="P1017_40806"></A>sysAppLaunchCmdSaveData</FONT><FONT FACE="Times">, which requests that the application save any data that is currently being edited but not yet saved in a database. Then, starting with the open application, each application is sent the launch code </FONT><FONT FACE="Courier New">sysAppLaunchCmdFind</FONT><FONT FACE="Times">. </FONT></P>

<P><I><FONT FACE="Times">The application's response to a Find request</FONT></I></P>

<P ALIGN=LEFT><FONT FACE="Times"><A NAME="P1021_41093"></A>Each application responds with these steps:</FONT></P>

<P><FONT FACE="Times"> 1. The application opens its database(s) using the mode specified in its Find parameters. This can be specified as read-only mode and may also (depending on the user's Security settings) specify that secret records should be shown.</FONT></P>

<P><FONT FACE="Times"> 2. The application draws an application header in the Find Results dialog. <A HREF="#P1025_41811">Figure 8-4</A> contains some examples of application headers as they appear in the dialog. The application uses </FONT><FONT FACE="Courier New">&#160;<A NAME="P1024_41551"></A>FindDrawHeader </FONT><FONT FACE="Times">to retrieve the application header from the application's resource database. If </FONT><FONT FACE="Courier New">FindDrawHeader</FONT><FONT FACE="Times"> returns true, there is no more space in the Find Results dialog, and step 3 is skipped. If there is room in the dialog, it is on to step 3.</FONT></P>

<P><B><FONT FACE="Times" SIZE="-1">Figure 8- 4</FONT></B><A NAME="P1025_41811"></A>. 

<B><FONT FACE="Times" SIZE="-1">Find results dialog showing application headers</FONT></B><BR>
<P><UL>
<TABLE>
<TR>
<TD WIDTH=512><P ALIGN=CENTER><IMG SRC="images/ch08-plmp.0804-4.gif" WIDTH=503 HEIGHT=182 align=left></P>
</TD></TR></TABLE></UL>

<P><FONT FACE="Times"> 3. The application iterates through each of its records in the database. If it is sent a Find request and there is room to fit all of the found items on the screen, the application iterates through the records starting at record 0. If some records from the application have already been displayed, the application has the Find Manager store the record number of the last displayed record and continues the iteration with the next record when the user taps the More button.</FONT></P>

  <UL><P><FONT FACE="Times">a. <A NAME="P1035_42333"></A>Most applications retrieve the next record by using </FONT><FONT FACE="Courier New">&#160;<A NAME="P1035_42386"></A>DmQueryNextInCategory</FONT><FONT FACE="Times">, which skips private records, if necessary. If an error occurs, the application exits the loop.</FONT></P>

  <P><FONT FACE="Times">b. It looks for a string that matches. An application should normally ignore case while determining a match. The application can use </FONT><FONT FACE="Courier New">&#160;<A NAME="P1036_42637"></A>FindStrInStr</FONT><FONT FACE="Times"> to determine whether there is a match and where the match occurs.</FONT></P>

  <P><FONT FACE="Times">c. If the application finds a match, it saves information about the match using </FONT><FONT FACE="Courier New">&#160;<A NAME="P1037_42796"></A>FindSaveMatch</FONT><FONT FACE="Times">. If </FONT><FONT FACE="Courier New">FindSaveMatch</FONT><FONT FACE="Times"> returns true, no more items can be drawn in the Find Results dialog. In this case, the application has finished iterating and goes to step 4. Otherwise, it draws to the Find Results dialog a one-line summary of the matching item (</FONT><FONT FACE="Courier New">FindGetLineBounds</FONT><FONT FACE="Times"> returns the rectangle in which to draw). The summary should, if possible, include the searched-for string, along with other contextual information. </FONT></P>

  <P><FONT FACE="Times">In addition, the application increments the </FONT><FONT FACE="Courier New">lineNumber</FONT><FONT FACE="Times"> field of the Find parameters.</FONT></P>

  <P><FONT FACE="Times">d. The application should check the event queue every so often (using </FONT><FONT FACE="Courier New">EvtSysEventAvail</FONT><FONT FACE="Times">). If an event has occurred, the application should set the more field of the Find parameters to true and go to step 4.</FONT></P>

</UL><P><FONT FACE="Times"> 4. The application closes any databases it has opened and returns.</FONT></P>

<P ALIGN=LEFT><FONT FACE="Times">When the Find Results dialog is displayed, the user can choose Find More. In this case, the Find Manager starts the process again, skipping any applications that have been completely searched.</FONT></P>

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=6>

<TR BGCOLOR="#DCF0FF">

<TD>

NOTE:<BR>
<P ALIGN=LEFT><FONT FACE="Times">In the documentation for Find that was current at the time of this book's writing, some Find functions and a field in the Find parameters are incorrectly documented as being for system use only. The following functions are necessary to correctly support Find: </FONT><FONT FACE="Courier New">FindDrawHeader</FONT><FONT FACE="Times">, </FONT><FONT FACE="Courier New">FindGetLineBounds</FONT><FONT FACE="Times">, </FONT><FONT FACE="Courier New">FindStrInStr</FONT><FONT FACE="Times">, </FONT><FONT FACE="Courier New">FindSaveMatch</FONT><FONT FACE="Times">. This Find parameter field is also necessary: </FONT><FONT FACE="Courier New">lineNumber</FONT><FONT FACE="Times">.</FONT></P>
</TD>

</TR>

</TABLE>

<P><I><FONT FACE="Times">Handling a Find request with multiple databases</FONT></I></P>

<P ALIGN=LEFT><FONT FACE="Times">If your application supports searching in multiple databases, you've got to carefully handle continuing a search (Find More). The Find parameters provide the last matched record number (as saved by </FONT><FONT FACE="Courier New">FindSaveMatch</FONT><FONT FACE="Times">), but not the last matched database. Because of this, your Find routine doesn't know which database was last searched.</FONT></P>

<P ALIGN=LEFT><FONT FACE="Times">Our recommendation is to use system preferences as a place to store the name of the last database. When you call </FONT><FONT FACE="Courier New">FindSaveMatch</FONT><FONT FACE="Times">, you can retrieve the information. When you receive the Find launch code, if the </FONT><FONT FACE="Courier New">continuation</FONT><FONT FACE="Times"> field of the Find parameters is false, mark the last database as invalid and start the search with your first database. If the </FONT><FONT FACE="Courier New">continuation</FONT><FONT FACE="Times"> field of the Find parameters is true, start your search with the saved database (if it is valid).</FONT></P>

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=6>

<TR BGCOLOR="#DCF0FF">

<TD>

NOTE:<BR>
<P ALIGN=LEFT><FONT FACE="Times">Remember that you can't store information in global variables, because when the </FONT><FONT FACE="Courier New">sysAppLaunchCmdFind</FONT><FONT FACE="Times"> launch code is sent, your application's global variables don't get allocated. </FONT></P>
</TD>

</TR>

</TABLE>

<P ALIGN=LEFT><FONT FACE="Times">Alternatively, you could use the record number field as a combination record number and database. You could store the indicated database (0, 1, 2, etc.) in the upper few bits, and the actual record number in the remaining bits.</FONT></P>

<P><I><FONT FACE="Times">Navigating to a found item</FONT></I></P>

<P ALIGN=LEFT><FONT FACE="Times">When the user taps on an item in the Find Results dialog, that item's application is sent the </FONT><FONT FACE="Courier New"><A NAME="P1058_45511"></A>sysAppLaunchCmdGoTo</FONT><FONT FACE="Times"> launch code. That application may or may not be the current application. If it is, the application just switches to displaying the found item. If it isn't, the application must call </FONT><FONT FACE="Courier New">StartApplication</FONT><FONT FACE="Times"> and enter a standard event loop.</FONT></P>

<P ALIGN=LEFT><FONT FACE="Times">The Find parameters are sent, along with the </FONT><FONT FACE="Courier New">sysAppLaunchCmdGoTo</FONT><FONT FACE="Times"> launch code. These parameters are all the items that were passed to </FONT><FONT FACE="Courier New">FindSaveMatch</FONT><FONT FACE="Times">, along with an additional one: the length of the searched-for string. Your application should then display the found item, highlighting the searched-for string within the found item.</FONT></P>

<P><I><FONT FACE="Times">Displaying a found item from a running application</FONT></I></P>

<P ALIGN=LEFT><FONT FACE="Times">Here's the step-by-step process your open application will go through when it receives the </FONT><FONT FACE="Courier New">sysAppLaunchCmdGoTo</FONT><FONT FACE="Times"> launch code:</FONT></P>

<P><FONT FACE="Times"> 1. Close any existing forms (using </FONT><FONT FACE="Courier New">FrmCloseAllForms</FONT><FONT FACE="Times">).</FONT></P>

<P><FONT FACE="Times"> 2. Open the form appropriate to display the found item (using </FONT><FONT FACE="Courier New">FrmGotoForm</FONT><FONT FACE="Times">).</FONT></P>

<P><FONT FACE="Times"> 3. Create a </FONT><FONT FACE="Courier New"><A NAME="P1068_46404"></A>frmGotoEvent</FONT><FONT FACE="Times"> event record with fields initialized from the go to parameters, and post it to the event queue (using </FONT><FONT FACE="Courier New">EvtAddEventToQueue</FONT><FONT FACE="Times">).</FONT></P>

<P><FONT FACE="Times"> 4. Respond to the </FONT><FONT FACE="Courier New">frmGotoEvent</FONT><FONT FACE="Times"> event in your form's event handler by navigating to the correct record and highlighting the found contents (using </FONT><FONT FACE="Courier New">FldSetScrollPosition</FONT><FONT FACE="Times"> and </FONT><FONT FACE="Courier New">FldSetSelection</FONT><FONT FACE="Times">).</FONT></P>

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=6>

<TR BGCOLOR="#DCF0FF">

<TD>

NOTE:<BR>
<P ALIGN=LEFT><FONT FACE="Times">Note that we must find the unique ID of the specified </FONT><FONT FACE="Courier New">recordNumber</FONT><FONT FACE="Times"> before we close all the forms. There are many cases that call for this, but, as an example, the user might be viewing a blank form immediately prior to the Find request. Before displaying the found item, the application needs to delete the blank Customer dialog and close the form. If this occurs, however, the records in the database may no longer be numbered the same. Therefore, we find the unique ID of the found record. After closing the forms, we then find the record based on its unchanging unique ID instead of the possibly compromised record number.</FONT></P>
</TD>

</TR>

</TABLE>

<P><I><FONT FACE="Times">Displaying a found item from a closed application</FONT></I></P>

<P ALIGN=LEFT><FONT FACE="Times">If your application is closed when it receives the </FONT><FONT FACE="Courier New">sysAppLaunchCmdGoTo</FONT><FONT FACE="Times"> launch code, you need to do a few more things:</FONT></P>

<P><FONT FACE="Times"> 1. As specified by the </FONT><FONT FACE="Courier New"><A NAME="P1077_47540"></A>sysAppLaunchFlagNewGlobals</FONT><FONT FACE="Times"> launch flag, call </FONT><FONT FACE="Courier New">StartApplication</FONT><FONT FACE="Times">.</FONT></P>

<P><FONT FACE="Times"> 2. Create a </FONT><FONT FACE="Courier New">frmGotoEvent</FONT><FONT FACE="Times"> event record with fields initialized from the goto parameters and post it to the event queue (using </FONT><FONT FACE="Courier New">EvtAddEventToQueue</FONT><FONT FACE="Times">).</FONT></P>

<P><FONT FACE="Times"> 3. Enter your </FONT><FONT FACE="Courier New">EventLoop</FONT><FONT FACE="Times">.</FONT></P>

<P><FONT FACE="Times"> 4. Respond to the </FONT><FONT FACE="Courier New">frmGotoEvent</FONT><FONT FACE="Times"> event in your form's event handler by navigating to the correct record and highlighting the found contents (using </FONT><FONT FACE="Courier New">FldSetScrollPosition</FONT><FONT FACE="Times"> and </FONT><FONT FACE="Courier New">FldSetSelection</FONT><FONT FACE="Times">).</FONT></P>

<P><FONT FACE="Times"> 5. Call </FONT><FONT FACE="Courier New">StopApplication</FONT><FONT FACE="Times"> after the </FONT><FONT FACE="Courier New">EventLoop</FONT><FONT FACE="Times"> is finished.</FONT><A NAME="P1081_48014"></A></P>

<P><I><FONT FACE="Times" SIZE="+1">Find in the Sales Application</FONT></I></P>

<P ALIGN=LEFT><FONT FACE="Times"><A NAME="P1085_48043"></A>From the earlier description of Find, you can see that supporting it in your application, while straightforward, does require handling a number of steps and possible situations. </FONT></P>

<P ALIGN=LEFT><FONT FACE="Times">Let's look now at how we handle these steps in the Sales application.</FONT></P>

<P><I><FONT FACE="Times">Handling the Find request</FONT></I></P>

<P ALIGN=LEFT><FONT FACE="Times">The </FONT><FONT FACE="Courier New">&#160;<A NAME="P1091_48320"></A>PilotMain</FONT><FONT FACE="Times"> handles the save data and the Find launch codes. Here's the bit of code from </FONT><FONT FACE="Courier New">PilotMain</FONT><FONT FACE="Times"> that shows the call to </FONT><FONT FACE="Courier New">sysAppLaunchCmdFind</FONT><FONT FACE="Times">:</FONT></P><PRE><FONT SIZE="-1">// Launch code sent to running app before sysAppLaunchCmdFind</FONT>
<FONT SIZE="-1">// or other action codes that will cause data searches or manipulation.                      </FONT>
<FONT SIZE="-1">else if (cmd == sysAppLaunchCmdSaveData) {</FONT>
<FONT SIZE="-1">   FrmSaveAllForms();</FONT>
<FONT SIZE="-1">}</FONT>
<FONT SIZE="-1">else if (cmd == sysAppLaunchCmdFind) {</FONT>
<FONT SIZE="-1">   Search((FindParamsPtr)cmdPBP);</FONT>
<FONT SIZE="-1">}</FONT></PRE>

<P><I><FONT FACE="Times">Searching for matching strings</FONT></I></P>

<P ALIGN=LEFT><FONT FACE="Times">Here's the </FONT><FONT FACE="Courier New">&#160;<A NAME="P1103_48792"></A>Search</FONT><FONT FACE="Times"> routine that actually handles the searching through our customer database. The part of the code that's specific to our application is emphasized; the remaining code is likely to be the standard for most applications:</FONT></P><PRE><FONT SIZE="-1">static void Search(FindParamsPtr findParams)</FONT>
<FONT SIZE="-1">{</FONT>
<FONT SIZE="-1">   Err            err;</FONT>
<FONT SIZE="-1">   Word           pos;</FONT>
<FONT SIZE="-1">   UInt           fieldNum;</FONT>
<FONT SIZE="-1">   UInt           cardNo = 0;</FONT>
<FONT SIZE="-1">   UInt           recordNum;</FONT>
<FONT SIZE="-1">   CharPtr        header;</FONT>
<FONT SIZE="-1">   Boolean        done;</FONT>
<FONT SIZE="-1">   VoidHand          recordH;</FONT>
<FONT SIZE="-1">   VoidHand          headerH;</FONT>
<FONT SIZE="-1">   LocalID        dbID;</FONT>
<FONT SIZE="-1">   DmOpenRef         dbP;</FONT>
<FONT SIZE="-1">   RectangleType     r;</FONT>
<FONT SIZE="-1">   DmSearchStateType searchState;</FONT>
<FONT SIZE="-1">   </FONT>
<FONT SIZE="-1">   // unless told otherwise, there are no more items to be found</FONT>
<FONT SIZE="-1">   findParams-&gt;more = false;  </FONT>

<FONT SIZE="-1">   // Find the application's data file.</FONT>
<B><FONT SIZE="-1">   err = DmGetNextDatabaseByTypeCreator(true, &amp;searchState, </FONT></B>
<B><FONT SIZE="-1">&#160;&#160;&#160;&#160;&#160;&#160;kCustomerDBType, kSalesCreator, true, &amp;cardNo, &amp;dbID);</FONT></B>
<FONT SIZE="-1">   if (err) </FONT>
<FONT SIZE="-1">      return;</FONT>

<FONT SIZE="-1">   // Open the expense database.</FONT>
<FONT SIZE="-1">   dbP = DmOpenDatabase(cardNo, dbID, findParams-&gt;dbAccesMode);</FONT>
<FONT SIZE="-1">   if (! dbP)</FONT>
<FONT SIZE="-1">      return;</FONT>

<FONT SIZE="-1">   // Display the heading line.</FONT>
<FONT SIZE="-1">   headerH = DmGetResource(strRsc, FindHeaderString);</FONT>
<FONT SIZE="-1">   header = MemHandleLock(headerH);</FONT>
<FONT SIZE="-1">   done = FindDrawHeader(findParams, header);</FONT>
<FONT SIZE="-1">   MemHandleUnlock(headerH);</FONT>
<FONT SIZE="-1">   if (done) {</FONT>
<FONT SIZE="-1">      findParams-&gt;more = true;</FONT>
<FONT SIZE="-1">   }</FONT>
<FONT SIZE="-1">   else {</FONT>
<FONT SIZE="-1">      // Search all the fields; start from the last record searched.</FONT>
<FONT SIZE="-1">      recordNum = findParams-&gt;recordNum;</FONT>
<FONT SIZE="-1">      for(;;) {</FONT>
<FONT SIZE="-1">         Boolean match = false;</FONT>
<B><FONT SIZE="-1">         Customer       customer;</FONT></B>
<FONT SIZE="-1">         </FONT>
<FONT SIZE="-1">         // Because applications can take a long time to finish a find </FONT>
<FONT SIZE="-1">         // users like to be able to stop the find.  Stop the find </FONT>
<FONT SIZE="-1">         // if an event is pending. This stops if the user does </FONT>
<FONT SIZE="-1">         // something with the device.  Because this call slows down </FONT>
<FONT SIZE="-1">         // the search we perform it every so many records instead of </FONT>
<FONT SIZE="-1">         // every record.  The response time should still be short </FONT>
<FONT SIZE="-1">         // without introducing much extra work to the search.</FONT>
<FONT SIZE="-1">         </FONT>
<FONT SIZE="-1">         // Note that in the implementation below, if the next 16th </FONT>
<FONT SIZE="-1">         // record is secret the check doesn't happen.  Generally </FONT>
<FONT SIZE="-1">         // this shouldn't be a problem since if most of the records </FONT>
<FONT SIZE="-1">         // are secret then the search won't take long anyway!</FONT>
<FONT SIZE="-1">         if ((recordNum &amp; 0x000f) == 0 &amp;&amp;       // every 16th record</FONT>
<FONT SIZE="-1">            EvtSysEventAvail(true)) {</FONT>
<FONT SIZE="-1">            // Stop the search process.</FONT>
<FONT SIZE="-1">            findParams-&gt;more = true;</FONT>
<FONT SIZE="-1">            break;</FONT>
<FONT SIZE="-1">         }</FONT>
<FONT SIZE="-1">         </FONT>
<FONT SIZE="-1">         recordH = DmQueryNextInCategory(dbP, &amp;recordNum, </FONT>
<FONT SIZE="-1">            dmAllCategories);</FONT>
<FONT SIZE="-1">         // Have we run out of records?</FONT>
<FONT SIZE="-1">         if (! recordH)</FONT>
<FONT SIZE="-1">            break;</FONT>
<FONT SIZE="-1">         </FONT>
<B><FONT SIZE="-1">         // Search each of the fields of the customer</FONT></B>
<B><FONT SIZE="-1">      </FONT></B>
<B><FONT SIZE="-1">         UnpackCustomer(&amp;customer, MemHandleLock(recordH));</FONT></B>
<B><FONT SIZE="-1">         </FONT></B>
<B><FONT SIZE="-1">         if ((match = FindStrInStr((CharPtr) customer.name, </FONT></B>
<B><FONT SIZE="-1">            findParams-&gt;strToFind, &amp;pos)) != false)</FONT></B>
<B><FONT SIZE="-1">            fieldNum = CustomerNameField;</FONT></B>
<B><FONT SIZE="-1">         else if ((match = FindStrInStr((CharPtr) customer.address, </FONT></B>
<B><FONT SIZE="-1">            findParams-&gt;strToFind, &amp;pos)) != false)</FONT></B>
<B><FONT SIZE="-1">            fieldNum = CustomerAddressField;</FONT></B>
<B><FONT SIZE="-1">         else if ((match = FindStrInStr((CharPtr) customer.city, </FONT></B>
<B><FONT SIZE="-1">            findParams-&gt;strToFind, &amp;pos)) != false)</FONT></B>
<B><FONT SIZE="-1">            fieldNum = CustomerCityField;</FONT></B>
<B><FONT SIZE="-1">         else if ((match = FindStrInStr((CharPtr) customer.phone, </FONT></B>
<B><FONT SIZE="-1">            findParams-&gt;strToFind, &amp;pos)) != false)</FONT></B>
<B><FONT SIZE="-1">            fieldNum = CustomerPhoneField;</FONT></B>
<FONT SIZE="-1">            </FONT>
<FONT SIZE="-1">         if (match) {</FONT>
<FONT SIZE="-1">            done = FindSaveMatch(findParams, recordNum, pos, fieldNum, 0,</FONT>
<FONT SIZE="-1">               cardNo, dbID);</FONT>
<FONT SIZE="-1">            if (done) </FONT>
<FONT SIZE="-1">               break;</FONT>
<FONT SIZE="-1">   </FONT>
<FONT SIZE="-1">            //Get the bounds of the region where we will draw the results.</FONT>
<FONT SIZE="-1">            FindGetLineBounds(findParams, &amp;r);</FONT>
<FONT SIZE="-1">            </FONT>
<FONT SIZE="-1">            // Display the title of the description.</FONT>
<B><FONT SIZE="-1">            DrawCharsToFitWidth(customer.name, &amp;r);</FONT></B>
<FONT SIZE="-1">   </FONT>
<FONT SIZE="-1">            findParams-&gt;lineNumber++;</FONT>
<FONT SIZE="-1">         }</FONT>
<FONT SIZE="-1">         MemHandleUnlock(recordH);</FONT>
<FONT SIZE="-1">         if (done)</FONT>
<FONT SIZE="-1">            break;</FONT>
<FONT SIZE="-1">         recordNum++;</FONT>
<FONT SIZE="-1">      }</FONT>
<FONT SIZE="-1">   }  </FONT>
<FONT SIZE="-1">   DmCloseDatabase(dbP);   </FONT>
<FONT SIZE="-1">}</FONT><FONT FACE="Courier New">&#160;</FONT><A NAME="P1213_52739"></A></PRE>

<P><I><FONT FACE="Times">Displaying the found item</FONT></I></P>

<P ALIGN=LEFT><FONT FACE="Times">First, here's the code from </FONT><FONT FACE="Courier New">PilotMain</FONT><FONT FACE="Times"> that calls </FONT><FONT FACE="Courier New">StartApplication</FONT><FONT FACE="Times">, </FONT><FONT FACE="Courier New">EventLoop</FONT><FONT FACE="Times">, and </FONT><FONT FACE="Courier New">StopApplication</FONT><FONT FACE="Times">, if necessary (if using GCC and the application was already running, the code must have the </FONT><FONT FACE="Courier New">CALLBACK</FONT><FONT FACE="Times"> macros, since </FONT><FONT FACE="Courier New">PilotMain</FONT><FONT FACE="Times"> was called as a subroutine from a system function):</FONT></P><PRE><FONT SIZE="-1">// This launch code might be sent to the app when it's already running</FONT>
<FONT SIZE="-1">   else if (cmd == sysAppLaunchCmdGoTo) {</FONT>
<FONT SIZE="-1">      Boolean  launched;</FONT>
<FONT SIZE="-1">      launched = launchFlags &amp; sysAppLaunchFlagNewGlobals;</FONT>
<FONT SIZE="-1">      </FONT>
<FONT SIZE="-1">      if (launched) {</FONT>
<FONT SIZE="-1">         error = StartApplication();</FONT>
<FONT SIZE="-1">         if (!error) {</FONT>
<FONT SIZE="-1">            GoToItem((GoToParamsPtr) cmdPBP, launched);</FONT>
<FONT SIZE="-1">            EventLoop();</FONT>
<FONT SIZE="-1">            StopApplication();   </FONT>
<FONT SIZE="-1">         }</FONT>
<FONT SIZE="-1">      } else {</FONT>
<FONT SIZE="-1">#ifdef __GNUC__</FONT>
<FONT SIZE="-1">         CALLBACK_PROLOGUE</FONT>
<FONT SIZE="-1">#endif</FONT>
<FONT SIZE="-1">         GoToItem((GoToParamsPtr) cmdPBP, launched);</FONT>
<FONT SIZE="-1">#ifdef __GNUC__</FONT>
<FONT SIZE="-1">         CALLBACK_EPILOGUE</FONT>
<FONT SIZE="-1">#endif</FONT>
<FONT SIZE="-1">      }</FONT>
<FONT SIZE="-1">   }</FONT></PRE>

<P ALIGN=LEFT><FONT FACE="Times">Here's the </FONT><FONT FACE="Courier New">&#160;<A NAME="P1241_53621"></A>GoToItem</FONT><FONT FACE="Times"> function that opens the correct form and posts a </FONT><FONT FACE="Courier New">frmGotoEvent</FONT><FONT FACE="Times">:</FONT></P><PRE><FONT SIZE="-1">static void GoToItem (GoToParamsPtr goToParams, Boolean launchingApp)</FONT>
<FONT SIZE="-1">{</FONT>
<FONT SIZE="-1">   EventType   event;</FONT>
<FONT SIZE="-1">   UInt     recordNum = goToParams-&gt;recordNum;</FONT>
<FONT SIZE="-1">   </FONT>
<FONT SIZE="-1">   // If the current record is blank, then it will be deleted, so we'll use</FONT>
<FONT SIZE="-1">   // the record's unique id to find the record index again, after all </FONT>
<FONT SIZE="-1">   // the forms are closed.</FONT>
<FONT SIZE="-1">   if (! launchingApp) {</FONT>
<FONT SIZE="-1">      ULong    uniqueID;</FONT>
<FONT SIZE="-1">      </FONT>
<FONT SIZE="-1">      DmRecordInfo(gCustomerDB, recordNum, NULL, &amp;uniqueID, NULL);</FONT>
<FONT SIZE="-1">      FrmCloseAllForms();</FONT>
<FONT SIZE="-1">      DmFindRecordByID(gCustomerDB, uniqueID, &amp;recordNum);</FONT>
<FONT SIZE="-1">   }</FONT>
<FONT SIZE="-1">      </FONT>
<FONT SIZE="-1">   FrmGotoForm(CustomersForm);</FONT>
<FONT SIZE="-1">   </FONT>
<FONT SIZE="-1">   // Send an event to select the matching text.</FONT>
<FONT SIZE="-1">   MemSet (&amp;event, 0, sizeof(EventType));</FONT>

<FONT SIZE="-1">   event.eType = frmGotoEvent;</FONT>
<FONT SIZE="-1">   event.data.frmGoto.formID = CustomersForm;</FONT>
<FONT SIZE="-1">   event.data.frmGoto.recordNum = goToParams-&gt;recordNum;</FONT>
<FONT SIZE="-1">   event.data.frmGoto.matchPos = goToParams-&gt;matchPos;</FONT>
<FONT SIZE="-1">   event.data.frmGoto.matchLen = goToParams-&gt;searchStrLen;</FONT>
<FONT SIZE="-1">   event.data.frmGoto.matchFieldNum = goToParams-&gt;matchFieldNum;</FONT>
<FONT SIZE="-1">   event.data.frmGoto.matchCustom = goToParams-&gt;matchCustom;</FONT>
<FONT SIZE="-1">   EvtAddEventToQueue(&amp;event);</FONT>
<FONT SIZE="-1">}</FONT></PRE>

<P ALIGN=LEFT><FONT FACE="Times">Remember that this code needs to take into account the possibility of records that change numbers in between closing open forms and displaying the found record. We do this using </FONT><FONT FACE="Courier New">DmRecordInfo</FONT><FONT FACE="Times"> and </FONT><FONT FACE="Courier New">DmFindRecordByID</FONT><FONT FACE="Times">. The first takes the record and finds the unique idea associated with it; the second returns a record based on the unique idea. </FONT></P>

<P ALIGN=LEFT><FONT FACE="Times">Note also that we're opening the </FONT><FONT FACE="Courier New">CustomersForm</FONT><FONT FACE="Times">, even though we really want the </FONT><FONT FACE="Courier New">CustomerForm</FONT><FONT FACE="Times">. The reason we do this is that we can't get to the </FONT><FONT FACE="Courier New">CustomerForm</FONT><FONT FACE="Times"> directly. It is a modal dialog that is displayed above the </FONT><FONT FACE="Courier New">CustomersForm</FONT><FONT FACE="Times">. Thus, the </FONT><FONT FACE="Courier New">CustomersForm</FONT><FONT FACE="Times"> needs to be opened first, because it is that bit of code that knows how to open the </FONT><FONT FACE="Courier New">CustomerForm</FONT><FONT FACE="Times">. Here's the code from </FONT><FONT FACE="Courier New">CustomersHandleEvent</FONT><FONT FACE="Times"> that opens the </FONT><FONT FACE="Courier New">CustomerForm</FONT><FONT FACE="Times">:</FONT></P><PRE><FONT SIZE="-1">case frmGotoEvent:</FONT>
<FONT SIZE="-1">   EditCustomerWithSelection(event-&gt;data.frmGoto.recordNum, false, </FONT>
<FONT SIZE="-1">      &amp;deleted, &amp;hidden, &amp;event-&gt;data.frmGoto);</FONT>
<FONT SIZE="-1">   handled = true;</FONT>
<FONT SIZE="-1">   break;</FONT></PRE>

<P ALIGN=LEFT><FONT FACE="Times">Here's the portion of </FONT><FONT FACE="Courier New">&#160;&#160;<A NAME="P1282_55683"></A>EditCustomerWithSelection</FONT><FONT FACE="Times"> that scrolls and highlights the correct text:</FONT></P><PRE><FONT SIZE="-1">static void EditCustomerWithSelection(UInt recordNumber, Boolean isNew,</FONT>
<FONT SIZE="-1">   Boolean *deleted, Boolean *hidden, struct frmGoto *gotoData)</FONT>
<FONT SIZE="-1">{</FONT>
<FONT SIZE="-1">   // code deleted that gets the customer record and initializes </FONT>
<FONT SIZE="-1">   // the fields</FONT>
<FONT SIZE="-1">         </FONT>
<FONT SIZE="-1">   // select one of the fields</FONT>
<FONT SIZE="-1">   if (gotoData &amp;&amp; gotoData-&gt;matchFieldNum) {</FONT>
<FONT SIZE="-1">      FieldPtr selectedField =   </FONT>
<FONT SIZE="-1">         GetObjectFromActiveForm(gotoData-&gt;matchFieldNum);</FONT>
<FONT SIZE="-1">      FldSetScrollPosition(selectedField, gotoData-&gt;matchPos);</FONT>
<FONT SIZE="-1">      FrmSetFocus(frm, FrmGetObjectIndex(frm, gotoData-&gt;matchFieldNum));</FONT>
<FONT SIZE="-1">      FldSetSelection(selectedField, gotoData-&gt;matchPos, </FONT>
<FONT SIZE="-1">         gotoData-&gt;matchPos + gotoData-&gt;matchLen);</FONT>
<FONT SIZE="-1">   }</FONT>
<FONT SIZE="-1">   </FONT>
<FONT SIZE="-1">   // code deleted that displays the dialog and handles updates </FONT>
<FONT SIZE="-1">   // when the dialog is dismissed</FONT>
<FONT SIZE="-1">}</FONT></PRE>

<P ALIGN=LEFT><FONT FACE="Times">That is all there is to adding support for Find to our application. Indeed, the trickiest part of the code is figuring out the type of situations you might encounter that will cause Find to work incorrectly. The two most important of these are searching applications with multiple databases correctly and making sure that you don't lose the record in between closing forms and displaying<A NAME="P1303_56879"></A> results.</FONT><A NAME="P1303_56888"></A></P>

<P><A NAME="P1306_56888"></A>

<TABLE BORDER=0 WIDTH="100%">
<TR>
<TD><H1 ALIGN=LEFT><I><FONT FACE="Times" SIZE="+2">Beaming</FONT></I></H1></TD>
<TD><P ALIGN=RIGHT><A HREF="#TopOfPage"><IMG SRC="images/appletop.gif" ALT="Top Of Page" BORDER=0 width="34" height="26"></A></P></TD></TR></TABLE></P>
<P ALIGN=LEFT><IMG SRC="images/applespl.gif" width="751" height="7"></P>

<P ALIGN=LEFT><FONT FACE="Times"><A NAME="P1308_56895"></A>In this section, we discuss beaming. First, we give you a general overview of beaming, describe the user interface, and offer you a few useful tips. Next, we provide a checklist that you can use to implement beaming in an application. Last, we implement beaming in the Sales application.</FONT></P>

<P><I><FONT FACE="Times" SIZE="+1">Beaming and the Exchange Manager</FONT></I></P>

<P ALIGN=LEFT><FONT FACE="Times">The <A NAME="P1313_57218"></A>Exchange Manager is in charge of exchanging of information between Palm OS devices and other devices. This manager is new to Palm OS 3.0 and is built on industry standards.</FONT></P>

<P ALIGN=LEFT><FONT FACE="Times">Currently, the Exchange Manager works only over an infrared link, although it may be enhanced in the future to work over other links (such as TCP/IP or email). The exchange manager uses the <A NAME="P1315_57580"></A>ObEx Infrared Data Association (IrDA) standard to exchange information. As a result, it should be possible to exchange information between Palm OS devices and other devices that implement this ObEx standard.</FONT></P>

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=6>

<TR BGCOLOR="#DCF0FF">

<TD>

NOTE:<BR>
<P ALIGN=LEFT><FONT FACE="Times">For information on IrDA standards, see </FONT><FONT FACE="Times" SIZE="-1"><I><A HREF="http://www.irda.org">http://www.irda.org</A></I>. For information on Multipurpose Internet Mail Extensions (MIME), see <I><A HREF="http://www.mindspring.com/~mgrand/mime.html">http://www.mindspring.com/~mgrand/mime.html</A></I> or <I><A HREF="http://www.cis.ohio-state.edu/hypertext/faq/usenet/mail/mime-faq/top.html">http://www.cis.ohio-state.edu/hypertext/faq/usenet/mail/mime-faq/top.html</A></I>.</FONT></P>
</TD>

</TR>

</TABLE>

<P><I><FONT FACE="Times" SIZE="+1">How Beaming Works</FONT></I></P>

<P ALIGN=LEFT><FONT FACE="Times">Applications that support this feature usually allow beaming either a single item or an entire category. When the user chooses the Beam menu item, a dialog appears showing that the beam is being prepared. Then it searches for another device using infrared. Once it finds the other device, it beeps and starts sending the data. After the remote device receives all the data, it beeps and presents a dialog to the user, asking whether the user wants to accept the data. If the user decides to accept the data, it is put away; if not, it is thrown away. The creator type of the item is matched to an appropriate application on the receiving device, which then displays the newly received data.</FONT></P>

<P ALIGN=LEFT><FONT FACE="Times">Newly received items are always placed in the Unfiled category. This is true even when both sending and receiving units have the same categories. While problematic for a few users, this it the right solution for most situations. Users will have one consistent interface for receiving items. After all, who is to say that a user wants beamed items filed in the same name category that the sending handheld uses?</FONT></P>

<P ALIGN=LEFT><FONT FACE="Times">The user can also send an entire category. When a category is sent, private records are skipped (to avoid accidentally sending unintended records). Newly received items are placed in the Unfiled category.</FONT></P>

<P><I><FONT FACE="Times" SIZE="+1">Programming Tips</FONT></I></P>

<P ALIGN=LEFT><FONT FACE="Times"><A NAME="P1331_59374"></A>The following sections present a set of miscellaneous tips to help you implement beaming. The first ones are optimization suggestions, the next will help you when debugging your code, and the last are a grab bag of helpful ideas.</FONT></P>

<P><I><FONT FACE="Times">Optimization tips</FONT></I></P>

  <UL><LI><FONT FACE="Times"> <A NAME="P1335_59622"> </A>When calling </FONT><FONT FACE="Courier New">&#160;<A NAME="P1335_59636"></A>ExgSend</FONT><FONT FACE="Times">, don't make a lot of calls, each with only a few bytes in them. It is much better to allocate a buffer and send the entire buffer, if necessary. Throughput will be faster with larger, fewer calls. </FONT></LI>

  <LI><FONT FACE="Times">  When a receive beam launch code is sent to your </FONT><FONT FACE="Courier New">PilotMain</FONT><FONT FACE="Times">, your application is not necessarily running. As a result, you can't allocate similarly large buffers for receiving data with </FONT><FONT FACE="Courier New">&#160;<A NAME="P1336_60028"></A>ExgReceive</FONT><FONT FACE="Times">. In fact, you should make as few and as small a set of allocations as possible to avoid stressing the currently running application. It is quite proper, however, to allocate a large buffer if you are the currently running application when a receive beam takes place.</FONT></LI></UL>

<P><I><FONT FACE="Times">Debugging tips</FONT></I></P>

  <UL><LI><FONT FACE="Times"> <A NAME="P1340_60321"> </A>If you have textual data to send, you can send to the Memo Pad (set the name to end in <I>.TXT</I>) even before you've written your receive code. If the text doesn't appear, you know you've got problems in the sending portion of the code.</FONT></LI>

  <LI><FONT FACE="Times">  Set </FONT><FONT FACE="Courier New">localMode</FONT><FONT FACE="Times"> (in the </FONT><FONT FACE="Courier New">ExgSocketType</FONT><FONT FACE="Times">) to true to begin with. This gives you a loop of the data back to the same device. Or use the Graffiti shortcut in combination with two other characters to tell Exchange Manager to make all beams local. That combination is:</FONT></LI></UL>

<P ALIGN=CENTER><IMG SRC="images/ch08-plmp.08A-5.gif" WIDTH=503 HEIGHT=77 align=left></P>

  <UL><LI><FONT FACE="Times">  See &quot;Device Reset&quot; on page&#160;284 for more information.</FONT></LI>

  <LI><FONT FACE="Times">  Use the <A NAME="P1345_60877"></A>Graffiti shortcut in combination with two other characters to tell Exchange Manager to use the serial port rather than IR. That combination is:</FONT></LI></UL>

<P ALIGN=CENTER><IMG SRC="images/ch08-plmp.08B-6.gif" WIDTH=503 HEIGHT=77 align=left></P>

  <UL><LI><FONT FACE="Times">  This is a tricky way to use POSE (which doesn't support IR hardware) to test your code. See &quot;Device Reset&quot; in Chapter&#160;10 for more information.</FONT></LI></UL>

<P><I><FONT FACE="Times">General tips</FONT></I></P>

  <UL><LI><FONT FACE="Times">  If you set the </FONT><FONT FACE="Courier New">target</FONT><FONT FACE="Times"> creator ID when sending, you prohibit any other application from receiving the data on the other end.</FONT></LI>

  <LI><FONT FACE="Times">  You must call </FONT><FONT FACE="Courier New">ExgSend</FONT><FONT FACE="Times"> in a loop, because it may not send all the bytes you instruct it to send. </FONT><FONT FACE="Courier New">ExgSend </FONT><FONT FACE="Times">stops when it can send a full packet; it doesn't continue sending the remaining data without further prompting.</FONT></LI>

  <LI><FONT FACE="Times">  Call </FONT><FONT FACE="Courier New">&#160;<A NAME="P1354_61526"></A>ExgRegisterData</FONT><FONT FACE="Times"> in your </FONT><FONT FACE="Courier New">PilotMain</FONT><FONT FACE="Times"> when you receive the </FONT><FONT FACE="Courier New">sysAppLaunch-CmdSyncNotify</FONT><FONT FACE="Times">. If you wait until you call your </FONT><FONT FACE="Courier New">StartApplication</FONT><FONT FACE="Times"> routine to register with the system, a user won't be able to beam to your application after it has been installed until it has actually been run once.</FONT></LI>

  <LI><FONT FACE="Times">  Don't call any Exchange Manager routines if your application is running on OS 2.0 or earlier. In fact, your code should specifically check for the version of the OS and take the proper precautions.</FONT></LI>

  <LI><FONT FACE="Times">  Try running on a 3.0 device that lacks IR capability (like, for instance, POSE) to make sure that you fail gracefully. <A NAME="P1356_62128"></A>You should get the alert shown in <A HREF="#P1359_62184">Figure 8-5</A>.</FONT></LI></UL>

<P><B><FONT FACE="Times" SIZE="-1">Figure 8- 5</FONT></B>. 

<B><FONT FACE="Times" SIZE="-1"><A NAME="P1359_62184"></A>Alert shown when user attempts to beam on a device that has the beaming APIs (3.0 OS or greater), but no IR hardware</FONT></B><BR>
<P><UL>
<TABLE>
<TR>
<TD WIDTH=512><P ALIGN=CENTER><IMG SRC="images/ch08-plmp.0805-7.gif" WIDTH=503 HEIGHT=111 align=left></P>
</TD></TR></TABLE></UL>

<P><I><FONT FACE="Times" SIZE="+1">Step-by-Step Implementation Checklist</FONT></I></P>

<P ALIGN=LEFT><FONT FACE="Times"><A NAME="P1369_62337"></A>Beaming lends itself well to a checklist approach of implementation. If you follow these steps in a cookbook-like fashion, you should get beaming up in a jiffy.</FONT></P>

<P><I><FONT FACE="Times">Determine data interchange format</FONT></I></P>

<P><FONT FACE="Times"> 1. You first need to decide whether you'll use a file extension or MIME type (or both). You also have to determine the format of the transmitted data (for both a single entry and an category).</FONT></P>

<P><I><FONT FACE="Times">Add beam user interface</FONT></I></P>

<P><FONT FACE="Times"> 2. Add a Beam menu item to beam the current entry.</FONT></P>

<P><FONT FACE="Times"> 3. Add a Beam Category item to the overview Record menu to beam the current category.</FONT></P>

<P><I><FONT FACE="Times">Send an entry</FONT></I></P>

<P><FONT FACE="Times"> 4. Add </FONT><FONT FACE="Courier New">&lt;ExgMgr.h&gt; </FONT><FONT FACE="Times">to your include files.</FONT></P>

<P><FONT FACE="Times"> 5. Declare an </FONT><FONT FACE="Courier New">ExgSocketType</FONT><FONT FACE="Times"> and initialize it to 0.</FONT></P>

<P><FONT FACE="Times"> 6. Initialize the </FONT><FONT FACE="Courier New">description</FONT><FONT FACE="Times"> field of the </FONT><FONT FACE="Courier New">ExgSocketType</FONT><FONT FACE="Times">.</FONT></P>

<P><FONT FACE="Times"> 7. Initialize </FONT><FONT FACE="Courier New">type</FONT><FONT FACE="Times">, </FONT><FONT FACE="Courier New">target</FONT><FONT FACE="Times">, and/or </FONT><FONT FACE="Courier New">name</FONT><FONT FACE="Times">.</FONT></P>

<P><FONT FACE="Times"> 8. Initialize </FONT><FONT FACE="Courier New">localMode</FONT><FONT FACE="Times"> to 1 (this is for testing with one device; it's optional).</FONT></P>

<P><FONT FACE="Times"> 9. Call </FONT><FONT FACE="Courier New">ExgPut</FONT><FONT FACE="Times"> to begin the beam.</FONT></P>

<P><FONT FACE="Times"> 10. Call </FONT><FONT FACE="Courier New">ExgSend</FONT><FONT FACE="Times"> in a loop to send the actual data.</FONT></P>

<P><FONT FACE="Times"> 11. Call </FONT><FONT FACE="Courier New">ExgDisconnect</FONT><FONT FACE="Times"> to terminate the beam.</FONT></P>

<P><I><FONT FACE="Times">Receive an entry</FONT></I></P>

<P><FONT FACE="Times"> 12. Register for receiving based on the MIME type and/or file extension (optional) you set up in step 1.</FONT></P>

<P><FONT FACE="Times">In </FONT><FONT FACE="Courier New">PilotMain</FONT><FONT FACE="Times">, when a </FONT><FONT FACE="Courier New"><A NAME="P1394_63433"></A>sysAppLaunchCmdSyncNotify</FONT><FONT FACE="Times"> launch code occurs, call </FONT><FONT FACE="Courier New">&#160;<A NAME="P1394_63485"></A>ExgRegisterData</FONT><FONT FACE="Times"> with </FONT><FONT FACE="Courier New">exgRegExtensionID</FONT><FONT FACE="Times"> and/or call </FONT><FONT FACE="Courier New">ExgRegisterData</FONT><FONT FACE="Times"> with </FONT><FONT FACE="Courier New">exgRegTypeID</FONT><FONT FACE="Times">. This setup is optional, however. If a sender beams data specifying your target application creator, your application will get sent a launch code even if it hasn't registered for a specific extension and/or MIME type. You should do this registration if you have a specific kind of data that you want to handle; senders of that data may not have a specific application in mind when they do the send. </FONT></P>

<P><FONT FACE="Times"> 13. Handle the receive beam launch code.</FONT></P>

<P><FONT FACE="Times">In </FONT><FONT FACE="Courier New">PilotMain</FONT><FONT FACE="Times">, check for the </FONT><FONT FACE="Courier New"><A NAME="P1396_64037"></A>sysAppLaunchCmdExgReceiveData</FONT><FONT FACE="Times"> launch code. You won't have global variables unless you happen to be the open application.</FONT></P>

<P><FONT FACE="Times"> 14. Call </FONT><FONT FACE="Courier New">ExgAccept</FONT><FONT FACE="Times">.</FONT></P>

<P><FONT FACE="Times"> 15. Call </FONT><FONT FACE="Courier New">ExgReceive</FONT><FONT FACE="Times"> repeatedly and until </FONT><FONT FACE="Courier New">ExgReceive</FONT><FONT FACE="Times"> returns 0. A zero is returned when no more data is being received or an error has occurred.</FONT></P>

<P><FONT FACE="Times"> 16. Call </FONT><FONT FACE="Courier New">ExgDisconnect </FONT><FONT FACE="Times">to hang up properly.</FONT></P>

<P><FONT FACE="Times"> 17. Set </FONT><FONT FACE="Courier New">gotoLaunchCode</FONT><FONT FACE="Times"> and </FONT><FONT FACE="Courier New">gotoParams</FONT><FONT FACE="Times">.</FONT></P>

<P><FONT FACE="Times">Set </FONT><FONT FACE="Courier New">gotoLaunchCode</FONT><FONT FACE="Times"> to your creator's application. Set the following fields in </FONT><FONT FACE="Courier New">gotoParams</FONT><FONT FACE="Times"> with the appropriate values: </FONT><FONT FACE="Courier New">uniqueID</FONT><FONT FACE="Times">, </FONT><FONT FACE="Courier New">dbID</FONT><FONT FACE="Times">, </FONT><FONT FACE="Courier New">dbCardNo</FONT><FONT FACE="Times">, </FONT><FONT FACE="Courier New">recordNum</FONT><FONT FACE="Times">.</FONT></P>

<P><I><FONT FACE="Times">Display received item</FONT></I></P>

<P ALIGN=LEFT><FONT FACE="Times">This feature is a free gift thanks to the work you did in supporting Find. If your application already correctly handles Find, displaying received items is no work.</FONT></P>

<P><I><FONT FACE="Times">Send an entire category</FONT></I></P>

<P ALIGN=LEFT><FONT FACE="Times">The code for sending an entire category is very similar to the code for sending one item (the actual data you send will be different, of course). You must make sure that your data format allows you to distinguish between one item and multiple items.</FONT></P>

<P><FONT FACE="Times"> 18. Declare an </FONT><FONT FACE="Courier New">ExgSocketType</FONT><FONT FACE="Times"> and initialize it to 0.</FONT></P>

<P><FONT FACE="Times"> 19. Initialize the </FONT><FONT FACE="Courier New">description</FONT><FONT FACE="Times"> field of the </FONT><FONT FACE="Courier New">ExgSocketType</FONT><FONT FACE="Times">.</FONT></P>

<P><FONT FACE="Times"> 20. Initialize </FONT><FONT FACE="Courier New">type</FONT><FONT FACE="Times">, </FONT><FONT FACE="Courier New">target</FONT><FONT FACE="Times">, and/or </FONT><FONT FACE="Courier New">name</FONT><FONT FACE="Times">.</FONT></P>

<P><FONT FACE="Times"> 21. Initialize </FONT><FONT FACE="Courier New">localMode</FONT><FONT FACE="Times"> to </FONT><FONT FACE="Courier New">1</FONT><FONT FACE="Times"> (this is for testing with one device; it's optional).</FONT></P>

<P><FONT FACE="Times"> 22. Call </FONT><FONT FACE="Courier New">ExgPut</FONT><FONT FACE="Times"> to begin the beam.</FONT></P>

<P><FONT FACE="Times"> 23. Call </FONT><FONT FACE="Courier New">ExgSend</FONT><FONT FACE="Times"> in a loop to send the actual data.</FONT></P>

<P><FONT FACE="Times"> 24. Call </FONT><FONT FACE="Courier New">ExgDisconnect</FONT><FONT FACE="Times"> to terminate the beam.</FONT></P>

<P><I><FONT FACE="Times">Receive an entire category</FONT></I></P>

<P ALIGN=LEFT><FONT FACE="Times">Receiving an entire <A NAME="P1421_65421"></A>category is similar to receiving one item.</FONT></P>

<P><FONT FACE="Times"> 25. Call </FONT><FONT FACE="Courier New">ExgAccept</FONT><FONT FACE="Times">.</FONT></P>

<P><FONT FACE="Times"> 26. Call </FONT><FONT FACE="Courier New">ExgReceive</FONT><FONT FACE="Times"> repeatedly.</FONT></P>

<P><FONT FACE="Times"> 27. Call </FONT><FONT FACE="Courier New">ExgDisconnect</FONT><FONT FACE="Times">.</FONT></P>

<P><FONT FACE="Times"> 28. Set </FONT><FONT FACE="Courier New">gotoLaunchCode</FONT><FONT FACE="Times"> and </FONT><FONT FACE="Courier New">gotoParams</FONT><FONT FACE="Times">.</FONT></P>

<P><I><FONT FACE="Times">Test all possibilities</FONT></I></P>

<P ALIGN=LEFT><FONT FACE="Times"><A NAME="P1430_65596"></A>You need to run a gamut of tests to make sure you haven't forgotten any of the details. Test every one of the following combinations of sending and receiving and any other tests that come to mind.</FONT></P>

<P><FONT FACE="Times"> 29. Send a record while your application is open on the remote device.</FONT></P>

<P><FONT FACE="Times"> 30. Send a record while your application isn't open on the remote device.</FONT></P>

<P><FONT FACE="Times"> 31. Send a category with lots of records (so that the </FONT><FONT FACE="Courier New">ExgReceive</FONT><FONT FACE="Times"> can't read all its data at one time).</FONT></P>

<P><FONT FACE="Times"> 32. Tap No when the Accept dialog is presented on the remote device.</FONT></P>

<P><FONT FACE="Times"> 33. Send a category with a private record. Verify that the private record isn't received.</FONT></P>

<P><FONT FACE="Times"> 34. Verify that beaming an empty category does nothing (doesn't try to send anything).</FONT></P>

<P><FONT FACE="Times"> 35. If you've registered a MIME type or extension, send using the </FONT><FONT FACE="Courier New">ExgSend</FONT><FONT FACE="Times"> test application to make sure your application correctly receives (rather than relying strictly on the target).</FONT></P>

<P><FONT FACE="Times"> 36. Try the test on a 3.0 device that lacks IR capability (for example, POSE).</FONT><A NAME="P1439_66543"></A></P>

<P><I><FONT FACE="Times" SIZE="+1">Sales Application</FONT></I></P>

<P ALIGN=LEFT><FONT FACE="Times"><A NAME="P1443_66560"></A>The Sales application doesn't have categories, so we don't have a Beam Category menu item; instead, we support Beam all Customers for times when the user wants to beam all the customer information. We also support beaming a single customer. </FONT></P>

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=6>

<TR BGCOLOR="#DCF0FF">

<TD>

NOTE:<BR>
<P ALIGN=LEFT><FONT FACE="Times">We don't support beaming an entire order, although that would be a reasonable thing to add to the application, particularly if it were a commercial product. Our interests are pedagogical rather than commercial, so we are skipping that bit; adding this support would not teach you anything new.</FONT></P>
</TD>

</TR>

</TABLE>

<P ALIGN=LEFT><FONT FACE="Times"><A NAME="P1447_67094"></A>When beaming a single customer, we send the customer record itself, with a name ending in <I>.CST</I>. When beaming all customers, we send:</FONT></P>

  <UL><LI><FONT FACE="Times">  A two-byte record count indicating the number of total records we are beaming</FONT></LI>

  <LI><FONT FACE="Times">  For each record:</FONT></LI></UL>

  <UL><P><FONT FACE="Times">-  A two-byte record length for the record</FONT></P>

  <P><FONT FACE="Times">-  The customer record itself</FONT></P>

</UL><P ALIGN=LEFT><FONT FACE="Times">Let's look at handling a single customer first and then turn to dealing with them all.</FONT></P>

<P><I><FONT FACE="Times">Sending a single customer</FONT></I></P>

<P ALIGN=LEFT><FONT FACE="Times">We add support for beaming to </FONT><FONT FACE="Courier New">OrderHandleMenuEvent</FONT><FONT FACE="Times">, where we add the Beam menu item:</FONT></P><PRE><FONT SIZE="-1">case RecordBeamCustomer:</FONT>
<FONT SIZE="-1">   BeamCustomer(GetRecordNumberForCustomer(gCurrentOrder-&gt;customerID));</FONT>
<FONT SIZE="-1">   handled = true;</FONT>
<FONT SIZE="-1">   break;</FONT></PRE>

<P ALIGN=LEFT><FONT FACE="Times">When the user selects the menu item, the </FONT><FONT FACE="Courier New">BeamCustomer</FONT><FONT FACE="Times"> routine we have created gets called into play. </FONT><FONT FACE="Courier New">&#160;<A NAME="P1463_67811"></A>BeamCustomer</FONT><FONT FACE="Times"> beams a single customer:</FONT></P><PRE><FONT SIZE="-1">static void BeamCustomer(UInt recordNumber)</FONT>
<FONT SIZE="-1">{</FONT>
<FONT SIZE="-1">   ExgSocketType  s;</FONT>
<FONT SIZE="-1">   Handle         theRecord = DmQueryRecord(gCustomerDB, recordNumber);</FONT>
<FONT SIZE="-1">   PackedCustomer *thePackedCustomer = MemHandleLock(theRecord);</FONT>
<FONT SIZE="-1">   Err            err;</FONT>
<FONT SIZE="-1">   </FONT>
<FONT SIZE="-1">   MemSet(&amp;s, sizeof(s), 0);</FONT>
<FONT SIZE="-1">   s.description = thePackedCustomer-&gt;name;</FONT>
<FONT SIZE="-1">   s.name = &quot;customer.cst&quot;;</FONT>
<FONT SIZE="-1">   s.target = salesCreator;</FONT>

<FONT SIZE="-1">   err = ExgPut(&amp;s);</FONT>
<FONT SIZE="-1">   if (!err)</FONT>
<FONT SIZE="-1">      err = BeamBytes(&amp;s, thePackedCustomer, MemHandleSize(theRecord));</FONT>
<FONT SIZE="-1">   MemHandleUnlock(theRecord);</FONT>
<FONT SIZE="-1">   err = ExgDisconnect(&amp;s, err);</FONT>
<FONT SIZE="-1">}</FONT></PRE>

<P ALIGN=LEFT><FONT FACE="Courier New" SIZE="+0">BeamCustomer</FONT><FONT FACE="Times"> relies on </FONT><FONT FACE="Courier New">BeamBytes</FONT><FONT FACE="Times"> to actually send the data. Here is that code:</FONT></P><PRE><FONT SIZE="-1">static Err &#160;<A NAME="P1485_68453"></A>BeamBytes(ExgSocketPtr s, void *buffer, ULong bytesToSend)</FONT>
<FONT SIZE="-1">{</FONT>
<FONT SIZE="-1">   Err err = 0;</FONT>
<FONT SIZE="-1">   </FONT>
<FONT SIZE="-1">   while (!err &amp;&amp; bytesToSend &gt; 0) {</FONT>
<FONT SIZE="-1">      ULong bytesSent = ExgSend(s, buffer, bytesToSend, &amp;err);</FONT>
<FONT SIZE="-1">      bytesToSend -= bytesSent;</FONT>
<FONT SIZE="-1">      buffer = ((char *) buffer) + bytesSent;</FONT>
<FONT SIZE="-1">   }</FONT>
<FONT SIZE="-1">   return err;</FONT>
<FONT SIZE="-1">}</FONT></PRE>

<P ALIGN=LEFT><FONT FACE="Times">That is all the code for beaming one customer. Let's look at what we need to do to receive that information on the other end.</FONT></P>

<P><I><FONT FACE="Times">Receiving a record</FONT></I></P>

<P ALIGN=LEFT><FONT FACE="Times">First, we need to register with the Exchange Manager in </FONT><FONT FACE="Courier New">PilotMain</FONT><FONT FACE="Times">. Note that we check to make sure we are running OS 3.0 or greater before setting to work:</FONT></P><PRE><FONT SIZE="-1">} else if (cmd == sysAppLaunchCmdSyncNotify) {</FONT>
<FONT SIZE="-1">   DWord    romVersion;</FONT>
<FONT SIZE="-1">   </FONT>
<FONT SIZE="-1">   FtrGet(sysFtrCreator, sysFtrNumROMVersion, &amp;romVersion);</FONT>
<FONT SIZE="-1">   if (sysGetROMVerMajor(romVersion) &gt;= 3) </FONT>
<FONT SIZE="-1">      ExgRegisterData(kSalesCreator, exgRegExtensionID, &quot;cst&quot;);</FONT>
<FONT SIZE="-1">      </FONT>
<FONT SIZE="-1">   // code deleted that resorts our databases</FONT>
<FONT SIZE="-1">}</FONT></PRE>

<P ALIGN=LEFT><FONT FACE="Times">Next, we've got to handle the receive data launch code, which we also put into our </FONT><FONT FACE="Courier New">PilotMain</FONT><FONT FACE="Times">:</FONT></P><PRE><FONT SIZE="-1">} else if (cmd == sysAppLaunchCmdExgReceiveData) {</FONT>
<FONT SIZE="-1">      DmOpenRef   dbP;</FONT>
<FONT SIZE="-1">      </FONT>
<FONT SIZE="-1">      // if our app is not active, we need to open the database</FONT>
<FONT SIZE="-1">      // The subcall flag is used to determine whether we are active</FONT>
<FONT SIZE="-1">      if (launchFlags &amp; sysAppLaunchFlagSubCall) {</FONT>
<FONT SIZE="-1">#ifdef __GNUC__</FONT>
<FONT SIZE="-1">         CALLBACK_PROLOGUE</FONT>
<FONT SIZE="-1">#endif</FONT>
<FONT SIZE="-1">         dbP = gCustomerDB;</FONT>
<FONT SIZE="-1">         </FONT>
<FONT SIZE="-1">         // save any data we may be editing.</FONT>
<FONT SIZE="-1">         FrmSaveAllForms();</FONT>

<FONT SIZE="-1">         error = ReceiveBeam(dbP, (ExgSocketPtr) cmdPBP);</FONT>
<FONT SIZE="-1">#ifdef __GNUC__</FONT>
<FONT SIZE="-1">         CALLBACK_EPILOGUE</FONT>
<FONT SIZE="-1">#endif</FONT>
<FONT SIZE="-1">      } else {</FONT>
<FONT SIZE="-1">         dbP = DmOpenDatabaseByTypeCreator(kCustomerDBType, kSalesCreator, </FONT>
<FONT SIZE="-1">            dmModeReadWrite);</FONT>
<FONT SIZE="-1">         if (dbP) {</FONT>
<FONT SIZE="-1">            error = ReceiveBeam(dbP, (ExgSocketPtr) cmdPBP);</FONT>
<FONT SIZE="-1">         </FONT>
<FONT SIZE="-1">            DmCloseDatabase(dbP);</FONT>
<FONT SIZE="-1">         }</FONT>
<FONT SIZE="-1">      }</FONT>
<FONT SIZE="-1">   } </FONT></PRE>

<P ALIGN=LEFT><FONT FACE="Times">We open the customer database if our application isn't already running. If our application is running, and if we're using GCC, we must use </FONT><FONT FACE="Courier New">CALLBACK_PROLOGUE</FONT><FONT FACE="Times"> and </FONT><FONT FACE="Courier New">CALLBACK_EPILOGUE</FONT><FONT FACE="Times">, since </FONT><FONT FACE="Courier New">PilotMain</FONT><FONT FACE="Times"> is being called as a subroutine call from the Palm OS (if we don't put in the callback macros, we'll crash if we try to access global variables like </FONT><FONT FACE="Courier New">gCustomerDB</FONT><FONT FACE="Times">). Then, we call </FONT><FONT FACE="Courier New">FrmSaveAllForms</FONT><FONT FACE="Times"> to save any data currently being edited. </FONT><FONT FACE="Courier New">ReceiveBeam</FONT><FONT FACE="Times"> handles much of this work. Note that since new customers need to have unique customer IDs, we assign a new customer ID to the newly received customer, just as we would if the user used the New Customer... menu item.</FONT></P>

<P ALIGN=LEFT><FONT FACE="Times">This version of </FONT><FONT FACE="Courier New">&#160;<A NAME="P1543_70855"></A>ReceiveBeam</FONT><FONT FACE="Times"> doesn't receive all customers yet. See <A HREF="#P1707_76206">&quot;Receiving all customers&quot; on page&#160;246</A> for the final version, which does. </FONT></P><PRE><FONT SIZE="-1">// NB: First version that doesn't support receiving all customers yet</FONT>
<FONT SIZE="-1">static Err ReceiveBeam(DmOpenRef db, ExgSocketPtr socketPtr)</FONT>
<FONT SIZE="-1">{</FONT>
<FONT SIZE="-1">   Err      err;</FONT>
<FONT SIZE="-1">   UInt  index;</FONT>
<FONT SIZE="-1">   SDWord   newCustomerID = GetLowestCustomerID() - 1;   </FONT>

<FONT SIZE="-1">   err = ExgAccept(socketPtr);</FONT>
<FONT SIZE="-1">   if (!err) {</FONT>
<FONT SIZE="-1">      err = ReadIntoNewRecord(db, socketPtr, 0xffffffff, &amp;index);</FONT>
<FONT SIZE="-1">      // must assign a new unique customer ID</FONT>
<FONT SIZE="-1">         if (!err) {</FONT>
<FONT SIZE="-1">            VoidHand h = DmGetRecord(db, index);</FONT>
<FONT SIZE="-1">            DmWrite(MemHandleLock(h), offsetof(Customer, customerID), </FONT>
<FONT SIZE="-1">               &amp;newCustomerID, sizeof(newCustomerID)); </FONT>
<FONT SIZE="-1">            MemHandleUnlock(h);</FONT>
<FONT SIZE="-1">            DmReleaseRecord(db, index, true);</FONT>
<FONT SIZE="-1">         }</FONT>
<FONT SIZE="-1">   }</FONT>
<FONT SIZE="-1">   err = ExgDisconnect(socketPtr, err);</FONT>
<FONT SIZE="-1">   </FONT>
<FONT SIZE="-1">   if (!err) {</FONT>
<FONT SIZE="-1">      DmRecordInfo(db, index, NULL, &amp;socketPtr-&gt;goToParams.uniqueID,</FONT>
<FONT SIZE="-1">         NULL);</FONT>
<FONT SIZE="-1">      DmOpenDatabaseInfo(db, &amp;socketPtr-&gt;goToParams.dbID,</FONT>
<FONT SIZE="-1">         NULL, NULL, &amp;socketPtr-&gt;goToParams.dbCardNo, NULL);</FONT>
<FONT SIZE="-1">      socketPtr-&gt;goToParams.recordNum = index;</FONT>
<FONT SIZE="-1">      socketPtr-&gt;goToCreator = salesCreator;</FONT>
<FONT SIZE="-1">   }</FONT>
<FONT SIZE="-1">   return err;</FONT>
<FONT SIZE="-1">}</FONT></PRE>

<P ALIGN=LEFT><FONT FACE="Courier New" SIZE="+0">&#160;<A NAME="P1576_72000"></A>ReadIntoNewRecord</FONT><FONT FACE="Times"> reads until there is no more to read (or the number of bytes specified, a feature we use when reading all customers). It returns the new record number in the </FONT><FONT FACE="Courier New">indexPtr</FONT><FONT FACE="Times"> parameter:</FONT></P><PRE><FONT SIZE="-1">// read at most numBytes into a new record.</FONT>
<FONT SIZE="-1">// Don't use very much dynamic RAM or stack space--another app is running</FONT>
<FONT SIZE="-1">static Err ReadIntoNewRecord(DmOpenRef db, ExgSocketPtr socketPtr,</FONT>
<FONT SIZE="-1">   ULong numBytes, UInt *indexPtr)</FONT>
<FONT SIZE="-1">{</FONT>
<FONT SIZE="-1">   char  buffer[100];</FONT>
<FONT SIZE="-1">   Err      err;</FONT>
<FONT SIZE="-1">   UInt  index = 0;</FONT>
<FONT SIZE="-1">   ULong bytesReceived;</FONT>
<FONT SIZE="-1">   VoidHand recHandle = NULL;</FONT>
<FONT SIZE="-1">   CharPtr  recPtr;</FONT>
<FONT SIZE="-1">   ULong recSize = 0;</FONT>
<FONT SIZE="-1">   Boolean  allocatedRecord = false;</FONT>
<FONT SIZE="-1">   </FONT>
<FONT SIZE="-1">   do {</FONT>
<FONT SIZE="-1">      ULong numBytesToRead;</FONT>
<FONT SIZE="-1">      </FONT>
<FONT SIZE="-1">      numBytesToRead = min(numBytes, sizeof(buffer));</FONT>
<FONT SIZE="-1">      bytesReceived = ExgReceive(socketPtr, buffer, numBytesToRead,</FONT>
<FONT SIZE="-1">         &amp;err);</FONT>
<FONT SIZE="-1">      numBytes -= bytesReceived;</FONT>
<FONT SIZE="-1">      if (!err) {</FONT>
<FONT SIZE="-1">         if (!recHandle)</FONT>
<FONT SIZE="-1">            recHandle = DmNewRecord(db, &amp;index, bytesReceived);</FONT>
<FONT SIZE="-1">         else</FONT>
<FONT SIZE="-1">            recHandle = DmResizeRecord(db, index, </FONT>
<FONT SIZE="-1">               recSize + bytesReceived);</FONT>
<FONT SIZE="-1">         if (!recHandle) {</FONT>
<FONT SIZE="-1">            err = DmGetLastErr();</FONT>
<FONT SIZE="-1">            break;</FONT>
<FONT SIZE="-1">         }</FONT>
<FONT SIZE="-1">         allocatedRecord = true;</FONT>
<FONT SIZE="-1">         recPtr = MemHandleLock(recHandle);</FONT>
<FONT SIZE="-1">         err = DmWrite(recPtr, recSize, buffer, bytesReceived);</FONT>
<FONT SIZE="-1">         MemHandleUnlock(recHandle);</FONT>
<FONT SIZE="-1">         recSize += bytesReceived;</FONT>
<FONT SIZE="-1">      }</FONT>
<FONT SIZE="-1">   } while (!err &amp;&amp; bytesReceived &gt; 0 &amp;&amp; numBytes &gt; 0);</FONT>
<FONT SIZE="-1">   </FONT>
<FONT SIZE="-1">   if (recHandle) {</FONT>
<FONT SIZE="-1">      DmReleaseRecord(db, index, true);</FONT>
<FONT SIZE="-1">   }</FONT>
<FONT SIZE="-1">   if (err &amp;&amp; allocatedRecord)</FONT>
<FONT SIZE="-1">      DmRemoveRecord(db, index);</FONT>
<FONT SIZE="-1">      </FONT>
<FONT SIZE="-1">   *indexPtr = index;</FONT>
<FONT SIZE="-1">   return err;</FONT>
<FONT SIZE="-1">}</FONT></PRE>

<P ALIGN=LEFT><FONT FACE="Times">That is all there is to sending and receiving a single customer. Next, let's look at what additional changes you need to make to beam or receive them all at once.</FONT></P>

<P><I><FONT FACE="Times">Sending all customers</FONT></I></P>

<P ALIGN=LEFT><FONT FACE="Times">Once again, we add something to our </FONT><FONT FACE="Courier New">CustomersHandleMenuEvent</FONT><FONT FACE="Times"> that handles sending all customers:</FONT></P><PRE><FONT SIZE="-1">case CustomerBeamAllCustomers:</FONT>
<FONT SIZE="-1">   BeamAllCustomers();</FONT>
<FONT SIZE="-1">   handled = true;</FONT>
<FONT SIZE="-1">   break;</FONT></PRE>

<P ALIGN=LEFT><FONT FACE="Times">It calls </FONT><FONT FACE="Courier New">&#160;<A NAME="P1636_73907"></A>BeamAllCustomers</FONT><FONT FACE="Times"> which beams the number of records, then the size of each record and the record itself:</FONT></P><PRE><FONT SIZE="-1">#define kMaxNumberLength   5</FONT>

<FONT SIZE="-1">static void BeamAllCustomers(void)</FONT>
<FONT SIZE="-1">{</FONT>
<FONT SIZE="-1">   DmOpenRef   dbP = gCustomerDB;</FONT>
<FONT SIZE="-1">   UInt     mode;</FONT>
<FONT SIZE="-1">   LocalID     dbID;</FONT>
<FONT SIZE="-1">   UInt     cardNo;</FONT>
<FONT SIZE="-1">   Boolean     databaseReopened;</FONT>
<FONT SIZE="-1">   UInt     numCustomers;</FONT>
<FONT SIZE="-1">   </FONT>
<FONT SIZE="-1">    // If the database was opened to show secret records, reopen it to not              </FONT>
<FONT SIZE="-1">   // see secret records.  The idea is that secret records are not sent </FONT>
<FONT SIZE="-1">   // when a category is sent.  They must be explicitly sent one by one.</FONT>
<FONT SIZE="-1">   DmOpenDatabaseInfo(dbP, &amp;dbID, NULL, &amp;mode, &amp;cardNo, NULL);</FONT>
<FONT SIZE="-1">   if (mode &amp; dmModeShowSecret) {</FONT>
<FONT SIZE="-1">      dbP = DmOpenDatabase(cardNo, dbID, dmModeReadOnly);</FONT>
<FONT SIZE="-1">      databaseReopened = true;</FONT>
<FONT SIZE="-1">   } else</FONT>
<FONT SIZE="-1">      databaseReopened = false;</FONT>
<FONT SIZE="-1">   </FONT>
<FONT SIZE="-1">   // We should send  because there's at least one record to send.</FONT>
<FONT SIZE="-1">   if ((numCustomers = DmNumRecordsInCategory(dbP, dmAllCategories)) &gt; 0) </FONT>
<FONT SIZE="-1">   {</FONT>
<FONT SIZE="-1">      ExgSocketType  s;</FONT>
<FONT SIZE="-1">      VoidHand recHandle;</FONT>
<FONT SIZE="-1">      Err      err;</FONT>
<FONT SIZE="-1">      UInt  index = dmMaxRecordIndex;</FONT>
<FONT SIZE="-1">      </FONT>
<FONT SIZE="-1">      MemSet(&amp;s, sizeof(s), 0);</FONT>
<FONT SIZE="-1">      s.description = &quot;All customers&quot;;</FONT>
<FONT SIZE="-1">      s.target = kSalesCreator;</FONT>
<FONT SIZE="-1">      s.localMode = 1;</FONT>
<FONT SIZE="-1">      </FONT>
<FONT SIZE="-1">      err = ExgPut(&amp;s);</FONT>
<FONT SIZE="-1">      if (!err)</FONT>
<FONT SIZE="-1">         err = BeamBytes(&amp;s, &amp;numCustomers, sizeof(numCustomers));</FONT>
<FONT SIZE="-1">      </FONT>
<FONT SIZE="-1">      while (!err &amp;&amp; numCustomers-- &gt; 0) {</FONT>
<FONT SIZE="-1">         UInt  numberToSeekBackward = 1;</FONT>
<FONT SIZE="-1">         </FONT>
<FONT SIZE="-1">         if (index == dmMaxRecordIndex)</FONT>
<FONT SIZE="-1">            numberToSeekBackward = 0;  // we want the last one</FONT>
<FONT SIZE="-1">         err = DmSeekRecordInCategory(dbP, &amp;index, numberToSeekBackward,</FONT>
<FONT SIZE="-1">            dmSeekBackward, dmAllCategories);</FONT>
<FONT SIZE="-1">         if (!err) {</FONT>
<FONT SIZE="-1">            UInt recordSize;</FONT>

<FONT SIZE="-1">            recHandle = DmQueryRecord(dbP, index);</FONT>
<FONT SIZE="-1">            ErrNonFatalDisplayIf(!recHandle, &quot;Couldn't query record&quot;);</FONT>
<FONT SIZE="-1">            recordSize = MemHandleSize(recHandle);</FONT>
<FONT SIZE="-1">            err = BeamBytes(&amp;s, &amp;recordSize, sizeof(recordSize));</FONT>
<FONT SIZE="-1">            if (!err) {</FONT>
<FONT SIZE="-1">               PackedCustomer *theRecord = MemHandleLock(recHandle);</FONT>
<FONT SIZE="-1">               </FONT>
<FONT SIZE="-1">               err = BeamBytes(&amp;s, theRecord, MemHandleSize(recHandle));</FONT>
<FONT SIZE="-1">               MemHandleUnlock(recHandle);</FONT>
<FONT SIZE="-1">            }</FONT>
<FONT SIZE="-1">         }</FONT>
<FONT SIZE="-1">      }</FONT>
<FONT SIZE="-1">      err = ExgDisconnect(&amp;s, err);</FONT>
<FONT SIZE="-1">   } else </FONT>
<FONT SIZE="-1">      FrmAlert(NoDataToBeamAlert);</FONT>
<FONT SIZE="-1">   </FONT>
<FONT SIZE="-1">   if (databaseReopened)</FONT>
<FONT SIZE="-1">      DmCloseDatabase(dbP);</FONT>
<FONT SIZE="-1">}</FONT></PRE>

<P ALIGN=LEFT><FONT FACE="Courier New" SIZE="+0">BeamAllCustomers</FONT><FONT FACE="Times"> uses </FONT><FONT FACE="Courier New">BeamBytes</FONT><FONT FACE="Times">, which we've already seen. </FONT></P>

<P><I><FONT FACE="Times"><A NAME="P1707_76206"></A>Receiving all customers</FONT></I></P>

<P ALIGN=LEFT><FONT FACE="Times">In order to receive all customers, </FONT><FONT FACE="Courier New">&#160;<A NAME="P1709_76265"></A>ReceiveBeam</FONT><FONT FACE="Times"> must change just a bit (changes are in bold):</FONT></P><PRE><FONT SIZE="-1">static Err ReceiveBeam(DmOpenRef db, ExgSocketPtr socketPtr)</FONT>
<FONT SIZE="-1">{</FONT>
<FONT SIZE="-1">   Err      err;</FONT>
<FONT SIZE="-1">   UInt     index;</FONT>
<FONT SIZE="-1">   Boolean  nameEndsWithCst = false;</FONT>
<FONT SIZE="-1">   SDWord   newCustomerID = GetLowestCustomerID() - 1;   </FONT>
<FONT SIZE="-1">   </FONT>
<B><FONT SIZE="-1">   // we have a single customer if it has a name ending</FONT></B>
<B><FONT SIZE="-1">   // in &quot;.cst&quot;. Otherwise, it's all customers. &quot;All customers&quot;</FONT></B>
<B><FONT SIZE="-1">   //  will have a name</FONT></B>
<B><FONT SIZE="-1">   // because the exchange manager provides one automatically.</FONT></B>
<B><FONT SIZE="-1">   if (socketPtr-&gt;name) {</FONT></B>
<B><FONT SIZE="-1">      CharPtr  dotLocation = StrChr(socketPtr-&gt;name, '.');</FONT></B>
<B><FONT SIZE="-1">      if (dotLocation &amp;&amp; StrCaselessCompare(dotLocation, &quot;.cst&quot;) == 0)</FONT></B>
<B><FONT SIZE="-1">         nameEndsWithCst = true;</FONT></B>
<B><FONT SIZE="-1">   }</FONT></B>
<FONT SIZE="-1">   err = ExgAccept(socketPtr);</FONT>
<FONT SIZE="-1">   if (!err) {</FONT>
<B><FONT SIZE="-1">      if (nameEndsWithCst || socketPtr-&gt;type) {</FONT></B>
<FONT SIZE="-1">         // one customer</FONT>
<FONT SIZE="-1">         err = ReadIntoNewRecord(db, socketPtr, 0xffffffff, &amp;index);</FONT>
<FONT SIZE="-1">         </FONT>
<FONT SIZE="-1">         // must assign a new unique customer ID</FONT>
<FONT SIZE="-1">         if (!err) {</FONT>
<FONT SIZE="-1">            VoidHand h = DmGetRecord(db, index);</FONT>
<FONT SIZE="-1">            DmWrite(MemHandleLock(h), offsetof(Customer, customerID), </FONT>
<FONT SIZE="-1">               &amp;newCustomerID, sizeof(newCustomerID)); </FONT>
<FONT SIZE="-1">            MemHandleUnlock(h);</FONT>
<FONT SIZE="-1">            DmReleaseRecord(db, index, true);</FONT>
<FONT SIZE="-1">         }</FONT>
<B><FONT SIZE="-1">      } else {</FONT></B>
<B><FONT SIZE="-1">         // all customers</FONT></B>
<B><FONT SIZE="-1">         UInt  numRecords;</FONT></B>

<B><FONT SIZE="-1">&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;ExgReceive(socketPtr, &amp;numRecords, sizeof(numRecords), &amp;err);</FONT></B>
<B><FONT SIZE="-1">&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;while (!err &amp;&amp; numRecords-- &gt; 0) {</FONT></B>
<B><FONT SIZE="-1">&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;UInt recordSize;</FONT></B>

<B><FONT SIZE="-1">            ExgReceive(socketPtr, &amp;recordSize, sizeof(recordSize), &amp;err);</FONT></B>
<B><FONT SIZE="-1">&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;if (!err) {</FONT></B>
<B><FONT SIZE="-1">               err = ReadIntoNewRecord(db, socketPtr, recordSize, &amp;index);</FONT></B>
<B><FONT SIZE="-1">               // must assign a new unique customer ID</FONT></B>
<B><FONT SIZE="-1">               if (!err) {</FONT></B>
<B><FONT SIZE="-1">                  VoidHand h = DmGetRecord(db, index);</FONT></B>
<B><FONT SIZE="-1">                  DmWrite(MemHandleLock(h), </FONT></B>
<B><FONT SIZE="-1">                  	offsetof(Customer, customerID), </FONT></B>
<B><FONT SIZE="-1">                  	&amp;newCustomerID, sizeof(newCustomerID)); </FONT></B>
<B><FONT SIZE="-1">                  newCustomerID--;</FONT></B>
<B><FONT SIZE="-1">                  MemHandleUnlock(h);</FONT></B>
<B><FONT SIZE="-1">                  DmReleaseRecord(db, index, true);</FONT></B>
<B><FONT SIZE="-1">               }</FONT></B>
<B><FONT SIZE="-1">            }</FONT></B>
<B><FONT SIZE="-1">&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;}</FONT></B>
<B><FONT SIZE="-1">      }</FONT></B>
<FONT SIZE="-1">   }</FONT>
<FONT SIZE="-1">   err = ExgDisconnect(socketPtr, err);</FONT>
<FONT SIZE="-1">   </FONT>
<FONT SIZE="-1">   if (!err) {</FONT>
<FONT SIZE="-1">      DmRecordInfo(db, index, NULL, &amp;socketPtr-&gt;goToParams.uniqueID,</FONT>
<FONT SIZE="-1">         NULL);</FONT>
<FONT SIZE="-1">      DmOpenDatabaseInfo(db, &amp;socketPtr-&gt;goToParams.dbID,</FONT>
<FONT SIZE="-1">         NULL, NULL, &amp;socketPtr-&gt;goToParams.dbCardNo, NULL);</FONT>
<FONT SIZE="-1">      socketPtr-&gt;goToParams.recordNum = index;</FONT>
<FONT SIZE="-1">      socketPtr-&gt;goToCreator = kSalesCreator;</FONT>
<FONT SIZE="-1">   }</FONT>
<FONT SIZE="-1">   return err;</FONT>
<FONT SIZE="-1">}</FONT><A NAME="P1777_78624"></A></PRE>

<P ALIGN=LEFT><FONT FACE="Times">That is all the code needed to support beaming. Use the checklist to make sure you take care of all the little details, and review the sample application if you have any further questions. Otherwise, it's on to another topic.</FONT><A NAME="P1778_78849"></A></P>

<P><A NAME="P1781_78849"></A>

<TABLE BORDER=0 WIDTH="100%">
<TR>
<TD><H1 ALIGN=LEFT><I><FONT FACE="Times" SIZE="+2">Barcodes</FONT></I></H1></TD>
<TD><P ALIGN=RIGHT><A HREF="#TopOfPage"><IMG SRC="images/appletop.gif" ALT="Top Of Page" BORDER=0 width="34" height="26"></A></P></TD></TR></TABLE></P>
<P ALIGN=LEFT><IMG SRC="images/applespl.gif" width="751" height="7"></P>

<P ALIGN=LEFT><FONT FACE="Times"><A NAME="P1783_78857"></A>The <A NAME="P1783_78861"></A>Symbol SPT 1500 has a built-in barcode scanner (see <A HREF="#P1784_79250">Figure 8-6</A>). The two buttons at the top of the device start the scan, and the barcode scanner runs along the top of the device. As you might imagine, for some vertical applications, this can be quite useful (for example, salespeople could have a catalog with barcoded items; warehouse workers could read barcodes from boxes). </FONT></P>

<P><B><FONT FACE="Times" SIZE="-1">Figure 8- 6</FONT></B><A NAME="P1784_79250"></A>. 

<B><FONT FACE="Times" SIZE="-1">Symbol SPT 1500 with barcode scanner</FONT></B><BR>
<P><UL>
<TABLE>
<TR>
<TD WIDTH=512><P ALIGN=CENTER><IMG SRC="images/ch08-plmp.0806-8.gif" WIDTH=503 HEIGHT=134 align=left></P>
</TD></TR></TABLE></UL>

<P ALIGN=LEFT><FONT FACE="Times">If you want to implement barcode scanning in an application, there are some special requirements and APIs from Symbol to use. First, let's look at some of the API calls that barcode reading brings to the Palm 3.0 OS. Then we do a code walkthrough of a sample application that scans barcodes.</FONT></P>

<P ALIGN=LEFT><FONT FACE="Times">For more information on the Symbol APIs or the SDK, contact Symbol Technologies (<A HREF="http://www.symbol.com/palm"><I>http://www.symbol.com/palm</I>)</A>. Symbol also has a neat utility program that lets you turn the SPT 1500 device into a unit dedicated to your application. The utility allows you to reflash the device ROM to include or dedicate it to your application. For more information on this, contact Symbol.<A HREF="#P1797_79949">*</A></FONT></P>

<P><I><FONT FACE="Times" SIZE="+1">Handling Scanning in an Application</FONT></I></P>

<P ALIGN=LEFT><FONT FACE="Times"><A NAME="P1801_80159"></A>There are some minor additions to the Palm 3.0 OS. The basic support for scanning barcodes requires these simple steps:</FONT></P>

<P><FONT FACE="Times"> 1. Your code needs to make sure you have a Symbol device by calling the function </FONT><FONT FACE="Courier New">&#160;<A NAME="P1803_80360"></A>ScanIsPalmSymbolUnit</FONT><FONT FACE="Times">. If it isn't a Symbol device, make no further Symbol calls. This routine is provided as part of a library; thus, you can call it whether or not you are on a Symbol device. You should normally call this once at the beginning of your program and store its result in a global.</FONT></P>

<P><FONT FACE="Times"> 2. The next step is to load the Symbol library with </FONT><FONT FACE="Courier New">&#160;<A NAME="P1804_80707"></A>ScanOpenDecoder</FONT><FONT FACE="Times">. Once you've done this, the scanner provides power to the scanning hardware. To save battery life, you usually don't do this at the start of your application, where scanning is inappropriate (for instance, only some forms may allow scanning, so you may enable scanning when such a form opens). After calling this routine, the scan hardware has power, but the user still can't press the buttons to do a scan.</FONT></P>

<P><FONT FACE="Times"> 3. Once the Symbol library is open, you have a few optional alternatives to consider. These involve initializing various scanning options, such as:</FONT></P>

  <UL><P><FONT FACE="Times">-  The type of barcodes to be recognized.</FONT></P>

  <P><FONT FACE="Times">-  The feedback options you want to give when a barcode is scanned-you can have the unit beep or flash the green LED or both.</FONT></P>

  <P><FONT FACE="Times">-  Options on the barcodes that include lengths, conversions, checksums, etc.</FONT></P>

</UL><P><FONT FACE="Times"> 4. When you are actually ready for the user to scan, call </FONT><FONT FACE="Courier New">&#160;<A NAME="P1809_81576"></A>ScanCmdScanEnable</FONT><FONT FACE="Times">. Don't just blindly call this routine after opening the scanning library. Enable scanning only when it actually makes sense for the user to scan (for example, when the user enters a particular field). Otherwise, the user might accidentally press one of the two built-in scan buttons, which will:</FONT></P>

  <UL><P><FONT FACE="Times">-  Cause the laser to activate while the unit isn't pointing at a barcode. Activating lasers that are pointing at random locations is a bad idea (think lawsuit).</FONT></P>

  <P><FONT FACE="Times">-  Unnecessarily drain the battery.</FONT></P>

</UL><P><FONT FACE="Times"> 5. Your application needs to respond to two new events while scanning is enabled:</FONT></P>

  <UL><P><FONT FACE="Times">- </FONT><FONT FACE="Courier New"><A NAME="P1813_82166"> </A>scanDecodeEvent</FONT><FONT FACE="Times">. This is sent when a scan (successful or unsuccessful) has occurred. In response to such an event, call </FONT><FONT FACE="Courier New">&#160;<A NAME="P1813_82287"></A>ScanGetDecodedData</FONT><FONT FACE="Times">. You get the scanned ASCII data from this call as well as what kind of barcode (there are many different symbologies) was scanned.</FONT></P>

  <P><FONT FACE="Times">- </FONT><FONT FACE="Courier New"><A NAME="P1814_82438"> </A>scanBatteryErrorEvent</FONT><FONT FACE="Times">. This event is sent when the<A NAME="P1814_82488"></A> battery is too low to do a scan. As a scan requires more power from the battery than simply running the handheld, there may be enough battery life to run the handheld, but not enough to do the scan. This event is sent so that you can alert the user to the problem.</FONT></P>

</UL><TABLE BORDER=0 CELLSPACING=0 CELLPADDING=6>

<TR BGCOLOR="#DCF0FF">

<TD>

NOTE:<BR>
<P ALIGN=LEFT><FONT FACE="Times">It is very important that you handle </FONT><FONT FACE="Courier New">scanBatteryErrorEvent</FONT><FONT FACE="Times"> correctly in your application. Without a proper alert, the user will have no idea why the scan did not occur.</FONT></P>
</TD>

</TR>

</TABLE>

<P><FONT FACE="Times"> 6. When scanning is no longer appropriate (for instance, the user leaves a field in which they are allowed to scan), call </FONT><FONT FACE="Courier New">&#160;<A NAME="P1817_83044"></A>ScanCmdScanDisable</FONT><FONT FACE="Times">.</FONT></P>

<P><FONT FACE="Times"> 7. When you're ready to shut down the scanner, call </FONT><FONT FACE="Courier New">&#160;<A NAME="P1818_83116"></A>ScanCloseDecoder</FONT><FONT FACE="Times">. This may be at the end of your application for an application that allows scanning everywhere. It may be as a form closes, if you've got some forms that allow scanning and others that don't.</FONT><A NAME="P1818_83324"></A></P>

<P><I><FONT FACE="Times" SIZE="+1">A Scanning Sample</FONT></I></P>

<P ALIGN=LEFT><FONT FACE="Times">Some applications might be written so that any field could be written into with Graffiti or, alternatively, scanned into with the barcode scanner. The code we've written is designed to retrofit an existing application to allow input to any field from the scanner. A successful scan takes the scanned data and inserts it in the field that contains the insertion point.</FONT></P>

<P><I><FONT FACE="Times">Starting up the application</FONT></I></P>

<P ALIGN=LEFT><FONT FACE="Times">In </FONT><FONT FACE="Courier New">AppStart</FONT><FONT FACE="Times">, we check to make sure we're running on a Symbol unit. If so, we initialize the library, set parameters so that we can scan every type of barcode and enable scanning (remember that this application allows scanning anywhere):</FONT></P><PRE><FONT SIZE="-1">static Boolean gScanManagerInitialized = false;</FONT>

<FONT SIZE="-1">static Err AppStart(void)</FONT>
<FONT SIZE="-1">{</FONT>
<FONT SIZE="-1">   // other initialization code deleted</FONT>

<FONT SIZE="-1">   if (ScanIsPalmSymbolUnit()) {</FONT>
<FONT SIZE="-1">      Err err = ScanOpenDecoder();  // load the scanner library</FONT>
<FONT SIZE="-1">      if (err == 0) {</FONT>
<FONT SIZE="-1">         int i;</FONT>
<FONT SIZE="-1">         // we want to be able to scan everything we can get our hands on</FONT>
<FONT SIZE="-1">         // If we just wanted the default types, we could jump directly</FONT>
<FONT SIZE="-1">         // to calling ScanCmdScanEnable</FONT>
<FONT SIZE="-1">         BarType allTypes[] = {</FONT>
<FONT SIZE="-1">            barCODE39, barUPCA, barUPCE, barEAN13, barEAN8, barD25,</FONT>
<FONT SIZE="-1">            barI2OF5, barCODABAR, barCODE128, barCODE93, barTRIOPTIC39,</FONT>
<FONT SIZE="-1">            barUCC_EAN128, barMSI_PLESSEY, barUPCE1, barBOOKLAND_EAN,</FONT>
<FONT SIZE="-1">            barISBT128, barCOUPON};</FONT>
<FONT SIZE="-1">         for (i = 0; i &lt; sizeof(allTypes) / sizeof(*allTypes); i++)</FONT>
<FONT SIZE="-1">            err = ScanSetBarcodeEnabled(allTypes[i], true); </FONT>
<FONT SIZE="-1">         err = ScanCmdSendParams(No_Beep); // send all the accumulated</FONT>
<FONT SIZE="-1">                                           // settings to scanner</FONT>

<FONT SIZE="-1">         // allow scanning as of now (uses some battery life)</FONT>
<FONT SIZE="-1">         err = ScanCmdScanEnable(); </FONT>
<FONT SIZE="-1">         gScanManagerInitialized = true;</FONT>
<FONT SIZE="-1">      }</FONT>
<FONT SIZE="-1">   }</FONT>
<FONT SIZE="-1">   return 0;</FONT>
<FONT SIZE="-1">}</FONT></PRE>

<P><I><FONT FACE="Times">The application shutdown</FONT></I></P>

<P ALIGN=LEFT><FONT FACE="Times">In </FONT><FONT FACE="Courier New">AppStop</FONT><FONT FACE="Times">, we disable scanning and close the library:</FONT></P><PRE><FONT SIZE="-1">static void AppStop(void)</FONT>
<FONT SIZE="-1">{</FONT>
<FONT SIZE="-1">   // other termination code deleted</FONT>

<FONT SIZE="-1">   if (gScanManagerInitialized) {</FONT>
<FONT SIZE="-1">      ScanCmdScanDisable();   // turn scanner off</FONT>
<FONT SIZE="-1">      ScanCloseDecoder();</FONT>
<FONT SIZE="-1">   }</FONT>
<FONT SIZE="-1">}</FONT></PRE>

<P><I><FONT FACE="Times">Event handling</FONT></I></P>

<P ALIGN=LEFT><FONT FACE="Times"><A NAME="P1874_85360"></A>In </FONT><FONT FACE="Courier New">AppHandleEvent</FONT><FONT FACE="Times">, we put up an alert (see <A HREF="#P1875_85460">Figure 8-7</A>) if the battery is too low to scan.</FONT></P>

<P><B><FONT FACE="Times" SIZE="-1">Figure 8- 7</FONT></B><A NAME="P1875_85460"></A>. 

<B><FONT FACE="Times" SIZE="-1">The application's alert that is posted when a scanBatteryErrorEvent occurs</FONT></B><BR>
<P><UL>
<TABLE>
<TR>
<TD WIDTH=512><P ALIGN=CENTER><IMG SRC="images/ch08-plmp.0807-9.gif" WIDTH=503 HEIGHT=89 align=left></P>
</TD></TR></TABLE></UL>

<P ALIGN=LEFT><FONT FACE="Times">Here is the code that accomplishes this task:</FONT></P><PRE><FONT SIZE="-1">if (eventP-&gt;eType == <A NAME="P1887_85600"></A>scanBatteryErrorEvent) {</FONT>
<FONT SIZE="-1">     FrmAlert(LowScanBatteryAlert);</FONT>
<FONT SIZE="-1">     return true;</FONT>
<FONT SIZE="-1">}</FONT></PRE>

<P ALIGN=LEFT><FONT FACE="Times">Also in </FONT><FONT FACE="Courier New">AppHandleEvent</FONT><FONT FACE="Times">, we need to handle a scan event:</FONT></P><PRE><FONT SIZE="-1">if (eventP-&gt;eType == scanDecodeEvent) {</FONT>
<FONT SIZE="-1">   MESSAGE decodeDataMsg;</FONT>

<FONT SIZE="-1">   int status = ScanGetDecodedData( &amp;decodeDataMsg );</FONT>
<FONT SIZE="-1">   // if we successfully got the decode data from the API...</FONT>
<FONT SIZE="-1">if( status == STATUS_OK ) { </FONT>
<FONT SIZE="-1">      FormPtr form = FrmGetActiveForm();</FONT>

<FONT SIZE="-1">      // a response of NR means no scan happened. If so, ignore it</FONT>
<FONT SIZE="-1">      if (decodeDataMsg.length == 2 &amp;&amp; decodeDataMsg.data[0] == 'N' &amp;&amp;</FONT>
<FONT SIZE="-1">         decodeDataMsg.data[1] == 'R')</FONT>
<FONT SIZE="-1">         return true;</FONT>

<FONT SIZE="-1">      // find the focused field and insert there</FONT>
<FONT SIZE="-1">      if (form) {</FONT>
<FONT SIZE="-1">         Word    focusedIndex = FrmGetFocus(form);</FONT>
<FONT SIZE="-1">             </FONT>
<FONT SIZE="-1">         //focusedIndex is documented to return -1 but is also documented</FONT>
<FONT SIZE="-1">         // to return a (unsigned) Word. Instead of returning -1, then, </FONT>
<FONT SIZE="-1">         // it returns 65536</FONT>
<FONT SIZE="-1">         if (focusedIndex &gt;= 0 &amp;&amp; focusedIndex &lt; 65535) {</FONT>
<FONT SIZE="-1">            if (FrmGetObjectType(form, focusedIndex) == frmFieldObj) {</FONT>
<FONT SIZE="-1">               FieldPtr focusedField = </FONT>
<FONT SIZE="-1">                  (FieldPtr) FrmGetObjectPtr(form, focusedIndex);</FONT>
<FONT SIZE="-1">                     </FONT>
<FONT SIZE="-1">               if (focusedField-&gt;attr.editable)</FONT>
<FONT SIZE="-1">                  FldInsert(focusedField, (CharPtr) decodeDataMsg.data,</FONT>
<FONT SIZE="-1">                     decodeDataMsg.length);</FONT>
<FONT SIZE="-1">            }</FONT>
<FONT SIZE="-1">         }</FONT>
<FONT SIZE="-1">     }</FONT>
<FONT SIZE="-1">   }</FONT>
<FONT SIZE="-1">   return true;</FONT>
<FONT SIZE="-1">}</FONT></PRE>

<P ALIGN=LEFT><FONT FACE="Times">This is all there is to supporting barcode reading in an application. With a dandy device like the Symbol SPT 1500 and such an easy set of changes required to support barcode scanning, you should expect to see a variety of <A NAME="P1927_87158"></A>applications.</FONT><A NAME="P1927_87171"></A></P>
<HR ALIGN=LEFT SIZE=2 WIDTH=100% NOSHADE>

<P><A NAME="P1797_79949"></A>
* <FONT FACE="Times" SIZE="-1">If you are new to barcode technologies, there is an excellent reference work available: <I>The Bar Code Book</I>, by Roger C. Palmer, 1995, Third Ed. (Helmers, ISBN: 0-91126-109-5).</FONT></P>
<!-- TRANSIT - TEXTBAR -->

<ADDRESS><FONT SIZE=-1>Palm Programming: The Developer's Guide
<BR>Copyright &#169; 1999, O'Rielly and Associates, Inc.
<BR>Published on the web by permission of O'Rielly and Associates, Inc. Contents modified for web display.</FONT></ADDRESS><P ALIGN=RIGHT><!-- TRANSIT - PREVIOUS PAGE --><A HREF="ch07.htm#TopOfPage"><IMG SRC="images/appleppv.gif" ALT="Previous Page" BORDER=0 width="34" height="26"></A><A HREF="#TopOfPage"><IMG SRC="images/appletop.gif" ALT="Top Of Page" BORDER=0 width="34" height="26"></A><!-- TRANSIT - TOC --><A HREF="TableOfContents.htm#TopOfPage" TARGET="_top"><IMG SRC="images/appletoc.gif" ALT="Table Of Contents" BORDER=0 width="34" height="26"></A><!-- TRANSIT - INDEX --><A HREF="index.htm#TopOfPage"><IMG SRC="images/appleidx.gif" ALT="Index" BORDER=0 width="34" height="26"></A><!-- TRANSIT - NEXT PAGE --><A HREF="ch09.htm#TopOfPage"><IMG SRC="images/applepnx.gif" ALT="Next Page" BORDER=0 width="34" height="26"></A></P>
</BODY>
</HTML>
