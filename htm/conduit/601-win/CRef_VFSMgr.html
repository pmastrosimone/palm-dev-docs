<html>
<head>
<title>Virtual File System Manager API | C/C++ Sync Suite Reference</title> 
<link href="psi_devpubs.css" rel="stylesheet" type="text/css">

<!-- BEGIN META DATA -->
<meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
<META NAME="KEYWORDS" CONTENT="C, C++, C/C++ Sync Suite, Virtual File System Manager, Virtual File System, VFS, VFS Manager, vfsmgr, expansion, card, slot, file, file system, reference, API, CDK, conduit, conduits, Windows">
<META NAME="DESCRIPTION" CONTENT="Provides reference details on the Virtual File System Manager API in the C/C++ Sync Suite.">
<META NAME="PSITEMPLATE" CONTENT="1006-007 PalmSource HTML 20040609">
<META NAME="GENERATOR" CONTENT="Quadralay WebWorks Publisher Professional Edition 6.0.7">
<META NAME="LASTUPDATED" CONTENT="06/28/04 08:30:10">
<!-- END META DATA -->
</head>

<body bgcolor="#ffffff" text="#000000" leftmargin="0" topmargin="0" marginwidth="0" marginheight="0">
<a name="995934"></a>

<!-- BEGIN TOPNAV -->
<table width="100%" border="0" cellspacing="0" cellpadding="0">
<tr>
<td><img src="images/shim.gif" width="7" height="75" border="0" alt=""></td>
<td align="left"><table border="0" cellpadding="0" cellspacing="0" width="744">
<tr>
<td><img name="index_r2_c1" src="images/shim.gif" width="25" height="75" border="0" alt=""></td>
<td valign="top"><table border="0" cellpadding="0" cellspacing="0" width="96">
<tr>
<td><img name="index_r2_c4" src="images/shim.gif" width="96" height="15" border="0" alt=""></td>
</tr>
<tr>
<td><a href="http://www.palmsource.com/"><img name="ps_logo" src="images/ps_logo.gif" width="96" height="54" border="0" alt=""></a></td>
</tr>

</table>
</td>

<td><table border="0" cellpadding="0" cellspacing="0" width="30">
<td><img name="index_x" src="images/shim.gif" width="30" height="75" border="0" alt=""></td>
</table></td>

<!--BEGIN MASTHEAD-->
<td><table border="0" cellpadding="0" cellspacing="0" width="96">
<tr>
<td><img name="index_x" src="images/shim.gif" width="615" height="5" border="0" alt=""></td>
</tr>
<tr>
<td>
<!--BEGIN BOOK NAVIGATION-->
<span class="nav">
<A href="http://www.palmos.com/dev/support/docs/">Documentation</a>&nbsp;&nbsp;|&nbsp;&nbsp;
<a href="C++SyncReferenceTOC.html">Table of Contents</a>&nbsp;&nbsp;
             |&nbsp;&nbsp;<a href="CRef_ExpMgr.html">&lt;&nbsp;Previous</a>&nbsp;&nbsp;
             |&nbsp;&nbsp;<a href="CRef_Part_Desktop.html">Next&nbsp;&gt;</a>&nbsp;&nbsp;
             |&nbsp;&nbsp;<a href="C++SyncReferenceIX.html">Index</a>
</span>
<!--END BOOK NAVIGATION-->
</tr>
<tr>
<td>
<!--BEGIN PAGE TITLE-->
<h2 class="PageTitle">10 &nbsp;&nbsp;
Virtual File System Manager API</h2></td>
<!--END PAGE TITLE-->
</tr>
<tr>
<td>
<!--BEGIN BOOK TITLE-->
<p class="BookTitle">C/C++ Sync Suite Reference</p>
<p class="SubTitle">Palm OS&#174; Conduit Development Kit for Windows, Version 6.0.1 </p>
<!--END BOOK TITLE-->
</td>
</tr>
<tr>
<td><img name="index_x" src="images/shim.gif" width="615" height="5" border="0" alt=""></td>
</tr>
</table>
</td>
<!--END MASTHEAD-->
</tr>
</table>
<img name="dashes" src="images/dashes.gif" width="744" height="3" border="0" alt=""></td>
</tr>
</table>
<!-- END TOPNAV -->

<table width="100%" border="0" cellspacing="0" cellpadding="0">
<tr>
<td valign="top" width="5"><img name="index_x" src="images/shim.gif" width="5" height="33" border="0" alt=""></td>

<!--BEGIN SIDETOC-->
<td valign="top" width="175">
<div id="sidetoc" valign="bottom">
<h1 class="SideTOC1-PartTab"><a href="CRef_Part_Conduit.html">Part II: Conduit APIs</a> </h1>
<h1 class="SideTOC1"><a href="CRef_VFSMgr.html">10  Virtual File System Manager API</a></h1>

   <h2 class="SideTOC2"><a href="#995992">
   VFS Manager Structures and Types</a></h2>

      <h3 class="SideTOC3"><a href="#996019">
      FileInfoType</a></h3>

      <h3 class="SideTOC3"><a href="#996057">
      FileOrigin</a></h3>

      <h3 class="SideTOC3"><a href="#996090">
      FileRef</a></h3>

      <h3 class="SideTOC3"><a href="#996110">
      VFSAnyMountParamType</a></h3>

      <h3 class="SideTOC3"><a href="#996156">
      VFSSlotMountParamType</a></h3>

      <h3 class="SideTOC3"><a href="#996205">
      VolumeInfoType</a></h3>

   <h2 class="SideTOC2"><a href="#996265">
   VFS Manager Constants</a></h2>

      <h3 class="SideTOC3"><a href="#996304">
      Date Types</a></h3>

      <h3 class="SideTOC3"><a href="#996342">
      Defined File Systems</a></h3>

      <h3 class="SideTOC3"><a href="#996392">
      File and Directory Attributes</a></h3>

      <h3 class="SideTOC3"><a href="#996443">
      Invalid Reference Numbers</a></h3>

      <h3 class="SideTOC3"><a href="#996483">
      Miscellaneous Constants</a></h3>

      <h3 class="SideTOC3"><a href="#996510">
      Open Modes</a></h3>

      <h3 class="SideTOC3"><a href="#996550">
      Seek Origins</a></h3>

      <h3 class="SideTOC3"><a href="#1138259">
      Versions of the VFS Manager API</a></h3>

      <h3 class="SideTOC3"><a href="#1135409">
      Volume Attributes</a></h3>

      <h3 class="SideTOC3"><a href="#996631">
      Volume Mount Classes</a></h3>

      <h3 class="SideTOC3"><a href="#1040677">
      Volume Format/Mount Flags</a></h3>

   <h2 class="SideTOC2"><a href="#996695">
   VFS Manager Functions</a></h2>

      <h3 class="SideTOC3"><a href="#996828">
      VFSCustomControl</a></h3>

      <h3 class="SideTOC3"><a href="#996887">
      VFSDirCreate</a></h3>

      <h3 class="SideTOC3"><a href="#996951">
      VFSDirEntryEnumerate</a></h3>

      <h3 class="SideTOC3"><a href="#997042">
      VFSExportDatabaseToFile</a></h3>

      <h3 class="SideTOC3"><a href="#1106782">
      VFSExportDatabaseToFileEx</a></h3>

      <h3 class="SideTOC3"><a href="#1108053">
      VFSFileClose</a></h3>

      <h3 class="SideTOC3"><a href="#997171">
      VFSFileCreate</a></h3>

      <h3 class="SideTOC3"><a href="#997251">
      VFSFileDelete</a></h3>

      <h3 class="SideTOC3"><a href="#997310">
      VFSFileEOF</a></h3>

      <h3 class="SideTOC3"><a href="#997357">
      VFSFileGet</a></h3>

      <h3 class="SideTOC3"><a href="#997415">
      VFSFileGetAttributes</a></h3>

      <h3 class="SideTOC3"><a href="#997471">
      VFSFileGetDate</a></h3>

      <h3 class="SideTOC3"><a href="#997531">
      VFSFileOpen</a></h3>

      <h3 class="SideTOC3"><a href="#997600">
      VFSFilePut</a></h3>

      <h3 class="SideTOC3"><a href="#997668">
      VFSFileRead</a></h3>

      <h3 class="SideTOC3"><a href="#997728">
      VFSFileRename</a></h3>

      <h3 class="SideTOC3"><a href="#997797">
      VFSFileResize</a></h3>

      <h3 class="SideTOC3"><a href="#997847">
      VFSFileSeek</a></h3>

      <h3 class="SideTOC3"><a href="#997906">
      VFSFileSetAttributes</a></h3>

      <h3 class="SideTOC3"><a href="#997966">
      VFSFileSetDate</a></h3>

      <h3 class="SideTOC3"><a href="#998028">
      VFSFileSize</a></h3>

      <h3 class="SideTOC3"><a href="#998082">
      VFSFileTell</a></h3>

      <h3 class="SideTOC3"><a href="#998133">
      VFSFileWrite</a></h3>

      <h3 class="SideTOC3"><a href="#998191">
      VFSGetAPIVersion</a></h3>

      <h3 class="SideTOC3"><a href="#998225">
      VFSGetDefaultDirectory</a></h3>

      <h3 class="SideTOC3"><a href="#998297">
      VFSImportDatabaseFromFile</a></h3>

      <h3 class="SideTOC3"><a href="#1107874">
      VFSImportDatabaseFromFileEx</a></h3>

      <h3 class="SideTOC3"><a href="#998356">
      VFSSupport</a></h3>

      <h3 class="SideTOC3"><a href="#998396">
      VFSVolumeEnumerate</a></h3>

      <h3 class="SideTOC3"><a href="#998460">
      VFSVolumeFormat</a></h3>

      <h3 class="SideTOC3"><a href="#998540">
      VFSVolumeGetLabel</a></h3>

      <h3 class="SideTOC3"><a href="#998593">
      VFSVolumeInfo</a></h3>

      <h3 class="SideTOC3"><a href="#998644">
      VFSVolumeSetLabel</a></h3>

      <h3 class="SideTOC3"><a href="#998709">
      VFSVolumeSize</a></h3>

   <h2 class="SideTOC2"><a href="#998756">
   VFS Manager Error Codes</a></h2>

</div>
</td>
<!--END SIDETOC-->

<td width="5">&nbsp;&nbsp;</td>
<td width="2" background="images/index_r8_c10.gif"><img src="images/shim.gif" width="2" height="75" border="0" alt=""></td>
<td width="5">&nbsp;&nbsp;</td>
<td valign="top">

<!--BEGIN CONTENT-->
<div id="content" valign="bottom">
<p><a name="995945"> </a>The Virtual File System (VFS) Manager is a layer of software that allows conduits to access all installed file systems on handheld expansion cards. It provides a unified API to conduit developers while allowing them to seamlessly access many different types of file systems&#8212such as VFAT, HFS, and NFS&#8212on many different types of media, including Secure Digital (SD), MultiMediaCard (MMC), CompactFlash, Sony's Memory Stick, and others.</p>

<p><a name="995946"> </a>This chapter provides reference material for the VFS Manager API as follows:</p>
   <blockquote class = "bq"><a name="995950"> </a><a href="CRef_VFSMgr.html#995992">VFS Manager Structures and Types</a></blockquote>
   <blockquote class = "bq"><a name="995954"> </a><a href="CRef_VFSMgr.html#996265">VFS Manager Constants</a></blockquote>
   <blockquote class = "bq"><a name="995958"> </a><a href="CRef_VFSMgr.html#996695">VFS Manager Functions</a></blockquote>
   <blockquote class = "bq"><a name="995962"> </a><a href="CRef_VFSMgr.html#998756">VFS Manager Error Codes</a></blockquote>

<p><a name="1020322"> </a>The VFS Manager functions are available in <code>VFSAPI.dll</code> and declared in <code>VFSMgr.h</code>. (VFS Manager error codes are declared in <code>VFSErr.h</code>.) For more information on the VFS Manager, see <a href="CComp_Expansion.html#995934">Chapter 6, "Using Expansion Technology,"</a> in the <i>C/C++ Sync Suite Companion</i>. </p>
<div class="NINoteImportant"><hr>
  <a name="995981"> </a> <b>NOTE: </b> The VFS Manager is an optional system extension on handhelds. Therefore you should check for the presence of the VFS Manager on the handheld before call any VFS Manager API functions. See <a href="CComp_Expansion.html#996251">"Verifying Handheld Compatibility"</a> in the <i>C/C++ Sync Suite Companion</i>. 
<hr>
</div>

<h2 class="haH2">
  <a name="995992"> </a>VFS Manager Structures and Types <a href="#995934"><span class="nav">^TOP^</span></a>
</h2>


<p><a name="995993"> </a>This section describes the following data structures and data types that you use with the VFS Manager API.</p>

<p class="fineprint">

<div class="tablediv"><table cellspacing="0" class="tTable">

  <tr valign="top">
    <td><p class="tt"><a name="1042441"> </a><a href="CRef_VFSMgr.html#996019"><code>FileInfoType</code></a> </p>
    </td>
    <td><p class="tt"><a name="1042471"> </a>Receives information passed back by <a href="CRef_VFSMgr.html#996951"><code>VFSDirEntryEnumerate()</code></a><span style="color: #333;;  font-style: normal; font-weight: normal; text-decoration: none; text-transform: none; vertical-align: baseline"> </span>about a file or directory.</p>
    </td>
  </tr>
  <tr valign="top">
    <td><p class="tt"><a name="1042443"> </a><a href="CRef_VFSMgr.html#996057"><code>FileOrigin</code></a> </p>
    </td>
    <td><p class="tt"><a name="1042473"> </a>Defines the new position from which to read or write with <a href="CRef_VFSMgr.html#997847"><code>VFSFileSeek()</code></a>.</p>
    </td>
  </tr>
  <tr valign="top">
    <td><p class="tt"><a name="1042445"> </a><a href="CRef_VFSMgr.html#996090"><code>FileRef</code></a> </p>
    </td>
    <td><p class="tt"><a name="1042475"> </a>Defines references to files and directories.</p>
    </td>
  </tr>
  <tr valign="top">
    <td><p class="tt"><a name="1042447"> </a><a href="CRef_VFSMgr.html#996110"><code>VFSAnyMountParamType</code></a> </p>
    </td>
    <td><p class="tt"><a name="1042477"> </a>Defines a base structure for volume mount parameters for different file systems. For slot-based file systems, use the <a href="CRef_VFSMgr.html#996156"><code>VFSSlotMountParamType</code></a> structure. </p>
    </td>
  </tr>
  <tr valign="top">
    <td><p class="tt"><a name="1042449"> </a><a href="CRef_VFSMgr.html#996156"><code>VFSSlotMountParamType</code></a> </p>
    </td>
    <td><p class="tt"><a name="1042479"> </a>Defines parameters for a card mounted in a physical slot.</p>
    </td>
  </tr>
  <tr valign="top">
    <td><p class="tt"><a name="1042451"> </a><a href="CRef_VFSMgr.html#996205"><code>VolumeInfoType</code></a> </p>
    </td>
    <td><p class="tt"><a name="1042481"> </a>Receives information that is passed back by <a href="CRef_VFSMgr.html#998593"><code>VFSVolumeInfo()</code></a> and used throughout the VFS Manager functions.</p>
    </td>
  </tr>
</table>

</div>

</p>

<h3 class="hbH3">
  <a name="996019"> </a>FileInfoType Struct <a href="#995934"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="996021"> </a>Purpose 
</h4>

<p><a name="996025"> </a>Receives information passed back by <a href="CRef_VFSMgr.html#996951"><code>VFSDirEntryEnumerate()</code></a><span style="color: #333;;  font-style: normal; font-weight: normal; text-decoration: none; text-transform: none; vertical-align: baseline"> </span>about a file or directory.</p>
<h4>
  <a name="996026"> </a>Declared In 
</h4>
<code>VFSMgr.h<a name="996027"> </a></code><h4>
  <a name="996028"> </a>Prototype 
</h4>
<pre class="proto"><a name="996029"></a>typedef struct FileInfoTag {
   UInt32 attributes;
   char *nameP;
   UInt16 nameBufLen;
} FileInfoType, *FileInfoPtr
</pre>
<h4>
  <a name="996030"> </a>Fields 
</h4>

<dl>
<dt><a name="996031"> </a><code>attributes</code></dt>
<dd><a name="996034"> </a>Characteristics of the file or directory. See <a href="CRef_VFSMgr.html#996392">"File and Directory Attributes"</a> for the bits that make up this field.</dd>

<dt><a name="996036"> </a><code>nameP</code></dt>
<dd><a name="996037"> </a>Pointer to the buffer that receives the full name of the file or directory. Allocate a sufficiently large buffer and specify its size in <code>nameBufLen</code>. </dd>

<dt><a name="996038"> </a><code>nameBufLen</code></dt>
<dd><a name="996039"> </a>Size of the <code>nameP</code> buffer, in bytes.</dd>

</dl>
<h4>
  <a name="996040"> </a>Compatibility 
</h4>

<p><a name="996041"> </a>VFS Manager version: All. <br>Palm OS version: 4.0 or later. Implemented only if the VFS Manager is present on the handheld (see <a href="CComp_Expansion.html#996231">"Checking for Expansion Cards"</a> in the <i>C/C++ Sync Suite Companion</i>). </p>
<h4>
  <a name="996051"> </a>See Also 
</h4>

<p><a name="996055"> </a><a href="CRef_VFSMgr.html#996951"><code>VFSDirEntryEnumerate()</code></a></p>

<h3 class="hbH3">
  <a name="996057"> </a>FileOrigin Typedef <a href="#995934"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="996059"> </a>Purpose 
</h4>

<p><a name="996060"> </a>Defines the new position from which to read or write with <a href="CRef_VFSMgr.html#997847"><code>VFSFileSeek()</code></a>.</p>
<h4>
  <a name="996064"> </a>Declared In 
</h4>
<code>VFSMgr.h<a name="996065"> </a></code><h4>
  <a name="996066"> </a>Prototype 
</h4>
<pre class="proto"><a name="996067"></a>typedef UInt16 FileOrigin
</pre>
<h4>
  <a name="996068"> </a>Comments 
</h4>

<p><a name="996072"> </a>See <a href="CRef_VFSMgr.html#996550">"Seek Origins"</a> for descriptions of the supported file seek origins. </p>
<h4>
  <a name="996073"> </a>Compatibility 
</h4>

<p><a name="996074"> </a>VFS Manager version: All. <br>Palm OS version: 4.0 or later. Implemented only if the VFS Manager is present on the handheld (see <a href="CComp_Expansion.html#996231">"Checking for Expansion Cards"</a> in the <i>C/C++ Sync Suite Companion</i>). </p>
<h4>
  <a name="996084"> </a>See Also 
</h4>

<p><a name="996088"> </a><a href="CRef_VFSMgr.html#997847"><code>VFSFileSeek()</code></a></p>

<h3 class="hbH3">
  <a name="996090"> </a>FileRef Typedef <a href="#995934"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="996092"> </a>Purpose 
</h4>

<p><a name="996093"> </a>Defines references to files and directories.</p>
<h4>
  <a name="996094"> </a>Declared In 
</h4>
<code>VFSMgr.h<a name="996095"> </a></code><h4>
  <a name="996096"> </a>Prototype 
</h4>
<pre class="proto"><a name="996097"></a>typedef UInt32 FileRef
</pre>
<h4>
  <a name="996098"> </a>Compatibility 
</h4>

<p><a name="996099"> </a>VFS Manager version: All. <br>Palm OS version: 4.0 or later. Implemented only if the VFS Manager is present on the handheld (see <a href="CComp_Expansion.html#996231">"Checking for Expansion Cards"</a> in the <i>C/C++ Sync Suite Companion</i>). </p>

<h3 class="hbH3">
  <a name="996110"> </a>VFSAnyMountParamType Struct <a href="#995934"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="996112"> </a>Purpose 
</h4>

<p><a name="996113"> </a>Defines a base structure for volume mount parameters for different file systems. For slot-based file systems, use the <a href="CRef_VFSMgr.html#996156"><code>VFSSlotMountParamType</code></a> structure. </p>
<h4>
  <a name="996117"> </a>Declared In 
</h4>
<code>VFSMgr.h<a name="996118"> </a></code><h4>
  <a name="996119"> </a>Prototype 
</h4>
<pre class="proto"><a name="996120"></a>typedef struct VFSAnyMountParamTag {
   UInt16 volRefNum;
   UInt16 reserved;
   UInt32 mountClass;
} VFSAnyMountParamType
</pre>
<pre class="proto"><a name="996122"></a>typedef VFSAnyMountParamType *VFSAnyMountParamPtr
</pre>
<h4>
  <a name="996123"> </a>Fields 
</h4>

<dl>
<dt><a name="996124"> </a><code>volRefNum</code></dt>
<dd><a name="996125"> </a>The volume reference number. This is initially obtained when you call <a href="CRef_VFSMgr.html#998396"><code>VFSVolumeEnumerate()</code></a> to successfully enumerate volumes. </dd>

<dt><a name="996129"> </a><code>reserved</code></dt>
<dd><a name="996130"> </a>Reserved for future use.</dd>

<dt><a name="996131"> </a><code>mountClass</code></dt>
<dd><a name="996132"> </a>Defines the type of mount to use with the specified volume. See <a href="CRef_VFSMgr.html#996631">"Volume Mount Classes"</a> for a list of mount types.</dd>

</dl>
<h4>
  <a name="996136"> </a>Compatibility 
</h4>

<p><a name="996137"> </a>VFS Manager version: All. <br>Palm OS version: 4.0 or later. Implemented only if the VFS Manager is present on the handheld (see <a href="CComp_Expansion.html#996231">"Checking for Expansion Cards"</a> in the <i>C/C++ Sync Suite Companion</i>). </p>
<h4>
  <a name="996147"> </a>See Also 
</h4>

<p><a name="996154"> </a><a href="CRef_VFSMgr.html#998396"><code>VFSVolumeEnumerate()</code></a>, <a href="CRef_VFSMgr.html#996156"><code>VFSSlotMountParamType</code></a></p>

<h3 class="hbH3">
  <a name="996156"> </a>VFSSlotMountParamType Struct <a href="#995934"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="996158"> </a>Purpose 
</h4>

<p><a name="996159"> </a>Defines parameters for a card mounted in a physical slot.</p>
<h4>
  <a name="996160"> </a>Declared In 
</h4>
<code>VFSMgr.h<a name="996161"> </a></code><h4>
  <a name="996162"> </a>Prototype 
</h4>
<pre class="proto"><a name="996163"></a>typedef struct VFSSlotMountParamTag {
   VFSAnyMountParamType vfsMountParam;
   UInt16 slotLibRefNum;
   UInt16 slotRefNum;
} VFSSlotMountParamType
</pre>
<h4>
  <a name="996164"> </a>Fields 
</h4>

<dl>
<dt><a name="996165"> </a><code>vfsMountParam</code></dt>
<dd><a name="996169"> </a>See the description of <a href="CRef_VFSMgr.html#996110"><code>VFSAnyMountParamType</code></a> for an explanation of the fields in this structure. This is passed back in the <a href="CRef_VFSMgr.html#996205"><code>VolumeInfoType</code></a> structure in a call to <a href="CRef_VFSMgr.html#998593"><code>VFSVolumeInfo()</code></a>. Set <code>vfsMountParam-&gt;mountClass</code> to <code>VFSMountClass_SlotDriver</code> to mount a physical slot.</dd>

<dt><a name="996176"> </a><code>slotLibRefNum</code></dt>
<dd><a name="996177"> </a>Reference number for the slot driver library allocated to the given slot number. If this value is not available, set this field to <code>vfsInvalidSlotLibRefNum</code>. </dd>

<dt><a name="996178"> </a><code>slotRefNum</code></dt>
<dd><a name="996179"> </a>The slot reference number obtained by the Expansion Manager's <a href="CRef_ExpMgr.html#996309"><code>ExpSlotEnumerate()</code></a> function.</dd>

</dl>
<h4>
  <a name="996183"> </a>Comments 
</h4>

<p><a name="996184"> </a>The <code>VFSSlotMountParamType</code> structure is used when you are mounting a volumn on a card located in a physical slot. Conduits rely on Palm OS to mount volumns, so they use this structure only as a parameter of <a href="CRef_VFSMgr.html#998460"><code>VFSVolumeFormat()</code></a>, which can mount a volumn after a conduit formats it. The <code>vfsMountParam-&gt;mountClass</code> field must be set to <code>VFSMountClass_SlotDriver</code>.</p>
<h4>
  <a name="996188"> </a>Compatibility 
</h4>

<p><a name="996189"> </a>VFS Manager version: All. <br>Palm OS version: 4.0 or later. Implemented only if the VFS Manager is present on the handheld (see <a href="CComp_Expansion.html#996231">"Checking for Expansion Cards"</a> in the <i>C/C++ Sync Suite Companion</i>). </p>
<h4>
  <a name="996199"> </a>See Also 
</h4>

<p><a name="996203"> </a><a href="CRef_VFSMgr.html#998460"><code>VFSVolumeFormat()</code></a></p>

<h3 class="hbH3">
  <a name="996205"> </a>VolumeInfoType Struct <a href="#995934"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="996207"> </a>Purpose 
</h4>

<p><a name="996211"> </a>Receives information that is passed back by <a href="CRef_VFSMgr.html#998593"><code>VFSVolumeInfo()</code></a> and used throughout the VFS Manager functions.</p>
<h4>
  <a name="996212"> </a>Declared In 
</h4>
<code>VFSMgr.h<a name="996213"> </a></code><h4>
  <a name="996214"> </a>Prototype 
</h4>
<pre class="proto"><a name="996215"></a>typedef struct VolumeInfoTag {
   UInt32 attributes;
   UInt32 fsType;
   UInt32 fsCreator;
   UInt32 mountClass;
   UInt16 slotLibRefNum;
   UInt16 slotRefNum;
   UInt32 mediaType;
   UInt32 reserved;
} VolumeInfoType, *VolumeInfoPtr
</pre>
<h4>
  <a name="996216"> </a>Fields 
</h4>

<dl>
<dt><a name="996217"> </a><code>attributes</code></dt>
<dd><a name="996220"> </a>Characteristics of the volume. See <a href="CRef_VFSMgr.html#1135409">"Volume Attributes"</a> for the bits that make up this field.</dd>

<dt><a name="996222"> </a><code>fsType</code></dt>
<dd><a name="996225"> </a>File system type for this volume. See <a href="CRef_VFSMgr.html#996342">"Defined File Systems"</a> for a list of the supported file systems.</dd>

<dt><a name="996227"> </a><code>fsCreator</code></dt>
<dd><a name="996228"> </a>Creator code of this volume's file system driver. This information is used with <a href="CRef_VFSMgr.html#996828"><code>VFSCustomControl()</code></a>.</dd>

<dt><a name="996232"> </a><code>mountClass</code></dt>
<dd><a name="996233"> </a>Mount class of the driver that mounted this volume. The supported mount classes are listed under <a href="CRef_VFSMgr.html#996631">"Volume Mount Classes."</a></dd>

<dt><a name="996237"> </a><code>slotLibRefNum</code></dt>
<dd><a name="996238"> </a>Reference to the slot driver library with which the volume is mounted. This field is valid only when the <code>mountClass</code> is <code>vfsMountClass_SlotDriver</code>.</dd>

<dt><a name="996239"> </a><code>slotRefNum</code></dt>
<dd><a name="996240"> </a>Expansion Manager slot reference number where the card containing the volume is loaded. This field is valid only when the <code>mountClass</code> is <code>vfsMountClass_SlotDriver</code>.</dd>

<dt><a name="996241"> </a><code>mediaType</code></dt>
<dd><a name="996244"> </a>Type of card media. See <a href="CRef_ExpMgr.html#1005543">"Media Type Constants"</a> for the list of values.</dd>

<dt><a name="996246"> </a><code>reserved</code></dt>
<dd><a name="996247"> </a>Reserved for future use.</dd>

</dl>
<h4>
  <a name="996248"> </a>Compatibility 
</h4>

<p><a name="996249"> </a>VFS Manager version: All. <br>Palm OS version: 4.0 or later. Implemented only if the VFS Manager is present on the handheld (see <a href="CComp_Expansion.html#996231">"Checking for Expansion Cards"</a> in the <i>C/C++ Sync Suite Companion</i>). </p>
<h4>
  <a name="996259"> </a>See Also 
</h4>

<p><a name="996263"> </a><a href="CRef_VFSMgr.html#998593"><code>VFSVolumeInfo()</code></a></p>

<h2 class="haH2">
  <a name="996265"> </a>VFS Manager Constants <a href="#995934"><span class="nav">^TOP^</span></a>
</h2>


<p><a name="996266"> </a>This section describes the following groups of preprocessor constants that you use with the VFS Manager API.</p>

<p class="fineprint">

<div class="tablediv"><table cellspacing="0" class="tTable">

  <tr valign="top">
    <td><p class="tt"><a name="1042805"> </a><a href="CRef_VFSMgr.html#996304">Date Types</a> </p>
    </td>
    <td><p class="tt"><a name="1042959"> </a>Define the types of dates a conduit can specify with the <a href="CRef_VFSMgr.html#997471"><code>VFSFileGetDate()</code></a> and <a href="CRef_VFSMgr.html#997966"><code>VFSFileSetDate()</code></a> functions.</p>
    </td>
  </tr>
  <tr valign="top">
    <td><p class="tt"><a name="1042807"> </a><a href="CRef_VFSMgr.html#996342">Defined File Systems</a> </p>
    </td>
    <td><p class="tt"><a name="1042961"> </a>Define the file systems currently defined by the VFS Manager. These values are used with <a href="CRef_VFSMgr.html#998593"><code>VFSVolumeInfo()</code></a> in the <span style="color: #333;;  font-style: normal; font-weight: normal; text-decoration: none; text-transform: none; vertical-align: baseline">VolumeInfoType.fsType</span> parameter.</p>
    </td>
  </tr>
  <tr valign="top">
    <td><p class="tt"><a name="1042809"> </a><a href="CRef_VFSMgr.html#996392">File and Directory Attributes</a> </p>
    </td>
    <td><p class="tt"><a name="1042963"> </a>Indicate the attributes of a file or directory.</p>
    </td>
  </tr>
  <tr valign="top">
    <td><p class="tt"><a name="1042811"> </a><a href="CRef_VFSMgr.html#996443">Invalid Reference Numbers</a> </p>
    </td>
    <td><p class="tt"><a name="1042965"> </a>Define placeholders that a caller should use when the it does not have a valid file, slot library, or volume reference number to use.</p>
    </td>
  </tr>
  <tr valign="top">
    <td><p class="tt"><a name="1042813"> </a><a href="CRef_VFSMgr.html#996483">Miscellaneous Constants</a> </p>
    </td>
    <td><p class="tt"><a name="1042967"> </a>Define miscellaneous constants for the VFS Manager API.</p>
    </td>
  </tr>
  <tr valign="top">
    <td><p class="tt"><a name="1042815"> </a><a href="CRef_VFSMgr.html#996510">Open Modes</a> </p>
    </td>
    <td><p class="tt"><a name="1042969"> </a>Define the modes in which a file or directory is opened.</p>
    </td>
  </tr>
  <tr valign="top">
    <td><p class="tt"><a name="1042817"> </a><a href="CRef_VFSMgr.html#996550">Seek Origins</a> </p>
    </td>
    <td><p class="tt"><a name="1042971"> </a>Define file positions to which an offset is added (or subtracted, if the offset is negative) to get a seek position within a file when using <a href="CRef_VFSMgr.html#997847"><code>VFSFileSeek()</code></a>.</p>
    </td>
  </tr>
  <tr valign="top">
    <td><p class="tt"><a name="1112844"> </a><a href="CRef_VFSMgr.html#1138259">Versions of the VFS Manager API</a></p>
    </td>
    <td><p class="tt"><a name="1112846"> </a>Define the major and minor version numbers of the VFS Manager API returned by <code>VFSGetAPIVersion()</code>. </p>
    </td>
  </tr>
  <tr valign="top">
    <td><p class="tt"><a name="1042819"> </a><a href="CRef_VFSMgr.html#1135409">Volume Attributes</a> </p>
    </td>
    <td><p class="tt"><a name="1042973"> </a>Indicate the attributes of a volume.</p>
    </td>
  </tr>
  <tr valign="top">
    <td><p class="tt"><a name="1042821"> </a><a href="CRef_VFSMgr.html#996631">Volume Mount Classes</a> </p>
    </td>
    <td><p class="tt"><a name="1042975"> </a>Define how a given volume is mounted. </p>
    </td>
  </tr>
</table>

</div>

</p>

<h3 class="hbH3">
  <a name="996304"> </a>Date Types <a href="#995934"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="996305"> </a>Purpose 
</h4>

<p><a name="996306"> </a>Define the types of dates a conduit can specify with the <a href="CRef_VFSMgr.html#997471"><code>VFSFileGetDate()</code></a> and <a href="CRef_VFSMgr.html#997966"><code>VFSFileSetDate()</code></a> functions.</p>
<h4>
  <a name="996313"> </a>Declared In 
</h4>
<code>VFSMgr.h<a name="996314"> </a></code><h4>
  <a name="996315"> </a>Constants 
</h4>

<dl>
<dt><a name="996316"> </a><code>#define vfsFileDateAccessed 3</code></dt>
<dd><a name="996317"> </a>Date the file was last accessed.</dd>

<dt><a name="996318"> </a><code>#define vfsFileDateCreated 1</code></dt>
<dd><a name="996319"> </a>File creation date.</dd>

<dt><a name="996320"> </a><code>#define vfsFileDateModified 2</code></dt>
<dd><a name="996321"> </a>Date the file was last modified.</dd>

</dl>
<h4>
  <a name="996322"> </a>Compatibility 
</h4>

<p><a name="996323"> </a>VFS Manager version: All. <br>Palm OS version: 4.0 or later. Implemented only if the VFS Manager is present on the handheld (see <a href="CComp_Expansion.html#996231">"Checking for Expansion Cards"</a> in the <i>C/C++ Sync Suite Companion</i>). </p>
<h4>
  <a name="996333"> </a>See Also 
</h4>

<p><a name="996340"> </a><a href="CRef_VFSMgr.html#997471"><code>VFSFileGetDate()</code></a>, <a href="CRef_VFSMgr.html#997966"><code>VFSFileSetDate()</code></a></p>

<h3 class="hbH3">
  <a name="996342"> </a>Defined File Systems <a href="#995934"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="996343"> </a>Purpose 
</h4>

<p><a name="996344"> </a>Define the file systems currently defined by the VFS Manager. These values are used with <a href="CRef_VFSMgr.html#998593"><code>VFSVolumeInfo()</code></a> in the <span style="color: #333;;  font-style: normal; font-weight: normal; text-decoration: none; text-transform: none; vertical-align: baseline">VolumeInfoType.fsType</span> parameter.</p>
<h4>
  <a name="996348"> </a>Declared In 
</h4>
<code>VFSMgr.h<a name="996349"> </a></code><h4>
  <a name="996350"> </a>Constants 
</h4>

<dl>
<dt><a name="996351"> </a><code>#define fsFilesystemType_AFS 'afsu'</code></dt>
<dd><a name="996352"> </a>Unix Andrew file system.</dd>

<dt><a name="996353"> </a><code>#define fsFilesystemType_EXT2 'ext2'</code></dt>
<dd><a name="996354"> </a>Linux file system.</dd>

<dt><a name="996355"> </a><code>#define fsFilesystemType_FAT 'fats'</code></dt>
<dd><a name="996356"> </a>FAT12 and FAT16, which handles only 8.3 filenames.</dd>

<dt><a name="996357"> </a><code>#define fsFilesystemType_FFS 'ffsb'</code></dt>
<dd><a name="996358"> </a>Unix Berkeley block based file system.</dd>

<dt><a name="996359"> </a><code>#define fsFilesystemType_HFS 'hfss'</code></dt>
<dd><a name="996360"> </a>Macintosh standard hierarchical file system.</dd>

<dt><a name="996361"> </a><code>#define fsFilesystemType_HFSPlus 'hfse'</code></dt>
<dd><a name="996362"> </a>Macintosh extended hierarchical file system.</dd>

<dt><a name="996363"> </a><code>#define fsFilesystemType_HPFS 'hpfs'</code></dt>
<dd><a name="996364"> </a>OS/2 High Performance file system</dd>

<dt><a name="996365"> </a><code>#define fsFilesystemType_MFS 'mfso'</code></dt>
<dd><a name="996366"> </a>Macintosh original file system.</dd>

<dt><a name="996367"> </a><code>#define fsFilesystemType_NFS 'nfsu'</code></dt>
<dd><a name="996368"> </a>Unix Networked file system.</dd>

<dt><a name="996369"> </a><code>#define fsFilesystemType_Novell 'novl'</code></dt>
<dd><a name="996370"> </a>Novell file system.</dd>

<dt><a name="996371"> </a><code>#define fsFilesystemType_NTFS 'ntfs'</code></dt>
<dd><a name="996372"> </a>Windows NT file system.</dd>

<dt><a name="996373"> </a><code>#define fsFilesystemType_VFAT 'vfat'</code></dt>
<dd><a name="996374"> </a>FAT12 and FAT16, extended to handle long filenames.</dd>

</dl>
<h4>
  <a name="996375"> </a>Compatibility 
</h4>

<p><a name="996376"> </a>VFS Manager version: All. <br>Palm OS version: 4.0 or later. Implemented only if the VFS Manager is present on the handheld (see <a href="CComp_Expansion.html#996231">"Checking for Expansion Cards"</a> in the <i>C/C++ Sync Suite Companion</i>). </p>
<h4>
  <a name="996386"> </a>See Also 
</h4>

<p><a name="996390"> </a><a href="CRef_VFSMgr.html#998593"><code>VFSVolumeInfo()</code></a></p>

<h3 class="hbH3">
  <a name="996392"> </a>File and Directory Attributes <a href="#995934"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="996393"> </a>Purpose 
</h4>

<p><a name="996394"> </a>Indicate the attributes of a file or directory.</p>
<h4>
  <a name="996395"> </a>Declared In 
</h4>
<code>VFSMgr.h<a name="996396"> </a></code><h4>
  <a name="996397"> </a>Constants 
</h4>

<dl>
<dt><a name="996398"> </a><code>#define vfsFileAttrArchive (0x00000020UL)</code></dt>
<dd><a name="996399"> </a>Archived file or directory.</dd>

<dt><a name="996400"> </a><code>#define vfsFileAttrDirectory (0x00000010UL)</code></dt>
<dd><a name="996401"> </a>A directory, not a file.</dd>

<dt><a name="996402"> </a><code>#define vfsFileAttrHidden (0x00000002UL)</code></dt>
<dd><a name="996403"> </a>Hidden file or directory.</dd>

<dt><a name="996404"> </a><code>#define vfsFileAttrLink (0x00000040UL)</code></dt>
<dd><a name="996405"> </a>Link to another file or directory.</dd>

<dt><a name="996406"> </a><code>#define vfsFileAttrReadOnly (0x00000001UL)</code></dt>
<dd><a name="996407"> </a>Read-only file or directory.</dd>

<dt><a name="996408"> </a><code>#define vfsFileAttrSystem (0x00000004UL)</code></dt>
<dd><a name="996409"> </a>System file or directory.</dd>

<dt><a name="996410"> </a><code>#define vfsFileAttrVolumeLabel (0x00000008UL)</code></dt>
<dd><a name="996411"> </a>Volume label.</dd>

</dl>
<h4>
  <a name="996412"> </a>Comments 
</h4>

<p><a name="996413"> </a>Use these attributes individually or in combination when setting or interpreting the file attributes for a given file or directory. See <a href="CRef_VFSMgr.html#997415"><code>VFSFileGetAttributes()</code></a>, <a href="CRef_VFSMgr.html#997906"><code>VFSFileSetAttributes()</code></a>, and the <a href="CRef_VFSMgr.html#996019"><code>FileInfoType</code></a> data structure for specific use.</p>
<h4>
  <a name="996423"> </a>Compatibility 
</h4>

<p><a name="996424"> </a>VFS Manager version: All. <br>Palm OS version: 4.0 or later. Implemented only if the VFS Manager is present on the handheld (see <a href="CComp_Expansion.html#996231">"Checking for Expansion Cards"</a> in the <i>C/C++ Sync Suite Companion</i>). </p>
<h4>
  <a name="996434"> </a>See Also 
</h4>

<p><a name="996441"> </a><a href="CRef_VFSMgr.html#997415"><code>VFSFileGetAttributes()</code></a>, <a href="CRef_VFSMgr.html#997906"><code>VFSFileSetAttributes()</code></a></p>

<h3 class="hbH3">
  <a name="996443"> </a>Invalid Reference Numbers <a href="#995934"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="996444"> </a>Purpose 
</h4>

<p><a name="996445"> </a>Define placeholders that a caller should use when the it does not have a valid file, slot library, or volume reference number to use.</p>
<h4>
  <a name="996446"> </a>Declared In 
</h4>
<code>VFSMgr.h<a name="996447"> </a></code><h4>
  <a name="996448"> </a>Constants 
</h4>

<dl>
<dt><a name="996449"> </a><code>#define vfsInvalidFileRef 0</code></dt>
<dd><a name="996450"> </a>The file reference number is invalid.</dd>

<dt><a name="996451"> </a><code>#define vfsInvalidSlotLibRefNum (-1)</code></dt>
<dd><a name="996452"> </a>The slot library reference number is not available. See the description of the <a href="CRef_VFSMgr.html#996156"><code>VFSSlotMountParamType</code></a> structure. </dd>

<dt><a name="996456"> </a><code>#define vfsInvalidVolRef 0</code></dt>
<dd><a name="996457"> </a>The volume has not been formatted. See the description of <a href="CRef_VFSMgr.html#998460"><code>VFSVolumeFormat()</code></a>. </dd>

</dl>
<h4>
  <a name="996461"> </a>Comments 
</h4>

<p><a name="996462"> </a>These placeholder values are guaranteed not to represent a valid reference number. Use them like you would use <code>NULL</code> for a file ponter. </p>
<h4>
  <a name="996463"> </a>Compatibility 
</h4>

<p><a name="996464"> </a>VFS Manager version: All. <br>Palm OS version: 4.0 or later. Implemented only if the VFS Manager is present on the handheld (see <a href="CComp_Expansion.html#996231">"Checking for Expansion Cards"</a> in the <i>C/C++ Sync Suite Companion</i>). </p>
<h4>
  <a name="996474"> </a>See Also 
</h4>

<p><a name="996481"> </a><a href="CRef_VFSMgr.html#996156"><code>VFSSlotMountParamType</code></a>, <a href="CRef_VFSMgr.html#998460"><code>VFSVolumeFormat()</code></a></p>

<h3 class="hbH3">
  <a name="996483"> </a>Miscellaneous Constants <a href="#995934"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="996484"> </a>Purpose 
</h4>

<p><a name="996485"> </a>Define miscellaneous constants for the VFS Manager API.</p>
<h4>
  <a name="996486"> </a>Declared In 
</h4>
<code>VFSMgr.h<a name="996487"> </a></code><h4>
  <a name="996488"> </a>Constants 
</h4>

<dl>
<dt><a name="996499"> </a><code>#define sysFileCVFSMgr 'vfsm'</code></dt>
<dd><a name="996500"> </a>Defines the creator ID for the VFS Manager in the device's ROM. You can use this with <a href="CRef_SyncCommon.html#1072017"><code>SyncReadFeature()</code></a> to get the version number of the VFS Manager. However, the preferred way to get the version number is to call <a href="CRef_VFSMgr.html#998356"><code>VFSSupport()</code></a>.</dd>

<dt><a name="996507"> </a><code>#define vfsFtrIDVersion 0</code></dt>
<dd><a name="996508"> </a>Feature number used to obtain the version of the VFS Manager in the device's ROM. Use this number in conjunction with a creator ID of <code>sysFileCVFSMgr</code>.</dd>

</dl>

<h3 class="hbH3">
  <a name="996510"> </a>Open Modes <a href="#995934"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="996511"> </a>Purpose 
</h4>

<p><a name="996512"> </a>Define the modes in which a file or directory is opened.</p>
<h4>
  <a name="996513"> </a>Declared In 
</h4>
<code>VFSMgr.h<a name="996514"> </a></code><h4>
  <a name="996515"> </a>Constants 
</h4>

<dl>
<dt><a name="996516"> </a><code>#define vfsModeCreate (0x0008UL)</code></dt>
<dd><a name="996517"> </a>Create the file if it doesn't already exist. </dd>

<dt><a name="996518"> </a><code>#define vfsModeExclusive (0x0001UL)</code></dt>
<dd><a name="996519"> </a>Open and lock the file or directory. This mode excludes anyone else from using the file or directory until it is closed.</dd>

<dt><a name="996520"> </a><code>#define vfsModeRead (0x0002UL)</code></dt>
<dd><a name="996521"> </a>Open for read access.</dd>

<dt><a name="996522"> </a><code>#define vfsModeReadWrite (vfsModeWrite | vfsModeRead)</code></dt>
<dd><a name="996523"> </a>Open for read/write access.</dd>

<dt><a name="996524"> </a><code>#define vfsModeTruncate (0x0010UL)</code></dt>
<dd><a name="996525"> </a>Truncate the file to zero bytes after opening, removing all existing data. </dd>

<dt><a name="996526"> </a><code>#define vfsModeWrite (0x0004UL | vfsModeExclusive)</code></dt>
<dd><a name="996527"> </a>Open for exclusive write access. This mode excludes anyone else from using the file or directory until it is closed. </dd>

</dl>
<h4>
  <a name="996528"> </a>Comments 
</h4>

<p><a name="996529"> </a>Specify one of these values in the <code class="par">openMode</code> parameter of <a href="CRef_VFSMgr.html#997531"><code>VFSFileOpen()</code></a>.</p>
<h4>
  <a name="996533"> </a>Compatibility 
</h4>

<p><a name="996534"> </a>VFS Manager version: All. <br>Palm OS version: 4.0 or later. Implemented only if the VFS Manager is present on the handheld (see <a href="CComp_Expansion.html#996231">"Checking for Expansion Cards"</a> in the <i>C/C++ Sync Suite Companion</i>). </p>
<h4>
  <a name="996544"> </a>See Also 
</h4>

<p><a name="996548"> </a><a href="CRef_VFSMgr.html#997531"><code>VFSFileOpen()</code></a></p>

<h3 class="hbH3">
  <a name="996550"> </a>Seek Origins <a href="#995934"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="996551"> </a>Purpose 
</h4>

<p><a name="996552"> </a>Define file positions to which an offset is added (or subtracted, if the offset is negative) to get a seek position within a file when using <a href="CRef_VFSMgr.html#997847"><code>VFSFileSeek()</code></a>.</p>
<h4>
  <a name="996556"> </a>Declared In 
</h4>
<code>VFSMgr.h<a name="996557"> </a></code><h4>
  <a name="996558"> </a>Constants 
</h4>

<dl>
<dt><a name="996559"> </a><code>#define fsOriginBeginning 0</code></dt>
<dd><a name="996560"> </a>From the beginning (first data byte of file).</dd>

<dt><a name="996561"> </a><code>#define fsOriginCurrent 1</code></dt>
<dd><a name="996562"> </a>From the current position.</dd>

<dt><a name="996563"> </a><code>#define fsOriginEnd 2</code></dt>
<dd><a name="996564"> </a>From the end of the file (one position beyond the last data byte). Only negative offsets are legal from this origin.</dd>

</dl>
<h4>
  <a name="996565"> </a>Compatibility 
</h4>

<p><a name="996566"> </a>VFS Manager version: All. <br>Palm OS version: 4.0 or later. Implemented only if the VFS Manager is present on the handheld (see <a href="CComp_Expansion.html#996231">"Checking for Expansion Cards"</a> in the <i>C/C++ Sync Suite Companion</i>). </p>
<h4>
  <a name="996576"> </a>See Also 
</h4>

<p><a name="1138256"> </a><a href="CRef_VFSMgr.html#997847"><code>VFSFileSeek()</code></a></p>

<h3 class="hbH3">
  <a name="1138259"> </a>Versions of the VFS Manager API <a href="#995934"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="1138260"> </a>Purpose 
</h4>

<p><a name="1112253"> </a>Define the major and minor version numbers of the VFS Manager API returned by <a href="CRef_VFSMgr.html#998191"><code>VFSGetAPIVersion()</code></a>. </p>
<h4>
  <a name="1112254"> </a>Declared In 
</h4>
<code>VFSMgr.h<a name="1112255"> </a></code><h4>
  <a name="1112256"> </a>Constants 
</h4>

<dl>
<dt><a name="1112258"> </a><code>#define VFSAPI_VER_MAJOR_1 1</code></dt>
<dd><a name="1112259"> </a>Indicates the major version number is 1.</dd>

<dt><a name="1112264"> </a><code>#define VFSAPI_VER_MINOR_0 0</code></dt>
<dd><a name="1112265"> </a>Indicates the minor version number is 0.</dd>

<dt><a name="1112270"> </a><code>#define VFSAPI_VER_MINOR_1 1</code></dt>
<dd><a name="1135406"> </a>Indicates the minor version number is 1.</dd>

</dl>

<h3 class="hbH3">
  <a name="1135409"> </a>Volume Attributes <a href="#995934"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="1135410"> </a>Purpose 
</h4>

<p><a name="996584"> </a>Indicate the attributes of a volume.</p>
<h4>
  <a name="996585"> </a>Declared In 
</h4>
<code>VFSMgr.h<a name="996586"> </a></code><h4>
  <a name="996587"> </a>Constants 
</h4>

<dl>
<dt><a name="996588"> </a><code>#define vfsVolumeAttrHidden (0x00000002UL)</code></dt>
<dd><a name="996589"> </a>The volume should not be visible to the user. For more information, see <a href="CComp_Expansion.html#996507">"Hidden Volumes"</a> in the <i>C/C++ Sync Suite Companion</i>.</dd>

<dt><a name="996599"> </a><code>#define vfsVolumeAttrReadOnly (0x00000002UL)</code></dt>
<dd><a name="996600"> </a>The volume is read only.</dd>

<dt><a name="996601"> </a><code>#define vfsVolumeAttrSlotBased (0x00000001UL)</code></dt>
<dd><a name="996602"> </a>The volume is associated with a slot driver as opposed to the Palm OS<sup>&#174;</sup> Emulator. </dd>

</dl>
<h4>
  <a name="996603"> </a>Comments 
</h4>

<p><a name="996604"> </a>Use these attributes individually or in combination when interpreting the attributes field of a <a href="CRef_VFSMgr.html#996205"><code>VolumeInfoType</code></a> structure passed back by <a href="CRef_VFSMgr.html#998593"><code>VFSVolumeInfo()</code></a>. </p>
<h4>
  <a name="996611"> </a>Compatibility 
</h4>

<p><a name="996612"> </a>VFS Manager version: All. <br>Palm OS version: 4.0 or later. Implemented only if the VFS Manager is present on the handheld (see <a href="CComp_Expansion.html#996231">"Checking for Expansion Cards"</a> in the <i>C/C++ Sync Suite Companion</i>). </p>
<h4>
  <a name="996622"> </a>See Also 
</h4>

<p><a name="996629"> </a><a href="CRef_VFSMgr.html#998593"><code>VFSVolumeInfo()</code></a>, <a href="CRef_VFSMgr.html#996205"><code>VolumeInfoType</code></a></p>

<h3 class="hbH3">
  <a name="996631"> </a>Volume Mount Classes <a href="#995934"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="996632"> </a>Purpose 
</h4>

<p><a name="996633"> </a>Define how a given volume is mounted. </p>
<h4>
  <a name="996634"> </a>Declared In 
</h4>
<code>VFSMgr.h<a name="996635"> </a></code><h4>
  <a name="996636"> </a>Constants 
</h4>

<dl>
<dt><a name="996639"> </a><code>#define vfsMountClass_Simulator sysFileTSimulator</code></dt>
<dd><a name="996640"> </a>Mount the volume through the 68K Palm Simulator. This is used for testing.</dd>

<dt><a name="996641"> </a><code>#define vfsMountClass_SlotDriver sysFileTSlotDriver</code></dt>
<dd><a name="996642"> </a>Mount the volume with a slot driver shared library.</dd>

<dt><a name="996643"> </a><code>#define sysFileTSimulator '\?\?\?\?'</code></dt>
<dd><a name="996644"> </a>File type for 68K Palm Simulator files (<code>app.tres</code>, <code>sys.tres</code>). <code>vfsMountClass_Simulator</code> is defined as this value.</dd>

<dt><a name="996645"> </a><code>#define sysFileTSlotDriver 'libs'</code></dt>
<dd><a name="996646"> </a>File type for slot driver libraries. <code>vfsMountClass_SlotDriver</code> is defined as this value.</dd>

</dl>
<h4>
  <a name="996647"> </a>Comments 
</h4>

<p><a name="996651"> </a>The <code>mountClass</code> fields in the <a href="CRef_VFSMgr.html#996110"><code>VFSAnyMountParamType</code></a> and <a href="CRef_VFSMgr.html#996205"><code>VolumeInfoType</code></a> structures take one of the <code>vfsMount...</code> values, two of which are defined as the <code>sysFileT...</code> values also listed above.</p>
<h4>
  <a name="996655"> </a>Compatibility 
</h4>

<p><a name="996656"> </a>VFS Manager version: All. <br>Palm OS version: 4.0 or later. Implemented only if the VFS Manager is present on the handheld (see <a href="CComp_Expansion.html#996231">"Checking for Expansion Cards"</a> in the <i>C/C++ Sync Suite Companion</i>). </p>
<h4>
  <a name="996666"> </a>See Also 
</h4>

<p><a name="996673"> </a><a href="CRef_VFSMgr.html#996110"><code>VFSAnyMountParamType</code></a>, <a href="CRef_VFSMgr.html#996205"><code>VolumeInfoType</code></a></p>

<h3 class="hbH3">
  <a name="1040677"> </a>Volume Format/Mount Flags <a href="#995934"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="1040678"> </a>Purpose 
</h4>

<p><a name="1042108"> </a>Flags that control how a volume is mounted after formatting.</p>
<h4>
  <a name="1040680"> </a>Declared In 
</h4>
<code>VFSMgr.h<a name="1040681"> </a></code><h4>
  <a name="1040682"> </a>Constants 
</h4>

<dl>
<dt><a name="1040687"> </a><code>#define vfsMountFlagsReserved1 0x08</code></dt>
<dd><a name="1042118"> </a>Reserved for future use.</dd>

<dt><a name="1040693"> </a><code>#define vfsMountFlagsReserved2 0x10</code></dt>
<dd><a name="1042122"> </a>Reserved for future use.</dd>

<dt><a name="1040699"> </a><code>#define vfsMountFlagsReserved3 0x20</code></dt>
<dd><a name="1042126"> </a>Reserved for future use.</dd>

<dt><a name="1040705"> </a><code>#define vfsMountFlagsReserved4 0x40</code></dt>
<dd><a name="1042130"> </a>Reserved for future use.</dd>

<dt><a name="1040711"> </a><code>#define vfsMountFlagsReserved5 0x80</code></dt>
<dd><a name="1042134"> </a>Reserved for future use.</dd>

<dt><a name="1040717"> </a><code>#define vfsMountFlagsUseThisFileSystem 0x01</code></dt>
<dd><a name="1042138"> </a>Pass this flag to cause the volume to be mounted or formatted using the file system specified by the specified file system.</dd>

</dl>
<h4>
  <a name="1040719"> </a>Comments 
</h4>

<p><a name="1042145"> </a>Volumes are mounted as part of the volume format process using <a href="CRef_VFSMgr.html#998460"><code>VFSVolumeFormat()</code></a>.</p>

<p><a name="1042149"> </a>Pass no flags (0) to have the VFS Manager attempt to mount or format the volume using a file system appropriate to the slot.</p>

<h2 class="haH2">
  <a name="996695"> </a>VFS Manager Functions <a href="#995934"><span class="nav">^TOP^</span></a>
</h2>


<p><a name="996696"> </a>This section describes the following functions, which enable conduits to access file systems on expansion cards.</p>

<p class="fineprint">

<div class="tablediv"><table cellspacing="0" class="tTable">

  <tr valign="top">
    <td><p class="tt"><a name="1043106"> </a><a href="CRef_VFSMgr.html#996828"><code>VFSCustomControl()</code></a> </p>
    </td>
    <td><p class="tt"><a name="1043339"> </a>Makes a custom API call to a particular file system driver, given the driver's creator ID.</p>
    </td>
  </tr>
  <tr valign="top">
    <td><p class="tt"><a name="1043108"> </a><a href="CRef_VFSMgr.html#996887"><code>VFSDirCreate()</code></a> </p>
    </td>
    <td><p class="tt"><a name="1043341"> </a>Creates a new directory.</p>
    </td>
  </tr>
  <tr valign="top">
    <td><p class="tt"><a name="1043110"> </a><a href="CRef_VFSMgr.html#996951"><code>VFSDirEntryEnumerate()</code></a> </p>
    </td>
    <td><p class="tt"><a name="1043343"> </a>Enumerates the entries in a given directory. Entries can include files, links, and other directories.</p>
    </td>
  </tr>
  <tr valign="top">
    <td><p class="tt"><a name="1043112"> </a><a href="CRef_VFSMgr.html#997042"><code>VFSExportDatabaseToFile()</code></a> </p>
    </td>
    <td><p class="tt"><a name="1043345"> </a>Flattens and exports the specified database on the handheld to the specified PDB or PRC file on an expansion card. Works only with classic databases.</p>
    </td>
  </tr>
  <tr valign="top">
    <td><p class="tt"><a name="1108527"> </a><a href="CRef_VFSMgr.html#1106782"><code>VFSExportDatabaseToFileEx()</code></a></p>
    </td>
    <td><p class="tt"><a name="1108529"> </a>Flattens and exports the specified database on the handheld to the specified image file on an expansion card. Works with schema, extended, and classic databases only on handhelds running Palm OS Cobalt, version 6.0.1 or later.</p>
    </td>
  </tr>
  <tr valign="top">
    <td><p class="tt"><a name="1043114"> </a><a href="CRef_VFSMgr.html#1108053"><code>VFSFileClose()</code></a> </p>
    </td>
    <td><p class="tt"><a name="1043347"> </a>Closes an opened file or directory.</p>
    </td>
  </tr>
  <tr valign="top">
    <td><p class="tt"><a name="1043116"> </a><a href="CRef_VFSMgr.html#997171"><code>VFSFileCreate()</code></a> </p>
    </td>
    <td><p class="tt"><a name="1043349"> </a>Creates a file given a volume reference number and a path.</p>
    </td>
  </tr>
  <tr valign="top">
    <td><p class="tt"><a name="1043118"> </a><a href="CRef_VFSMgr.html#997251"><code>VFSFileDelete()</code></a> </p>
    </td>
    <td><p class="tt"><a name="1043351"> </a>Deletes a closed file or directory.</p>
    </td>
  </tr>
  <tr valign="top">
    <td><p class="tt"><a name="1043120"> </a><a href="CRef_VFSMgr.html#997310"><code>VFSFileEOF()</code></a> </p>
    </td>
    <td><p class="tt"><a name="1043353"> </a>Gets end-of-file status for an open file.</p>
    </td>
  </tr>
  <tr valign="top">
    <td><p class="tt"><a name="1043122"> </a><a href="CRef_VFSMgr.html#997357"><code>VFSFileGet()</code></a> </p>
    </td>
    <td><p class="tt"><a name="1043355"> </a>Reads the file from the expansion card on the handheld and copies it to the desktop.</p>
    </td>
  </tr>
  <tr valign="top">
    <td><p class="tt"><a name="1043124"> </a><a href="CRef_VFSMgr.html#997415"><code>VFSFileGetAttributes()</code></a> </p>
    </td>
    <td><p class="tt"><a name="1043357"> </a>Gets the attributes of an open file or directory.</p>
    </td>
  </tr>
  <tr valign="top">
    <td><p class="tt"><a name="1043126"> </a><a href="CRef_VFSMgr.html#997471"><code>VFSFileGetDate()</code></a> </p>
    </td>
    <td><p class="tt"><a name="1043359"> </a>Gets the dates of an open file or directory.</p>
    </td>
  </tr>
  <tr valign="top">
    <td><p class="tt"><a name="1043128"> </a><a href="CRef_VFSMgr.html#997531"><code>VFSFileOpen()</code></a> </p>
    </td>
    <td><p class="tt"><a name="1043361"> </a>Opens a file or directory and returns a reference pointer to it.</p>
    </td>
  </tr>
  <tr valign="top">
    <td><p class="tt"><a name="1043130"> </a><a href="CRef_VFSMgr.html#997600"><code>VFSFilePut()</code></a> </p>
    </td>
    <td><p class="tt"><a name="1043363"> </a>Reads a file from the desktop and copies it to an expansion card on the handheld.</p>
    </td>
  </tr>
  <tr valign="top">
    <td><p class="tt"><a name="1043132"> </a><a href="CRef_VFSMgr.html#997668"><code>VFSFileRead()</code></a> </p>
    </td>
    <td><p class="tt"><a name="1043365"> </a>Reads data from a file into the specified buffer.</p>
    </td>
  </tr>
  <tr valign="top">
    <td><p class="tt"><a name="1043134"> </a><a href="CRef_VFSMgr.html#997728"><code>VFSFileRename()</code></a> </p>
    </td>
    <td><p class="tt"><a name="1043367"> </a>Renames a closed file or directory.</p>
    </td>
  </tr>
  <tr valign="top">
    <td><p class="tt"><a name="1043136"> </a><a href="CRef_VFSMgr.html#997797"><code>VFSFileResize()</code></a> </p>
    </td>
    <td><p class="tt"><a name="1043369"> </a>Changes the size of an open file.</p>
    </td>
  </tr>
  <tr valign="top">
    <td><p class="tt"><a name="1043138"> </a><a href="CRef_VFSMgr.html#997906"><code>VFSFileSetAttributes()</code></a> </p>
    </td>
    <td><p class="tt"><a name="1043371"> </a>Sets the position from which to read or write within an open file.</p>
    </td>
  </tr>
  <tr valign="top">
    <td><p class="tt"><a name="1043140"> </a><a href="CRef_VFSMgr.html#997966"><code>VFSFileSetDate()</code></a> </p>
    </td>
    <td><p class="tt"><a name="1043373"> </a>Sets the attributes of an open file or directory.</p>
    </td>
  </tr>
  <tr valign="top">
    <td><p class="tt"><a name="1043142"> </a><a href="CRef_VFSMgr.html#997847"><code>VFSFileSeek()</code></a> </p>
    </td>
    <td><p class="tt"><a name="1043375"> </a>Changes the dates of an open file or directory.</p>
    </td>
  </tr>
  <tr valign="top">
    <td><p class="tt"><a name="1043144"> </a><a href="CRef_VFSMgr.html#998028"><code>VFSFileSize()</code></a> </p>
    </td>
    <td><p class="tt"><a name="1043377"> </a>Gets the size of an open file.</p>
    </td>
  </tr>
  <tr valign="top">
    <td><p class="tt"><a name="1043146"> </a><a href="CRef_VFSMgr.html#998082"><code>VFSFileTell()</code></a> </p>
    </td>
    <td><p class="tt"><a name="1043379"> </a>Gets the current position of the file pointer within an open file.</p>
    </td>
  </tr>
  <tr valign="top">
    <td><p class="tt"><a name="1043148"> </a><a href="CRef_VFSMgr.html#998133"><code>VFSFileWrite()</code></a> </p>
    </td>
    <td><p class="tt"><a name="1043381"> </a>Writes data to an open file.</p>
    </td>
  </tr>
  <tr valign="top">
    <td><p class="tt"><a name="1043150"> </a><a href="CRef_VFSMgr.html#998191"><code>VFSGetAPIVersion()</code></a> </p>
    </td>
    <td><p class="tt"><a name="1043383"> </a>Retrieves the version of the Expansion Manager and VFS Manager APIs.</p>
    </td>
  </tr>
  <tr valign="top">
    <td><p class="tt"><a name="1043152"> </a><a href="CRef_VFSMgr.html#998225"><code>VFSGetDefaultDirectory()</code></a> </p>
    </td>
    <td><p class="tt"><a name="1043385"> </a>Retrieves the default directory on the given volume for files of a particular type.</p>
    </td>
  </tr>
  <tr valign="top">
    <td><p class="tt"><a name="1043154"> </a><a href="CRef_VFSMgr.html#998297"><code>VFSImportDatabaseFromFile()</code></a> </p>
    </td>
    <td><p class="tt"><a name="1043387"> </a>Creates a database from the specified PDB or PRC file on an expansion card. Works only with classic databases.</p>
    </td>
  </tr>
  <tr valign="top">
    <td><p class="tt"><a name="1111476"> </a><a href="CRef_VFSMgr.html#1107874"><code>VFSImportDatabaseFromFileEx()</code></a></p>
    </td>
    <td><p class="tt"><a name="1111478"> </a>Creates a database from the specified image file on an expansion card. Works with schema, extended, and classic databases only on handhelds running Palm OS Cobalt, version 6.0.1 or later.</p>
    </td>
  </tr>
  <tr valign="top">
    <td><p class="tt"><a name="1043156"> </a><a href="CRef_VFSMgr.html#998356"><code>VFSSupport()</code></a> </p>
    </td>
    <td><p class="tt"><a name="1043389"> </a>Determines whether the Expansion Manager and VFS Manager are present on the handheld, their version if present, and gets expansion slot and volume information.</p>
    </td>
  </tr>
  <tr valign="top">
    <td><p class="tt"><a name="1043158"> </a><a href="CRef_VFSMgr.html#998396"><code>VFSVolumeEnumerate()</code></a> </p>
    </td>
    <td><p class="tt"><a name="1043391"> </a>Enumerates the mounted volumes and retrieves a list of volume reference numbers.</p>
    </td>
  </tr>
  <tr valign="top">
    <td><p class="tt"><a name="1043160"> </a><a href="CRef_VFSMgr.html#998460"><code>VFSVolumeFormat()</code></a> </p>
    </td>
    <td><p class="tt"><a name="1043393"> </a>Formats and mounts the first volume installed in a given slot.</p>
    </td>
  </tr>
  <tr valign="top">
    <td><p class="tt"><a name="1043162"> </a><a href="CRef_VFSMgr.html#998540"><code>VFSVolumeGetLabel()</code></a> </p>
    </td>
    <td><p class="tt"><a name="1043395"> </a>Gets the volume label for a particular volume.</p>
    </td>
  </tr>
  <tr valign="top">
    <td><p class="tt"><a name="1043164"> </a><a href="CRef_VFSMgr.html#998593"><code>VFSVolumeInfo()</code></a> </p>
    </td>
    <td><p class="tt"><a name="1043397"> </a>Gets information about the specified volume.</p>
    </td>
  </tr>
  <tr valign="top">
    <td><p class="tt"><a name="1043166"> </a><a href="CRef_VFSMgr.html#998644"><code>VFSVolumeSetLabel()</code></a> </p>
    </td>
    <td><p class="tt"><a name="1043399"> </a>Changes the volume label for a mounted volume.</p>
    </td>
  </tr>
  <tr valign="top">
    <td><p class="tt"><a name="1043168"> </a><a href="CRef_VFSMgr.html#998709"><code>VFSVolumeSize()</code></a> </p>
    </td>
    <td><p class="tt"><a name="1043401"> </a>Determines the total amount of space on a volume, as well as the amount that is currently being used.</p>
    </td>
  </tr>
</table>

</div>

</p>

<p class="fineprint">

</p>

<h3 class="hbH3">
  <a name="996828"> </a>VFSCustomControl Function <a href="#995934"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="996830"> </a>Purpose 
</h4>

<p><a name="996831"> </a>Makes a custom API call to a particular file system driver, given the driver's creator ID.</p>
<h4>
  <a name="996832"> </a>Declared In 
</h4>
<code>VFSMgr.h<a name="996833"> </a></code><h4>
  <a name="996834"> </a>Prototype 
</h4>
<pre class="proto"><a name="996835"></a>SInt32 VFSCustomControl (
   UInt32 <code class="par">fsCreator</code>,
   UInt32 <code class="par">apiCreator</code>,
   UInt16 <code class="par">apiSelector</code>,
   void <code class="par">*pDataBuf</code>,
   UInt16 <code class="par">*pwDataBufLen</code>
)
</pre>
<h4>
  <a name="996836"> </a>Parameters 
</h4>

<dl>
<dt><a name="996837"> </a><code>&rarr;  <i>fsCreator</i></code></dt>
<dd><a name="996838"> </a>Creator of the file system on the handheld to call. A value of zero tells the VFS Manager to check each registered file system, looking for one that supports the call.</dd>

<dt><a name="996839"> </a><code>&rarr;  <i>apiCreator</i></code></dt>
<dd><a name="996840"> </a>Registered creator ID of the file system driver on the handheld. </dd>

<dt><a name="996841"> </a><code>&rarr;  <i>apiSelector</i></code></dt>
<dd><a name="996842"> </a>Code for the custom operation that you want the file system driver to perform. See the file system driver manufacturer for details. </dd>

<dt><a name="996843"> </a><code>&harr;  <i>pDataBuf</i></code></dt>
<dd><a name="996844"> </a>A pointer to a buffer containing data specific to the operation. On exit, depending on the function of the particular custom call and on the value of <code class="par">pwDataBufLen</code>, the contents of this buffer may have been updated.</dd>

<dt><a name="996845"> </a><code>&harr;  <i>pwDataBufLen</i></code></dt>
<dd><a name="996846"> </a>On entry, points to the size of the <code class="par">pDataBuf</code> buffer. On exit, this value reflects the size of the data written to the <code class="par">pDataBuf</code> buffer. If <code class="par">pwDataBufLen</code> is <code>NULL</code>, <code class="par">pDataBuf</code> is passed to the file system but is not updated on exit.</dd>

</dl>
<h4>
  <a name="996847"> </a>Returns 
</h4>

<p><a name="996848"> </a>If successful, returns 0. </p>

<p><a name="996849"> </a>If unsuccessful, returns one of the following error codes:</p>

<dl>
<dt><a name="996850"> </a><code>expErrNotOpen </code></dt>
<dt><a name="996851"> </a><code>expErrUnsupportedOperation</code></dt>
<dt><a name="996852"> </a><code>SYNCERR_COMM_NOT_INIT </code></dt>
<dt><a name="996853"> </a><code>SYNCERR_REMOTE_BAD_ARG </code></dt>
<dt><a name="996854"> </a><code>vfsErrInvalidOperation </code></dt>
<dt><a name="996855"> </a><code>vfsErrNoFileSystem </code></dt>
</dl>

<p><a name="996862"> </a>For descriptions of all VFS Manager error codes, see <a href="CRef_VFSMgr.html#998756">"VFS Manager Error Codes."</a></p>
<h4>
  <a name="996864"> </a>Comments 
</h4>

<p><a name="996865"> </a>The driver identifies the call and its API by a registered creator ID and a selector. (You can use <a href="CRef_VFSMgr.html#998593"><code>VFSVolumeInfo()</code></a> to determine the creator ID of the file system for a given volume.) This allows file system developers to extend the API by defining selectors for their creator IDs. It also allows file system developers to support selectors (and custom calls) defined by other file system developers. </p>

<p><a name="996869"> </a>This function must return <code>expErrUnsupportedOperation</code> for all unsupported or undefined opcodes and/or creators.</p>
<h4>
  <a name="996870"> </a>Compatibility 
</h4>

<p><a name="996871"> </a>VFS Manager version: All. <br>Palm OS version: 4.0 or later. Implemented only if the VFS Manager is present on the handheld (see <a href="CComp_Expansion.html#996231">"Checking for Expansion Cards"</a> in the <i>C/C++ Sync Suite Companion</i>). </p>
<h4>
  <a name="996881"> </a>See Also 
</h4>

<p><a name="996885"> </a><a href="CRef_VFSMgr.html#998593"><code>VFSVolumeInfo()</code></a> </p>

<h3 class="hbH3">
  <a name="996887"> </a>VFSDirCreate Function <a href="#995934"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="996889"> </a>Purpose 
</h4>

<p><a name="996890"> </a>Creates a new directory.</p>
<h4>
  <a name="996891"> </a>Declared In 
</h4>
<code>VFSMgr.h<a name="996892"> </a></code><h4>
  <a name="996893"> </a>Prototype 
</h4>
<pre class="proto"><a name="996894"></a>SInt32 VFSDirCreate (
   UInt16 <code class="par">volRefNum</code>,
   const char <code class="par">*pszDirName</code>
)
</pre>
<h4>
  <a name="996895"> </a>Parameters 
</h4>

<dl>
<dt><a name="996896"> </a><code>&rarr;  <i>volRefNum</i></code></dt>
<dd><a name="996897"> </a>Volume reference number passed back by <a href="CRef_VFSMgr.html#998396"><code>VFSVolumeEnumerate()</code></a>. </dd>

<dt><a name="996901"> </a><code>&rarr;  <i>pszDirName</i></code></dt>
<dd><a name="996902"> </a>A pointer to the full path of the directory to be created.</dd>

</dl>
<h4>
  <a name="996903"> </a>Returns 
</h4>

<p><a name="996904"> </a>If successful, returns 0.</p>

<p><a name="996905"> </a>If unsuccessful, returns one of the following error codes:</p>

<dl>
<dt><a name="996906"> </a><code>expErrNotOpen </code></dt>
<dt><a name="996907"> </a><code>SYNCERR_COMM_NOT_INIT </code></dt>
<dt><a name="996908"> </a><code>SYNCERR_REMOTE_BAD_ARG </code></dt>
<dt><a name="996909"> </a><code>vfsErrBadName </code></dt>
<dt><a name="996910"> </a><code>vfsErrFileAlreadyExists </code></dt>
<dt><a name="996911"> </a><code>vfsErrInvalidOperation </code></dt>
<dt><a name="996912"> </a><code>vfsErrNoFileSystem </code></dt>
<dt><a name="996913"> </a><code>vfsErrVolumeBadRef </code></dt>
<dt><a name="996914"> </a><code>vfsErrVolumeFull </code></dt>
</dl>

<p><a name="996917"> </a>For descriptions of all VFS Manager error codes, see <a href="CRef_VFSMgr.html#998756">"VFS Manager Error Codes."</a></p>
<h4>
  <a name="996919"> </a>Comments 
</h4>

<p><a name="996920"> </a>All parts of the path except the last component must already exist. The <code>vfsFileAttrDirectory</code> attribute is set with this function.</p>

<p><a name="996924"> </a><a href="CRef_VFSMgr.html#996887"><code>VFSDirCreate()</code></a> does not open the directory. Any operations you want to perform on this directory require a reference, which is obtained through a call to <a href="CRef_VFSMgr.html#997531"><code>VFSFileOpen()</code></a>.</p>
<h4>
  <a name="996928"> </a>Compatibility 
</h4>

<p><a name="996929"> </a>VFS Manager version: All. <br>Palm OS version: 4.0 or later. Implemented only if the VFS Manager is present on the handheld (see <a href="CComp_Expansion.html#996231">"Checking for Expansion Cards"</a> in the <i>C/C++ Sync Suite Companion</i>). </p>
<h4>
  <a name="996939"> </a>See Also 
</h4>

<p><a name="996946"> </a><a href="CRef_VFSMgr.html#997531"><code>VFSFileOpen()</code></a>, <a href="CRef_VFSMgr.html#997251"><code>VFSFileDelete()</code></a>, <a href="CRef_VFSMgr.html#996951"><code>VFSDirEntryEnumerate()</code></a> </p>

<h3 class="hbH3">
  <a name="996951"> </a>VFSDirEntryEnumerate Function <a href="#995934"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="996953"> </a>Purpose 
</h4>

<p><a name="996954"> </a>Enumerates the entries in a given directory. Entries can include files, links, and other directories. </p>
<h4>
  <a name="996955"> </a>Declared In 
</h4>
<code>VFSMgr.h<a name="996956"> </a></code><h4>
  <a name="996957"> </a>Prototype 
</h4>
<pre class="proto"><a name="996958"></a>SInt32 VFSDirEntryEnumerate (
   FileRef <code class="par">dirRef</code>,
   UInt32 <code class="par">*pui32DirEntryIterator</code>,
   FileInfoType <code class="par">*pFileInfo</code>
)
</pre>
<h4>
  <a name="996959"> </a>Parameters 
</h4>

<dl>
<dt><a name="996960"> </a><code>&rarr;  <i>dirRef</i></code></dt>
<dd><a name="996964"> </a>Directory reference passed back by <a href="CRef_VFSMgr.html#997531"><code>VFSFileOpen()</code></a>.</dd>

<dt><a name="996965"> </a><code>&harr;  <i>pui32DirEntryIterator</i></code></dt>
<dd><a name="996966"> </a>Pointer to the index of the last entry enumerated. For the first iteration, initialize this parameter to the constant <code>expIteratorStart</code>. Upon return, this references the next entry in the directory. If <code class="par">pFileInfo</code> is the last entry, this parameter is set to <code>expIteratorStop</code>.</dd>

<dt><a name="996967"> </a><code>&larr;  <i>pFileInfo</i></code></dt>
<dd><a name="996971"> </a>Pointer to the <a href="CRef_VFSMgr.html#996019"><code>FileInfoType</code></a> data structure that contains information about the given directory entry. </dd>

</dl>
<h4>
  <a name="996972"> </a>Returns 
</h4>

<p><a name="996973"> </a>If successful, returns 0. </p>

<p><a name="996974"> </a>If unsuccessful, returns one of the following error codes:</p>

<dl>
<dt><a name="996975"> </a><code>expErrEnumerationEmpty </code></dt>
<dt><a name="996976"> </a><code>expErrNotOpen</code></dt>
<dt><a name="996977"> </a><code>SYNCERR_COMM_NOT_INIT </code></dt>
<dt><a name="996978"> </a><code>SYNCERR_REMOTE_BAD_ARG </code></dt>
<dt><a name="996979"> </a><code>vfsErrFileBadRef</code></dt>
<dt><a name="996980"> </a><code>vfsErrInvalidOperation </code></dt>
<dt><a name="996981"> </a><code>vfsErrNotADirectory</code></dt>
<dt><a name="996982"> </a><code>vfsErrNoFileSystem </code></dt>
</dl>

<p><a name="996985"> </a>For descriptions of all VFS Manager error codes, see <a href="CRef_VFSMgr.html#998756">"VFS Manager Error Codes."</a></p>
<h4>
  <a name="996987"> </a>Comments 
</h4>

<p><a name="996988"> </a>The file system function returns information on the entry referenced by <code class="par">pui32DirEntryIterator</code>. The directory to be enumerated must first be opened with <a href="CRef_VFSMgr.html#997531"><code>VFSFileOpen()</code></a> to obtain a file reference number. To get information on all entries in a directory, you must make repeated calls to <code>VFSDirEntryEnumerate()</code> inside a loop. Boundaries on the iteration are the defined constants <code>expIteratorStart</code> and <code>expIteratorStop</code>. Before the first call to <code>VFSDirEntryEnumerate()</code>, initialize <code class="par">pui32DirEntryIterator</code> to the constant value <code>expIteratorStart</code>. Each iteration then increments the value pointed to by <code class="par">pui32DirEntryIterator</code> to the next entry. When this function returns information on the last entry in the directory, <code class="par">pui32DirEntryIterator</code> is set to <code>expIteratorStop</code>. </p>
<div class="NINoteImportant"><hr>
  <a name="996992"> </a> <b>IMPORTANT: </b> Creating, renaming, or deleting any file or directory invalidates the enumeration. After any such operation, the enumeration will need to be restarted.
<hr>
</div>
<h4>
  <a name="996994"> </a>Example 
</h4>

<p><a name="996995"> </a>The following illustrates how to use <code>VFSDirEntryEnumerate()</code>.</p>

<div class="CodeRule"><hr></div><pre class="CodeBlock">
// Open the directory and iterate through the files in it.<a name="996996"> </a>
// volRefNum must have already been defined.<a name="996997"> </a>
FileRef dirRef;<a name="996998"> </a>
<a name="996999"> </a>
err = VFSFileOpen (volRefNum, "/", vfsModeRead, &amp;dirRef);<a name="997000"> </a>
if(err == errNone) {<a name="997001"> </a>
   // Iterate through all the files in the open directory<a name="997002"> </a>
   UInt32 fileIterator;<a name="997003"> </a>
   FileInfoType fileInfo;<a name="997004"> </a>
  char *fileName = new char[256];  // Should check for err.<a name="997005"> </a>
<a name="997006"> </a>
   fileInfo.nameP = fileName;       // Point to local buffer.<a name="997007"> </a>
   fileInfo.nameBufLen = sizeof(fileName);<a name="997008"> </a>
   fileIterator = expIteratorStart;<a name="997009"> </a>
   while (fileIterator != expIteratorStop) {<a name="997010"> </a>
      // Get the next file<a name="997011"> </a>
      err = <b>VFSDirEntryEnumerate</b> (dirRef, &amp;fileIterator,<a name="997012"> </a>
         &amp;fileInfo);<a name="997013"> </a>
      if(err == errNone) {<a name="997014"> </a>
         // Process the file here.<a name="997015"> </a>
      }<a name="997016"> </a>
   } else {<a name="997017"> </a>
      // Handle directory open error here.<a name="997018"> </a>
   }<a name="997019"> </a>
   delete [] fileName;<a name="997020"> </a>
}<a name="997021"> </a>
</pre><div class="CodeRule"><hr></div>

<h4>
  <a name="997022"> </a>Compatibility 
</h4>

<p><a name="997023"> </a>VFS Manager version: All. <br>Palm OS version: 4.0 or later. Implemented only if the VFS Manager is present on the handheld (see <a href="CComp_Expansion.html#996231">"Checking for Expansion Cards"</a> in the <i>C/C++ Sync Suite Companion</i>). </p>
<h4>
  <a name="997033"> </a>See Also 
</h4>

<p><a name="997040"> </a><a href="CRef_VFSMgr.html#997531"><code>VFSFileOpen()</code></a>, <a href="CRef_ExpMgr.html#1005105">"Directory Enumeration Constants"</a> </p>

<h3 class="hbH3">
  <a name="997042"> </a>VFSExportDatabaseToFile Function <a href="#995934"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="997044"> </a>Purpose 
</h4>

<p><a name="1109023"> </a>Flattens and exports the specified database on the handheld to the specified PDB or PRC file on an expansion card. Works only with classic databases.</p>
<h4>
  <a name="1109027"> </a>Declared In 
</h4>
<code>VFSMgr.h<a name="997047"> </a></code><h4>
  <a name="997048"> </a>Prototype 
</h4>
<pre class="proto"><a name="997049"></a>SInt32 VFSExportDatabaseToFile (
   UInt16 <code class="par">volRefNum</code>,
   const char <code class="par">*pszPathName</code>,
   UInt16 <code class="par">wCardNumber</code>,
   LocalID <code class="par">dbID</code>
)
</pre>
<h4>
  <a name="997050"> </a>Parameters 
</h4>

<dl>
<dt><a name="997051"> </a><code>&rarr;  <i>volRefNum</i></code></dt>
<dd><a name="997052"> </a>Volume reference number (passed back by <a href="CRef_VFSMgr.html#998396"><code>VFSVolumeEnumerate()</code></a>) of the volume on which to create the destination file.</dd>

<dt><a name="997056"> </a><code>&rarr;  <i>pszPathName</i></code></dt>
<dd><a name="997057"> </a>Pointer to the full path and filename of the destination file to create. All parts of the path, excluding the filename, must already exist. </dd>

<dt><a name="997058"> </a><code>&rarr;  <i>wCardNumber</i></code></dt>
<dd><a name="997059"> </a>RAM card number in the handheld on which the database exists. Note that this does not refer to the expansion card and is therefore not related to the slot reference number. The card number for the first RAM memory card on the handheld is 0, which is the only one that most handhelds have. </dd>

<dt><a name="1020883"> </a><code>&rarr;  <i>dbID</i></code></dt>
<dd><a name="1020884"> </a>The local ID of the database on the handheld. This is the <code>dwLocalID</code> field of the <a href="CRef_SyncClassic.html#1093299"><code>SyncDatabaseInfoType</code></a> structure, which is passed back by the following functions: <a href="CRef_SyncClassic.html#1070556"><code>SyncFindDbByName()</code></a>, <a href="CRef_SyncClassic.html#1070576"><code>SyncFindDbByTypeCreator()</code></a>, and <a href="CRef_SyncClassic.html#1070634"><code>SyncOpenDB()</code></a>.</dd>

</dl>
<h4>
  <a name="997076"> </a>Returns 
</h4>

<p><a name="997077"> </a>If successful, returns 0. </p>

<p><a name="997078"> </a>If unsuccessful, returns one of the following error codes:</p>

<dl>
<dt><a name="997079"> </a><code>SYNCERR_COMM_NOT_INIT </code></dt>
<dt><a name="997080"> </a><code>SYNCERR_REMOTE_BAD_ARG </code></dt>
<dt><a name="997081"> </a><code>vfsErrBadName </code></dt>
<dt><a name="997082"> </a><code>vfsErrInvalidOperation </code></dt>
</dl>

<p><a name="997085"> </a>For descriptions of all VFS Manager error codes, see <a href="CRef_VFSMgr.html#998756">"VFS Manager Error Codes."</a></p>
<h4>
  <a name="997087"> </a>Comments 
</h4>

<p><a name="997088"> </a>This utility function flattens and exports a database from primary storage memory on a handheld to a PDB or PRC file on an expansion card. This function is the opposite of <a href="CRef_VFSMgr.html#998297"><code>VFSImportDatabaseFromFile()</code></a>. Use this function, for example, to copy applications from primary storage to an expansion card.</p>
<div class="NINoteImportant"><hr>
  <a name="1056674"> </a> <b>IMPORTANT: </b> With VFS Manager API version 1.1, this function is deprecated for use with handhelds running Palm OS Cobalt; call <a href="CRef_VFSMgr.html#1106782"><code>VFSExportDatabaseToFileEx()</code></a> instead. The reason for replacing this function is that memory card numbers are not supported by Palm OS Cobalt and local IDs are insufficient to identify schema databases and are cumbersome to identify extended and classic databases.<br><br>However, this function is still supported for use with Palm OS 4.x and Palm OS Garnet.
<hr>
</div>
<h4>
  <a name="997092"> </a>Example 
</h4>

<p><a name="997093"> </a>The following example illustrates how to use <span style="color: #333;;  font-style: normal; font-weight: normal; text-decoration: none; text-transform: none; vertical-align: baseline">VFSExportDatabaseToFile()</span> to export the MemoPad database.</p>

<div class="CodeRule"><hr></div><pre class="CodeBlock">
SyncFindDbByTypeCreatorParams rParam;<a name="997094"> </a>
SyncDatabaseInfoType rInfo;<a name="997095"> </a>
<a name="997096"> </a>
memset (&amp;rParam, 0, sizeof (rParam));<a name="997097"> </a>
rParam.bSrchFlags = SYNC_DB_SRCH_OPT_NEW_SEARCH;<a name="997098"> </a>
rParam.dwCreator = 'memo';<a name="997099"> </a>
<a name="997100"> </a>
SyncFindDbByTypeCreator (rParam, rInfo);<a name="997101"> </a>
SInt32 retval = <b>VFSExportDatabaseToFile</b> (volRefNum, <a name="997102"> </a>
   "/Palm/Launcher/Memopad.pdb", 0, rInfo.dwLocalId);<a name="997103"> </a>
</pre><div class="CodeRule"><hr></div>

<h4>
  <a name="997104"> </a>Compatibility 
</h4>

<p><a name="997105"> </a>VFS Manager version: All. <br>Palm OS version: 4.0 or later. Implemented only if the VFS Manager is present on the handheld (see <a href="CComp_Expansion.html#996231">"Checking for Expansion Cards"</a> in the <i>C/C++ Sync Suite Companion</i>). </p>
<h4>
  <a name="997115"> </a>See Also 
</h4>

<p><a name="997122"> </a><a href="CRef_VFSMgr.html#998133"><code>VFSFileWrite()</code></a>, <a href="CRef_VFSMgr.html#998297"><code>VFSImportDatabaseFromFile()</code></a> </p>

<h3 class="hbH3">
  <a name="1106782"> </a>VFSExportDatabaseToFileEx Function <a href="#995934"><span class="nav">^TOP^</span></a>
</h3>


<p><a name="1106785"> </a>Flattens and exports the specified database on the handheld to the specified image file on an expansion card. Works with schema, extended, and classic databases only on handhelds running Palm OS Cobalt, version 6.0.1 or later.</p>
<h4>
  <a name="1106786"> </a>Declared In 
</h4>
<code>VFSMgr.h<a name="1106787"> </a></code><h4>
  <a name="1106788"> </a>Prototype 
</h4>
<pre class="proto"><a name="1106789"></a>SInt32 VFSExportDatabaseToFileEx (
   UInt16 <code class="par">volRefNum</code>,
   char <code class="par">*pszPathName</code>,
   DBDatabaseInfo <code class="par">*pDbInfo</code>
)
</pre>
<h4>
  <a name="1106790"> </a>Parameters 
</h4>

<dl>
<dt><a name="1106791"> </a><code>&rarr;  <i>volRefNum</i></code></dt>
<dd><a name="1106792"> </a>Volume reference number (passed back by <a href="CRef_VFSMgr.html#998396"><code>VFSVolumeEnumerate()</code></a>) of the volume on which to create the destination file.</dd>

<dt><a name="1107291"> </a><code>&harr;  <i>pszPathName</i></code></dt>
<dd><a name="1107292"> </a>Pointer to the full path and filename or only to the directory of the destination file to create. Do not specify <code>NULL</code>. All parts of the path, excluding the filename, must already exist. If you specify a directory, this function automatically generates the filename and appends it to the directory name. Upon return, receives the full path and filename to which the database is written.</dd>

<dt><a name="1106795"> </a><code>&rarr;  <i>pDbInfo</i></code></dt>
<dd><a name="1106796"> </a>A pointer to a <a href="CRef_SyncCommon.html#1038263"><code>DBDatabaseInfo</code></a> structure whose <code>name</code>, <code>creator</code>, <code>type</code> and <code>attributes</code> fields specify the database to export. The <code>type</code> is only used as a cross-check and may be set to zero if you don't care what its value is. The <code>attributes</code> must specify whether the database is a classic, extended, or schema database. All other <code>attributes</code> bits are ignored. </dd>

</dl>
<h4>
  <a name="1106797"> </a>Returns 
</h4>

<p><a name="1107334"> </a>If successful, returns 0. </p>

<p><a name="1107335"> </a>If unsuccessful, returns one of the following error codes:</p>

<dl>
<dt><a name="1107336"> </a><code>SYNCERR_COMM_NOT_INIT </code></dt>
<dt><a name="1107337"> </a><code>SYNCERR_REMOTE_BAD_ARG </code></dt>
<dt><a name="1113128"> </a><code>SYNCERR_UNKNOWN_REQUEST</code></dt>
<dd><a name="1113129"> </a>The handheld is running a version of Palm OS that this function does not support. See "Compatibility" below.</dd>

<dt><a name="1107338"> </a><code>vfsErrBadName </code></dt>
<dt><a name="1107339"> </a><code>vfsErrInvalidOperation </code></dt>
</dl>

<p><a name="1107342"> </a>For descriptions of all VFS Manager error codes, see <a href="CRef_VFSMgr.html#998756">"VFS Manager Error Codes."</a></p>
<h4>
  <a name="1106799"> </a>Comments 
</h4>

<p><a name="1107750"> </a>This utility function flattens and exports a schema, extended, or classic database from primary storage memory on a handheld to a to an image file on an expansion card. This function does the opposite of <a href="CRef_VFSMgr.html#1107874"><code>VFSImportDatabaseFromFileEx()</code></a>. Use this function, for example, to copy applications or databases from primary storage to an expansion card.</p>

<p><a name="1107795"> </a>With this function, you identify a database to export by the <code>creator</code>, <code>name</code>, <code>attributes</code>, <code>type</code> fields of the input <code>DBDatabaseInfo</code> structure. Then you specify the location to which to export the file: the volume and a path and filename or only a directory path. If you specify only a directory, then the Sync Manager generates a unique filename in the same way it does for <a href="CRef_SyncCommon.html#1000188"><code>SyncGenerateBackupFileName()</code></a> and appends it to the directory path and passes back the full path and filename when this function returns.</p>

<p><a name="1107796"> </a>This function is a replacement for <a href="CRef_VFSMgr.html#997042"><code>VFSExportDatabaseToFile()</code></a>, which identifies databases only by memory card number and local ID. The reason for replacing this function is that memory card numbers are not supported by Palm OS Cobalt and local IDs are insufficient to identify schema databases and somewhat cumbersome to identify extended and classic databases.</p>
<h4>
  <a name="1111546"> </a>Example 
</h4>

<p><a name="1111547"> </a>The following example illustrates how to use <span style="color: #333;;  font-style: normal; font-weight: normal; text-decoration: none; text-transform: none; vertical-align: baseline">VFSExportDatabaseToFileEx()</span> to export a given schema database.</p>

<div class="CodeRule"><hr></div><pre class="CodeBlock">
UInt16 volRefNum; // Get this via VFSVolumeEnumerate().<a name="1111981"> </a>
char pathName[128] = "/Palm/Launcher/MySchemaDatabase.sdb";<a name="1111982"> </a>
DBDatabaseInfo dbInfo;<a name="1112177"> </a>
dbInfo.name = "MySchemaDatabase";<a name="1112086"> </a>
dbInfo.creator = 0x0017;<a name="1112094"> </a>
dbInfo.type = 0;<a name="1111969"> </a>
dbInfo.attributes = dmHdrAttrSchema;<a name="1111549"> </a>
<a name="1111554"> </a>
SInt32 retval = <b>VFSExportDatabaseToFileEX</b> (volRefNum, <a name="1111556"> </a>
   pathName, &amp;dbInfo);<a name="1112215"> </a>
</pre><div class="CodeRule"><hr></div>

<h4>
  <a name="1107845"> </a>Compatibility 
</h4>

<p><a name="1108475"> </a>VFS Manager version: 1.1 or later. <br>Palm OS version: 6.0.1 or later. Implemented only if the VFS Manager is present on the handheld (see <a href="CComp_Expansion.html#996231">"Checking for Expansion Cards"</a> in the <i>C/C++ Sync Suite Companion</i>). </p>
<h4>
  <a name="1107800"> </a>See Also 
</h4>

<p><a name="1108049"> </a><a href="CRef_SyncCommon.html#1038263"><code>DBDatabaseInfo</code></a>, <a href="CRef_VFSMgr.html#1107874"><code>VFSImportDatabaseFromFileEx()</code></a></p>

<h3 class="hbH3">
  <a name="1108053"> </a>VFSFileClose Function <a href="#995934"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="997126"> </a>Purpose 
</h4>

<p><a name="997127"> </a>Closes an opened file or directory.</p>
<h4>
  <a name="997128"> </a>Declared In 
</h4>
<code>VFSMgr.h<a name="997129"> </a></code><h4>
  <a name="997130"> </a>Prototype 
</h4>
<pre class="proto"><a name="997131"></a>SInt32 VFSFileClose (
   FileRef <code class="par">fileRef</code>
)
</pre>
<h4>
  <a name="997132"> </a>Parameters 
</h4>

<dl>
<dt><a name="997133"> </a><code>&rarr;  <i>fileRef</i></code></dt>
<dd><a name="997137"> </a>File reference number passed back from <a href="CRef_VFSMgr.html#997531"><code>VFSFileOpen()</code></a>.</dd>

</dl>
<h4>
  <a name="997138"> </a>Returns 
</h4>

<p><a name="997139"> </a>If successful, returns 0. </p>

<p><a name="997140"> </a>If unsuccessful, returns one of the following error codes:</p>

<dl>
<dt><a name="997141"> </a><code>expErrNotOpen </code></dt>
<dt><a name="997142"> </a><code>SYNCERR_COMM_NOT_INIT </code></dt>
<dt><a name="997143"> </a><code>vfsErrFileBadRef </code></dt>
<dt><a name="997144"> </a><code>vfsErrInvalidOperation </code></dt>
</dl>

<p><a name="997147"> </a>For descriptions of all VFS Manager error codes, see <a href="CRef_VFSMgr.html#998756">"VFS Manager Error Codes."</a></p>
<h4>
  <a name="997149"> </a>Comments 
</h4>

<p><a name="997150"> </a><code>VFSFileClose()</code> closes a file or directory that has been opened with <a href="CRef_VFSMgr.html#997531"><code>VFSFileOpen()</code></a>.</p>
<h4>
  <a name="997154"> </a>Compatibility 
</h4>

<p><a name="997155"> </a>VFS Manager version: All. <br>Palm OS version: 4.0 or later. Implemented only if the VFS Manager is present on the handheld (see <a href="CComp_Expansion.html#996231">"Checking for Expansion Cards"</a> in the <i>C/C++ Sync Suite Companion</i>). </p>
<h4>
  <a name="997165"> </a>See Also 
</h4>

<p><a name="997169"> </a><a href="CRef_VFSMgr.html#997531"><code>VFSFileOpen()</code></a></p>

<h3 class="hbH3">
  <a name="997171"> </a>VFSFileCreate Function <a href="#995934"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="997173"> </a>Purpose 
</h4>

<p><a name="997174"> </a>Creates a file given a volume reference number and a path.</p>
<h4>
  <a name="997175"> </a>Declared In 
</h4>
<code>VFSMgr.h<a name="997176"> </a></code><h4>
  <a name="997177"> </a>Prototype 
</h4>
<pre class="proto"><a name="997178"></a>SInt32 VFSFileCreate (
   UInt16 <code class="par">volRefNum</code>,
   const char <code class="par">*pszPathName</code>
)
</pre>
<h4>
  <a name="997179"> </a>Parameters 
</h4>

<dl>
<dt><a name="997180"> </a><code>&rarr;  <i>volRefNum</i></code></dt>
<dd><a name="997181"> </a>Volume reference number (passed back by <a href="CRef_VFSMgr.html#998396"><code>VFSVolumeEnumerate()</code></a>) of the volume on which to create the file. </dd>

<dt><a name="997185"> </a><code>&rarr;  <i>pszPathName</i></code></dt>
<dd><a name="997186"> </a>Pointer to the full path of the file to be created. All parts of the path, excluding the filename, must already exist. </dd>

</dl>
<h4>
  <a name="997187"> </a>Returns 
</h4>

<p><a name="997188"> </a>If successful, returns 0. </p>

<p><a name="997189"> </a>If unsuccessful, returns one of the following error codes:</p>

<dl>
<dt><a name="997190"> </a><code>expErrNotOpen </code></dt>
<dt><a name="997191"> </a><code>SYNCERR_COMM_NOT_INIT </code></dt>
<dt><a name="997192"> </a><code>SYNCERR_REMOTE_BAD_ARG </code></dt>
<dt><a name="997193"> </a><code>vfsErrBadName </code></dt>
<dt><a name="997194"> </a><code>vfsErrFileAlreadyExists </code></dt>
<dt><a name="997195"> </a><code>vfsErrInvalidOperation </code></dt>
<dt><a name="997196"> </a><code>vfsErrNoFileSystem </code></dt>
<dt><a name="997197"> </a><code>vfsErrVolumeBadRef </code></dt>
<dt><a name="997198"> </a><code>vfsErrVolumeFull </code></dt>
</dl>

<p><a name="997201"> </a>For descriptions of all VFS Manager error codes, see <a href="CRef_VFSMgr.html#998756">"VFS Manager Error Codes."</a></p>
<h4>
  <a name="997203"> </a>Comments 
</h4>

<p><a name="997204"> </a>All parts of the path except the last component must already exist. <a href="CRef_VFSMgr.html#997171"><code>VFSFileCreate()</code></a> does not open the file. Any operations you want to perform on this directory require a reference, which is obtained through a call to <a href="CRef_VFSMgr.html#997531"><code>VFSFileOpen()</code></a>.</p>

<p><a name="997211"> </a>It is the responsibility of the file system library on the handheld to ensure that all filenames are translated into a format that is compatible with the native format of the file system, such as the 8.3 convention for a FAT file system without long filename support. See <a href="CComp_Expansion.html#996803">"Directory Paths"</a> in the <i>C/C++ Sync Suite Companion</i> for a description of how to construct a valid path.</p>

<p><a name="997224"> </a>This function does not open the file. <a href="CRef_VFSMgr.html#997531"><code>VFSFileOpen()</code></a> must be used to open the file. Neither does it create a directory. To create a directory use <a href="CRef_VFSMgr.html#996887"><code>VFSDirCreate()</code></a>.</p>
<h4>
  <a name="997228"> </a>Compatibility 
</h4>

<p><a name="997229"> </a>VFS Manager version: All. <br>Palm OS version: 4.0 or later. Implemented only if the VFS Manager is present on the handheld (see <a href="CComp_Expansion.html#996231">"Checking for Expansion Cards"</a> in the <i>C/C++ Sync Suite Companion</i>). </p>
<h4>
  <a name="997239"> </a>See Also 
</h4>

<p><a name="997249"> </a><a href="CRef_VFSMgr.html#997251"><code>VFSFileDelete()</code></a>, <a href="CRef_VFSMgr.html#997531"><code>VFSFileOpen()</code></a>, <a href="CRef_VFSMgr.html#996887"><code>VFSDirCreate()</code></a> </p>

<h3 class="hbH3">
  <a name="997251"> </a>VFSFileDelete Function <a href="#995934"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="997253"> </a>Purpose 
</h4>

<p><a name="997254"> </a>Deletes a closed file or directory.</p>
<h4>
  <a name="997255"> </a>Declared In 
</h4>
<code>VFSMgr.h<a name="997256"> </a></code><h4>
  <a name="997257"> </a>Prototype 
</h4>
<pre class="proto"><a name="997258"></a>SInt32 VFSFileDelete (
   UInt16 <code class="par">volRefNum</code>,
   const char <code class="par">*pszPathName</code>
)
</pre>
<h4>
  <a name="997259"> </a>Parameters 
</h4>

<dl>
<dt><a name="997260"> </a><code>&rarr;  <i>volRefNum</i></code></dt>
<dd><a name="997261"> </a>Volume reference number (passed back by <a href="CRef_VFSMgr.html#998396"><code>VFSVolumeEnumerate()</code></a>) of the volume on which to delete the file. </dd>

<dt><a name="997265"> </a><code>&rarr;  <i>pszPathName</i></code></dt>
<dd><a name="997266"> </a>Pointer to the full path of the file or directory to delete.</dd>

</dl>
<h4>
  <a name="997267"> </a>Returns 
</h4>

<p><a name="997268"> </a>If successful, returns 0. </p>

<p><a name="997269"> </a>If unsuccessful, returns one of the following error codes:</p>

<dl>
<dt><a name="997270"> </a><code>expErrNotOpen </code></dt>
<dt><a name="997271"> </a><code>SYNCERR_COMM_NOT_INIT </code></dt>
<dt><a name="997272"> </a><code>SYNCERR_REMOTE_BAD_ARG </code></dt>
<dt><a name="997273"> </a><code>vfsErrBadName </code></dt>
<dt><a name="997274"> </a><code>vfsErrDirNotEmpty </code></dt>
<dt><a name="997275"> </a><code>vfsErrFileNotFound </code></dt>
<dt><a name="997276"> </a><code>vfsErrFilePermissionDenied </code></dt>
<dt><a name="997277"> </a><code>vfsErrFileStillOpen </code></dt>
<dt><a name="997278"> </a><code>vfsErrInvalidOperation </code></dt>
<dt><a name="997279"> </a><code>vfsErrNoFileSystem </code></dt>
<dt><a name="997280"> </a><code>vfsErrVolumeBadRef </code></dt>
</dl>

<p><a name="997283"> </a>For descriptions of all VFS Manager error codes, see <a href="CRef_VFSMgr.html#998756">"VFS Manager Error Codes."</a></p>
<h4>
  <a name="997285"> </a>Comments 
</h4>

<p><a name="997286"> </a>A directory must be empty before <code>VFSFileDelete()</code> can delete it. </p>
<h4>
  <a name="997287"> </a>Compatibility 
</h4>

<p><a name="997288"> </a>VFS Manager version: All. <br>Palm OS version: 4.0 or later. Implemented only if the VFS Manager is present on the handheld (see <a href="CComp_Expansion.html#996231">"Checking for Expansion Cards"</a> in the <i>C/C++ Sync Suite Companion</i>). </p>
<h4>
  <a name="997298"> </a>See Also 
</h4>

<p><a name="997308"> </a><a href="CRef_VFSMgr.html#997171"><code>VFSFileCreate()</code></a>, <a href="CRef_VFSMgr.html#996887"><code>VFSDirCreate()</code></a>, <a href="CRef_VFSMgr.html#1108053"><code>VFSFileClose()</code></a> </p>

<h3 class="hbH3">
  <a name="997310"> </a>VFSFileEOF Function <a href="#995934"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="997312"> </a>Purpose 
</h4>

<p><a name="997313"> </a>Gets end-of-file status for an open file. </p>
<h4>
  <a name="997314"> </a>Declared In 
</h4>
<code>VFSMgr.h<a name="997315"> </a></code><h4>
  <a name="997316"> </a>Prototype 
</h4>
<pre class="proto"><a name="997317"></a>SInt32 VFSFileEOF (
   FileRef <code class="par">fileRef</code>
)
</pre>
<h4>
  <a name="997318"> </a>Parameters 
</h4>

<dl>
<dt><a name="997319"> </a><code>&rarr;  <i>fileRef</i></code></dt>
<dd><a name="997323"> </a>File reference number passed back by <a href="CRef_VFSMgr.html#997531"><code>VFSFileOpen()</code></a>.</dd>

</dl>
<h4>
  <a name="997324"> </a>Returns 
</h4>

<p><a name="997325"> </a>If successful, returns 0 (the file pointer was not already at the end of the file). </p>

<p><a name="997326"> </a>If unsuccessful, returns one of the following error codes:</p>

<dl>
<dt><a name="997327"> </a><code>expErrNotOpen </code></dt>
<dt><a name="997328"> </a><code>SYNCERR_COMM_NOT_INIT </code></dt>
<dt><a name="997329"> </a><code>vfsErrFileBadRef </code></dt>
<dt><a name="997330"> </a><code>vfsErrFileEOF </code></dt>
<dt><a name="997331"> </a><code>vfsErrInvalidOperation </code></dt>
<dt><a name="997332"> </a><code>vfsErrIsADirectory </code></dt>
<dt><a name="997333"> </a><code>vfsErrNoFileSystem </code></dt>
</dl>

<p><a name="997336"> </a>For descriptions of all VFS Manager error codes, see <a href="CRef_VFSMgr.html#998756">"VFS Manager Error Codes."</a></p>
<h4>
  <a name="997338"> </a>Comments 
</h4>

<p><a name="997339"> </a>This function operates only on files and cannot be used with directories.</p>
<h4>
  <a name="997340"> </a>Compatibility 
</h4>

<p><a name="997341"> </a>VFS Manager version: All. <br>Palm OS version: 4.0 or later. Implemented only if the VFS Manager is present on the handheld (see <a href="CComp_Expansion.html#996231">"Checking for Expansion Cards"</a> in the <i>C/C++ Sync Suite Companion</i>). </p>
<h4>
  <a name="997351"> </a>See Also 
</h4>

<p><a name="997355"> </a><a href="CRef_VFSMgr.html#997531"><code>VFSFileOpen()</code></a></p>

<h3 class="hbH3">
  <a name="997357"> </a>VFSFileGet Function <a href="#995934"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="997359"> </a>Purpose 
</h4>

<p><a name="997360"> </a>Reads the file from the expansion card on the handheld and copies it to the desktop. </p>
<h4>
  <a name="997361"> </a>Declared In 
</h4>
<code>VFSMgr.h<a name="997362"> </a></code><h4>
  <a name="997363"> </a>Prototype 
</h4>
<pre class="proto"><a name="997364"></a>SInt32 VFSFileGet (
   UInt16 <code class="par">volRefNum</code>,
   const char <code class="par">*pszDevicePathName</code>,
   const char <code class="par">*pszDiskPathName</code>
)
</pre>
<h4>
  <a name="997365"> </a>Parameters 
</h4>

<dl>
<dt><a name="997366"> </a><code>&rarr;  <i>volRefNum</i></code></dt>
<dd><a name="997367"> </a>Volume reference number (passed back by <a href="CRef_VFSMgr.html#998396"><code>VFSVolumeEnumerate()</code></a>) of the volume on which the file is present. </dd>

<dt><a name="997371"> </a><code>&rarr;  <i>pszDevicePathName</i></code></dt>
<dd><a name="997372"> </a>Full path and filename of the file to be read from the expansion card on the handheld. </dd>

<dt><a name="997373"> </a><code>&rarr;  <i>pszDiskPathName</i></code></dt>
<dd><a name="997374"> </a>Full path and filename for the file to be created on the desktop. All parts of the path, except the file, must already exist. If the file does not exist, then this function creates it. If the file exists, then it overwrites the file. </dd>

</dl>
<h4>
  <a name="997375"> </a>Returns 
</h4>

<p><a name="997376"> </a>If successful, returns 0. </p>

<p><a name="997377"> </a>If unsuccessful, returns one of the following error codes: </p>

<dl>
<dt><a name="997378"> </a><code>expErrNotOpen </code></dt>
<dt><a name="997379"> </a><code>SYNCERR_COMM_NOT_INIT </code></dt>
<dt><a name="997380"> </a><code>SYNCERR_REMOTE_BAD_ARG </code></dt>
<dt><a name="997381"> </a><code>vfsErrDiskFileAccess </code></dt>
<dt><a name="997382"> </a><code>vfsErrFileAccessOther </code></dt>
<dt><a name="997383"> </a><code>vfsErrFileBadRef </code></dt>
<dt><a name="997384"> </a><code>vfsErrFileEOF </code></dt>
<dt><a name="997385"> </a><code>vfsErrFilePermissionDenied </code></dt>
<dt><a name="997386"> </a><code>vfsErrInvalidOperation </code></dt>
<dt><a name="997387"> </a><code>vfsErrIsADirectory </code></dt>
<dt><a name="997388"> </a><code>vfsErrNoFileSystem </code></dt>
</dl>

<p><a name="997391"> </a>For descriptions of all VFS Manager error codes, see <a href="CRef_VFSMgr.html#998756">"VFS Manager Error Codes."</a></p>
<h4>
  <a name="997393"> </a>Comments 
</h4>

<p><a name="997394"> </a>Using <code>VFSFileGet()</code> to copy a file to the desktop is easier than opening the file on the expansion card and reading it into a buffer on the desktop. </p>
<h4>
  <a name="997395"> </a>Compatibility 
</h4>

<p><a name="997396"> </a>VFS Manager version: All. <br>Palm OS version: 4.0 or later. Implemented only if the VFS Manager is present on the handheld (see <a href="CComp_Expansion.html#996231">"Checking for Expansion Cards"</a> in the <i>C/C++ Sync Suite Companion</i>). </p>
<h4>
  <a name="997406"> </a>See Also 
</h4>

<p><a name="997413"> </a><a href="CRef_VFSMgr.html#997531"><code>VFSFileOpen()</code></a>, <a href="CRef_VFSMgr.html#997600"><code>VFSFilePut()</code></a></p>

<h3 class="hbH3">
  <a name="997415"> </a>VFSFileGetAttributes Function <a href="#995934"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="997417"> </a>Purpose 
</h4>

<p><a name="997418"> </a>Gets the attributes of an open file or directory.</p>
<h4>
  <a name="997419"> </a>Declared In 
</h4>
<code>VFSMgr.h<a name="997420"> </a></code><h4>
  <a name="997421"> </a>Prototype 
</h4>
<pre class="proto"><a name="997422"></a>SInt32 VFSFileGetAttributes (
   FileRef <code class="par">fileRef</code>,
   UInt32 <code class="par">*pui32Attributes</code>
)
</pre>
<h4>
  <a name="997423"> </a>Parameters 
</h4>

<dl>
<dt><a name="997424"> </a><code>&rarr;  <i>fileRef</i></code></dt>
<dd><a name="997428"> </a>File reference number passed back by <a href="CRef_VFSMgr.html#997531"><code>VFSFileOpen()</code></a>.</dd>

<dt><a name="997429"> </a><code>&larr;  <i>pui32Attributes</i></code></dt>
<dd><a name="997432"> </a>Pointer to the attributes of the file or directory. See <a href="CRef_VFSMgr.html#996392">"File and Directory Attributes"</a> for a list of values that can be passed back through this parameter. </dd>

</dl>
<h4>
  <a name="997434"> </a>Returns 
</h4>

<p><a name="997435"> </a>If successful, returns 0. </p>

<p><a name="997436"> </a>If unsuccessful, returns one of the following error codes: </p>

<dl>
<dt><a name="997437"> </a><code>expErrNotOpen </code></dt>
<dt><a name="997438"> </a><code>SYNCERR_COMM_NOT_INIT </code></dt>
<dt><a name="997439"> </a><code>vfsErrFileBadRef </code></dt>
<dt><a name="997440"> </a><code>vfsErrInvalidOperation </code></dt>
<dt><a name="997441"> </a><code>vfsErrNoFileSystem </code></dt>
</dl>

<p><a name="997444"> </a>For descriptions of all VFS Manager error codes, see <a href="CRef_VFSMgr.html#998756">"VFS Manager Error Codes."</a></p>
<h4>
  <a name="997446"> </a>Comments 
</h4>

<p><a name="997447"> </a>The file or directory must be open before calling this function. </p>
<h4>
  <a name="997448"> </a>Compatibility 
</h4>

<p><a name="997449"> </a>VFS Manager version: All. <br>Palm OS version: 4.0 or later. Implemented only if the VFS Manager is present on the handheld (see <a href="CComp_Expansion.html#996231">"Checking for Expansion Cards"</a> in the <i>C/C++ Sync Suite Companion</i>). </p>
<h4>
  <a name="997459"> </a>See Also 
</h4>

<p><a name="997466"> </a><a href="CRef_VFSMgr.html#997531"><code>VFSFileOpen()</code></a>, <a href="CRef_VFSMgr.html#997471"><code>VFSFileGetDate()</code></a>, <a href="CRef_VFSMgr.html#997906"><code>VFSFileSetAttributes()</code></a> </p>

<h3 class="hbH3">
  <a name="997471"> </a>VFSFileGetDate Function <a href="#995934"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="997473"> </a>Purpose 
</h4>

<p><a name="997474"> </a>Gets the dates of an open file or directory.</p>
<h4>
  <a name="997475"> </a>Declared In 
</h4>
<code>VFSMgr.h<a name="997476"> </a></code><h4>
  <a name="997477"> </a>Prototype 
</h4>
<pre class="proto"><a name="997478"></a>SInt32 VFSFileGetDate (
   FileRef <code class="par">fileRef</code>,
   UInt16 <code class="par">whichDate</code>,
   UInt32 <code class="par">*pui32Date</code>
)
</pre>
<h4>
  <a name="997479"> </a>Parameters 
</h4>

<dl>
<dt><a name="997480"> </a><code>&rarr;  <i>fileRef</i></code></dt>
<dd><a name="997484"> </a>File reference number passed back by <a href="CRef_VFSMgr.html#997531"><code>VFSFileOpen()</code></a>.</dd>

<dt><a name="997485"> </a><code>&rarr;  <i>whichDate</i></code></dt>
<dd><a name="997486"> </a>Specifies which date&#8212creation, modification, or last access&#8212you want. Supply one of the values described in <a href="CRef_VFSMgr.html#996304">"Date Types."</a> </dd>

<dt><a name="997490"> </a><code>&larr;  <i>pui32Date</i></code></dt>
<dd><a name="997491"> </a>Pointer to the requested date. This field is expressed in the standard Palm OS date format&#8212the number of seconds since midnight (00:00:00) January 1, 1904. </dd>

</dl>
<h4>
  <a name="997492"> </a>Returns 
</h4>

<p><a name="997493"> </a>If successful, returns 0. </p>

<p><a name="997494"> </a>If unsuccessful, returns one of the following error codes: </p>

<dl>
<dt><a name="997495"> </a><code>expErrNotOpen </code></dt>
<dt><a name="997496"> </a><code>expErrUnsupportedOperation </code></dt>
<dt><a name="997497"> </a><code>SYNCERR_COMM_NOT_INIT </code></dt>
<dt><a name="997498"> </a><code>SYNCERR_REMOTE_BAD_ARG </code></dt>
<dt><a name="997499"> </a><code>vfsErrFileBadRef </code></dt>
<dt><a name="997500"> </a><code>vfsErrInvalidOperation </code></dt>
<dt><a name="997501"> </a><code>vfsErrNoFileSystem </code></dt>
</dl>

<p><a name="997504"> </a>For descriptions of all VFS Manager error codes, see <a href="CRef_VFSMgr.html#998756">"VFS Manager Error Codes."</a></p>
<h4>
  <a name="997506"> </a>Comments 
</h4>

<p><a name="997507"> </a>The file or directory must be open before calling this function. Note that not all file systems are required to support all date types. If the supplied date type is not supported by the file system, <code>VFSFileGetDate</code> returns <code>expErrUnsupportedOperation</code>. </p>
<h4>
  <a name="997508"> </a>Compatibility 
</h4>

<p><a name="997509"> </a>VFS Manager version: All. <br>Palm OS version: 4.0 or later. Implemented only if the VFS Manager is present on the handheld (see <a href="CComp_Expansion.html#996231">"Checking for Expansion Cards"</a> in the <i>C/C++ Sync Suite Companion</i>). </p>
<h4>
  <a name="997519"> </a>See Also 
</h4>

<p><a name="997526"> </a><a href="CRef_VFSMgr.html#997531"><code>VFSFileOpen()</code></a>, <a href="CRef_VFSMgr.html#997415"><code>VFSFileGetAttributes()</code></a>, <a href="CRef_VFSMgr.html#997966"><code>VFSFileSetDate()</code></a> </p>

<h3 class="hbH3">
  <a name="997531"> </a>VFSFileOpen Function <a href="#995934"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="997533"> </a>Purpose 
</h4>

<p><a name="997534"> </a>Opens a file or directory and returns a reference pointer to it.</p>
<h4>
  <a name="997535"> </a>Declared In 
</h4>
<code>VFSMgr.h<a name="997536"> </a></code><h4>
  <a name="997537"> </a>Prototype 
</h4>
<pre class="proto"><a name="997538"></a>SInt32 VFSFileOpen (
   UInt16 <code class="par">volRefNum</code>,
   const char <code class="par">*pszPathName</code>,
   UInt16 <code class="par">openMode</code>,
   FileRef <code class="par">*pFileRef</code>
)
</pre>
<h4>
  <a name="997539"> </a>Parameters 
</h4>

<dl>
<dt><a name="997540"> </a><code>&rarr;  <i>volRefNum</i></code></dt>
<dd><a name="997541"> </a>Volume reference number (passed back by <a href="CRef_VFSMgr.html#998396"><code>VFSVolumeEnumerate()</code></a>) of the volume on which to open the file. </dd>

<dt><a name="997545"> </a><code>&rarr;  <i>pszPathName</i></code></dt>
<dd><a name="997546"> </a>Pointer to the full path of the file or directory to be opened. This must be a valid path. It cannot be empty and cannot contain null characters. The format of the path should match what the underlying file system supports. See <a href="CComp_Expansion.html#996803">"Directory Paths"</a> in the <i>C/C++ Sync Suite Companion</i> for a description of how to construct a valid path.</dd>

<dt><a name="997556"> </a><code>&rarr;  <i>openMode</i></code></dt>
<dd><a name="997559"> </a>Mode to use when opening the file. See <a href="CRef_VFSMgr.html#996510">"Open Modes"</a> for a list of accepted modes.</dd>

<dt><a name="997561"> </a><code>&larr;  <i>pFileRef</i></code></dt>
<dd><a name="997562"> </a>Pointer to the opened file or directory. </dd>

</dl>
<h4>
  <a name="997563"> </a>Returns 
</h4>

<p><a name="997564"> </a>If successful, returns 0. </p>

<p><a name="997565"> </a>If unsuccessful, returns one of the following error codes: </p>

<dl>
<dt><a name="997566"> </a><code>expErrNotOpen </code></dt>
<dt><a name="997567"> </a><code>SYNCERR_COMM_NOT_INIT </code></dt>
<dt><a name="997568"> </a><code>SYNCERR_REMOTE_BAD_ARG </code></dt>
<dt><a name="997569"> </a><code>vfsErrBadName </code></dt>
<dt><a name="997570"> </a><code>vfsErrFileNotFound </code></dt>
<dt><a name="997571"> </a><code>vfsErrFilePermissionDenied </code></dt>
<dt><a name="997572"> </a><code>vfsErrInvalidOperation </code></dt>
<dt><a name="997573"> </a><code>vfsErrVolumeBadRef </code></dt>
</dl>

<p><a name="997576"> </a>For descriptions of all VFS Manager error codes, see <a href="CRef_VFSMgr.html#998756">"VFS Manager Error Codes."</a></p>
<h4>
  <a name="997578"> </a>Comments 
</h4>

<p><a name="997579"> </a>The file reference number (<code class="par">pFileRef</code>) obtained for a directory cannot be used for all functions. For example, it is not permitted (or logical) to read directly from an opened directory. </p>
<h4>
  <a name="997580"> </a>Compatibility 
</h4>

<p><a name="997581"> </a>VFS Manager version: All. <br>Palm OS version: 4.0 or later. Implemented only if the VFS Manager is present on the handheld (see <a href="CComp_Expansion.html#996231">"Checking for Expansion Cards"</a> in the <i>C/C++ Sync Suite Companion</i>). </p>
<h4>
  <a name="997591"> </a>See Also 
</h4>

<p><a name="997598"> </a><a href="CRef_VFSMgr.html#1108053"><code>VFSFileClose()</code></a>, <a href="CRef_VFSMgr.html#996951"><code>VFSDirEntryEnumerate()</code></a></p>

<h3 class="hbH3">
  <a name="997600"> </a>VFSFilePut Function <a href="#995934"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="997602"> </a>Purpose 
</h4>

<p><a name="997603"> </a>Reads a file from the desktop and copies it to an expansion card on the handheld.</p>
<h4>
  <a name="997604"> </a>Declared In 
</h4>
<code>VFSMgr.h<a name="997605"> </a></code><h4>
  <a name="997606"> </a>Prototype 
</h4>
<pre class="proto"><a name="997607"></a>SInt32 VFSFilePut (
   UInt16 <code class="par">volRefNum</code>,
   const char <code class="par">*pszDevicePathName</code>,
   const char <code class="par">*pszDiskPathName</code>
)
</pre>
<h4>
  <a name="997608"> </a>Parameters 
</h4>

<dl>
<dt><a name="997609"> </a><code>&rarr;  <i>volRefNum</i></code></dt>
<dd><a name="997610"> </a>Volume reference number (passed back by <a href="CRef_VFSMgr.html#998396"><code>VFSVolumeEnumerate()</code></a>) of the volume on which to put the file. </dd>

<dt><a name="997614"> </a><code>&rarr;  <i>pszDevicePathName</i></code></dt>
<dd><a name="997615"> </a>Full path and filename of the destination file on the handheld. All parts of the path, except the file, must exist. Can also be set to <code>NULL</code> (see "Comments" below). </dd>

<dt><a name="997616"> </a><code>&rarr;  <i>pszDiskPathName</i></code></dt>
<dd><a name="997617"> </a>Full path and filename for the file to be read from the desktop. </dd>

</dl>
<h4>
  <a name="997618"> </a>Returns 
</h4>

<p><a name="997619"> </a>If successful, returns 0. </p>

<p><a name="997620"> </a>If unsuccessful, returns one of the following error codes: </p>

<dl>
<dt><a name="997621"> </a><code>expErrNotOpen </code></dt>
<dt><a name="997622"> </a><code>SYNCERR_COMM_NOT_INIT </code></dt>
<dt><a name="997623"> </a><code>SYNCERR_REMOTE_BAD_ARG </code></dt>
<dt><a name="997624"> </a><code>vfsErrBadName </code></dt>
<dt><a name="997625"> </a><code>vfsErrDirectoryNotFound </code></dt>
<dt><a name="997626"> </a><code>vfsErrDiskFileAccess </code></dt>
<dt><a name="997627"> </a><code>vfsErrFileAccessOther </code></dt>
<dt><a name="997628"> </a><code>vfsErrFileAlreadyExists </code></dt>
<dt><a name="997629"> </a><code>vfsErrFileNotFound </code></dt>
<dt><a name="997630"> </a><code>vfsErrFilePermissionDenied</code></dt>
<dt><a name="997631"> </a><code>vfsErrInvalidOperation </code></dt>
<dt><a name="997632"> </a><code>vfsErrNoFileSystem </code></dt>
<dt><a name="997633"> </a><code>vfsErrVolumeBadRef </code></dt>
<dt><a name="997634"> </a><code>vfsErrVolumeFull</code></dt>
</dl>

<p><a name="997637"> </a>For descriptions of all VFS Manager error codes, see <a href="CRef_VFSMgr.html#998756">"VFS Manager Error Codes."</a></p>
<h4>
  <a name="997639"> </a>Comments 
</h4>

<p><a name="997640"> </a>The behavior of this function depends on whether a destination path is specified:</p>
<ul type="disc">
  <li><a name="997641"> </a>If <code class="par">pszDevicePathName</code> is specified, all parts of the path, except the filename, must already exist. 
  <ul type="disc">
    <li><a name="997642"> </a>If the full path exists, this function copies the file to specified location. 
    <li><a name="997643"> </a>If the full path does <i>not</i> exist, this function fails and returns an error. 
  </ul>
  <li><a name="997644"> </a>If <code class="par">pszDevicePathName</code> is <code>NULL</code> or points to an empty string: 
  <ul type="disc">
    <li><a name="997645"> </a>If a default directory is registered for this file type, the VFS Manager ensures that the entire path exists&#8212creating the directories leading up to the default directory, if necessary&#8212and puts the file in the default directory.
    <li><a name="997646"> </a>If no default directory is registered for this file type, this function returns <code>vfsErrDirectoryNotFound</code>. 
  </ul>
</ul>

<p><a name="997647"> </a>If the path exists in either of the above cases, this function copies the file specified by <code class="par">pszDiskPathName</code> to the destination on the expansion card. If the file already exists at the destination, this function overwrites it with the one specified by <code class="par">pszDiskPathName</code>. </p>
<h4>
  <a name="997648"> </a>Compatibility 
</h4>

<p><a name="997649"> </a>VFS Manager version: All. <br>Palm OS version: 4.0 or later. Implemented only if the VFS Manager is present on the handheld (see <a href="CComp_Expansion.html#996231">"Checking for Expansion Cards"</a> in the <i>C/C++ Sync Suite Companion</i>). </p>
<h4>
  <a name="997659"> </a>See Also 
</h4>

<p><a name="997666"> </a><a href="CRef_VFSMgr.html#998225"><code>VFSGetDefaultDirectory()</code></a>, <a href="CRef_VFSMgr.html#997357"><code>VFSFileGet()</code></a></p>

<h3 class="hbH3">
  <a name="997668"> </a>VFSFileRead Function <a href="#995934"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="997670"> </a>Purpose 
</h4>

<p><a name="997671"> </a>Reads data from a file into the specified buffer. </p>
<h4>
  <a name="997672"> </a>Declared In 
</h4>
<code>VFSMgr.h<a name="997673"> </a></code><h4>
  <a name="997674"> </a>Prototype 
</h4>
<pre class="proto"><a name="997675"></a>SInt32 VFSFileRead (
   FileRef <code class="par">fileRef</code>,
   UInt32 <code class="par">numBytes</code>,
   void <code class="par">*pBuffer</code>,
   UInt32 <code class="par">*pNumBytesRead</code>
)
</pre>
<h4>
  <a name="997676"> </a>Parameters 
</h4>

<dl>
<dt><a name="997677"> </a><code>&rarr;  <i>fileRef</i></code></dt>
<dd><a name="997681"> </a>File reference number passed back by <a href="CRef_VFSMgr.html#997531"><code>VFSFileOpen()</code></a>.</dd>

<dt><a name="997682"> </a><code>&rarr;  <i>numBytes</i></code></dt>
<dd><a name="997683"> </a>Number of bytes to read.</dd>

<dt><a name="997684"> </a><code>&larr;  <i>pBuffer</i></code></dt>
<dd><a name="997685"> </a>A pointer to the destination memory chunk on the desktop where the data is stored. The caller must preallocate this buffer to hold at least <code class="par">numBytes</code> characters.</dd>

<dt><a name="997686"> </a><code>&larr;  <i>pNumBytesRead</i></code></dt>
<dd><a name="997687"> </a>A pointer to an unsigned integer that reflects the number of bytes actually read. This value is set on return and does not need to be initialized. If no bytes are read, the value is set to zero.</dd>

</dl>
<h4>
  <a name="997688"> </a>Returns 
</h4>

<p><a name="997689"> </a>If successful, returns 0. </p>

<p><a name="997690"> </a>If unsuccessful, returns one of the following error codes: </p>

<dl>
<dt><a name="997691"> </a><code>expErrNotOpen </code></dt>
<dt><a name="997692"> </a><code>SYNCERR_COMM_NOT_INIT </code></dt>
<dt><a name="997693"> </a><code>vfsErrFileBadRef </code></dt>
<dt><a name="997694"> </a><code>vfsErrFileEOF </code></dt>
<dt><a name="997695"> </a><code>vfsErrFilePermissionDenied </code></dt>
<dt><a name="997696"> </a><code>vfsErrInvalidOperation </code></dt>
<dt><a name="997697"> </a><code>vfsErrIsADirectory </code></dt>
<dt><a name="997698"> </a><code>vfsErrNoFileSystem </code></dt>
</dl>

<p><a name="997701"> </a>For descriptions of all VFS Manager error codes, see <a href="CRef_VFSMgr.html#998756">"VFS Manager Error Codes."</a></p>
<h4>
  <a name="997703"> </a>Comments 
</h4>

<p><a name="997704"> </a>This function operates only on files and cannot be used with directories; use <a href="CRef_VFSMgr.html#996951"><code>VFSDirEntryEnumerate()</code></a> to explore the contents of a directory.</p>
<h4>
  <a name="997708"> </a>Compatibility 
</h4>

<p><a name="997709"> </a>VFS Manager version: All. <br>Palm OS version: 4.0 or later. Implemented only if the VFS Manager is present on the handheld (see <a href="CComp_Expansion.html#996231">"Checking for Expansion Cards"</a> in the <i>C/C++ Sync Suite Companion</i>). </p>
<h4>
  <a name="997719"> </a>See Also 
</h4>

<p><a name="997726"> </a><a href="CRef_VFSMgr.html#998133"><code>VFSFileWrite()</code></a>, <a href="CRef_VFSMgr.html#998297"><code>VFSImportDatabaseFromFile()</code></a> </p>

<h3 class="hbH3">
  <a name="997728"> </a>VFSFileRename Function <a href="#995934"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="997730"> </a>Purpose 
</h4>

<p><a name="997731"> </a>Renames a closed file or directory. </p>
<h4>
  <a name="997732"> </a>Declared In 
</h4>
<code>VFSMgr.h<a name="997733"> </a></code><h4>
  <a name="997734"> </a>Prototype 
</h4>
<pre class="proto"><a name="997735"></a>SInt32 VFSFileRename (
   UInt16 <code class="par">volRefNum</code>,
   const char <code class="par">*pszPathName</code>,
   const char <code class="par">*pszNewName</code>
)
</pre>
<h4>
  <a name="997736"> </a>Parameters 
</h4>

<dl>
<dt><a name="997737"> </a><code>&rarr;  <i>volRefNum</i></code></dt>
<dd><a name="997738"> </a>Volume reference number (passed back by <a href="CRef_VFSMgr.html#998396"><code>VFSVolumeEnumerate()</code></a>) of the volume on which to rename the file. </dd>

<dt><a name="997742"> </a><code>&rarr;  <i>pszPathName</i></code></dt>
<dd><a name="997743"> </a>Pointer to the full path of the file or directory to rename. </dd>

<dt><a name="997744"> </a><code>&rarr;  <i>pszNewName</i></code></dt>
<dd><a name="997745"> </a>Pointer to the new filename. Note that this is the name of the file only and does not include the path to the file. </dd>

</dl>
<h4>
  <a name="997746"> </a>Returns 
</h4>

<p><a name="997747"> </a>If successful, returns 0. </p>

<p><a name="997748"> </a>If unsuccessful, returns one of the following error codes: </p>

<dl>
<dt><a name="997749"> </a><code>expErrNotOpen</code></dt>
<dt><a name="997750"> </a><code>SYNCERR_COMM_NOT_INIT </code></dt>
<dt><a name="997751"> </a><code>SYNCERR_REMOTE_BAD_ARG </code></dt>
<dt><a name="997752"> </a><code>vfsErrBadName</code></dt>
<dt><a name="997753"> </a><code>vfsErrFileAlreadyExists</code></dt>
<dt><a name="997754"> </a><code>vfsErrFileNotFound</code></dt>
<dt><a name="997755"> </a><code>vfsErrFilePermissionDenied</code></dt>
<dt><a name="997756"> </a><code>vfsErrFileStillOpen</code></dt>
<dt><a name="997757"> </a><code>vfsErrInvalidOperation </code></dt>
<dt><a name="997758"> </a><code>vfsErrNoFileSystem </code></dt>
<dt><a name="997759"> </a><code>vfsErrVolumeBadRef</code></dt>
<dt><a name="997760"> </a><code>vfsErrVolumeFull</code></dt>
</dl>

<p><a name="997763"> </a>For descriptions of all VFS Manager error codes, see <a href="CRef_VFSMgr.html#998756">"VFS Manager Error Codes."</a></p>
<h4>
  <a name="997765"> </a>Comments 
</h4>

<p><a name="997766"> </a>This function cannot be used to move a file to another location within the file system. This function returns <code>vfsErrBadName</code> if either <code class="par">pszPathName</code> or <code class="par">pszNewName</code> is invalid, or if the string pointed to by <code class="par">pszNewName</code> is a path rather than a filename. </p>
<h4>
  <a name="997767"> </a>Example 
</h4>

<p><a name="997768"> </a>Below is an example of how to use <code>VFSFileRename()</code>. Note that the renamed file remains in the <code>/PALM/Programs</code> directory; <code>VFSFileRename()</code> can't be used to move files from one directory to another.</p>

<div class="CodeRule"><hr></div><pre class="CodeBlock">
// volRefNum must have been previously defined; most likely,<a name="997769"> </a>
// it was returned by VFSVolumeEnumerate. <a name="997770"> </a>
<a name="997771"> </a>
err = <b>VFSFileRename</b> (volRefNum, "/PALM/Programs/foo.prc",<a name="997772"> </a>
   "bar.prc");<a name="997773"> </a>
if (err != 0) {<a name="997774"> </a>
   // Handle error...<a name="997775"> </a>
}<a name="997776"> </a>
</pre><div class="CodeRule"><hr></div>

<h4>
  <a name="997777"> </a>Compatibility 
</h4>

<p><a name="997778"> </a>VFS Manager version: All. <br>Palm OS version: 4.0 or later. Implemented only if the VFS Manager is present on the handheld (see <a href="CComp_Expansion.html#996231">"Checking for Expansion Cards"</a> in the <i>C/C++ Sync Suite Companion</i>). </p>
<h4>
  <a name="997788"> </a>See Also 
</h4>

<p><a name="997795"> </a><a href="CRef_VFSMgr.html#997171"><code>VFSFileCreate()</code></a>, <a href="CRef_VFSMgr.html#997251"><code>VFSFileDelete()</code></a> </p>

<h3 class="hbH3">
  <a name="997797"> </a>VFSFileResize Function <a href="#995934"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="997799"> </a>Purpose 
</h4>

<p><a name="997800"> </a>Changes the size of an open file.</p>
<h4>
  <a name="997801"> </a>Declared In 
</h4>
<code>VFSMgr.h<a name="997802"> </a></code><h4>
  <a name="997803"> </a>Prototype 
</h4>
<pre class="proto"><a name="997804"></a>SInt32 VFSFileResize (
   FileRef <code class="par">fileRef</code>,
   UInt32 <code class="par">ui32NewSize</code>
)
</pre>
<h4>
  <a name="997805"> </a>Parameters 
</h4>

<dl>
<dt><a name="997806"> </a><code>&rarr;  <i>fileRef</i></code></dt>
<dd><a name="997810"> </a>File reference number passed back from <a href="CRef_VFSMgr.html#997531"><code>VFSFileOpen()</code></a>.</dd>

<dt><a name="997811"> </a><code>&rarr;  <i>ui32NewSize</i></code></dt>
<dd><a name="997812"> </a>The desired new size of the file. This can be larger or smaller than the current file size.</dd>

</dl>
<h4>
  <a name="997813"> </a>Returns 
</h4>

<p><a name="997814"> </a>If successful, returns 0. </p>

<p><a name="997815"> </a>If unsuccessful, returns one of the following error codes: </p>

<dl>
<dt><a name="997816"> </a><code>expErrNotOpen</code></dt>
<dt><a name="997817"> </a><code>SYNCERR_COMM_NOT_INIT </code></dt>
<dt><a name="997818"> </a><code>vfsErrFileBadRef</code></dt>
<dt><a name="997819"> </a><code>vfsErrInvalidOperation </code></dt>
<dt><a name="997820"> </a><code>vfsErrIsADirectory</code></dt>
<dt><a name="997821"> </a><code>vfsErrNoFileSystem </code></dt>
<dt><a name="997822"> </a><code>vfsErrVolumeFull</code></dt>
</dl>

<p><a name="997825"> </a>For descriptions of all VFS Manager error codes, see <a href="CRef_VFSMgr.html#998756">"VFS Manager Error Codes."</a></p>
<h4>
  <a name="997827"> </a>Comments 
</h4>

<p><a name="997828"> </a>If the resizing of the file would make the current file pointer point beyond the end of the file, this function sets the file pointer to the end of the file.</p>

<p><a name="997829"> </a>This function operates only on files and cannot be used with directories.</p>
<h4>
  <a name="997830"> </a>Compatibility 
</h4>

<p><a name="997831"> </a>VFS Manager version: All. <br>Palm OS version: 4.0 or later. Implemented only if the VFS Manager is present on the handheld (see <a href="CComp_Expansion.html#996231">"Checking for Expansion Cards"</a> in the <i>C/C++ Sync Suite Companion</i>). </p>
<h4>
  <a name="997841"> </a>See Also 
</h4>

<p><a name="997845"> </a><a href="CRef_VFSMgr.html#998028"><code>VFSFileSize()</code></a> </p>

<h3 class="hbH3">
  <a name="997847"> </a>VFSFileSeek Function <a href="#995934"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="997849"> </a>Purpose 
</h4>

<p><a name="997850"> </a>Sets the position from which to read or write within an open file.</p>
<h4>
  <a name="997851"> </a>Declared In 
</h4>
<code>VFSMgr.h<a name="997852"> </a></code><h4>
  <a name="997853"> </a>Prototype 
</h4>
<pre class="proto"><a name="997854"></a>SInt32 VFSFileSeek (
   FileRef <code class="par">fileRef</code>,
   FileOrigin <code class="par">origin</code>,
   SInt32 <code class="par">offset</code>
)
</pre>
<h4>
  <a name="997855"> </a>Parameters 
</h4>

<dl>
<dt><a name="997856"> </a><code>&rarr;  <i>fileRef</i></code></dt>
<dd><a name="997860"> </a>File reference number passed back from <a href="CRef_VFSMgr.html#997531"><code>VFSFileOpen()</code></a>.</dd>

<dt><a name="997861"> </a><code>&rarr;  <i>origin</i></code></dt>
<dd><a name="997862"> </a>Origin to use when calculating the new position. The <code>offset</code> parameter indicates the desired new position relative to this origin, which must be one of the values defined in <a href="CRef_VFSMgr.html#996550">"Seek Origins."</a> </dd>

<dt><a name="997866"> </a><code>&rarr;  <i>offset</i></code></dt>
<dd><a name="997867"> </a>Offset, either positive or negative, from the origin to which to set the current position. A value of zero positions you at the specified origin.</dd>

</dl>
<h4>
  <a name="997868"> </a>Returns 
</h4>

<p><a name="997869"> </a>If successful, returns 0. </p>

<p><a name="997870"> </a>If unsuccessful, returns one of the following error codes: </p>

<dl>
<dt><a name="997871"> </a><code>expErrNotOpen </code></dt>
<dt><a name="997872"> </a><code>SYNCERR_COMM_NOT_INIT </code></dt>
<dt><a name="997873"> </a><code>SYNCERR_REMOTE_BAD_ARG </code></dt>
<dt><a name="997874"> </a><code>vfsErrFileBadRef </code></dt>
<dt><a name="997875"> </a><code>vfsErrFileEOF </code></dt>
<dt><a name="997876"> </a><code>vfsErrInvalidOperation </code></dt>
<dt><a name="997877"> </a><code>vfsErrIsADirectory </code></dt>
<dt><a name="997878"> </a><code>vfsErrNoFileSystem </code></dt>
</dl>

<p><a name="997881"> </a>For descriptions of all VFS Manager error codes, see <a href="CRef_VFSMgr.html#998756">"VFS Manager Error Codes."</a></p>
<h4>
  <a name="997883"> </a>Comments 
</h4>

<p><a name="997884"> </a>If the resulting position of the file pointer would be beyond the end of the file, this function sets the position to the end of the file. Similarly, if the resulting position of the file pointer would be before the beginning of the file, this function sets the position to the beginning of the file. </p>

<p><a name="997885"> </a>This function operates only on files and cannot be used with directories.</p>
<h4>
  <a name="997886"> </a>Compatibility 
</h4>

<p><a name="997887"> </a>VFS Manager version: All. <br>Palm OS version: 4.0 or later. Implemented only if the VFS Manager is present on the handheld (see <a href="CComp_Expansion.html#996231">"Checking for Expansion Cards"</a> in the <i>C/C++ Sync Suite Companion</i>). </p>
<h4>
  <a name="997897"> </a>See Also 
</h4>

<p><a name="997904"> </a><a href="CRef_VFSMgr.html#998028"><code>VFSFileSize()</code></a>, <a href="CRef_VFSMgr.html#998082"><code>VFSFileTell()</code></a> </p>

<h3 class="hbH3">
  <a name="997906"> </a>VFSFileSetAttributes Function <a href="#995934"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="997908"> </a>Purpose 
</h4>

<p><a name="997909"> </a>Sets the attributes of an open file or directory.</p>
<h4>
  <a name="997910"> </a>Declared In 
</h4>
<code>VFSMgr.h<a name="997911"> </a></code><h4>
  <a name="997912"> </a>Prototype 
</h4>
<pre class="proto"><a name="997913"></a>SInt32 VFSFileSetAttributes (
   FileRef <code class="par">fileRef</code>,
   UInt32 <code class="par">ui32Attributes</code>
)
</pre>
<h4>
  <a name="997914"> </a>Parameters 
</h4>

<dl>
<dt><a name="997915"> </a><code>&rarr;  <i>fileRef</i></code></dt>
<dd><a name="997919"> </a>File reference number passed back from <a href="CRef_VFSMgr.html#997531"><code>VFSFileOpen()</code></a>.</dd>

<dt><a name="997920"> </a><code>&rarr;  <i>ui32Attributes</i></code></dt>
<dd><a name="997923"> </a>Attributes to associate with the file or directory. See <a href="CRef_VFSMgr.html#996392">"File and Directory Attributes"</a> for a list of values you can use when setting this parameter. </dd>

</dl>
<h4>
  <a name="997925"> </a>Returns 
</h4>

<p><a name="997926"> </a>If successful, returns 0. </p>

<p><a name="997927"> </a>If unsuccessful, returns one of the following error codes: </p>

<dl>
<dt><a name="997928"> </a><code>expErrNotOpen</code></dt>
<dt><a name="997929"> </a><code>SYNCERR_COMM_NOT_INIT </code></dt>
<dt><a name="997930"> </a><code>SYNCERR_REMOTE_BAD_ARG </code></dt>
<dt><a name="997931"> </a><code>vfsErrFileBadRef </code></dt>
<dt><a name="997932"> </a><code>vfsErrInvalidOperation </code></dt>
<dt><a name="997933"> </a><code>vfsErrNoFileSystem </code></dt>
</dl>

<p><a name="997936"> </a>For descriptions of all VFS Manager error codes, see <a href="CRef_VFSMgr.html#998756">"VFS Manager Error Codes."</a></p>
<h4>
  <a name="997938"> </a>Comments 
</h4>

<p><a name="997939"> </a>You cannot use this function to set the <code>vfsFileAttrDirectory</code> or <code>vfsFileAttrVolumeLabel</code> attributes. The <code>vfsFileAttrDirectory</code> is set when you call <a href="CRef_VFSMgr.html#996887"><code>VFSDirCreate()</code></a>. The <code>vfsFileAttrVolumeLabel</code> attribute is set when you call <a href="CRef_VFSMgr.html#998644"><code>VFSVolumeSetLabel()</code></a>.</p>
<h4>
  <a name="997946"> </a>Compatibility 
</h4>

<p><a name="997947"> </a>VFS Manager version: All. <br>Palm OS version: 4.0 or later. Implemented only if the VFS Manager is present on the handheld (see <a href="CComp_Expansion.html#996231">"Checking for Expansion Cards"</a> in the <i>C/C++ Sync Suite Companion</i>). </p>
<h4>
  <a name="997957"> </a>See Also 
</h4>

<p><a name="997964"> </a><a href="CRef_VFSMgr.html#997415"><code>VFSFileGetAttributes()</code></a>, <a href="CRef_VFSMgr.html#997966"><code>VFSFileSetDate()</code></a> </p>

<h3 class="hbH3">
  <a name="997966"> </a>VFSFileSetDate Function <a href="#995934"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="997968"> </a>Purpose 
</h4>

<p><a name="997969"> </a>Changes the dates of an open file or directory.</p>
<h4>
  <a name="997970"> </a>Declared In 
</h4>
<code>VFSMgr.h<a name="997971"> </a></code><h4>
  <a name="997972"> </a>Prototype 
</h4>
<pre class="proto"><a name="997973"></a>SInt32 VFSFileSetDate (
   FileRef <code class="par">fileRef</code>,
   UInt16 <code class="par">whichDate</code>,
   UInt32 <code class="par">ui32Date</code>
)
</pre>
<h4>
  <a name="997974"> </a>Parameters 
</h4>

<dl>
<dt><a name="997975"> </a><code>&rarr;  <i>fileRef</i></code></dt>
<dd><a name="997979"> </a>File reference number passed back in <a href="CRef_VFSMgr.html#997531"><code>VFSFileOpen()</code></a>.</dd>

<dt><a name="997980"> </a><code>&rarr;  <i>whichDate</i></code></dt>
<dd><a name="997981"> </a>Specifies which date&#8212creation, modification, or last access&#8212to modify. Supply one of the constants defined in <a href="CRef_VFSMgr.html#996304">"Date Types."</a> </dd>

<dd><a name="997985"> </a>Note that not all file systems are required to support all date types. If the supplied date type is not supported by the file system, <a href="CRef_VFSMgr.html#997471"><code>VFSFileGetDate()</code></a> returns <code>expErrUnsupportedOperation</code>. </dd>

<dt><a name="997989"> </a><code>&rarr;  <i>ui32Date</i></code></dt>
<dd><a name="997990"> </a>The new date. Express this parameter in the standard Palm OS date format&#8212the number of seconds since midnight (00:00:00) January 1, 1904. </dd>

</dl>
<h4>
  <a name="997991"> </a>Returns 
</h4>

<p><a name="997992"> </a>If successful, returns 0. </p>

<p><a name="997993"> </a>If unsuccessful, returns one of the following error codes: </p>

<dl>
<dt><a name="997994"> </a><code>expErrNotOpen</code></dt>
<dt><a name="997995"> </a><code>expErrUnsupportedOperation </code></dt>
<dt><a name="997996"> </a><code>SYNCERR_COMM_NOT_INIT </code></dt>
<dt><a name="997997"> </a><code>SYNCERR_REMOTE_BAD_ARG </code></dt>
<dt><a name="997998"> </a><code>vfsErrFileBadRef</code></dt>
<dt><a name="997999"> </a><code>vfsErrFilePermissionDenied</code></dt>
<dt><a name="998000"> </a><code>vfsErrInvalidOperation </code></dt>
<dt><a name="998001"> </a><code>vfsErrNoFileSystem </code></dt>
</dl>

<p><a name="998004"> </a>For descriptions of all VFS Manager error codes, see <a href="CRef_VFSMgr.html#998756">"VFS Manager Error Codes."</a></p>
<h4>
  <a name="998006"> </a>Comments 
</h4>

<p><a name="998007"> </a>If the <code class="par">whichDate</code> parameter is not one of the defined date type constants, this function returns <code>SYNCERR_REMOTE_BAD_ARG</code>. However, if <code class="par">whichDate</code> is one of the defined constants but is not one supported by the file system, this function returns <code>expErrUnsupportedOperation</code>. </p>
<h4>
  <a name="998008"> </a>Compatibility 
</h4>

<p><a name="998009"> </a>VFS Manager version: All. <br>Palm OS version: 4.0 or later. Implemented only if the VFS Manager is present on the handheld (see <a href="CComp_Expansion.html#996231">"Checking for Expansion Cards"</a> in the <i>C/C++ Sync Suite Companion</i>). </p>
<h4>
  <a name="998019"> </a>See Also 
</h4>

<p><a name="998026"> </a><a href="CRef_VFSMgr.html#997471"><code>VFSFileGetDate()</code></a>, <a href="CRef_VFSMgr.html#997906"><code>VFSFileSetAttributes()</code></a> </p>

<h3 class="hbH3">
  <a name="998028"> </a>VFSFileSize Function <a href="#995934"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="998030"> </a>Purpose 
</h4>

<p><a name="998031"> </a>Gets the size of an open file.</p>
<h4>
  <a name="998032"> </a>Declared In 
</h4>
<code>VFSMgr.h<a name="998033"> </a></code><h4>
  <a name="998034"> </a>Prototype 
</h4>
<pre class="proto"><a name="998035"></a>SInt32 VFSFileSize (
   FileRef <code class="par">fileRef</code>,
   UInt32 <code class="par">*pui32FileSize</code>
)
</pre>
<h4>
  <a name="998036"> </a>Parameters 
</h4>

<dl>
<dt><a name="998037"> </a><code>&rarr;  <i>fileRef</i></code></dt>
<dd><a name="998041"> </a>File reference number passed back from <a href="CRef_VFSMgr.html#997531"><code>VFSFileOpen()</code></a>.</dd>

<dt><a name="998042"> </a><code>&larr;  <i>pui32FileSize</i></code></dt>
<dd><a name="998043"> </a>Pointer to the size of the open file.</dd>

</dl>
<h4>
  <a name="998044"> </a>Returns 
</h4>

<p><a name="998045"> </a>If successful, returns 0. </p>

<p><a name="998046"> </a>If unsuccessful, returns one of the following error codes: </p>

<dl>
<dt><a name="998047"> </a><code>expErrNotOpen</code></dt>
<dt><a name="998048"> </a><code>SYNCERR_COMM_NOT_INIT </code></dt>
<dt><a name="998049"> </a><code>vfsErrFileBadRef</code></dt>
<dt><a name="998050"> </a><code>vfsErrInvalidOperation </code></dt>
<dt><a name="998051"> </a><code>vfsErrIsADirectory</code></dt>
<dt><a name="998052"> </a><code>vfsErrNoFileSystem </code></dt>
</dl>

<p><a name="998055"> </a>For descriptions of all VFS Manager error codes, see <a href="CRef_VFSMgr.html#998756">"VFS Manager Error Codes."</a></p>
<h4>
  <a name="998057"> </a>Comments 
</h4>

<p><a name="998058"> </a>This function operates only on files and cannot be used with directories. </p>
<h4>
  <a name="998059"> </a>Compatibility 
</h4>

<p><a name="998060"> </a>VFS Manager version: All. <br>Palm OS version: 4.0 or later. Implemented only if the VFS Manager is present on the handheld (see <a href="CComp_Expansion.html#996231">"Checking for Expansion Cards"</a> in the <i>C/C++ Sync Suite Companion</i>). </p>
<h4>
  <a name="998070"> </a>See Also 
</h4>

<p><a name="998080"> </a><a href="CRef_VFSMgr.html#997797"><code>VFSFileResize()</code></a>, <a href="CRef_VFSMgr.html#998082"><code>VFSFileTell()</code></a>, <a href="CRef_VFSMgr.html#998709"><code>VFSVolumeSize()</code></a> </p>

<h3 class="hbH3">
  <a name="998082"> </a>VFSFileTell Function <a href="#995934"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="998084"> </a>Purpose 
</h4>

<p><a name="998085"> </a>Gets the current position of the file pointer within an open file. </p>
<h4>
  <a name="998086"> </a>Declared In 
</h4>
<code>VFSMgr.h<a name="998087"> </a></code><h4>
  <a name="998088"> </a>Prototype 
</h4>
<pre class="proto"><a name="998089"></a>SInt32 VFSFileTell (
   FileRef <code class="par">fileRef</code>,
   UInt32 <code class="par">*pFilePos</code>
)
</pre>
<h4>
  <a name="998090"> </a>Parameters 
</h4>

<dl>
<dt><a name="998091"> </a><code>&rarr;  <i>fileRef</i></code></dt>
<dd><a name="998095"> </a>File reference number passed back from <a href="CRef_VFSMgr.html#997531"><code>VFSFileOpen()</code></a>.</dd>

<dt><a name="998096"> </a><code>&larr;  <i>pFilePos</i></code></dt>
<dd><a name="998097"> </a>Pointer to the current position of the file pointer.</dd>

</dl>
<h4>
  <a name="998098"> </a>Returns 
</h4>

<p><a name="998099"> </a>If successful, returns 0. </p>

<p><a name="998100"> </a>If unsuccessful, returns one of the following error codes: </p>

<dl>
<dt><a name="998101"> </a><code>expErrNotOpen</code></dt>
<dt><a name="998102"> </a><code>SYNCERR_COMM_NOT_INIT </code></dt>
<dt><a name="998103"> </a><code>vfsErrFileBadRef</code></dt>
<dt><a name="998104"> </a><code>vfsErrInvalidOperation </code></dt>
<dt><a name="998105"> </a><code>vfsErrIsADirectory</code></dt>
<dt><a name="998106"> </a><code>vfsErrNoFileSystem </code></dt>
</dl>

<p><a name="998109"> </a>For descriptions of all VFS Manager error codes, see <a href="CRef_VFSMgr.html#998756">"VFS Manager Error Codes."</a></p>
<h4>
  <a name="998111"> </a>Comments 
</h4>

<p><a name="998112"> </a>This function operates only on files and cannot be used with directories. </p>
<h4>
  <a name="998113"> </a>Compatibility 
</h4>

<p><a name="998114"> </a>VFS Manager version: All. <br>Palm OS version: 4.0 or later. Implemented only if the VFS Manager is present on the handheld (see <a href="CComp_Expansion.html#996231">"Checking for Expansion Cards"</a> in the <i>C/C++ Sync Suite Companion</i>). </p>
<h4>
  <a name="998124"> </a>See Also 
</h4>

<p><a name="998131"> </a><a href="CRef_VFSMgr.html#997847"><code>VFSFileSeek()</code></a>, <a href="CRef_VFSMgr.html#998028"><code>VFSFileSize()</code></a> </p>

<h3 class="hbH3">
  <a name="998133"> </a>VFSFileWrite Function <a href="#995934"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="998135"> </a>Purpose 
</h4>

<p><a name="998136"> </a>Writes data to an open file.</p>
<h4>
  <a name="998137"> </a>Declared In 
</h4>
<code>VFSMgr.h<a name="998138"> </a></code><h4>
  <a name="998139"> </a>Prototype 
</h4>
<pre class="proto"><a name="998140"></a>SInt32 VFSFileWrite (
   FileRef <code class="par">fileRef</code>,
   UInt32 <code class="par">numBytes</code>,
   const void <code class="par">*pDataBuf</code>,
   UInt32 <code class="par">*pNumBytesWritten</code>
)
</pre>
<h4>
  <a name="998141"> </a>Parameters 
</h4>

<dl>
<dt><a name="998142"> </a><code>&rarr;  <i>fileRef</i></code></dt>
<dd><a name="998146"> </a>File reference number passed back from <a href="CRef_VFSMgr.html#997531"><code>VFSFileOpen()</code></a>.</dd>

<dt><a name="998147"> </a><code>&rarr;  <i>numBytes</i></code></dt>
<dd><a name="998148"> </a>The number of bytes to write.</dd>

<dt><a name="998149"> </a><code>&rarr;  <i>pDataBuf</i></code></dt>
<dd><a name="998150"> </a>A pointer to a buffer containing the data to write.</dd>

<dt><a name="998151"> </a><code>&larr;  <i>pNumBytesWritten</i></code></dt>
<dd><a name="998152"> </a>A pointer to an unsigned integer that reflects the number of bytes actually written. This value is set on return and does not need to be initialized. If no bytes are written the value is set to zero. </dd>

</dl>
<h4>
  <a name="998153"> </a>Returns 
</h4>

<p><a name="998154"> </a>If successful, returns 0. </p>

<p><a name="998155"> </a>If unsuccessful, returns one of the following error codes: </p>

<dl>
<dt><a name="998156"> </a><code>expErrNotOpen</code></dt>
<dt><a name="998157"> </a><code>SYNCERR_COMM_NOT_INIT </code></dt>
<dt><a name="998158"> </a><code>SYNCERR_REMOTE_BAD_ARG </code></dt>
<dt><a name="998159"> </a><code>vfsErrFileBadRef</code></dt>
<dt><a name="998160"> </a><code>vfsErrFilePermissionDenied</code></dt>
<dt><a name="998161"> </a><code>vfsErrInvalidOperation </code></dt>
<dt><a name="998162"> </a><code>vfsErrIsADirectory</code></dt>
<dt><a name="998163"> </a><code>vfsErrNoFileSystem </code></dt>
<dt><a name="998164"> </a><code>vfsErrVolumeFull</code></dt>
</dl>

<p><a name="998167"> </a>For descriptions of all VFS Manager error codes, see <a href="CRef_VFSMgr.html#998756">"VFS Manager Error Codes."</a></p>
<h4>
  <a name="998169"> </a>Comments 
</h4>

<p><a name="998170"> </a>This function operates only on files and cannot be used with directories. </p>
<h4>
  <a name="998171"> </a>Compatibility 
</h4>

<p><a name="998172"> </a>VFS Manager version: All. <br>Palm OS version: 4.0 or later. Implemented only if the VFS Manager is present on the handheld (see <a href="CComp_Expansion.html#996231">"Checking for Expansion Cards"</a> in the <i>C/C++ Sync Suite Companion</i>). </p>
<h4>
  <a name="998182"> </a>See Also 
</h4>

<p><a name="998189"> </a><a href="CRef_VFSMgr.html#997042"><code>VFSExportDatabaseToFile()</code></a>, <a href="CRef_VFSMgr.html#997668"><code>VFSFileRead()</code></a> </p>

<h3 class="hbH3">
  <a name="998191"> </a>VFSGetAPIVersion Function <a href="#995934"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="998193"> </a>Purpose 
</h4>

<p><a name="998194"> </a>Retrieves the version of the Expansion Manager and VFS Manager APIs. </p>
<h4>
  <a name="998195"> </a>Declared In 
</h4>
<code>VFSMgr.h<a name="998196"> </a></code><h4>
  <a name="998197"> </a>Prototype 
</h4>
<pre class="proto"><a name="998198"></a>SInt32 VFSGetAPIVersion (
   UInt32 <code class="par">*pdwMajor</code>,
   UInt32 <code class="par">*pdwMinor</code>
)
</pre>
<h4>
  <a name="998199"> </a>Parameters 
</h4>

<dl>
<dt><a name="998200"> </a><code>&larr;  <i>pdwMajor</i></code></dt>
<dd><a name="998201"> </a>Pointer to variable for returning the <i>major</i> version number; pass <code>NULL</code> to ignore. </dd>

<dt><a name="998202"> </a><code>&larr;  <i>pdwMinor</i></code></dt>
<dd><a name="998203"> </a>Pointer to variable for returning the <i>minor</i> version number; pass <code>NULL</code> to ignore.</dd>

</dl>
<h4>
  <a name="998204"> </a>Returns 
</h4>

<p><a name="998205"> </a>Always returns 0. </p>
<h4>
  <a name="998206"> </a>Comments 
</h4>

<p><a name="998207"> </a>The Expansion Manager and VFS Manager APIs strive to maintain backward compatibility within a given <i>major</i> version number group. As new exported functions are added to the API s or critical bugs are fixed, the <i>minor</i> version number of the APIs will be incremented and the documentation of the new functions will identify the APIs version number where they were first available. Conduits can check the version number using the <code>VFSGetAPIVersion()</code> function. For example, if a conduit requires a bug fix for a particular VFS Manager function that was made in VFS Manager API version number 2.1, the conduit must call <code>VFSGetAPIVersion()</code> to make sure that the <i>major</i> number is 2 and the <i>minor</i> number is 1 or greater before making calls to the new function. </p>
<h4>
  <a name="998208"> </a>Compatibility 
</h4>

<p><a name="998209"> </a>VFS Manager version: All. <br>Palm OS version: 4.0 or later. Implemented only if the VFS Manager is present on the handheld (see <a href="CComp_Expansion.html#996231">"Checking for Expansion Cards"</a> in the <i>C/C++ Sync Suite Companion</i>). </p>
<h4>
  <a name="998219"> </a>See Also 
</h4>

<p><a name="998223"> </a><a href="CRef_VFSMgr.html#1138259">"Versions of the VFS Manager API"</a></p>

<h3 class="hbH3">
  <a name="998225"> </a>VFSGetDefaultDirectory Function <a href="#995934"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="998227"> </a>Purpose 
</h4>

<p><a name="998228"> </a>Retrieves the default directory on the given volume for files of a particular type.</p>
<h4>
  <a name="998229"> </a>Declared In 
</h4>
<code>VFSMgr.h<a name="998230"> </a></code><h4>
  <a name="998231"> </a>Prototype 
</h4>
<pre class="proto"><a name="998232"></a>SInt32 VFSGetDefaultDirectory (
   UInt16 <code class="par">volRefNum</code>,
   const char <code class="par">*pszFileType</code>,
   char <code class="par">*pszDirPath</code>,
   UInt16 <code class="par">*pwPathLen</code>
)
</pre>
<h4>
  <a name="998233"> </a>Parameters 
</h4>

<dl>
<dt><a name="998234"> </a><code>&rarr;  <i>volRefNum</i></code></dt>
<dd><a name="998235"> </a>Volume reference number passed back by <a href="CRef_VFSMgr.html#998396"><code>VFSVolumeEnumerate()</code></a>. </dd>

<dt><a name="998239"> </a><code>&rarr;  <i>pszFileType</i></code></dt>
<dd><a name="998240"> </a>A pointer to the requested file type, as a <code>NULL</code>-terminated string. The file type may either be a MIME media type/subtype pair, such as "image/jpeg", "text/plain", or "audio/basic"; or a file extension, such as ".jpeg". If you pass in a file extension, it must begin with a period '<code>.</code>'&#8212for example "<code>.prc</code>". </dd>

<dt><a name="998241"> </a><code>&larr;  <i>pszDirPath</i></code></dt>
<dd><a name="998242"> </a>A pointer to the buffer that receives the default directory path for the requested file type. The caller must allocate this buffer before calling this function. </dd>

<dt><a name="998243"> </a><code>&harr;  <i>pwPathLen</i></code></dt>
<dd><a name="998244"> </a>A pointer to the size of the path. On entry, set this to the size of <code class="par">pszDirPath</code> buffer. On return, reflects the number of bytes copied to <code class="par">pszDirPath</code>.</dd>

</dl>
<h4>
  <a name="998245"> </a>Returns 
</h4>

<p><a name="998246"> </a>If successful, returns 0. </p>

<p><a name="998247"> </a>If unsuccessful, returns one of the following error codes: </p>

<dl>
<dt><a name="998248"> </a><code>SYNCERR_COMM_NOT_INIT </code></dt>
<dt><a name="998249"> </a><code>SYNCERR_REMOTE_BAD_ARG </code></dt>
<dt><a name="998250"> </a><code>vfsErrBadName </code></dt>
<dt><a name="998251"> </a><code>vfsErrBufferOverflow</code></dt>
<dt><a name="998252"> </a><code>vfsErrFileNotFound</code></dt>
<dt><a name="998253"> </a><code>vfsErrInvalidOperation </code></dt>
</dl>

<p><a name="998256"> </a>For descriptions of all VFS Manager error codes, see <a href="CRef_VFSMgr.html#998756">"VFS Manager Error Codes."</a></p>
<h4>
  <a name="998258"> </a>Comments 
</h4>

<p><a name="998259"> </a>This function returns the complete path to the default directory registered for the specified file type. A default directory can be registered for each type of media supported. The directory should be registered under media and file type. (Note that this directory is typically a "root" directory for the file type; any subdirectories under this root directory should also be searched for files of the appropriate type.) If this function finds no match for either the specified media type for this volume or the requested file type, it returns <code>vfsErrFileNotFound</code>. </p>

<p><a name="998260"> </a>If a match is found, but the <code class="par">pszDirPath</code> buffer is too small to hold the resulting path string, this function returns <code>vfsErrBufferOverflow</code>. </p>

<p><a name="998261"> </a>This function can be used by an image viewer application, for example, to find the directory containing images without having to know what type of media the volume was on. This could be "<code>/DCIM</code>", "<code>/images</code>", or something else depending on the type of media.</p>
<h4>
  <a name="998262"> </a>Example 
</h4>

<p><a name="998263"> </a>This example illustrates how to use the <code>VFSGetDefaultDirectory()</code> function. </p>

<div class="CodeRule"><hr></div><pre class="CodeBlock">
char fileTypeStr [] = ".prc";<a name="998264"> </a>
char devicePathBuffer [MAX_PATH];<a name="998265"> </a>
UInt16 bufLen = sizeof (devicePathBuffer);<a name="998266"> </a>
<a name="998267"> </a>
SInt32 retval = <b>VFSGetDefaultDirectory</b> <a name="998268"> </a>
   (volRefNum, fileTypeStr, devicePathBuffer, &amp;bufLen); <a name="998269"> </a>
if (0 == retval)<a name="998270"> </a>
{<a name="998271"> </a>
   // Got the default directory.<a name="998272"> </a>
   // Perform further operations here. <a name="998273"> </a>
}<a name="998274"> </a>
else<a name="998275"> </a>
{<a name="998276"> </a>
   // Could not get the default path on the card:<a name="998277"> </a>
   // process error codes. <a name="998278"> </a>
}<a name="998279"> </a>
</pre><div class="CodeRule"><hr></div>

<h4>
  <a name="998280"> </a>Compatibility 
</h4>

<p><a name="998281"> </a>VFS Manager version: All. <br>Palm OS version: 4.0 or later. Implemented only if the VFS Manager is present on the handheld (see <a href="CComp_Expansion.html#996231">"Checking for Expansion Cards"</a> in the <i>C/C++ Sync Suite Companion</i>). </p>
<h4>
  <a name="998291"> </a>See Also 
</h4>

<p><a name="998295"> </a><a href="CRef_VFSMgr.html#996951"><code>VFSDirEntryEnumerate()</code></a> </p>

<h3 class="hbH3">
  <a name="998297"> </a>VFSImportDatabaseFromFile Function <a href="#995934"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="998299"> </a>Purpose 
</h4>

<p><a name="998300"> </a>Creates a database from the specified PDB or PRC file on an expansion card. Works only with classic databases.</p>
<h4>
  <a name="998301"> </a>Declared In 
</h4>
<code>VFSMgr.h<a name="998302"> </a></code><h4>
  <a name="998303"> </a>Prototype 
</h4>
<pre class="proto"><a name="998304"></a>SInt32 VFSImportDatabaseFromFile (
   UInt16 <code class="par">volRefNum</code>,
   const char <code class="par">*pszPathName</code>,
   UInt16 <code class="par">*pwCardNumber</code>,
   LocalID <code class="par">*pDbId</code>
)
</pre>
<h4>
  <a name="998305"> </a>Parameters 
</h4>

<dl>
<dt><a name="998306"> </a><code>&rarr;  <i>volRefNum</i></code></dt>
<dd><a name="998307"> </a>Volume reference number (passed back by <a href="CRef_VFSMgr.html#998396"><code>VFSVolumeEnumerate()</code></a>) of the volume from which to get the source file. </dd>

<dt><a name="998311"> </a><code>&rarr;  <i>pszPathName</i></code></dt>
<dd><a name="998312"> </a>A pointer to the full path and name of the source file to get.</dd>

<dt><a name="998313"> </a><code>&larr;  <i>pwCardNumber</i></code></dt>
<dd><a name="998314"> </a>A pointer to a variable that receives the <a href="Intro_Glossary.html#925551"><span style="color: #333;;  font-style: normal; font-weight: bold; text-decoration: underline; text-transform: none; vertical-align: baseline">memory card</span></a> number of the newly-created database. If the database already resides in the storage heap, the card number of the existing database is passed back and the error <code>SYNCERR_FILE_ALREADY_EXIST</code> is returned.</dd>

<dt><a name="998315"> </a><code>&larr;  <i>pDbId</i></code></dt>
<dd><a name="998316"> </a>A pointer to a variable that receives the database ID of the new database. If the database already resides in the storage heap, the database ID of the existing database is passed back and the error <code>SYNCERR_FILE_ALREADY_EXIST</code> is returned. </dd>

</dl>
<h4>
  <a name="998317"> </a>Returns 
</h4>

<p><a name="998318"> </a>If successful, returns 0. </p>

<p><a name="998319"> </a>If unsuccessful, returns one of the following error codes: </p>

<dl>
<dt><a name="998320"> </a><code>SYNCERR_COMM_NOT_INIT </code></dt>
<dt><a name="998321"> </a><code>SYNCERR_FILE_ALREADY_EXIST </code></dt>
<dt><a name="998322"> </a><code>SYNCERR_REMOTE_BAD_ARG </code></dt>
<dt><a name="998323"> </a><code>vfsErrBadName</code></dt>
<dt><a name="998324"> </a><code>vfsErrInvalidOperation </code></dt>
</dl>

<p><a name="998327"> </a>For descriptions of all VFS Manager error codes, see <a href="CRef_VFSMgr.html#998756">"VFS Manager Error Codes."</a></p>
<h4>
  <a name="998329"> </a>Comments 
</h4>

<p><a name="998330"> </a>This function imports a PDB or PRC file on an expansion card into a new database in the handheld storage heap. If the database already exists, this function passes back values in <code class="par">pwCardNumber</code> and <code class="par">pDbId</code> for the existing database and returns an error code of <code>SYNCERR_FILE_ALREADY_EXIST</code>. </p>

<p><a name="998331"> </a>This function is used, for example, to copy applications from a storage card to main memory.</p>
<div class="NINoteImportant"><hr>
  <a name="1111423"> </a> <b>IMPORTANT: </b> With VFS Manager API version 1.1, this function is deprecated for use with handhelds running Palm OS Cobalt; call <a href="CRef_VFSMgr.html#1107874"><code>VFSImportDatabaseFromFileEx()</code></a> instead. The reason for replacing this function is that memory card numbers are not supported by Palm OS Cobalt and local IDs are insufficient to identify schema databases and are cumbersome to identify extended and classic databases.<br><br>However, this function is still supported for use with Palm OS 4.x and Palm OS Garnet.
<hr>
</div>
<h4>
  <a name="998332"> </a>Example 
</h4>

<p><a name="998333"> </a>This example illustrates the use of the <code>VFSImportDatabaseFromFile()</code> function. </p>

<div class="CodeRule"><hr></div><pre class="CodeBlock">
SInt32 retval = <b>VFSImportDatabaseFromFile</b> (volRefNum, <a name="998334"> </a>
   "/Palm/Launcher/Contacts.pdb", &amp;cardNo, &amp;dBID);<a name="998335"> </a>
</pre><div class="CodeRule"><hr></div>

<h4>
  <a name="998336"> </a>Compatibility 
</h4>

<p><a name="998337"> </a>VFS Manager version: All. <br>Palm OS version: 4.0 or later. Implemented only if the VFS Manager is present on the handheld (see <a href="CComp_Expansion.html#996231">"Checking for Expansion Cards"</a> in the <i>C/C++ Sync Suite Companion</i>). </p>
<h4>
  <a name="998347"> </a>See Also 
</h4>

<p><a name="998354"> </a><a href="CRef_VFSMgr.html#997042"><code>VFSExportDatabaseToFile()</code></a>, <a href="CRef_VFSMgr.html#997668"><code>VFSFileRead()</code></a> </p>

<h3 class="hbH3">
  <a name="1107874"> </a>VFSImportDatabaseFromFileEx Function <a href="#995934"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="1107876"> </a>Purpose 
</h4>

<p><a name="1107877"> </a>Creates a database from the specified image file on an expansion card. Works with schema, extended, and classic databases only on handhelds running Palm OS Cobalt, version 6.0.1 or later.</p>
<h4>
  <a name="1107878"> </a>Declared In 
</h4>
<code>VFSMgr.h<a name="1107879"> </a></code><h4>
  <a name="1107880"> </a>Prototype 
</h4>
<pre class="proto"><a name="1107881"></a>SInt32 VFSImportDatabaseFromFileEx (
   UInt16 <code class="par">volRefNum</code>,
   char <code class="par">*pszPathName</code>,
   DBDatabaseInfo <code class="par">*pDbInfo</code>
)
</pre>
<h4>
  <a name="1107882"> </a>Parameters 
</h4>

<dl>
<dt><a name="1107883"> </a><code>&rarr;  <i>volRefNum</i></code></dt>
<dd><a name="1107884"> </a>Volume reference number (passed back by <a href="CRef_VFSMgr.html#998396"><code>VFSVolumeEnumerate()</code></a>) of the volume from which to get the source file. </dd>

<dt><a name="1107885"> </a><code>&rarr;  <i>pszPathName</i></code></dt>
<dd><a name="1107886"> </a>A pointer to the full path and name of the source file to get. Do not specify <code>NULL</code>.</dd>

<dt><a name="1108181"> </a><code>&larr;  <i>pDbInfo</i></code></dt>
<dd><a name="1108185"> </a>A pointer to a <a href="CRef_SyncCommon.html#1038263"><code>DBDatabaseInfo</code></a> structure. If successful, this structure contains values in all section 1 fields, which describe the database that this function created.</dd>

</dl>
<h4>
  <a name="1107889"> </a>Returns 
</h4>

<p><a name="1108207"> </a>If successful, returns 0. </p>

<p><a name="1108208"> </a>If unsuccessful, returns one of the following error codes: </p>

<dl>
<dt><a name="1108209"> </a><code>SYNCERR_COMM_NOT_INIT </code></dt>
<dt><a name="1108210"> </a><code>SYNCERR_FILE_ALREADY_EXIST </code></dt>
<dt><a name="1108211"> </a><code>SYNCERR_REMOTE_BAD_ARG </code></dt>
<dt><a name="1113141"> </a><code>SYNCERR_UNKNOWN_REQUEST</code></dt>
<dd><a name="1113142"> </a>The handheld is running a version of Palm OS that this function does not support. See "Compatibility" below.</dd>

<dt><a name="1108212"> </a><code>vfsErrBadName</code></dt>
<dt><a name="1108213"> </a><code>vfsErrInvalidOperation </code></dt>
</dl>

<p><a name="1108216"> </a>For descriptions of all VFS Manager error codes, see <a href="CRef_VFSMgr.html#998756">"VFS Manager Error Codes."</a></p>
<h4>
  <a name="1107891"> </a>Comments 
</h4>

<p><a name="1108395"> </a>This function imports an image file on an expansion card into a new database in the handheld storage heap. The file is an image of either a schema, extended, or classic database.</p>

<p><a name="1108423"> </a>This function does the opposite of <a href="CRef_VFSMgr.html#1106782"><code>VFSExportDatabaseToFileEx()</code></a>. Use it, for example, to copy applications or databases from an expansion card to primary storage on the handheld.</p>

<p><a name="1108432"> </a>This function is a replacement for <a href="CRef_VFSMgr.html#998297"><code>VFSImportDatabaseFromFile()</code></a>, which identifies databases only by memory card number and local ID. The reason for replacing this function is that memory card numbers are not supported by Palm OS Cobalt and local IDs are insufficient to identify schema databases and somewhat cumbersome to identify extended and classic databases.</p>
<h4>
  <a name="1112101"> </a>Example 
</h4>

<p><a name="1112102"> </a>This example illustrates the use of the <code>VFSImportDatabaseFromFileEx()</code> function.</p>

<div class="CodeRule"><hr></div><pre class="CodeBlock">
UInt16 volRefNum; // Get this via VFSVolumeEnumerate().<a name="1112131"> </a>
DBDatabaseInfo dbInfo;<a name="1112137"> </a>
<a name="1112111"> </a>
SInt32 retval = <b>VFSImportDatabaseFromFileEx</b> (volRefNum, <a name="1112104"> </a>
   "/Palm/Launcher/MySchemaDatabase.sdb", &amp;dbInfo);<a name="1112156"> </a>
</pre><div class="CodeRule"><hr></div>

<h4>
  <a name="1108449"> </a>Compatibility 
</h4>

<p><a name="1108450"> </a>VFS Manager version: 1.1 or later. <br>Palm OS version: 6.0.1 or later. Implemented only if the VFS Manager is present on the handheld (see <a href="CComp_Expansion.html#996231">"Checking for Expansion Cards"</a> in the <i>C/C++ Sync Suite Companion</i>). </p>
<h4>
  <a name="1107893"> </a>See Also 
</h4>

<p><a name="1107894"> </a><a href="CRef_SyncCommon.html#1038263"><code>DBDatabaseInfo</code></a>, <a href="CRef_VFSMgr.html#1106782"><code>VFSExportDatabaseToFileEx()</code></a></p>

<h3 class="hbH3">
  <a name="998356"> </a>VFSSupport Function <a href="#995934"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="998358"> </a>Purpose 
</h4>

<p><a name="998359"> </a>Determines whether the Expansion Manager and VFS Manager are present on the handheld, their version if present, and gets expansion slot and volume information. </p>
<h4>
  <a name="998360"> </a>Declared In 
</h4>
<code>VFSMgr.h<a name="998361"> </a></code><h4>
  <a name="998362"> </a>Prototype 
</h4>
<pre class="proto"><a name="998363"></a>SInt32 VFSSupport (
   UInt32 <code class="par">&amp;dwExpansionMgrVersion</code>,
   UInt32 <code class="par">&amp;dwVolumesAvailable</code>
)
</pre>
<h4>
  <a name="998364"> </a>Parameters 
</h4>

<dl>
<dt><a name="998365"> </a><code>&larr;  <i>dwExpansionMgrVersion</i></code></dt>
<dd><a name="998366"> </a>When this parameter passes back a zero value, no expansion slot is present. A nonzero value is the version of Expansion Manager on the handheld. The VFS Manager version number is identical.</dd>

<dt><a name="998367"> </a><code>&larr;  <i>dwVolumesAvailable</i></code></dt>
<dd><a name="998368"> </a>When this parameter passes back a zero value, either no file system is present on the card in the slot or no card is in the slot. A nonzero value is the number of volumes present on the card. </dd>

</dl>
<h4>
  <a name="998369"> </a>Returns 
</h4>

<p><a name="998370"> </a>If successful, returns 0. </p>

<p><a name="998371"> </a>If unsuccessful, returns one of the following error codes: </p>

<dl>
<dt><a name="998372"> </a><code>SYNCERR_BAD_ARG </code></dt>
</dl>

<p><a name="998375"> </a>For descriptions of all VFS Manager error codes, see <a href="CRef_VFSMgr.html#998756">"VFS Manager Error Codes."</a></p>
<h4>
  <a name="998377"> </a>Comments 
</h4>

<p><a name="998378"> </a>This information has already been obtained by the desktop VFS Manager, so no additional calls are made to the handheld at the time you call this function. If either pointer is <code>NULL</code>, this function returns <code>SYNCERR_BAD_ARG</code>. </p>
<h4>
  <a name="998379"> </a>Compatibility 
</h4>

<p><a name="998380"> </a>VFS Manager version: All. <br>Palm OS version: 4.0. </p>
<h4>
  <a name="998381"> </a>See Also 
</h4>

<p><a name="998387"> </a><a href="CRef_VFSMgr.html#998191"><code>VFSGetAPIVersion()</code></a>, <a href="CComp_Expansion.html#996231">"Checking for Expansion Cards"</a> in the <i>C/C++ Sync Suite Companion</i> </p>

<h3 class="hbH3">
  <a name="998396"> </a>VFSVolumeEnumerate Function <a href="#995934"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="998398"> </a>Purpose 
</h4>

<p><a name="998399"> </a>Enumerates the mounted volumes and retrieves a list of volume reference numbers.</p>
<h4>
  <a name="998400"> </a>Declared In 
</h4>
<code>VFSMgr.h<a name="998401"> </a></code><h4>
  <a name="998402"> </a>Prototype 
</h4>
<pre class="proto"><a name="998403"></a>SInt32 VFSVolumeEnumerate (
   UInt16 <code class="par">*pwNumVolumes</code>,
   UInt16 <code class="par">*pwVolRefList</code>
)
</pre>
<h4>
  <a name="998404"> </a>Parameters 
</h4>

<dl>
<dt><a name="998405"> </a><code>&larr;  <i>pwNumVolumes</i></code></dt>
<dd><a name="998406"> </a>A pointer to the number of volumes successfully enumerated. </dd>

<dt><a name="998407"> </a><code>&harr;  <i>pwVolRefList</i></code></dt>
<dd><a name="998408"> </a>On exit, a pointer to an array of volume reference numbers. If the caller passes in <code>NULL</code>, the function passes back no volume reference numbers. If <code>NULL</code> is not passed in, the caller must allocate sufficient space to hold all volume reference numbers. </dd>

</dl>
<h4>
  <a name="998409"> </a>Returns 
</h4>

<p><a name="998410"> </a>If successful, returns 0. </p>

<p><a name="998411"> </a>If unsuccessful, returns one of the following error codes: </p>

<dl>
<dt><a name="998412"> </a><code>expErrEnumerationEmpty </code></dt>
<dt><a name="998413"> </a><code>SYNCERR_COMM_NOT_INIT </code></dt>
<dt><a name="998414"> </a><code>vfsErrInvalidOperation </code></dt>
</dl>

<p><a name="998417"> </a>For descriptions of all VFS Manager error codes, see <a href="CRef_VFSMgr.html#998756">"VFS Manager Error Codes."</a></p>
<h4>
  <a name="998419"> </a>Comments 
</h4>

<p><a name="998420"> </a>This function passes back a list of reference numbers of all of the volumes that are mounted. The list can span across expansion cards, if multiple cards are present. To find which card and slot this volume is mounted from, call <a href="CRef_VFSMgr.html#998593"><code>VFSVolumeInfo()</code></a>. </p>

<p><a name="998424"> </a>Before calling <code>VFSVolumeEnumerate()</code> to get volume reference numbers, the caller must allocate enough space for the array pointed to by <code class="par">pwVolRefList</code>. If the caller passes in <code>NULL</code> for <code class="par">pwVolRefList</code>, the function returns only the number of volumes. Use this to allocate the array and call <code>VFSVolumeEnumerate()</code> again to get the volume reference numbers.</p>
<h4>
  <a name="998425"> </a>Example 
</h4>

<p><a name="998426"> </a>The following example shows how to use <code>VFSVolumeEnumerate()</code> to get the number of mounted volumes, allocate a buffer, and get the list of volume reference numbers. </p>

<div class="CodeRule"><hr></div><pre class="CodeBlock">
UInt16 numVolumes = 0; <a name="998427"> </a>
UInt16 *pwVolRefNumList;<a name="998428"> </a>
<a name="998429"> </a>
// The first call returns only the number of mounted volumes,<a name="998430"> </a>
// not their reference numbers.<a name="998431"> </a>
<b>VFSVolumeEnumerate</b> (&amp;numVolumes, NULL); <a name="998432"> </a>
   if (numVolumes)<a name="998433"> </a>
   {<a name="998434"> </a>
      // Allocate buffer for volume reference list. <a name="998435"> </a>
      pwVolRefNumList = new WORD [numVolumes];<a name="998436"> </a>
   if (pwVolRefNumList != NULL)<a name="998437"> </a>
      {<a name="998438"> </a>
      // Get the volume reference numbers. <a name="998439"> </a>
      <b>VFSVolumeEnumerate</b> (&amp;numVolumes, pwVolRefNumList);<a name="998440"> </a>
      }<a name="998441"> </a>
}<a name="998442"> </a>
</pre><div class="CodeRule"><hr></div>

<h4>
  <a name="998443"> </a>Compatibility 
</h4>

<p><a name="998444"> </a>VFS Manager version: All. <br>Palm OS version: 4.0 or later. Implemented only if the VFS Manager is present on the handheld (see <a href="CComp_Expansion.html#996231">"Checking for Expansion Cards"</a> in the <i>C/C++ Sync Suite Companion</i>). </p>
<h4>
  <a name="998454"> </a>See Also 
</h4>

<p><a name="998458"> </a><a href="CRef_VFSMgr.html#998593"><code>VFSVolumeInfo()</code></a> </p>

<h3 class="hbH3">
  <a name="998460"> </a>VFSVolumeFormat Function <a href="#995934"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="998462"> </a>Purpose 
</h4>

<p><a name="998463"> </a>Formats and mounts the first volume installed in a given slot. </p>
<h4>
  <a name="998464"> </a>Declared In 
</h4>
<code>VFSMgr.h<a name="998465"> </a></code><h4>
  <a name="998466"> </a>Prototype 
</h4>
<pre class="proto"><a name="998467"></a>SInt32 VFSVolumeFormat (
   HSByte <code class="par">byMountFlags</code>,
   UInt16 <code class="par">fsLibRefNum</code>,
   VFSAnyMountParamPtr <code class="par">pVfsMountParam</code>,
   UInt16 <code class="par">vfsMountParamLen</code>
)
</pre>
<h4>
  <a name="998468"> </a>Parameters 
</h4>

<dl>
<dt><a name="998469"> </a><code>&rarr;  <i>byMountFlags</i></code></dt>
<dd><a name="1042153"> </a>Flags that control how the volume should be formatted. Currently, the only value defined in <a href="CRef_VFSMgr.html#1040677">"Volume Format/Mount Flags"</a> that is not reserved is <code>vfsMountFlagsUseThisFileSystem</code>. Pass this flag to cause the volume to be formatted using the file system specified by <code>fsLibRefNum</code>. Pass zero (0) to have the VFS Manager attempt to format the volume using a file system appropriate to the slot.</dd>

<dt><a name="998471"> </a><code>&rarr;  <i>fsLibRefNum</i></code></dt>
<dd><a name="1042203"> </a>Reference number of the file system library for which the volume should be formatted. If <code class="par">byMountFlags</code> is not set to <code>vfsMountFlagsUseThisFileSystem</code>, this parameter is ignored.</dd>

<dt><a name="998473"> </a><code>&harr;  <i>pVfsMountParam</i></code></dt>
<dd><a name="998474"> </a>Parameters to be used when mounting the volume after it has been formatted. Supply a pointer to a <a href="CRef_VFSMgr.html#996110"><code>VFSAnyMountParamType</code></a> structure. Note that you must pass in a pointer to a different structure type depending on the value of <code class="par">pVfsMountParam</code><code>-&gt;mountClass</code>. For example, if <code>mountClass</code> is set to <code>vfsMountClass_SlotDriver</code>, then the <code class="par">pVfsMountParam</code> you pass in must point to a <code>VFSSlotMountParamType</code> structure. Upon exit, this points to a structure of the same type containing a new volume reference number. </dd>

<dt><a name="998478"> </a><code>&rarr;  <i>vfsMountParamLen</i></code></dt>
<dd><a name="998479"> </a>The length in bytes of the structure passed via <code class="par">pVfsMountParam</code>. </dd>

</dl>
<h4>
  <a name="998480"> </a>Returns 
</h4>

<p><a name="998481"> </a>If successful, returns 0. </p>

<p><a name="998482"> </a>If unsuccessful, returns one of the following error codes: </p>

<dl>
<dt><a name="998483"> </a><code>expErrNotEnoughPower </code></dt>
<dt><a name="998484"> </a><code>expErrNotOpen </code></dt>
<dt><a name="998485"> </a><code>SYNCERR_COMM_NOT_INIT </code></dt>
<dt><a name="998486"> </a><code>vfsErrInvalidOperation </code></dt>
<dt><a name="998487"> </a><code>vfsErrNoFileSystem </code></dt>
</dl>

<p><a name="998490"> </a>For descriptions of all VFS Manager error codes, see <a href="CRef_VFSMgr.html#998756">"VFS Manager Error Codes."</a></p>
<h4>
  <a name="998492"> </a>Comments 
</h4>

<p><a name="998493"> </a><code>VFSVolumeFormat()</code> attempts to find a compatible file system library on the handheld to mount the volume. A volume can be either mounted or unmounted at the time you call this function. <code>VFSVolumeFormat()</code> also remounts the volume if the format succeeds. (The handheld slot driver provided by PalmSource, Inc. currently supports only one volume per slot.) </p>
<div class="NINoteImportant"><hr>
  <a name="998494"> </a> <b>NOTE: </b> For a card that has not been previously formatted (and therefore does not have a volume), set the <code>volRefNum</code> member of the <a href="CRef_VFSMgr.html#996110"><code>VFSAnyMountParamType</code></a> structure to <code>vfsInvalidVolRef</code>. Upon exit, this function passes back a valid volume reference number in a structure of the same type.
<hr>
</div>

<p><a name="998498"> </a>To use <code>VFSVolumeFormat()</code> with a file system based on a slot driver: </p>
<ul type="disc">
  <li><a name="998499"> </a>The <code class="par">pVfsMountParam</code> parameter must point to a <code>VFSSlotMountParamType</code> structure. 
  <li><a name="998500"> </a>The <code class="par">pVfsMountParam</code><code>-&gt;mountClass</code> member must be set to <code>vfsMountClass_SlotDriver</code>. 
  <li><a name="998501"> </a>The <code class="par">pVfsMountParam</code><code>-&gt;slotLibRefNum</code> member may be set to <code>vfsInvalidSlotLibRefNum</code> (which causes the handheld HotSync<sup>&#174;</sup> client to look up the proper driver) or to the value obtained for the <a href="CRef_VFSMgr.html#996205"><code>VolumeInfoType</code></a> structure by calling <a href="CRef_VFSMgr.html#998593"><code>VFSVolumeInfo()</code></a>. 
</ul>

<p><a name="1042254"> </a>If <code>vfsMountFlagsUseThisFileSystem</code> is passed as a <code class="par">byMountFlags</code> value, <code>VFSVolumeFormat()</code> attempts to format the volume using the file system library specified by <code class="par">fsLibRefNum</code>. Typically the <code class="par">byMountFlags</code> parameter is not set. In this case <code>VFSVolumeFormat()</code> tries to find a compatible library to format the volume.</p>
<h4>
  <a name="998508"> </a>Example 
</h4>

<p><a name="998509"> </a>The following code excerpt formats a volume on a physical slot using a compatible file system. </p>

<div class="CodeRule"><hr></div><pre class="CodeBlock">
VFSSlotMountParamType stSlotMountParam;<a name="998510"> </a>
<a name="998511"> </a>
stSlotMountParam.vfsMountParam.volRefNum = volRefNum; // Or vfsInvalidVolRef if <a name="998512"> </a>
                                                     // the card has not been <a name="998513"> </a>
                                                     // formatted.<a name="998514"> </a>
stSlotMountParam.vfsMountParam.reserved = 0;<a name="998515"> </a>
stSlotMountParam.vfsMountParam.mountClass = vfsMountClass_SlotDriver;<a name="998516"> </a>
stSlotMountParam.slotLibRefNum = vfsInvalidSlotLibRefNum; <a name="998517"> </a>
stSlotMountParam.slotRefNum = slotRefNum;<a name="998518"> </a>
// We get this from ExpSlotEnumerate().<a name="998519"> </a>
<a name="998520"> </a>
SInt32 retval = <b>VFSVolumeFormat</b> (0, 0, &amp;stSlotMountParam,<a name="998521"> </a>
   sizeof(stSlotMountParam));<a name="998522"> </a>
</pre><div class="CodeRule"><hr></div>

<h4>
  <a name="998523"> </a>Compatibility 
</h4>

<p><a name="998524"> </a>VFS Manager version: All. <br>Palm OS version: 4.0 or later. Implemented only if the VFS Manager is present on the handheld (see <a href="CComp_Expansion.html#996231">"Checking for Expansion Cards"</a> in the <i>C/C++ Sync Suite Companion</i>). </p>
<h4>
  <a name="998534"> </a>See Also 
</h4>

<p><a name="998538"> </a><a href="CRef_VFSMgr.html#998593"><code>VFSVolumeInfo()</code></a> </p>

<h3 class="hbH3">
  <a name="998540"> </a>VFSVolumeGetLabel Function <a href="#995934"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="998542"> </a>Purpose 
</h4>

<p><a name="998543"> </a>Gets the volume label for a particular volume.</p>
<h4>
  <a name="998544"> </a>Declared In 
</h4>
<code>VFSMgr.h<a name="998545"> </a></code><h4>
  <a name="998546"> </a>Prototype 
</h4>
<pre class="proto"><a name="998547"></a>SInt32 VFSVolumeGetLabel (
   UInt16 <code class="par">volRefNum</code>,
   char <code class="par">*pszVolLabel</code>,
   UInt16 <code class="par">*pwBufLen</code>
)
</pre>
<h4>
  <a name="998548"> </a>Parameters 
</h4>

<dl>
<dt><a name="998549"> </a><code>&rarr;  <i>volRefNum</i></code></dt>
<dd><a name="998550"> </a>Volume reference number (passed back by <a href="CRef_VFSMgr.html#998396"><code>VFSVolumeEnumerate()</code></a>) of the volume for which to get the label. </dd>

<dt><a name="998554"> </a><code>&larr;  <i>pszVolLabel</i></code></dt>
<dd><a name="998555"> </a>A pointer to a character buffer that receives the volume name upon return.</dd>

<dt><a name="998556"> </a><code>&rarr;  <i>pwBufLen</i></code></dt>
<dd><a name="998557"> </a>A pointer to the length, in bytes, of the <code class="par">pszVolLabel</code> buffer.</dd>

</dl>
<h4>
  <a name="998558"> </a>Returns 
</h4>

<p><a name="998559"> </a>If successful, returns 0. </p>

<p><a name="998560"> </a>If unsuccessful, returns one of the following error codes: </p>

<dl>
<dt><a name="998561"> </a><code>expErrNotOpen</code></dt>
<dt><a name="998562"> </a><code>SYNCERR_COMM_NOT_INIT </code></dt>
<dt><a name="998563"> </a><code>SYNCERR_REMOTE_BAD_ARG </code></dt>
<dt><a name="998564"> </a><code>vfsErrBufferOverflow </code></dt>
<dt><a name="998565"> </a><code>vfsErrInvalidOperation </code></dt>
<dt><a name="998566"> </a><code>vfsErrNameShortened </code></dt>
<dt><a name="998567"> </a><code>vfsErrNoFileSystem </code></dt>
<dt><a name="998568"> </a><code>vfsErrVolumeBadRef </code></dt>
</dl>

<p><a name="998571"> </a>For descriptions of all VFS Manager error codes, see <a href="CRef_VFSMgr.html#998756">"VFS Manager Error Codes."</a></p>
<h4>
  <a name="998573"> </a>Comments 
</h4>

<p><a name="998574"> </a>Volume reference numbers can change each time the handheld mounts a given volume. To keep track of a particular volume, save the volume's label rather than its reference number. Volume labels can be up to 255 characters long. They can contain any normal character, including spaces and lowercase characters, in any character set as well as the following special characters: </p>
<pre class="sl">$ % ' - _ @ ~ ` ! ( ) ^ # &amp; + , ; = [ ].</pre>
<h4>
  <a name="998576"> </a>Compatibility 
</h4>

<p><a name="998577"> </a>VFS Manager version: All. <br>Palm OS version: 4.0 or later. Implemented only if the VFS Manager is present on the handheld (see <a href="CComp_Expansion.html#996231">"Checking for Expansion Cards"</a> in the <i>C/C++ Sync Suite Companion</i>). </p>
<h4>
  <a name="998587"> </a>See Also 
</h4>

<p><a name="998591"> </a><a href="CRef_VFSMgr.html#998644"><code>VFSVolumeSetLabel()</code></a> </p>

<h3 class="hbH3">
  <a name="998593"> </a>VFSVolumeInfo Function <a href="#995934"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="998595"> </a>Purpose 
</h4>

<p><a name="998596"> </a>Gets information about the specified volume.</p>
<h4>
  <a name="998597"> </a>Declared In 
</h4>
<code>VFSMgr.h<a name="998598"> </a></code><h4>
  <a name="998599"> </a>Prototype 
</h4>
<pre class="proto"><a name="998600"></a>SInt32 VFSVolumeInfo (
   UInt16 <code class="par">volRefNum</code>,
   VolumeInfoType <code class="par">*pVolInfo</code>
)
</pre>
<h4>
  <a name="998601"> </a>Parameters 
</h4>

<dl>
<dt><a name="998602"> </a><code>&rarr;  <i>volRefNum</i></code></dt>
<dd><a name="998603"> </a>Volume reference number (passed back by <a href="CRef_VFSMgr.html#998396"><code>VFSVolumeEnumerate()</code></a>) of the volume for which to get information. </dd>

<dt><a name="998607"> </a><code>&larr;  <i>pVolInfo</i></code></dt>
<dd><a name="998608"> </a>Pointer to the structure that receives the volume information for the specified volume. See <a href="CRef_VFSMgr.html#996205"><code>VolumeInfoType</code></a> for more information on the fields in this data structure.</dd>

</dl>
<h4>
  <a name="998612"> </a>Returns 
</h4>

<p><a name="998613"> </a>If successful, returns 0. </p>

<p><a name="998614"> </a>If unsuccessful, returns one of the following error codes: </p>

<dl>
<dt><a name="998615"> </a><code>expErrNotOpen</code></dt>
<dt><a name="998616"> </a><code>SYNCERR_COMM_NOT_INIT </code></dt>
<dt><a name="998617"> </a><code>vfsErrInvalidOperation </code></dt>
<dt><a name="998618"> </a><code>vfsErrNoFileSystem </code></dt>
<dt><a name="998619"> </a><code>vfsErrVolumeBadRef</code></dt>
</dl>

<p><a name="998622"> </a>For descriptions of all VFS Manager error codes, see <a href="CRef_VFSMgr.html#998756">"VFS Manager Error Codes."</a></p>
<h4>
  <a name="998624"> </a>Compatibility 
</h4>

<p><a name="998625"> </a>VFS Manager version: All. <br>Palm OS version: 4.0 or later. Implemented only if the VFS Manager is present on the handheld (see <a href="CComp_Expansion.html#996231">"Checking for Expansion Cards"</a> in the <i>C/C++ Sync Suite Companion</i>). </p>
<h4>
  <a name="998635"> </a>See Also 
</h4>

<p><a name="998642"> </a><a href="CRef_VFSMgr.html#998540"><code>VFSVolumeGetLabel()</code></a>, <a href="CRef_VFSMgr.html#998709"><code>VFSVolumeSize()</code></a> </p>

<h3 class="hbH3">
  <a name="998644"> </a>VFSVolumeSetLabel Function <a href="#995934"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="998646"> </a>Purpose 
</h4>

<p><a name="998647"> </a>Changes the volume label for a mounted volume.</p>
<h4>
  <a name="998648"> </a>Declared In 
</h4>
<code>VFSMgr.h<a name="998649"> </a></code><h4>
  <a name="998650"> </a>Prototype 
</h4>
<pre class="proto"><a name="998651"></a>SInt32 VFSVolumeSetLabel (
   UInt16 <code class="par">volRefNum</code>,
   const char <code class="par">*pszVolLabel</code>
)
</pre>
<h4>
  <a name="998652"> </a>Parameters 
</h4>

<dl>
<dt><a name="998653"> </a><code>&rarr;  <i>volRefNum</i></code></dt>
<dd><a name="998654"> </a>Volume reference number (passed back by <a href="CRef_VFSMgr.html#998396"><code>VFSVolumeEnumerate()</code></a>) of the volume for which to set the label. </dd>

<dt><a name="998658"> </a><code>&rarr;  <i>pszVolLabel</i></code></dt>
<dd><a name="998659"> </a>Pointer to the label to apply to the specified volume. This string must be <code>NULL</code>-terminated.</dd>

</dl>
<h4>
  <a name="998660"> </a>Returns 
</h4>

<p><a name="998661"> </a>If successful, returns 0. </p>

<p><a name="998662"> </a>If unsuccessful, returns one of the following error codes: </p>

<dl>
<dt><a name="998663"> </a><code>expErrNotOpen </code></dt>
<dt><a name="998664"> </a><code>SYNCERR_COMM_NOT_INIT </code></dt>
<dt><a name="998665"> </a><code>SYNCERR_REMOTE_BAD_ARG </code></dt>
<dt><a name="998666"> </a><code>vfsErrBadName </code></dt>
<dt><a name="998667"> </a><code>vfsErrInvalidOperation </code></dt>
<dt><a name="998668"> </a><code>vfsErrNameShortened </code></dt>
<dt><a name="998669"> </a><code>vfsErrNoFileSystem </code></dt>
<dt><a name="998670"> </a><code>vfsErrVolumeBadRef </code></dt>
</dl>

<p><a name="998673"> </a>For descriptions of all VFS Manager error codes, see <a href="CRef_VFSMgr.html#998756">"VFS Manager Error Codes."</a></p>
<h4>
  <a name="998675"> </a>Comments 
</h4>

<p><a name="998676"> </a>Volume labels can be up to 255 characters long. They can contain any normal character, including spaces and lowercase characters, in any character set as well as the following special characters: </p>
<pre class="sl">$ % ' - _ @ ~ ` ! ( ) ^ # &amp; + , ; = [ ].</pre>

<p><a name="998683"> </a>See <a href="CComp_Expansion.html#996533">"Naming Volumes"</a> in the <i>C/C++ Sync Suite Companion</i> for guidelines on naming.</p>
<div class="NINoteImportant"><hr>
  <a name="998688"> </a> <b>NOTE: </b> Most conduits or applications should not need to call <code>VFSVolumeSetLabel()</code>. This function may create or delete a file in the root directory, which would invalidate any current calls to <a href="CRef_VFSMgr.html#996951"><code>VFSDirEntryEnumerate()</code></a>.
<hr>
</div>
<h4>
  <a name="998692"> </a>Compatibility 
</h4>

<p><a name="998693"> </a>VFS Manager version: All. <br>Palm OS version: 4.0 or later. Implemented only if the VFS Manager is present on the handheld (see <a href="CComp_Expansion.html#996231">"Checking for Expansion Cards"</a> in the <i>C/C++ Sync Suite Companion</i>). </p>
<h4>
  <a name="998703"> </a>See Also 
</h4>

<p><a name="998707"> </a><a href="CRef_VFSMgr.html#998540"><code>VFSVolumeGetLabel()</code></a> </p>

<h3 class="hbH3">
  <a name="998709"> </a>VFSVolumeSize Function <a href="#995934"><span class="nav">^TOP^</span></a>
</h3>

<h4>
  <a name="998711"> </a>Purpose 
</h4>

<p><a name="998712"> </a>Determines the total amount of space on a volume, as well as the amount that is currently being used.</p>
<h4>
  <a name="998713"> </a>Declared In 
</h4>
<code>VFSMgr.h<a name="998714"> </a></code><h4>
  <a name="998715"> </a>Prototype 
</h4>
<pre class="proto"><a name="998716"></a>SInt32 VFSVolumeSize (
   UInt16 <code class="par">volRefNum</code>,
   UInt32 <code class="par">*pui32SizeUsed</code>,
   UInt32 <code class="par">*pui32TotalCapacity</code>
)
</pre>
<h4>
  <a name="998717"> </a>Parameters 
</h4>

<dl>
<dt><a name="998718"> </a><code>&rarr;  <i>volRefNum</i></code></dt>
<dd><a name="998719"> </a>Volume reference number (passed back by <a href="CRef_VFSMgr.html#998396"><code>VFSVolumeEnumerate()</code></a>) of the volume for which to get the size. </dd>

<dt><a name="998723"> </a><code>&larr;  <i>pui32SizeUsed</i></code></dt>
<dd><a name="998724"> </a>A pointer to a variable that receives the amount of space, in bytes, in use on the volume.</dd>

<dt><a name="998725"> </a><code>&larr;  <i>pui32TotalCapacity</i></code></dt>
<dd><a name="998726"> </a>A pointer to a variable that receives the total capacity of the volume, in bytes.</dd>

</dl>
<h4>
  <a name="998727"> </a>Returns 
</h4>

<p><a name="998728"> </a>If successful, returns 0. </p>

<p><a name="998729"> </a>If unsuccessful, returns one of the following error codes: </p>

<dl>
<dt><a name="998730"> </a><code>expErrNotOpen </code></dt>
<dt><a name="998731"> </a><code>SYNCERR_COMM_NOT_INIT </code></dt>
<dt><a name="998732"> </a><code>vfsErrInvalidOperation </code></dt>
<dt><a name="998733"> </a><code>vfsErrNoFileSystem </code></dt>
<dt><a name="998734"> </a><code>vfsErrVolumeBadRef </code></dt>
</dl>

<p><a name="998737"> </a>For descriptions of all VFS Manager error codes, see <a href="CRef_VFSMgr.html#998756">"VFS Manager Error Codes."</a></p>
<h4>
  <a name="998739"> </a>Compatibility 
</h4>

<p><a name="998740"> </a>VFS Manager version: All. <br>Palm OS version: 4.0 or later. Implemented only if the VFS Manager is present on the handheld (see <a href="CComp_Expansion.html#996231">"Checking for Expansion Cards"</a> in the <i>C/C++ Sync Suite Companion</i>). </p>
<h4>
  <a name="998750"> </a>See Also 
</h4>

<p><a name="998754"> </a><a href="CRef_VFSMgr.html#998593"><code>VFSVolumeInfo()</code></a></p>

<h2 class="haH2">
  <a name="998756"> </a>VFS Manager Error Codes <a href="#995934"><span class="nav">^TOP^</span></a>
</h2>


<p><a name="998760"> </a><a href="CRef_VFSMgr.html#998778">Table 10.1</a> lists the values of error codes that the VFS Manager API functions can return. The description of each function states which errors each function can return. </p>

<p><a name="1015506"> </a>All of the named error codes below are defined as preprocessor constants, which are declared in the <code>VFSErr.h</code> header file. Expansion Manager error codes (<code>exp...</code>) and Sync Manager error codes (<code>SYNC...</code>) can also be returned (see <a href="CRef_ExpMgr.html#996416">"Expansion Manager API Error Codes"</a> and <a href="CRef_SyncCommon.html#995968">"Common Sync Manager Error Codes"</a>).</p>

<p class="fineprint">

</p>

<p class="fineprint">
<p class="caption"><a name="998778"> </a><b>Table 10.1&nbsp;&nbsp;VFS Manager error codes </b></p>
<div class="tablediv"><table cellspacing="0" class="tTable">

  <tr valign="top">
    <th><p class="tt"><a name="998784"> </a><b>Value</b></p>
    </th>
    <th><p class="tt"><a name="998786"> </a><b>Code</b></p>
    </th>
    <th><p class="tt"><a name="998788"> </a><b>Description</b></p>
    </th>
  </tr>
  <tr valign="top">
    <td><p class="tt"><a name="998790"> </a>0x00002A01L</p>
    </td>
    <td><p class="tt"><a name="998793"> </a><code>vfsErrBufferOverflow</code> </p>
    </td>
    <td><p class="tt"><a name="998795"> </a>The supplied buffer is too small.</p>
    </td>
  </tr>
  <tr valign="top">
    <td><p class="tt"><a name="998797"> </a>0x00002A02L</p>
    </td>
    <td><p class="tt"><a name="998800"> </a><code>vfsErrFileGeneric</code> </p>
    </td>
    <td><p class="tt"><a name="998802"> </a>Generic file error.</p>
    </td>
  </tr>
  <tr valign="top">
    <td><p class="tt"><a name="998804"> </a>0x00002A03L</p>
    </td>
    <td><p class="tt"><a name="998807"> </a><code>vfsErrFileBadRef</code> </p>
    </td>
    <td><p class="tt"><a name="998809"> </a>The file reference number is invalid: it has been closed or was not obtained from <a href="CRef_VFSMgr.html#997531"><code>VFSFileOpen()</code></a>.</p>
    </td>
  </tr>
  <tr valign="top">
    <td><p class="tt"><a name="998814"> </a>0x00002A04L</p>
    </td>
    <td><p class="tt"><a name="998817"> </a><code>vfsErrFileStillOpen</code> </p>
    </td>
    <td><p class="tt"><a name="998819"> </a>The file is still open&#8212for example, trying to delete an open file. </p>
    </td>
  </tr>
  <tr valign="top">
    <td><p class="tt"><a name="998821"> </a>0x00002A05L</p>
    </td>
    <td><p class="tt"><a name="998824"> </a><code>vfsErrFilePermissionDenied</code> </p>
    </td>
    <td><p class="tt"><a name="998826"> </a>Permission denied to perform requested operation&#8212for example, an attempt to write to a read-only file or to read a file already opened in the <code>vfsModeExclusive</code> mode. </p>
    </td>
  </tr>
  <tr valign="top">
    <td><p class="tt"><a name="998828"> </a>0x00002A06L</p>
    </td>
    <td><p class="tt"><a name="998831"> </a><code>vfsErrFileAlreadyExists</code> </p>
    </td>
    <td><p class="tt"><a name="998833"> </a>A file or a directory with this name exists in this location already.</p>
    </td>
  </tr>
  <tr valign="top">
    <td><p class="tt"><a name="998835"> </a>0x00002A07L</p>
    </td>
    <td><p class="tt"><a name="998838"> </a><code>vfsErrFileEOF</code> </p>
    </td>
    <td><p class="tt"><a name="998840"> </a>The file pointer has been moved to the end of the file. This code is not considered an error. </p>
    </td>
  </tr>
  <tr valign="top">
    <td><p class="tt"><a name="998842"> </a>0x00002A08L</p>
    </td>
    <td><p class="tt"><a name="998845"> </a><code>vfsErrFileNotFound</code> </p>
    </td>
    <td><p class="tt"><a name="998847"> </a>The file was not found in the specified path.</p>
    </td>
  </tr>
  <tr valign="top">
    <td><p class="tt"><a name="998849"> </a>0x00002A09L</p>
    </td>
    <td><p class="tt"><a name="998852"> </a><code>vfsErrVolumeBadRef</code> </p>
    </td>
    <td><p class="tt"><a name="998854"> </a>The volume reference number is invalid.</p>
    </td>
  </tr>
  <tr valign="top">
    <td><p class="tt"><a name="998856"> </a>0x00002A0AL</p>
    </td>
    <td><p class="tt"><a name="998859"> </a><code>vfsErrVolumeStillMounted</code> </p>
    </td>
    <td><p class="tt"><a name="998861"> </a>The volume is still mounted. </p>
    </td>
  </tr>
  <tr valign="top">
    <td><p class="tt"><a name="998863"> </a>0x00002A0BL</p>
    </td>
    <td><p class="tt"><a name="998866"> </a><code>vfsErrNoFileSystem</code> </p>
    </td>
    <td><p class="tt"><a name="998868"> </a>None of the file systems installed on the handheld support this operation.</p>
    </td>
  </tr>
  <tr valign="top">
    <td><p class="tt"><a name="998870"> </a>0x00002A0CL</p>
    </td>
    <td><p class="tt"><a name="998873"> </a><code>vfsErrBadData</code> </p>
    </td>
    <td><p class="tt"><a name="998875"> </a>The operation could not be completed because of invalid data&#8212for example, importing a database from a corrupted <code>.prc</code> file. </p>
    </td>
  </tr>
  <tr valign="top">
    <td><p class="tt"><a name="998877"> </a>0x00002A0DL</p>
    </td>
    <td><p class="tt"><a name="998880"> </a><code>vfsErrDirNotEmpty</code> </p>
    </td>
    <td><p class="tt"><a name="998882"> </a>The directory is not empty and therefore cannot be deleted.</p>
    </td>
  </tr>
  <tr valign="top">
    <td><p class="tt"><a name="998884"> </a>0x00002A0EL</p>
    </td>
    <td><p class="tt"><a name="998887"> </a><code>vfsErrBadName</code> </p>
    </td>
    <td><p class="tt"><a name="998889"> </a>Invalid filename, path, or volume label. See <a href="CComp_Expansion.html#996739">"Naming Files,"</a> <a href="CComp_Expansion.html#996803">"Directory Paths,"</a> or <a href="CComp_Expansion.html#996533">"Naming Volumes"</a> in the <i>C/C++ Sync Suite Companion</i>. </p>
    </td>
  </tr>
  <tr valign="top">
    <td><p class="tt"><a name="998906"> </a>0x00002A0FL</p>
    </td>
    <td><p class="tt"><a name="998909"> </a><code>vfsErrVolumeFull</code> </p>
    </td>
    <td><p class="tt"><a name="998911"> </a>There is insufficient space left on the volume.</p>
    </td>
  </tr>
  <tr valign="top">
    <td><p class="tt"><a name="998913"> </a>0x00002A10L</p>
    </td>
    <td><p class="tt"><a name="998916"> </a><code>vfsErrUnimplemented</code> </p>
    </td>
    <td><p class="tt"><a name="998918"> </a>This call is not implemented.</p>
    </td>
  </tr>
  <tr valign="top">
    <td><p class="tt"><a name="998920"> </a>0x00002A11L</p>
    </td>
    <td><p class="tt"><a name="998923"> </a><code>vfsErrNotADirectory</code> </p>
    </td>
    <td><p class="tt"><a name="998925"> </a>This operation can be performed only on a directory.</p>
    </td>
  </tr>
  <tr valign="top">
    <td><p class="tt"><a name="998927"> </a>0x00002A12L</p>
    </td>
    <td><p class="tt"><a name="998930"> </a><code>vfsErrIsADirectory</code> </p>
    </td>
    <td><p class="tt"><a name="998932"> </a>This operation can be performed only on a regular file, not a directory.</p>
    </td>
  </tr>
  <tr valign="top">
    <td><p class="tt"><a name="998934"> </a>0x00002A13L</p>
    </td>
    <td><p class="tt"><a name="998937"> </a><code>vfsErrDirectoryNotFound</code> </p>
    </td>
    <td><p class="tt"><a name="998939"> </a>The path, excluding filename, does not exist or no default directory is registered for this file type. </p>
    </td>
  </tr>
  <tr valign="top">
    <td><p class="tt"><a name="998941"> </a>0x00002A14L</p>
    </td>
    <td><p class="tt"><a name="998944"> </a><code>vfsErrNameShortened</code> </p>
    </td>
    <td><p class="tt"><a name="998946"> </a>A volume name or filename was automatically shortened to conform to the file system specification. </p>
    </td>
  </tr>
  <tr valign="top">
    <td><p class="tt"><a name="998948"> </a>0x00002A30L</p>
    </td>
    <td><p class="tt"><a name="998951"> </a><code>vfsErrInvalidOperation</code> </p>
    </td>
    <td><p class="tt"><a name="998953"> </a>A file system is not present or the VFS Manager function is not valid. </p>
    </td>
  </tr>
  <tr valign="top">
    <td><p class="tt"><a name="998955"> </a>0x00002A31L</p>
    </td>
    <td><p class="tt"><a name="998958"> </a><code>vfsErrDiskFileAccess</code> </p>
    </td>
    <td><p class="tt"><a name="998960"> </a>Failed to create or open the disk file on the desktop.Use Windows' <code>GetLastError()</code> function for details. </p>
    </td>
  </tr>
  <tr valign="top">
    <td><p class="tt"><a name="998962"> </a>0x00002A32L</p>
    </td>
    <td><p class="tt"><a name="998965"> </a><code>vfsErrDiskFull</code> </p>
    </td>
    <td><p class="tt"><a name="998967"> </a>Not enough space on the desktop's disk. </p>
    </td>
  </tr>
  <tr valign="top">
    <td><p class="tt"><a name="998969"> </a>0x00002A33L</p>
    </td>
    <td><p class="tt"><a name="998972"> </a><code>vfsErrFileAccessOther</code> </p>
    </td>
    <td><p class="tt"><a name="998974"> </a>Generic desktop file access error.Use Windows' <code>GetLastError()</code> function for details. If returned by <a href="CRef_VFSMgr.html#997357"><code>VFSFileGet()</code></a>, could not access or map the desktop file&#8212for example, because of insufficient memory on the desktop.</p>
    </td>
  </tr>
</table>

</div>

</p>
&nbsp;<br>
</div>
<!--END CONTENT-->

</td>
<td width="5">&nbsp;&nbsp;</td>
</tr>

</table>

<!-- BEGIN FOOTER -->
<table width="100%" border="0" cellspacing="0" cellpadding="0">
<tr>
<td width="7" rowspan="2"><img name="index_x" src="images/shim.gif" width="7" height="33" border="0" alt=""></td>
<td align="left"><img name="dashes" src="images/dashes.gif" width="744" height="3" border="0" alt=""></td>
<td width="10" rowspan="2"><img name="index_x" src="images/shim.gif" width="10" height="33" border="0" alt=""></td>
</tr>
<tr>
<td align="center">
<p class="footer">
Copyright © 1998-2004, PalmSource, Inc. and its affiliates. All rights reserved.<br>
<a href="http://www.palmsource.com/contact/">Write Us</a> | <a href="http://www.palmos.com/dev/training/">Training</a> | <a href="http://www.palmos.com/dev/support/kb/">Knowledge Base</a> | <a href="CRef_Front.html" target="_blank">Legal</a></p>
<br>
<!--BEGIN BOOK NAVIGATION-->
<p class="nav">
<A href="http://www.palmos.com/dev/support/docs/">Documentation</a>&nbsp;&nbsp;|&nbsp;&nbsp;
<a href="C++SyncReferenceTOC.html">Table of Contents</a>&nbsp;&nbsp;
             |&nbsp;&nbsp;<a href="CRef_ExpMgr.html">&lt;&nbsp;Previous</a>&nbsp;&nbsp;
             |&nbsp;&nbsp;<a href="CRef_Part_Desktop.html">Next&nbsp;&gt;</a>&nbsp;&nbsp;
             |&nbsp;&nbsp;<a href="C++SyncReferenceIX.html">Index</a>
</p>
</td>
</tr>
<!-- END FOOTER -->

</body>
</html>