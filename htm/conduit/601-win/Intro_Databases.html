<html>
<head>
<title>Palm OS Databases | Introduction to Conduit Development</title> 
<link href="psi_devpubs.css" rel="stylesheet" type="text/css">

<!-- BEGIN META DATA -->
<meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
<META NAME="KEYWORDS" CONTENT="database, databases, schema, non-schema, classic, extended, conduit, conduits, CDK">
<META NAME="DESCRIPTION" CONTENT="Describes the concepts of Palm OS schema, extended, and classic databases.">
<META NAME="PSITEMPLATE" CONTENT="1006-007 PalmSource HTML 20040609">
<META NAME="GENERATOR" CONTENT="Quadralay WebWorks Publisher Professional Edition 6.0.7">
<META NAME="LASTUPDATED" CONTENT="06/28/04 08:30:38">
<!-- END META DATA -->
</head>

<body bgcolor="#ffffff" text="#000000" leftmargin="0" topmargin="0" marginwidth="0" marginheight="0">
<a name="995933"></a>

<!-- BEGIN TOPNAV -->
<table width="100%" border="0" cellspacing="0" cellpadding="0">
<tr>
<td><img src="images/shim.gif" width="7" height="75" border="0" alt=""></td>
<td align="left"><table border="0" cellpadding="0" cellspacing="0" width="744">
<tr>
<td><img name="index_r2_c1" src="images/shim.gif" width="25" height="75" border="0" alt=""></td>
<td valign="top"><table border="0" cellpadding="0" cellspacing="0" width="96">
<tr>
<td><img name="index_r2_c4" src="images/shim.gif" width="96" height="15" border="0" alt=""></td>
</tr>
<tr>
<td><a href="http://www.palmsource.com/"><img name="ps_logo" src="images/ps_logo.gif" width="96" height="54" border="0" alt=""></a></td>
</tr>

</table>
</td>

<td><table border="0" cellpadding="0" cellspacing="0" width="30">
<td><img name="index_x" src="images/shim.gif" width="30" height="75" border="0" alt=""></td>
</table></td>

<!--BEGIN MASTHEAD-->
<td><table border="0" cellpadding="0" cellspacing="0" width="96">
<tr>
<td><img name="index_x" src="images/shim.gif" width="615" height="5" border="0" alt=""></td>
</tr>
<tr>
<td>
<!--BEGIN BOOK NAVIGATION-->
<span class="nav">
<A href="http://www.palmos.com/dev/support/docs/">Documentation</a>&nbsp;&nbsp;|&nbsp;&nbsp;
<a href="IntroToConduitsTOC.html">Table of Contents</a>&nbsp;&nbsp;
             |&nbsp;&nbsp;<a href="Intro_HotSyncProc.html">&lt;&nbsp;Previous</a>&nbsp;&nbsp;
             |&nbsp;&nbsp;<a href="Intro_Trust.html">Next&nbsp;&gt;</a>&nbsp;&nbsp;
             |&nbsp;&nbsp;<a href="IntroToConduitsIX.html">Index</a>
</span>
<!--END BOOK NAVIGATION-->
</tr>
<tr>
<td>
<!--BEGIN PAGE TITLE-->
<h2 class="PageTitle">8 &nbsp;&nbsp;
Palm OS Databases</h2></td>
<!--END PAGE TITLE-->
</tr>
<tr>
<td>
<!--BEGIN BOOK TITLE-->
<p class="BookTitle">Introduction to Conduit Development</p>
<p class="SubTitle">Palm OS&#174; Conduit Development Kit for Windows, Version 6.0.1 </p>
<!--END BOOK TITLE-->
</td>
</tr>
<tr>
<td><img name="index_x" src="images/shim.gif" width="615" height="5" border="0" alt=""></td>
</tr>
</table>
</td>
<!--END MASTHEAD-->
</tr>
</table>
<img name="dashes" src="images/dashes.gif" width="744" height="3" border="0" alt=""></td>
</tr>
</table>
<!-- END TOPNAV -->

<table width="100%" border="0" cellspacing="0" cellpadding="0">
<tr>
<td valign="top" width="5"><img name="index_x" src="images/shim.gif" width="5" height="33" border="0" alt=""></td>

<!--BEGIN SIDETOC-->
<td valign="top" width="175">
<div id="sidetoc" valign="bottom">
<h1 class="SideTOC1"><a href="Intro_Databases.html">8  Palm OS Databases</a></h1>

   <h2 class="SideTOC2"><a href="#998635">
   Database Overview</a></h2>

      <h3 class="SideTOC3"><a href="#998639">
      Schema vs. Non-schema Databases</a></h3>

      <h3 class="SideTOC3"><a href="#998668">
      Resources and Resource Databases</a></h3>

      <h3 class="SideTOC3"><a href="#1013071">
      Mutually Exclusive Database Characteristics</a></h3>

      <h3 class="SideTOC3"><a href="#998677">
      Uniquely Identifying Databases</a></h3>

      <h3 class="SideTOC3"><a href="#998687">
      Database Attributes</a></h3>

   <h2 class="SideTOC2"><a href="#998903">
   Schema Databases</a></h2>

      <h3 class="SideTOC3"><a href="#1009957">
      Schema Database Header</a></h3>

      <h3 class="SideTOC3"><a href="#998909">
      Schemas and Tables</a></h3>

      <h3 class="SideTOC3"><a href="#999436">
      Schema Database Rows</a></h3>

      <h3 class="SideTOC3"><a href="#1000119">
      Secure Databases</a></h3>

      <h3 class="SideTOC3"><a href="#1000218">
      Concurrent Schema Database Access</a></h3>

      <h3 class="SideTOC3"><a href="#1007124">
      Change Tracking Services for Schema Databases</a></h3>

   <h2 class="SideTOC2"><a href="#1003516">
   Non-Schema Databases</a></h2>

      <h3 class="SideTOC3"><a href="#1003556">
      Structure of a Non-Schema Database</a></h3>

      <h3 class="SideTOC3"><a href="#1004346">
      Record Attributes</a></h3>

      <h3 class="SideTOC3"><a href="#1004491">
      Categories and the Application Info Block</a></h3>

      <h3 class="SideTOC3"><a href="#1004532">
      Working with Non-Schema Database Records</a></h3>

      <h3 class="SideTOC3"><a href="#1004539">
      Maintaining Record Order</a></h3>

      <h3 class="SideTOC3"><a href="#1004541">
      Concurrent Non-Schema Database Access</a></h3>

</div>
</td>
<!--END SIDETOC-->

<td width="5">&nbsp;&nbsp;</td>
<td width="2" background="images/index_r8_c10.gif"><img src="images/shim.gif" width="2" height="75" border="0" alt=""></td>
<td width="5">&nbsp;&nbsp;</td>
<td valign="top">

<!--BEGIN CONTENT-->
<div id="content" valign="bottom">
<p><a name="998630"> </a>The work of most conduits is to read and write Palm OS<sup>&#174;</sup> databases on a handheld. This chapter describes the types and layout of databases in the following sections:</p>
   <blockquote class = "bq"><a name="996830"> </a><a href="Intro_Databases.html#998635">Database Overview</a></blockquote>
   <blockquote class = "bq"><a name="1004909"> </a><a href="Intro_Databases.html#998903">Schema Databases</a></blockquote>
   <blockquote class = "bq"><a name="1004921"> </a><a href="Intro_Databases.html#1003516">Non-Schema Databases</a></blockquote>

<h2 class="haH2">
  <a name="998635"> </a>Database Overview <a href="#995933"><span class="nav">^TOP^</span></a>
</h2>


<p><a name="998637"> </a>A traditional file system first reads all or a portion of a file into a memory buffer from disk, using or updating the information in the memory buffer, and then writes the updated memory buffer back to disk. Because Palm Powered<sup>&#8482;</sup> handhelds have limited amounts of dynamic RAM and use nonvolatile RAM instead of disk storage, a traditional file system is not optimal for storing and retrieving Palm OS user data. Thus, except when working with expansion media (an SD card, Memory Stick, and the like), Palm OS doesn't make use of a traditional file system. Instead of files, Palm OS applications work mainly with <b>databases</b>.</p>

<p><a name="1015668"> </a>Databases organize related rows (for schema databases) or records (for non-schema databases); each belongs to one and only one database. A database may be a collection of all address book entries, all datebook entries, and so on. A Palm OS application or conduit can create, delete, open, and close databases as necessary, just as a traditional file system can create, delete, open, and close a traditional file. Applications call the <b>Data Manager</b> to perform these operations; conduits call the <b>Sync Manager</b> on the desktop, which in turn calls the Data Manager on the handheld to perform database operations.</p>

<p><a name="1015669"> </a>The following subsections compare the different types of databases and their common features:</p>
   <blockquote class = "bq"><a name="1006175"> </a><a href="Intro_Databases.html#998639">Schema vs. Non-schema Databases</a></blockquote>
   <blockquote class = "bq"><a name="1006206"> </a><a href="Intro_Databases.html#998668">Resources and Resource Databases</a></blockquote>
   <blockquote class = "bq"><a name="1014888"> </a><a href="Intro_Databases.html#1013071">Mutually Exclusive Database Characteristics</a></blockquote>
   <blockquote class = "bq"><a name="1006213"> </a><a href="Intro_Databases.html#998677">Uniquely Identifying Databases</a></blockquote>
   <blockquote class = "bq"><a name="1006220"> </a><a href="Intro_Databases.html#998687">Database Attributes</a></blockquote>
<h3 class="hbH3">
  <a name="998639"> </a>Schema vs. Non-schema Databases <a href="#995933"><span class="nav">^TOP^</span></a>
</h3>


<p><a name="1006063"> </a>For those new to Palm OS programming, the term "database" can be somewhat misleading. Palm OS Cobalt supports three different types of database, some of which look more like conventional databases than others. Schema databases bear a strong resemblance to relational databases. Data is organized into tables, which consist of rows and columns. <b>Schema databases</b> use the concept of a <b>schema</b> to define the structure of a table row. Unlike relational databases, however, schema databases don't allow you to perform joins and other complex operations.</p>

<p><a name="998646"> </a>The other two database types are classified as "<b>non-schema</b>" databases because they are significantly less structured. There are two supported non-schema database types:</p>
<ul type="disc">
  <li><a name="998647"> </a><b>Classic databases</b> are supported for compatibility with earlier versions of Palm OS. All versions of Palm OS back to Palm OS 1.0 support this database format, and this is the format used by applications running on Palm OS Cobalt through PACE.
  <li><a name="998651"> </a><b>Extended databases</b> are an "extended" version of classic databases. There are three primary differences between classic and extended databases: 
  <ul type="disc">
    <li><a name="998806"> </a>records can exceed 64 KB in length (classic records cannot)&#8212in fact, they can be almost 64 MB, if memory is available.
    <li><a name="998810"> </a>uniquely identified by a combination of name and creator ID (classic databases are uniquely identified by name alone)
    <li><a name="998811"> </a>can store data using the processor's native endianness (classic databases must store record data using big-endianness, for compatibility with the 68K-based Dragonball CPU used in the early Palm OS devices).
  </ul>
</ul>

<p><a name="1000745"> </a>One of the strengths of the relational approach employed by schema databases is that you can deal with the data as information and, ideally, not worry about the details of how it is represented or physically maintained in the database itself. Having to deal with these kinds of implementation details makes extended and classic databases more difficult to manage.</p>

<p><a name="998655"> </a>Handheld applications and conduits that must remain compatible with Palm OS versions earlier than Palm OS Cobalt&#8212perhaps a version of the application exists that runs on earlier versions of Palm OS and this application must be able to work with the earlier version's data&#8212will use classic databases. Those handheld applications and conduits that don't have such a compatibility requirement should use either extended or schema databases instead. Which to use depends on the nature of the application. Schema databases provide a great deal of support for organizing the database contents and for security, at the expense of performance. Extended databases, on the other hand, are faster to read and write, but are less secure and less structured&#8212meaning that your application and conduit have to do the work of maintaining and interpreting record contents themselves.</p>

<p><a name="998661"> </a>Non-schema databases treat their contents as lists of mostly opaque records. The Palm OS Data Manager knows just enough about each record to understand category assignment, modification status, and deletion status. Applications are entirely responsible for structuring and interpreting database record contents. Traditional Palm OS applications, written for 68K-based handhelds and for PACE, work exclusively with classic databases.</p>

<p><a name="998662"> </a>Schema databases add a layer of abstraction to the record contents. This extra layer of abstraction allows you to create more flexible applications, with improved sharing of data between applications. Because the Data Manager knows more about the structure of the database rows, it can provide more detailed change tracking than for non-schema databases. Changes to a database's schema definitions, row data, and category membership are each tracked independently, making synchronization simpler and more efficient.</p>

<p><a name="998841"> </a>Schema databases have other advantages as well:</p>
<ul type="disc">
  <li><a name="998663"> </a>They provide more standardized data storage.
  <li><a name="998665"> </a>Schema databases can be more easily extended with additional fields.
  <li><a name="998666"> </a>It is much easier to create conduits for schema databases, and it is easier to integrate a schema database with a database on the desktop computer or on a server.
</ul>
<h3 class="hbH3">
  <a name="998668"> </a>Resources and Resource Databases <a href="#995933"><span class="nav">^TOP^</span></a>
</h3>


<p><a name="998670"> </a>Non-schema databases that are designated as resource databases tag each chunk of data with a unique resource type and resource ID. These tagged data chunks are called <b>resources</b>. Resource databases are almost identical in structure to other non-schema databases except for a slight amount of increased storage overhead per resource record (two extra bytes).</p>

<p><a name="998674"> </a>Resources are typically used to store the user interface elements of an application, such as images, fonts, dialog layouts, and so forth. Part of building an application involves creating these resources and merging them with the actual executable code. In the Palm OS environment, an application is, in fact, simply a resource database with the executable code stored as one or more code resources and the graphics elements and other miscellaneous data stored in the same database as other resource types.</p>

<p><a name="998675"> </a>Applications may also find resource databases useful for storing and retrieving application preferences, saved window positions, state information, and so forth. These preferences settings can be stored in a separate resource database.</p>
<h3 class="hbH3">
  <a name="1013071"> </a>Mutually Exclusive Database Characteristics <a href="#995933"><span class="nav">^TOP^</span></a>
</h3>


<p><a name="1013072"> </a><a href="Intro_Databases.html#1014226">Table 8.1</a> shows which types of databases can contain records or resources and whether they can be secure. Note that database types (schema, extended, and classic) are mutually exclusive, and that a database cannot contain both records and resources. Only schema databases can be secure (see <a href="Intro_Databases.html#1000119">"Secure Databases"</a>).</p>

<p class="fineprint">
<p class="caption"><a name="1014226"> </a><b>Table 8.1&nbsp;&nbsp;Mutually exclusive database characteristics</b></p>
<div class="tablediv"><table cellspacing="0" class="tTable">

  <tr valign="top">
    <th><p class="tt"><a name="1014232"> </a><b>Database Type</b></p>
    </th>
    <th><p class="tt"><a name="1014234"> </a><b>Can Contain Records or Resources?</b></p>
    </th>
    <th><p class="tt"><a name="1014236"> </a><b>Can Be Secure?</b></p>
    </th>
  </tr>
  <tr valign="top">
    <td><p class="tt"><a name="1014238"> </a>Schema</p>
    </td>
    <td><p class="tt"><a name="1014240"> </a>Records (rows) only</p>
    </td>
    <td><p class="tt"><a name="1014242"> </a>Yes</p>
    </td>
  </tr>
  <tr valign="top">
    <td><p class="tt"><a name="1014244"> </a>Extended</p>
    </td>
    <td><p class="tt"><a name="1014246"> </a>Either</p>
    </td>
    <td><p class="tt"><a name="1014248"> </a>No</p>
    </td>
  </tr>
  <tr valign="top">
    <td><p class="tt"><a name="1014250"> </a>Classic</p>
    </td>
    <td><p class="tt"><a name="1014252"> </a>Either</p>
    </td>
    <td><p class="tt"><a name="1014254"> </a>No</p>
    </td>
  </tr>
</table>

</div>

</p>
<h3 class="hbH3">
  <a name="998677"> </a>Uniquely Identifying Databases <a href="#995933"><span class="nav">^TOP^</span></a>
</h3>


<p><a name="1010953"> </a>Schema, extended, and classic databases exist in disjoint namespaces. Because the namespaces are disjoint, it is possible for up to three databases, one per namespace, to have the same name and creator ID.</p>

<p><a name="1010983"> </a>In all versions of Palm OS, classic databases must be uniquely identified by name. Schema and extended databases, however, are uniquely identified by a combination of the database's name and its creator ID. Thus, schema and extended database names need only be unique for a single creator ID: two such databases with the same name can reside on a single handheld as long as their creator IDs differ. </p>
<h3 class="hbH3">
  <a name="998687"> </a>Database Attributes <a href="#995933"><span class="nav">^TOP^</span></a>
</h3>


<p><a name="998688"> </a>In addition to the records that make up the database's contents&#8212and in addition to the schemas that define the structure of the rows in a schema database table&#8212all Palm OS databases have a set of flags that describe various aspects of the database itself, plus a set of dates identifying when the database was created, last modified, and last backed up. As well, non-schema databases have an <b>application info block</b> to hold application settings and the like, and a <b>sort info block</b> to control the ordering of database records. Schema databases use the concept of cursors for applications to control row ordering; conduits do not have access to cursors.</p>

<h2 class="haH2">
  <a name="998903"> </a>Schema Databases <a href="#995933"><span class="nav">^TOP^</span></a>
</h2>


<p><a name="998904"> </a>Schema databases consist of one or more tables. All of the rows in a given table have the same structure.</p>

<p><a name="998905"> </a>All data in a schema database table is represented in the form of two-dimensional tables. A <b>table</b> contains zero or more rows and one or more columns. All <b>rows</b> in a table have the same sequence of <b>columns</b>, but with a different series of values in those columns. Note that a row doesn't have to have a value for a column; the special value <code>NULL</code> can be used to indicate that the value is undefined. See <a href="Intro_Databases.html#1004727">Figure 8.1</a>.</p>

<p class="FFigureCaption">
  <a name="1004727"> </a><b>Figure 8.1&nbsp;&nbsp;Schema database example</b>
</p>
<div align="left"><img src="images/SchemaDatabase.gif" height="370" width="342" border="0" hspace="0" vspace="0">
</div>

<p><a name="998906"> </a>As with a relational database, operations are defined by logic, not by the position of a row within a table. That is, you ask for all rows where (x = 3) and not for the first, third, and fifth rows, for example. The rows of a schema database table are in arbitrary order&#8212the order in which they appear doesn't necessarily reflect the order in which they were entered or in which they are stored.</p>

<p><a name="1006225"> </a>The following subsections provide further details on schema databases, secure databases, and concurrent access:</p>
   <blockquote class = "bq"><a name="1006252"> </a><a href="Intro_Databases.html#1009957">Schema Database Header</a></blockquote>
   <blockquote class = "bq"><a name="1006299"> </a><a href="Intro_Databases.html#998909">Schemas and Tables</a></blockquote>
   <blockquote class = "bq"><a name="1006314"> </a><a href="Intro_Databases.html#999436">Schema Database Rows</a></blockquote>
   <blockquote class = "bq"><a name="1006325"> </a><a href="Intro_Databases.html#1000119">Secure Databases</a></blockquote>
   <blockquote class = "bq"><a name="1009838"> </a><a href="Intro_Databases.html#1000218">Concurrent Schema Database Access</a></blockquote>
<h3 class="hbH3">
  <a name="1009957"> </a>Schema Database Header <a href="#995933"><span class="nav">^TOP^</span></a>
</h3>


<p><a name="1009958"> </a>The schema database header contains information that describes the database and includes pointers to the category info block, row sort indexes, tables, and rows. It contains all of the information in a non-schema database header, except that it lacks the optional sort info block, which is replaced by the sort indexes for each table, and the application info block, which does not exist in a schema database. The schema database header contains the following information:</p>

<dl>
<dt><a name="1006598"> </a>Name</dt>
<dd><a name="1006599"> </a>The null-terminated name of the database. Schema database names should be valid SQL identifiers that are no longer than 32 characters, including the null terminator.</dd>

<dt><a name="1006600"> </a>Type</dt>
<dd><a name="1006601"> </a>A four-byte string that allows Palm OS to distinguish among multiple databases with the same creator ID. Type values have the same requirements as creator IDs, but you do not register them since they are not unique. Certain types have special meaning&#8212for example <code>'appl'</code> is for applications.</dd>

<dt><a name="1006602"> </a>Creator</dt>
<dd><a name="1006603"> </a>A four-byte string that uniquely identifies the creator of an application or database. You must register your creator ID with PalmSource to protect your application from conflicting with others. Values are case-sensitive and composed of ASCII characters in the range 32-126 (decimal). Values consisting of all lowercase letters are reserved for use by PalmSource.</dd>

<dt><a name="1006604"> </a>Attributes</dt>
<dd><a name="1006605"> </a>Flags that indicate such characteristics as whether the database contains records or resources, is read-only, has a modified application info block, should be backed up, is copy-protected, is open, and so on.</dd>

<dt><a name="1006606"> </a>Version</dt>
<dd><a name="1006607"> </a>An application-specific version number.</dd>

<dt><a name="1006608"> </a>Creation Date</dt>
<dd><a name="1006609"> </a>The date on which the database was created.</dd>

<dt><a name="1006610"> </a>Modification Date</dt>
<dd><a name="1006611"> </a>The date on which the database was last modified, either by an application or conduit.</dd>

<dt><a name="1006612"> </a>Last Backup Date</dt>
<dd><a name="1006613"> </a>The date on which the database was last backed up.</dd>

<dt><a name="1006614"> </a>Modification Number</dt>
<dd><a name="1006615"> </a>An integer that is incremented every time a record in the database is deleted, added, or modified.</dd>

<dt><a name="1006616"> </a>Unique ID Seed</dt>
<dd><a name="1006617"> </a>A value assigned and used only by the Data Manager to generate record IDs for this database.</dd>

<dt><a name="1006618"> </a>DRID</dt>
<dd><a name="1006619"> </a>The database reset identifier. The Data Manager pseudo-randomly generates this identifier for each schema database for synchronization use only. The desktop Sync Manager uses the DRID to determine whether the sync clock value and change counters are no longer dependable&#8212for example, when the database has been restored after a hard reset. </dd>

<dt><a name="1006623"> </a>Sync Clock</dt>
<dd><a name="1006624"> </a>Each schema database has a local sync clock that is used to update the change counter. At the end of a sync operation, the Data Manager increments the sync clock.</dd>

<dt><a name="1006625"> </a>Category Info</dt>
<dd><a name="1006626"> </a>A pointer to the category info block. This area is not directly accessible. Conduits access category information only via the Sync Manager.</dd>

<dt><a name="1006627"> </a>Table Definitions</dt>
<dd><a name="1006628"> </a>A pointer to a list of all the tables defined in the database.</dd>

<dt><a name="1006629"> </a>Default Sort Index</dt>
<dd><a name="1006630"> </a>A pointer to a list of row pointers that indicate the default sort order of rows in a table. This is the only sort order used by the schema Sync Manager.</dd>

<dt><a name="1006631"> </a>Sort Indexes</dt>
<dd><a name="1006632"> </a>A pointer to an array of sort indexes that can be used only by the handheld application. Conduits have no access to these sort indexes.</dd>

<dt><a name="1006633"> </a>Number of Tables</dt>
<dd><a name="1006634"> </a>The number of tables stored in the database.</dd>

<dt><a name="1006635"> </a>List of Tables</dt>
<dd><a name="1006636"> </a>Each entry points to a table. Each table has a list of row IDs. Each row has attributes, category membership, and so on, and points to a list of its column values.</dd>

</dl>
<h3 class="hbH3">
  <a name="998909"> </a>Schemas and Tables <a href="#995933"><span class="nav">^TOP^</span></a>
</h3>


<p><a name="998913"> </a>A <b>schema</b> is simply the collective definitions of a table's columns. Each schema database can be heterogeneous in that it can support multiple tables. Because each table's definition includes the column definitions for that table&#8212the schema&#8212two tables can have the same schema, yet changes to one table's schema do not affect the other.</p>

<p><a name="998918"> </a>Tables can be defined at the time a database is created, or added later.</p>

<p><a name="998919"> </a>Schema access is gated by the access restrictions for the database. Read-only access to a database implies read-only access to all of that database's schemas (and thus any attempt to modify the schema will fail). See <a href="Intro_Databases.html#1000119">"Secure Databases"</a> for more information on database access restrictions.</p>

<h4 class="hcH4">
  <a name="998923"> </a>Logical (External) vs. Physical (Internal) Views
</h4>

<p><a name="998924"> </a>Schemas allow the Sync Manager to decouple the logical (external) view of your data from the physical (internal) view. When working with a schema database you manipulate row data in terms of data types defined in the column property sets&#8212this is the <b>logical data view</b>. In actual fact, however, the Data Manager stores row data internally in an unpublished variant format: the <b>physical data view</b>. This decoupling facilitates changes to internal data formats without affecting existing database consumers.</p>

<p><a name="998925"> </a>Data types defined in column property sets are Palm OS primitives or their vectors. The Data Manager converts between its physical data types and the logical data types that are enforced during field get and set operations.</p>

<h4 class="hcH4">
  <a name="998926"> </a>Column Properties
</h4>

<p><a name="998927"> </a>A schema is a collection of column property sets. Each column property set contains the following <b>built-in properties</b>:</p>

<dl>
<dt><a name="998931"> </a>ID</dt>
<dd><a name="998932"> </a>A 32-bit application-defined identifier. This ID must be unique for a given table.</dd>

<dt><a name="998933"> </a>Name</dt>
<dd><a name="1010122"> </a>An application-defined name for the column. The column name must be unique for a given table. It can be up to 32 bytes in length, including the terminating null character, and must be a valid SQL identifier consisting only of 7-bit ASCII characters. The column name is stored in a single application-defined language encoding. </dd>

<dt><a name="998935"> </a>Data Type</dt>
<dd><a name="998936"> </a>The type of data contained within the database column.</dd>

<dt><a name="998937"> </a>Size</dt>
<dd><a name="998938"> </a>The maximum size, in bytes, for columns that contain variable-length strings, blobs, and vectors.</dd>

<dt><a name="998939"> </a>Attributes</dt>
<dd><a name="998940"> </a>A set of flags that indicate whether the column data can be modified, whether the column was added to the table after the table was created, and whether or not the column data will be synchronized. (Modifications made to a "non-syncable" column's data don't change the modification state for the row, and thus by themselves don't cause the row to be flagged as modified.)</dd>

</dl>

<p><a name="998941"> </a>These built-in column properties are provided by the Data Manager and cannot be removed. In addition to these built-in properties, you can define custom properties for a column: properties that facilitate application-specific semantics for columns. For more information on manipulating the column definitions that make up a schema, see <a href="Intro_Databases.html#999237">"Working with Column Definitions."</a></p>

<h4 class="hcH4">
  <a name="998945"> </a>Column Data Types
</h4>

<p><a name="998949"> </a>Schema databases support the column data types listed in <a href="Intro_Databases.html#1010135">Table 8.2</a>.</p>

<p class="fineprint">
<p class="caption"><a name="1010135"> </a><b>Table 8.2&nbsp;&nbsp;Supported schema column data types </b></p>
<div class="tablediv"><table cellspacing="0" class="tTable">

  <tr valign="top">
    <th><p class="tt"><a name="1010143"> </a><b>Palm OS Primitive/Logical Types</b></p>
    </th>
    <th><p class="tt"><a name="1010145"> </a><b>Description</b></p>
    </th>
    <th><p class="tt"><a name="1010147"> </a><b>Storage Requirement</b></p>
    </th>
    <th><p class="tt"><a name="1010149"> </a><b>Range/Size</b></p>
    </th>
  </tr>
  <tr valign="top">
    <td><p class="tt"><a name="1010151"> </a><code>uint8_t</code></p>
    </td>
    <td><p class="tt"><a name="1010153"> </a>Unsigned char</p>
    </td>
    <td><p class="tt"><a name="1010155"> </a>1 byte</p>
    </td>
    <td><p class="tt"><a name="1010157"> </a>0 to 255</p>
    </td>
  </tr>
  <tr valign="top">
    <td><p class="tt"><a name="1010159"> </a><code>uint16_t</code></p>
    </td>
    <td><p class="tt"><a name="1010161"> </a>Unsigned short int</p>
    </td>
    <td><p class="tt"><a name="1010163"> </a>2 bytes</p>
    </td>
    <td><p class="tt"><a name="1010165"> </a>0 to 65535</p>
    </td>
  </tr>
  <tr valign="top">
    <td><p class="tt"><a name="1010167"> </a><code>uint32_t</code></p>
    </td>
    <td><p class="tt"><a name="1010169"> </a>Unsigned int</p>
    </td>
    <td><p class="tt"><a name="1010171"> </a>4 bytes</p>
    </td>
    <td><p class="tt"><a name="1010173"> </a>0 to 4294967295</p>
    </td>
  </tr>
  <tr valign="top">
    <td><p class="tt"><a name="1010175"> </a><code>uint64_t</code></p>
    </td>
    <td><p class="tt"><a name="1010177"> </a></p>
    </td>
    <td><p class="tt"><a name="1010179"> </a>8 bytes</p>
    </td>
    <td><p class="tt"><a name="1010181"> </a></p>
    </td>
  </tr>
  <tr valign="top">
    <td><p class="tt"><a name="1010183"> </a><code>int8_t</code></p>
    </td>
    <td><p class="tt"><a name="1010185"> </a>Signed char</p>
    </td>
    <td><p class="tt"><a name="1010187"> </a>1 byte</p>
    </td>
    <td><p class="tt"><a name="1010189"> </a>-128 to 127</p>
    </td>
  </tr>
  <tr valign="top">
    <td><p class="tt"><a name="1010191"> </a><code>int16_t</code></p>
    </td>
    <td><p class="tt"><a name="1010193"> </a>Signed short int</p>
    </td>
    <td><p class="tt"><a name="1010195"> </a>2 bytes</p>
    </td>
    <td><p class="tt"><a name="1010197"> </a>-32768 to 32767</p>
    </td>
  </tr>
  <tr valign="top">
    <td><p class="tt"><a name="1010199"> </a><code>int32_t</code></p>
    </td>
    <td><p class="tt"><a name="1010201"> </a>Signed int</p>
    </td>
    <td><p class="tt"><a name="1010203"> </a>4 bytes</p>
    </td>
    <td><p class="tt"><a name="1010205"> </a>-2147483648 to 2147483647</p>
    </td>
  </tr>
  <tr valign="top">
    <td><p class="tt"><a name="1010207"> </a><code>int64_t</code></p>
    </td>
    <td><p class="tt"><a name="1010209"> </a></p>
    </td>
    <td><p class="tt"><a name="1010211"> </a>8 bytes</p>
    </td>
    <td><p class="tt"><a name="1010213"> </a></p>
    </td>
  </tr>
  <tr valign="top">
    <td><p class="tt"><a name="1010215"> </a><code>float</code></p>
    </td>
    <td><p class="tt"><a name="1010217"> </a>Float</p>
    </td>
    <td><p class="tt"><a name="1010219"> </a>4 bytes</p>
    </td>
    <td><p class="tt"><a name="1010221"> </a></p>
    </td>
  </tr>
  <tr valign="top">
    <td><p class="tt"><a name="1010223"> </a><code>double</code></p>
    </td>
    <td><p class="tt"><a name="1010225"> </a>Double</p>
    </td>
    <td><p class="tt"><a name="1010227"> </a>8 bytes</p>
    </td>
    <td><p class="tt"><a name="1010229"> </a></p>
    </td>
  </tr>
  <tr valign="top">
    <td><p class="tt"><a name="1010231"> </a><code>Boolean</code></p>
    </td>
    <td><p class="tt"><a name="1010233"> </a>True /False value</p>
    </td>
    <td><p class="tt"><a name="1010235"> </a>1 byte</p>
    </td>
    <td><p class="tt"><a name="1010237"> </a>0 or 1</p>
    </td>
  </tr>
  <tr valign="top">
    <td><p class="tt"><a name="1010239"> </a><code>DateTimeType</code></p>
    </td>
    <td><p class="tt"><a name="1010241"> </a>Date-Time type</p>
    </td>
    <td><p class="tt"><a name="1010243"> </a>14 bytes</p>
    </td>
    <td><p class="tt"><a name="1010245"> </a></p>
    </td>
  </tr>
  <tr valign="top">
    <td><p class="tt"><a name="1010247"> </a><code>DateType</code></p>
    </td>
    <td><p class="tt"><a name="1010249"> </a>Date expressed as an absolute date</p>
    </td>
    <td><p class="tt"><a name="1010251"> </a>2 bytes</p>
    </td>
    <td><p class="tt"><a name="1010253"> </a></p>
    </td>
  </tr>
  <tr valign="top">
    <td><p class="tt"><a name="1010255"> </a><code>TimeType</code></p>
    </td>
    <td><p class="tt"><a name="1010257"> </a></p>
    </td>
    <td><p class="tt"><a name="1010259"> </a>2 bytes</p>
    </td>
    <td><p class="tt"><a name="1010261"> </a></p>
    </td>
  </tr>
  <tr valign="top">
    <td><p class="tt"><a name="1010263"> </a>time_t</p>
    </td>
    <td><p class="tt"><a name="1010265"> </a>(<code>dbDateTimeSecs</code>) Time in seconds since the UNIX epoch</p>
    </td>
    <td><p class="tt"><a name="1010267"> </a>4 bytes</p>
    </td>
    <td><p class="tt"><a name="1010269"> </a>-2147483648 to 2147483647</p>
    </td>
  </tr>
  <tr valign="top">
    <td><p class="tt"><a name="1010271"> </a><code>char</code></p>
    </td>
    <td><p class="tt"><a name="1010273"> </a>Fixed-length character string</p>
    </td>
    <td><p class="tt"><a name="1010275"> </a><i>m</i> bytes, where m is the statically-defined length and 1 &lt;= <i>m</i> &lt;= 255</p>
    </td>
    <td><p class="tt"><a name="1010277"> </a>1 &lt;= <i>m</i> &lt;= 255, where <i>m</i> is the maximum defined length.</p>
    </td>
  </tr>
  <tr valign="top">
    <td><p class="tt"><a name="1010279"> </a>VarChar</p>
    </td>
    <td><p class="tt"><a name="1010281"> </a>Variable-length character string</p>
    </td>
    <td><p class="tt"><a name="1010283"> </a><i>n</i>+4, where <i>n</i> is the actual string length and where <i>n</i> &lt;= <i>m</i>. <i>m</i> is the maximum defined length and 1 &lt;= <i>m</i> &lt;= 2<sup>32</sup></p>
    </td>
    <td><p class="tt"><a name="1010285"> </a>1 &lt;= <i>m</i> &lt;= 2<sup>32</sup>, where <i>m</i> is the maximum defined length.</p>
    </td>
  </tr>
  <tr valign="top">
    <td><p class="tt"><a name="1010287"> </a>blob</p>
    </td>
    <td><p class="tt"><a name="1010289"> </a>Variable-length array of bytes.</p>
    </td>
    <td><p class="tt"><a name="1010291"> </a><i>n</i>+4, where <i>n</i> is the actual string length and where <i>n</i> &lt;= <i>m</i>. <i>m</i> is the maximum defined length and 1 &lt;= <i>m</i> &lt;= 2<sup>32</sup></p>
    </td>
    <td><p class="tt"><a name="1010293"> </a>1 &lt;= <i>m</i> &lt;= 2<sup>32</sup>, where <i>m</i> is the maximum defined length.</p>
    </td>
  </tr>
  <tr valign="top">
    <td><p class="tt"><a name="1010295"> </a>Vector</p>
    </td>
    <td><p class="tt"><a name="1010297"> </a>Variable-length vectors of Palm primitive numeric, string, and date-time types. See <a href="Intro_Databases.html#1010312">Table 8.3</a>, below, for a list of supported vector types.</p>
    </td>
    <td><p class="tt"><a name="1010302"> </a><i>n</i>+4, where <i>n</i> is the number of bytes needed to contain the vector.</p>
    </td>
    <td><p class="tt"><a name="1010304"> </a>2<sup>32</sup> bytes.</p>
    </td>
  </tr>
</table>

</div>

</p>

<p class="fineprint">
<p class="caption"><a name="1010312"> </a><b>Table 8.3&nbsp;&nbsp;Supported vector types </b></p>
<div class="tablediv"><table cellspacing="0" class="tTable">

  <tr valign="top">
    <th><p class="tt"><a name="1010316"> </a><b>Vector Types</b></p>
    </th>
    <th><p class="tt"><a name="1010318"> </a><b>Usage</b></p>
    </th>
  </tr>
  <tr valign="top">
    <td><p class="tt"><a name="1010320"> </a><code>uint8_t</code> vectors</p>
    </td>
    <td><p class="tt"><a name="1010322"> </a><code>uint8_t[]</code></p>
    </td>
  </tr>
  <tr valign="top">
    <td><p class="tt"><a name="1010324"> </a><code>uint16_t</code> vectors</p>
    </td>
    <td><p class="tt"><a name="1010326"> </a><code>uint16_t[]</code></p>
    </td>
  </tr>
  <tr valign="top">
    <td><p class="tt"><a name="1010328"> </a><code>uint32_t</code> vectors</p>
    </td>
    <td><p class="tt"><a name="1010330"> </a><code>uint32_t[]</code></p>
    </td>
  </tr>
  <tr valign="top">
    <td><p class="tt"><a name="1010332"> </a><code>uint64_t</code> vectors</p>
    </td>
    <td><p class="tt"><a name="1010334"> </a><code>uint64_t[]</code></p>
    </td>
  </tr>
  <tr valign="top">
    <td><p class="tt"><a name="1010336"> </a><code>float</code> vectors</p>
    </td>
    <td><p class="tt"><a name="1010338"> </a><code>float[]</code></p>
    </td>
  </tr>
  <tr valign="top">
    <td><p class="tt"><a name="1010340"> </a><code>double</code> vectors</p>
    </td>
    <td><p class="tt"><a name="1010342"> </a><code>double[]</code></p>
    </td>
  </tr>
  <tr valign="top">
    <td><p class="tt"><a name="1010344"> </a><code>Boolean</code> vectors</p>
    </td>
    <td><p class="tt"><a name="1010346"> </a><code>Boolean[]</code></p>
    </td>
  </tr>
  <tr valign="top">
    <td><p class="tt"><a name="1010348"> </a><code>DateTimeType</code> vectors</p>
    </td>
    <td><p class="tt"><a name="1010350"> </a><code>DateTimeType[]</code></p>
    </td>
  </tr>
  <tr valign="top">
    <td><p class="tt"><a name="1010352"> </a><code>DateType</code> vectors</p>
    </td>
    <td><p class="tt"><a name="1010354"> </a><code>DateType[]</code></p>
    </td>
  </tr>
  <tr valign="top">
    <td><p class="tt"><a name="1010356"> </a><code>TimeType</code> vectors</p>
    </td>
    <td><p class="tt"><a name="1010358"> </a><code>TimeType[]</code></p>
    </td>
  </tr>
  <tr valign="top">
    <td><p class="tt"><a name="1010360"> </a>String vectors</p>
    </td>
    <td><p class="tt"><a name="1010362"> </a>Array of null-terminated strings, with an extra terminating null character marking the end of the vector. For instance, using 7-bit ASCII: <code>"String1\0String2\0String3\0\0"</code> </p>
    </td>
  </tr>
</table>

</div>

</p>
<div class="NINoteImportant"><hr>
  <a name="999180"> </a> <b>NOTE: </b> In a string vector, the null characters must be interpreted as encoding-dependent null characters instead of null bytes. A null character may be multi-byte for a specific encoding scheme.
<hr>
</div>

<h4 class="hcH4">
  <a name="999182"> </a>Database, Table, and Column Identifiers
</h4>

<p><a name="1000933"> </a>Schema databases are uniquely identified by a combination of their name and their creator ID. </p>

<p><a name="1000940"> </a>Database tables are identified by name. There is no need for a numeric "table identifier." Table names should be valid SQL identifiers up to 32 bytes in length, including the terminating null character.</p>

<p><a name="1010399"> </a>A column is uniquely identified by either the column's descriptive name or by a 32-bit ID (both must be unique). These application-defined column names and IDs allow multiple applications within a given application context to share a common semantic understanding of a given column type. For instance, two applications might select a name of "EMNO" for the employee number column of the "EMPLOYEE" database and use column-based search and retrieval of values in the column named "EMNO". The design-time specification of both column identifiers and table names facilitates the development of public metadata interfaces for databases and encourages generic data exchange based on these interfaces.</p>

<h4 class="hcH4">
  <a name="999205"> </a>Creating, Modifying, and Deleting Tables
</h4>

<p><a name="999206"> </a>You can create tables either at the time you create a database or after the fact. Each table definition specifies the table's name and an array of column definitions. </p>

<p><a name="1001215"> </a>You can remove a table from a database only if the table contains either no rows or only rows whose deleted bit is set. If the table contains non-deleted rows, delete or remove them first. Once the table is empty (it can still contain rows that are marked as deleted), you can remove the table from the database.</p>

<p><a name="999229"> </a>When modifying an existing table, you are limited to adding columns and modifying custom column properties. </p>

<h4 class="hcH4">
  <a name="999237"> </a>Working with Column Definitions
</h4>

<p><a name="1001310"> </a>Each table maintains a list of column definitions, each with a column ID unique within the table. This ID is necessary to work with individual columns, but isn't needed to obtain the complete set of column definitions that make up a schema.</p>

<p><a name="1001324"> </a>In addition to any custom properties you define for a column definition, all columns have a set of built-in properties. These built-in properties are read-only, to prevent applications from modifying existing data row columns in a way that can impact other data consumers. The following are the built-in properties for a column:</p>
<ul type="disc">
  <li><a name="1010403"> </a>Name (must be unique)
  <li><a name="999263"> </a>Data type
  <li><a name="999264"> </a>Size (maximum byte size for variable-length strings, blobs, and vectors)
  <li><a name="999265"> </a>Attributes
</ul>

<p><a name="999266"> </a>Unlike the built-in properties, custom properties may be read, written and deleted. Custom property IDs must fall outside the built-in property ID range.</p>

<p><a name="999267"> </a>For a given column, the schema Sync Manager allows you to define custom properties, if the specified property ID does not exist. If the specified property ID exists, its value is updated to the new value. You can also retrieve the value of a custom or built-in property, but you can remove only custom properties. If you remove a custom column property, only the property is removed, not the column values.</p>

<h4 class="hcH4">
  <a name="999288"> </a>Row Attributes
</h4>

<p><a name="999292"> </a>Schema database rows can have the attributes listed in <a href="Intro_Databases.html#999296">Table 8.4</a>.</p>

<p class="fineprint">
<p class="caption"><a name="999296"> </a><b>Table 8.4&nbsp;&nbsp;Schema database row attributes</b></p>
<div class="tablediv"><table cellspacing="0" class="tTable">

  <tr valign="top">
    <th><p class="tt"><a name="999300"> </a><b>Attribute</b></p>
    </th>
    <th><p class="tt"><a name="999302"> </a><b>Description</b></p>
    </th>
  </tr>
  <tr valign="top">
    <td><p class="tt"><a name="999304"> </a>Archive</p>
    </td>
    <td><p class="tt"><a name="999306"> </a>The row's data is preserved until the next HotSync. When the archive bit is set, the delete bit is set as well, so archived rows are otherwise treated like deleted rows.</p>
    </td>
  </tr>
  <tr valign="top">
    <td><p class="tt"><a name="999308"> </a>Delete</p>
    </td>
    <td><p class="tt"><a name="999310"> </a>The row has been deleted.</p>
    </td>
  </tr>
  <tr valign="top">
    <td><p class="tt"><a name="999312"> </a>Read-only</p>
    </td>
    <td><p class="tt"><a name="999314"> </a>The row is read-only, and cannot be written to.</p>
    </td>
  </tr>
  <tr valign="top">
    <td><p class="tt"><a name="999316"> </a>Secret (private)</p>
    </td>
    <td><p class="tt"><a name="999318"> </a>The row is private.</p>
    </td>
  </tr>
</table>

</div>

</p>
<div class="NINoteImportant"><hr>
  <a name="999320"> </a> <b>NOTE: </b> Neither the Data Manager on the handheld nor the schema Sync Manager places any semantics on the read-only attribute. It is up to the application or conduit to enforce the read-only semantics.
<hr>
</div>

<p><a name="999321"> </a>The read-only attribute is used to support certain record sharing scenarios that allow a user to view a record, but not to modify it. Note that schemas also allow the definition of "always writable" columns that allow particular fields to be writable in a read-only row. This might be used, for example, in a calendar event for a TV show that is read-only (you can't reschedule the show); the field containing the alarm information would be "always writable" allowing each user the option of setting an alarm.</p>

<h4 class="hcH4">
  <a name="999379"> </a>Categories
</h4>

<p><a name="1001750"> </a>Categories are a user-controlled means of grouping or filtering records or rows. Non-schema databases allow records to be a member of only one of 15 categories, or "Unfiled." Schema database rows, on the other hand, can be a member of any combination of up to 255 categories (or none&#8212the equivalent of "Unfiled"). Thus, where in an extended database a record might, say, have to either fall into the "Personal" or "Business" category, in a schema database a row could fall into both.</p>

<p><a name="999381"> </a>As with non-schema databases, category information is local to a database. However, unlike non-schema databases which store information about that database's categories in the application info block, schema databases rely upon an internal "category info" block to contain this information.</p>

<p><a name="999382"> </a>Information about the database's categories, such as the number and names of the categories, as well as the order in which they occur in a UI list, is controlled by the Category Manager on the handheld. The Data Manager is responsible only for managing the category membership of individual database rows. The Sync Manager on the desktop enables conduits to access this category information.</p>

<p><a name="999383"> </a>Category membership for a row is limited to the maximum number of categories that can be defined locally in a schema database. Because the maximum number of categories a database can support is limited to 255, any given row can only be a member of up to 255 categories. </p>

<p><a name="999384"> </a>In a non-schema database, records are always in one category ("Unfiled" is just a specific category). In a schema database, rows may be in one category, multiple categories, or none. The notion of "Unfiled" as a category doesn't make sense here, because rows shouldn't be able to be in the "Unfiled" category and in other categories at the same time. Because applications and conduits can perform other operations on rows with no category membership, a row that is a member of no database categories could be thought of as "Unfiled." Note that the Category Manager on the handheld controls how rows with no category membership are displayed to end users.</p>

<p><a name="999385"> </a>The Data Manager stores category local IDs as category membership information for a record or row. Storing category local IDs abstracts the Data Manager from any modifications performed on the internal category structure, such as adding or deleting a category.</p>

<p><a name="1001781"> </a>The schema Sync Manager enables conduits to manipulate categories or a row's category membership in the following ways:</p>
<ul type="disc">
  <li><a name="1001787"> </a>Set and get the category membership for single or multiple rows.
  <li><a name="1001788"> </a>Add, delete, and modify category names.
  <li><a name="1001800"> </a>Get the number of categories a row is a member of.
  <li><a name="1001816"> </a>Remove a row from a category.
  <li><a name="1001826"> </a>Retrieve the number, names, and IDs of categories.
</ul>

<p><a name="1001840"> </a>Also, the schema Sync Manager lets conduits manipulate rows that meet the given category membership criteria:</p>
<ul type="disc">
  <li><a name="1001847"> </a>Get the number of all rows whose category membership matches the specified category membership criteria.
  <li><a name="1001855"> </a>Delete all rows with category membership matching the specified category membership criteria.
  <li><a name="1001871"> </a>Replace one or more categories with the specified category for all rows, depending on the given match mode criteria.
  <li><a name="1001879"> </a>Remove category membership in the specified categories from all rows in the database, depending on the match mode criteria.
  <li><a name="1001880"> </a>Determine whether a row is a member of the specified categories, depending on the given match mode criteria.
  <li><a name="1001881"> </a>Get a list of all the modified rows whose category membership matches the specified category membership criteria.
</ul>

<h4 class="hcH4">
  <a name="999434"> </a>Application Info Block
</h4>

<p><a name="999435"> </a>Schema databases don't have a dedicated application info block. For application-specific data of the type found in a non-schema database's application info block, create a database table specifically for this purpose.</p>
<h3 class="hbH3">
  <a name="999436"> </a>Schema Database Rows <a href="#995933"><span class="nav">^TOP^</span></a>
</h3>


<p><a name="999440"> </a>As discussed in <a href="Intro_Databases.html#998909">"Schemas and Tables,"</a> a schema database table can have zero or more rows, and each row within the table shares a common structure, or schema.</p>

<p><a name="999441"> </a>Rows are identified by a 32-bit identifier that is unique within the database. You supply the row ID when reading, writing, deleting, and removing rows. In the rare instance that you find yourself with a row ID independent of the table from which it came, you can call a schema Sync Manager function to determine to which table the row belongs.</p>

<h4 class="hcH4">
  <a name="999448"> </a>Creating New Rows
</h4>

<p><a name="1010415"> </a>The schema Sync Manager allows you to create a new row and add it to a table; you can't add a row to a database without adding it to a table. Assuming that the row was added to the table successfully, the schema Sync Manager returns the row ID of your new row. Optionally, you can add an "empty" row by not supply any data.</p>
<div class="NINoteImportant"><hr>
  <a name="1002036"> </a> <b>NOTE: </b> Row IDs are assigned to new rows by the Data Manager on the handheld; conduits do not assign or change row IDs. The only exception is during a restore operation, which happens during the HotSync operation after a handheld has been hard reset.
<hr>
</div>

<p><a name="999456"> </a>Rows added to a table are added to the end of the database. You aren't given the opportunity to specify the position of the row within the table. The schema Sync Manager APIs also don't include a function for altering the position of a row within a table. That is because when applications work with schema database rows, they often are working within the context of a cursor, within which applications can perform such operations. The schema Sync Manager does not provide conduits access to cursors.</p>

<h4 class="hcH4">
  <a name="999458"> </a>Reading and Writing Data
</h4>

<p><a name="1002272"> </a>Columns in a row are identified by a 32-bit application-defined ID. The Data Manager also identifies them by an index, but the schema Sync Manager enables conduits to access them only by ID.</p>

<p><a name="1002572"> </a>The schema Sync Manager provides the means to read and write:</p>
<ul type="disc">
  <li><a name="1002573"> </a>a partial column value specified by column ID, offset from the beginning of the column value, and the number of bytes to read (C/C++ Sync Suite only)
  <li><a name="1002574"> </a>one or more complete column values specified by column ID
  <li><a name="1002575"> </a>all the column values in a row specified by record ID
  <li><a name="1002618"> </a>multiple rows in a single call
</ul>

<p><a name="1002576"> </a>Reading and writing partial column values is useful for columns containing large strings or blobs where, for space efficiency it makes sense to read or write only a portion of the column's data.</p>

<h4 class="hcH4">
  <a name="1000110"> </a>Deleting Rows
</h4>

<p><a name="1002762"> </a>When a user "deletes" a row in a schema database on the handheld, the row's data chunk is freed (effectively destroying the data), the local ID stored in the row entry is set to 0, and the delete bit is set in the row's attributes. When the user "archives" a row, the delete bit is set, but the data chunk is not freed and the local ID is preserved. This way, the next time the user performs a HotSync operation, a conduit can quickly determine which records to remove (because their row entries are still around on the handheld). "Remove" in this sense means that the row's data chunk, if present, and row entry are disposed of. In the case of archived rows, a conduit can save the row data on the desktop before it permanently removes the row entry and data from the handheld. For deleted rows, the conduit just has to delete the same row from the desktop before permanently removing the row entry from the handheld.</p>

<p><a name="1002843"> </a>To clarify the use of terminology in the schema Sync Manager APIs:</p>

<dl>
<dt><a name="1002844"> </a>Delete</dt>
<dd><a name="1002931"> </a>Set the row's delete bit, retain the row's entry in the header, and dispose of a row's data. Usually only handheld applications delete rows, but a conduit can delete rows also.</dd>

<dt><a name="1002865"> </a>Remove</dt>
<dd><a name="1002850"> </a>Dispose of a row's data and its entry in the header. This leaves no trace of the row. Either an application or a conduit may remove rows.</dd>

<dt><a name="1002854"> </a>Archive</dt>
<dd><a name="1002881"> </a>Set the row's delete bit and retain the row's data and entry in the database header. Only handheld applications archive rows. This allows a conduit the opportunity to transfer the row data to the desktop before removing it from the handheld.</dd>

<dt><a name="1002856"> </a>Purge</dt>
<dd><a name="1002857"> </a>Means the same as "remove" but removes all rows with their delete bit set. This is what a conduit usually does with a handheld database after it has synchronized it. Note that this usage differs somewhat from the terminology used in classic and extended Sync Manager APIs.</dd>

</dl>

<h4 class="hcH4">
  <a name="1002748"> </a>Maintaining Row Order
</h4>

<p><a name="1002751"> </a>The handheld application is responsible for determining the order of rows in a schema database. An application can define a default sort index and multiple sort indexes for a table in a schema database, but a conduit can specify only the default sort index when it works with a table. Therefore when a conduit reads multiple rows, they are retrieved in the order specified by the database's default sort index.</p>
<h3 class="hbH3">
  <a name="1000119"> </a>Secure Databases <a href="#995933"><span class="nav">^TOP^</span></a>
</h3>


<p><a name="1000120"> </a>Some applications need to create secure databases that restrict access to the database. The Data Manager supports the creation of secure, schema databases that are protected by application-defined access rules, which are also known as <b>rule sets</b>. </p>

<p><a name="1000125"> </a>For more about creating and defining access rules for secure databases, see <i>Exploring Palm OS: Memory, Databases, and Files</i>.</p>

<h4 class="hcH4">
  <a name="1000181"> </a>Synchronizing Secure Databases
</h4>

<p><a name="1000182"> </a>The Data Manager restricts access to a secure database to only those applications and users authorized by the database's access rules. During a HotSync<sup>&#174;</sup> operation, the HotSync client on the handheld uses Data Manager functions to access the handheld databases on behalf of the conduits running on the desktop. The HotSync client application must be able to access secure databases that need to be synchronized or backed up. </p>

<p><a name="1000183"> </a>For an application to ensure that its secure database is syncable, it must modify the database access rules so that the HotSync client has special "bypass" access using the <code>AzmLibSetBypass()</code> function (see <i>Exploring Palm OS: Security and Cryptography</i>). When the HotSync client is given bypass access, any conduit on the desktop is able to access the database (the HotSync process does not provide a way to restrict access on a per-conduit basis). The bypass access must be made for each action needed. Because you can grant the HotSync client bypass access for each action separately, you can, for example, give the HotSync client read access, but not write or delete access.</p>

<p><a name="1000184"> </a>If the HotSync client is not given bypass access, it is subject to the normal access rules as defined by the application. For example, if an application defines the access rules for its database so that only signed applications have access (read, write, or delete), during a HotSync operation the database isn't syncable because the HotSync client doesn't have the proper signature required to access the data. Therefore to allow syncing of the database the application must give "bypass" access to the HotSync client, which essentially grants access both to the HotSync client and to any properly-signed application.</p>

<p><a name="1003152"> </a>The HotSync client on the handheld maintains a notion of <b>trusted desktops</b>. The HotSync process allows syncing or backing up of secure databases to only trusted desktops, unless the user has not set a password (user token) on the handheld. Whenever a user with a password set performs a HotSync operation with a desktop for the first time, the HotSync client on the handheld prompts the user to indicate whether the user trusts the desktop they are synchronizing with. If the user does not trust the desktop, then conduits on that desktop can access only databases that are not secure. During a HotSync operation, conduits can call the Sync Manager to determine whether the handheld trusts the desktop. Conduits that need to access secure databases can use the trust status to determine what to do when secure databases are unavailable.</p>

<p><a name="1017248"> </a>For more on trusted desktops, see <a href="Intro_Trust.html#995934">Chapter 9, "Understanding Trusted Desktops."</a></p>

<h4 class="hcH4">
  <a name="1016679"> </a>Creating Secure Databases
</h4>

<p><a name="1016687"> </a>A conduit by itself cannot create a secure database even during a HotSync operation at a trusted desktop. There are no Sync Manager APIs to create a secure database from the desktop. A secure database can be created only by an application on the handheld.</p>

<p><a name="1016688"> </a>However, a conduit can work around this restriction by using the C <a href="CRef_SyncCommon.html#1283837"><code>SyncCallDeviceApplication()</code></a> or COM <a href="COMRef_Meth.html#1816446"><code>CallDeviceApplication()</code></a> API to call an application on the handheld. This target application can then create the secure database and assign appropriate access privileges. The target application should ensure that it assigns appropriate privileges to itself before accessing the secure database; otherwise it could cause UI to pop up in the middle of the HotSync operation (because the application is sublaunched and does not benefit from the sync bypass rule).</p>

<p><a name="1017182"> </a>Because using this API causes the HotSync client on the handheld to locally sublaunch the target application, the application context that gets implicitly passed in is the one for the HotSync client. Moreover, the HotSync client turns off its own access to all secure databases (via the bypass rule) before sublaunching the target application. (Otherwise, this would be a security breach, because the sublaunched application could then access any secure database accessible by the HotSync client.) Therefore the target application sublaunched in this way can create a secure database and set up the appropriate security privileges for the target application to access the database outside of a HotSync operation, but it cannot open and read/write the secure database it created. Neither can the target application access other databases that it previously secured with an application fingerprint or signature-based token. This restriction may not be a problem, if you only need the sublaunched target application to create a secure database, which the conduit can then read/write like any other secure database using the Sync Manager API. But if you need the sublaunched target application itself to write data in the secure database it creates during a HotSync operation, it can do the following:</p>
<ol type="1">
  <li value="1"><a name="1016990"> </a>Create the secure database.
  <li value="2"><a name="1017044"> </a>Temporarily assign read/write privileges to all or only to the sync application, whether it is the HotSync client or another sync application. (The target application doesn't need to hardcode the sync application's token fingerprint. This can be discovered and set dynamically. Hence, the target application is not bound to any single sync solution.)
  <li value="3"><a name="1016992"> </a>Write data to the database as needed.
  <li value="4"><a name="1016993"> </a>Assign the permanent privileges&#8212that is, create and set a token based on the application's fingerprint or its digital signature.
</ol>

<p><a name="1019015"> </a>For more information about security in Palm OS Cobalt, see <i>Exploring Palm OS: Security and Cryptography</i> and <i>Exploring Palm OS: Memory, Databases, and Files</i>.</p>

<h4 class="hcH4">
  <a name="1019022"> </a>Backing up Secure Databases
</h4>

<p><a name="1019023"> </a>When a secure database is backed up to the desktop, it is sent to the desktop in encrypted form and is saved on the desktop encrypted. During a backup operation the Data Manager encrypts the data so that only the Data Manager can decrypt it. This differs from a sync operation; when data is sent to the desktop during synchronization it is sent "in the clear"&#8212it is not encrypted.</p>

<p><a name="1003221"> </a>The desktop Sync Manager provides functions that conduits can use to back up and restore both classic as well as secure and nonsecure schema databases. But only the handheld Data Manager can encrypt and decrypt secure databases. Therefore the desktop Sync Manager includes functions that conduits can use to backup and restore the security data that the Data Manager requires to decrypt secure databases after they are restored to the handheld, say after the handheld is hard-reset.</p>

<p><a name="1003222"> </a>Note that the Sync Manager can restore only the secure databases that it backed up to the desktop. It is not possible to create secure databases on the desktop and install them on the handheld. Only the Data Manager on the handheld can create secure databases.</p>
<h3 class="hbH3">
  <a name="1000218"> </a>Concurrent Schema Database Access <a href="#995933"><span class="nav">^TOP^</span></a>
</h3>


<p><a name="1003268"> </a>Consider two types of concurrent access to schema databases:</p>
<ul type="disc">
  <li><a name="1003269"> </a><i>Two</i> entities accessing <i>one</i> database concurrently
  <li><a name="1003270"> </a><i>One</i> entity accessing <i>two or more</i> databases concurrently
</ul>

<h4 class="hcH4">
  <a name="1000219"> </a>Two Entities, One Database
</h4>

<p><a name="1003278"> </a>When you open a non-schema database with write access, you have exclusive access to that database: no one else can open that database while you have it open, even if they are just opening it with read access. Or, when you open a non-schema database with read access, no one else can open that same database with write access. This can be somewhat restrictive: on a communicator-style device, for example, if you are editing a record in the address book when the phone rings, the phone application running in another process couldn't open the address book in order to perform a caller-ID lookup.</p>

<p><a name="1000220"> </a>Schema databases don't have this problem because they support concurrent access to a single database. Note that schema databases don't support concurrent write access: <i>only one writer and multiple readers are allowed.</i> </p>

<p><a name="1009718"> </a>Examples of entities accessing the same database concurrently are a single conduit that runs in multiple threads and needs to open the same database in more than one thread, and processes on the handheld that access the same database at the same time a conduit does. Therefore the Data Manager enforces the same concurrent access rules for conduits as it does for applications.</p>

<p><a name="1003233"> </a>When opening a schema database you specify a <b>share mode</b> in addition to an access mode (or open mode). The following share mode constants are supported for schema databases. Only one share mode can be specified when opening a database.</p>

<dl>
<dt><a name="1003254"> </a>None</dt>
<dd><a name="1003255"> </a>No one else can open this database.</dd>

<dt><a name="1003256"> </a>Read</dt>
<dd><a name="1003257"> </a>Others can open this database with read access.</dd>

<dt><a name="1003258"> </a>Read/write</dt>
<dd><a name="1003259"> </a>Others can open this database with read or write access.</dd>

</dl>

<p><a name="1003327"> </a>Concurrent write access to the same database is not supported. That is, specifying an access mode of read/write and a share mode of read/write is not supported; an error is returned if you attempt to open a database with this combination of access and share modes. </p>

<p><a name="1003338"> </a><a href="Intro_Databases.html#1003342">Table 8.5</a> shows all of the allowed combinations of access modes and share modes and identifies which combinations can be used together (those that are marked <b>Yes</b>).</p>

<p class="fineprint">
<p class="caption"><a name="1003342"> </a><b>Table 8.5&nbsp;&nbsp;Allowable concurrent access/share mode combinations</b></p>
<div class="tablediv"><table cellspacing="0" class="tTable">

  <tr valign="top">
    <th><p class="tt"><a name="1003354"> </a><b></b></p>
    </th>
    <th><p class="tt"><a name="1003356"> </a><b>Mode=R<br>Share=None</b></p>
    </th>
    <th><p class="tt"><a name="1003358"> </a><b>Mode=R<br>Share=R</b></p>
    </th>
    <th><p class="tt"><a name="1003360"> </a><b>Mode=R<br>Share=R/W</b></p>
    </th>
    <th><p class="tt"><a name="1003362"> </a><b>Mode=R/W<br>Share=None</b></p>
    </th>
    <th><p class="tt"><a name="1003364"> </a><b>Mode=R/W<br>Share=R</b></p>
    </th>
  </tr>
  <tr valign="top">
    <td><p class="tt"><a name="1003366"> </a><b>Mode=R<br>Share=None</b></p>
    </td>
    <td><p class="tt"><a name="1003368"> </a>No</p>
    </td>
    <td><p class="tt"><a name="1003370"> </a>No</p>
    </td>
    <td><p class="tt"><a name="1003372"> </a>No</p>
    </td>
    <td><p class="tt"><a name="1003374"> </a>No</p>
    </td>
    <td><p class="tt"><a name="1003376"> </a>No</p>
    </td>
  </tr>
  <tr valign="top">
    <td><p class="tt"><a name="1003378"> </a><b>Mode=R<br>Share=R</b></p>
    </td>
    <td><p class="tt"><a name="1003380"> </a>No</p>
    </td>
    <td><p class="tt"><a name="1003382"> </a><b>Yes</b> </p>
    </td>
    <td><p class="tt"><a name="1003384"> </a><b>Yes</b> </p>
    </td>
    <td><p class="tt"><a name="1003386"> </a>No</p>
    </td>
    <td><p class="tt"><a name="1003388"> </a>No</p>
    </td>
  </tr>
  <tr valign="top">
    <td><p class="tt"><a name="1003390"> </a><b>Mode=R<br>Share=R/W</b></p>
    </td>
    <td><p class="tt"><a name="1003392"> </a>No</p>
    </td>
    <td><p class="tt"><a name="1003394"> </a><b>Yes</b> </p>
    </td>
    <td><p class="tt"><a name="1003396"> </a><b>Yes</b> </p>
    </td>
    <td><p class="tt"><a name="1003398"> </a>No</p>
    </td>
    <td><p class="tt"><a name="1003400"> </a><b>Yes</b> </p>
    </td>
  </tr>
  <tr valign="top">
    <td><p class="tt"><a name="1003402"> </a><b>Mode=R/W<br>Share=None</b></p>
    </td>
    <td><p class="tt"><a name="1003404"> </a>No</p>
    </td>
    <td><p class="tt"><a name="1003406"> </a>No</p>
    </td>
    <td><p class="tt"><a name="1003408"> </a>No</p>
    </td>
    <td><p class="tt"><a name="1003410"> </a>No</p>
    </td>
    <td><p class="tt"><a name="1003412"> </a>No</p>
    </td>
  </tr>
  <tr valign="top">
    <td><p class="tt"><a name="1003414"> </a><b>Mode=R/W<br>Share=R</b></p>
    </td>
    <td><p class="tt"><a name="1003416"> </a>No</p>
    </td>
    <td><p class="tt"><a name="1003418"> </a>No</p>
    </td>
    <td><p class="tt"><a name="1003420"> </a><b>Yes</b> </p>
    </td>
    <td><p class="tt"><a name="1003422"> </a>No</p>
    </td>
    <td><p class="tt"><a name="1003424"> </a>No</p>
    </td>
  </tr>
</table>

</div>

</p>

<p><a name="1000320"> </a>When sharing is enabled (that is, when the database is opened with shared read or shared read/write), the Data Manager server synchronizes access to the database. The synchronization is done at the database level. Each Data Manager (and hence Sync Manager) call is atomic, thus providing data integrity at the function level. Because the Data Manager doesn't support multiple applications writing to the same database, it doesn't have to deal with issues around concurrent updates.</p>

<h5 class="hdH5">
  <a name="1017340"> </a>Guidelines for Sharing Access to a Schema Database
</h5>

<p><a name="1017538"> </a>Because concurrent access is allowed, you must be careful how you open a database so that you do not unintentionally block another process from accessing the same database. For example, a phone application requires access to the Address Book database to look up caller ID information for an incoming call. At the same time, a HotSync operation could be in progress, during which a conduit needs to read/write the same database to synchronize it with the desktop.</p>

<p><a name="1017539"> </a>To prevent one process from unintentionally locking out database access to another process, you should follow these guidelines when opening a database:</p>
<ol type="1">
  <li value="1"><a name="1017414"> </a>Use the "Share None" mode only when you need exclusive access to the database&#8212that is, when you do not want any other application to have even read-only access to the database.
  <li value="2"><a name="1017460"> </a>Use the "Share Read" mode when you can allow another application to have read access to the database. For example, a conduit should open the Address Book database in "Open Read/Write" and "Share Read" modes, so that the conduit can read and modify the database, and at the same time allow an application such as the phone to open the Address Book database in "Open Read Only" and "Share Read/Write" modes so that it can look up caller information.
  <li value="3"><a name="1017500"> </a>Use "Share Read/Write" mode when you need to allow other processes (such as PIM applications or the HotSync client through conduits) to have both read and write access to the database. With this share mode, you must use "Open Read Only" mode.
</ol>

<h4 class="hcH4">
  <a name="1003477"> </a>One Entity, Two or More Databases
</h4>

<p><a name="1003506"> </a>The schema Sync Manager also supports <i>one</i> entity accessing <i>two or more</i> schema databases concurrently. Therefore a conduit can have multiple schema databases open at the same time. (The Sync Manager enforces a limit of only one open non-schema database at a time.) Your conduit must still close all open databases before your it completes, though.</p>
<h3 class="hbH3">
  <a name="1007124"> </a>Change Tracking Services for Schema Databases <a href="#995933"><span class="nav">^TOP^</span></a>
</h3>


<p><a name="1007144"> </a>The Data Manager on the handheld tracks changes in each schema database in much more detail than in each non-schema database. The most important capability that these extra services enable is that a conduit can fast-sync schema databases at multiple desktops in the most common synchronization scenarios; whereas a conduit always slow-syncs non-schema databases when the handheld synchronizes with a different desktop.</p>

<p><a name="1010055"> </a>When a schema database is first created, the Data Manager stores within the database header a 16-bit sync clock value. The database <b>sync clock</b> indicates when this database was last synchronized. At the time of its creation, a database has a sync clock value that starts at 1. Then every time a database is synchronized, the schema Sync Manager increments the database's sync clock by 1 at the end of the HotSync operation, but only if the conduit closes the database with a special "synced all changes" flag.</p>

<p><a name="1008429"> </a>To provide a conduit with more detailed change information, the Data Manager defines several <b>sync atoms</b>, units of information in a schema database for which the Data Manager tracks changes between HotSync operations. The following elements of a schema database are sync atoms:</p>
<ul type="disc">
  <li><a name="1007924"> </a>table schema definitions
  <li><a name="1010067"> </a>category definitions
  <li><a name="1007977"> </a>row column values (not individual column values)
  <li><a name="1010070"> </a>row category membership
</ul>

<p><a name="1008212"> </a>For each sync atom, the Data Manager maintains the following change information:</p>

<dl>
<dt><a name="1008213"> </a>change counter</dt>
<dd><a name="1008214"> </a>When any sync atom is modified, added, archived, or deleted, the Data Manager updates this counter with the current database sync clock value.</dd>

<dt><a name="1008208"> </a>purge counter</dt>
<dd><a name="1008113"> </a>When all the deleted instances of a sync atom are purged from a database, the Data Manager updates this counter with the current database sync clock value. This counter tracks the relative time of the last purge and applies to the entire database. When a desktop <b>purges</b> a database, the deleted sync atoms are completely removed from the handheld. When an out-of-date desktop (a purge was done after its last HotSync operation) synchronizes with the handheld, it must identify the purged atoms by comparing ID lists. </dd>

</dl>

<p><a name="1008507"> </a>Table schema can have one or more columns with a <b>non-syncable attribute</b> set. When a row is modified, its change counter is updated only if the change was made to a "syncable" column. If only non-syncable columns are modified for a row, the schema Sync Manager does not recognize the row as modified when you use any API that works with "modified" rows. However, the schema Sync Manager does allow non-syncable columns to be explicitly read from the desktop.</p>

<p><a name="1008670"> </a>Each schema database has a pseudo-randomly generated identifier for synchronization use only. The schema Sync Manager generates a new <b>database reset identifier</b> (DRID) for each schema database when it is created or restored to a handheld after a hard reset. The DRID enables the schema Sync Manger to identify situations in which the sync clock value and change counters are no longer dependable&#8212in which case, HotSync Manager tells a conduit that it cannot perform a fast sync. For example, when a database is restored after the handheld is hard reset, or when the database sync clock value rolls over. See <a href="Intro_HotSyncProc.html#996156">"Determining the Sync Mode"</a> for more information.</p>

<p><a name="1008657"> </a>The HotSync process uses these Data Manager services to return information via its APIs to conduits about the sync mode in which they should execute and which instances of each sync atom have been modified since the last HotSync operation for a given schema database. </p>

<p><a name="1010458"> </a>These change tracking services for schema databases provide the following advantages over the simple "dirty" flags available for non-schema databases and records:</p>
<ul type="disc">
  <li><a name="1008734"> </a>Change counters allow changes to be tracked forever, or until the handheld is hard reset or the counter wraps.
  <li><a name="1008738"> </a>Deleted sync atoms are tracked until they are purged, which enables fast sync at multiple desktops.
  <li><a name="1008741"> </a>Purge counters keep track of purges so that a conduit can improve its performance even during a slow sync.
  <li><a name="1008745"> </a>Categories are managed by the Category Manager (for the Data Manager) and have a change counter, which provides category name change tracking that is not provided for non-schema databases.
  <li><a name="1008830"> </a>For enterprise applications, change tracking at the column level is especially useful, because it enables a conduit to synchronize only the modified column values between the handheld and a database on a backend server.
</ul>

<h2 class="haH2">
  <a name="1003516"> </a>Non-Schema Databases <a href="#995933"><span class="nav">^TOP^</span></a>
</h2>


<p><a name="1003517"> </a>Schema databases impose a structure upon the data, organizing it into tables, rows, and columns. Non-schema databases, on the other hand, impose less overhead and are significantly more flexible. Of course, your application and conduit generally must do more work when dealing with non-schema databases, because they are entirely responsible for interpreting the structure of each record.</p>

<p><a name="1003518"> </a>Non-schema databases can either be record or resource databases. A <b>record database</b> holds application data. Each record can be structured in any fashion that the application desires. <b>Resource databases</b> are used to contain executable code, application resources, and the like. </p>

<p><a name="1003522"> </a>In Palm OS Cobalt, non-schema databases come in two "flavors": classic and extended. Classic databases are provided for compatibility with previous versions of Palm OS (and with applications running on Palm OS Cobalt through PACE). Because of a couple of long-standing limitations, however, unless your application needs this level of compatibility, it should use extended or schema databases instead. Both classic and extended databases can be either record or resource databases.</p>

<p><a name="1003526"> </a>Extended databases are very similar to classic databases. <a href="Intro_Databases.html#1004097">Table 8.6</a> describes the differences.</p>

<p class="fineprint">
<p class="caption"><a name="1004097"> </a><b>Table 8.6&nbsp;&nbsp;Comparison of non-schema database types</b></p>
<div class="tablediv"><table cellspacing="0" class="tTable">

  <tr valign="top">
    <th><p class="tt"><a name="1003529"> </a><b>Classic Database</b></p>
    </th>
    <th><p class="tt"><a name="1003531"> </a><b>Extended Database</b></p>
    </th>
  </tr>
  <tr valign="top">
    <td><p class="tt"><a name="1003533"> </a>Must have record sizes smaller than 64 KB</p>
    </td>
    <td><p class="tt"><a name="1003535"> </a>Can have record sizes up to 4 GB</p>
    </td>
  </tr>
  <tr valign="top">
    <td><p class="tt"><a name="1003537"> </a>Are uniquely identified by name.</p>
    </td>
    <td><p class="tt"><a name="1003539"> </a>Are uniquely identified by a combination of name and creator ID.</p>
    </td>
  </tr>
  <tr valign="top">
    <td><p class="tt"><a name="1003541"> </a>Data should be stored in big-endian format (for 68K compatibility).</p>
    </td>
    <td><p class="tt"><a name="1003543"> </a>Data can be stored in either big-endian or little-endian format.</p>
    </td>
  </tr>
</table>

</div>

</p>

<p><a name="1003545"> </a>Even though the two non-schema database types are so similar, the desktop Sync Manager provides two separate APIs, each working with databases of only one type.</p>

<p><a name="1006365"> </a>The following subsections provide further details on non-schema databases:</p>
   <blockquote class = "bq"><a name="1006380"> </a><a href="Intro_Databases.html#1003556">Structure of a Non-Schema Database</a></blockquote>
   <blockquote class = "bq"><a name="1006432"> </a><a href="Intro_Databases.html#1004346">Record Attributes</a></blockquote>
   <blockquote class = "bq"><a name="1006459"> </a><a href="Intro_Databases.html#1004491">Categories and the Application Info Block</a></blockquote>
   <blockquote class = "bq"><a name="1006474"> </a><a href="Intro_Databases.html#1004532">Working with Non-Schema Database Records</a></blockquote>
   <blockquote class = "bq"><a name="1006490"> </a><a href="Intro_Databases.html#1004539">Maintaining Record Order</a></blockquote>
   <blockquote class = "bq"><a name="1006505"> </a><a href="Intro_Databases.html#1004541">Concurrent Non-Schema Database Access</a></blockquote>
<h3 class="hbH3">
  <a name="1003556"> </a>Structure of a Non-Schema Database <a href="#995933"><span class="nav">^TOP^</span></a>
</h3>


<p><a name="1004205"> </a><a href="Intro_Databases.html#1004207">Figure 8.2</a> illustrates the structure of a non-schema database. The database header contains information that describes the database and includes pointers to the application info block, sort info block, and records. Arrows indicate pointers to data or arrays of data. Each record entry in the header has the record ID, 8 attribute bits, and a 3-byte unique ID for the record. </p>

<p class="FFigureCaption">
  <a name="1004207"> </a><b>Figure 8.2&nbsp;&nbsp;Non-schema database structure</b>
</p>
<div align="left"><img src="images/Intro_Databases2.gif" height="331" width="624" border="0" hspace="0" vspace="0">
</div>

<p><a name="1004313"> </a>The header of a non-schema database contains the following information:</p>

<dl>
<dt><a name="1004314"> </a>Name</dt>
<dd><a name="1004315"> </a>The null-terminated name of the database. Non-schema database names must consist of only 7-bit ASCII characters from 0x20 through 0x7E. A name can be no longer than 32 characters, including the null terminator.</dd>

<dt><a name="1004316"> </a>Creator</dt>
<dd><a name="1004317"> </a>A four-byte string that uniquely identifies the creator of an application or database. You must register your creator ID with PalmSource to protect your application from conflicting with others. Values are case-sensitive and composed of ASCII characters in the range 32-126 (decimal). Values consisting of all lowercase letters are reserved for use by PalmSource.</dd>

<dt><a name="1004318"> </a>Type</dt>
<dd><a name="1004319"> </a>A four-byte string that allows Palm OS to distinguish among multiple databases with the same creator ID. Type values have the same requirements as creator IDs, but you do not register them since they are not unique. Certain types have special meaning&#8212for example <code>'appl'</code> is for applications.</dd>

<dt><a name="1004320"> </a>Attributes</dt>
<dd><a name="1004321"> </a>Flags that indicate such characteristics as whether the database contains records or resources, is read-only, has a modified application info block, should be backed up, is copy-protected, is open, and so on. See <a href="Intro_Databases.html#1004346">"Record Attributes"</a> for details.</dd>

<dt><a name="1004322"> </a>Version</dt>
<dd><a name="1004323"> </a>An application-specific version number.</dd>

<dt><a name="1004324"> </a>Creation Date</dt>
<dd><a name="1004325"> </a>The date on which the database was created.</dd>

<dt><a name="1004326"> </a>Modification Date</dt>
<dd><a name="1004327"> </a>The date on which the database was last modified, either by an application or conduit.</dd>

<dt><a name="1004328"> </a>Last Backup Date</dt>
<dd><a name="1004329"> </a>The date on which the database was last backed up.</dd>

<dt><a name="1004330"> </a>Modification Number</dt>
<dd><a name="1004331"> </a>An integer that is incremented every time a record in the database is deleted, added, or modified.</dd>

<dt><a name="1004332"> </a>Unique ID Seed</dt>
<dd><a name="1004333"> </a>A value assigned and used only by the Data Manager to generate record IDs for this database.</dd>

<dt><a name="1004334"> </a>Application Info</dt>
<dd><a name="1004335"> </a>A pointer to the application info block. This value is optional.</dd>

<dt><a name="1004336"> </a>Sort Info</dt>
<dd><a name="1004337"> </a>A pointer to the sort info block. This value is optional.</dd>

<dt><a name="1004338"> </a>Number of Records</dt>
<dd><a name="1010081"> </a>The number of record entries stored in the database header itself, which includes those marked deleted. The number of records exposed to conduits via the Sync Manager is the total number in the database.</dd>

<dt><a name="1004340"> </a>List of Records</dt>
<dd><a name="1004341"> </a>Each record entry includes the ID of the record, attribute bits (see <a href="Intro_Databases.html#1004346">"Record Attributes"</a>), and a pointer to the record data. The record ID must be unique for each record within a database. It remains the same for a particular record no matter how many times the record is modified. It is used during synchronization to track records on the handheld with the same records on the desktop.</dd>

</dl>
<h3 class="hbH3">
  <a name="1004346"> </a>Record Attributes <a href="#995933"><span class="nav">^TOP^</span></a>
</h3>


<p><a name="1004350"> </a>Non-schema database records can have the attributes listed in <a href="Intro_Databases.html#1004354">Table 8.7</a>.</p>

<p class="fineprint">
<p class="caption"><a name="1004354"> </a><b>Table 8.7&nbsp;&nbsp;Non-schema database record attributes</b></p>
<div class="tablediv"><table cellspacing="0" class="tTable">

  <tr valign="top">
    <th><p class="tt"><a name="1004358"> </a><b>Attribute</b></p>
    </th>
    <th><p class="tt"><a name="1004360"> </a><b>Description</b></p>
    </th>
  </tr>
  <tr valign="top">
    <td><p class="tt"><a name="1004362"> </a>Delete</p>
    </td>
    <td><p class="tt"><a name="1004364"> </a>The record has been deleted. Only its record ID and attributes remain. Classic database records do not have an Archive bit. Instead the Sync Manager provides an Archive attribute that is set if both the Delete bit is set and if the record data is still present on the handheld.</p>
    </td>
  </tr>
  <tr valign="top">
    <td><p class="tt"><a name="1004366"> </a>Dirty</p>
    </td>
    <td><p class="tt"><a name="1004368"> </a>The record has been modified since the last HotSync operation.</p>
    </td>
  </tr>
  <tr valign="top">
    <td><p class="tt"><a name="1004370"> </a>Busy</p>
    </td>
    <td><p class="tt"><a name="1004372"> </a>The record is locked by a handheld application for reading or writing.</p>
    </td>
  </tr>
  <tr valign="top">
    <td><p class="tt"><a name="1004374"> </a>Secret</p>
    </td>
    <td><p class="tt"><a name="1004376"> </a>The record is private and should be displayed only if the user wishes.</p>
    </td>
  </tr>
  <tr valign="top">
    <td><p class="tt"><a name="1004378"> </a>Category Index</p>
    </td>
    <td><p class="tt"><a name="1004380"> </a>The category that the record is in. This is an index from 0 to 15, which references one of the categories defined in the application info block.</p>
    </td>
  </tr>
</table>

</div>

</p>
<h3 class="hbH3">
  <a name="1004491"> </a>Categories and the Application Info Block <a href="#995933"><span class="nav">^TOP^</span></a>
</h3>


<p><a name="1004492"> </a><b>Categories</b> are groups of related records in a single database. Applications usually use categories to enable the end user to organize and filter records. Non-schema databases allow records to be a member of only one of 15 categories, or in the "Unfiled" category.</p>

<p><a name="1004493"> </a>In a non-schema database, the <b>application info block</b> can contain both application-specific data and category information. The Sync Manager provides functions for manipulating the application info block. Otherwise, you read and write the application info block in much the same way as you read and write any other non-schema database record.</p>

<p><a name="1004494"> </a>If you choose to use the handheld's category API in an application that uses a non-schema database, you must set up the database appropriately. The Palm OS category functions expect to find information in a certain format in the application info block. These functions also expect to find in the record's attributes the category that each record belongs to. The Sync Manager provides conduits access to the same category information.</p>
<h3 class="hbH3">
  <a name="1004532"> </a>Working with Non-Schema Database Records <a href="#995933"><span class="nav">^TOP^</span></a>
</h3>


<p><a name="1004533"> </a>A conduit can access non-schema database records either by index or by a record ID that is unique within the database. </p>

<h4 class="hcH4">
  <a name="1004534"> </a>Reading and Writing Data
</h4>

<p><a name="1004535"> </a>The structure of non-schema database records is application-specific, so the Sync Manager provides the means to read and write records only as opaque data. In addition to reading records directly by index or record ID, you can also iterating through all records, all records in a category, only modified records, or only modified records in a category. </p>

<h4 class="hcH4">
  <a name="1004536"> </a>Deleting Records
</h4>

<p><a name="1004537"> </a>When a user "deletes" a record on the handheld, the record's data chunk is freed (effectively destroying the data), the local ID stored in the record entry is set to 0, and the delete bit is set in the attributes. When the user "archives" a record, the delete bit is also set but the chunk is not freed and the local ID is preserved. This way, the next time the user performs a HotSync operation, a conduit can quickly determine which records to delete (because their record entries are still around on the handheld). In the case of archived records, a conduit can save the record data on the desktop before it permanently removes the record entry and data from the handheld. For deleted records, the conduit just has to delete the same record from the desktop before permanently removing the record entry from the handheld.</p>

<p><a name="1004538"> </a>The Sync Manager provides the means to delete one record by ID, all records in a given category, all records with the delete bit set, and all records in the database.</p>
<h3 class="hbH3">
  <a name="1004539"> </a>Maintaining Record Order <a href="#995933"><span class="nav">^TOP^</span></a>
</h3>


<p><a name="1004540"> </a>The handheld application is responsible for determining the order of records in a non-schema database, as in a schema database. Therefore when a conduit reads records by index, they are retrieved in the order that the application has sorted them in. When a conduit creates a new record, the Sync Manager adds it after the last record.</p>
<h3 class="hbH3">
  <a name="1004541"> </a>Concurrent Non-Schema Database Access <a href="#995933"><span class="nav">^TOP^</span></a>
</h3>


<p><a name="1004542"> </a>Consider two types of concurrent access to non-schema databases:</p>
<ul type="disc">
  <li><a name="1004543"> </a><i>Two</i> entities accessing <i>one</i> database concurrently (not supported)
  <li><a name="1004544"> </a><i>One</i> entity accessing <i>two or more</i> databases concurrently
</ul>

<h4 class="hcH4">
  <a name="1004545"> </a>Two Entities, One Database
</h4>

<p><a name="1004546"> </a>The handheld Data Manager, and thus the desktop Sync Manager, does <i>not</i> support <i>two</i> entities accessing <i>one</i> non-schema database concurrently. When you open a non-schema Palm OS database with write access, you have exclusive access to that database: no one else can open that database while you have it open, even if they are just opening it with read access. Or, when you open a non-schema database with read access, no one else can open that same database with write access. If you need to be able to share access to databases, then you must use a schema database. See <a href="Intro_Databases.html#1000218">"Concurrent Schema Database Access."</a></p>

<h4 class="hcH4">
  <a name="1004550"> </a>One Entity, Two or More Databases
</h4>

<p><a name="1004551"> </a>The Sync Manager via its C/C++ API does <i>not</i> support <i>one</i> entity accessing <i>two or more</i> classic databases concurrently. With this API, you can open only one database at a time. You must then close it before opening another.</p>

<p><a name="1004586"> </a>However, the COM Sync module, which provides a layer between a conduit and the C/C++ Sync Manager API, <i>does</i> support <i>one</i> entity accessing <i>two or more</i> classic databases concurrently. The COM Sync module actually opens and closes databases as needed via the Sync Manager API, effectively freeing the conduit from the restriction of having only one non-schema database open at a time.</p>
&nbsp;<br>
</div>
<!--END CONTENT-->

</td>
<td width="5">&nbsp;&nbsp;</td>
</tr>

</table>

<!-- BEGIN FOOTER -->
<table width="100%" border="0" cellspacing="0" cellpadding="0">
<tr>
<td width="7" rowspan="2"><img name="index_x" src="images/shim.gif" width="7" height="33" border="0" alt=""></td>
<td align="left"><img name="dashes" src="images/dashes.gif" width="744" height="3" border="0" alt=""></td>
<td width="10" rowspan="2"><img name="index_x" src="images/shim.gif" width="10" height="33" border="0" alt=""></td>
</tr>
<tr>
<td align="center">
<p class="footer">
Copyright © 2001-2004, PalmSource, Inc. and its affiliates. All rights reserved.<br>
<a href="http://www.palmsource.com/contact/">Write Us</a> | <a href="http://www.palmos.com/dev/training/">Training</a> | <a href="http://www.palmos.com/dev/support/kb/">Knowledge Base</a> | <a href="Intro_Front.html" target="_blank">Legal</a></p>
<br>
<!--BEGIN BOOK NAVIGATION-->
<p class="nav">
<A href="http://www.palmos.com/dev/support/docs/">Documentation</a>&nbsp;&nbsp;|&nbsp;&nbsp;
<a href="IntroToConduitsTOC.html">Table of Contents</a>&nbsp;&nbsp;
             |&nbsp;&nbsp;<a href="Intro_HotSyncProc.html">&lt;&nbsp;Previous</a>&nbsp;&nbsp;
             |&nbsp;&nbsp;<a href="Intro_Trust.html">Next&nbsp;&gt;</a>&nbsp;&nbsp;
             |&nbsp;&nbsp;<a href="IntroToConduitsIX.html">Index</a>
</p>
</td>
</tr>
<!-- END FOOTER -->

</body>
</html>