This is gdb.info, produced by makeinfo version 4.3 from
/netrel/src/gdb-20030919-1/gdb/doc/gdb.texinfo.

INFO-DIR-SECTION Programming & development tools.
START-INFO-DIR-ENTRY
* Gdb: (gdb).                     The GNU debugger.
END-INFO-DIR-ENTRY

   This file documents the GNU debugger GDB.

   This is the Ninth Edition, of `Debugging with GDB: the GNU
Source-Level Debugger' for GDB Version 2003-09-20-cvs (cygwin-special).

   Copyright (C) 1988, 1989, 1990, 1991, 1992, 1993, 1994, 1995, 1996,
1998,
1999, 2000, 2001, 2002, 2003 Free Software Foundation, Inc.

   Permission is granted to copy, distribute and/or modify this document
under the terms of the GNU Free Documentation License, Version 1.1 or
any later version published by the Free Software Foundation; with the
Invariant Sections being "Free Software" and "Free Software Needs Free
Documentation", with the Front-Cover Texts being "A GNU Manual," and
with the Back-Cover Texts as in (a) below.

   (a) The Free Software Foundation's Back-Cover Text is: "You have
freedom to copy and modify this GNU Manual, like GNU software.  Copies
published by the Free Software Foundation raise funds for GNU
development."


File: gdb.info,  Node: The `F' reply packet,  Next: Memory transfer,  Prev: The `F' request packet,  Up: File-I/O remote protocol extension

The `F' reply packet
--------------------

   The `F' reply packet has the following format:

          `F'RETCODE`,'ERRNO`,'CTRL-C FLAG`;'CALL SPECIFIC ATTACHMENT

     RETCODE is the return code of the system call as hexadecimal value.

     ERRNO is the errno set by the call, in protocol specific
     representation.  This parameter can be omitted if the call was
     successful.

     CTRL-C FLAG is only send if the user requested a break.  In this
     case, ERRNO must be send as well, even if the call was successful.
     The CTRL-C FLAG itself consists of the character 'C':

          F0,0,C

     or, if the call was interupted before the host call has been
     performed:

          F-1,4,C

     assuming 4 is the protocol specific representation of `EINTR'.


File: gdb.info,  Node: Memory transfer,  Next: The Ctrl-C message,  Prev: The `F' reply packet,  Up: File-I/O remote protocol extension

Memory transfer
---------------

   Structured data which is transferred using a memory read or write as
e.g.  a `struct stat' is expected to be in a protocol specific format
with all scalar multibyte datatypes being big endian.  This should be
done by the target before the `F' packet is sent resp. by GDB before it
transfers memory to the target.  Transferred pointers to structured
data should point to the already coerced data at any time.


File: gdb.info,  Node: The Ctrl-C message,  Next: Console I/O,  Prev: Memory transfer,  Up: File-I/O remote protocol extension

The Ctrl-C message
------------------

   A special case is, if the CTRL-C FLAG is set in the GDB reply
packet.  In this case the target should behave, as if it had gotten a
break message.  The meaning for the target is "system call interupted
by `SIGINT'".  Consequentially, the target should actually stop (as
with a break message) and return to GDB with a `T02' packet.  In this
case, it's important for the target to know, in which state the system
call was interrupted.  Since this action is by design not an atomic
operation, we have to differ between two cases:

   * The system call hasn't been performed on the host yet.

   * The system call on the host has been finished.


   These two states can be distinguished by the target by the value of
the returned `errno'.  If it's the protocol representation of `EINTR',
the system call hasn't been performed.  This is equivalent to the
`EINTR' handling on POSIX systems.  In any other case, the target may
presume that the system call has been finished -- successful or not --
and should behave as if the break message arrived right after the
system call.

   GDB must behave reliable.  If the system call has not been called
yet, GDB may send the `F' reply immediately, setting `EINTR' as `errno'
in the packet.  If the system call on the host has been finished before
the user requests a break, the full action must be finshed by GDB.
This requires sending `M' or `X' packets as they fit.  The `F' packet
may only be send when either nothing has happened or the full action
has been completed.


File: gdb.info,  Node: Console I/O,  Next: The isatty call,  Prev: The Ctrl-C message,  Up: File-I/O remote protocol extension

Console I/O
-----------

   By default and if not explicitely closed by the target system, the
file descriptors 0, 1 and 2 are connected to the GDB console.  Output
on the GDB console is handled as any other file output operation
(`write(1, ...)' or `write(2, ...)').  Console input is handled by GDB
so that after the target read request from file descriptor 0 all
following typing is buffered until either one of the following
conditions is met:

   * The user presses `Ctrl-C'.  The behaviour is as explained above,
     the `read' system call is treated as finished.

   * The user presses `Enter'.  This is treated as end of input with a
     trailing line feed.

   * The user presses `Ctrl-D'.  This is treated as end of input.  No
     trailing character, especially no Ctrl-D is appended to the input.


   If the user has typed more characters as fit in the buffer given to
the read call, the trailing characters are buffered in GDB until either
another `read(0, ...)' is requested by the target or debugging is
stopped on users request.


File: gdb.info,  Node: The isatty call,  Next: The system call,  Prev: Console I/O,  Up: File-I/O remote protocol extension

The isatty(3) call
------------------

   A special case in this protocol is the library call `isatty' which
is implemented as it's own call inside of this protocol.  It returns 1
to the target if the file descriptor given as parameter is attached to
the GDB console, 0 otherwise.  Implementing through system calls would
require implementing `ioctl' and would be more complex than needed.


File: gdb.info,  Node: The system call,  Next: List of supported calls,  Prev: The isatty call,  Up: File-I/O remote protocol extension

The system(3) call
------------------

   The other special case in this protocol is the `system' call which
is implemented as it's own call, too.  GDB is taking over the full task
of calling the necessary host calls to perform the `system' call.  The
return value of `system' is simplified before it's returned to the
target.  Basically, the only signal transmitted back is `EINTR' in case
the user pressed `Ctrl-C'.  Otherwise the return value consists
entirely of the exit status of the called command.

   Due to security concerns, the `system' call is refused to be called
by GDB by default.  The user has to allow this call explicitly by
entering

``set remote system-call-allowed 1''
   Disabling the `system' call is done by

``set remote system-call-allowed 0''
   The current setting is shown by typing

``show remote system-call-allowed''

File: gdb.info,  Node: List of supported calls,  Next: Protocol specific representation of datatypes,  Prev: The system call,  Up: File-I/O remote protocol extension

List of supported calls
-----------------------

* Menu:

* open::
* close::
* read::
* write::
* lseek::
* rename::
* unlink::
* stat/fstat::
* gettimeofday::
* isatty::
* system::


File: gdb.info,  Node: open,  Next: close,  Up: List of supported calls

open
....

Synopsis:
     int open(const char *pathname, int flags);
     int open(const char *pathname, int flags, mode_t mode);
     
Request:
     Fopen,pathptr/len,flags,mode

`flags' is the bitwise or of the following values:

`O_CREAT'
     If the file does not exist it will be created.  The host rules
     apply as far as file ownership and time stamps are concerned.

`O_EXCL'
     When used with O_CREAT, if the file already exists it is an error
     and open() fails.

`O_TRUNC'
     If the file already exists and the open mode allows writing
     (O_RDWR or O_WRONLY is given) it will be truncated to length 0.

`O_APPEND'
     The file is opened in append mode.

`O_RDONLY'
     The file is opened for reading only.

`O_WRONLY'
     The file is opened for writing only.

`O_RDWR'
     The file is opened for reading and writing.

     Each other bit is silently ignored.

`mode' is the bitwise or of the following values:

`S_IRUSR'
     User has read permission.

`S_IWUSR'
     User has write permission.

`S_IRGRP'
     Group has read permission.

`S_IWGRP'
     Group has write permission.

`S_IROTH'
     Others have read permission.

`S_IWOTH'
     Others have write permission.

     Each other bit is silently ignored.

Return value:
     open returns the new file descriptor or -1 if an error
     occured.
     
Errors:


`EEXIST'
     pathname already exists and O_CREAT and O_EXCL were used.

`EISDIR'
     pathname refers to a directory.

`EACCES'
     The requested access is not allowed.

`ENAMETOOLONG'
     pathname was too long.

`ENOENT'
     A directory component in pathname does not exist.

`ENODEV'
     pathname refers to a device, pipe, named pipe or socket.

`EROFS'
     pathname refers to a file on a read-only filesystem and write
     access was requested.

`EFAULT'
     pathname is an invalid pointer value.

`ENOSPC'
     No space on device to create the file.

`EMFILE'
     The process already has the maximum number of files open.

`ENFILE'
     The limit on the total number of files open on the system has been
     reached.

`EINTR'
     The call was interrupted by the user.


File: gdb.info,  Node: close,  Next: read,  Prev: open,  Up: List of supported calls

close
.....

Synopsis:
     int close(int fd);
     
Request:
     Fclose,fd
     
Return value:
     close returns zero on success, or -1 if an error occurred.
     
Errors:


`EBADF'
     fd isn't a valid open file descriptor.

`EINTR'
     The call was interrupted by the user.


File: gdb.info,  Node: read,  Next: write,  Prev: close,  Up: List of supported calls

read
....

Synopsis:
     int read(int fd, void *buf, unsigned int count);
     
Request:
     Fread,fd,bufptr,count
     
Return value:
     On success, the number of bytes read is returned.
     Zero indicates end of file.  If count is zero, read
     returns zero as well.  On error, -1 is returned.
     
Errors:


`EBADF'
     fd is not a valid file descriptor or is not open for reading.

`EFAULT'
     buf is an invalid pointer value.

`EINTR'
     The call was interrupted by the user.


File: gdb.info,  Node: write,  Next: lseek,  Prev: read,  Up: List of supported calls

write
.....

Synopsis:
     int write(int fd, const void *buf, unsigned int count);
     
Request:
     Fwrite,fd,bufptr,count
     
Return value:
     On success, the number of bytes written are returned.
     Zero indicates nothing was written.  On error, -1
     is returned.
     
Errors:


`EBADF'
     fd is not a valid file descriptor or is not open for writing.

`EFAULT'
     buf is an invalid pointer value.

`EFBIG'
     An attempt was made to write a file that exceeds the host specific
     maximum file size allowed.

`ENOSPC'
     No space on device to write the data.

`EINTR'
     The call was interrupted by the user.


File: gdb.info,  Node: lseek,  Next: rename,  Prev: write,  Up: List of supported calls

lseek
.....

Synopsis:
     long lseek (int fd, long offset, int flag);
     
Request:
     Flseek,fd,offset,flag

   `flag' is one of:

`SEEK_SET'
     The offset is set to offset bytes.

`SEEK_CUR'
     The offset is set to its current location plus offset bytes.

`SEEK_END'
     The offset is set to the size of the file plus offset bytes.

Return value:
     On success, the resulting unsigned offset in bytes from
     the beginning of the file is returned.  Otherwise, a
     value of -1 is returned.
     
Errors:


`EBADF'
     fd is not a valid open file descriptor.

`ESPIPE'
     fd is associated with the GDB console.

`EINVAL'
     flag is not a proper value.

`EINTR'
     The call was interrupted by the user.


File: gdb.info,  Node: rename,  Next: unlink,  Prev: lseek,  Up: List of supported calls

rename
......

Synopsis:
     int rename(const char *oldpath, const char *newpath);
     
Request:
     Frename,oldpathptr/len,newpathptr/len
     
Return value:
     On success, zero is returned.  On error, -1 is returned.
     
Errors:


`EISDIR'
     newpath is an existing directory, but oldpath is not a directory.

`EEXIST'
     newpath is a non-empty directory.

`EBUSY'
     oldpath or newpath is a directory that is in use by some process.

`EINVAL'
     An attempt was made to make a directory a subdirectory of itself.

`ENOTDIR'
     A  component used as a directory in oldpath or new path is not a
     directory.  Or oldpath is a directory and newpath exists but is
     not a directory.

`EFAULT'
     oldpathptr or newpathptr are invalid pointer values.

`EACCES'
     No access to the file or the path of the file.

`ENAMETOOLONG'
     oldpath or newpath was too long.

`ENOENT'
     A directory component in oldpath or newpath does not exist.

`EROFS'
     The file is on a read-only filesystem.

`ENOSPC'
     The device containing the file has no room for the new directory
     entry.

`EINTR'
     The call was interrupted by the user.


File: gdb.info,  Node: unlink,  Next: stat/fstat,  Prev: rename,  Up: List of supported calls

unlink
......

Synopsis:
     int unlink(const char *pathname);
     
Request:
     Funlink,pathnameptr/len
     
Return value:
     On success, zero is returned.  On error, -1 is returned.
     
Errors:


`EACCES'
     No access to the file or the path of the file.

`EPERM'
     The system does not allow unlinking of directories.

`EBUSY'
     The file pathname cannot be unlinked because it's being used by
     another process.

`EFAULT'
     pathnameptr is an invalid pointer value.

`ENAMETOOLONG'
     pathname was too long.

`ENOENT'
     A directory component in pathname does not exist.

`ENOTDIR'
     A component of the path is not a directory.

`EROFS'
     The file is on a read-only filesystem.

`EINTR'
     The call was interrupted by the user.


File: gdb.info,  Node: stat/fstat,  Next: gettimeofday,  Prev: unlink,  Up: List of supported calls

stat/fstat
..........

Synopsis:
     int stat(const char *pathname, struct stat *buf);
     int fstat(int fd, struct stat *buf);
     
Request:
     Fstat,pathnameptr/len,bufptr
     Ffstat,fd,bufptr
     
Return value:
     On success, zero is returned.  On error, -1 is returned.
     
Errors:


`EBADF'
     fd is not a valid open file.

`ENOENT'
     A directory component in pathname does not exist or the path is an
     empty string.

`ENOTDIR'
     A component of the path is not a directory.

`EFAULT'
     pathnameptr is an invalid pointer value.

`EACCES'
     No access to the file or the path of the file.

`ENAMETOOLONG'
     pathname was too long.

`EINTR'
     The call was interrupted by the user.


File: gdb.info,  Node: gettimeofday,  Next: isatty,  Prev: stat/fstat,  Up: List of supported calls

gettimeofday
............

Synopsis:
     int gettimeofday(struct timeval *tv, void *tz);
     
Request:
     Fgettimeofday,tvptr,tzptr
     
Return value:
     On success, 0 is returned, -1 otherwise.
     
Errors:


`EINVAL'
     tz is a non-NULL pointer.

`EFAULT'
     tvptr and/or tzptr is an invalid pointer value.


File: gdb.info,  Node: isatty,  Next: system,  Prev: gettimeofday,  Up: List of supported calls

isatty
......

Synopsis:
     int isatty(int fd);
     
Request:
     Fisatty,fd
     
Return value:
     Returns 1 if fd refers to the GDB console, 0 otherwise.
     
Errors:


`EINTR'
     The call was interrupted by the user.


File: gdb.info,  Node: system,  Prev: isatty,  Up: List of supported calls

system
......

Synopsis:
     int system(const char *command);
     
Request:
     Fsystem,commandptr/len
     
Return value:
     The value returned is -1 on error and the return status
     of the command otherwise.  Only the exit status of the
     command is returned, which is extracted from the hosts
     system return value by calling WEXITSTATUS(retval).
     In case /bin/sh could not be executed, 127 is returned.
     
Errors:


`EINTR'
     The call was interrupted by the user.


File: gdb.info,  Node: Protocol specific representation of datatypes,  Next: Constants,  Prev: List of supported calls,  Up: File-I/O remote protocol extension

Protocol specific representation of datatypes
---------------------------------------------

* Menu:

* Integral datatypes::
* Pointer values::
* struct stat::
* struct timeval::


File: gdb.info,  Node: Integral datatypes,  Next: Pointer values,  Up: Protocol specific representation of datatypes

Integral datatypes
..................

   The integral datatypes used in the system calls are

     int, unsigned int, long, unsigned long, mode_t and time_t

   `Int', `unsigned int', `mode_t' and `time_t' are implemented as 32
bit values in this protocol.

   `Long' and `unsigned long' are implemented as 64 bit types.

   *Note Limits::, for corresponding MIN and MAX values (similar to
those in `limits.h') to allow range checking on host and target.

   `time_t' datatypes are defined as seconds since the Epoch.

   All integral datatypes transferred as part of a memory read or write
of a structured datatype e.g. a `struct stat' have to be given in big
endian byte order.


File: gdb.info,  Node: Pointer values,  Next: struct stat,  Prev: Integral datatypes,  Up: Protocol specific representation of datatypes

Pointer values
..............

   Pointers to target data are transmitted as they are.  An exception
is made for pointers to buffers for which the length isn't transmitted
as part of the function call, namely strings.  Strings are transmitted
as a pointer/length pair, both as hex values, e.g.

     `1aaf/12'

which is a pointer to data of length 18 bytes at position 0x1aaf.  The
length is defined as the full string length in bytes, including the
trailing null byte.  Example:

     ``hello, world'' at address 0x123456

is transmitted as

     `123456/d'


File: gdb.info,  Node: struct stat,  Next: struct timeval,  Prev: Pointer values,  Up: Protocol specific representation of datatypes

struct stat
...........

   The buffer of type struct stat used by the target and GDB is defined
as follows:

     struct stat {
         unsigned int  st_dev;      /* device */
         unsigned int  st_ino;      /* inode */
         mode_t        st_mode;     /* protection */
         unsigned int  st_nlink;    /* number of hard links */
         unsigned int  st_uid;      /* user ID of owner */
         unsigned int  st_gid;      /* group ID of owner */
         unsigned int  st_rdev;     /* device type (if inode device) */
         unsigned long st_size;     /* total size, in bytes */
         unsigned long st_blksize;  /* blocksize for filesystem I/O */
         unsigned long st_blocks;   /* number of blocks allocated */
         time_t        st_atime;    /* time of last access */
         time_t        st_mtime;    /* time of last modification */
         time_t        st_ctime;    /* time of last change */
     };

   The integral datatypes are conforming to the definitions given in the
approriate section (see *Note Integral datatypes::, for details) so this
structure is of size 64 bytes.

   The values of several fields have a restricted meaning and/or range
of values.

     st_dev:     0       file
                 1       console
     
     st_ino:     No valid meaning for the target.  Transmitted unchanged.
     
     st_mode:    Valid mode bits are described in Appendix C.  Any other
                 bits have currently no meaning for the target.
     
     st_uid:     No valid meaning for the target.  Transmitted unchanged.
     
     st_gid:     No valid meaning for the target.  Transmitted unchanged.
     
     st_rdev:    No valid meaning for the target.  Transmitted unchanged.
     
     st_atime, st_mtime, st_ctime:
                 These values have a host and file system dependent
                 accuracy.  Especially on Windows hosts the file systems
                 don't support exact timing values.

   The target gets a struct stat of the above representation and is
responsible to coerce it to the target representation before continuing.

   Note that due to size differences between the host and target
representation of stat members, these members could eventually get
truncated on the target.


File: gdb.info,  Node: struct timeval,  Prev: struct stat,  Up: Protocol specific representation of datatypes

struct timeval
..............

   The buffer of type struct timeval used by the target and GDB is
defined as follows:

     struct timeval {
         time_t tv_sec;  /* second */
         long   tv_usec; /* microsecond */
     };

   The integral datatypes are conforming to the definitions given in the
approriate section (see *Note Integral datatypes::, for details) so this
structure is of size 8 bytes.


File: gdb.info,  Node: Constants,  Next: File-I/O Examples,  Prev: Protocol specific representation of datatypes,  Up: File-I/O remote protocol extension

Constants
---------

   The following values are used for the constants inside of the
protocol.  GDB and target are resposible to translate these values
before and after the call as needed.

* Menu:

* Open flags::
* mode_t values::
* Errno values::
* Lseek flags::
* Limits::


File: gdb.info,  Node: Open flags,  Next: mode_t values,  Up: Constants

Open flags
..........

   All values are given in hexadecimal representation.

       O_RDONLY        0x0
       O_WRONLY        0x1
       O_RDWR          0x2
       O_APPEND        0x8
       O_CREAT       0x200
       O_TRUNC       0x400
       O_EXCL        0x800


File: gdb.info,  Node: mode_t values,  Next: Errno values,  Prev: Open flags,  Up: Constants

mode_t values
.............

   All values are given in octal representation.

       S_IFREG       0100000
       S_IFDIR        040000
       S_IRUSR          0400
       S_IWUSR          0200
       S_IXUSR          0100
       S_IRGRP           040
       S_IWGRP           020
       S_IXGRP           010
       S_IROTH            04
       S_IWOTH            02
       S_IXOTH            01


File: gdb.info,  Node: Errno values,  Next: Lseek flags,  Prev: mode_t values,  Up: Constants

Errno values
............

   All values are given in decimal representation.

       EPERM           1
       ENOENT          2
       EINTR           4
       EBADF           9
       EACCES         13
       EFAULT         14
       EBUSY          16
       EEXIST         17
       ENODEV         19
       ENOTDIR        20
       EISDIR         21
       EINVAL         22
       ENFILE         23
       EMFILE         24
       EFBIG          27
       ENOSPC         28
       ESPIPE         29
       EROFS          30
       ENAMETOOLONG   91
       EUNKNOWN       9999

   EUNKNOWN is used as a fallback error value if a host system returns
any error value not in the list of supported error numbers.


File: gdb.info,  Node: Lseek flags,  Next: Limits,  Prev: Errno values,  Up: Constants

Lseek flags
...........

       SEEK_SET      0
       SEEK_CUR      1
       SEEK_END      2


File: gdb.info,  Node: Limits,  Prev: Lseek flags,  Up: Constants

Limits
......

   All values are given in decimal representation.

       INT_MIN       -2147483648
       INT_MAX        2147483647
       UINT_MAX       4294967295
       LONG_MIN      -9223372036854775808
       LONG_MAX       9223372036854775807
       ULONG_MAX      18446744073709551615


File: gdb.info,  Node: File-I/O Examples,  Prev: Constants,  Up: File-I/O remote protocol extension

File-I/O Examples
-----------------

   Example sequence of a write call, file descriptor 3, buffer is at
target address 0x1234, 6 bytes should be written:

     <- `Fwrite,3,1234,6'
     _request memory read from target_
     -> `m1234,6'
     <- XXXXXX
     _return "6 bytes written"_
     -> `F6'

   Example sequence of a read call, file descriptor 3, buffer is at
target address 0x1234, 6 bytes should be read:

     <- `Fread,3,1234,6'
     _request memory write to target_
     -> `X1234,6:XXXXXX'
     _return "6 bytes read"_
     -> `F6'

   Example sequence of a read call, call fails on the host due to
invalid file descriptor (EBADF):

     <- `Fread,3,1234,6'
     -> `F-1,9'

   Example sequence of a read call, user presses Ctrl-C before syscall
on host is called:

     <- `Fread,3,1234,6'
     -> `F-1,4,C'
     <- `T02'

   Example sequence of a read call, user presses Ctrl-C after syscall on
host is called:

     <- `Fread,3,1234,6'
     -> `X1234,6:XXXXXX'
     <- `T02'


File: gdb.info,  Node: Agent Expressions,  Next: Copying,  Prev: Remote Protocol,  Up: Top

The GDB Agent Expression Mechanism
**********************************

   In some applications, it is not feasable for the debugger to
interrupt the program's execution long enough for the developer to
learn anything helpful about its behavior.  If the program's
correctness depends on its real-time behavior, delays introduced by a
debugger might cause the program to fail, even when the code itself is
correct.  It is useful to be able to observe the program's behavior
without interrupting it.

   Using GDB's `trace' and `collect' commands, the user can specify
locations in the program, and arbitrary expressions to evaluate when
those locations are reached.  Later, using the `tfind' command, she can
examine the values those expressions had when the program hit the trace
points.  The expressions may also denote objects in memory --
structures or arrays, for example -- whose values GDB should record;
while visiting a particular tracepoint, the user may inspect those
objects as if they were in memory at that moment.  However, because GDB
records these values without interacting with the user, it can do so
quickly and unobtrusively, hopefully not disturbing the program's
behavior.

   When GDB is debugging a remote target, the GDB "agent" code running
on the target computes the values of the expressions itself.  To avoid
having a full symbolic expression evaluator on the agent, GDB translates
expressions in the source language into a simpler bytecode language, and
then sends the bytecode to the agent; the agent then executes the
bytecode, and records the values for GDB to retrieve later.

   The bytecode language is simple; there are forty-odd opcodes, the
bulk of which are the usual vocabulary of C operands (addition,
subtraction, shifts, and so on) and various sizes of literals and
memory reference operations.  The bytecode interpreter operates
strictly on machine-level values -- various sizes of integers and
floating point numbers -- and requires no information about types or
symbols; thus, the interpreter's internal data structures are simple,
and each bytecode requires only a few native machine instructions to
implement it.  The interpreter is small, and strict limits on the
memory and time required to evaluate an expression are easy to
determine, making it suitable for use by the debugging agent in
real-time applications.

* Menu:

* General Bytecode Design::     Overview of the interpreter.
* Bytecode Descriptions::       What each one does.
* Using Agent Expressions::     How agent expressions fit into the big picture.
* Varying Target Capabilities:: How to discover what the target can do.
* Tracing on Symmetrix::        Special info for implementation on EMC's
                                boxes.
* Rationale::                   Why we did it this way.


File: gdb.info,  Node: General Bytecode Design,  Next: Bytecode Descriptions,  Up: Agent Expressions

General Bytecode Design
=======================

   The agent represents bytecode expressions as an array of bytes.  Each
instruction is one byte long (thus the term "bytecode").  Some
instructions are followed by operand bytes; for example, the `goto'
instruction is followed by a destination for the jump.

   The bytecode interpreter is a stack-based machine; most instructions
pop their operands off the stack, perform some operation, and push the
result back on the stack for the next instruction to consume.  Each
element of the stack may contain either a integer or a floating point
value; these values are as many bits wide as the largest integer that
can be directly manipulated in the source language.  Stack elements
carry no record of their type; bytecode could push a value as an
integer, then pop it as a floating point value.  However, GDB will not
generate code which does this.  In C, one might define the type of a
stack element as follows:
     union agent_val {
       LONGEST l;
       DOUBLEST d;
     };

where `LONGEST' and `DOUBLEST' are `typedef' names for the largest
integer and floating point types on the machine.

   By the time the bytecode interpreter reaches the end of the
expression, the value of the expression should be the only value left
on the stack.  For tracing applications, `trace' bytecodes in the
expression will have recorded the necessary data, and the value on the
stack may be discarded.  For other applications, like conditional
breakpoints, the value may be useful.

   Separate from the stack, the interpreter has two registers:
`pc'
     The address of the next bytecode to execute.

`start'
     The address of the start of the bytecode expression, necessary for
     interpreting the `goto' and `if_goto' instructions.

Neither of these registers is directly visible to the bytecode language
itself, but they are useful for defining the meanings of the bytecode
operations.

   There are no instructions to perform side effects on the running
program, or call the program's functions; we assume that these
expressions are only used for unobtrusive debugging, not for patching
the running code.

   Most bytecode instructions do not distinguish between the various
sizes of values, and operate on full-width values; the upper bits of the
values are simply ignored, since they do not usually make a difference
to the value computed.  The exceptions to this rule are:
memory reference instructions (`ref'N)
     There are distinct instructions to fetch different word sizes from
     memory.  Once on the stack, however, the values are treated as
     full-size integers.  They may need to be sign-extended; the `ext'
     instruction exists for this purpose.

the sign-extension instruction (`ext' N)
     These clearly need to know which portion of their operand is to be
     extended to occupy the full length of the word.

   If the interpreter is unable to evaluate an expression completely for
some reason (a memory location is inaccessible, or a divisor is zero,
for example), we say that interpretation "terminates with an error".
This means that the problem is reported back to the interpreter's caller
in some helpful way.  In general, code using agent expressions should
assume that they may attempt to divide by zero, fetch arbitrary memory
locations, and misbehave in other ways.

   Even complicated C expressions compile to a few bytecode
instructions; for example, the expression `x + y * z' would typically
produce code like the following, assuming that `x' and `y' live in
registers, and `z' is a global variable holding a 32-bit `int':
     reg 1
     reg 2
     const32 address of z
     ref32
     ext 32
     mul
     add
     end

   In detail, these mean:
`reg 1'
     Push the value of register 1 (presumably holding `x') onto the
     stack.

`reg 2'
     Push the value of register 2 (holding `y').

`const32 address of z'
     Push the address of `z' onto the stack.

`ref32'
     Fetch a 32-bit word from the address at the top of the stack;
     replace the address on the stack with the value.  Thus, we replace
     the address of `z' with `z''s value.

`ext 32'
     Sign-extend the value on the top of the stack from 32 bits to full
     length.  This is necessary because `z' is a signed integer.

`mul'
     Pop the top two numbers on the stack, multiply them, and push their
     product.  Now the top of the stack contains the value of the
     expression `y * z'.

`add'
     Pop the top two numbers, add them, and push the sum.  Now the top
     of the stack contains the value of `x + y * z'.

`end'
     Stop executing; the value left on the stack top is the value to be
     recorded.


File: gdb.info,  Node: Bytecode Descriptions,  Next: Using Agent Expressions,  Prev: General Bytecode Design,  Up: Agent Expressions

Bytecode Descriptions
=====================

   Each bytecode description has the following form:

`add' (0x02): A B => A+B
     Pop the top two stack items, A and B, as integers; push their sum,
     as an integer.

   In this example, `add' is the name of the bytecode, and `(0x02)' is
the one-byte value used to encode the bytecode, in hexidecimal.  The
phrase "A B => A+B" shows the stack before and after the bytecode
executes.  Beforehand, the stack must contain at least two values, A
and B; since the top of the stack is to the right, B is on the top of
the stack, and A is underneath it.  After execution, the bytecode will
have popped A and B from the stack, and replaced them with a single
value, A+B.  There may be other values on the stack below those shown,
but the bytecode affects only those shown.

   Here is another example:

`const8' (0x22) N: => N
     Push the 8-bit integer constant N on the stack, without sign
     extension.

   In this example, the bytecode `const8' takes an operand N directly
from the bytecode stream; the operand follows the `const8' bytecode
itself.  We write any such operands immediately after the name of the
bytecode, before the colon, and describe the exact encoding of the
operand in the bytecode stream in the body of the bytecode description.

   For the `const8' bytecode, there are no stack items given before the
=>; this simply means that the bytecode consumes no values from the
stack.  If a bytecode consumes no values, or produces no values, the
list on either side of the => may be empty.

   If a value is written as A, B, or N, then the bytecode treats it as
an integer.  If a value is written is ADDR, then the bytecode treats it
as an address.

   We do not fully describe the floating point operations here; although
this design can be extended in a clean way to handle floating point
values, they are not of immediate interest to the customer, so we avoid
describing them, to save time.

`float' (0x01): =>
     Prefix for floating-point bytecodes.  Not implemented yet.

`add' (0x02): A B => A+B
     Pop two integers from the stack, and push their sum, as an integer.

`sub' (0x03): A B => A-B
     Pop two integers from the stack, subtract the top value from the
     next-to-top value, and push the difference.

`mul' (0x04): A B => A*B
     Pop two integers from the stack, multiply them, and push the
     product on the stack.  Note that, when one multiplies two N-bit
     numbers yielding another N-bit number, it is irrelevant whether the
     numbers are signed or not; the results are the same.

`div_signed' (0x05): A B => A/B
     Pop two signed integers from the stack; divide the next-to-top
     value by the top value, and push the quotient.  If the divisor is
     zero, terminate with an error.

`div_unsigned' (0x06): A B => A/B
     Pop two unsigned integers from the stack; divide the next-to-top
     value by the top value, and push the quotient.  If the divisor is
     zero, terminate with an error.

`rem_signed' (0x07): A B => A MODULO B
     Pop two signed integers from the stack; divide the next-to-top
     value by the top value, and push the remainder.  If the divisor is
     zero, terminate with an error.

`rem_unsigned' (0x08): A B => A MODULO B
     Pop two unsigned integers from the stack; divide the next-to-top
     value by the top value, and push the remainder.  If the divisor is
     zero, terminate with an error.

`lsh' (0x09): A B => A<<B
     Pop two integers from the stack; let A be the next-to-top value,
     and B be the top value.  Shift A left by B bits, and push the
     result.

`rsh_signed' (0x0a): A B => `(signed)'A>>B
     Pop two integers from the stack; let A be the next-to-top value,
     and B be the top value.  Shift A right by B bits, inserting copies
     of the top bit at the high end, and push the result.

`rsh_unsigned' (0x0b): A B => A>>B
     Pop two integers from the stack; let A be the next-to-top value,
     and B be the top value.  Shift A right by B bits, inserting zero
     bits at the high end, and push the result.

`log_not' (0x0e): A => !A
     Pop an integer from the stack; if it is zero, push the value one;
     otherwise, push the value zero.

`bit_and' (0x0f): A B => A&B
     Pop two integers from the stack, and push their bitwise `and'.

`bit_or' (0x10): A B => A|B
     Pop two integers from the stack, and push their bitwise `or'.

`bit_xor' (0x11): A B => A^B
     Pop two integers from the stack, and push their bitwise
     exclusive-`or'.

`bit_not' (0x12): A => ~A
     Pop an integer from the stack, and push its bitwise complement.

`equal' (0x13): A B => A=B
     Pop two integers from the stack; if they are equal, push the value
     one; otherwise, push the value zero.

`less_signed' (0x14): A B => A<B
     Pop two signed integers from the stack; if the next-to-top value
     is less than the top value, push the value one; otherwise, push
     the value zero.

`less_unsigned' (0x15): A B => A<B
     Pop two unsigned integers from the stack; if the next-to-top value
     is less than the top value, push the value one; otherwise, push
     the value zero.

`ext' (0x16) N: A => A, sign-extended from N bits
     Pop an unsigned value from the stack; treating it as an N-bit
     twos-complement value, extend it to full length.  This means that
     all bits to the left of bit N-1 (where the least significant bit
     is bit 0) are set to the value of bit N-1.  Note that N may be
     larger than or equal to the width of the stack elements of the
     bytecode engine; in this case, the bytecode should have no effect.

     The number of source bits to preserve, N, is encoded as a single
     byte unsigned integer following the `ext' bytecode.

`zero_ext' (0x2a) N: A => A, zero-extended from N bits
     Pop an unsigned value from the stack; zero all but the bottom N
     bits.  This means that all bits to the left of bit N-1 (where the
     least significant bit is bit 0) are set to the value of bit N-1.

     The number of source bits to preserve, N, is encoded as a single
     byte unsigned integer following the `zero_ext' bytecode.

`ref8' (0x17): ADDR => A
`ref16' (0x18): ADDR => A
`ref32' (0x19): ADDR => A
`ref64' (0x1a): ADDR => A
     Pop an address ADDR from the stack.  For bytecode `ref'N, fetch an
     N-bit value from ADDR, using the natural target endianness.  Push
     the fetched value as an unsigned integer.

     Note that ADDR may not be aligned in any particular way; the
     `refN' bytecodes should operate correctly for any address.

     If attempting to access memory at ADDR would cause a processor
     exception of some sort, terminate with an error.

`ref_float' (0x1b): ADDR => D
`ref_double' (0x1c): ADDR => D
`ref_long_double' (0x1d): ADDR => D
`l_to_d' (0x1e): A => D
`d_to_l' (0x1f): D => A
     Not implemented yet.

`dup' (0x28): A => A A
     Push another copy of the stack's top element.

`swap' (0x2b): A B => B A
     Exchange the top two items on the stack.

`pop' (0x29): A =>
     Discard the top value on the stack.

`if_goto' (0x20) OFFSET: A =>
     Pop an integer off the stack; if it is non-zero, branch to the
     given offset in the bytecode string.  Otherwise, continue to the
     next instruction in the bytecode stream.  In other words, if A is
     non-zero, set the `pc' register to `start' + OFFSET.  Thus, an
     offset of zero denotes the beginning of the expression.

     The OFFSET is stored as a sixteen-bit unsigned value, stored
     immediately following the `if_goto' bytecode.  It is always stored
     most significant byte first, regardless of the target's normal
     endianness.  The offset is not guaranteed to fall at any particular
     alignment within the bytecode stream; thus, on machines where
     fetching a 16-bit on an unaligned address raises an exception, you
     should fetch the offset one byte at a time.

`goto' (0x21) OFFSET: =>
     Branch unconditionally to OFFSET; in other words, set the `pc'
     register to `start' + OFFSET.

     The offset is stored in the same way as for the `if_goto' bytecode.

`const8' (0x22) N: => N
`const16' (0x23) N: => N
`const32' (0x24) N: => N
`const64' (0x25) N: => N
     Push the integer constant N on the stack, without sign extension.
     To produce a small negative value, push a small twos-complement
     value, and then sign-extend it using the `ext' bytecode.

     The constant N is stored in the appropriate number of bytes
     following the `const'B bytecode.  The constant N is always stored
     most significant byte first, regardless of the target's normal
     endianness.  The constant is not guaranteed to fall at any
     particular alignment within the bytecode stream; thus, on machines
     where fetching a 16-bit on an unaligned address raises an
     exception, you should fetch N one byte at a time.

`reg' (0x26) N: => A
     Push the value of register number N, without sign extension.  The
     registers are numbered following GDB's conventions.

     The register number N is encoded as a 16-bit unsigned integer
     immediately following the `reg' bytecode.  It is always stored most
     significant byte first, regardless of the target's normal
     endianness.  The register number is not guaranteed to fall at any
     particular alignment within the bytecode stream; thus, on machines
     where fetching a 16-bit on an unaligned address raises an
     exception, you should fetch the register number one byte at a time.

`trace' (0x0c): ADDR SIZE =>
     Record the contents of the SIZE bytes at ADDR in a trace buffer,
     for later retrieval by GDB.

`trace_quick' (0x0d) SIZE: ADDR => ADDR
     Record the contents of the SIZE bytes at ADDR in a trace buffer,
     for later retrieval by GDB.  SIZE is a single byte unsigned
     integer following the `trace' opcode.

     This bytecode is equivalent to the sequence `dup const8 SIZE
     trace', but we provide it anyway to save space in bytecode strings.

`trace16' (0x30) SIZE: ADDR => ADDR
     Identical to trace_quick, except that SIZE is a 16-bit big-endian
     unsigned integer, not a single byte.  This should probably have
     been named `trace_quick16', for consistency.

`end' (0x27): =>
     Stop executing bytecode; the result should be the top element of
     the stack.  If the purpose of the expression was to compute an
     lvalue or a range of memory, then the next-to-top of the stack is
     the lvalue's address, and the top of the stack is the lvalue's
     size, in bytes.


File: gdb.info,  Node: Using Agent Expressions,  Next: Varying Target Capabilities,  Prev: Bytecode Descriptions,  Up: Agent Expressions

Using Agent Expressions
=======================

   Here is a sketch of a full non-stop debugging cycle, showing how
agent expressions fit into the process.

   * The user selects trace points in the program's code at which GDB
     should collect data.

   * The user specifies expressions to evaluate at each trace point.
     These expressions may denote objects in memory, in which case
     those objects' contents are recorded as the program runs, or
     computed values, in which case the values themselves are recorded.

   * GDB transmits the tracepoints and their associated expressions to
     the GDB agent, running on the debugging target.

   * The agent arranges to be notified when a trace point is hit.  Note
     that, on some systems, the target operating system is completely
     responsible for collecting the data; see *Note Tracing on
     Symmetrix::.

   * When execution on the target reaches a trace point, the agent
     evaluates the expressions associated with that trace point, and
     records the resulting values and memory ranges.

   * Later, when the user selects a given trace event and inspects the
     objects and expression values recorded, GDB talks to the agent to
     retrieve recorded data as necessary to meet the user's requests.
     If the user asks to see an object whose contents have not been
     recorded, GDB reports an error.



File: gdb.info,  Node: Varying Target Capabilities,  Next: Tracing on Symmetrix,  Prev: Using Agent Expressions,  Up: Agent Expressions

Varying Target Capabilities
===========================

   Some targets don't support floating-point, and some would rather not
have to deal with `long long' operations.  Also, different targets will
have different stack sizes, and different bytecode buffer lengths.

   Thus, GDB needs a way to ask the target about itself.  We haven't
worked out the details yet, but in general, GDB should be able to send
the target a packet asking it to describe itself.  The reply should be a
packet whose length is explicit, so we can add new information to the
packet in future revisions of the agent, without confusing old versions
of GDB, and it should contain a version number.  It should contain at
least the following information:

   * whether floating point is supported

   * whether `long long' is supported

   * maximum acceptable size of bytecode stack

   * maximum acceptable length of bytecode expressions

   * which registers are actually available for collection

   * whether the target supports disabled tracepoints


